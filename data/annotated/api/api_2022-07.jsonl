{"id": "ftcyR4", "name": "Fork 2d-Primiti clonedpupp 194", "author": "ClonedPuppy", "description": "Corrected test frame for animated 2d primitives and different 2d & 3d backgrounds. \nChange background animation by pressing mouse button at different x positions. \nY position of mouse changes the background speed and direction.\nIs this shader useful 4 u ?", "tags": ["2d", "line", "circle", "primitives", "rectangle", "disc", "frame", "backgrounds"], "likes": 1, "viewed": 221, "published": 3, "date": "1659297205", "time_retrieved": "2024-07-30T16:37:36.743855", "image_code": "\n//---------------------------------------------------------\n// Shader: 2dPrimitives.glsl by gPlatl\n//         v1.0  2015-09-13  initial release\n//         v1.1  2016-02-14  added primitives\n//         v1.2  2016-03-30  circleBox added\n//         v1.3  2016-08-15  line & line segment added\n//         v1.4  2016-09-09  circle2 & ring2 added\n//         v1.5  2017-03-05  code corrections\n//         v1.6  2017-03-15  donjon tunnel added\n//         v1.7  2017-10-29  rotateCCW added\n//               2018-12-17  working on...  \n// Tags:   2d, primitives, line, disc, circle, rectangle, frame, backgrounds \n// Test frame for animated 2d primitives and different 2d & 3d backgrounds.\n// Change background by pressing mouse button on different x positions.\n// Y position of mouse changes the background speed and direction.\n// Note:     Will be enhanced from time to time...\n// see also: http://glslsandbox.com/e#26010\n//           https://www.shadertoy.com/view/XtjGzt\n//           https://www.shadertoy.com/view/lsy3zz\n//           https://iquilezles.org/articles/distfunctions2d\n//---------------------------------------------------------\n\nconst float HALF_PI = 1.57079632679;\nconst float      PI = 3.14159265359;\nconst float  TWO_PI = 6.28318530718;\n\nvec2 uv = vec2(0);  // centered pixel position -1 .. 1\n\n#define BACKGROUNDS 7\n\n//---------------------------------------------------------\n// get moving background texture\n//---------------------------------------------------------\n#define TILES_COUNT_X 4.0\n#define TILES_COUNT_Y 3.0\nvec3 BackgroundColor (vec2 position, sampler2D tilesTexture, vec2 resolution)\n{\n  //vec2 p = TILES_COUNT_X * position.xy / resolution.x;\n  vec2 p = TILES_COUNT_Y * position.xy / resolution.y;\n  return texture (tilesTexture, p).xyz;\n}\n//---------------------------------------------------------\n// get pseudo 3d bump background\n//---------------------------------------------------------\nvec3 BumpyBackground (vec2 pos, sampler2D aTexture, float time)\n{\n  #define ANIMATE_TEXTURE true\n  #define LINEAR_STEPS 20.0\n  #define DISTANCE 0.16\n  #define FEATURES 0.5\n\n  vec3 color;\n  vec2 dir = 0.6*vec2(pos - vec2(0.5, 0.5)) * (DISTANCE / LINEAR_STEPS);\n  if (ANIMATE_TEXTURE)\n    pos += time * vec2(0.3, 1e-5* sin(time));\n    \n  for (float i = 1.0; i < LINEAR_STEPS; i++) \n  {\n    vec3 pixel1 = texture(aTexture, pos - i * dir).xyz;\n      \n      \n    if (pow(length(pixel1) / 1.4, 0.20) * (1.0 - FEATURES)\n       +pow(length(texture(aTexture, (pos - i * dir) * 2.0).rgb) / 1.4, 0.90) * FEATURES\n       > i / LINEAR_STEPS) \n    color = pixel1 * i / LINEAR_STEPS;\n    //color += 0.16 * pixel1 * i / LINEAR_STEPS;\n  }\n  return color;\n}\n//---------------------------------------------------------\n// perspective ground texture\n//---------------------------------------------------------\nvec3 BaseGround (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  vec3 camera = vec3(atime, 1.0, atime);\n  vec3 raydelta = vec3(sin(pos.x)\n                      ,abs(sin(pos.y)-0.88)\n                      ,cos(pos.x));\n  vec3 mapped = raydelta * (camera.y / raydelta.y) + camera;\n  vec3 col = vec3(texture( tilesTexture, mapped.xz ));\n//  col *= abs(pos.y - 1.0);  // darkness based on the horizon\n  return col;\n}\n//---------------------------------------------------------\n// pipe tunnel with 1 texture\n//---------------------------------------------------------\nvec3 PipeTunnel (vec2 pos, sampler2D tilesTexture, float atime)\n{\n  float a = atan(pos.y, pos.x) / HALF_PI;\n  float r = sqrt(dot(pos, pos));\n  vec2 k = mod(vec2(atime + 1.0 / r, a), 1.0);\n  return r * texture(tilesTexture, k).xyz;\n}\n//---------------------------------------------------------\n// donjon tunnel with 2 textures\n//---------------------------------------------------------\nvec4 DonjonTunnel(vec2 p, float aTime)\n{\n    // p.y += sin(aTime) * 0.15;   // up/down\n    float a = atan(p.x,p.y) / HALF_PI;\n    p.x = abs(p.x);\n    float d = max(max(p.x,abs(p.y)), min(p.x+p.y, length(p)));\n    vec2 k = vec2(a, 1.2/d + aTime);  \n    if (d > p.x && (d > p.x+p.y))\n      return texture(iChannel3, k) * d;    // ground\n    return texture(iChannel0, k) * d;      // wall\n}\n//---------------------------------------------------------\n// square tunnel with 3 textures\n//---------------------------------------------------------\nvec3 SquareTunnel(vec2 p, float atime)\n{\n  float r = pow(pow(p.x*p.x,6.0) + pow(p.y*p.y,6.0), 1.0/16.0);\n  vec2 pp = 2.0 * vec2 (atime + 1.0/r, atan(p.y,p.x)/3.1416);\n\t\n  vec3 col = vec3(0);\n  if (p.y > 0.0)\n    col = texture(iChannel1, pp).rgb; \n  else col = texture(iChannel0, pp).rgb;\n  col = mix( col, texture(iChannel2, pp).rgb, smoothstep(0.9,1.1,abs(p.x/p.y) ) );\n  return vec3( col*r);\n}\n\n\n//=== 2d geometric primitives ===\n\n// y position ranges from -1.0 .. +1.0\n\n// functions return intensity (0.0 .. 1.0) with antialiased edges\n\n//---------------------------------------------------------\n// draw endless line through point A and B with radius r\n//---------------------------------------------------------\nfloat line(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n  return smoothstep(r, 0.5*r, d);\n}\n\n//---------------------------------------------------------\n// draw segment line from point A to point B and radius r\n// see also sdCapsule(p,a,b,r) from inigo quilez\n// https://iquilezles.org/articles/distfunctions\n//---------------------------------------------------------\nfloat segment(vec2 P, vec2 A, vec2 B, float r)\n{\n  vec2 g = B - A;\n  vec2 h = P - A;\n  float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n  return smoothstep(r, 0.5*r, d);\n}\n//---------------------------------------------------------\nfloat segment2(vec2 P, vec2 A, vec2 B, float r)\n{\n  float d = length((P-=A)-(B-=A)*clamp(dot(P,B)/dot(B,B), 0.0, 1.0 ));\n  return smoothstep(r, 0.5*r, d);;   \n}\n\n//---------------------------------------------------------\n// draw rectangle at pos(-1..+1) with given size\n//---------------------------------------------------------\nfloat rectangle(vec2 pos, vec2 size)\n{\n  size *= 0.5;\n  vec2 r = abs(uv - pos - size) - size;\n  return step( max(r.x,r.y),0.0);\n}\n//---------------------------------------------------------\n// draw rectangle at pos with given size\n//---------------------------------------------------------\nfloat rectangle2(vec2 pos, vec2 size)\n{\n  return (step(pos.x, uv.x)         - step(pos.x + size.x,uv.x))\n       * (step(pos.y - size.y,uv.y) - step(pos.y, uv.y));\n}\n//---------------------------------------------------------\n// draw rounded rectangle\n//---------------------------------------------------------\nfloat roundedRectangle (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.66, 0.33, d / thickness * 5.0);\n}\n//---------------------------------------------------------\n// draw rectangle frame with rounded edges\n//---------------------------------------------------------\nfloat roundedFrame (vec2 pos, vec2 size, float radius, float thickness)\n{\n  float d = length(max(abs(uv - pos),size) - size) - radius;\n  return smoothstep(0.55, 0.45, abs(d / thickness) * 5.0);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius)\n{\n    float d = length(uv-pos);\n    return smoothstep(d,d+0.01,radius);\n}\n//---------------------------------------------------------\n// draw circle at pos with given radius and halo\n//---------------------------------------------------------\nfloat circle(vec2 pos, float radius, float halo)\n{\n  return clamp (halo * (radius - length(uv-pos)), 0.0, 1.0);\n}\n//---------------------------------------------------------\nfloat circle2(vec2 pos, float radius, float halo)\n{\n  return clamp(((1.0-(length(uv-pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\n//---------------------------------------------------------\n// interpolation between a circle and a box with rounded corner\n//---------------------------------------------------------\nfloat circleBox(vec2 pos            // position\n               ,vec2 size           // shape size\n               ,float cornerRadius  // radius of rounded box corner\n               ,float between)      // interpolation value: 0.0 .. 1.0\n{\n  float sd = (length(uv-pos) - size.x); // circle\n  size -= vec2(cornerRadius);           // rounded box\n  vec2 d = (abs(uv-pos) - size);\n  float box = min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - cornerRadius;\n  float v = (1.0 - between)*sd + box*between;  //mix\n  return clamp (-88.0*v , 0.0, 1.0);\n}\n\n//---------------------------------------------------------\n// return 2d rotation matrix\n//---------------------------------------------------------\nmat2 rotate2D(float angle)\n{\n  float c = cos(angle), s = sin(angle);\n  return mat2(c, s, -s, c);\n}\n//---------------------------------------------------------\n// return point p rotated with given angle\n//---------------------------------------------------------\nvec2 rotateCCW (vec2 pos, float angle)\n{ \n  float ca = cos(angle),  sa = sin(angle);\n  return pos * mat2(ca, sa, -sa, ca);  \n}\n\n//---------------------------------------------------------\n// squircle: a variable shape (star..rectangle..circle)\n// http://en.wikipedia.org/wiki/Squircle\n//---------------------------------------------------------\nfloat squircle(vec2 pos, float radius, float power)\n{\n  vec2 p = abs(pos - uv) / radius;\n  float d = (pow(p.x,power) + pow(p.y, power) - pow(radius, power)) -1.0;\n  return 1.0 - clamp (16.0*d, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw ring at given position\n//---------------------------------------------------------\nfloat ring(vec2 pos, float radius, float thick)\n{\n  return mix(1.0, 0.0, smoothstep(thick, thick + 0.01, abs(length(uv-pos) - radius)));\n}\n//---------------------------------------------------------\nfloat ring2(vec2 pos, float radius, float thick)\n{\n  return clamp((thick-abs(length(uv-pos) - radius))*100.0, 0.0, 1.0); \n}\n//---------------------------------------------------------\n// draw ring at pos \n//---------------------------------------------------------\nfloat haloRing(vec2 pos, float radius, float thick)\n{\n  return clamp(-(abs(length(uv-pos) - radius) * 100.0 / thick) + 0.9, 0.0, 1.0);\n}\n//---------------------------------------------------------\n// draw polygon with n edges at pos \n//---------------------------------------------------------\nfloat polygon(vec2 pos, float n, float radius)\n{\n  vec2 p = pos;\n  float angle = atan(p.x, p.y) + PI;\n  float r = TWO_PI / n;\n  float d = cos(floor(0.5 + angle / r) * r - angle) * length(p) / radius;\n  return smoothstep(0.41,0.4,d);\n}\n\n//---------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  float time = iTime;\n  vec2 pos, size;\n  vec2 npos = fragCoord.xy / iResolution.xy;   // 0.0 .. 1.0\n  \n  // get uv position with origin at window center\n  float aspect = iResolution.x / iResolution.y;   // aspect ratio x/y\n  vec2 ratio = vec2(aspect, 1.0);                 // aspect ratio (x/y,1)     \n  uv = (2.0 * npos - 1.0) * ratio;             // -1.0 .. 1.0\n    \n  vec2 mpos = iMouse.xy / iResolution.xy;      //  0.0 .. 1.0\n  vec2 mp = (2.0 * mpos - 1.0) * ratio;        // -1.0 .. 1.0  \n  float speed = (mpos.y - 0.4) * time;    \n    \n  vec3 col;\n  int selection = int((iMouse.x / iResolution.x) * float(BACKGROUNDS));\n    \n  if      (selection == 6)   \n    col = BackgroundColor(fragCoord, iChannel0, iResolution.xy);\n    \n  else if (selection == 5)\n    col = BackgroundColor(fragCoord+vec2(-180.0*speed,0.0), iChannel0, iResolution.xy);\n      \n  else if (selection == 4)\n    col = BumpyBackground (uv, iChannel2, 4.0 * speed);\n\n  else if (selection == 3)\n    col = BaseGround(npos, iChannel1, speed);\n\n  else if (selection == 2)\n    col = PipeTunnel(uv, iChannel1, speed);\n     \n  else if (selection == 1)\n    col = DonjonTunnel (uv, speed).rgb;\n\n  else\n    col = SquareTunnel(uv, speed);\n\n  float intensity = 0.0;\n      \n  //--- line --- \n  pos = vec2(-0.5*sin(time), 0.0);\n  const vec3 lineColor1 = vec3(0.1, 0.4, 0.7);\n  intensity = line (uv, pos, mp, 0.016);\n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor1, intensity);\n    \n  //--- line segment --- \n  const vec3 lineColor2 = vec3(0.9, 0.9, 0.2);\n  intensity = segment (uv, pos, mp, 0.02);     \n  if ((intensity > 0.0) && (intensity <= 1.0))\n    col = mix(col, lineColor2, intensity);\n    \n  //--- green rectangle ---\n  const vec3 rectangleColor = vec3(0.2, 0.8, 0.5);\n  intensity = 0.6 * rectangle (vec2(sin(time),-0.9),vec2(0.5, 0.1));\n  col = mix(col, rectangleColor.rgb, intensity);\n\n  //--- rounded rectangle ---\n  const vec3 rectColor = vec3(0.1, 0.8, 0.5);\n  pos = vec2(-sin(time), 0.6);\n  size = vec2(0.16, 0.02);\n  intensity = 0.6 * roundedRectangle (pos, size, 0.1, 0.2);\n  col = mix(col, rectColor, intensity);\n    \n  //--- rounded frame ---\n  const vec3 frameColor = vec3(0.5, 0.3, 0.6);\n  size = vec2(0.28, 0.10);\n  intensity = roundedFrame (pos, size, 0.08, 0.2);\n  col = mix(col, frameColor, intensity);\n    \n  //--- red dot ---\n  const vec3 circleColor2 = vec3(0.6, 0.2, 0.2);\n  vec2 redPos = vec2(-0.5*sin(time), 0.0);\n  intensity = circle(redPos, 0.05, 100.0);\n  col = mix(col, circleColor2, intensity);\n\n  //--- mouse dot ---\n  if (iMouse.z > 0.0)\n  {\n    const vec3 circleColorM = vec3(1.6, 1.2, 0.6);\n    intensity = circle(mp, 0.05, 100.0);\n    col = mix(col, circleColorM, intensity);\n  }\n\n  //--- yellow circle ---\n  const vec3 circleColor = vec3(1, 0.8, 0.3);\n  intensity = circle(vec2(sin(time), 0.6), 0.2);\n  //intensity = circle(vec2(sin(time), 0.6), 0.2, 6.);\n  col = mix(col, circleColor, intensity);\n\n  //--- violet circleBox ---\n  const vec3 cbColor = vec3(0.5, 0.3, 0.8);\n  pos = vec2(-sin(time), -0.6);\n  float between = 0.5+0.5*sin(time);  // mix value\n  size = vec2(0.15, 0.10);\n  intensity = 0.8 * circleBox(pos, size, 0.02, between);\n  col = mix(col, cbColor, intensity);\n  \n  //--- brown squircle ---\n  const vec3 sqColor = vec3(0.8, 0.5, 0.3);\n  pos = vec2(1.3, 0.6*sin(time+HALF_PI));\n  float power = 0.8 + 2.0*(1.0+sin(time));\n  intensity = 0.9 * squircle (pos, 0.1, power);\n  if (intensity > 0.0) \n    col = mix(col, sqColor, intensity);\n  \n  //--- pink ring ---\n  vec3 ringColor = vec3(0.9, 0.4, 0.6);\n  pos = vec2(0.5*sin(time), 0.0);\n  intensity = ring2(pos, 0.2 +0.05*sin(time), 0.04);\n  if (intensity > 0.0) \n    col = mix(col, ringColor, intensity);\n  \n  //--- haloRing ---\n  ringColor = vec3(1.0, 1.0, 1.5);\n  intensity = haloRing (vec2(-sin(time), 0.0), 0.3, 6.0);\n  col = mix(col, ringColor, intensity);\n  \n  //--- polygon ---\n  const vec3 polygonColor = vec3(0.5, 0.9, 0.3);\n  pos = vec2(sin(time), -0.5);\n  pos = rotateCCW(uv - pos,time);\n  float n = floor (6.0 + 3.0 * sin(time));\n  intensity = 0.8 * polygon(pos,n, 0.4);\n  col = mix(col, polygonColor.rgb, intensity);\n    \n  fragColor = vec4 (col, 1.0);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftcyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1535, 1535, 1614, 1671, 1768], [1769, 1922, 1987, 1987, 2661], [2662, 2812, 2877, 2877, 3227], [3228, 3378, 3443, 3443, 3610], [3611, 3764, 3804, 3850, 4151], [4152, 4305, 4345, 4345, 4700], [4845, 5022, 5067, 5067, 5178], [5180, 5456, 5504, 5504, 5643], [5644, 5704, 5753, 5753, 5864], [5866, 6035, 6073, 6073, 6164], [6165, 6326, 6365, 6365, 6490], [6491, 6637, 6714, 6714, 6831], [6832, 6995, 7068, 7068, 7190], [7191, 7351, 7389, 7389, 7461], [7462, 7631, 7681, 7681, 7744], [7745, 7805, 7856, 7856, 7931], [7933, 8117, 8355, 8355, 8661], [8663, 8812, 8840, 8840, 8910], [8911, 9074, 9114, 9114, 9200], [9202, 9419, 9472, 9472, 9624], [9625, 9776, 9825, 9825, 9914], [9915, 9975, 10025, 10025, 10098], [10099, 10240, 10293, 10293, 10376], [10377, 10534, 10582, 10582, 10768], [10770, 10830, 10887, 10887, 15044]], "test": "untested"}
{"id": "7ldyRH", "name": "infinite nested block", "author": "FabriceNeyret2", "description": "inspired by reference:  https://twitter.com/kineticgraphics/status/1537861671296741376", "tags": ["raymarching", "short", "reproduction"], "likes": 28, "viewed": 391, "published": 3, "date": "1659294232", "time_retrieved": "2024-07-30T16:37:37.593584", "image_code": "#define rot(a)       mat2(cos(a+vec4(0,-1.57,1.57,0)))     // rotation \n#define C(q)         max( q.x, max(q.y,q.z) )\n#define B(d,y,k,p)   r = abs( q+ vec3(6, y, 2.+4.*min(d,T-k)).p ), t = min(t, C(r) -2. )  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., T = mod(iTime,8.); \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),           // ray direction\n          p = vec3(0,0,20), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? .5*(iMouse.xyz/R -.5)\n              :  0.*vec3( 10,4,0)/1e2 * cos(iTime + vec3(0,11,0)); \n    p *= exp2(-T/8.);                                      // zoom\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.xy *= rot(.5*iTime),\n        q.yz *= rot(.78-6.*M.y),                           // rotations\n        q.xz *= rot(.78-6.*M.x), \n        t = C(q),                                          // main cube\n     // a = 8.-abs(q), t = max(t, -C(-a) ),                // hollow cube\n        t = max(t, -C(-8.-q)),                             // pyBlob simplif\n        B(1.,6.,2.,xyz),                                   // flying bricks\n        B(0.,6.,3.,yzx), \n        B(0.,6.,4.,zxy), \n        B(0.,6.,5.,xyz), \n        B(0.,2.,6.,yzx), \n        B(0.,2.,7.,zxy), \n        B(0.,2.,8.,xyz), \n        p += .5*t*D;                                       // step forward = dist to obj          \n\n // O = texture(iChannel0, .1*(t==q.x||t==a.x ? q.yz : t==q.y||t==a.y ? q.xz : q.xy) ).rrrr;\n // O *= t==q.x||t==a.x ? .5 : t==q.y||t==a.y ? .7 : 1.;\n    O *= O * 1.5 *exp2(-fract(T/8.)/5.) ;\n}\n\n\n\n\n\n/** // --- version adapted from pyBlob fixes. https://www.shadertoy.com/view/NtdyRN\n    // but restoring the block speed ( del 5.* in B() ) breaks the luminance continuity\n    // plus the faces are \"too identical\" while for strange reason it wasn't the case before. \n\n\n#define rot(a)       mat2(cos(a+vec4(0,-1.57,1.57,0)))     // rotation \n#define C(q)         max( q.x, max(q.y,q.z) )\n#define B(d,y,k,p)   r = abs( q+ vec3(6, y, 2.+4.*min(d,5.*(T-k))).p ), t = min(t, C(r) -2. )  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., T = mod(iTime,8.); \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),           // ray direction\n          p = vec3(11.5), q, a, r,                         // marching point along ray\n          M = iMouse.z > 0. ? .5*(iMouse.xyz/R -.5)\n              :  0.*vec3( 10,4,0)/1e2 * cos(iTime + vec3(0,11,0)); \n    p *= exp2(-T/8.);                                      // zoom\n    D.xy *= rot(.5*iTime),\n    D.yz *= rot(-.6*M.y+.60),                              // rotations\n    D.xz *= rot(-.6*M.x+.78); \n    for\n      ( O=vec4(1)\n      ; O.x > 0. &&  t > .01 * exp2(-T/8.) // adjust cutoff for \"t\" based on zoom (depending on chosen ray origin, best factor may vary between 7..8)\n      ; O-=.01\n      )                                                    // march scene\n        q = p,\n      //t = C(q), a = 8.-abs(q), t = max(t, -C(-a) ),      // hollow cube\n        a = q + 8. * step(q, min(q.yzx, q.zxy)), t = C(a), // corner sdf\n        B(1.,6.,2.,xyz),                                   // flying bricks\n        B(0.,6.,3.,yzx), \n        B(0.,6.,4.,zxy), \n        B(0.,6.,5.,xyz), \n        B(0.,2.,6.,yzx), \n        B(0.,2.,7.,zxy), \n        B(0.,2.,8.,xyz),\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n // O = texture(iChannel0, .1*(t==q.x||t==a.x ? q.yz : t==q.y||t==a.y ? q.xz : q.xy) ).rrrr;\n // O *= t==q.x||t==a.x ? .5 : t==q.y||t==a.y ? .7 : 1.;\n    O *= O*O*1.7;\n // O = 1.9*exp(-4.*(1.-O));\n}\n\n/**/", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 246, 246, 1635]], "test": "untested"}
{"id": "7ldcRH", "name": "Pretty Modulated", "author": "gurudevbk", "description": "Modified some parameters from Pretty Hip  (https://www.shadertoy.com/view/XsBfRW) ", "tags": ["2d", "cineshader"], "likes": 12, "viewed": 4193, "published": 3, "date": "1659292287", "time_retrieved": "2024-07-30T16:37:38.665224", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float aspect = iResolution.y/iResolution.x; //aspect ratio of viewport\n    float value; //var\n\tvec2 uv = fragCoord.xy / iResolution.x; //vec ratio of fragment coordinate to width of viewport\n \n    \n    float rot = radians(45.0); // radians(45.0*sin(iTime)); //radians(45.0)\n    float rot2 = radians(45.0*sin(iTime)); // radians(45.0*sin(iTime)); //radians(45.0)\n    \n    uv -= vec2(0.5, 0.5*aspect); //transform\n\n\n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \tuv  = m * uv;\n    uv += vec2(0.5, 0.5*aspect);\n    uv.y+=0.5*(1.0-aspect);\n    vec2 pos = 20.0*uv;\n    vec2 rep = fract(cos(rot2)-0.5*tan(rot2)+cos(rot2/2.0)*pos);\n    float dist = min(min(rep.x, 1.0-rep.x), min(rep.y, 1.0-rep.y));\n    float squareDist = length((floor(pos)+vec2(0.5)) - vec2(5.0) );\n    \n    float edge = sin(iTime-squareDist*0.5)*0.5+0.5;\n    \n    edge = (iTime-squareDist*0.5)*0.5+cos(rot2);\n    edge = 2.0*fract(edge*0.5);\n    //value = 2.0*abs(dist-0.5);\n    //value = pow(dist, 2.0);\n    value = fract (dist*2.0);\n    value = mix(value, 1.0-value, step(1.0, edge));\n    //value *= 1.0-0.5*edge;\n    edge = pow(abs(1.0-edge), 2.0);\n    \n    //edge = abs(1.0-edge);\n    value = smoothstep( edge-0.05, edge, 0.95*value);\n    \n    \n    value += squareDist*.1;\n    //fragColor = vec4(value);\n    fragColor = mix(vec4(1.0,1.0,1.0,1.0)*(tan(rot2)/1.0),vec4(0.5,0.75,1.0,1.0), value);\n    fragColor.a = 0.25*clamp(value, 0.0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ldcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1487]], "test": "untested"}
{"id": "stdyRH", "name": "SPEED DMODE", "author": "u004fu0077u004f", "description": "It displays text, but with fancy lines. This isn't really my best text renderer; I just made this as a joke. Use it however you see fit, except the 'line' function which I stole.", "tags": ["text", "fonts"], "likes": 2, "viewed": 258, "published": 3, "date": "1659289759", "time_retrieved": "2024-07-30T16:37:39.548862", "image_code": "const float line_thickness = .01;\nconst vec3 line_color = vec3(.956, .584, .137);\nvoid line(inout vec4 color, vec2 uv, vec2 a, vec2 b) {\n    // Code stolen from rkibria's \"Wireframe cube\", because I suck at math.\n    // <https://www.shadertoy.com/view/4lfBWf>\n    uv -= a;\n    b -= a;\n    color.rgb = mix(color.rgb, line_color, 1.-smoothstep(0., 1., length(uv-b*clamp(dot(b, uv)/dot(b, b), 0., 1.))/line_thickness));\n}\nvec2 text_pos;\nfloat text_x;\nvoid set_text_pos(vec2 pos) {\n    text_pos = pos;\n    text_x = pos.x;\n}\nconst vec2 character_size = vec2(.0475, .1);\nconst vec2 character_padding = character_size*.36;\n#define L(ax, ay, bx, by) line(color, uv, vec2(ax, ay)*character_size+text_pos, vec2(bx, by)*character_size+text_pos)\nvoid C(inout vec4 color, vec2 uv, uint character) {\n    switch (character) {\n        case 0x00u: // NULL\n            return;\n        case 0x0au: // LINE FEED\n            text_pos.x = text_x;\n            text_pos.y -= character_size.y+character_padding.y;\n            return;\n        case 0x20u: // SPACE (\" \")\n            break;\n        case 0x2cu: // COMMA (\",\")\n            L(.5, .333, 0., 0.);\n            break;\n        case 0x41u: // LATIN CAPITAL LETTER A (\"A\")\n            L(0., 0., 0., .667);\n            L(0., .667, .5, 1.);\n            L(.5, 1., 1., .667);\n            L(1., .667, 1., 0.);\n            L(0., .333, 1., .333);\n            break;\n        case 0x43u: // LATIN CAPITAL LETTER C (\"C\")\n            L(1., 1., 0., 1.);\n            L(0., 1., 0., 0.);\n            L(0., 0., 1., 0.);\n            break;\n        case 0x44u: // LATIN CAPITAL LETTER D (\"D\")\n            L(0., 1., 0., 0.);\n            L(0., 1., .5, 1.);\n            L(.5, 1., 1., .667);\n            L(1., .667, 1., .333);\n            L(1., .333, .5, 0.);\n            L(.5, 0., 0., 0.);\n            break;\n        case 0x45u: // LATIN CAPITAL LETTER E (\"E\")\n            L(0., 0., 0., 1.);\n            L(0., 1., 1., 1.);\n            L(0., .5, 1., .5);\n            L(0., 0., 1., 0.);\n            break;\n        case 0x46u: // LATIN CAPITAL LETTER F (\"F\")\n            L(0., 0., 0., 1.);\n            L(0., 1., 1., 1.);\n            L(0., .5, 1., .5);\n            break;\n        case 0x47u: // LATIN CAPITAL LETTER G (\"G\")\n            L(1., 1., 0., 1.);\n            L(0., 1., 0., 0.);\n            L(0., 0., 1., 0.);\n            L(1., 0., 1., .5);\n            L(1., .5, .5, .5);\n            break;\n        case 0x48u: // LATIN CAPITAL LETTER H (\"H\")\n            L(0., 1., 0., 0.);\n            L(0., .5, 1., .5);\n            L(1., 1., 1., 0.);\n            break;\n        case 0x49u: // LATIN CAPITAL LETTER I (\"I\")\n            L(0., 1., 1., 1.);\n            L(0., 0., 1., 0.);\n            L(.5, 1., .5, 0.);\n            break;\n        case 0x4bu: // LATIN CAPITAL LETTER K (\"K\")\n            L(0., 1., 0., 0.);\n            L(0., .5, 1., 1.);\n            L(0., .5, 1., 0.);\n            break;\n        case 0x4cu: // LATIN CAPITAL LETTER L (\"L\")\n            L(0., 1., 0., 0.);\n            L(0., 0., 1., 0.);\n            break;\n        case 0x4du: // LATIN CAPITAL LETTER M (\"M\")\n            L(0., 0., 0., 1.);\n            L(0., 1., .5, .667);\n            L(.5, .667, 1., 1.);\n            L(1., 1., 1., 0.);\n            break;\n        case 0x4eu: // LATIN CAPITAL LETTER N (\"N\")\n            L(0., 0., 0., 1.);\n            L(0., 1., 1., 0.);\n            L(1., 0., 1., 1.);\n            break;\n        case 0x4fu: // LATIN CAPITAL LETTER O (\"O\")\n            L(0., 0., 1., 0.);\n            L(1., 0., 1., 1.);\n            L(1., 1., 0., 1.);\n            L(0., 1., 0., 0.);\n            break;\n        case 0x50u: // LATIN CAPITAL LETTER P (\"P\")\n            L(0., 0., 0., 1.);\n            L(0., 1., 1., 1.);\n            L(1., 1., 1., .5);\n            L(1., .5, 0., .5);\n            break;\n        case 0x52u: // LATIN CAPITAL LETTER R (\"R\")\n            L(0., 0., 0., 1.);\n            L(0., 1., 1., 1.);\n            L(1., 1., 1., .5);\n            L(1., .5, 0., .5);\n            L(0., .5, 1., 0.);\n            break;\n        case 0x53u: // LATIN CAPITAL LETTER S (\"S\")\n            L(0., 0., 1., 0.);\n            L(1., 0., 1., .5);\n            L(1., .5, 0., .5);\n            L(0., .5, 0., 1.);\n            L(0., 1., 1., 1.);\n            break;\n        case 0x54u: // LATIN CAPITAL LETTER T (\"T\")\n            L(0., 1., 1., 1.);\n            L(.5, 1., .5, 0.);\n            break;\n        case 0x55u: // LATIN CAPITAL LETTER U (\"U\")\n            L(0., 0., 1., 0.);\n            L(1., 0., 1., 1.);\n            L(0., 1., 0., 0.);\n            break;\n        case 0x56u: // LATIN CAPITAL LETTER V (\"V\")\n            L(0., 1., .5, 0.);\n            L(1., 1., .5, 0.);\n            break;\n        case 0x58u: // LATIN CAPITAL LETTER X (\"X\")\n            L(0., 0., 1., 1.);\n            L(1., 0., 0., 1.);\n            break;\n        case 0x59u: // LATIN CAPITAL LETTER V (\"V\")\n            L(0., 1., .5, .667);\n            L(1., 1., .5, .667);\n            L(.5, .667, .5, 0.);\n            break;\n        case 0xfffdu: // REPLACEMENT CHARACTER (\"ï¿½\")\n        default:\n            L(0., 0., 1., 0.);\n            L(1., 0., 1., 1.);\n            L(1., 1., 0., 1.);\n            L(0., 1., 0., 0.);\n            L(0., 0., 1., 1.);\n            L(1., 0., 0., 1.);\n            break;\n    }\n    text_pos.x += character_size.x+character_padding.x;\n}\n#define C(c) C(color, uv, c)\n#define Q(c) {\\\n    C((uint(c) & 0xff000000u) >> 24);\\\n    C((uint(c) & 0xff0000u) >> 16);\\\n    C((uint(c) & 0xff00u) >> 8);\\\n    C(uint(c) & 0xffu);\\\n};\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    color = vec4(mix(vec3(.137, .129, .129), vec3(.321, .317, .337), uv.y), 1.);\n    set_text_pos(vec2(.025, 1.-character_size.y-.025));\n    Q(0x46524f4d)Q(0x20495659)Q(0x2c204f55)Q(0x540a4d49)Q(0x44444c45)Q(0x2c205448) // \"FROM IVY, OUT\\nMIDDLE, TH\"\n    Q(0x524f5547)Q(0x480a4f55)Q(0x5220434f)Q(0x4e4e4543)Q(0x544f522c)Q(0x0a4c494b) // \"ROUGH\\nOUR CONNECTOR,\\nLIK\"\n    Q(0x4520410a)Q(0x53504545)Q(0x44204445)Q(0x4d4f4e00) // \"E A\\nSPEED DEMON\"\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stdyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 136, 259, 418], [448, 448, 477, 477, 519], [734, 734, 785, 785, 5305]], "test": "untested"}
{"id": "NldczH", "name": "impossible ring 2", "author": "FabriceNeyret2", "description": "reference: https://twitter.com/DrGBuckingham/status/1543335895700750336\n", "tags": ["raymarching", "illusion", "short", "reproduction", "multicamera"], "likes": 40, "viewed": 442, "published": 3, "date": "1659287024", "time_retrieved": "2024-07-30T16:37:40.351715", "image_code": "// shorter version below.\n\n// --- 441 chars\n\n\n#define rot(a)       mat2(cos(a+vec4(0,-1.57,1.57,0)))     // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n     vec3  R = iResolution;\n    float t=9., y = 2.*U.y/R.y-1.; \n    vec3  D = normalize(vec3(U+U, -1e3*R.y) - R),          // ray direction\n          p = vec3(0,0,7e3), q,                            // marching point along ray \n          M = iMouse.z > 0. ? .5*(iMouse.xyz/R -.5)\n               :  vec3( sign(y)/7.64,0,0);                 // swap camera direction at mid-height\n            // :  vec3( y/4.,0,0) * cos(vec3(0,11,0)); \n            // :  vec3( (acos(y)/3.14-.5)/2. ,0,0) * cos(vec3(0,11,0)); \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)           // march scene\n        q = p,\n        q.yz *= rot(-6.*M.y),                              // rotations\n        q.xz *= rot(-6.*M.x), \n        t = max( abs(length(q.xy)-5.), abs(q.z) ) -1.,     // square-torus\n        y = 12.*atan(q.y,q.x)/6.28 + iTime,\n        t = max(t, abs(fract(y)-.5)-.4 ),                  // bricks\n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O*1.75;\n}\n\n\n\n\n\n\n/** // --- 368 chars by Xor\n\n#define r      mat2(cos(vec4(0,-1.57,1.57,0)-6.*M          // rotation                  \n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          t = R,\n          p = (vec3(U+U,-1e3)-R)/R.yyz*7., q,              // marching point along ray \n          M = iMouse.z > 0. ? .5*(iMouse.xyz/R -.5)\n               :  vec3( sign(-p.y)/7.6,0,0);               // swap camera direction at mid-height\n    for (O=vec4(1); O.x > 0. && t.z > .01; O-=.01)         // march scene\n        q = p,\n        q.yz *= r.y)),                                     // rotations\n        q.xz *= r.x)), \n        t = max(max(abs(q), abs(length(q.xy)-5.) ) -1., abs(fract(1.91*atan(q.y,q.x) + iTime)-.5)-.4 ),                  // bricks\n        p.z += .5*t.z;                                     // step forward = dist to obj          \n\n   O *= O * 1.75;\n}\n\n/**/\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NldczH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[136, 136, 172, 172, 1177]], "test": "untested"}
{"id": "fttyR8", "name": "Day 955", "author": "jeyko", "description": "potato  ", "tags": ["mdtmjvm"], "likes": 39, "viewed": 649, "published": 3, "date": "1659286048", "time_retrieved": "2024-07-30T16:37:41.804829", "image_code": "// Fork of \"Day 802\" by jeyko. https://shadertoy.com/view/ssBBDW\n// 2022-07-31 07:41:23\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    C *= 0.;\n    \n    float sc = 1./(1.+max(15.*float(lightMode == 1.)*max(sin(iTime*2.),0.)*sin(iTime*0.5),0.));\n    \n    float md = 14.;\n    U = floor(U*sc)/sc + pow(mix(hash11(floor(iTime*md)),hash11(ceil(iTime*md)),fract(iTime*md)),0.5)*0.5;\n    \n    \n    vec2 uv = U/R.xy;\n    vec2 nuv = (U - 0.5*R.xy)/max(R.x,R.y);\n    \n    float db = sdBox(nuv,vec2(0.26,0.26));\n    \n    vec4 a = Tb(uv);\n    vec4 b = Tc(uv);\n    \n    if(db > 0.){\n        //b = 1.-step(b,vec4(0.4,0.1,0.4,1));\n        b *= 0.1;\n        //b = 1.-b;\n    }\n\n    \n    C += a - b ;\n    C *= Td(uv);\n    \n    vec3 n = hash33(vec3(U,mod(iTime,200.)));\n    vec3 nb = hash33(vec3(U,mod(iTime,5200.)));\n    //C = mix(C,n.xyzx,n.xyzz);\n    \n    C.xyz += smoothstep(1.,0.,length(C.xyz))*n*0.2;\n    \n    C.xyz -= smoothstep(0.,1.,length(C.xyz))*nb*0.1;\n    \n    C = mix(C,1.-C,smoothstep(dFdx(nuv.x),0.,abs(db) - 0.001 - 0.4*float(enva(iTime)>0.9)));\n    C = max(C,vec4(0.01));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float eass(float p, float g) {\n    float s = p*0.45;\n    for(float i = 0.; i < g; i++){\n    \ts = smoothstep(0.,1.,s);\n    }\n    return s;\n}\n\n#define pi acos(-1.)\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\n#define lightMode float(fract(iTime*0.1) <0.5 )\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat luma(vec3 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\nfloat sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 12.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    n = sin(n*2.);\n    return n;\n}\n\nfloat enva(float t){\n    return (fract(t*0.25) );\n}\nfloat envb(float t){\n    return (fract(t*0.25 + 0.5) );\n}\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}", "buffer_a_code": "vec3 getRd(vec3 ro, vec3 lookAt, vec2 uv ){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return normalize(dir + right*uv.x + up * uv.y);\n}\nmat3 getLookAtMatrix(vec3 ro, vec3 lookAt){\n    vec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(dir,vec3(0,1,0)));\n    vec3 up = normalize(cross(dir,right));\n    return mat3(right,up,dir);\n}\n\nvec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat textb(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nfloat text(vec2 p, float[4] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(15. * n14(id.x + idx + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2 + idx)),14.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 4. - hash11(idx)*4.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\nvec3 map(vec3 p){\n    vec3 d = vec3(0);\n    \n    p *= 3.;\n    vec3 op = p;\n    float att = 1.;\n    for(float i = 0.; i < 3.; i++){\n        \n        p = abs(p);\n        p *= 1.5;\n        \n        p -= 0.4;\n        if(lightMode==0.)\n            p /= clamp(dot(p,p),-.5,2.4);\n        \n        \n        p += sin(dot(p,cos(p*1. + i + iTime)))*att*0.4;\n        p.yz *= rot(1.6 + i*0.);\n        p.xy *= rot(4.6);\n        \n        \n        \n        d += exp(-abs(dot(op.xx,p.xy))*80.)*att*3.;\n        //d += abs(dot(sin(p*1.),cos(p*1.5 + 15.)))*att;\n        att *= 0.7;\n    }\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    d *= 1.4;\n//d = 1.-abs(d);\n    //d = abs(d);\n    //d = clamp(d,0.,1.);\n    //d = max(d,0.);\n    //d = mix(vec3(1,0.5,1)*0.1,vec3(1,1.5,1),d*5.);\n    \n    //d = mix(vec3(1.4,0.1,0.4),vec3(0,0.4,0.2),d*0.5)*d;\n    d = (0.5 + 0.5*sin(vec3(1,2,5)*1. - cos(d*29.)*0. + 4. + d.x*0.4))*d*1.;\n    //d = exp(d*1000.);\n    //d = pow(d,vec3(5.));\n    return d;\n}\n\nvec3 getMarch(vec3 ro, vec3 rd, vec2 uv){\n\n    vec3 col = vec3(0);\n    \n    float iters = 510.;\n    float maxD = 10. + 5.*float(sin(iTime));\n    vec3 accum = vec3(0);\n    //float stepSz = 1./iters*maxD*mix(0.99,1.,hash23(vec3(uv*2000.,110.)).x);\n            \n    //ro -= rd * hash23(vec3(uv*2000.,510. + iTime*0.)).x*1./iters*maxD;\n    float dith = texture(iChannel1,gl_FragCoord.xy/vec2(textureSize(iChannel1,0).xy*2)).x;\n    dith = step(dith,0.5);\n    ro -= rd * dith * 11./iters*maxD;\n    //ro -= rd * hash23(vec3(uv*2000.,510. + iTime*0.)).x*1./iters*maxD;\n    \n    vec3 p = ro;\n    \n    float t = 0.;\n    float stepSz = 1./iters*maxD;\n    for(float i = 0.; i < iters; i++){\n        vec3 d = map(p);\n        \n        accum += d*stepSz*(1.-dot(accum,accum));\n        stepSz = 1./iters*maxD*mix(1.,0.5,exp(-dot(d,d)*44.));\n    \n        if(dot(accum,accum) > 0.8 || t > maxD)\n            break;\n        t += stepSz;\n        p += rd*stepSz;\n    }\n    \n    //col += accum;\n    col = mix(col,accum,dot(accum,accum)*15.);\n    //col = mix(col,accum,pow(dot(accum,accum)*4.,1.)*144.);\n    \n    col = col/(2. + col*0.7)*1.4;\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(0,0,-2);\n    ro.xy *= rot((iTime*0.8 + sin(iTime*1.7)*0.6)*0.1);\n    ro.xz *= rot((iTime + sin(iTime*1.4))*0.2);\n    ro.xz *= rot(iMouse.x/iResolution.x);\n    ro.yz *= rot(iMouse.y/iResolution.x);\n    //ro.xz *= rot(iTime);\n    //ro.xy *= rot(sin(iTime));\n   \n    \n    vec3 lookAt = vec3(0);\n    mat3 lookAtMat = getLookAtMatrix(ro,lookAt);\n    vec3 rd = lookAtMat * normalize(vec3(uv,1.));\n    \n    col = getMarch(ro, rd, uv);\n    \n    {\n        for(float i = 0.; i < 40.; i++){\n            vec3 dotPos = hash31(i + 20.)*2. - 1.;\n            dotPos *= 4.;\n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            lp *= rot(exp(-fract(iTime*sin(i) + sin(i)*20.)*4.)*pi);\n            float d = max(\n                min(abs(lp.x),abs(lp.y)),\n                sdBox(lp,vec2(0.01))\n                ) - 0.0001 - 0.001*pow(abs(sin(i + iTime)),5.);\n            //col += smoothstep( dFdx(uv.x), 0. , d);\n            col += smoothstep( 1./R.x, 0. , d);\n        }\n        \n        for(float i = 0.; i < 40. - 30.*lightMode; i++){\n            vec3 dotPos = max(hash31(i + 100.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n\n            float sc = 8. + sin(i)*5.;\n            lp *= sc;\n            //uv *= 2.;\n\n            float td = text(lp, float[4](96.,96.,96.,96.), -0.5 , 0.2 , false, 0., 0.47 , true, i);\n            \n            //col = mix(col,vec3(1),smoothstep(0.4*fwidth(td)*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n            col = mix(col,vec3(1),smoothstep(0.4*0.01*(1.-step(0.01,td)),0.,td - 0.4 * float(i<9. && sc > 5.)));\n\n        }\n        for(float i = 0.; i < 10.; i++){\n            vec3 dotPos = max(hash31(i + 1200.),0.4)*2. - 1.;\n            dotPos *= 2.;\n            \n            \n            vec3 projPos = lookAtMat*dotPos;\n            projPos /= projPos.z*2.;\n            if(projPos.z < 0.)\n                continue;\n            vec2 lp = uv - projPos.xy;\n            lp *= 17.4;\n\n            float md = 0.3;\n            float id = floor(lp.y/md);\n            if(id < 2. || id > 9. + sin(i)*20.)\n                continue;\n            lp.y = mod(lp.y,md);\n            float td = textb(lp, float[4*4](\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,103.,103.,103.,\n                103.,96.,96.,96.\n                ), -0.5 , 0.2 , false, 0., 0.47 , true, id + i*20. + floor(iTime*10.));\n            col = mix(col,vec3(1),smoothstep(0.04,0.,td - 0.0));\n        }\n        \n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n\n        \n    \n    }\n    \n    uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    float td = sdBox(uv - (max(hash31(floor(iTime*1.)).xy,0.2)*1. - 0.75)*2., vec2(0.1,0.001));\n    \n    \n    if(td < 0.){\n        col = 1.-col;\n    }\n\n    //col = mix(col,1.-col,smoothstep(0.,fwidth(td),td));\n    //vec3 rd = normalize(vec3(uv,1));\n    \n    \n    \n    \n    if((envb(iTime) < 0.1))\n        col = luma(col)*vec3(1);\n\n    \n    //col = 1.- col;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 n14(float f){ return texture(iChannel2,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\n\nfloat text(vec2 p, float[16] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble, float idx) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x) ];\n    if(scrobble)\n        char += floor(\n            15. * n14(id.x + idx + (iTime * 0.05 *sin(idx)+ sin(id.x))*24.).y * \n            pow(abs(sin(iTime + id.x*0.2 + idx)),1.) ) ;\n    /*\n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    */\n    char -= 32. ;\n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 16. - n14(idx + 200.).x*15.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy*(1. ) ;\n    uv += vec2(.6,0)*float(fract(iTime*14.2) < 0.4)*float(fract(iTime*2.2) < 0.1);\n    vec2 t = 1./R.xy;\n    vec4 l = vec4(\n        luma(Ta(uv + vec2(t.x,0)))-luma(Ta(uv - vec2(t.x,0))) +\n        luma(Ta(uv + vec2(0,t.y)))-luma(Ta(uv - vec2(0,t.y)))\n    );\n    //l = abs(l);\n    \n    \n    if(fract(iTime) < 0.1)\n        C = vec4(step((l.x),0.04));\n    else\n        C = vec4(1);\n    \n    uv = (U - 0.5*R.xy)/R.y;\n\n    if((lightMode==0.)){\n        vec2 p = (uv + vec2(+0.9,0.))*15.;\n        p.y += iTime;\n        float md = 0.1;\n        float id = floor(p.y/md);\n        p.y = mod(p.y,md);\n        float td = text(p, float[4*4](\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,103.,103.,103.,\n            103.,96.,96.,96.\n            ), -0.5 , 0.2 , false, 0., 0.47 , true, id);\n        C = mix(C,vec4(0),smoothstep(0.01,0.,td - 0.02));\n        \n    }\n}", "buffer_b_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// dither\n/*\nvec3[4*4] palAppleII = vec3[](\n    vec3(217, 60, 240)/255.,\n    vec3(64, 53, 120)/255.,\n    vec3(108, 41, 64)/255.,\n    vec3(0, 0, 0)/255.,\n\n    vec3(236, 168, 191)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(217, 104, 15)/255.,\n    vec3(64, 75, 7)/255.,\n\n    vec3(191, 180, 248)/255.,\n    vec3(38, 151, 240)/255.,\n    vec3(128, 128, 128)/255.,\n    vec3(19, 87, 64)/255.,\n\n    vec3(255, 255, 255)/255.,\n    vec3(147, 214, 191)/255.,\n    vec3(191, 202, 135)/255.,\n    vec3(38, 195, 15)/255.\n);\n*/\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    vec2 t = 1./R.xy;\n    \n    C = Ta(uv);\n    \n    float dith = texture(iChannel1,U.xy/vec2(textureSize(iChannel1,0).xy*(1 + int(fract(iTime*0.1) < 0.2)))).x;\n    \n    \n    float quant = 3.;\n    float recipQuant = 1./quant;\n    \n    vec4 s = Ta(uv);\n    vec3 currColHsv = rgb2hsv(s.xyz);\n    s = hsv2rgbSmooth(currColHsv*vec3(1,0.2,1.) + vec3(0.3,0.,0.)).xyzz;\n    \n    vec4 currC = floor(s*quant)/quant;\n    vec4 nextC = clamp(currC + recipQuant,0.,1.);\n    float perc = fract(luma(s)*quant);\n    \n    \n    \n\n    \n    \n    if(perc>dith){\n        C = nextC;\n    } else{\n        C = currC;\n    }\n   \n\n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_c_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// iq\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n\nvec4 n14(float f){ return texture(iChannel0,vec2(mod(floor(f),256.),floor(f/256.))/256.); }\n\n\nfloat text(vec2 p, float[8] chars, float spacing, float s, bool isAbs, float absWidth, float opacity, bool scrobble) {\n\tp *= s;  \n    \n    p.x *= 1. - spacing;\n    vec2 id = floor(p*8.*2.);\n    p = mod(p,1./16.);\n    p.x = p.x/(1. - spacing) + 1./16./8.;\n    float char = chars[int(id.x)];\n    //char += 112. ;\n    if(scrobble)\n        char += floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y*pow(abs(sin(iTime + id.x*0.2)),14.) ) ;\n    \n    if(scrobble)\n        char += 0.*floor(15. * n14(id.x + (iTime + sin(id.x))*24.).y * (2. - 1.)* (1. - eass((iTime - + id.x*1./16. - 3.)*1.,3.)) ) ;\n    \n    float t;\n    if(abs(id.y) < 1. && id.x >= 0. && id.x < 8.  && char < 200.){\n        vec4 letter = texture(iChannel3,p + vec2(mod(char,16.),-floor(char/16.) )/16.);\n        t = letter.w - opacity;\n        if(abs(p.x-1./16./2.)>1./16./2.)\n            t = 10e4;\n    \n        t /= s*10.1;\n    } else {\n        t = 10e5;\n    \n\t }\n    if (isAbs)\n        t = abs(t) - absWidth;\n    return t;\n}\n\n\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 oU = U;\n    float sc = 4. + 4.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(U/sc)*sc;\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n    uv.x = abs(uv.x);\n    \n    uv.x -= 0.4;\n    vec2 t = 1./R.xy;\n    \n    \n    \n    vec2 prevP = vec2(0);\n    \n    float d = 10e4;\n    for(float i = 0.; i < 10.; i++){\n        vec2 k = vec2(sin(i*0.7 + sin(iTime + i)), cos(i*1.5 + iTime)*2.)*0.1;\n            \n            \n            \n        d = min(d,sdSegment(uv,k,prevP) - 0.004 - noise(vec3(i+iTime + sin(iTime + i),uv*5.))*0.01);\n        \n        \n        prevP = k;\n    }\n   \n   float od = d;\n   d = abs(d);\n   C *= 0.;\n   //C += 1.; // epic lol\n   \n   \n   if(lightMode == 1.)\n       C += 1.;\n   else\n       C= mix(C,1.-C,smoothstep(0.,fwidth(d),d - 0.004));\n   \n   if(od < 0.)\n       return;\n   \n    sc = 3. + 2.*float(fract(iTime)<0.3)*float(fract(iTime*0.25)<0.25);\n    U = floor(oU/sc)*sc;\n    \n   vec2 u = (U-R.xy*0.5)/R.y;\n   u.x -= .5;\n   u*=2. + floor((hash11(floor(iTime/3.))*4.));\n   u.x /= 1.5;\n   \n   //u += 1./3.;\n   if(u.x < 1. && u.y < 1. && u.x > 0. && u.y > 0. && lightMode == 0.)\n       C -= 1.- texture(iChannel1,u);\n    \n    \n    sc = 2.;\n    U = floor(U/sc)*sc;   \n    uv = (U-R.xy*0.5)/R.y;\n    \n    float pxsz = 0.001;\n    float tt =10e5;\n    for(float i = 0.; i < 0.; i++){\n        float m = sin(iTime*0.4 + sin(iTime)+i);\n        tt = min(tt,text(uv + vec2(0,sin(i+ m)*0.1), float[8](135.,130.,121.,119.,120.,132.,117.,130.), 0.04 +m*0.5 , 0.5 , true, 0.004, 0.3 + 0.1*sin(iTime+i*0.4), false));\n    }\n    {\n        float m = sin(iTime*0.4 + sin(iTime));\n        vec2 p = uv + vec2(0.7,-0.2);\n        //p *= rot(0.5*pi);\n        p.x += (iTime + sin(iTime))*0.3;\n        p.x = pmod(p.x,6.);\n        tt = min(tt,text(p, float[8](128.,127.,132.,113.,132.,117.,1117.,1130.), 0.01 +m*0.4 , 0.4 , true, 0.0001, 0.4 + 0.*sin(iTime*0.3 + 0.4), true));\n    }   \n             \n            \n    C = mix(C,(0.6-C) ,smoothstep(pxsz + 0.01,0., tt - 0.01));\n    \n/*\n    vec3 hit = vec3(0);\n    float similarity = -1.;\n    for(int i = 0; i < 4*3; i++){\n        vec3 palC = palAppleII[i];\n        \n        //vec3 palCHsv = hsv2rgbSmooth( in vec3 hsv )\n        vec3 palCHsv = rgb2hsv(palC);\n        \n        float localSimilarity = dot(luma(palC), luma(C));\n        \n        if(localSimilarity > similarity){\n            similarity = localSimilarity;\n            hit = palC;\n        }\n    }\n    C.xyz = hit;\n*/\n    //C = currC;\n    \n}", "buffer_d_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 129, 129, 1071]], "test": "untested"}
{"id": "fltcR8", "name": "iterative-tracer", "author": "elementbound", "description": "low-iq bruteforce approach for raytracing a bunch of spheres with AA, DOF, shadows and GI", "tags": ["raytracer", "iterative"], "likes": 1, "viewed": 235, "published": 3, "date": "1659262992", "time_retrieved": "2024-07-30T16:37:42.835075", "image_code": "#define MAX_RAY_DEPTH 4\n#define SAMPLE_COUNT 16\n\n#define SPHERE_COUNT 5\n\ncamera_t camera;\nsphere_t spheres[SPHERE_COUNT];\n\nrayStep_t raySteps[MAX_RAY_DEPTH];\n\nvoid setupCamera(float time) {\n    float yaw = iTime / 15.0;\n    float roll = (1.0 + sin(mod(iTime / 30.0, 1.0) * 2.0 * PI)) / 2.0;\n    roll = mix(-30.0f, 60.0f, roll) * DEG2RAD;\n    \n    camera.from = yawroll(yaw, roll) * 4.0;\n    camera.to = vec3(0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    \n    camera.r = 0.005;\n    camera.fov = 60. * DEG2RAD;\n    \n    camera.from.y = abs(camera.from.y);\n}\n\nvoid setupScene(float time) {\n    setupCamera(time);\n    \n    for (int i = 0; i < SPHERE_COUNT - 2; ++i) {\n        float sf = float(i) / float(SPHERE_COUNT - 2);\n        spheres[i].pos = yawroll(sf * 360. * DEG2RAD, 0.);\n        spheres[i].r = 0.375;\n    \n        spheres[i].material.albedo = (1.0 + normalize(spheres[i].pos)) / 2.0;\n        spheres[i].material.emissive = vec3(0.);\n        spheres[i].material.metallic = (1.0 + spheres[i].pos.x) / 2.;\n        spheres[i].material.roughness = (1.0 + spheres[i].pos.z) / 2.;\n    }\n    \n    // Top light sphere\n    spheres[SPHERE_COUNT - 1].pos = vec3(0., 4., 0.);\n    spheres[SPHERE_COUNT - 1].r = 1.;\n    \n    spheres[SPHERE_COUNT - 1].material.albedo = vec3(0);\n    spheres[SPHERE_COUNT - 1].material.emissive = vec3(2);\n    \n    \n    // Bottom floor sphere\n    spheres[SPHERE_COUNT - 2].pos = vec3(0., -512. - spheres[0].r, 0.);\n    spheres[SPHERE_COUNT - 2].r = 512.;\n    \n    spheres[SPHERE_COUNT - 2].material.albedo = vec3(1.0);\n    spheres[SPHERE_COUNT - 2].material.emissive = vec3(0.);\n    spheres[SPHERE_COUNT - 2].material.roughness = 0.05;\n    spheres[SPHERE_COUNT - 2].material.metallic = 1.;\n}\n\nfloat raycastScene(ray_t ray, out vec3 p, out vec3 n, out material_t material) {\n    float rt = -32768.;\n    vec3 rp, rn;\n    material_t rm;\n    \n    vec3 tp, tn;\n    \n    for (int i = 0; i < SPHERE_COUNT; ++i) {\n        float t = raycastSphere(ray, spheres[i], tp, tn);\n        \n        if (t >= 0. && t < abs(rt)) {\n            rt = t;\n            rp = tp;\n            rn = tn;\n            rm = spheres[i].material;\n        }\n    }\n    \n    if (rt >= 0.) {\n        p = rp;\n        n = rn;\n        material = rm;\n    }\n    \n    return rt;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float resMin = min(iResolution.x, iResolution.y);\n    float resMax = max(iResolution.x, iResolution.y);\n    vec2 uv = fragCoord/resMin;\n    uv.x -= (resMax - resMin) / resMin / 2.;\n    \n    // Setup scene\n    setupScene(iTime);\n    \n    fragColor = vec4(0.);\n    \n    for (int j = 0; j < SAMPLE_COUNT; ++j) {\n        vec4 seed = vec4(fragCoord, iFrame, j);\n        ray_t ray = getRay(camera, uv, seed);\n\n        float t;\n        vec3 p, n;\n        material_t m;\n        vec3 radiance = vec3(0.);\n\n        int rayDepth = 0;\n        \n        for (int i = 0; i < MAX_RAY_DEPTH; ++i) {\n            t = raycastScene(ray, p, n, m);\n            raySteps[i].ray = ray;\n            raySteps[i].t = t;\n            raySteps[i].color = vec3(0.);\n            \n            rayDepth++;\n\n            if (t >= 0.) {\n                raySteps[i].material = m;\n                raySteps[i].p = p;\n                raySteps[i].n = n;\n                \n                ray.origin = p + n * 0.0001;\n                vec3 offset = hash44(vec4(fragCoord.xy, iFrame, 17 + i * 27 + j * 37)).xyz;\n                offset = normalize(2. * offset - 1.);\n                ray.d = reflect(ray.d, normalize(n + offset * m.roughness));\n            } else {\n                break;\n            }\n        }\n        \n        raySteps[rayDepth - 1].color = texture(iChannel0, raySteps[rayDepth - 1].ray.d).rgb;\n        \n        for (int i = rayDepth - 2; i >= 0; i -= 1) {\n            vec3 albedoMultiplier = mix(\n                vec3(length(raySteps[i+1].color)),\n                raySteps[i+1].color,\n                raySteps[i].material.metallic\n            );\n        \n            raySteps[i].color =\n                raySteps[i].material.albedo * albedoMultiplier +\n                raySteps[i].material.emissive;\n        }\n        \n        fragColor += vec4(raySteps[0].color, 1.);\n    }\n    \n    fragColor /= float(SAMPLE_COUNT);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ================================================================================================\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n//----------------------------------------------------------------------------------------\n// 1 out 4 in...\nfloat hash14(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.x + p4.y) * (p4.z + p4.w));\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n// ================================================================================================\n// Useful constants\n\n#define DEG2RAD 0.01745329251994329576923690768489\n#define PI 3.1415926535897932384626433832795\n\n// ================================================================================================\n// Common structs\n\nstruct ray_t {\n    vec3 origin;\n    vec3 d;\n};\n\nstruct material_t {\n    vec3 albedo;\n    vec3 emissive;\n    float roughness;\n    float metallic;\n};\n\nstruct sphere_t {\n    vec3 pos; \n    float r;\n    material_t material;\n};\n  \nstruct rayStep_t {\n    ray_t ray;\n    material_t material;\n    vec3 color;\n    \n    float t;\n    vec3 p;\n    vec3 n;\n};\n  \nstruct camera_t {\n\tvec3 from; \n\tvec3 to;\n\tvec3 up;\n    \n    float fov;\n    float r;\n};\n\n// ================================================================================================\n// Raycasting\n\nfloat raycastSphere(ray_t ray, sphere_t sphere, out vec3 p, out vec3 n)\n{\n    // Based on:\n    // https://gdbooks.gitbooks.io/3dcollisions/content/Chapter3/raycast_sphere.html\n\n\tvec3 p0 = ray.origin;\n    vec3 d = ray.d;\n    vec3 c = sphere.pos;\n    float r = sphere.r;\n    \n    vec3 e = c - p0;\n    float Esq = dot(e, e);\n    float a = dot(e, d);\n    float b = sqrt(Esq - a*a);\n    float f = sqrt(r*r - b*b);\n    \n    float D = r*r - Esq + a*a;\n    float t = 0.;\n    \n    if (D < 0.)\n        return -1.;\n\n    if (Esq < r*r)\n        t = a + f;\n    else\n        t = a - f;\n        \n    p = ray.origin + t * ray.d;\n    n = normalize(p - c);\n        \n    return t;\n}\n\n// ================================================================================================\n// Camera\n\n// Based on: \n// https://www.khronos.org/registry/OpenGL-Refpages/gl2.1/xhtml/gluLookAt.xml\nmat4 lookAt(vec3 from, vec3 to, vec3 up) {\n    up = normalize(up);\n    \n    vec3 forward = to - from;\n    forward = normalize(forward);\n    \n    vec3 side = normalize(cross(forward, up));\n    up = cross(side, forward); \n    up = normalize(up);\n    \n    return mat4(vec4(side, 0.0), vec4(up, 0.0), vec4(forward, 0.0), vec4(0.,0.,0.,1.));\n}\n\nvec3 yawroll(float yaw, float roll) {\n    float d = cos(roll);\n    return vec3(cos(yaw)*d, sin(roll), sin(yaw)*d);\n}\n\nray_t getRay(camera_t camera, vec2 uv, vec4 seed) {\n    vec3 offset = hash44(seed).xyz;\n    offset = 2. * offset - 1.;\n    offset *= camera.r;\n    \n    mat4 view = lookAt(camera.from + offset, camera.to, camera.up);\n    float znear = 1.0 / tan(camera.fov / 2.0f);\n    \n    vec3 d = normalize(vec3(2. * uv - 1., znear));\n    d = (view * vec4(d, 0.0)).xyz;\n    \n    ray_t result;\n    result.origin = camera.from;\n    result.d = d;\n    \n    return result;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fltcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 189, 189, 556], [558, 558, 587, 587, 1715], [1717, 1717, 1797, 1797, 2258], [2260, 2260, 2317, 2317, 4212]], "test": "untested"}
{"id": "fttcR8", "name": "varying width stripes effect", "author": "grevel", "description": "Inspired by a shirt of a stranger that I saw during my holidays.", "tags": ["video", "effect", "bands", "stripes"], "likes": 3, "viewed": 203, "published": 3, "date": "1659261764", "time_retrieved": "2024-07-30T16:37:43.663859", "image_code": "#define lines 20.0\n#define widthMin 0.1\n#define widthMax 0.6\n\nfloat map(float inp, float inMin, float inMax, float outMin, float outMax) {\n    return (inp - inMin) / (inMax - inMin) * (outMax - outMin) + outMin;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 uvClamped = uv;\n    uvClamped.y *= lines;\n    uvClamped.y = floor(uvClamped.y);\n    uvClamped.y /= lines;\n\n    vec4 texCol = vec4(texture(iChannel0, uvClamped));\n    float brightness = (texCol.x + texCol.y + texCol.z)/3.0;\n    \n    \n    float col = step(2.0*abs(fract(uv.y * lines)-0.5), map(brightness, 0.0, 1.0, widthMin, widthMax));\n    \n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttcR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 138, 138, 213], [215, 215, 272, 272, 706]], "test": "untested"}
{"id": "7lcyz8", "name": "KITTIES!!", "author": "Xibanya", "description": "They love you!", "tags": ["procedural", "sdf", "cat", "generator", "cats"], "likes": 153, "viewed": 4324, "published": 3, "date": "1659223153", "time_retrieved": "2024-07-30T16:37:44.686126", "image_code": "// designs inspired by https://www.freepik.com/premium-vector/cute-cats-collection-cats-faces_10120615.htm\n// comment this out to get four rows of procgen cats rather than 2\n#define BIGGER\n\n#define PUPIL vec3(0.18, 0.17, 0.165)\n#define CAT_BASE_1 vec3(0.9, 0.77, 0.55)\n#define CAT_BASE_2 vec3(0.4, 0.37, 0.37)\n#define CAT_BASE_3 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_4 vec3(0.7, 0.6, 0.5)\n#define CAT_BASE_5 vec3(0.9, 0.9, 0.83)\n#define CAT_LIGHT_1 vec3(0.97, 0.9, 0.7)\n#define CAT_LIGHT_2 vec3(1., 0.95, 0.97)\n#define CAT_LIGHT_3 vec3(1., 0.95, 0.85) \n#define CAT_LIGHT_4 vec3(1., 0.96, 0.78)\n#define CAT_LIGHT_5 vec3(0.9, 0.9, 0.83)\n#define CAT_DARK_1 vec3(0.7, 0.5, 0.4)\n#define CAT_DARK_2 vec3(0.25, 0.2, 0.2)\n#define CAT_DARK_3 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_4 vec3(0.5, 0.4, 0.35)\n#define CAT_DARK_5 vec3(0.44, 0.37, 0.36)\n#define CAT_OUTLINE_1 vec3(0.37, 0.2, 0.13)\n#define CAT_OUTLINE_2 vec3(0.18, 0.18, 0.16)\n#define CAT_OUTLINE_3 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_4 vec3(0.35, 0.3, 0.26)\n#define CAT_OUTLINE_5 vec3(0.35, 0.3, 0.26)\n#define CAT_EYE_1 vec3(1.)\n#define CAT_EYE_2 vec3(0.8, 0.76, 0.38)\n#define CAT_EYE_3 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_4 vec3(0.6, 0.86, 0.9)\n#define CAT_EYE_5 vec3(0.9)\n#define CAT_BELLY_1 vec3(0.97, 0.9, 0.7)\n#define CAT_BELLY_2 vec3(1., 0.95, 0.97)\n#define CAT_BELLY_3 vec3(0.7, 0.6, 0.5) * 1.1\n#define CAT_BELLY_4 vec3(1., 0.96, 0.78)\n#define CAT_BELLY_5 vec3(0.9, 0.9, 0.83)\n\n#define TABBY_SPOT 0.075\n\n#define MAX_ROTATION 150.\n#define MIN_ROTATION -150.\n#define MAX_EAR_DOWN 225.\n#define MAX_EAR_UP 195.\n\n#ifdef BIGGER\n    #define OUTLINE_THICKNESS 0.04\n#else\n    #define OUTLINE_THICKNESS 0.02\n#endif\n#define OUTLINE_THRESHOLD 0.7\n\nstruct Cat {\n    float butt; // width of the lower end of the body\n    float height; // body length\n    float rotation; // body rotation in degrees\n    vec3 baseColor;\n    vec3 lightColor;\n    vec3 darkColor;\n    vec3 outlineColor;\n    vec3 eyeColor;\n    vec3 belly;\n    float f; // this is to cache the FBM noise value\n    float r; // progress from min rotation value to max rotation value from 0 to 1\n    float faceDark;\n    float heart;\n    float spots;\n    float tabby;\n    int type;\n};\nmat2 Rotate2DMatrix(float a)\n{\n    float ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca, -sa, sa, ca);\n}\nvec2 Rotate2D(vec2 p, float a)\n{\n    return Rotate2DMatrix(radians(a)) * p;\n}\nvec3 DoOutline(float d, vec3 color, float thickness, vec3 outColor)\n{\n    if (d < 0.)\n    {\n        float t = -d / thickness;\n        t = t * t;\n        color = mix(outColor, color, step(OUTLINE_THRESHOLD, t));\n    }\n    return color;\n}\nfloat InvLerp(in float from, float to, float value)\n{\n    return (value - from) / (to - from);\n}\nvec2 interpolate(vec2 a, vec2 b, vec2 c, vec2 d, float p)\n{\n    vec2 v0 = mix(a, b, p);\n    vec2 v1 = mix(b, c, p);\n    vec2 v2 = mix(c, d, p);\n    vec2 v3 = mix(v0, v1, p);\n    vec2 v4 = mix(v1, v2, p);\n    \n    return mix(v3, v4, p);\n}\nfloat Spline(in vec2 p, in vec2 a, in vec2 b)\n{\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n// 2D SDF functions from https://iquilezles.org/articles/distfunctions2d/\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat Heart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\nfloat UnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\nfloat EquiTriSDF(in vec2 p)\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\nfloat Isosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat Egg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x);\n    float r = ra - rb;\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat Circle( vec2 p, float r )\n{\n    return length(p) - r;\n}\nfloat FBMRandom(vec2 st)\n{\n    vec2 m = vec2(iMouse.xy);\n    return fract(sin(dot(st.xy, m + vec2(12.9898, 78.233))) *\n                    43758.5453123);\n}\nCat GetCat(vec2 uv)\n{\n    // declaring the arrays outside the function doesn't work on some platforms\n    // so gotta do this rigamarole here\n    vec3[5] base;\n    base[0] = CAT_BASE_1; base[1] = CAT_BASE_2; base[2] = CAT_BASE_3; \n    base[3] = CAT_BASE_4; base[4] = CAT_BASE_5;\n\n    vec3[5] light;\n    light[0] = CAT_LIGHT_1; light[1] = CAT_LIGHT_2; light[2] = CAT_LIGHT_3; \n    light[3] = CAT_LIGHT_4; light[4] = CAT_LIGHT_5;\n\n    vec3[5] dark;\n    dark[0] = CAT_DARK_1; dark[1] = CAT_DARK_2; dark[2] = CAT_DARK_3; \n    dark[3] = CAT_DARK_4; dark[4] = CAT_DARK_5;\n\n    vec3[3] eye;\n    eye[0] = CAT_EYE_1; eye[1] = CAT_EYE_2; eye[2] = CAT_EYE_3;\n\n    vec3[5] outline;\n    outline[0] = CAT_OUTLINE_1; outline[1] = CAT_OUTLINE_2; outline[2] = CAT_OUTLINE_3; \n    outline[3] = CAT_OUTLINE_4; outline[4] = CAT_OUTLINE_5;\n\n    vec3[5] belly;\n    belly[0] = CAT_BELLY_1; belly[1] = CAT_BELLY_2;\n    belly[2] = CAT_BELLY_3; belly[3] = CAT_BELLY_4;\n    belly[4] = CAT_BELLY_5;\n\n    Cat cat;\n\n    vec2 cUV = floor(uv * 2.);\n\n    float f = clamp(0., 1., FBMRandom(cUV));\n    cat.f = f;\n    int i = 0;\n    float count = 5.;\n    float mul = 1000.;\n    float cF = fract(f + cUV.x + cUV.y * 0.5);\n    if (mod(floor(cF * mul) + 1., count) == 0.) i = 1;\n    else if (mod(floor(cF * mul) + 2., count) == 0.) i = 2; \n    else if (mod(floor(cF * mul) + 3., count) == 0.) i = 3; \n    else if (mod(floor(cF * mul) + 4., count) == 0.) i = 4;\n\n    cat.type = i;\n    \n    cat.baseColor = base[i];\n    cat.lightColor = light[i];\n    cat.darkColor = dark[i];\n    cat.outlineColor = outline[i];\n    cat.belly = belly[i];\n    cat.eyeColor = mod(floor(f * 100.), 3.) == 0.? eye[0] : \n        (mod(floor(f * 100.) + 1., 3.) == 0.? eye[1] : eye[2]);\n\n    cat.rotation = mix(MIN_ROTATION, MAX_ROTATION, fract(f + cUV.x * 0.3));\n    cat.r = InvLerp(MIN_ROTATION, MAX_ROTATION, cat.rotation);\n    cat.height = mix(0.5, 1., fract(f + 0.5 + cUV.y));\n    cat.butt = mix(0.7, 0.9, abs(f * 2. - 1.));\n   \n    cat.faceDark = mod(floor((1. - cat.f) * 5.), 4.) == 0.? 1. : 0.;\n    cat.heart = mod(floor(fract(cat.f + 0.75) * 10.), 2.) == 0.? 1. : 0.;\n    cat.spots = mod(floor(cat.f * 1450.), 2.) == 0.? 1. : 0.;\n    cat.tabby = mod(floor(fract(cat.f + 0.25) * 1329.), 3.) == 0.? 1. : 0.;\n    return cat;\n}\nfloat Smooth(float sdf) { return 1. - smoothstep(-0.025, -0.01, sdf);}\nfloat TopMarks(vec2 headUV)\n{\n    float xSign = sign(headUV.x);  \n    vec2 mUV = headUV * vec2(7., 1.) + vec2(0., 2.);\n    float markScale = 1.;\n    float mSDF = Circle(mUV, markScale);\n\n    vec2 mUV1 = Rotate2D(headUV, 16. * xSign);\n    mUV1 = mUV1 * vec2(10., 1.) + vec2(-1. * -xSign, 2.2);\n    mSDF = min(mSDF, Circle(mUV1, markScale));\n    return mSDF;\n}\nfloat HeartMark(vec2 headUV)\n{\n    vec2 heartUV = headUV * vec2(0.15, 0.2) + vec2(0., 1.05);\n    return Heart(heartUV);\n}\nvoid HeadMarkings(vec2 p, Cat cat, inout vec3 col)\n{\n    float xSign = sign(p.x);\n    vec3 light = mix(cat.lightColor * 1.1, cat.lightColor, \n        clamp(0., 1., dot(p, p)));\n    if (cat.heart == 1.)\n    {\n        float heartSDF = HeartMark(p);\n        col = heartSDF < 0.? col : light;\n    }\n   \n    if (cat.faceDark == 1.)\n    {\n        float spots = 0.;\n        vec3 sColor = cat.darkColor;\n        if (cat.spots == 1.)\n        {\n            float w =  sin(p.x * 50.) * 0.025;\n            vec2 stUV = p + vec2(1., 1.4);\n            stUV.y += w;\n            spots = Circle(stUV * vec2(1., 1.2), 1.2);\n            stUV -= vec2(2.3, 0.1);\n            spots = min(spots, Circle(Rotate2D(stUV, 25.) * vec2(1., 1.75), 0.75));\n            if (cat.heart == 0.)\n            {\n                stUV = p - vec2(0.8, 1.4);\n                stUV.y += w * 0.2;\n                stUV.x *= 0.7;\n                spots = min(spots, Circle(stUV, 0.75));\n            }\n            if (cat.tabby == 1.) sColor += TABBY_SPOT;\n        }\n        else\n        {\n            vec2 sideUV = p - vec2(1.6 * xSign, -0.9);\n            spots = Circle(sideUV, 1.5);\n        }\n         col = mix(col, sColor, Smooth(spots));\n    }\n    if (cat.tabby == 1.)\n    {\n        float mSDF = TopMarks(p);\n        col = mix(col, cat.darkColor, Smooth(mSDF));\n    }\n    if (mod(floor(cat.f * 1000.), 2.) == 0.)\n    {\n        float muzzle = Isosceles(p * 3. + vec2(0., 0.1), vec2(0.9, 1.)) - 1.;\n        col = mix(col, light, Smooth(muzzle));\n    }\n}\nvoid Eyes(vec2 headUV, Cat cat, inout vec3 col)\n{\n    float xSign = sign(headUV.x);  \n    vec2 eyeUV = headUV + vec2(0., 0.5);\n    eyeUV.x -= 0.8 * xSign;\n\n    // blinky blinky\n    float t = sin(iTime * max(0.5, cat.f) + cat.f) * 0.5 + 0.5;\n    float b = smoothstep(0., 1., InvLerp(0.999, 1., t));\n    eyeUV.y = mix(eyeUV.y, eyeUV.y * 7., b);\n\n    float eyeScale = mix(0.5, 0.55, cat.f);\n    float eyeSDF = Circle(eyeUV, eyeScale);\n    vec3 eyeCol = cat.eyeColor;\n    float pupil = Circle(eyeUV, eyeScale * 0.75);\n    eyeCol = mix(eyeCol, PUPIL, Smooth(pupil));\n    vec2 shineUV = eyeUV + vec2(0.2, 0.15);\n    float shine = Circle(shineUV, eyeScale * 0.3);\n    shine = min(shine, Circle(shineUV + vec2(0.1, -0.2), eyeScale * 0.15));\n    eyeCol = mix(eyeCol, vec3(1.), Smooth(shine));\n    vec2 lidUV = eyeUV * vec2(1., 0.95) + vec2(0., 0.05);\n    lidUV.y = mix(lidUV.y, lidUV.y * 0.95 - 0.02, b);\n    float lid = Circle(lidUV, eyeScale);\n    vec3 lidColor = cat.faceDark == 1.? cat.outlineColor : cat.darkColor;\n    eyeCol = mix(lidColor, eyeCol, Smooth(eyeSDF));\n    eyeSDF = min(eyeSDF, lid);\n    col = mix(col, eyeCol, Smooth(eyeSDF));\n}\nfloat Head(vec2 p, Cat cat, out vec3 col)\n{\n    float headHeight = cat.height * 1.2;\n    float headScale = 2.5;\n    vec2 headUV = (p - vec2(0., headHeight)) * headScale;\n    headUV = Rotate2D(headUV, -cat.rotation);\n    headUV.y *= -1.;\n    float xSign = sign(headUV.x);  \n    float headSDF = Egg(headUV, 2., 3.) + 0.1;\n    vec2 huv = headUV + vec2(0., 0.);\n    col = mix(cat.baseColor * 1.2, cat.baseColor, \n        smoothstep(0., 1.5, dot(huv, huv)));\n\n    // markings\n    HeadMarkings(headUV, cat, col);\n\n    //Ears\n    vec2 earUV = headUV;\n    earUV.x -= 1.1 * xSign;\n    earUV.y += 1.1;\n    float earRot = mix(MAX_EAR_DOWN, MAX_EAR_UP, fract(cat.f * 25.));\n    float earTip = 1.;\n    if (mod(floor(cat.f * 0.35 * 1000.), 3.) == 0.) earTip = 0.75;\n    earUV = Rotate2D(earUV, earRot * xSign);\n    float ear = Egg(earUV, 2., earTip) + 1.2;\n    vec3 earColor = cat.darkColor;\n    earUV = Rotate2D(earUV, -5. * xSign);\n    float earNeg = Egg(earUV * vec2(1.1, 1.) + vec2(0.2 * xSign, 0.), 2., 1.) + 1.4;\n    earColor = mix(earColor, cat.lightColor, Smooth(earNeg));\n    col = mix(earColor, col, Smooth(headSDF));\n    headSDF = min(headSDF, ear);\n   \n    // nose\n    vec3 noseColor = cat.outlineColor;\n    float noseScale = 8.;\n    vec2 noseUV = headUV;\n   \n    float bridge = Isosceles(noseUV * noseScale + vec2(0., 2.3), \n        vec2(0.7, 2.5)) - .75;\n    vec3 bridgeCol = cat.darkColor;\n    if (cat.type == 1) bridgeCol = cat.baseColor;\n    else if (mod(floor(cat.f * 2324321.), 2.) == 0.)\n    {\n        bridgeCol = cat.baseColor * 1.1;\n    }\n    col = mix(col, bridgeCol, Smooth(bridge));\n\n    noseUV *= vec2(1., -1.);\n    noseUV.y += 0.2;\n    float noseSDF = Isosceles(noseUV * noseScale, vec2(1.1, 0.8)) - .5;\n    col = mix(col, noseColor, Smooth(noseSDF));\n\n    // Eyes\n    Eyes(headUV, cat, col);\n\n    // Mouth\n    vec2 mouthUV = headUV - vec2(0., 0.3);\n    mouthUV.x *= 0.8;\n    mouthUV.x -= 0.19 * xSign;\n    float mouthScale = 0.2;\n    float mouth = Circle(mouthUV, mouthScale);\n    mouthUV = mouthUV * vec2(1.2, 0.9) + vec2(0., 0.1);\n    mouth = max(mouth, -Circle(mouthUV, mouthScale));\n    col = mix(col, cat.outlineColor, Smooth(mouth));\n\n    // head outline before whiskers\n    col = DoOutline(headSDF, col, OUTLINE_THICKNESS * headScale, cat.outlineColor);\n\n    // whiskers\n    vec2 wUV = headUV;\n    wUV.x -= 2. * xSign;\n    wUV.y -= 1.;\n    float wScale = 1.2;\n    float whisker = Circle(wUV, wScale);\n    vec2 wUV2 = wUV * vec2(0.8, 1.) - vec2(0.1 * xSign, 0.075);\n    whisker = max(whisker, -Circle(wUV2, wScale));\n\n    wUV.x += 0.35 * xSign;\n    wUV.y -= 0.25;\n    float w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.8, 1.) + vec2(0.1 * xSign, -0.075);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    wUV.x += 0.1 * xSign;\n    wUV.y -= 0.15;\n    w2 = Circle(wUV, wScale);\n    wUV2 = wUV * vec2(0.75, 1.) + vec2(0.2 * xSign, -0.05);\n    w2 = max(w2, -Circle(wUV2, wScale));\n    whisker = min(whisker, w2);\n\n    col = whisker < 0.? cat.outlineColor : col;\n\n    headSDF = min(headSDF, whisker);\n    return headSDF;\n}\nfloat Tail(vec2 uv, Cat cat)\n{\n    float rSign = sign(cat.rotation);\n    float xMul = cat.r * 2. - 1.;\n    float invX = 1. - abs(xMul);\n    float t = (sin(iTime * cat.f + cat.f) * 0.5 + 0.5);\n\n    vec2 a = vec2(0., 0.6);\n    vec2 b = vec2(1. * xMul * t, 1. * abs(xMul));\n    vec2 c = vec2((-0.5 + 0.5 *invX) * xMul + 1.5 * invX + t * 0.5, 1. - 0.5 * invX);\n    vec2 d = vec2((0.3 + 0.5 * invX) * xMul * t, 1.5 + 0.15 * abs(xMul) * t * 2.);\n\n    float tail = 0.;\n    const float STEPS = 20.;\n    for (float i = 0.; i < STEPS; ++i)\n    {\n        vec2  p0 = interpolate(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = interpolate(a, b, c, d, (i+1.) / STEPS);\n        float l = Spline(uv, p0, p1) - 0.1;\n        tail = min(tail, l);\n    }   \n    return tail;\n}\nvoid BackPattern(vec2 p, Cat cat, inout vec3 col)\n{\n    float r = cat.r * 2. - 1.;\n    float aR = abs(r);\n    float rSign = sign(r);\n    \n    //spots\n    if ((cat.spots == 1. || cat.faceDark == 1.))\n    {\n        vec2 spotUV = p * 7.;\n        spotUV.y += mix(10., 2., aR) * rSign;\n        spotUV.x += mix(-10., -3., aR) * rSign;\n\n        // if smooth face marks, spots should also be smooth\n        if (cat.spots == 1.) spotUV.y += sin(spotUV.x * 10.) * 0.1;\n       \n        float spot = EquiTriSDF(spotUV) - 2.;\n        spot = min(spot, EquiTriSDF(spotUV * 2. + \n            vec2(10. * rSign + 10. * step(rSign, 0.), 6. + 5. * step(rSign, 0.))) - 2.);\n\n        vec3 spotColor = cat.darkColor;\n        if (cat.tabby == 1.) spotColor += TABBY_SPOT;\n        \n        col = spot < 0.? spotColor : col;\n    }\n    \n    // tabby stripes\n    if (cat.tabby == 1.)\n    {\n        float xSign = sign(p.x);\n        vec2 uv = p;\n        \n        if (rSign > 0.)\n        {\n            uv.x += mix(-2., -.05, aR);\n            uv = Rotate2D(uv, 25. * aR);\n        }\n        else if (rSign < 0.)\n        {\n            uv.x += mix(2., 0.5, aR);\n            uv = Rotate2D(uv, -50. * aR);\n        }\n        uv *= vec2(1., 8.);\n        float l = Circle(uv, 0.5);\n        l = min(l, Circle(uv + vec2(0., 1.5), 0.5));\n        l = min(l, Circle(uv - vec2(0, 1.5), 0.5));\n        col = l < 0.? cat.darkColor : col;\n    }\n}\nfloat SceneSDF(vec2 p, out vec3 col)\n{\n    Cat cat = GetCat(p);\n    p = fract(p * 2.) - 0.5;\n    #ifdef BIGGER\n    float scale = 4.;\n    p.y += 0.1;\n    #else\n     float scale = 4.5;\n    #endif\n    \n    vec2 bodyUV = p * scale;\n   \n    col = mix(cat.baseColor, cat.baseColor * 1.2, dot(bodyUV, bodyUV) * 0.5 + 0.5);\n    cat.rotation += mix(-10., 10., cos(iTime * 0.2 * cat.f + (cat.f * 2. - 1.)) * 0.5 + 0.5);\n    bodyUV = Rotate2D(bodyUV, cat.rotation);\n    float sdf = UnevenCapsule(bodyUV, cat.butt, 0.5, cat.height);\n\n    BackPattern(bodyUV, cat, col);\n\n    vec2 bellyUV = bodyUV;\n    bellyUV.y += sin(bodyUV.x * 75.) * 0.025;\n    float b = InvLerp(-90., 90., cat.rotation);\n    float bX = 0.75;\n    bellyUV.x += mix(-bX, bX, b);\n    bellyUV.y += mix(-0.1, 0.1, b);\n    float width = mix(0.7, 0.5, abs(b * 2. - 1.));\n    float belly = UnevenCapsule(bellyUV * 1.5, width, 0.5, cat.height) - 0.2;\n    col = mix(col, cat.belly, Smooth(belly));\n    col = DoOutline(sdf, col, OUTLINE_THICKNESS, cat.outlineColor);\n\n    // head casting shadow on the body\n    float shadow = Circle(bodyUV - vec2(0., cat.height * 1.1), 0.5);\n    col = shadow < 0.? col * 0.9 : col;\n\n    vec3 headCol;\n    float headSDF = Head(bodyUV, cat, headCol);\n    col = headSDF < 0.? headCol : col;\n    sdf = min(sdf, headSDF);\n\n    float tail = Tail(p * scale, cat);\n    vec3 tailCol = DoOutline(tail, cat.baseColor, OUTLINE_THICKNESS, cat.outlineColor);\n    col = sdf < 0.? col : tailCol;\n    sdf = min(sdf, tail);\n    \n    // body casting shadow on the floor\n    vec2 sUV = Rotate2D(bodyUV, -cat.rotation);\n    sUV = sUV * vec2(1., 3.) + vec2(0., 1.7);\n    shadow = Circle(sUV, 1.);\n    vec3 shadowCol = mix(vec3(1.), vec3(0.7), \n        (1. - smoothstep(-0.5, -0.001, shadow)));\n    col = sdf < 0.? col : shadowCol;\n    sdf = min(sdf, shadow);\n\n    return sdf;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p.x += (iTime + 3000.) * 0.25;\n    #ifdef BIGGER\n        // adjusting for how it looks different in shadertoy \n        // than from VSCode where I authored this...\n        p *= 0.5;\n        p.y += 0.01;\n    #else\n        p.y += 0.025;\n    #endif\n\n    vec3 col = vec3(1.);\n    vec3 fg = vec3(0.);\n    \n    float sdf = SceneSDF(p, fg);\n    col = sdf < 0.? fg : col;\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lcyz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2189, 2189, 2219, 2219, 2301], [2302, 2302, 2334, 2334, 2379], [2380, 2380, 2449, 2449, 2616], [2617, 2617, 2670, 2670, 2713], [2714, 2714, 2773, 2773, 2951], [2952, 2952, 2999, 2999, 3115], [3116, 3190, 3215, 3215, 3234], [3235, 3235, 3260, 3260, 3279], [3280, 3280, 3306, 3306, 3526], [3527, 3527, 3587, 3587, 3826], [3827, 3827, 3856, 3856, 4067], [4068, 4068, 4109, 4109, 4417], [4418, 4418, 4468, 4468, 4741], [4742, 4742, 4775, 4775, 4803], [4804, 4804, 4830, 4830, 4960], [7228, 7228, 7253, 7253, 7298], [7299, 7299, 7328, 7328, 7657], [7658, 7658, 7688, 7688, 7779], [7780, 7780, 7832, 7832, 9286], [9287, 9287, 9336, 9336, 10426], [10427, 10427, 10470, 10470, 13497], [13498, 13498, 13528, 13528, 14254], [14255, 14255, 14306, 14306, 15652], [15653, 15653, 15691, 15691, 17488], [17489, 17489, 17546, 17546, 18000]], "test": "untested"}
{"id": "slcyR8", "name": "subtly stylized circular bokeh", "author": "vinvinvin", "description": "hmmm", "tags": ["blur", "bokeh"], "likes": 2, "viewed": 276, "published": 3, "date": "1659215154", "time_retrieved": "2024-07-30T16:37:45.761252", "image_code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n\n    return nUv;\n    \n} \n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\nvec2 barrelDistortion(vec2 coord, float amt) {\n\tvec2 cc = coord - 0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord + cc * dist * amt;\n}\n\nvec4 spectrum_offset( float t ) {\n\tvec4 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\n\treturn pow( ret, vec4(1.0/2.2) );\n}\n\n//Vignette parameters:\n\n//Inner radius\n#define inner .5\n//Outer radius\n#define outer 1.2\n//Vignette strength/intensity\n#define strength .3\n//Vignette roundness, higher = smoother, lower = sharper\n#define curvature .9\n//=============//\n // Final Blend //\n//=============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 uv = coord / iResolution.xy;\n    \n    vec4 original = texture(iChannel0, uv);\n    \n    uv = scale_uv(uv, vec2(RENDER_SCALE), vec2(0.5));\n    // vec4 blurred = texture(iChannel1, uv);\n    // blurred = pow(blurred, vec4(1.0 / GAMMA));\n        \n    float k = DISTORT_AMOUNT;\n    float kcube = 0.0;\n    \n    // float offset = .1 * sin( iTime * .5 );\n    \n    uv = ((uv - 0.5) * (1.0 - (ZOOM_AMOUNT))) + 0.5;\n    vec4 blurred = texture( iChannel1, computeDistortedUV( uv, k, kcube ) );\n        \n    const int num_iter = 12;\n    const float reci_num_iter_f = 1.0 / float(num_iter);\n    // We want to tone down the chromatic abberation on higher resolutions\n    float max_distort = 0.15 * TO_1_AMOUNT * (1120.0 / iResolution.x);\n    \n\tvec4 sumcol = vec4(0.0);\n\tvec4 sumw = vec4(0.0);\t\n\tfor ( int i=0; i<num_iter;++i )\n\t{\n\t\tfloat t = float(i) * reci_num_iter_f;\n\t\tvec4 w = spectrum_offset(t);\n\t\tsumw += w;\n\t\t// sumcol += w * texture( iChannel0, uv );\n        sumcol += w * texture( iChannel1, barrelDistortion(computeDistortedUV( uv, k, kcube ), .6 * max_distort*t ));\n\t}\t\n\tblurred = sumcol / sumw;\n    // blurred = pow(blurred, vec4(1.0 / (ADJUSTED_GAMMA * 2.5)));\n    blurred = pow(blurred, vec4(1.0 / ADJUSTED_GAMMA));\n    \n    color = blurred;//mix(original, blurred, 1.0);\n\n    \n        \n    //Calculate edge curvature\n    vec2 curve = pow(abs(uv*2.-1.),vec2(1./curvature));\n    //Compute distance to edge\n    float edge = pow(length(curve),curvature);\n    //Compute vignette gradient and intensity\n    float vignette = 1.-strength*(TO_1_AMOUNT)*smoothstep(inner,outer,edge);\n    \n    //Add vignette to the resulting texture\n    color.rgb *= vignette;\n    //color = texture(iChannel2, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    Doom 2016 does a fast real-time Bokeh\n    where the half-resolution framebuffer\n    is blurred with a circular average\n    (tapped fragments in a circular pattern,\n    no Gaussian used) and then a second blur\n    is performed where the colours are\n    blended with a colour \"max\" operation\n    (brightest RGB components kept).\n*/\n\n  //========//\n // Macros //\n//========//\n\n#define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 5.0 : 3.1)\n#define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.0 : 0.0)\n#define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.05 : 0.05)\n#define TO_1_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.0)\n// #define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.8 : 1.8)\n// #define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.2)\n// #define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.25 : 0.25)\n\n  //===========//\n // Constants //\n//===========//\n\nconst float PI = 3.14159;\nconst float GAMMA = 4.5;\n\n//#define ADJUSTED_GAMMA (iMouse.z > 0.0 ? GAMMA * (1.0 - (pow((iMouse.x / iResolution.x), 0.5) * 0.4)) : GAMMA)\n#define ADJUSTED_GAMMA GAMMA\n// We adjust the gamma on pass \nconst float PASS_2_GAMMA_DENOM = 0.2;\n// Make the effect of larger side swirls decrease with increased size\n#define SWIRL_SIZE_EXP (-0.9 * pow(max((3.0 - BLUR_AMOUNT) / 3.0, 0.0), 1.5))\n\n\nconst float RENDER_SCALE = 0.25;\n//const float BLUR_AMOUNT = 1.0;\n\nconst int BOX_BLUR_SAMPLES = 1;\nconst float BOKEH_ASPECT_RATIO = 1.25;\nconst vec2 BOX_BLUR_SCALE = vec2(2);\nconst vec2 BOX_BLUR_OFFSET = float(BOX_BLUR_SAMPLES / 2) * BOX_BLUR_SCALE;\nconst float BOX_BLUR_ACCUM = 1.0 / float(BOX_BLUR_SAMPLES);\n\nconst float GoldenAngle = 2.39996323;\n\n// more is better quality\nconst float Iterations = 200.0;\n\nconst mat2 Rotation = mat2(\n    cos(GoldenAngle),\n    sin(GoldenAngle),\n   -sin(GoldenAngle),\n    cos(GoldenAngle)\n);\n\n  //===========//\n // Functions //\n//===========//\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvec4 box_blur(sampler2D sp, vec2 uv, vec2 dir) {\n\tvec4 result = vec4(0.0);\n    uv -= dir * BOX_BLUR_OFFSET;\n    \n    for (int i = 0; i < BOX_BLUR_SAMPLES; ++i) {\n        result += texture(sp, uv);\n        uv += dir * BOX_BLUR_SCALE;\n    }\n    result *= vec4(BOX_BLUR_ACCUM);\n    \n    return result;\n}\n\n", "buffer_a_code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n    nUv.y = 1. - nUv.y;\n \n    return nUv; \n}\n\n\n //===============//\n // Preprocessing //\n//===============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    uv = scale_uv(uv, vec2(1.0 / RENDER_SCALE), vec2(0.5));\n    \n\tcolor = texture( iChannel0, uv );\n    \n    // vec2 uv=(gl_FragCoord.xy/resolution.xy*.5)+.25;\n\n    \n    // vinhowe: threshold some highlights. a lot of this is just guessing and trying things.\n    \n    float luminance = 0.2126*color.r + 0.7152*color.g + 0.0722*color.b;\n    if (luminance > 0.8) {\n        color = mix(color, pow(color, 1.0 / vec4(1.4)), min(BLUR_AMOUNT / 0.8, 1.0));\n    }\n    color = pow(color, vec4(ADJUSTED_GAMMA));\n    \n   \n\n    // float mixValue = ZOOM_AMOUNT;\n    // color.rgb *= max(1.0 - mixValue, 0.0);\n    // color.rgb += vec3(0.1, 0.1, 0.1) * mixValue;\n    // color.rgb = min((color.rgb * (1.0 + (ZOOM_AMOUNT * 30.0))) + (ZOOM_AMOUNT * 0.1), vec3(1.0, 1.0, 1.0));\n    // color.rgb = mix(color.rgb, vec3(0.05, 0.05, 1.0), max(min(((0.5-uv.y) + 0.5)*ZOOM_AMOUNT, 1.0), 0.0));\n    // color.b *= 1.0 + (ZOOM_AMOUNT * 1.0);\n    // color.rgb += vec3(0.05, 0.05, 0.06) * ZOOM_AMOUNT;\n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "  //=================//\n // First Blur Pass //\n//=================//\n\nconst vec2 OFFSETS[] = vec2[](\n    vec2(0.0, 0.0),\n    vec2(1.5, 0.0),\n    vec2(0.46, 1.43),\n    vec2(-1.21, 0.88),\n    vec2(-1.21, -0.88),\n    vec2(0.46, -1.43),\n    vec2(3.0, 0.0),\n    vec2(2.43, 1.76),\n    vec2(0.93, 2.85),\n    vec2(-0.93, 2.85),\n    vec2(-2.43, 1.76),\n    vec2(-3.0, 0.0),\n    vec2(-2.43, -1.76),\n    vec2(-0.93, -2.85),\n    vec2(0.93, -2.85),\n    vec2(2.43, -1.76)\n);\n\nvec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n \n    return nUv; \n}\n\nconst float SCALE = 1.5;\n//const float Iterations = 500.0;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //color = box_blur(iChannel0,BOKEH ASPECT_RATIO, 1/BOKEH ASPECT_RATIO) uv, vec2(ps.x, 0));\n    \n    color = vec4(0);\n    \n    float rec = 1.0; // reciprocal \n    \n    float radius = 200.0;\n    vec2 horizontalAngle = vec2(0.0, radius * 0.01 / sqrt(Iterations));\n    \n    for (float i = 0.0; i < Iterations; ++i) {\n        rec += 1.0 / rec;\n        \n\t    horizontalAngle = horizontalAngle * Rotation;\n        \n        vec2 offset = (rec - 1.0) * horizontalAngle;\n        vec2 offsetWithScaling = offset * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        vec2 distortedOffset = offsetWithScaling * vec2(1.0*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);\n       \n        // Make bokeh near the edges thinner\n        //vec2 offsetWithRatio = OFFSETS[i] * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        //vec2 offset = offsetWithRatio * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);\n        \n        float offsetLength = length(offset);\n        float distortedOffsetLength = length(distortedOffset);\n        // float baseOffsetLength = length(OFFSETS[i]);\n        float distortedOffsetAngle = atan(distortedOffset.y, distortedOffset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - abs(distortedOffset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = distortedOffsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\n        float normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);\n        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - distortedOffsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = distortedOffsetAngle + minLength * normalizedCenterDist;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * distortedOffsetLength;\n        // vec2 adjustedOffset = mix(offset, vec2(cos(newAngle), sin(newAngle))*offsetLength, distortedLength*0.1);\n        \n        // adjustedOffset = offset;\n\n        // if (baseOffsetLength > 3.0) {\n        //     color += texture(iChannel0, (coord + offset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n        // } else {\n        // \n        // }\n        //color += texture(iChannel0, (coord + offset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps) * (0.5 + (1.5 * pow(baseOffsetLength/3.0, 10.0)));\n        \n        color += texture(iChannel0, (coord + adjustedOffset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps) * (1.0 + (0.4 * pow(offsetLength/2.0, 4.0)));\n        // color += texture(iChannel0, (coord + distortedOffset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n    }\n\tcolor /= Iterations;\n   \n    // color = pow(color, vec4(ADJUSTED_GAMMA));\n    color.a = 1.0;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "  //==================//\n // Third Blur Pass //\n//==================//\n\nconst vec2 OFFSETS[] = vec2[](\n\tvec2(1, 1),\n    vec2(-1, 1),\n    vec2(1, -1),\n    vec2(-1, -1)\n);\n\nconst float SCALE = 0.12;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //coord = scale_uv(coord, vec2(0.5), iResolution.xy * 0.5);\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        vec2 c = coord;\n       \n        c += OFFSETS[i] * SCALE * BLUR_AMOUNT;\n        c *= ps;\n        color = max(color, texture(iChannel0, c));\n    }\n    \n    color.a = 1.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slcyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 313], [316, 316, 338, 338, 370], [372, 372, 398, 398, 441], [443, 443, 485, 485, 521], [523, 523, 569, 569, 655], [657, 657, 690, 690, 892], [1167, 1167, 1211, 1211, 2906]], "test": "untested"}
{"id": "7tdyRr", "name": "Day 954", "author": "jeyko", "description": "shoutout tater for his awesum pixel art stuff which i got inspired by", "tags": ["pixelart", "mdtmjvm"], "likes": 44, "viewed": 632, "published": 3, "date": "1659210218", "time_retrieved": "2024-07-30T16:37:46.515236", "image_code": "#define R iResolution.xy\n\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// from iq\nvec3 hsv2rgbSmooth( in vec3 hsv )\n{\n    vec3 rgb = clamp( abs(mod(hsv.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n    rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n    return hsv.z * mix( vec3(1.0), rgb, hsv.y);\n}\n\n\n#define iTime (iTime + 4.*iMouse.x/iResolution.x)\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = (U - 0.5*R.xy)/max(R.x,R.y);\n\n    vec3 col = vec3(0);\n    \n    float res =3./max(R.x,R.y);\n    \n    \n    vec2 p = uv;\n    p = uv;\n\n    float scroll = iTime*0.1;\n    float pan = sin(iTime*0.6 + sin(iTime*0.5))*0.05 - 0.1;\n    pan += (iMouse.y/iResolution.y - 0.5)*0.;\n    \n    p.x += scroll;\n    p.y += pan;\n    \n    vec2 op = p;\n\n    vec2 pid = floor(p/res);\n    p = floor(p/res)*res;       \n    float dith = texelFetch(iChannel0,ivec2(pid)%8,0).x;\n        \n    // sky\n    {\n \n        \n        vec3 skyCol = vec3(1.,0.7,0.4)*0.9;\n        vec3 skyColb = vec3(0.1,0.4,0.5)*1.2;\n        \n        //float dith = texture(iChannel0,);\n        \n        col = mix(skyCol,vec3(1.4,0.7,0.5)*0.7,step(0.7-p.y*15. + 0.5*noise(vec3(p.x,4,4))*0.1,dith));\n        col = mix(col,vec3(1.,0.4,0.3)*0.8,step(1.4-p.y*10. + 0.5*noise(vec3(p.x,4,4))*0.1,dith));\n        col = rgb2hsv(col);\n        \n        col = hsv2rgbSmooth(col + vec3(0,-0.1,0));\n        //col = mix(col,skyColb,step(1.2-p.y*15. + 0.5*noise(vec3(p.x,4,4))*0.1,dith));\n        \n        //col = dith*vec3(1);\n        //col = mix(skyCol,skyColb,p.y*2. + 0.5*noise(vec3(p.x,4,4))*0.1);\n    }\n    float sdl = p.y + noise(vec3(p.x,4. + p.x,4))*0. + 0.1;\n    if(sdl < 0. + mod(pid.x*0.1 + r21(vec2(pid.x*0.1,40.))*0.,2.)*0.003){\n        col = vec3(0.45,0.42,0.5) + 0.;\n    }     \n    // Clouds\n    {\n        \n        for(float i = 0.; i < 56.; i++){\n            vec2 cpos = vec2(\n                    - mod(\n                        i*12.6\n                        + .05*iTime*max(abs(sin(i + sin(i*20.)*4. + 200.)),0.8)*1.05\n                        + scroll*0. \n                        ,2.\n                    )*2.\n                    + 2. + scroll\n                ,cos(i*20.)*0.1 + 0.07);\n            vec2 lcpos = cpos - p;\n            float d = length(lcpos.y) + abs(lcpos.y)*0.9;\n            d += smoothstep(0.,4.,abs(lcpos.x));\n            d += noise(vec3(lcpos.x*2. + i*120.,4. + i,4. + p.y))*0.05;\n            //d -= noise(vec3(lcpos.x*4. + i*120.,4. + i,4. + p.y))*0.01;\n            //if(d < 0.00)\n                //col = mix(col,col*3.*vec3(0.2,0.15,0.25)*(1. + sin(i*3.)*0.1),0.4 + sin(i*20.)*0.1);\n            if(d < 0.00)\n                col = mix(col,vec3(1.2,0.7,0.6)*0.8,0.6);\n        \n        }\n    \n    }\n    \n    vec3 rocks = vec3(0);\n    float minDrocks = 10e6;\n    // props\n    \n    {\n            \n        for(float i = 0.; i < 50.; i++){\n            vec2 lp = p + vec2(0,pan*0.4);\n            lp.x -= 2. + sin(i)*4.;\n            lp.x = mod(lp.x,4.) - 2.;\n            lp.y += 0.45 + sin(i*200.)*0.05;\n            float sdplank = length(lp);\n            sdplank = max(sdplank,-lp.y + 0.02);\n            \n            sdplank -= abs(noiseGrid(vec3(lp*120. + i*20.,15.)))*0.004 + abs(sin(i*15.))*0.02;\n            minDrocks = min(minDrocks,sdplank + max(lp.y*1. -0.01,0.));\n            if(sdplank < 0.004 ){\n                rocks = mix(\n                    vec3(0.34,0.35,0.4),\n                    vec3(0.1)*2.,\n                    1.-step(\n                        clamp(dot(lp,normalize(vec2(1,-1)))*44.+0.4,0.,1.),\n                        dith\n                    )\n                );\n            }\n        }\n        \n        \n        \n    \n    }\n        \n    \n    // ground\n    \n    {\n\n\n            float griters = 40.;\n            vec2 lastp = p;\n            \n            for(float i = 0.; i <= griters; i++){\n                \n                float sc = pow(i/griters,4.);\n                p = lastp;\n                p.y += sc*pan*0.4;\n                p.x += (1.-sc)*iTime*0.004;\n                \n                //vec2 offs = vec2(0,pan);\n                \n                //vec2 lp = p;\n                //vec2 lpid = floor(p/res);\n                //lp = floor(lp/res)*res;    \n                \n                \n                //p.x += iTime*0.2*0.003;\n                //pid = floor(p/res);\n                //p = floor(p/res)*res;\n                \n                float iterscale = smoothstep(1.,0.7,i/griters);\n    \n                float n = noise(vec3(p.x*(1. + 1.*abs(sin(i*20.))),1. + i * 20.,4. + i))*0.1*sin(i*10.+iTime*float(iMouse.z>0.))*iterscale;\n                float lsd = p.y*1. + n + i/griters*0.2 + 0.14;\n                float idx = i/griters;\n                float grass = mod(pid.x + r21(vec2(i*20. + pid.x,40.))*4.,2.)*0.01*sin(i)*smoothstep(0.4,1.,idx);\n                float fade = (1. - idx);\n                if(lsd < 0. + grass){\n                    vec3 grcol = (vec3(0.4,0.34,0.1) - 0.1*sin(vec3(0.2,0.4,41.3) + i));\n                    grcol = mix(grcol,vec3(0.3,0.3,0.5), pow(fade,2.4));\n                    float grass = mod(pid.x + r21(vec2(pid.x))*1., 2.)*0.3*(idx);\n                    \n                    float dn = noise(vec3(p.x*2.,1. + p.y*6. + n*4. + i*20.,4. + i*20.)) + grass;\n                    \n                    grcol *= 1.\n                        - vec3(0.6,0.8,0.6)*0.2*step(dn,0.5) \n                        - vec3(0.6,0.4,0.5)*0.3*step(dn + 0.9 - grass*0.7*(1.-iterscale) + n*20.,0.1)*(sc*0.6 + 0.4)\n                        - smoothstep(0.02,0.,minDrocks)*0.4\n                        //- step(minDrocks,0.007)*0.4\n                        \n                        ;\n                    \n                    col = grcol;\n                }\n            }\n    }\n    \n    col = mix(col,rocks,float(rocks.x!=0.));\n    col = rgb2hsv(col);\n    \n    \n    float t = iTime + 10.;\n    float tt = 10.;\n    float tid = floor(t/tt);\n    float T = mod(t,tt);\n    float tenv = clamp(T,0.,1.);\n    \n    \n    float a = -0.4;\n    float b = 0.;\n    float v = mod(tid,2.) == 0. ? mix(a,b,tenv) : mix(b,a,tenv);\n        \n    col = hsv2rgbSmooth(col + vec3(0,v,-0.04));\n    \n    \n    \n    col = pow(abs(col),vec3(0.8));\n\n    C = vec4(col,1);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdBox(vec2 c, vec2 s){\n    c = abs(c) - s; return max(c.x,c.y);\n}\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define pmod(p,a) mod(p,a) - 0.5*a\n// Dave hoskins hash without sine\nfloat r21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// cyclic noise by nimitz. i have a tutorial on it on shadertoy\n\nfloat noise(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    p.xy *= rot(1.4);\n    p.x *= 3.;\n    for(float i = 0.; i < 12.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(1.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.7;\n        p *= 1.5;\n    }\n    \n    //n = n * 0.9;\n    n = sin(n*2.);\n    return n;\n}\nfloat noiseGrid(vec3 p_){\n    float n = 0.;\n    float amp = 1.;\n    vec4 p = vec4(p_,11.);\n    for(float i = 0.; i <2.; i++){\n        p.yz *= rot(.5);\n        p.xz *= rot(2.5 + i);\n        p.wy *= rot(2.5-i);\n        p += cos(p*1. + vec4(3,2,1,1.) )*amp*.5;\n        n += dot(sin(p),cos(p))*amp;\n    \n        amp *= 0.5;\n        p *= 1.5;\n    }\n    \n    //n = sin(n*1.);\n    return n;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tdyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 379], [380, 391, 426, 426, 615], [668, 668, 708, 708, 6446]], "test": "untested"}
{"id": "sdVfD3", "name": "Raymarched Terrain with Water", "author": "SpinningCube", "description": "Raymarched terrain with realistic looking water which reflects and refracts light. Click and drag to rotate the camera.", "tags": ["3d", "raymarching", "reflection", "terrain", "refraction", "water"], "likes": 8, "viewed": 301, "published": 3, "date": "1659202916", "time_retrieved": "2024-07-30T16:37:47.587369", "image_code": "/*\n * Terrain Raymarching\n * \n * Uses raymarching to render procedurally generated terrain.\n * Includes water, which realistically reflects and refracts light.\n * \n * \n * by SpinningCube\n * \n */\n\nconst float baseEpsilon = 0.1;\nfloat epsilon = baseEpsilon;\nconst int maxSteps = 600;\nconst float renderDistance = 2000.;\nconst float waterLevel = 15.;\nconst float pi = 3.1415926536;\nconst vec3 sunDir = vec3(1.5, .7, -0.2);\n\nint stepCount = 0;\nfloat lastDist = 0.;\nfloat depth = 0.;\nint material = 0;\nbool disableWater = false;\n\nfloat sphereSDF(vec3 samplePos, vec3 pos, float radius) {\n    return distance(samplePos, pos) - radius;\n}\n\nfloat groundSDF(vec3 samplePos, float y) {\n    return samplePos.y - y;\n}\n\nfloat planeSDF(vec3 samplePos, float y) {\n    return abs(samplePos.y - y) - 2. * epsilon;\n}\n\nfloat smoothmax(float a, float b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + k));\n}\n\nvec3 smoothmax(vec3 a, vec3 b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + vec3(k)));\n}\n\nvec4 smoothmax(vec4 a, vec4 b, float k) {\n    return 0.5 * (a + b + sqrt((a - b) * (a - b) + vec4(k)));\n}\n\nvec4 textureCubicLod(sampler2D sampler, vec3 res, vec2 uv, float LOD) {\n    //return textureLod(sampler, uv, LOD);\n    uv = uv * res.xy + .5;\n    vec2 fractUV = fract(uv);\n    uv = (floor(uv) + fractUV * fractUV * (3. - 2.*fractUV) - 0.5)/res.xy;\n    return textureLod(sampler, uv, LOD);\n}\n\nvec4 myTexture(vec3 samplePos) {\n    samplePos += vec3(10., 0., 6.);\n    \n    samplePos += 50. * (textureLod(iChannel2, .0002 * samplePos.xz, 1.5).rgb - vec3(0.5));\n    \n    vec4 col = vec4(0.);\n    col += 10. * smoothmax(vec4(0.), textureLod(iChannel0, .0001 * samplePos.xz, 1.0) - .3, 0.03);\n    //col += 2. * textureLod(iChannel0, .0007 * samplePos.xz, 1.0);\n    col += 1. * textureLod(iChannel3, .002 * samplePos.xz, 1.0).rrrr;\n    col += 0.02 * textureCubicLod(iChannel0, iChannelResolution[0], .01 * samplePos.xz, 1.0);\n    col += 0.005 * textureCubicLod(iChannel0, iChannelResolution[0], .03 * samplePos.xz, 1.0);\n    col = .7 * pow(col, vec4(1.3)) + .2;\n    return col;\n    //return textureCubicLod(iChannel0, iChannelResolution[0], .01 * samplePos.xz, 1.0) + 0.0 * textureLod(iChannel0, .5 * samplePos.xz, 1.0);\n}\n\nfloat terrainHeight(vec3 samplePos) {\n    return 20. * myTexture(samplePos).r;\n}\n\nfloat distToScene(vec3 samplePos, float maxDist) {\n    material = 0;\n    float dist = maxDist;\n    dist = min(dist, sphereSDF(samplePos, vec3(0., -3., 35.), 3.) );\n    \n    float height = terrainHeight(samplePos);\n    dist = min(dist, groundSDF(samplePos, height));\n    \n    float water;\n    if (!disableWater) {\n        float waterNoise = 0.0;\n        float scale = 0.07;\n        float magnitude = 1.0;\n        for (int i = 0; i < 3; i++) {\n            waterNoise += magnitude * textureLod(iChannel2, scale * samplePos.xz, 3.0).r;\n            magnitude *= 0.7;\n            scale *= 2.1;\n        }\n        water = groundSDF(samplePos, waterLevel + 0.1 * waterNoise);\n        dist = min(dist, water);\n    }\n    material = int(dist == water);\n    return dist;\n}\n\n// Tetrahedron sampling technique by IQ\nvec3 calcNormal( vec3 p, float epsilon )\n{\n    float h = 2.5 * epsilon;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * distToScene( p + k.xyy*h, renderDistance ) + \n                      k.yyx * distToScene( p + k.yyx*h, renderDistance ) + \n                      k.yxy * distToScene( p + k.yxy*h, renderDistance ) + \n                      k.xxx * distToScene( p + k.xxx*h, renderDistance ));\n}\n\nvec4 castRay(vec3 rayOrigin, vec3 rayDir, float renderDist) {\n    vec3 rayPos;\n    float rayLength = 0.;\n    float stepSize = 10. * epsilon;\n    float smallStepSize = .25 * epsilon;\n    stepCount = 0;\n    for (int i = 0; i < maxSteps; i++) {\n        rayPos = rayOrigin + rayDir * rayLength;\n        \n        float dist = distToScene(rayPos, renderDist);\n        if (dist < epsilon) {\n            if (dist <= 0.) {\n                /*dist = distToScene(rayPos, renderDist);\n                rayLength += max(-stepSize, dist);\n                rayPos = rayOrigin + rayDir * rayLength;/**/\n                for (int j = 0; j < 100; j++) {\n                    if (dist > .5 * epsilon) {\n                        lastDist = dist;\n                        depth = rayLength;\n                        return vec4(1., rayPos);\n                    }\n                    rayLength -= smallStepSize * length(rayDir);\n                    rayPos = rayOrigin + rayDir * rayLength;\n                    dist = distToScene(rayPos, renderDist);\n                    smallStepSize += 1. * smallStepSize;\n                }/**/\n            }\n            lastDist = dist;\n            depth = rayLength;\n            return vec4(1., rayPos);\n        }\n        \n        rayLength += min(stepSize * length(rayDir), dist);\n        \n        if (rayLength >= renderDist) {\n            return vec4(0.);\n        }\n        \n        stepCount += int(dist < .5);\n        stepSize += 0.008 * stepSize * stepSize;\n    }\n    depth = rayLength;\n    return vec4(0.);\n}\n\n// Average sky color\nvec3 ambient(vec3 normal) {\n    return mix(1.5 * vec3(0.16, .5, 0.15), 2. * vec3(0.15, 0.45, 1.), normal.y * 0.5 + 0.5);\n}\n\n// The sky\nvec3 sky(vec3 rayDir) {\n    vec3 sky = max(vec3(0.), ambient(vec3(0.0, 1.0, 0.0)) + 0.5 * (sqrt(0.5 * (rayDir.y + sqrt(rayDir.y*rayDir.y + 0.0001))) - 0.1) * vec3(-1.0, -1.7, -0.7));\n    float sunDot = max(0.0, dot(rayDir, normalize(sunDir)));\n    float sun = pow(sunDot, 3000.0);\n    float curveValue = 10000.0;\n    sun /= curveValue * (sun - 2.0) * sun + curveValue + 1.0;\n    sun *= 10000.0;\n    sun += 0.4 * pow(sunDot, 800.0);\n    sun += 0.2 * pow(sunDot, 200.0);\n    sun += 0.1 * pow(sunDot, 100.0);\n    sun += 0.2 * sunDot * sunDot * sunDot;\n    return 1. * sky + sun;\n}\n\nfloat fresnel(float IOR, float roughness, vec3 surfNormal, vec3 incoming) {\n    float F0 = (1. - IOR)/(1. + IOR);\n    F0 *= F0;\n    return F0 + (1. - roughness)*((1. - F0) * pow(1. - dot(surfNormal, incoming),5.));\n}\n\nvec3 combineLighting(vec3 normal, vec4 rayData, vec3 rayDir, vec3 lightDir, vec3 reflectionColor, vec3 refractionColor, float Material, int stepCount, float depth) {\n    vec3 surfPos = rayData.yzw;\n    \n    vec3 color;\n    color = 1.5 * myTexture(surfPos).rrr - 7.;\n    color = smoothmax(vec3(.85), color, .05);\n    color *= color;\n    //color = vec3(1.);\n    vec3 grass = vec3(0.17, .65, 0.17);\n    vec3 dirt = .55 * vec3(.15, .15, .1);\n    //color *= grass;\n    color = mix(dirt, 0.4 * grass, clamp(3. * (normal.y - .75), 0., 1.));\n    color = mix(color, vec3(0.), Material);\n    color *= texture(iChannel1, 0.1 * surfPos.xz).rrr;\n    \n    lightDir = normalize(lightDir);\n    float NdotL = max(0., dot(normal, lightDir));\n    vec3 directional = vec3(8.) * NdotL;\n    \n    float fogBlend = min(1., 0.0005 * depth);\n    fogBlend *= fogBlend;\n    \n    vec3 Ambient = sky(rayDir);\n    vec3 ambient = ambient(normal);\n    float AO = 1. / (1. + (.2 * float(stepCount)));\n    AO = sqrt(AO);\n    ambient *= AO;\n    \n    epsilon = 5. * baseEpsilon;\n    vec4 shadowRay = castRay(surfPos + epsilon * normal, lightDir, renderDistance) * vec4(1 - material, 1., 1., 1.);\n    directional *= 1. - shadowRay.x;\n    \n    vec3 halfway = normalize(lightDir - rayDir);\n    reflectionColor += 5000.0 * Material * NdotL * (1.0 - shadowRay.x) * pow(max(0.0, dot(normal, halfway)), 10000.0);\n    reflectionColor += 20.0 * Material * NdotL * (1.0 - shadowRay.x) * pow(max(0.0, dot(normal, halfway)), 2000.0);\n    \n    float roughness = 1. - Material;\n    float F = fresnel(1.333, roughness, normal, -rayDir);\n    \n    return mix(Ambient, max(mix(1.5 * color * (directional + ambient) + refractionColor, reflectionColor, F), vec3(0.)), max(0., rayData.x - fogBlend));\n}\n\nvec3 lighting(vec3 cam, vec3 normal, vec4 rayData, vec3 rayDir, float Material, int StepCount) {\n    \n    vec3 surfPos = rayData.yzw;\n    \n    vec3 reflDir = reflect(rayDir, normal);\n    vec3 reflectionColor = sky(rayDir);\n    vec3 refractionColor = vec3(0.);\n    \n    float Depth = depth;\n    \n    if (Material == 1.) {\n        vec3 refrDir = refract(rayDir, normal, 0.75);\n        //refrDir = rayDir; // Disable refraction\n        \n        disableWater = true;\n        epsilon = 2.5 * baseEpsilon;\n        vec4 refractionRay = castRay(surfPos, refrDir, renderDistance);\n        refractionColor = combineLighting(calcNormal(refractionRay.yzw, max(0.1, 0.001 * distance(rayData.yzw, cam))), refractionRay, refrDir, sunDir, reflectionColor, refractionColor, float(material), StepCount, depth);\n        refractionColor *= exp(vec3(0.8, 0.6, 0.5) * -depth);\n\n        epsilon = 2.5 * baseEpsilon;\n        vec4 reflectionRay = castRay(surfPos + epsilon * normal, reflDir, renderDistance);\n        \n        if (reflectionRay.x == 1.) {\n            reflectionColor = combineLighting(calcNormal(reflectionRay.yzw, max(0.1, 0.001 * distance(rayData.yzw, cam))), reflectionRay, reflDir, sunDir, reflectionColor, refractionColor, float(material), StepCount, depth);\n        } else {\n            reflectionColor = sky(reflDir);\n        }\n    }\n    \n    return combineLighting(normal, rayData, rayDir, sunDir, reflectionColor, refractionColor, Material, StepCount, Depth);\n}\n\nmat2 rotate(float a) {\n    float sinA = sin(a);\n    float cosA = cos(a);\n    return mat2(cosA, -sinA, sinA, cosA);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy - vec2(0.5);\n    if (mouse == vec2(-0.5)) {\n        mouse = vec2(0., -0.04);\n    }\n    \n    float speed = 100.;\n    float x = 0.2 * speed * iTime;\n    float z = speed * (iTime - 10.);\n    vec3 cam = vec3(x, max(25., terrainHeight(vec3(x, 0., z)) + 5.), z);\n    vec3 rayDir = vec3(uv, 1.);\n    rayDir = normalize(rayDir);\n    \n    // Mouse camera controls\n    rayDir.yz *= rotate(pi * -mouse.y);\n    rayDir.xz *= rotate(2.5 * pi * -mouse.x);\n    \n    vec4 rayData = castRay(cam, rayDir, renderDistance);\n    vec3 surfNormal = calcNormal(rayData.yzw, max(0.1, 0.001 * distance(rayData.yzw, cam)));\n    vec3 col;\n    \n    //col = rayData.x * .5 * (surfNormal * vec3(1., 1., -1.) + vec3(1.));\n    //col = vec3(stepCount)/100.;\n\n    col = lighting(cam, surfNormal, rayData, rayDir, float(material), stepCount);\n    \n    //col = lighting(surfNormal, rayData.yzw);\n    //col = myTexture(10. * uv.xyy).rrr;\n    //col = vec3(lastDist > 0.);\n    \n    \n    col = vec3(tanh(col.r), tanh(col.g), tanh(col.b)); // Lazy Tonemapping\n    col = pow(col, vec3(1./2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0); // Output to screen\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVfD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 525, 582, 582, 630], [632, 632, 674, 674, 704], [706, 706, 747, 747, 797], [799, 799, 843, 843, 901], [903, 903, 944, 944, 1008], [1010, 1010, 1051, 1051, 1115], [1117, 1117, 1188, 1231, 1406], [1408, 1408, 1440, 1440, 2230], [2232, 2232, 2269, 2269, 2312], [2314, 2314, 2364, 2364, 3073], [3075, 3115, 3157, 3157, 3522], [3524, 3524, 3585, 3585, 5045], [5047, 5068, 5095, 5095, 5190], [5192, 5203, 5226, 5226, 5780], [5782, 5782, 5857, 5857, 5998], [6000, 6000, 6165, 6165, 7744], [7746, 7746, 7842, 7842, 9207], [9209, 9209, 9231, 9231, 9325], [9327, 9327, 9384, 9384, 10620]], "test": "untested"}
{"id": "Nttczr", "name": "SimplePatternGen", "author": "eiffie", "description": "Writing on my phone. Debug text everywhere.", "tags": ["test"], "likes": 8, "viewed": 361, "published": 3, "date": "1659165688", "time_retrieved": "2024-07-30T16:37:48.584702", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\n  U*=U;\n  ivec2 i=ivec2(U);\n  float t=iTime*3.23,c=mod(float(fract(t)<.5?i.x^i.y:i.x|i.y)*floor(t),256.)/256.;\n\n  O = vec4(c,c,c,1.0);\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n    int t=samp>>4;t*=3;//int(.1814*float(samp));\n    t=(t*16/3|t*3)*(t>>12&t>>7)|(t>>5&t>>3);\n    return vec2( mod(float(t),256.)/1024.-.125 );\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nttczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 178]], "test": "untested"}
{"id": "fttcRn", "name": "Day 953 [Content Aware Scale]", "author": "jeyko", "description": "pota", "tags": ["photoshop", "mdtmjvm"], "likes": 9, "viewed": 500, "published": 3, "date": "1659116619", "time_retrieved": "2024-07-30T16:37:49.614947", "image_code": "//#define WORM_DBG \n//#define DERIV_DBG \n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    C = Td(uv);\n    #ifdef DERIV_DBG\n        C = Tb(uv);\n    #endif\n    #ifdef WORM_DBG\n        float wrm = texelFetch(iChannel2,ivec2(0,U.y),0).x;\n        if(abs(uv.x - wrm) < 0.002)\n            C -= 1.;\n    #endif\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define R iResolution.xy\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Ta(u) texture(iChannel0,u)\n#define Tb(u) texture(iChannel1,u)\n#define Tc(u) texture(iChannel2,u)\n#define Td(u) texture(iChannel3,u)\n\nfloat luma(vec4 color) {\n  return dot(color.rgb, vec3(0.299, 0.587, 0.114));\n}\n\nfloat hash11(float p){\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n", "buffer_a_code": "// Image\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    C = Ta(uv);\n    \n    //if(iFrame < 20)\n    //else {\n    \n        //C = Tb(uv);\n        //C = mix(Ta(uv), Tb(uv),0.1);\n    //}\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Deriv\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n\n    vec2 st = 2./R.xy;\n    \n    \n    C = vec4(\n        luma(Ta(uv + vec2(st.x,0))) - \n        luma(Ta(uv - vec2(st.x,0))) +\n        luma(Ta(uv + vec2(0,st.y))) - \n        luma(Ta(uv - vec2(0,st.y)))  \n    );\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Worm\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    //vec2 uv = U/R.xy*0.;\n\n    if(U.x < 1.){\n        \n        vec2 startp = vec2(hash11(iTime*110.1 + 20.)*1.,0);\n        startp *= 0.;\n        if(iMouse.z > 0.)\n            startp.x = iMouse.x/iResolution.x;\n        vec2 p = startp;\n        \n        vec2 prevHeadDir = vec2(0,1);\n        for(float y = 0.; y < R.y; y++){\n        \n            const float rotIters = 20.;\n            float minD = 1000.;\n            vec2 headDir = vec2(0);\n            \n            float headLen = (20. + sin(y + iTime)*20.*0.)/R.y;\n            \n            for(float rotIter = 0.; rotIter < rotIters; rotIter++){\n                float rotRad = 1.5 + sin(iTime)*1.;\n                rotRad *= 0.4;\n                vec2 dir = vec2(0,1) * rot( rotIter/rotIters*rotRad - rotRad*0.5) ;\n                vec2 lheadUv = p + dir* headLen;\n                float sampleD = Td(lheadUv).x;\n                \n                if(sampleD <= minD){\n                    minD = sampleD;\n                    headDir = dir;\n                }\n            }\n            \n            const bool smoot = true;\n            const float smoothAmt = 1.;\n            if(smoot){\n                headDir = mix(prevHeadDir,headDir,smoothAmt*abs(dot(prevHeadDir,headDir)));\n                headDir = normalize(headDir);\n            \n            }\n            prevHeadDir = headDir;\n            \n            // raymarching HAHAHA \n            float t = 0.;\n            vec2 rmDir = headDir;\n            vec2 rp = p;\n            {\n                rp.y = -1./R.y;\n                for(float i = 0.; i < 20.; i++){\n                    float d = rp.y;\n                    if(d > 0.){\n                        break;\n                    }\n                    d = abs(d);\n                    d *= 0.9;\n                    rp += rmDir*d;\n                    t += d;\n                }\n            }\n            \n            p.x = rp.x;\n            //p.x += t * rmDir.x*0.4;\n            //p.x += abs(sin(y*4.))*0.0004;\n            p.y += 1./R.y;\n            \n            \n            if(y == floor(U.y)){\n                C = vec4(p.x);\n                break;\n            }\n        }\n        \n    }\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// pixelsort?\n\nvoid mainImage( out vec4 C, in vec2 U ){\n    vec2 uv = U/R.xy;\n    \n    float x = Tc(uv*vec2(0,1)).x;\n    float wrm = texelFetch(iChannel2,ivec2(0,U.y),0).x;\n\n    if(uv.x < x && (iMouse.z > 0.))\n        C = mix(\n            Td(uv),\n            Td(uv - vec2(1./R.x,0)),\n            clamp(abs(uv.x - wrm)*R.x*0.2,0.,1.)\n            );\n    else\n        C = Td(uv);\n\n\n    if(iFrame < 2)\n        C = Ta(uv);\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fttcRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 82, 82, 327]], "test": "untested"}
{"id": "7l3yRn", "name": "PT workshop 7S: Path tracing", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 7: Implement path tracing using a loop over the path length.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 1, "viewed": 456, "published": 3, "date": "1659085686", "time_retrieved": "2024-07-30T16:37:50.698051", "image_code": "#define TRIANGLE_COUNT 30\n#define MAX_PATH_LENGTH 5\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];\n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);\n    vec3 solution = inverse(matrix) * (origin - v0);\n    out_t = solution.x;\n    vec2 barys = solution.yz;\n    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n    for (int i = 0; i != TRIANGLE_COUNT; ++i) {\n        float t;\n        if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {\n            out_t = t;\n            out_tri = tris[i];\n        }\n    }\n    return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n        direction -= 2.0 * dot(normal, direction) * normal;\n    return direction;\n}\n\n\n// Performs path tracing: It starts with the given ray. If this ray intersects\n// a triangle, a new random ray is traced iteratively, up to a fixed limit.\n// \\param origin The position at which the ray starts (x_j)\n// \\param direction The direction vector of the ray (omega_j)\n// \\param seed Needed for get_random_numbers()\n// \\return A noisy estimate of the reflected and emitted radiance at the point\n//         intersected by the ray (i.e. the color) (L_o(x))\nvec3 get_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    vec3 throughput_weight = vec3(1.0);\n    for (int i = 0; i != MAX_PATH_LENGTH; ++i) {\n        float t;\n        triangle_t tri;\n        if (ray_mesh_intersection(t, tri, origin, direction)) {\n            radiance += throughput_weight * tri.emission;\n            origin += t * direction;\n            direction = sample_hemisphere(get_random_numbers(seed), tri.normal);\n            throughput_weight *= tri.color * 2.0 * dot(tri.normal, direction);\n        }\n        else\n            break;\n    }\n    return radiance;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Perform path tracing with SAMPLE_COUNT paths\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l3yRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 618, 729, 729, 849], [1299, 1649, 1743, 1743, 2057], [2060, 2439, 2537, 2600, 13747], [13750, 13982, 14025, 14086, 14412], [14415, 14579, 14620, 14620, 14829], [14832, 14947, 15005, 15005, 15179], [15182, 15645, 15715, 15715, 16266], [16269, 16269, 16326, 16379, 17315]], "test": "untested"}
{"id": "sl3yRn", "name": "PT workshop 6S: Direct illum.", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 6: Rendering direct illumination using Monte Carlo integration and ray tracing.\nSolved\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 190, "published": 3, "date": "1659085372", "time_retrieved": "2024-07-30T16:37:51.629561", "image_code": "#define TRIANGLE_COUNT 30\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];\n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);\n    vec3 solution = inverse(matrix) * (origin - v0);\n    out_t = solution.x;\n    vec2 barys = solution.yz;\n    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n    for (int i = 0; i != TRIANGLE_COUNT; ++i) {\n        float t;\n        if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {\n            out_t = t;\n            out_tri = tris[i];\n        }\n    }\n    return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n        direction -= 2.0 * dot(normal, direction) * normal;\n    return direction;\n}\n\n\n// Computes the sum of emitted radiance and reflected radiance due to direct\n// illumination\n// \\param point The point being shaded (x)\n// \\param tri The triangle on which the point is located\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate with N=1 of the direct illumination (L_o(x))\nvec3 compute_direct_illumination(vec3 point, triangle_t tri, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    radiance += tri.emission;\n    vec3 direction = sample_hemisphere(get_random_numbers(seed), tri.normal);\n    vec3 throughput_weight = tri.color * 2.0 * dot(tri.normal, direction);\n    float t;\n    if (ray_mesh_intersection(t, tri, point, direction))\n        radiance += throughput_weight * tri.emission;\n    return radiance;\n}\n\n\n// Finds the triangle intersected by the given ray and performs shading without\n// global illumination.\n// \\param origin The position at which the ray starts\n// \\param direction The direction vector of the ray\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate of the reflected (direct only) and emitted\n//         radiance at the point intersected by the ray (i.e. the color)\nvec3 get_direct_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    float t;\n    triangle_t tri;\n    if (ray_mesh_intersection(t, tri, origin, direction))\n        return compute_direct_illumination(origin + t * direction, tri, seed);\n    else\n        return vec3(0.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Take the mean of SAMPLE_COUNT Monte Carlo estimates for direct\n    // illumination\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_direct_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl3yRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 592, 703, 703, 823], [1273, 1623, 1717, 1717, 2031], [2034, 2413, 2511, 2574, 13721], [13724, 13956, 13999, 14060, 14386], [14389, 14553, 14594, 14594, 14803], [14806, 14921, 14979, 14979, 15153], [15156, 15475, 15555, 15555, 15916], [15919, 16326, 16403, 16403, 16610], [16613, 16613, 16670, 16723, 17704]], "test": "untested"}
{"id": "7t3yRn", "name": "PT workshop 5S: Hemisphere samp.", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 5: Uniform sampling of a unit hemisphere.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 165, "published": 3, "date": "1659085257", "time_retrieved": "2024-07-30T16:37:52.484276", "image_code": "#define SAMPLE_COUNT 512\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    float z = 2.0 * random_numbers[1] - 1.0;\n    float phi = 2.0 * M_PI * random_numbers[0];\n    float x = cos(phi) * sqrt(1.0 - z * z);\n    float y = sin(phi) * sqrt(1.0 - z * z);\n    return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    vec3 direction = sample_sphere(random_numbers);\n    if (dot(normal, direction) < 0.0)\n        direction -= 2.0 * dot(normal, direction) * normal;\n    return direction;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Splat spherical samples as Gaussians\n    out_color.rgb = vec3(0.0);\n    vec3 sphere_camera_position = vec3(0.0, 3.2, 0.0);\n    uvec2 seed = uvec2(0xdeadbeef, 0xc0ffee);\n    for (int i = 0; i != SAMPLE_COUNT; ++i) {\n        vec3 normal = normalize(vec3(1.0, 2.0, 3.0));\n        vec3 dir = sample_hemisphere(get_random_numbers(seed), normal);\n        float gaussian = exp(-100000.0 * (1.0 - dot(ray_direction, normalize(dir - sphere_camera_position))));\n        out_color.rgb += 0.5 * vec3(gaussian);\n    }\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t3yRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 568, 679, 679, 799], [802, 1034, 1077, 1138, 1464], [1467, 1631, 1672, 1672, 1881], [1884, 1999, 2057, 2057, 2231], [2234, 2234, 2291, 2344, 3405]], "test": "untested"}
{"id": "Nlcczr", "name": "PT workshop 8: Progressive", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nThis shader adds progressive rendering to the final solution. Click Reset time after viewport changes.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 1, "viewed": 582, "published": 3, "date": "1659084708", "time_retrieved": "2024-07-30T16:37:53.486596", "image_code": "// Interesting things happen in Buffer A, this just displays the image\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    out_color = texture(iChannel0, pixel_coord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TRIANGLE_COUNT 30\n#define MAX_PATH_LENGTH 5\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n                                                                                                                                                                                                                                                    vec3 v0 = tri.positions[0];     mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);     vec3 solution = inverse(matrix) * (origin - v0);     out_t = solution.x;     vec2 barys = solution.yz;\n                                                                                                                                                                                                                                                    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n                                                                                                                                                                                                                                                    for (int i = 0; i != TRIANGLE_COUNT; ++i) {         float t;         if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {             out_t = t;             out_tri = tris[i];         }     }     return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n                                                                                                                                                                                                                                                    float z = 2.0 * random_numbers[1] - 1.0;     float phi = 2.0 * M_PI * random_numbers[0];     float x = cos(phi) * sqrt(1.0 - z * z);     float y = sin(phi) * sqrt(1.0 - z * z);     return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n                                                                                                                                                                                                                                                    vec3 direction = sample_sphere(random_numbers);     if (dot(normal, direction) < 0.0)         direction -= 2.0 * dot(normal, direction) * normal;     return direction;\n}\n\n\n// Performs path tracing: It starts with the given ray. If this ray intersects\n// a triangle, a new random ray is traced iteratively, up to a fixed limit.\n// \\param origin The position at which the ray starts (x_j)\n// \\param direction The direction vector of the ray (omega_j)\n// \\param seed Needed for get_random_numbers()\n// \\return A noisy estimate of the reflected and emitted radiance at the point\n//         intersected by the ray (i.e. the color) (L_o(x))\nvec3 get_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    vec3 throughput_weight = vec3(1.0);\n                                                                                                                                                                                                                                                    for (int i = 0; i != MAX_PATH_LENGTH; ++i) {         float t;         triangle_t tri;         if (ray_mesh_intersection(t, tri, origin, direction)) {             radiance += throughput_weight * tri.emission;             origin += t * direction;             direction = sample_hemisphere(get_random_numbers(seed), tri.normal);             throughput_weight *= tri.color * 2.0 * dot(tri.normal, direction);         }         else             break;     }\n    return radiance;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Perform path tracing with SAMPLE_COUNT paths\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    vec3 prev_color = texture(iChannel0, tex_coord).rgb;\n    float weight = 1.0 / float(iFrame + 1);\n    out_color.rgb = (1.0 - weight) * prev_color + weight * out_color.rgb;\n    out_color.a = 1.0;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nlcczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 71, 128, 128, 196]], "test": "untested"}
{"id": "flcczr", "name": "PT workshop 7: Path tracing", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 7: Implement path tracing using a loop over the path length.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 434, "published": 3, "date": "1659084458", "time_retrieved": "2024-07-30T16:37:54.662452", "image_code": "#define TRIANGLE_COUNT 30\n#define MAX_PATH_LENGTH 5\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n                                                                                                                                                                                                                                                    vec3 v0 = tri.positions[0];     mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);     vec3 solution = inverse(matrix) * (origin - v0);     out_t = solution.x;     vec2 barys = solution.yz;\n                                                                                                                                                                                                                                                    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n                                                                                                                                                                                                                                                    for (int i = 0; i != TRIANGLE_COUNT; ++i) {         float t;         if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {             out_t = t;             out_tri = tris[i];         }     }     return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n                                                                                                                                                                                                                                                    float z = 2.0 * random_numbers[1] - 1.0;     float phi = 2.0 * M_PI * random_numbers[0];     float x = cos(phi) * sqrt(1.0 - z * z);     float y = sin(phi) * sqrt(1.0 - z * z);     return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n                                                                                                                                                                                                                                                    vec3 direction = sample_sphere(random_numbers);     if (dot(normal, direction) < 0.0)         direction -= 2.0 * dot(normal, direction) * normal;     return direction;\n}\n\n\n// Performs path tracing: It starts with the given ray. If this ray intersects\n// a triangle, a new random ray is traced iteratively, up to a fixed limit.\n// \\param origin The position at which the ray starts (x_j)\n// \\param direction The direction vector of the ray (omega_j)\n// \\param seed Needed for get_random_numbers()\n// \\return A noisy estimate of the reflected and emitted radiance at the point\n//         intersected by the ray (i.e. the color) (L_o(x))\nvec3 get_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    vec3 throughput_weight = vec3(1.0);\n    // TODO\n    return radiance;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Perform path tracing with SAMPLE_COUNT paths\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flcczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 618, 729, 729, 1089], [1539, 1889, 1983, 1983, 2777], [2780, 3159, 3257, 3320, 14707], [14710, 14942, 14985, 15046, 15372], [15375, 15539, 15580, 15580, 16029], [16032, 16147, 16205, 16205, 16619], [16622, 17085, 17155, 17155, 17261], [17264, 17264, 17321, 17374, 18310]], "test": "untested"}
{"id": "fl3yzn", "name": "Fibonacci points on a sphere", "author": "dmemes", "description": "spherical Fibonacci points", "tags": ["sphere", "goldenratio", "fibonaccispiral", "orbitcamera"], "likes": 20, "viewed": 377, "published": 3, "date": "1659062618", "time_retrieved": "2024-07-30T16:37:55.523151", "image_code": "float stable_atan2(float y, float x) {\n\treturn x == 0.0 ? (y == 0.0 ? 0.0 : (y < 0.0 ? -PI/2.0 : PI/2.0)) : atan(y, x);\n}\nvec2 cartesian_to_spherical_uv(vec3 v) {\n\tfloat theta = stable_atan2(v[2], v[0]);\n\treturn vec2(theta/PI*.5 + .5, acos(clamp(v[1], -1.0, 1.0))/PI);\n}\nvec3 spherical_uv_to_cartesian(vec2 uv) {\n\tuv[0] = uv[0]*2.0 - 1.0;\n\tuv *= PI;\n\tfloat sinPhi = sin(uv[1]);\n\treturn vec3(sinPhi*cos(uv[0]), cos(uv[1]), sinPhi*sin(uv[0]));\n}\n\nfloat intersect_sphere(vec3 ro, vec3 rd, vec4 sph) {\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot(oc, rd);\n\tfloat c = dot(oc, oc) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif (h < 0.0) return -1.0;\n\treturn -b - sqrt(h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec3 dir = vec3(0,0,2.5);\n    dir.xy = (fragCoord + 0.5) / iResolution.xy * 2.0 - vec2(1);\n    dir.x *= iResolution.x / iResolution.y;\n    dir = normalize(dir);\n    \n    mat3 rot = euler_yx(load_camera(iChannel0).euler);\n    vec3 org = rot*vec3(0,0,-3);\n    dir = rot * dir;\n    \n    vec4 sph = vec4(0,0,0,1);\n    \n    float t = intersect_sphere(org, dir, sph);\n    if (t < 0.0) {\n        fragColor = vec4(0);\n    } else {\n        vec3 normal = normalize(org + dir*t - sph.xyz);\n        \n        vec2 q = floor(cartesian_to_spherical_uv(normal) * 32.0);\n        fragColor.rgb = vec3(mix(0.25, 0.5, mod(q.x + q.y, 2.0 )));\n        \n        float n = 16.0 + iTime*16.0;\n        float a = 0.0;\n        for (float i = 0.0; i < n; i++) {\n            vec3 f = fib_to_dir(i + 0.5, n);\n            f.y = -f.y;\n            \n            float c = cos(0.5*PI/sqrt(n));\n            float r = (max(0.0, dot(f, normal) - c)) / (1.0 - c);\n            a += r;\n        }\n        \n        fragColor.rgb = mix(fragColor.rgb, vec3(1,0.75,0.25), clamp(a*10.0, 0.0, 1.0));\n        \n        \n        // light\n        fragColor.rgb *= 0.1 + 0.9*max(0.0, dot(normal, normalize(vec3(0.75,1,-0.75))));\n    }\n    \n    \n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// spherical fibonacci from https://www.shadertoy.com/view/stVfWc\n\nconst float PI  = 3.1415926535897932384626433832795;\nconst float PHI = 1.6180339887498948482045868343656;\n\nfloat madfrac( float a,float b) { return a*b -floor(a*b); }\nvec2  madfrac( vec2  a,float b) { return a*b -floor(a*b); }\n\nfloat dir_to_fib(vec3 p, float n) {\n    float phi = min(atan(p.y, p.x), PI), cosTheta = p.z;\n    \n    float k  = max(2.0, floor( log(n * PI * sqrt(5.0) * (1.0 - cosTheta*cosTheta))/ log(PHI*PHI)));\n    float Fk = pow(PHI, k)/sqrt(5.0);\n    \n    vec2 F = vec2( round(Fk), round(Fk * PHI) );\n\n    vec2 ka = -2.0*F/n;\n    vec2 kb = 2.0*PI*madfrac(F+1.0, PHI-1.0) - 2.0*PI*(PHI-1.0);    \n    mat2 iB = mat2( ka.y, -ka.x, -kb.y, kb.x ) / (ka.y*kb.x - ka.x*kb.y);\n\n    vec2 c = floor( iB * vec2(phi, cosTheta - (1.0-1.0/n)));\n    float d = 8.0;\n    float j = 0.0;\n    for( int s=0; s<4; s++ ) {\n        vec2 uv = vec2( float(s-2*(s/2)), float(s/2) );\n        \n        float cosTheta = dot(ka, uv + c) + (1.0-1.0/n);\n        \n        cosTheta = clamp(cosTheta, -1.0, 1.0)*2.0 - cosTheta;\n        float i = floor(n*0.5 - cosTheta*n*0.5);\n        float phi = 2.0*PI*madfrac(i, PHI-1.0);\n        cosTheta = 1.0 - (2.0*i + 1.0)/n;\n        float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n        \n        vec3 q = vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n        float squaredDistance = dot(q-p, q-p);\n        if (squaredDistance < d) {\n            d = squaredDistance;\n            j = i;\n        }\n    }\n    return j;\n}\nvec3  fib_to_dir(float i, float n) {\n    float phi = 2.0*PI*madfrac(i,PHI);\n    float cosTheta = 1.0 - 2.0*(i + 0.5)/n;\n    float sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n    return vec3( cos(phi)*sinTheta, sin(phi)*sinTheta, cosTheta);\n}\n\n\n\n// Camera\n\nstruct Camera {\n    vec2 euler;\n    vec4 prev_mouse;\n};\nCamera load_camera(sampler2D channel) {\n    Camera camera;\n    vec4 p0 = texelFetch(channel, ivec2(0), 0);\n    camera.euler      = texelFetch(channel, ivec2(0,0), 0).xy;\n    camera.prev_mouse = texelFetch(channel, ivec2(1,0), 0);\n    return camera;\n}\n\nmat3 euler_yx(vec2 euler) {\n    vec2 sin_euler = sin(euler);\n    vec2 cos_euler = cos(euler);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, \n                     0.0,  cos_euler.x, sin_euler.x, \n                     0.0, -sin_euler.x, cos_euler.x);\n    mat3 rotY = mat3(cos_euler.y, 0.0, -sin_euler.y, \n                     0.0, 1.0, 0.0, \n                     sin_euler.y, 0.0,  cos_euler.y);    \n    return rotY * rotX;\n}", "buffer_d_code": "// Orbit camera\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 ipos = ivec2(fragCoord);\n    if (ipos.y == 0 && ipos.x < 2) {\n        Camera camera;\n        if (iFrame == 0) {\n            camera.euler = vec2(PI/4.0, 0);\n            camera.prev_mouse = iMouse;\n        } else\n            camera = load_camera(iChannel0);\n\n        if (iMouse.z > 0.0 && camera.prev_mouse.z > 0.0) {\n            vec2 d = ((iMouse.xy - camera.prev_mouse.xy) / iResolution.xy) * 1.5;\n            d.y = -d.y;\n            camera.euler += d.yx;\n        }\n        camera.prev_mouse = iMouse;\n        \n        if      (ipos.x == 0) fragColor = vec4(camera.euler, 0.0, 0.0);\n        else if (ipos.x == 1) fragColor = camera.prev_mouse;\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl3yzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 121], [122, 122, 162, 162, 270], [271, 271, 312, 312, 443], [445, 445, 497, 497, 655], [657, 657, 709, 709, 1961]], "test": "untested"}
{"id": "7sKfDd", "name": "generative art deco", "author": "morisil", "description": "Where to even start. I just emerged generative art deco. Something I've been dreaming of for a while, but wouldn't even know where to start. And it just popped up when I broke The Mathematics of Perception with non-euclidean geometry.", "tags": ["chromaticaberration", "study", "depthoffield", "focus"], "likes": 19, "viewed": 757, "published": 3, "date": "1659057098", "time_retrieved": "2024-07-30T16:38:00.873844", "image_code": "// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n// Music by Giovanni Sollima, L'invenzione del nero:\n// https://soundcloud.com/giovanni-sollima/linvenzione-del-nero\n\n// See also The Mathematics of Perception to check the ideas behind:\n// https://www.shadertoy.com/view/7sVBzK\n\nconst float SHAPE_SIZE = .618;\nconst float CHROMATIC_ABBERATION = .02;\nconst float ITERATIONS = 10.;\nconst float INITIAL_LUMA = .4;\n\nconst float PI = 3.14159265359;\nconst float TWO_PI = 6.28318530718;\n\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nfloat sdPolygon(in float angle, in float distance) {\n  float segment = TWO_PI / 4.0;\n  return cos(floor(.5 + angle / segment) * segment - angle) * distance;\n}\n\nfloat getColorComponent(in vec2 st, in float modScale, in float blur) {\n    vec2 modSt = mod(st, 1. / modScale) * modScale * 2. - 1.;\n    float dist = length(modSt);\n    float angle = atan(modSt.x, modSt.y);\n    dist = sdPolygon(angle, dist);\n    float shapeMap = smoothstep(SHAPE_SIZE + blur, SHAPE_SIZE - blur, dist);\n    return shapeMap;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 st =\n        (2.* fragCoord - iResolution.xy)\n        / min(iResolution.x, iResolution.y);\n    st *= rotate2d(sin(iTime * .14) * .3);\n    st *= (sin(iTime * .15) + 2.) * .3;\n    st *= log(length(st * .3)) * .4;\n\n    float modScale = 1.;\n\n    vec3 color = vec3(0);\n    float luma = INITIAL_LUMA;\n    float blur = .5 + sin(iTime * .5) * .3;\n    for (float i = 0.; i < ITERATIONS; i++) {\n        vec2 center = st + vec2(sin(iTime * .12), cos(iTime * .13));\n        //center += pow(length(center), 1.);\n        vec3 shapeColor = vec3(\n            getColorComponent(center - st * CHROMATIC_ABBERATION, modScale, blur),\n            getColorComponent(center, modScale, blur),\n            getColorComponent(center + st * CHROMATIC_ABBERATION, modScale, blur)        \n        ) * luma;\n        st *= 1.1 + getColorComponent(center, modScale, .04) * 1.;\n        st *= rotate2d(sin(iTime  * .05) * .3);\n        color += shapeColor;\n        color = clamp(color, 0., 1.);\n        if (color == vec3(1)) break;\n        luma *= .6;\n        blur *= .63;\n    }\n    const float GRADING_INTENSITY = .4;\n    vec3 topGrading = vec3(\n        1. - sin(iTime * 1.1 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.2 * .3) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.3 * .3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. + cos(iTime * 1.4 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.5 * .3) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.6 * .3) * GRADING_INTENSITY\n    );\n    vec3 colorGrading = mix(topGrading, bottomGrading, fragCoord.y / iResolution.y);\n    fragColor = vec4(pow(color.rgb, colorGrading), 1.);\n}", "image_inputs": [{"id": 29472, "src": "https://soundcloud.com/giovanni-sollima/linvenzione-del-nero", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfDd.jpg", "access": "api", "license": "proprietary-license", "functions": [[1126, 1126, 1154, 1154, 1240], [1242, 1242, 1294, 1294, 1400], [1402, 1402, 1473, 1473, 1744], [1746, 1746, 1801, 1801, 3443]], "test": "untested"}
{"id": "ssKfWd", "name": "Roguelike biome map 2", "author": "jarble", "description": "Another roguelike game map. Every color is a different biome.\nIt looks almost like a Minecraft biome map, with continents, islands, and oceans.", "tags": ["fractal", "biome", "roguelike"], "likes": 11, "viewed": 359, "published": 3, "date": "1659047822", "time_retrieved": "2024-07-30T16:38:02.117519", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/4.+ iTime*16.);\n    O = vec4(1);\n    bool b = false;\n    for(uint i = 0u; i++ < 12u;I = i+(I+I.yx/uvec2(11,13)-I.yx/uvec2(13,11))*2u/3u){\n        b = !b && bool(I.x & 1u | I.y & 1u);\n        O.x = abs(float(b)-O.x);\n        O.xyz = O.yzx-float(b)/2.;\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n        //I /= 1u+uint(b);\n    }\n    if (!b) O = 1.-O;\n    \n}", "image_inputs": [], "sound_code": "#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\n#define fmod1(x,y) floor(min(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  //time *= 4.;\n  float tempo = 1.;\n  time /= tempo;\n  float\n  s1 = pow(2.,1.+fmod1(time/8.,3.)),\n  s2 = pow(2.,1.+fmod(time/8.,3.)),\n  m1 = s1*(1.+fmod(time/s2/s1+1.,2.)),\n  t = time*tempo,\n  m4 = fmod(t*s1/(1.+fmod1(t/s1,2.)),s2),\n  m3 = fmod((t*s1+m4)*s1/m1,s2);\n  t *= s1*s1/(1.+fmod(t/s1,2.));\n  float m2 = 1. + fmod1(t*s1,s1);\n  float a =\n      //8.*pow((1.-sqrt(fract(t/s1*tempo)/m1))/4.,2.)\n      log(1./8.+abs(fract(t/s1*tempo)))\n  ;\n  float nb = time*tempo*pow(2.,(m3+m2)/5.+7.5);\n  return abs(.5-vec2(fract(nb*.998),fract(nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKfWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 493]], "test": "untested"}
{"id": "ssKBDt", "name": "Fractal river map 2", "author": "jarble", "description": "A fractal that looks like a series of lakes and rivers.", "tags": ["fractal", "river", "lake"], "likes": 1, "viewed": 189, "published": 3, "date": "1659040132", "time_retrieved": "2024-07-30T16:38:03.204613", "image_code": "uint iters = 12u;\n\nbool labyrinth(uvec2 U){\n    bvec2 b = bvec2(U & 1u);\n    return b.x || b.y;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/4.+ iTime*16.);\n    O = vec4(1);\n    bool b = false;\n    float sum = 0.;\n    for(uint i = 0u; i++ < iters;I =(I+I.yx/uvec2(11,13)-I.yx/uvec2(13,11))*2u/3u){\n        I += i+1u;\n        sum += float(b?1:-1);\n        b = !b && labyrinth(I);\n        O.x = abs(float(b)*O.x*sum);\n        O.xyz = abs(float(b)-abs(O.yzx))/2.;\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 43, 43, 97], [99, 99, 135, 135, 508]], "test": "untested"}
{"id": "7dKBDt", "name": "Dodecahedron inner reflections", "author": "mrange", "description": "CC0: Dodecahedron inner reflections\nI watched this and was pretty amazed: https://www.youtube.com/watch?v=qNoQXF2dKBs\nI tried to create something like that but it's not as cool partly because I don't\nknow how to do a Rhombicosidodecahedron\n", "tags": ["3d", "reflections"], "likes": 30, "viewed": 540, "published": 3, "date": "1659039543", "time_retrieved": "2024-07-30T16:38:04.221893", "image_code": "// CC0: Dodecahedron inner reflections\n// I watched this and was pretty amazed: https://www.youtube.com/watch?v=qNoQXF2dKBs\n// I tried to create something like that but it's not as cool partly because I don't\n// know how to do a Rhombicosidodecahedron\n// But I think it's cool enough to share\n\n// Press left mouse button for some crappy camera control\n\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define PHI         (sqrt(5.0)*0.5 + 0.5)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n#define TOLERANCE       0.001\n#define MAX_RAY_LENGTH  20.0\n#define MAX_RAY_MARCHES 60\n#define NORM_OFF        0.0001\n#define ROT(a)          mat2(cos(a), sin(a), -sin(a), cos(a))\n#define MAX_BOUNCES     5\n#define GDF(n)          d = max(d, abs(dot(p, GDFVectors[n])))\n\nconst float initt = 0.5; \n\nint g_mat1 = 0;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n\n// http://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat sphere(vec3 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/distfunctions/\nfloat boxFrame(vec3 p, vec3 b, float e) {\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nconst vec3 GDFVectors[19] = vec3[](\n  normalize(vec3(1, 0, 0)),\n  normalize(vec3(0, 1, 0)),\n  normalize(vec3(0, 0, 1)),\n\n  normalize(vec3( 1,  1,  1)),\n  normalize(vec3(-1,  1,  1)),\n  normalize(vec3( 1, -1,  1)),\n  normalize(vec3( 1,  1, -1)),\n\n  normalize(vec3( 0       ,  1      , PHI+1.0 )),\n  normalize(vec3( 0       , -1      , PHI+1.0 )),\n  normalize(vec3( PHI+1.0 ,  0      , 1       )),\n  normalize(vec3(-PHI-1.0 ,  0      , 1       )),\n  normalize(vec3( 1       , PHI+1.0 , 0       )),\n  normalize(vec3(-1       , PHI+1.0 , 0       )),\n\n  normalize(vec3( 0   ,  PHI, 1   )),\n  normalize(vec3( 0   , -PHI, 1   )),\n  normalize(vec3( 1   ,  0  , PHI )),\n  normalize(vec3(-1   ,  0  , PHI )),\n  normalize(vec3( PHI ,  1  , 0   )),\n  normalize(vec3(-PHI ,  1  , 0   ))\n);\n\n/*\nfloat icosahedron(vec3 p, float r) {\n  p = abs(p);\n  float d = 0.0;\n  GDF(3);\n  GDF(7);\n  GDF(9);\n  GDF(11);\n  return d-r;\n}\nfloat truncatedIcosahedron(vec3 p, float r) {\n  p = abs(p);\n  float d = 0.0;\n  GDF(3);\n  GDF(7);\n  GDF(9);\n  GDF(11);\n  GDF(13);\n  GDF(15);\n  GDF(17);\n  return d-r;\n}\n*/\n\nfloat dodecahedron(vec3 p, float r) {\n  // Bound, not exact distance\n  p = abs(p);\n  float d = 0.0;\n  GDF(13);\n  GDF(15);\n  GDF(17);\n  return d-r;\n}\n\nfloat blobs(vec2 p) {\n  // Generates a grid of dots\n  vec2 bp = p;\n  vec2 bn = mod2(bp, vec2(3.0));\n\n  vec2 dp = p;\n  vec2 dn = mod2(dp, vec2(0.25));\n  float ddots = length(dp);\n  \n  // Blobs\n  float dblobs = 1E6;\n  for (int i = 0; i < 5; ++i) {\n    float dd = circle(bp-1.0*vec2(sin(TIME+float(i)), sin(float(i*i)+TIME*sqrt(0.5))), 0.1);\n    dblobs = pmin(dblobs, dd, 0.35);\n  }\n\n  float d = 1E6;\n  d = min(d, ddots);\n  // Smooth min between blobs and dots makes it look somewhat amoeba like\n  d = pmin(d, dblobs, 0.35);\n  return d;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  const vec3 gcol = HSV2RGB(vec3(0.45, 0.6, 1.0));\n  vec3 col = clamp(vec3(0.0025/abs(rd.y))*gcol, 0.0, 1.0);\n  \n  float tp0  = rayPlane(ro, rd, vec4(vec3(0.0, 1.0, 0.0), 4.0));\n  float tp1  = rayPlane(ro, rd, vec4(vec3(0.0, -1.0, 0.0), 6.0));\n  float tp = tp1;\n  tp = max(tp0,tp1);\n  if (tp > 0.0) {\n    vec3 pos  = ro + tp*rd;\n    const float fz = 0.25;\n    const float bz = 1.0/fz;\n    vec2 bpos = pos.xz/bz;\n    float db = blobs(bpos)*bz;\n    db = abs(db);\n    vec2 pp = pos.xz*fz;\n    float m = 0.5+0.25*(sin(3.0*pp.x+TIME*2.1)+sin(3.3*pp.y+TIME*2.0));\n    m *= m;\n    m *= m;\n    pp = fract(pp+0.5)-0.5;\n    float dp = pmin(abs(pp.x), abs(pp.y), 0.125);\n    dp = min(dp, db);\n    vec3 hsv = vec3(0.4+mix(0.15,0.0, m), tanh_approx(mix(50.0, 10.0, m)*dp), 1.0);\n    vec3 pcol = 1.5*hsv2rgb(hsv)*exp(-mix(30.0, 10.0, m)*dp);\n    \n    float f = 1.0-tanh_approx(0.1*length(pos.xz));\n    col = mix(col, pcol , f);\n  }\n\n\n  if (tp1 > 0.0) {\n    vec3 pos  = ro + tp1*rd;\n    vec2 pp = pos.xz;\n    float db = box(pp, vec2(6.0, 9.0))-1.0;\n    \n    col += vec3(2.0)*gcol*rd.y*smoothstep(0.25, 0.0, db);\n    col += vec3(0.8)*gcol*exp(-0.5*max(db, 0.0));\n  }\n\n\n  return col;\n}\n\nfloat dfExclusion(vec3 p) {\n  return sphere(p, 3.35);\n}\n\nfloat df0(vec3 p) {\n  float d0 = dodecahedron(p, 3.0);\n  float d = d0;\n  return d;\n}\n\nfloat df1(vec3 p) {\n  float d0 = -(df0(p)+0.05);\n  float d1 = boxFrame(p, vec3(1.1), 0.0)-0.1;\n  float d2 = sphere(p, 1.);\n\n  float d = d0;\n  g_mat1 = 0;\n  if (d1 < d) {\n    d = d1;\n    g_mat1 = 1;\n  }\n\n  if (d2 < d) {\n    d = d2;\n    g_mat1 = 0;\n  }\n  \n  return d;\n}\n\nvec3 normal1(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df1(pos+eps.xyy) - df1(pos-eps.xyy);\n  nor.y = df1(pos+eps.yxy) - df1(pos-eps.yxy);\n  nor.z = df1(pos+eps.yyx) - df1(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch1(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df1(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 normal0(vec3 pos) {\n  vec2  eps = vec2(NORM_OFF,0.0);\n  vec3 nor;\n  nor.x = df0(pos+eps.xyy) - df0(pos-eps.xyy);\n  nor.y = df0(pos+eps.yxy) - df0(pos-eps.yxy);\n  nor.z = df0(pos+eps.yyx) - df0(pos-eps.yyx);\n  return normalize(nor);\n}\n\nfloat rayMarch0(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  for (int i = 0; i < MAX_RAY_MARCHES; i++) {\n    if (t > MAX_RAY_LENGTH) {\n      t = MAX_RAY_LENGTH;    \n      break;\n    }\n    float d = df0(ro + rd*t);\n    if (d < TOLERANCE) {\n      break;\n    }\n    t  += d;\n  }\n  return t;\n}\n\nvec3 render1(vec3 ro, vec3 rd) {\n  vec3 agg = vec3(0.0, 0.0, 0.0);\n  float tagg = initt;\n  vec3 ragg = vec3(1.0);\n\n  for (int bounce = 0; bounce < MAX_BOUNCES; ++bounce) {\n    float mragg = max(max(ragg.x, ragg.y), ragg.z);\n    if (mragg < 0.1) break;\n    float st = rayMarch1(ro, rd);\n    tagg += st;\n    int mat = g_mat1;\n    vec3 sp = ro+rd*st;\n    float de = dfExclusion(sp);\n    vec3 sn = normal1(sp);\n    \n    const vec3 lcol = vec3(1.0, 1.5, 2.0);\n    \n    // Will never miss\n    switch(mat)\n    {\n    case 0:\n      if (de < 0.0) {\n        agg += ragg*0.5*lcol*exp(10.0*de);\n        ragg *= 0.9;\n      } else {\n        agg += ragg*lcol;\n        ragg = vec3(0.0);\n      }\n      break;\n    case 1:\n      agg += ragg*lcol;\n      ragg = vec3(0.);\n      break;\n    default:\n      break;\n    }\n    \n    rd = reflect(rd, sn);\n    ro = sp+initt*rd;\n    tagg += initt;\n    ragg *= 0.8;\n  }\n  \n  return agg*exp(-.5*vec3(0.3, 0.15, 0.1)*tagg);\n}\n\nvec3 render0(vec3 ro, vec3 rd) {\n  vec3 skyCol = skyColor(ro, rd);\n\n  vec3 col = skyCol;\n\n  float st = rayMarch0(ro, rd);\n  vec3 sp = ro+rd*st;\n  vec3 sn = normal0(sp);\n  float de = dfExclusion(sp);\n  float ptime = mod(TIME, 30.0);\n  float fi = mix(smoothstep(0.8, 1.0, sin(0.5*TAU*ptime*ptime))*step(4.0, ptime), 1.0, step(6.0, ptime));\n  if (st < MAX_RAY_LENGTH) {\n    float sfre = 1.0+dot(rd, sn);\n    sfre *= sfre;\n    sfre = mix(0.1, 1.0, sfre); \n    vec3 sref   = reflect(rd, sn);\n    vec3 srefr  = refract(rd, sn, 0.95);\n    vec3 ssky = sfre*skyColor(sp, sref);\n\n    if (de > 0.0) {\n      col = ssky;\n    } else {\n      col = 0.5*sfre*ssky;\n      vec3 col1 = (1.0-sfre)*render1(sp+srefr*initt, srefr);\n      col += fi*col1;\n    }\n    \n  }\n\n  return col;\n}\n\nvec3 effect(vec2 p) {\n  vec3 ro = vec3(0.0, 4.0, 5.0);\n  vec3 la = vec3(0.0, 0.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n  if (iMouse.x > 0.0) {\n    // Get angle from mouse position\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    ro.xz *= ROT(-2.0*m.x);\n    ro.zy *= ROT(2.0*m.y);\n  } else {\n    ro.xz *= ROT(0.1*TIME);\n  }\n\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/5.5);\n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n\n  vec3 col = render0(ro, rd);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col); \n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[981, 981, 1003, 1003, 1149], [1445, 1545, 1564, 1564, 1651], [1653, 1760, 1786, 1786, 1970], [1972, 2032, 2060, 2126, 2202], [2205, 2236, 2272, 2272, 2366], [2368, 2368, 2399, 2399, 2425], [2427, 2427, 2458, 2458, 2484], [2486, 2579, 2620, 2620, 2907], [2909, 3027, 3054, 3054, 3130], [3132, 3232, 3271, 3271, 3364], [3366, 3366, 3405, 3405, 3434], [3436, 3548, 3590, 3590, 3637], [4802, 4802, 4839, 4870, 4950], [4952, 4952, 4973, 5003, 5487], [5489, 5489, 5522, 5522, 6691], [6693, 6693, 6720, 6720, 6748], [6750, 6750, 6769, 6769, 6834], [6836, 6836, 6855, 6855, 7103], [7105, 7105, 7129, 7129, 7343], [7345, 7345, 7380, 7380, 7627], [7629, 7629, 7653, 7653, 7867], [7869, 7869, 7904, 7904, 8151], [8153, 8153, 8185, 8185, 9094], [9096, 9096, 9128, 9128, 9858], [9860, 9860, 9881, 9881, 10442], [10444, 10444, 10499, 10499, 10755]], "test": "untested"}
{"id": "7dVBWt", "name": "Touchelou", "author": "xfennec", "description": "Very simple effect, where texture is used to disturb another one.", "tags": ["texturedistortion"], "likes": 4, "viewed": 259, "published": 3, "date": "1659037644", "time_retrieved": "2024-07-30T16:38:05.222218", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv /= vec2(iResolution.y / iResolution.x, 1);\n    \n    // bass detection\n    // the sound texture is 512x2\n    int tx = int(uv.x*512.0);\n    \n\n\t// crude beat detection\n    float bass = 0.0;\n    int samples = 5;\n    for(int i = 0 ; i < samples ; ++i) {\n        bass += texelFetch( iChannel2, ivec2(i,0), 0 ).x;\n    }\n    bass /= float(samples);\n    float beat = smoothstep(0.8, 1.0, bass);\n    \n\n    vec2 uv2 = uv + vec2(iTime / 50.0, iTime / 100.0);\n\n    float intens = texture(iChannel1, uv2).r;\n \n    float anim = iTime / 10.0;\n    \n \n    vec2 def = vec2(sin(intens + anim), cos(intens + anim / 2.0));\n    def -= 0.2;\n\n    vec4 tex = texture(iChannel0, uv + def);\n     \n\n    tex *= vec4(0.2, 0.6, 2.0, 1.0);\n    tex *= vec4(1.0, 1.0, beat + 0.5, 1.0);\n\n\n    fragColor = vec4(tex.rgb, 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 945]], "test": "untested"}
{"id": "fdVfDd", "name": "Infinite roguelike dungeon 4", "author": "jarble", "description": "Another infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 4, "viewed": 245, "published": 3, "date": "1659036469", "time_retrieved": "2024-07-30T16:38:06.052000", "image_code": "float threshold = .8;\nint iters = 8;\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false;\n    uint sum = 0u;\n    for(int i = 0; i++ < iters;I =\n    //Multiply and divide by prime numbers to get interesting patterns\n    I*2u/3u\n    //I*13u/17u\n    ){\n        sum += uint(b);\n        I += sum*uint(i)+1u;\n        //I += uvec2(i); //another interesting pattern\n        b = !b || bool(I.x & 1u) && bool(I.y & 1u);\n        O.x = abs(float(b)*O.x)/2.;\n        O.xyz = abs(float(b)-abs(O.yzx))/2.;\n        \n        //some random-looking distortion\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/csK3zm\n#define fmod(x,y) floor(max(mod(floor(-(x))*4.,y),mod(floor(x)*3.,y)))\nvec2 mainSound(int samp, float time){  \n  float tempo = 1.;\n  time /= tempo;\n  float\n  s1 = pow(2.,1.+fmod(time/8.,3.)),\n  m1 = s1*(1.+fmod(time/s1/s1+1.,2.)),\n  t = time,\n  m4 = fmod(t*s1/(1.+fmod(t/s1,2.)),s1),\n  m3 = fmod((t+m4)*s1/m1,s1);\n  t *= s1*s1/(1.+fmod(t/s1,2.));\n  float m2 = 1. + fmod(t/s1,s1);\n  float a = pow(2.,fmod(time*2.,2.))*16.*pow((1.-sqrt(fract(t/s1)/m1))/2.,2.);\n  float nb = time*tempo*pow(2.,(m3+m2)/5.+6.5);\n  return abs(.5-vec2(fract(nb*.998),fract(nb)))*a;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 74, 74, 679]], "test": "untested"}
{"id": "sdKfDc", "name": "winter denouement", "author": "prishainabox", "description": "Following Painting a Landscape with Maths by Inigo Quilez\nhttps://www.youtube.com/watch?v=BFld4EBO2RE\nhttps://iquilezles.org/articles/morenoise/\nhttps://www.shadertoy.com/view/4ttSWf", "tags": ["raymarching"], "likes": 2, "viewed": 153, "published": 3, "date": "1659034275", "time_retrieved": "2024-07-30T16:38:06.881782", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;        \n    fragColor = vec4(texture(iChannel0, uv).rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// write color to buffer A\nfloat PI = 3.14159265;\nfloat  E = 2.71828182;\nint AA = 3; // sqrt(samples per pixel)\n\n/*******************************************************/\n\n// return smoothstep and its derivative from https://www.shadertoy.com/view/4ttSWf (Inigo Quilez)\nvec2 smoothstepd( float a, float b, float x) {\n\tif( x<a ) return vec2( 0.0, 0.0 );\n\tif( x>b ) return vec2( 1.0, 0.0 );\n    float ir = 1.0/(b-a);\n    x = (x-a)*ir;\n    return vec2( x*x*(3.0-2.0*x), 6.0*x*(1.0-x)*ir );\n}\n\nfloat random(in vec2 pt) {\n    vec2 uv = 50.0*(fract(pt / PI));\n    return fract(uv.x * uv.y * (uv.x + uv.y));\n}\n\n// https://iquilezles.org/articles/morenoise/\nfloat noise(in vec2 pt) {\n    \n    vec2 i = floor(pt); // integer component\n    vec2 f = fract(pt); // fractional component\n    f = 3.0 * f * f - 2.0 * f * f * f; // smooth interpolation\n    \n    // values of four corners\n    float a = random(i + vec2(0, 0)),\n          b = random(i + vec2(1, 0)),\n          c = random(i + vec2(0, 1)),\n          d = random(i + vec2(1, 1));\n          \n    float k0 = a,\n          k1 = b - a,\n          k2 = c - a,\n          k3 = a - b - c + d;\n          \n    // interpolate between four values x * (1âa) + y * a\n    return 2.0 * (k0 + k1*f.x + k2*f.y  + k3*f.x*f.y) - 1.0;      \n\n}\n\n// yz -> derivative, x -> noise value\n// learn this later\nvec3 noised(in vec2 pt) {\n    \n    vec2 i = floor(pt); // integer component\n    vec2 f = fract(pt); // fractional component\n    vec2 u = 3.0 * f * f - 2.0 * f * f * f; // smooth interpolation\n    \n    // heights of four corners\n    float a = random(i + vec2(0, 0)),\n          b = random(i + vec2(1, 0)),\n          c = random(i + vec2(0, 1)),\n          d = random(i + vec2(1, 1));\n          \n    float k0 = a,\n          k1 = b - a,\n          k2 = c - a,\n          k3 = a - b - c + d;\n          \n    // interpolate between four heights (basically mix function)  x * (1âa) + y * a\n    return vec3(\n        2.0 * (k0 + k1*u.x + k2*u.y  + k3*u.x*u.y) - 1.0,\n        2.0*(6.0*f*(1.0-f)) * vec2(k1 + k3*u.y, k2 + k3*u.x)\n    );      \n\n}\n\nmat2 getRotMatrixFromTriangle(in float x, in float y, in float h) {\n    // sin, cos, -cos, sin\n    return mat2(y/h, x/h, -x/h, y/h);\n}\n\nfloat fbm(in vec2 uv, in mat2 rot, in int iterations) {\n    float a = 0.0;\n    for (int i = 0; i < iterations; i++) {\n        vec2 t = pow(2.0, float(i)) * uv;\n        for (int j = 0; j < i; j++) {\n            t *= rot;\n        }\n        a += (1.0 / pow(2.0, float(i))) * noise(t);\n    }\n    return a;\n}\n\nmat2 rot;\nmat2 rot2;\n\nvoid initMatrices() {\n    rot = getRotMatrixFromTriangle(3.0, 4.0, 5.0);\n    rot2 = getRotMatrixFromTriangle(5.0, 12.0, 13.0);\n}\n\n// https://www.shadertoy.com/view/4ttSWf\nvec3 fbmd(in vec2 uv, in mat2 rot, in int iterations) {\n    float acc = 0.0;\n    float k = 1.0;\n    vec2 der = vec2(0);\n    mat2  m = mat2(1.0, 0.0, 0.0, 1.0);\n    vec2 t = uv;\n    for (int i = 0; i <= iterations; i++) {\n        vec3 n = noised(t); // calc noise & derivative\n        acc += k*n.x; // accumulate val\n        der += k*m*n.yz; // accumulate derivatives\n        k *= 0.5; // half amplitude\n        t *= rot*2.0; // double freq & rotate\n        m *= 2.0*rot;\n    }\n    return vec3(acc, der);\n}\n\n/*******************************************************/\n\nvec3 sunClr = vec3(11, 9, 5);\nvec3 skyClr = vec3(0.56, 0.7, 1.0);\nvec3 sunDir = normalize(vec3(0.1*float(-3.25), 0.1*float(3.5), 0.1*float(-2.5)));\n\n/*******************************************************/\n\n// TERRAIN\n\nfloat terrainMap(in vec2 pt) {\n    // noise terrain\n    pt /= 2000.0;\n    float a = fbm(pt, rot, 6);\n    a = a * 600.0 + 600.0;\n    // cliff\n    a += 160.0 * smoothstep(-230.0, 40.0, a);\n    // return height\n    return a;\n}\n\nvec4 terrainMapD(in vec2 pt) {\n    // noise derivative\n    vec3 e = fbmd(pt / 2000.0, rot, 12);\n    e.x = e.x * 600.0 + 600.0;\n    e.yz *= 600.0;\n    // cliff\n    vec2 c = smoothstepd(-230.0, 40.0, e.x);\n\te.x  = e.x  + 160.0*c.x;\n\te.yz = e.yz + 160.0*c.y*e.yz; // chain rule (from https://www.shadertoy.com/view/4ttSWf)\n    e.yz /= 2000.0;\n    return vec4(e.x, normalize(vec3(-e.y, 1.0, -e.z)));\n}\n\nfloat raymarchTerrain(in vec3 ro, in vec3 rd) {\n\n    // total distance traveled\n    float td = 0.01;\n    vec3 nor = vec3(0);\n    \n    for (int i = 0; i < 128; i++) {\n        vec3 pt = ro + rd*td;\n        // height of terrain\n        float h = terrainMap(pt.xz);\n        float d = 0.35 * (pt.y - h); \n        // if distance is close\n        if (abs(d) < 0.0001*td) {\n            break;\n        }\n        // add to total distance\n        td += d;\n        // if too far, break\n        if (td >= 1800.0) {\n            td = -1.0;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\nvec3 terrainNormal(in vec3 pt, in int mode) {\n    if (mode == 0) {\n        return terrainMapD(pt.xz).yzw;\n    } else {\n        vec2 e = vec2(0.03,0.0);\n        return normalize(vec3(\n            terrainMap(pt.xz - e.xy) - terrainMap(pt.xz + e.xy),\n            2.0*e.x,\n            terrainMap(pt.xz - e.yx) - terrainMap(pt.xz + e.yx) \n        ));\n    }\n  \n}\n\nfloat terrainShadow(in vec3 ro, in vec3 rd, in float shadowSoftness) {\n\n    // total distance traveled\n    float td = 0.05;\n    // shadow\n    float sha = 1.0;\n    \n    for (int i = 0; i < 128 && td < 1800.0; i++) {\n        vec3 pt = ro + rd*td;\n        // height of terrain\n        float h = terrainMap(pt.xz);\n        float d = pt.y - h;\n        // if distance is close\n        if (d < td*0.0001)\n            // intersection, so return shadow\n            return 0.0;\n        // add to total distance\n        sha = min(sha, shadowSoftness * d/td);\n        td += d;\n    }\n    \n    return clamp(sha, 0.0, 1.0);\n    \n}\n\nvec3 colorTerrain(in vec3 ro, in vec3 rd, in float d) {\n\n    vec3 pt = ro + rd*d;\n    vec3 tnor = terrainNormal(pt, 0);\n    vec3 nor = terrainNormal(pt, 1);\n    nor = mix(tnor, nor, smoothstep(0.0, 1.0, min(0.8, nor.y)));\n    \n    // base material color brown\n    vec3 mat = vec3(0.13, 0.08, 0.06);\n    vec3 clr = mat;\n    // use normal y component to figure out grass and snow color\n    float grass = smoothstep(0.6, 0.8, mix(tnor.y, nor.y, nor.y));\n    float snow  = smoothstep(0.7, 0.95, 0.15*tnor.y + 0.85*nor.y);\n    snow = snow*snow;\n    \n    // mix mat and grass and snow color\n    vec3 snowClr = 0.65*vec3(0.1, 0.1, 0.25) + sunClr*0.005*dot(nor, sunDir);\n    vec3 grassClr = vec3(0.07, 0.08, 0.005)*0.8 + snow*snowClr;\n    clr = clr*(1.0 - grass) + grass*grassClr;\n    \n    // lighting\n    vec3 light = vec3(0);\n    light += max(dot(nor, sunDir), 0.0) * sunClr * terrainShadow(pt, sunDir, 40.0); // sun\n    light += ((nor.y + 1.0) * 0.5) * skyClr * 0.5; // sky diffuse\n    light += mat * 6.0 * dot(nor, -sunDir); // bounce\n    \n    clr *= light;\n    \n    return clr;\n    \n}\n\n/*******************************************************/\n\n// CLOUDS\n\nfloat cloudMap(in vec3 pt) {\n    // plane\n    return dot(pt, vec3(0, -1, 0)) + 600.0;\n}\n\nfloat raymarchClouds(in vec3 ro, in vec3 rd) {\n\n    // total distance traveled\n    float td = 0.01;\n    \n    for (int i = 0; i < 128; i++) {\n        float d = cloudMap(ro + rd*td);\n        // if distance is close\n        if (abs(d) < td*0.0001) {\n            break;\n        }\n        // add to total distance\n        td += d;\n        // if too far, break\n        if (td >= 5000.0) {\n            td = -1.0;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n/*******************************************************/\n\nvec4 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n\n    vec3 clr = skyClr - 0.4*uv.y;\n\n    int mat = -1;\n    float d = 6000.0;;\n    \n    // land\n    {\n        float d0 = raymarchTerrain(ro, rd);\n        if (d0 > 0.0 && d0 < d) {\n            mat = 0;\n            d = d0;\n        }\n    }\n    \n    // clouds\n    {\n        float d1 = raymarchClouds(ro, rd);\n        if (d1 > 0.0 && d1 < d) {\n            mat = 1;\n            d = d1;\n        }\n    }\n    \n    // material colors\n    if (mat == 0) {\n        clr = colorTerrain(ro, rd, d);\n    } else if (mat == 1) {\n        // mix sky and cloud clr\n        vec3 pt = ro + rd*d;\n        vec3 cl = 0.4 * vec3(smoothstep( \n            -0.05, 1.0, fbm(pt.xz * 0.003 + 10.5, getRotMatrixFromTriangle(5.0, 12.0, 13.0), 5)\n        ));\n        clr = clr*(1.0-cl) + cl;\n    }\n    \n    // mix fog\n    vec3 f = pow(vec3(2.718281), -0.0001*d*vec3(1, 2, 4));\n    clr = f * clr + (1.0 - f) * vec3(0.9);\n    \n    // mix sun\n    clr += sunClr * 0.05 * pow(dot(sunDir, rd), 10.0);\n\n    clr.r = smoothstep(0.0, 1.0, clr.r);\n    clr.g = smoothstep(0.0, 1.0, clr.g);\n    clr.b = smoothstep(0.0, 1.0, clr.b);\n    return vec4( pow(clr, vec3(0.4545)), 1.0 );\n    \n}\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    return normalize(uv.x * right + uv.y * up + 1.2 * forward);\n}\n\n/*******************************************************/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 clr = vec3(0.0);\n    float d = 1.0;\n    float time = iTime;\n    \n    initMatrices();\n    \n    // camera\n    vec3 ro = vec3(-400, -300.0, -90) + vec3(130, 70, -240);\n    vec3 target = ro + vec3(0.11, 0.1, -0.6) + vec3(-0.60, -0.1, 0.0);\n    \n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - iResolution.xy) / min(iResolution.x, iResolution.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            vec4 rendered = render(uv, ro, rd);\n            if (i == 0 && j == 0) d = rendered.a;\n            clr += rendered.rgb;\n        }\n    }\n\n    clr /= float(AA * AA);\n    \n    // Output to screen\n    fragColor = vec4(clr, d);\n\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 162]], "test": "untested"}
{"id": "ssyBWt", "name": "Another doubled ended truchet", "author": "mrange", "description": "Seems I can't stop doing truchets at the moment. \nAn evolution from: https://www.shadertoy.com/view/NdKfW3\n", "tags": ["2d", "truchet"], "likes": 5, "viewed": 232, "published": 3, "date": "1658995351", "time_retrieved": "2024-07-30T16:38:07.747467", "image_code": "// CC0: Another doubled ended truchet\n// Seems I can't stop doing truchets at the moment. \n// An evolution from: https://www.shadertoy.com/view/NdKfW3\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p)-(b-r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0)-r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat cell0(vec2 p, float off, float linew, float dist) {\n  float r = 0.5+off;\n  float b = (1.0-0.2*dist)*r;\n  float d0 = box(p-0.5, vec2(r), b); \n  float d1 = box(p+0.5, vec2(r), b);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - linew;\n  return d;\n}\n\nfloat cell1(vec2 p, float off, float linew, float dist) {\n  float d0 = abs(p.y-off*-sign(p.x));\n  float d1 = abs(p.x-off*-sign(p.y));\n  float d2 = length(p)-(sqrt(2.0)*2.0)*abs(off);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = pmin(d, d2, 0.2*dist+0.001);\n  d = abs(d) - linew;\n  return d;\n}\n\nfloat truchet_var(float h, float cs, vec2 cp, float off, float linew, float dist) {\n  float hs = h >= 0.5 ? 1.0 : -1.0;\n  cp = hs > 0.0 ? cp : vec2(cp.x, -cp.y);\n\n  float h1 = fract(3677.0*h);\n  if (h1 > 0.1) {\n    return cell0(cp, off*hs*cs, linew, dist);\n  } else {\n    return cell1(cp, off*hs*cs, linew, dist);\n  }\n\n}\n\nvec3 effect(vec2 p) {\n  float hoff0 = 0.5+0.5*sin(0.5*p.x)*sin(0.5*p.y);\n  float hoff1 = 0.5+0.5*cos(0.33*p.x)*cos(0.66*p.y);\n  float dist = 0.0;\n  \n  const float z = 2.5;\n  p *= z;\n\n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n\n  float h0 = hash(cn);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(8677.0*h0);\n  float cs = mod(cn.x+cn.y, 2.0) >= 1.0 ? -1.0 : 1.0; \n\n  const float off   = 0.1;\n  const float linew = 0.01;\n  const float shade = 10.0;\n  \n  float d0 = truchet_var(h1, cs, cp, off, linew*mix(1.0, 2.0, hoff0), hoff1);\n  float d1 = truchet_var(h2, cs, cp, -off, linew*mix(1.0, 2.0, hoff1), hoff0);\n\n  vec3 col = vec3(0.0);\n  \n  vec3 bcol0 = hsv2rgb(vec3(0.1*TIME+hoff1, 0.9, 1.0));\n  vec3 bcol1 = hsv2rgb(vec3(0.123*TIME+hoff0, 0.9, 1.0));\n  \n  vec3 gcol0 = bcol0*0.0125/max(d0, 0.001); \n  vec3 gcol1 = bcol1*0.0125/max(d1, 0.001); \n\n  float shd0 = smoothstep(0.0, linew*shade, z*d0);\n  float shd1 = smoothstep(0.0, linew*shade, z*d1);\n  \n  if (h0 > 0.5) {\n    col += gcol0; \n    col *= shd1;\n    col += gcol1;\n  } else {\n    col += gcol1;\n    col *= shd0;\n    col += gcol0;\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  const float r   = 10.0;\n  const float spd = 0.25;\n  p += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n   \n  vec3 col = effect(p);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 311, 330, 330, 417], [419, 526, 552, 552, 736], [890, 890, 912, 912, 1058], [1354, 1414, 1435, 1435, 1505], [1507, 1625, 1661, 1661, 1743], [1745, 1845, 1884, 1884, 1969], [1971, 1971, 2028, 2028, 2224], [2226, 2226, 2283, 2283, 2516], [2518, 2518, 2601, 2601, 2838], [2840, 2840, 2861, 2861, 3959], [3961, 3961, 4016, 4016, 4317]], "test": "untested"}
{"id": "7dyBWt", "name": "delayed video 3", "author": "FabriceNeyret2", "description": "stores 96 video frames in the cubeMap ( 4x4 per face ). ref: https://shadertoy.com/view/fdyfDd .\nIn black & white we could store 384 frames ( = 6.4 \" )\n\nHere, the 12x8 window tiles are accessed at random delays.", "tags": ["video", "cubemap", "storage"], "likes": 8, "viewed": 306, "published": 3, "date": "1658994972", "time_retrieved": "2024-07-30T16:38:08.811621", "image_code": "// variant of https://shadertoy.com/view/sdyBWt\n// variant of https://shadertoy.com/view/fdyfDd\n// cubeMap utils inspired from https://www.shadertoy.com/view/3tGBDz\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 R = iResolution.xy,\n         U = 4.*vec2(3,2)*u/R, \n         F = u/R;                            // tileCoord\n    int n = int(U.x) + 12*int(U.y);          // tileId \n // n = (n*n*n)%96;                          // random permutation\n    n = ( (73*n)^0xfce3 ) % 96;              // ( WIP: not true permut )\n    O = T((F+vec2(n%4,(n%16)/4))/4., n/16 ); // convert to faceCoord & faceId\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": " void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n      \n    vec2 I = floor(U/=256.);\n    if ( n==5 && I==vec2(3) ) O = texture(iChannel1, fract(U) );\n    else if    ( I!=vec2(3) ) O = T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n);\n    else                      O = T((U-3.)/4., n+1);\n    \n/*   // --- doesn't compile correctly on Windows Angle !\n    O = n==5 && I==vec2(3) ? texture(iChannel1, fract(U) )\n        :       I!=vec2(3) ? T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n)\n        :                    T((U-3.)/4., n+1);\n*/\n}\n\n", "cube_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 E; // mimic access to a set on n textures.\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 204, 204, 600]], "test": "untested"}
{"id": "sdyBWt", "name": "delayed video 2", "author": "FabriceNeyret2", "description": "stores 96 video frames in the cubeMap ( 4x4 per face ). ref: https://shadertoy.com/view/fdyfDd .\nIn black & white we could store 384 frames ( = 6.4 \" )\n\nHere, the 12x8 window tiles are accessed with increased delays.", "tags": ["video", "cubemap", "storage"], "likes": 7, "viewed": 288, "published": 3, "date": "1658994750", "time_retrieved": "2024-07-30T16:38:09.907691", "image_code": "// variant of https://shadertoy.com/view/fdyfDd\n// cubeMap utils inspired from https://www.shadertoy.com/view/3tGBDz\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 R = iResolution.xy,\n         U = 4.*vec2(3,2)*u/R, \n         F = u/R;                       // tileCoord\n    int n = int(U.x) + 12*int(U.y);          // tileId\n    O = T((F+vec2(n%4,(n%16)/4))/4., n/16 ); // convert to faceCoord & faceId\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": " void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n      \n    vec2 I = floor(U/=256.);\n    if ( n==5 && I==vec2(3) ) O = texture(iChannel1, fract(U) );\n    else if    ( I!=vec2(3) ) O = T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n);\n    else                      O = T((U-3.)/4., n+1);\n    \n/*   // --- doesn't compile correctly on Windows Angle !\n    O = n==5 && I==vec2(3) ? texture(iChannel1, fract(U) )\n        :       I!=vec2(3) ? T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n)\n        :                    T((U-3.)/4., n+1);\n*/\n}\n\n", "cube_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 E; // mimic access to a set on n textures.\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 156, 156, 406]], "test": "untested"}
{"id": "fdyfDd", "name": "delayed video", "author": "FabriceNeyret2", "description": "stores 96 video frames in the cubeMap ( 4x4 per face ).\nIn black & white we could store 384 frames ( = 6.4 \" )", "tags": ["video", "cubemap", "storage"], "likes": 11, "viewed": 455, "published": 3, "date": "1658994108", "time_retrieved": "2024-07-30T16:38:10.736475", "image_code": "// cubeMap utils inspired from https://www.shadertoy.com/view/3tGBDz\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    vec2 R = iResolution.xy,\n         U = 4.*vec2(3,2)*u/R, \n         F = fract(U);                       // tileCoord\n    int  n = int(U.x) + 12*int(U.y);         // tileId\n    O = T((F+vec2(n%4,(n%16)/4))/4., n/16 ); // convert to faceCoord & faceId\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": " void mainCubemap( out vec4 O, vec2 U, vec3 o, vec3 D )\n{\n    vec3 A = abs(D);\n    int n = A.x > A.y ? A.x > A.z ? 0 : 2 : A.y > A.z ? 1 : 2; // faceID\n    if (D[n]<0.) n += 3;\n      \n    vec2 I = floor(U/=256.);\n    if ( n==5 && I==vec2(3) ) O = texture(iChannel1, fract(U) );\n    else if    ( I!=vec2(3) ) O = T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n);\n    else                      O = T((U-3.)/4., n+1);\n    \n/*   // --- doesn't compile correctly on Windows Angle !\n    O = n==5 && I==vec2(3) ? texture(iChannel1, fract(U) )\n        :       I!=vec2(3) ? T((I.x<3.? U+vec2(1,0) : U+vec2(-3,1))/4., n)\n        :                    T((U-3.)/4., n+1);\n*/\n}\n\n", "cube_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 E; // mimic access to a set on n textures.\n#define T(U,n) ( E = vec3( 2.*fract(U) -1., 1 )                                 \\\n                   * vec3( n==0||n==5 ?-1:1 , n!=1 ?-1:1 , n>2 ?-1:1 ),         \\\n                 E = (n)%3 != 2 ? E.yzx : E.xzy,                                \\\n                 texture( iChannel0, vec3( E[(n+1)%3], E[(n)%3], E[(n+2)%3] ) ) \\\n               )\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyfDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 108, 108, 363]], "test": "untested"}
{"id": "fsyfDt", "name": "BLF Repetition on BezierExtrude", "author": "iY0Yi", "description": "\"BezierExtrude\" by Del:\n[url]https://www.shadertoy.com/view/7dyBz3[/url]\n", "tags": ["bezier", "repetition", "extrude", "maptoy"], "likes": 35, "viewed": 462, "published": 3, "date": "1658990579", "time_retrieved": "2024-07-30T16:38:11.818582", "image_code": "#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 3.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// 1D version of iq's limited repetition\n// https://www.shadertoy.com/view/3syGzz\nfloat opRepLim( in float p, in float s, in float lima, in float limb ){\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n// \"BezierExtrude\" by Del:\n// https://www.shadertoy.com/view/7dyBz3\n// --------------------------------------------------------------------\n// returns xyz = position, w = spline position (t)\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = uv.x+uv.y-kx;\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 tt = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * tt.x) * tt.x;\n\t\tvec3 r2 = d + (c + b * tt.y) * tt.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? tt.y : tt.x;\n        t = dot(r2,r2) < dot(r1,r1) ? tt.y : tt.x; // quicker\n        \n    }\n    // now we have t, calculate splineposition and orient to spline tangent\n    t = clamp(t,0.,1.); // clamp spline start/end\n    vec3 ttan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, ttan));\n    vec3 _normal = cross(ttan, binormal);\n//\tvec3 t1 = normalize(cross(_normal, ttan));\n\tvec3 t1 = cross(_normal, ttan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(ttan, t1), ttan);\n    vec3 tp = mix(mix(A, B, t), mix(B, C, t), t);\n    pos.xyz = tp - pos; // spline position\n    pos *= mm;\n    \n    return vec4(pos, t);\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat map( in vec3 pos )\n{\n    vec3 a = vec3(sin(iTime*.5)*-3.,cos(iTime*.5)*3.,0);\n    vec3 b = vec3(0.0,sin(iTime*.5)*3.,sin(iTime*4.)*2.0);\n    vec3 c = vec3(sin(iTime*.5)*3.,cos(iTime*.5)*3.,0);\n    vec4 bz = sdBezierExtrude(pos,a,b,c);\n    \n    // here\n    float l = floor(fract(iTime*.25)*30.);\n    float s = .5;\n    vec3 bzr = bz.xyz;\n    bzr.z -= (bz.w-.5)*l;\n    bzr.z = opRepLim(bzr.z, s, -l, l) * ((bzr.z<-l*.5 || bzr.z>l*.5) ? 1. : s);\n    //\n    \n    float rad = .1-.05*abs(sin(iTime*.25));\n    float st = bz.w;//smoothstep(.5, .1, abs(bz.w-.5))+.5;\n    float h = .6*st+.2;//(cos(bz.w*TAU*4.)+.5)*.2+.8 - .6*st;\n    float d = sdBox(bzr.xyz, vec3(h,rad*3.,rad));\n    d = min(sdBox(bzr.xyz, vec3(rad*3.,h,rad)),d);\n    \n    //d = min(length(bz.xyz)-.15*st,d);\n    \n    d = min(length(pos-a)-.15,d);\n    d = min(length(pos-b)-.15,d);\n    d = min(length(pos-c)-.15,d);\n    return d*.8;\n}\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(0,0,2)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// User Inputs\n\n// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(0, 0, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 318, 389, 389, 435], [437, 628, 684, 861, 2518], [2520, 2526, 2557, 2557, 2648], [2650, 2650, 2676, 2676, 3546]], "test": "untested"}
{"id": "NsGBDd", "name": "Fractal river map", "author": "jarble", "description": "A fractal that looks like a series of lakes and rivers.", "tags": ["fractal", "river", "lake"], "likes": 4, "viewed": 181, "published": 3, "date": "1658986872", "time_retrieved": "2024-07-30T16:38:12.626421", "image_code": "uint iters = 12u;\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/4.+ iTime*8.);\n    O = vec4(1);\n    bool b = false;\n    for(uint i = 0u; i++ < iters;I = i + (I+(I.yx)/uvec2(11u,13u)-I.yx/uvec2(13u,11u))*2u/3u){\n        b = !b || bool(I.x & 1u) && bool(I.y & 1u);\n        O.x = abs(float(b)-O.x)/2.;\n        O.xyz = abs(float(b)-abs(O.yzx))/2.;\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n    ;\n}\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  float\n  tempo1 =\n      pow(2.,1.+fmod(t/8.,2.))\n  ,\n  m1 =\n      pow(2.,1.+fmod(t*tempo1,2.))\n  ,\n  c1 = fmod(t*tempo1,m1+fmod(t,m1)),\n  s1 = 1.+c1,\n  t1 = t*tempo1,\n  m2 = fmod(t1*(1.+fmod(t,2.))/2.,s1),\n  a=\n      5.*fract(-t*tempo/s1)\n  ,\n  nb =\n      7.*t*tempo*pow(2.,m2/5.+7.)/radians(180.)\n  ;\n  return\n      abs(vec2(cos(nb),sin(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 55, 55, 388]], "test": "untested"}
{"id": "NdGBWd", "name": "Rainbow Sand Experiment 3", "author": "fenix", "description": "This is like one of those sand paintings in a bottle, but with crazy colors. The idea is to move particles within 2x2 cells ensuring no loss of mass.\n* Mouse at top of screen: grab particle spawner\n* Mouse elsewhere: delete particles\n* Space: reset", "tags": ["simulation", "particles", "sand"], "likes": 4, "viewed": 218, "published": 3, "date": "1658984742", "time_retrieved": "2024-07-30T16:38:13.478144", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n//  v2: added auto-scroll based on deleting bottom row, removed horizontal black lines,\n//      mouse function determined by clicked region\n//  v3: better auto-scroll, new auto-spawner animation\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x, ifc.y & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x, ifc.y | 1), 0);\n    fragColor = max(top, bottom);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, iChannel1, iFrame, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int COLOR_CYCLE_FRAMES = 6000;\n\nfloat length2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nvec4 rainbow(int i)\n{\n    switch(i)\n    {\n        case 0:\n            return vec4(1.0, 0.0, 0.0, 1.0);\n        case 1:\n            return vec4(1.0, 0.5, 0.0, 1.0);\n        case 2:\n            return vec4(1.0, 1.0, 0.0, 1.0);\n        case 3:\n            return vec4(0.0, 1.0, 0.0, 1.0);\n        case 4:\n            return vec4(0.0, 0.0, 1.0, 1.0);\n        case 5:\n            return vec4(0.25, 0.0, 0.5, 1.0);\n        case 6:\n            return vec4(0.5, 0.0, 0.7, 1.0);\n    }\n}\n\nconst int COLOR_CHANGE_FRAMES = 200;\nvec4 colorByFrame(int frame)\n{   \n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex), rainbow(nextColorIndex), blend);\n}\n\nconst float PI = 3.141592653598793;\n\nvec2 rotate(float a)\n{\n    return vec2(sin(a), cos(a));\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (fragColor == vec4(0.0, 0.0, 0.0, 1.0))\n    {\n        float centerTime = (float(frame) * 0.003 - PI * 0.5);\n        float offset = (sin(centerTime) * 0.45 + cos(centerTime * 3.4) * 0.27 + sin(centerTime * 0.01) * 0.11) * 0.6;\n        vec2 spawnCenter = vec2(offset + 0.5, 0.9) * res.xy;\n        \n        if (mouse.z > 0.0 && mouse.y > res.y * 0.9)\n        {\n            spawnCenter.x = mouse.x;\n        }\n\n        float rotateTime = float(frame) * (0.01 + (1.0 + cos(float(frame) * 0.01)) * 0.0004) * 0.7;\n        float SPAWN_DISTANCE = res.x * 0.04;\n        vec2 spawnPoints[3] = vec2[](spawnCenter + SPAWN_DISTANCE * rotate(rotateTime),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime + PI * (2.0 / 3.0)),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime - PI * (2.0 / 3.0)));\n\n        for (int i = 0; i < 3; ++i)\n        {\n            if (length2(spawnPoints[i] - fragCoord) < square(res.x * 0.01))\n            {\n                fragColor = colorByFrame(frame + COLOR_CHANGE_FRAMES * i);\n            }\n        }\n    }\n}\n\nconst vec4 EMPTY = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid removeSand(sampler2D mipSampler, int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (mouse.z > 0.0 && mouse.y < res.y * 0.9)\n    {\n        vec2 removePos = mouse.xy;\n\n        if (length2(removePos - fragCoord) < square(res.x * 0.02))\n        {\n            fragColor = EMPTY;\n        }\n    }\n}\n\nvoid evolveByCells(sampler2D sampler, sampler2D mipSampler, int frame, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n    \n    if (!all(lessThan(urCell, ires)) || (offset != ivec2(0) && (coord.x == 0 || coord.y == 0)))\n    {\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    vec3 fullTest0 = textureLod(mipSampler, vec2(0.2, 0.6), 3.0).xyz;\n    vec3 fullTest1 = textureLod(mipSampler, vec2(0.4, 0.6), 3.0).xyz;\n    vec3 fullTest2 = textureLod(mipSampler, vec2(0.6, 0.6), 3.0).xyz;\n    vec3 fullTest3 = textureLod(mipSampler, vec2(0.8, 0.6), 3.0).xyz;\n    \n    int deleteInterval = 100000000;\n    int blockedCount = 0;\n    if (any(greaterThan(fullTest0, vec3(0)))) ++blockedCount;\n    if (any(greaterThan(fullTest1, vec3(0)))) ++blockedCount;\n    if (any(greaterThan(fullTest2, vec3(0)))) ++blockedCount;\n    if (any(greaterThan(fullTest3, vec3(0)))) ++blockedCount;\n    \n    if (blockedCount > 1)\n    {\n        deleteInterval = 5;\n    }\n    \n    ivec2 shift = ivec2(0);\n    if (frame % deleteInterval == 0)\n    {\n        shift.y = 2;\n    }\n\n    vec4 ulValue = texelFetch(sampler, ulCell + shift, 0);\n    vec4 urValue = texelFetch(sampler, urCell + shift, 0);\n    vec4 llValue = texelFetch(sampler, llCell + shift, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell + shift, 0);\n    ulValue.w = urValue.w = llValue.w = lrValue.w = 1.0;\n    \n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    if (cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true))\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false))\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        lrValue = urValue;\n        urValue = EMPTY;\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(true, false,\n                           true, false))\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, true))\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, iChannel1, 1, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, iChannel1, 1, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, iChannel1, 1, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGBWd.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[932, 932, 989, 989, 1195]], "test": "untested"}
{"id": "NsGfDt", "name": "Normal based outline attempt", "author": "intrakits", "description": "using the normal of an object to make an outline.", "tags": ["normal", "outline"], "likes": 4, "viewed": 211, "published": 3, "date": "1658976209", "time_retrieved": "2024-07-30T16:38:14.242102", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r){\n    //line from a to b\n    vec3 ab = b-a;\n    \n    // line from p to a\n    vec3 ap = p-a;\n    \n    // as p approaches a, it will be 1\n    // as p approaches b it will b 0\n    float t = dot(ab,ap) / dot(ab,ab);\n    \n    // clamp values between 0 and 1\n    t= clamp(t,0.,1.);\n    \n    // center point of the capsule\n    // start at a (top of capsule)\n    // go towards b, t steps\n    vec3 c = a + t*ab;\n    \n    float d = length(p-c)-r;\n    \n    return d;\n}\n\nfloat sdTorus(vec3 p, vec2 r){\n    float x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\nfloat GetDist(vec3 p){\n    // some test object\n    vec4 sphere = vec4(0,1,6,1);\n    \n    // distance to sphere\n    //--------------------------------\n    // distance to center of sphere: \n    // length(sphere position - camera position)\n    // distance to outside of the sphere:\n    // length(sphere position - camera position) - sphere radius\n    float ds = length(p-sphere.xyz)-sphere.w;\n    \n    //distance to floor (plane)\n    //this is just height of the origin point passed\n    float dp = p.y;\n    \n    //capsule distance\n    vec3 p2 = p;\n    p2-=vec3(2,0,6);\n    p2.xy*=Rot(iTime);\n    float cd = sdCapsule(p2, vec3(0,0.5,0), vec3(0,1.5,0), 0.5);\n    \n    //torus distance\n    vec3 p1 = p;\n    p1-=vec3(-3,0.5,6);\n    p1.xy*=Rot(iTime);\n    float td = sdTorus(p1, vec2(.5,.3));\n    \n    //box distance\n    float bd = dBox(p-vec3(-2,0.5,8),vec3(0.5));\n    \n    // cylinder distance\n    p.xy*=Rot(iTime);\n    float cyld = sdCylinder(p, vec3(0, .3, 5), vec3(3, 0.3, 6), .3);\n    \n    //choose the closest of the two\n    float d = min(ds,dp);\n    d = min(cd,d);\n    d = min(d,td);\n    d = min(bd,d);\n    d = min(cyld,d);\n    return d;\n}\nfloat RayMarch(vec3 ro, vec3 rd){\n    // distance from origin\n    float dO=0.;\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO*rd;\n        \n        // get distance to seam\n        float ds = GetDist(p);\n        //move origin to new point\n        dO+=ds;\n        if(ds < SURFACE_DIST || dO > MAX_DIST){\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p);\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy),\n         GetDist(p-e.yxy),\n         GetDist(p-e.yyx));\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(0,4,0);\n    \n  //  lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    diff = smoothstep(0.4,.41,diff);\n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n\n    return diff;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ro = vec3(0,4,0);\n    \n    //ray dir\n    //controls rotation\n    vec3 rd = normalize(vec3(uv.x,uv.y-0.5,1));\n    //------------------\n    float d = RayMarch(ro,rd);\n    // position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d;\n    \n    //get diffuse lighting\n    float diff = GetLight(p);\n    col = vec3(diff);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[70, 70, 89, 89, 151], [152, 152, 203, 203, 487], [489, 489, 538, 561, 994], [996, 996, 1026, 1026, 1097], [1099, 1099, 1126, 1126, 1165], [1166, 1166, 1188, 1212, 2305], [2306, 2306, 2339, 2367, 2769], [2770, 2770, 2793, 2832, 3195], [3196, 3196, 3219, 3254, 4114], [4115, 4115, 4172, 4254, 4830]], "test": "untested"}
{"id": "fsGfDt", "name": "Fractal archipelago map", "author": "jarble", "description": "A fractal that looks like an archipelago.", "tags": ["fractal", "archipelago", "islands"], "likes": 2, "viewed": 189, "published": 3, "date": "1658976205", "time_retrieved": "2024-07-30T16:38:15.144689", "image_code": "uint iters = 12u;\n\nvec4 archipelago(uvec2 I) {\n    vec4 O = vec4(1);\n    bool b = false;\n    for(uint i = 0u; i++ < iters;I = i+1u+(I+(I.yx)/uvec2(11u,13u)-I.yx/uvec2(13u,11u))*2u/3u){\n        b = !b || bool(I.x & 1u) && bool(I.y & 1u);\n        //b = !b || bool(I.x & uint(b)) && bool(I.y & uint(b));\n\n        O.x = abs(float(b)-O.x)/2.;\n        O.xyz = abs(float(b)-abs(O.yzx))/2.;\n    }\n    if (!b) O = 1.-O;\n    return O;\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/4.+ iTime*16.);\n    O = archipelago(I);\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n    ;\n}\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  float\n  tempo1 =\n      pow(2.,1.+fmod(t*4.,2.))\n  ,\n  m1 =\n      pow(2.,1.+fmod(t/tempo1,2.))\n  ,\n  c1 = fmod(t*tempo1/2.,m1+fmod(t,m1)),\n  s1 = 1.+c1,\n  t1 = t*tempo1,\n  m2 = fmod(t1*(1.+fmod(t/2.,2.)),s1),\n  a=\n      5.*fract(-t*tempo/s1)\n  ,\n  nb =\n      7.*t*tempo*pow(2.,m2/5.+7.)/radians(180.)\n  ;\n  return\n      abs(vec2(cos(nb),sin(nb)))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 46, 46, 426], [428, 428, 464, 464, 529]], "test": "untested"}
{"id": "fdGfDt", "name": "Outline Shader attempt.", "author": "intrakits", "description": "Attempting to make an outline of an object in one march.", "tags": ["outline"], "likes": 1, "viewed": 257, "published": 3, "date": "1658975417", "time_retrieved": "2024-07-30T16:38:15.884710", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURFACE_DIST 0.01\n#define AA 1\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat dBox(vec3 p, vec3 s){\n    return length(max(abs(p)-s,0.));\n}\n\nvec2 colMin(vec2 res, vec2 obj){\n    res.x = min(obj.x,res.x);\n    if(obj.x == res.x){\n        res.y = obj.y;\n    }\n    return res;\n}\n\nvec2 GetDist(vec3 p){\n   vec2 res = vec2(p.y,1);\n   p.xz*=Rot(iTime);\n   p.xy*=Rot(iTime);\n   vec2 box = vec2(dBox(p, vec3(1,1,1)),2);\n   res = colMin(res,box);\n   return res;\n}\nvec2 RayMarch(vec3 ro, vec3 rd){\n    float width = .01;\n    // distance from origin\n    vec3 rd1 = rd+vec3(width,0,0);\n    vec3 rd2 = rd+vec3(-width,0,0);\n    vec3 rd3 = rd+vec3(0,width,0);\n    vec3 rd4 = rd+vec3(0,-width,0);\n    vec2 dO=vec2(0.,0.);\n    vec2 dO1=vec2(0.,0.);\n    vec2 dO2=vec2(0.,0.);\n    vec2 dO3=vec2(0.,0.);\n    vec2 dO4=vec2(0.,0.);\n    // march until max steps is achieved or object hit\n    for(int i=0; i <MAX_STEPS; i++){\n        // current point being evaluated\n        vec3 p = ro + dO.x*rd;\n        vec3 p1 = ro + dO1.x*rd1;\n        vec3 p2 = ro + dO2.x*rd2;\n        vec3 p3 = ro + dO3.x*rd3;\n        vec3 p4 = ro + dO4.x*rd4;\n        \n\n        // get distance to seam\n        vec2 ds = GetDist(p);\n        vec2 ds1 = GetDist(p1);\n        vec2 ds2 = GetDist(p2);\n        vec2 ds3 = GetDist(p3);\n        vec2 ds4 = GetDist(p4);\n        //move origin to new point\n        dO+=ds.x;\n        dO1+=ds1.x;\n        dO2+=ds2.x;\n        dO3+=ds3.x;\n        dO4+=ds4.x;\n        if(ds.y!=ds1.y||ds.y!=ds2.y||ds.y!=ds3.y||ds.y!=ds4.y){\n            dO.y=3.;\n        }\n        else if(ds.x < SURFACE_DIST){\n            dO.y = ds.y;\n            break;\n        }\n        else if( dO.x > MAX_DIST){\n            dO.y= -1.;\n            break;\n        }\n    }\n    return dO;\n}\nvec3 GetNormal(vec3 p){\n    //distance to point being analyzed\n    float d = GetDist(p).x;\n    \n    //distance to another point along the objects surface that is closeby\n    vec2 e = vec2(0.01,0);\n    \n    //slope between the two points\n    //note: swizzel is the .xxy or .yyx etc\n    vec3 n = d - vec3(\n         GetDist(p-e.xyy).x,\n         GetDist(p-e.yxy).x,\n         GetDist(p-e.yyx).x);\n         \n    return normalize(n);\n    \n}\nfloat GetLight(vec3 p){\n    //position of the light source\n    vec3 lightPos = vec3(4,5.,-3);\n    \n    lightPos.xz += vec2(sin(iTime),cos(iTime));\n    //light vector\n    vec3 l = normalize(lightPos-p);\n    \n    //normal of object\n    vec3 n = GetNormal(p);\n    \n    // dot product of the light vector and normal of the point\n    // will give us the amount of lighting to apply to the point\n    // dot() evaluates to values between -1 and 1, so we will clamp it\n    float diff = clamp(dot(n, l),0.,1.);\n    \n    // calculate if point should be a shadow:\n    // raymarch from point being calculated towards light source\n    // if hits surface of something else before the light,\n    // then it must be obstructed and thus is a shadow\n    // the slight offset \"p+n*SURFACE_DIST*1.1\" is needed to ensure the\n    // break condistions in the function are not met too early\n    float d = RayMarch(p+n*SURFACE_DIST*1.1,l).x;\n    if(d < length(lightPos-p)){\n        diff *= .1;\n    }\n    \n    return diff;\n}\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 Render (inout vec3 ro, inout vec3 rd, inout float reflVal){\n//------------------\n    vec2 d = RayMarch(ro,rd);\n// position of point\n    // start at ray origin\n    // move d units in the ray direction\n    vec3 p = ro + rd *d.x;\n //get diffuse lighting\n    float diff = GetLight(p);\n    vec3 col = vec3(0);\n    col = vec3(diff);\n    \n    vec3 n = GetNormal(p);\n    vec3 r = reflect(rd, n);\n    vec3 refl = texture(iChannel0, r).rgb;\n    refl= refl*abs(n.y) + refl*abs(n.z) + refl*abs(n.x);\n    \n    if(d.y == 1.){\n        col *= vec3(1,0,0);\n        reflVal = 0.;\n    }\n    else if(d.y==2.){\n        col*=vec3(1);\n       \n       reflVal = 0.1;\n    }\n    else if(d.y==3.){\n        col=vec3(0,1,0);\n       \n       reflVal = 0.1;\n    }\n     ro = p+n*SURFACE_DIST*3.;\n     rd=r;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    // origin is now (0,0)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec2 mo = iMouse.xy/iResolution.xy;\n    \n   \n    \n    //camera\n    //-----------------\n    // ray origin\n    //controls position\n    vec3 ta = vec3(0, 1,0);\n    vec3 ro = ta + vec3( 0, .5,-5.);\n    mat3 ca = setCamera( ro, ta,0.);\n//    vec3 ro = vec3(0,3,-5);\n\n    \n    //ray dir\n    //controls rotation\n    #if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 pt = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 pt = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n    vec3 rd = ca * normalize( vec3(pt,2.5) );\n    \n    float reflVal = 1.;\n    vec3 col = Render(ro,rd,reflVal);\n    vec3 bounce = reflVal*Render(ro,rd,reflVal);\n    col += bounce;\n    /*vec3 bounce2 = reflVal*Render(ro,rd,reflVal);\n    col += bounce2;*/\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 104, 104, 166], [168, 168, 195, 195, 234], [236, 236, 268, 268, 369], [371, 371, 392, 392, 548], [549, 549, 581, 581, 1833], [1834, 1834, 1857, 1896, 2267], [2268, 2268, 2291, 2326, 3266], [3267, 3267, 3319, 3319, 3496], [3498, 3498, 3562, 3583, 4293]], "test": "untested"}
{"id": "fsGfWt", "name": "Rainbow Sand Experiment 2", "author": "fenix", "description": "This is like one of those sand paintings in a bottle, but with crazy colors. The idea is to move particles within 2x2 cells ensuring no loss of mass.\n* Mouse at top of screen: grab particle spawner\n* Mouse elsewhere: delete particles\n* Space: reset", "tags": ["simulation", "particles", "sand"], "likes": 6, "viewed": 292, "published": 3, "date": "1658965678", "time_retrieved": "2024-07-30T16:38:16.724465", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x, ifc.y & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x, ifc.y | 1), 0);\n    fragColor = max(top, bottom);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int COLOR_CYCLE_FRAMES = 6000;\n\nfloat length2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nvec4 rainbow(int i)\n{\n    switch(i)\n    {\n        case 0:\n            return vec4(1.0, 0.0, 0.0, 1.0);\n        case 1:\n            return vec4(1.0, 0.5, 0.0, 1.0);\n        case 2:\n            return vec4(1.0, 1.0, 0.0, 1.0);\n        case 3:\n            return vec4(0.0, 1.0, 0.0, 1.0);\n        case 4:\n            return vec4(0.0, 0.0, 1.0, 1.0);\n        case 5:\n            return vec4(0.25, 0.0, 0.5, 1.0);\n        case 6:\n            return vec4(0.5, 0.0, 0.7, 1.0);\n    }\n}\n\nconst int COLOR_CHANGE_FRAMES = 200;\nvec4 colorByFrame(int frame)\n{   \n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex), rainbow(nextColorIndex), blend);\n}\n\nconst float PI = 3.141592653598793;\n\nvec2 rotate(float a)\n{\n    return vec2(sin(a), cos(a));\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (fragColor == vec4(0.0, 0.0, 0.0, 1.0))\n    {\n        float centerSpeedup = (sin(float(frame) * 0.001) * 0.5 + 0.5) * 0.02;\n        float centerTime = (float(frame) * (0.001 + centerSpeedup) - PI * 0.5);\n        vec2 spawnCenter = vec2(sin(centerTime) * 0.45 + 0.5, 0.95) * res.xy;\n        \n        if (mouse.z > 0.0 && mouse.y > res.y * 0.9)\n        {\n            spawnCenter.x = mouse.x;\n        }\n\n        float rotateTime = float(frame) * 0.2;\n        float SPAWN_DISTANCE = res.x * 0.02;\n        vec2 spawnPoints[3] = vec2[](spawnCenter + SPAWN_DISTANCE * rotate(rotateTime),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime + PI * (2.0 / 3.0)),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime - PI * (2.0 / 3.0)));\n\n        for (int i = 0; i < 3; ++i)\n        {\n            if (length2(spawnPoints[i] - fragCoord) < square(res.x * 0.003))\n            {\n                fragColor = colorByFrame(frame + COLOR_CHANGE_FRAMES * i);\n            }\n        }\n    }\n}\n\nconst vec4 EMPTY = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid removeSand(sampler2D mipSampler, int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (mouse.z > 0.0 && mouse.y < res.y * 0.9)\n    {\n        vec2 removePos = mouse.xy;\n\n        if (length2(removePos - fragCoord) < square(res.x * 0.02))\n        {\n            fragColor = EMPTY;\n        }\n    }\n    \n    vec3 fullTest0 = textureLod(mipSampler, vec2(0.2, 0.6), 3.0).xyz;\n    vec3 fullTest1 = textureLod(mipSampler, vec2(0.4, 0.4), 3.0).xyz;\n    vec3 fullTest2 = textureLod(mipSampler, vec2(0.6, 0.4), 3.0).xyz;\n    vec3 fullTest3 = textureLod(mipSampler, vec2(0.8, 0.6), 3.0).xyz;\n    \n    int deleteInterval = 1000;\n    if (any(greaterThan(fullTest0, vec3(0))) &&\n        any(greaterThan(fullTest1, vec3(0))) &&\n        any(greaterThan(fullTest2, vec3(0))) &&\n        any(greaterThan(fullTest3, vec3(0))))\n    {\n        deleteInterval = 10;\n    }\n    \n    if ((frame % deleteInterval == 0) && fragCoord.y < 1.0)\n    {\n        fragColor = EMPTY;\n    }\n    //fragColor = fullTest0;\n}\n\nvoid evolveByCells(sampler2D sampler, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n    \n    if (!all(lessThan(urCell, ires)) || (offset != ivec2(0) && (coord.x == 0 || coord.y == 0)))\n    {\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    vec4 ulValue = texelFetch(sampler, ulCell, 0);\n    vec4 urValue = texelFetch(sampler, urCell, 0);\n    vec4 llValue = texelFetch(sampler, llCell, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell, 0);\n    ulValue.w = urValue.w = llValue.w = lrValue.w = 1.0;\n    \n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    if (cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true))\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false))\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        lrValue = urValue;\n        urValue = EMPTY;\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(true, false,\n                           true, false))\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, true))\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGfWt.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[734, 734, 791, 791, 997]], "test": "untested"}
{"id": "ssVBDc", "name": "Quick Desktop Wallpaper 220727", "author": "NEAR_DREAM_UNITY", "description": "Wanted a quick desktop wallpaper for my PC -- 2022/07/27", "tags": ["desktopwallpaperquick"], "likes": 3, "viewed": 224, "published": 3, "date": "1658963031", "time_retrieved": "2024-07-30T16:38:17.528315", "image_code": "/*\n    Wanted a quick desktop wallpaper for my PC -- 2022/07/27\n*/\n#define  AA        12.\nfloat    AA_Recip  = 1. / AA;\nfloat    AA_InvSq  = 1. / (AA * AA);\n\n\n#define  Grid(P)          (10. * vec2(3. * (P).x + (P).y, 3. * (P).y))\n#define  Pulse(N, F)      pow(0.5 + 0.5 * cos(N), (F))\n#define  PulseGrid(G, F)  max(Pulse((G).x, (F)), Pulse((G).y, (F)))\n\n\nvec3  TealGridImage  (vec2 p) {\n    vec3 total = vec3(0., 0.4, 0.3);\n    total += sin(1.57 * p.y) * vec3(0., 0.2, 0.3);\n    total += sin(0.78 * p.x) * vec3(0., -0.07, 0.);\n    vec2 mgrid = Grid(p);\n    total += 0.03 * PulseGrid(mgrid, 10.);\n    total += vec3(0.15, 0., 0.) * (1. - PulseGrid(mgrid, 1.7));\n    vec2 hgrid = Grid(p - vec2(0.01, 0.01));\n    total += 0.02 * PulseGrid(hgrid, 40.);\n    return total;\n}\n\n\nvec3  NDUWatermarkImage  (vec2 p) {\n    p.x += 170. - iResolution.x;\n    p.y += 150. - iResolution.y;\n    p *= 0.008;\n    return vec3(NDULogo(p) ? -0.1 : 0.);\n}\n\n\nvoid  mainImage  (out vec4 o, vec2 p) {\n    vec3 total = vec3(0.);\n    for (float aax = 0.5; aax < AA; aax++)\n    for (float aay = 0.5; aay < AA; aay++) {\n        vec2 aap = p + vec2(aax, aay) * AA_Recip - 0.5;\n        vec2 q = (aap * 2. - iResolution.xy) / iResolution.y; \n        total += TealGridImage(q);\n        total += NDUWatermarkImage(aap);\n    }\n    o = vec4(total * AA_InvSq, 1.);\n}\n", "image_inputs": [], "common_code": "\n\nbool  OneSquare  (vec2 moved, float size) {\n    float hlt = 17. / 32.;\n    return (\n        moved.x >= -hlt           &&\n        moved.y >= -hlt           &&\n        moved.x <= size + hlt     &&\n        moved.y <= size + hlt     && (\n            moved.x < hlt         ||\n            moved.y < hlt         ||\n            moved.x > size - hlt  ||\n            moved.y > size - hlt  ));\n}\n\n\nbool  NDULogo  (vec2 p) {\n    vec2 zoom = p * 17.;\n    vec2 tilt = vec2(zoom.x * 15. - zoom.y * 8., zoom.y * 17.) / 15.;\n    return (\n        OneSquare(tilt - vec2(0.,    -8.),   8.)  ||\n        OneSquare(tilt - vec2(-4.,   -12.),  4.)  ||\n        OneSquare(tilt - vec2(8.,    0.),    4.)  ||\n        OneSquare(tilt - vec2(8.,    -12.),  4.)  ||\n        OneSquare(tilt - vec2(0.,    8.),    4.)  ||\n        OneSquare(tilt - vec2(-12.,  -4.),   4.)  ||\n        OneSquare(tilt - vec2(-12.,  8.),    4.)  ||\n        OneSquare(tilt - vec2(-8.,   0.),    8.)  );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 386, 386, 767], [770, 770, 805, 805, 930], [933, 933, 972, 972, 1326]], "test": "untested"}
{"id": "7dVBDc", "name": "gradient color grading", "author": "morisil", "description": "I wanted to understand how some image post-processing is made, for example in instagram filters.\n\nInspired by Matrix Color Grading by Inigo Quilez:\nhttps://twitter.com/iquilezles/status/1440847977560494084\n", "tags": ["filter", "color", "grading"], "likes": 7, "viewed": 453, "published": 3, "date": "1658959185", "time_retrieved": "2024-07-30T16:38:18.560555", "image_code": "const float GRADING_INTENSITY = .8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 topGrading = vec3(\n        1. - sin(iTime * 1.1) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.2) * GRADING_INTENSITY,\n        1. - sin(iTime * 1.3) * GRADING_INTENSITY\n    );\n    vec3 bottomGrading = vec3(\n        1. + cos(iTime * 1.4) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.5) * GRADING_INTENSITY,\n        1. - cos(iTime * 1.6) * GRADING_INTENSITY\n    );\n    vec3 colorGrading = mix(topGrading, bottomGrading, fragCoord.y / iResolution.y);\n    color = pow(color, colorGrading);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 94, 94, 717]], "test": "untested"}
{"id": "sdVBDc", "name": "Roguelike biome map", "author": "jarble", "description": "A simple biome map with lakes, forests, and deserts.", "tags": ["fractal", "biome", "roguelike"], "likes": 6, "viewed": 239, "published": 3, "date": "1658959078", "time_retrieved": "2024-07-30T16:38:24.171554", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false;\n    for(int i = 0; i++ < 15;I = (I)*2u/3u+uvec2(i)*2u){\n        I = I.yx + I.x/9u-I.y/9u;\n        b = !b || bool(I.x & 1u | I.y & 1u);\n        O.x = abs(float(b)-O.x/2.);\n        if (!b) O.xyz = abs(O.xyz- O.yzx*1.5);\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    \n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){   \n    float a1 = floor(a);\n    return\n        mod(floor(a),b)\n    ;\n}\n#define fmod1(x,y) fmod((x)+pow(2.,fmod((-x)*16.,2.)),y)\nvec2 mainSound(int samp, float t){\n  float tempo = 4.;\n  t /= tempo;\n  float\n  tempo1 =\n      4.\n  ,\n  m1 =\n      4.\n  ,\n  c1 = fmod(t*tempo1,m1+fmod1(t,m1)),\n  s1 = 1.+c1,\n  t1 = t*tempo1,\n  m2 = fmod(t1*(1.+fmod1(t,2.))/2.,s1),\n  a=\n      pow((1.-sqrt(fract((t*tempo1+m2+t1)/2.))/1.25),2.)*.2\n  ,\n  nb =\n      t*tempo*pow(2.,m2/5.+7.5)/(1.+fmod1(t+m2,2.))\n  ;\n  return\n      vec2(fract(nb*.998*2.),fract(nb))*a\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 463]], "test": "untested"}
{"id": "7sVBWc", "name": "Fractal camouflage", "author": "jarble", "description": "A simple camouflage pattern.", "tags": ["fractal", "music", "camo", "camouflage"], "likes": 6, "viewed": 225, "published": 3, "date": "1658952959", "time_retrieved": "2024-07-30T16:38:25.126999", "image_code": "void mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false;\n    for(int i = 0; i++ < 9;I = (I+I.x/9u-I.y/9u)*2u/3u){\n        b = !b || (I.x & 3u) != (I.y & 2u);\n        O.x = abs(float(b)-O.x/2.);\n        O.xyz = abs(float(b)-abs(O.yzx)/1.5);\n    }\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n        //b-mod(floor(-a*2.),b/2.)\n    ;\n}\n\nvec2 mainSound(int samp, float time){\n  float s1 =\n      8.,\n  s2 = 4.,\n  t = time,\n  m1 =\n      0.\n  ;\n  t /= 2.;\n  for(int i = 0; i < 3; i++){\n      \n      t *= 1.+fmod(t/2.,2.);\n      t += floor(-t/2.);\n      m1 =\n      fmod(-t*2.,s2);\n      \n      t = t/(1.+fmod(m1+floor(t*2.)+floor(t/2.),2.));\n  }\n  float\n  m3 =\n      fmod((t),s1/2.)\n  ;\n  float m2 =\n      1. + floor(fmod(t,s1/2.));\n  ;\n  float a=\n      pow((sqrt(fract(-t))),2.)*8.\n  ;\n  float nb = pow(2.,(m3+m2-m1)/5.+7.)*2.;\n  return\n      abs(.5-abs(vec2(sin(time*nb*.998)*a,sin(time*nb)*a)))*2.\n  ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 302]], "test": "untested"}
{"id": "7sKBWc", "name": "deep 5input NOR", "author": "lomateron", "description": "probably not the deepest 5input NOR\nbut close because it is made from the combination of the deepest 4input NOR", "tags": ["binaryfunction"], "likes": 6, "viewed": 195, "published": 3, "date": "1658951229", "time_retrieved": "2024-07-30T16:38:26.395607", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define pi 3.141592653589793238\nfloat nor(float a, float b)\n{\n    return (+cos(pi*(a*0.+b*0.))\n            +cos(pi*(a*0.+b*1.))\n            +cos(pi*(a*1.+b*0.))\n            +cos(pi*(a*1.+b*1.)))*.25;//change .25 to something else\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float a = A(u+vec2( 1, 0)).x;\n    float b = A(u+vec2( 0, 1)).x;\n    float c = A(u+vec2(-1, 0)).x;\n    float d = A(u+vec2( 0,-1)).x;\n    float e = A(u+vec2( 0, 0)).x;\n    float r1 = 0.;\n    float r2 = 0.;\n    {\n        float e = nor( a , a );\n        float f = nor( b , b );\n        float g = nor( d , d );\n        float h = nor( a , b );\n        float i = nor( e , f );\n        float j = nor( h , i );\n        float k = nor( j , c );\n        float l = nor( j , k );\n        float m = nor( c , k );\n        float n = nor( l , m );\n        float o = nor( n , i );\n        float p = nor( n , d );\n        float q = nor( o , g );\n              r1= nor( p , q );\n    }\n    {\n        float o1 = nor(a,b);  float o0 = o1;\n        float o2 = nor(o1,a); \n        float o3 = nor(o1,b);\n              a  = nor(o2,o3);\n              b  = c;\n              o1 = nor(a,b);\n              o2 = nor(o1,a);\n              o3 = nor(o1,b);\n        float o4 = nor(o2,o3);\n        float o5 = nor(o4,o4);\n        float d2 = nor(d,d);\n              o5 = nor(o5,d2);\n              o4 = nor(o4,o0);\n              o4 = nor(o4,o4);\n              o4 = nor(o4,d);\n              r2 = nor(o4,o5);\n    }\n    float ee = nor(e,e);\n          r1 = nor( r1 , ee);\n          r2 = nor( r2 , e);\n    float o  = nor( r1 , r2);\n          o  = nor( o , o);\n    if(iFrame==0||iMouse.z>.5)\n    {\n        vec2 v = 6.*(u        *2.-iResolution.xy)/iResolution.y;\n        vec2 m = 8.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n        o = fract(cos(dot(u,vec2(1234.76543,4321.963753)))*2467.5678);\n        o = round(o);\n        //o = step(dot(v,v),dot(m,m)*.1);\n        //o = float(u.x==100.5 && u.y==100.5);\n    }\n    //if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=A(u).x;}\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "sdVBD3", "name": "PT workshop 6: Direct illum.", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 6: Rendering direct illumination using Monte Carlo integration and ray tracing.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 398, "published": 3, "date": "1658945580", "time_retrieved": "2024-07-30T16:38:27.384962", "image_code": "#define TRIANGLE_COUNT 30\n#define SAMPLE_COUNT 1\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n                                                                                                                                                                                                                                                    vec3 v0 = tri.positions[0];     mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);     vec3 solution = inverse(matrix) * (origin - v0);     out_t = solution.x;     vec2 barys = solution.yz;\n                                                                                                                                                                                                                                                    return out_t >= 0.001 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n                                                                                                                                                                                                                                                    for (int i = 0; i != TRIANGLE_COUNT; ++i) {         float t;         if (ray_triangle_intersection(t, origin, direction, tris[i]) && t < out_t) {             out_t = t;             out_tri = tris[i];         }     }     return out_t < 1.0e38;\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n                                                                                                                                                                                                                                                    float z = 2.0 * random_numbers[1] - 1.0;     float phi = 2.0 * M_PI * random_numbers[0];     float x = cos(phi) * sqrt(1.0 - z * z);     float y = sin(phi) * sqrt(1.0 - z * z);     return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n                                                                                                                                                                                                                                                    vec3 direction = sample_sphere(random_numbers);     if (dot(normal, direction) < 0.0)         direction -= 2.0 * dot(normal, direction) * normal;     return direction;\n}\n\n\n// Computes the sum of emitted radiance and reflected radiance due to direct\n// illumination\n// \\param point The point being shaded (x)\n// \\param tri The triangle on which the point is located\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate with N=1 of the direct illumination (L_o(x))\nvec3 compute_direct_illumination(vec3 point, triangle_t tri, inout uvec2 seed) {\n    vec3 radiance = vec3(0.0);\n    // TODO\n    return radiance;\n}\n\n\n// Finds the triangle intersected by the given ray and performs shading without\n// global illumination.\n// \\param origin The position at which the ray starts\n// \\param direction The direction vector of the ray\n// \\param seed Needed for get_random_numbers()\n// \\return A Monte Carlo estimate of the reflected (direct only) and emitted\n//         radiance at the point intersected by the ray (i.e. the color)\nvec3 get_direct_ray_radiance(vec3 origin, vec3 direction, inout uvec2 seed) {\n    float t;\n    triangle_t tri;\n    if (ray_mesh_intersection(t, tri, origin, direction))\n        return compute_direct_illumination(origin + t * direction, tri, seed);\n    else\n        return vec3(0.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Use a different seed for each pixel and each frame\n    uvec2 seed = uvec2(pixel_coord) ^ uvec2(iFrame << 16, iFrame << 16 + 237);\n    // Take the mean of SAMPLE_COUNT Monte Carlo estimates for direct\n    // illumination\n    out_color.rgb = vec3(0.0);\n    for (int i = 0; i != SAMPLE_COUNT; ++i)\n        out_color.rgb += get_direct_ray_radiance(camera_position, ray_direction, seed);\n    out_color.rgb /= float(SAMPLE_COUNT);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 592, 703, 703, 1063], [1513, 1863, 1957, 1957, 2751], [2754, 3133, 3231, 3294, 14681], [14684, 14916, 14959, 15020, 15346], [15349, 15513, 15554, 15554, 16003], [16006, 16121, 16179, 16179, 16593], [16596, 16915, 16995, 16995, 17061], [17064, 17471, 17548, 17548, 17755], [17758, 17758, 17815, 17868, 18849]], "test": "untested"}
{"id": "7sKBD3", "name": "PT workshop 5: Hemisphere sampl.", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 5: Uniform sampling of a unit hemisphere.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 378, "published": 3, "date": "1658945512", "time_retrieved": "2024-07-30T16:38:28.233692", "image_code": "#define SAMPLE_COUNT 512\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n                                                                                                                                                                                                                                                    float z = 2.0 * random_numbers[1] - 1.0;     float phi = 2.0 * M_PI * random_numbers[0];     float x = cos(phi) * sqrt(1.0 - z * z);     float y = sin(phi) * sqrt(1.0 - z * z);     return vec3(x, y, z);\n}\n\n\n// Like sample_sphere() but only samples the hemisphere where the dot product\n// with the given normal (n) is >= 0\nvec3 sample_hemisphere(vec2 random_numbers, vec3 normal) {\n    // TODO\n    return vec3(0.0, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Splat spherical samples as Gaussians\n    out_color.rgb = vec3(0.0);\n    vec3 sphere_camera_position = vec3(0.0, 3.2, 0.0);\n    uvec2 seed = uvec2(0xdeadbeef, 0xc0ffee);\n    for (int i = 0; i != SAMPLE_COUNT; ++i) {\n        vec3 normal = normalize(vec3(1.0, 2.0, 3.0));\n        vec3 dir = sample_hemisphere(get_random_numbers(seed), normal);\n        float gaussian = exp(-100000.0 * (1.0 - dot(ray_direction, normalize(dir - sphere_camera_position))));\n        out_color.rgb += 0.5 * vec3(gaussian);\n    }\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 568, 679, 679, 1039], [1042, 1274, 1317, 1378, 1704], [1707, 1871, 1912, 1912, 2361], [2364, 2479, 2537, 2549, 2583], [2586, 2586, 2643, 2696, 3757]], "test": "untested"}
{"id": "ssKBD3", "name": "PT workshop 4: Sphere sampling", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 4: Implementing uniform sampling of the unit sphere.test.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-2.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 396, "published": 3, "date": "1658945411", "time_retrieved": "2024-07-30T16:38:29.030562", "image_code": "#define SAMPLE_COUNT 512\n#define M_PI 3.141592653589793238462643\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A pseudo-random number generator\n// \\param seed Numbers that are different for each invocation. Gets updated so\n//             that it can be reused.\n// \\return Two independent, uniform, pseudo-random numbers in [0,1) (u_0, u_1)\nvec2 get_random_numbers(inout uvec2 seed) {\n    // This is PCG2D: https://jcgt.org/published/0009/03/02/\n    seed = 1664525u * seed + 1013904223u;\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    seed.x += 1664525u * seed.y;\n    seed.y += 1664525u * seed.x;\n    seed ^= (seed >> 16u);\n    // Convert to float. The constant here is 2^-32.\n    return vec2(seed) * 2.32830643654e-10;\n}\n\n\n// Given uniform random numbers u_0, u_1 in [0,1)^2, this function returns a\n// uniformly distributed point on the unit sphere (i.e. a random direction)\n// (omega)\nvec3 sample_sphere(vec2 random_numbers) {\n    // TODO\n    return vec3(0.0, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Splat spherical samples as Gaussians\n    out_color.rgb = vec3(0.0);\n    vec3 sphere_camera_position = vec3(0.0, 3.2, 0.0);\n    uvec2 seed = uvec2(0xdeadbeef, 0xc0ffee);\n    for (int i = 0; i != SAMPLE_COUNT; ++i) {\n        vec3 dir = sample_sphere(get_random_numbers(seed));\n        float gaussian = exp(-100000.0 * (1.0 - dot(ray_direction, normalize(dir - sphere_camera_position))));\n        out_color.rgb += 0.5 * vec3(gaussian);\n    }\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 568, 679, 679, 1039], [1042, 1274, 1317, 1378, 1704], [1707, 1871, 1912, 1924, 1958], [1961, 1961, 2018, 2071, 3066]], "test": "untested"}
{"id": "7dKBD3", "name": "PT workshop 3: Ray-mesh test", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 3: Implementing a ray-mesh intersection test.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 1, "viewed": 916, "published": 3, "date": "1658945328", "time_retrieved": "2024-07-30T16:38:30.100701", "image_code": "#define TRIANGLE_COUNT 30\n\n\n// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n                                                                                                                                                                                                                                                    vec3 v0 = tri.positions[0];     mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);     vec3 solution = inverse(matrix) * (origin - v0);     out_t = solution.x;     vec2 barys = solution.yz;\n                                                                                                                                                                                                                                                    return out_t >= 0.0 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\n// Checks whether a ray intersects any triangle of the mesh\n// \\param out_t The ray parameter at the closest intersection (if any) (t)\n// \\param out_tri The closest triangle that was intersected (if any)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\return true if there is an intersection, false otherwise\nbool ray_mesh_intersection(out float out_t, out triangle_t out_tri, vec3 origin, vec3 direction) {\n    // Definition of the mesh geometry (exported from Blender)\n    triangle_t tris[TRIANGLE_COUNT];\n    tris[0].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[0].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[0].positions[2] = vec3(0.000000133, -0.559199989, 0.000000040); tris[1].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[1].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[1].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[2].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[2].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[2].positions[2] = vec3(0.555999935, -0.000000119, 0.000000040); tris[3].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[3].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[3].positions[2] = vec3(0.313999921, -0.455999970, 0.000000040); tris[4].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[4].positions[1] = vec3(0.472000152, -0.406000137, 0.329999954); tris[4].positions[2] = vec3(0.472000152, -0.406000137, 0.000000040); tris[5].positions[0] = vec3(0.264999926, -0.296000093, 0.329999954); tris[5].positions[1] = vec3(0.313999921, -0.455999970, 0.000000040); tris[5].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[0] = vec3(0.313999921, -0.455999970, 0.329999954); tris[6].positions[1] = vec3(0.472000152, -0.406000137, 0.000000040); tris[6].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[7].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[7].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[7].positions[2] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[0] = vec3(0.240000039, -0.271999955, 0.165000007); tris[8].positions[1] = vec3(0.082000092, -0.225000143, 0.000000040); tris[8].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[9].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[9].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[9].positions[2] = vec3(0.240000039, -0.271999955, 0.000000040); tris[10].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[10].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[10].positions[2] = vec3(0.130000070, -0.064999968, 0.000000040); tris[11].positions[0] = vec3(0.082000092, -0.225000143, 0.000000040); tris[11].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[11].positions[2] = vec3(0.130000070, -0.064999968, 0.165000007); tris[12].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[12].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[12].positions[2] = vec3(0.000000133, -0.000000119, 0.000000040); tris[13].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[13].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[13].positions[2] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[0] = vec3(0.290000081, -0.113999903, 0.000000040); tris[14].positions[1] = vec3(0.290000081, -0.114000171, 0.165000007); tris[14].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[15].positions[0] = vec3(0.130000070, -0.064999968, 0.000000040); tris[15].positions[1] = vec3(0.130000070, -0.064999968, 0.165000007); tris[15].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[16].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[16].positions[1] = vec3(0.000000133, -0.000000119, 0.000000040); tris[16].positions[2] = vec3(0.000000133, -0.000000119, 0.548799932); tris[17].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[17].positions[1] = vec3(0.082000092, -0.225000143, 0.165000007); tris[17].positions[2] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[0] = vec3(0.130000070, -0.064999968, 0.165000007); tris[18].positions[1] = vec3(0.240000039, -0.271999955, 0.165000007); tris[18].positions[2] = vec3(0.290000081, -0.114000171, 0.165000007); tris[19].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[19].positions[1] = vec3(0.423000127, -0.246999890, 0.000000040); tris[19].positions[2] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[0] = vec3(0.423000127, -0.247000158, 0.329999954); tris[20].positions[1] = vec3(0.264999926, -0.296000093, 0.000000040); tris[20].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[21].positions[0] = vec3(0.423000127, -0.246999890, 0.000000040); tris[21].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[21].positions[2] = vec3(0.472000152, -0.406000137, 0.329999954); tris[22].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[22].positions[1] = vec3(0.555999935, -0.000000119, 0.000000040); tris[22].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[23].positions[0] = vec3(0.000000133, -0.559199989, 0.000000040); tris[23].positions[1] = vec3(0.000000133, -0.000000119, 0.548799932); tris[23].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[24].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[24].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[24].positions[2] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[0] = vec3(0.000000133, -0.559199989, 0.548799932); tris[25].positions[1] = vec3(0.555999935, -0.559199989, 0.548799932); tris[25].positions[2] = vec3(0.555999935, -0.559199989, 0.000000040); tris[26].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[26].positions[1] = vec3(0.264999926, -0.296000093, 0.329999954); tris[26].positions[2] = vec3(0.313999921, -0.455999970, 0.329999954); tris[27].positions[0] = vec3(0.555999935, -0.000000119, 0.548799932); tris[27].positions[1] = vec3(0.555999935, -0.559199989, 0.000000040); tris[27].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932); tris[28].positions[0] = vec3(0.472000152, -0.406000137, 0.329999954); tris[28].positions[1] = vec3(0.423000127, -0.247000158, 0.329999954); tris[28].positions[2] = vec3(0.264999926, -0.296000093, 0.329999954); tris[29].positions[0] = vec3(0.000000133, -0.000000119, 0.548799932); tris[29].positions[1] = vec3(0.555999935, -0.000000119, 0.548799932); tris[29].positions[2] = vec3(0.555999935, -0.559199989, 0.548799932);\n    tris[0].normal = vec3(0.0, 1.0, 0.0); tris[1].normal = vec3(0.301707575, -0.953400513, 0.0); tris[2].normal = vec3(0.0, 0.0, 1.0); tris[3].normal = vec3(-0.956165759, -0.292825958, -0.0); tris[4].normal = vec3(0.955649049, 0.294507888, 0.0); tris[5].normal = vec3(-0.956165759, -0.292825958, 0.0); tris[6].normal = vec3(0.301707575, -0.953400513, 0.0); tris[7].normal = vec3(-0.285119946, -0.958491845, 0.0); tris[8].normal = vec3(-0.285119946, -0.958491845, -0.0); tris[9].normal = vec3(0.953400053, -0.301709030, 0.0); tris[10].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[11].normal = vec3(-0.957826408, 0.287347476, 0.0); tris[12].normal = vec3(0.0, 0.0, 1.0); tris[13].normal = vec3(0.292825408, 0.956165927, 0.000001554); tris[14].normal = vec3(0.953399906, -0.301709496, -0.000000490); tris[15].normal = vec3(0.292826874, 0.956165478, -0.0); tris[16].normal = vec3(1.0, 0.0, 0.0); tris[17].normal = vec3(0.0, 0.0, 1.0); tris[18].normal = vec3(0.0, 0.0, 1.0); tris[19].normal = vec3(-0.296209850, 0.955122885, 0.000000776); tris[20].normal = vec3(-0.296208371, 0.955123343, 0.0); tris[21].normal = vec3(0.955648909, 0.294508341, 0.000000239); tris[22].normal = vec3(-1.0, 0.0, -0.0); tris[23].normal = vec3(1.0, 0.0, 0.0); tris[24].normal = vec3(0.0, 0.0, -1.0); tris[25].normal = vec3(-0.0, 1.0, 0.0); tris[26].normal = vec3(0.0, 0.0, 1.0); tris[27].normal = vec3(-1.0, -0.0, 0.0); tris[28].normal = vec3(0.0, 0.0, 1.0); tris[29].normal = vec3(0.0, 0.0, -1.0);\n    tris[0].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[1].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[2].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[3].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[4].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[5].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[6].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[7].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[8].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[9].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[10].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[11].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[12].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[13].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[14].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[15].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[16].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[17].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[18].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[19].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[20].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[21].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[22].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[23].color = vec3(0.289999992, 0.663999975, 0.324999988); tris[24].color = vec3(0.0, 0.0, 0.0); tris[25].color = vec3(0.874000013, 0.874000013, 0.875000000); tris[26].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[27].color = vec3(0.730000019, 0.246000007, 0.250999987); tris[28].color = vec3(0.839039981, 0.839039981, 0.839999974); tris[29].color = vec3(0.0, 0.0, 0.0);\n    tris[0].emission = vec3(0.0, 0.0, 0.0); tris[1].emission = vec3(0.0, 0.0, 0.0); tris[2].emission = vec3(0.0, 0.0, 0.0); tris[3].emission = vec3(0.0, 0.0, 0.0); tris[4].emission = vec3(0.0, 0.0, 0.0); tris[5].emission = vec3(0.0, 0.0, 0.0); tris[6].emission = vec3(0.0, 0.0, 0.0); tris[7].emission = vec3(0.0, 0.0, 0.0); tris[8].emission = vec3(0.0, 0.0, 0.0); tris[9].emission = vec3(0.0, 0.0, 0.0); tris[10].emission = vec3(0.0, 0.0, 0.0); tris[11].emission = vec3(0.0, 0.0, 0.0); tris[12].emission = vec3(0.0, 0.0, 0.0); tris[13].emission = vec3(0.0, 0.0, 0.0); tris[14].emission = vec3(0.0, 0.0, 0.0); tris[15].emission = vec3(0.0, 0.0, 0.0); tris[16].emission = vec3(0.0, 0.0, 0.0); tris[17].emission = vec3(0.0, 0.0, 0.0); tris[18].emission = vec3(0.0, 0.0, 0.0); tris[19].emission = vec3(0.0, 0.0, 0.0); tris[20].emission = vec3(0.0, 0.0, 0.0); tris[21].emission = vec3(0.0, 0.0, 0.0); tris[22].emission = vec3(0.0, 0.0, 0.0); tris[23].emission = vec3(0.0, 0.0, 0.0); tris[24].emission = vec3(3.0, 3.0, 3.0); tris[25].emission = vec3(0.0, 0.0, 0.0); tris[26].emission = vec3(0.0, 0.0, 0.0); tris[27].emission = vec3(0.0, 0.0, 0.0); tris[28].emission = vec3(0.0, 0.0, 0.0); tris[29].emission = vec3(3.0, 3.0, 3.0);\n    // Find the nearest intersection across all triangles\n    out_t = 1.0e38;\n    // TODO\n    return false;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Trace a ray and display the triangle color+emission\n    triangle_t tri;\n    float t;\n    out_color.rgb = vec3(0.0);\n    if (ray_mesh_intersection(t, tri, camera_position, ray_direction))\n        out_color.rgb = tri.color + tri.emission;\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[28, 529, 640, 640, 1000], [1450, 1800, 1894, 1894, 2686], [2689, 3068, 3166, 3229, 14159], [14162, 14162, 14219, 14272, 15065]], "test": "untested"}
{"id": "sdyBDK", "name": "PT workshop 2: Ray-triangle test", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 2: Implementing a ray-triangle intersection test.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 722, "published": 3, "date": "1658945246", "time_retrieved": "2024-07-30T16:38:30.875629", "image_code": "// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n                                                                                                                                                                                                                                                    vec3 image_plane_pos = left_bottom + x * right + y * up;     return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    out_t = 0.0;\n    // TODO\n    return false;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Trace a ray against a single triangle and display t\n    triangle_t tri;\n    tri.positions[0] = vec3(0.555999935, -0.000000119, 0.548799932);\n    tri.positions[1] = vec3(0.555999935, -0.000000119, 0.000000040);\n    tri.positions[2] = vec3(0.555999935, -0.559199989, 0.000000040);\n    tri.normal = vec3(-1.0, 0.0, -0.0);\n    tri.color = vec3(0.730000019, 0.246000007, 0.250999987);\n    tri.emission = vec3(0.0, 0.0, 0.0);\n    float t;\n    out_color.rgb = vec3(0.0);\n    if (ray_triangle_intersection(t, camera_position, ray_direction, tri))\n        out_color.rgb = vec3(0.7 * t);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 501, 612, 612, 972], [1422, 1772, 1866, 1866, 1915], [1918, 1918, 1975, 2028, 3162]], "test": "untested"}
{"id": "fdVfDc", "name": "Simple double ended truchet(RGB)", "author": "mrange", "description": "License CC0: Simple double ended truchet with COLORS\nSeems I am having a truchet kind of week. Anyway, from experimenting \nwith Wave Function Collapse algorithms or rather cheating it I figured\nI could use the fake idea to create double ended truchet", "tags": ["2d", "truchet"], "likes": 17, "viewed": 497, "published": 3, "date": "1658941144", "time_retrieved": "2024-07-30T16:38:31.778215", "image_code": "// License CC0: Simple double ended truchet with COLORS\n// Seems I am having a truchet kind of week. Anyway, from experimenting \n// with Wave Function Collapse algorithms or rather cheating it I figured\n// I could use the fake idea to create double ended truchets\n// Turned out ok and I thought another truchet shader wouldn't hurt.\n\n// A colorized version of: https://www.shadertoy.com/view/NdKfW3\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat cell(vec2 p, float off, float linew) {\n  float r = 0.5+off;\n  float d0 = length(p-0.5)-r; \n  float d1 = length(p+0.5)-r;\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - linew;\n  return d;\n}\n\nfloat truchet_var(float h, float cs, vec2 cp, float off, float linew) {\n  float hs = h >= 0.5 ? 1.0 : -1.0;\n  cp = hs > 0.0 ? cp : vec2(cp.y, -cp.x);\n\n  return cell(cp, off*hs*cs, linew);\n}\n\nvec3 effect(vec2 p) {\n  float hoff0 = 0.5+0.5*sin(0.5*p.x)*sin(0.5*p.y);\n  float hoff1 = 0.5+0.5*cos(0.33*p.x)*cos(0.66*p.y);\n  \n  const float z = 3.0;\n  float aa = 2.0/RESOLUTION.y;\n  aa *= z;\n  p *= z;\n\n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n\n  float h0 = hash(cn);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(8677.0*h0);\n  float cs = mod(cn.x+cn.y, 2.0) >= 1.0 ? -1.0 : 1.0; \n\n  const float off = 0.1;\n  const float linew = 0.01;\n  float d0 = truchet_var(h1, cs, cp, off, linew*mix(1.0, 2.0, hoff0));\n  float d1 = truchet_var(h2, cs, cp, -off, linew*mix(1.0, 2.0, hoff1));\n\n  vec3 col = vec3(0.0);\n  \n  vec3 bcol0 = hsv2rgb(vec3(hoff1, 0.95, 1.0));\n  vec3 bcol1 = hsv2rgb(vec3(hoff0, 0.95, 1.0));\n  \n  vec3 dcol0 = sqrt(bcol0); \n  vec3 dcol1 = sqrt(bcol1); \n\n  vec3 gcol0 = bcol0*exp(-10.0*max(3.0*d0, 0.0)); \n  vec3 gcol1 = bcol1*exp(-10.0*max(3.0*d1, 0.0)); \n\n  float f0 = smoothstep(aa, -aa, d0);\n  float f1 = smoothstep(aa, -aa, d1);\n\n  float shd0 = 1.0-exp(-5.0*max(3.0*d0, 0.0));\n  float shd1 = 1.0-exp(-5.0*max(3.0*d1, 0.0));\n  \n  if (h0 > 0.5) {\n    col += gcol0; \n    col = mix(col, dcol0, f0);\n    col *= shd1;\n    col += gcol1;\n    col = mix(col, dcol1, f1);\n  } else {\n    col += gcol1;\n    col = mix(col, dcol1, f1);\n    col *= shd0;\n    col += gcol0;\n    col = mix(col, dcol0, f0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  vec2 pp = p;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  const float r = 20.0;\n  const float spd = 0.5;\n  p += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n   \n  vec3 col = effect(p);\n  col *= smoothstep(1.5, 0.5, length(pp));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVfDc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[611, 611, 633, 633, 779], [1074, 1134, 1155, 1155, 1225], [1227, 1227, 1271, 1271, 1423], [1425, 1425, 1496, 1496, 1614], [1616, 1616, 1637, 1637, 2956], [2958, 2958, 3013, 3013, 3343]], "test": "untested"}
{"id": "7sKfzV", "name": "HUD Aim", "author": "VPaltoDance", "description": "Exploring shapes.", "tags": ["shapes", "polarcoordinates", "ui", "hud"], "likes": 14, "viewed": 401, "published": 3, "date": "1658938871", "time_retrieved": "2024-07-30T16:38:33.129602", "image_code": "// this shader is an attempt to reproduse one of the huds at https://graphicriver.net/item/hud-elements-/17159709#\n\n#define N 7.0f\n\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\n#define SMOOTH_BORDER_SIZE 0.0035\n\n#define BACKGROUND_COLOR vec3(0.01, 0.06, 0.11)\n#define BASE_COLOR vec3(0.13, 0.53, 0.6)\n#define SECOND_COLOR vec3(0.4, 0.45, 0.5)\n#define CIRCLE_COLOR vec3(0.74, 0.85, 0.93)\n#define DARK_RED_COLOR vec3(0.64, 0.16, 0.2)\n\nstruct Transform\n{\n    vec2 offset;\n    vec2 scale;\n    float angle;\n};\n\nvec2 transform_cartesian(vec2 xy, Transform transform)\n{\n     xy -= transform.offset;\n     xy *= transform.scale;\n     return xy;\n}\n\nvec2 transform_to_polar(vec2 xy)\n{\n    return vec2(length(xy), atan(xy.y, xy.x));\n}\n\nvec2 transform_to_polar(vec2 xy, Transform transform)\n{\n    return vec2(length(xy), atan(xy.y, xy.x) - transform.angle);\n}\n\nfloat circle_field(vec2 coords, Transform transform, float size,  float smooth_border)\n{\n    vec2 polar_coords = transform_to_polar(coords, transform);  \n\n    return smoothstep(polar_coords.x, polar_coords.x + smooth_border, size);\n}\n\nfloat circle_line(vec2 uv, Transform transform, float size, float smooth_border,float thickness)\n{\n    \n    vec2 uvT = transform_cartesian(uv, transform);\n    return circle_field(uvT, transform, size, smooth_border) - \n            circle_field(uvT, transform, size - thickness, smooth_border);\n}\n\nfloat circle_pannel_field(vec2 coords, Transform transform, float size,  float smooth_border)\n{\n    vec2 polar_coords = transform_to_polar(coords, transform);\n    float restrictions = float(abs(cos(polar_coords.y + PI / 2.0 + transform.angle)) < 0.55); \n    \n    return smoothstep(polar_coords.x, polar_coords.x + smooth_border, size) * \n            smoothstep(0.0,1.0,sin( 509.0 * (polar_coords.y) / TWO_PI)) * restrictions;\n}\n\nfloat create_circle_pannel(vec2 uv, Transform transform, float size, float smooth_border,float thickness)\n{\n    vec2 uvT = transform_cartesian(uv, transform);\n    return circle_pannel_field(uvT, transform, size, smooth_border) - \n            circle_pannel_field(uvT, transform, size - thickness, smooth_border);\n}\n\nfloat regular_polygon_field(vec2 coords, Transform transform, float num_sides, float size, float smooth_border)\n{    \n\n    vec2 polar_coords = transform_to_polar(coords, transform);  \n    // We need to map each circle point to a particular triangle point in polar coordinates to get\n    // a concentric triangles like field\n    float da = TWO_PI / num_sides;\n    \n    float tf = cos(floor(0.5 + polar_coords.y/da) * da - polar_coords.y) * polar_coords.x;\n    return smoothstep(tf,tf + smooth_border, size);\n}\n\nfloat regular_polygon_line(vec2 coords, Transform transform, float num_sides, float size, float smooth_border,float thickness)\n{\n    return regular_polygon_field(coords, transform, num_sides, size, smooth_border) - \n            regular_polygon_field(coords, transform, num_sides, size - thickness, smooth_border);\n}\n\nfloat create_brace(vec2 uv, Transform transform, float num_sides, float size, float smooth_border, float thickness, vec4 crop)\n{\n    vec2 uvT = transform_cartesian(uv, transform);\n    \n    float brace = regular_polygon_line(uvT, transform, num_sides, size, smooth_border, thickness) * \n            (smoothstep(crop.x, crop.x + smooth_border, uvT.x) - \n             smoothstep(crop.y, crop.y + smooth_border, uvT.x)) *\n            (smoothstep(crop.z, crop.z + smooth_border, uvT.y) - \n             smoothstep(crop.w, crop.w + smooth_border, uvT.y));\n             \n    return brace;\n}\n\n\nfloat create_symmetrical_braces(vec2 uv, Transform transform, float num_sides, float size, float smooth_border, float thickness, vec4 crop)\n{\n    \n    float brace1 = create_brace(uv, transform, num_sides, size, smooth_border, thickness, crop);\n             \n    transform.offset.x = -transform.offset.x;\n    crop = -crop.yxwz;\n             \n    float brace2 = create_brace(uv, transform, num_sides, size, smooth_border, thickness, crop);\n             \n     return max(brace1, brace2);\n}\n\nvoid animation()\n{\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 baseUV = uv - 0.5f;\n    baseUV.x *= iResolution.x/iResolution.y;\n    \n    vec3 color = BACKGROUND_COLOR;\n    \n    \n    \n    // ----------------------------- Animation -----------------------------\n    \n    float animation_timer = smoothstep(0.0, 0.7,sin(iTime * 2.0));\n    float arrows_animation = -0.02 * animation_timer;\n    float braces_animation = -0.08 * animation_timer;\n    float circle_animation = -0.01 * animation_timer;\n    float cross_animation = -PI * animation_timer / 2.0;\n    \n    // ----------------------------- Main braces -----------------------------\n    \n    Transform transform = Transform(vec2(-0.3, 0.0), vec2(1.0, 1.0), 0.0);\n    vec4 crop = vec4(-1.0, -0.3, -0.5, 0.5);\n    float object = create_symmetrical_braces(baseUV, transform, 6.0f, 0.52, SMOOTH_BORDER_SIZE, 0.006, crop);\n\n    color = mix(color, mix(BASE_COLOR, DARK_RED_COLOR , animation_timer), object); \n    \n    // ----------------------------- Double braces -----------------------------\n    \n    transform = Transform(vec2(0.2 + braces_animation, 0.0), vec2(1.0, 1.0), PI / 6.0);\n    crop = vec4(0.3, 1.0, -0.5, 0.5);\n    object = create_symmetrical_braces(baseUV, transform, 6.0f, 0.4, SMOOTH_BORDER_SIZE, 0.006, crop);\n    \n    \n    transform = Transform(vec2(-0.22 - braces_animation, 0.0), vec2(1.0, 1.0), PI / 6.0);\n    crop = vec4(-1.0, -0.3, -0.5, 0.5);\n    object += create_symmetrical_braces(baseUV, transform, 6.0f, 0.4, SMOOTH_BORDER_SIZE, 0.006, crop);\n    \n    color = mix(color, SECOND_COLOR, object); \n    \n    // ----------------------------- Aim arrows -----------------------------\n    \n    transform = Transform(vec2(0.23 + arrows_animation, 0.0), vec2(1.0, 1.0), PI / 6.0);\n    crop = vec4(-1.0, 0.0, -0.07, 0.07);\n    object = create_symmetrical_braces(baseUV, transform, 6.0f, 0.1, SMOOTH_BORDER_SIZE, 0.02, crop);\n    \n    color = mix(color,  mix(BASE_COLOR, DARK_RED_COLOR , animation_timer), object); \n    \n    // ----------------------------- Aim rhombuses -----------------------------\n    \n    transform = Transform(vec2(0.165 + arrows_animation, 0.0), vec2(1.85, 1.0), PI / 4.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object = create_symmetrical_braces(baseUV, transform, 4.0f, 0.025, SMOOTH_BORDER_SIZE, 1.0, crop);\n    \n    color = mix(color, mix(BASE_COLOR, DARK_RED_COLOR , animation_timer), object); \n    \n    transform = Transform(vec2(0.2, 0.0), vec2(1.85, 1.0), PI / 4.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object = create_symmetrical_braces(baseUV, transform, 4.0f, 0.01875, 1.3 * SMOOTH_BORDER_SIZE, 1.0, crop);\n    \n    transform = Transform(vec2(0.23, 0.0), vec2(1.85, 1.0), PI / 4.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object += create_symmetrical_braces(baseUV, transform, 4.0f, 0.01875,1.3 *  SMOOTH_BORDER_SIZE, 1.0, crop);\n    \n    transform = Transform(vec2(0.26, 0.0), vec2(1.85, 1.0), PI / 4.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object += create_symmetrical_braces(baseUV, transform, 4.0f, 0.01875, 1.3 * SMOOTH_BORDER_SIZE, 1.0, crop);\n    \n    \n    color = mix(color, CIRCLE_COLOR, object); \n    \n    // ----------------------------- Central circle -----------------------------\n    \n    transform = Transform(vec2(0.0, 0.0), vec2(1.0, 1.0), 0.0);\n    object = circle_line(baseUV, transform,  0.1+ circle_animation, SMOOTH_BORDER_SIZE, 0.03 + circle_animation);\n    color = mix(color, mix(CIRCLE_COLOR, DARK_RED_COLOR , animation_timer), object);\n    \n    \n    // ----------------------------- Central cross object -----------------------------\n    \n    transform = Transform(vec2(0.036, 0.0), vec2(1.0, 1.0), PI / 4.0 + cross_animation);\n    crop = vec4(-1.0, 0.0, -0.07, 0.07);\n    object = create_symmetrical_braces(baseUV, transform, 4.0f, 0.03, SMOOTH_BORDER_SIZE, 0.005, crop);\n    \n    \n    transform = Transform(vec2(0.0, 0.0), vec2(1.0, 1.0), 0.0);\n    object = max(object, circle_line(baseUV, transform,  0.02, SMOOTH_BORDER_SIZE, 1.0));\n    color = mix(color, mix(DARK_RED_COLOR, vec3(0.7, 0.7, 0.7), animation_timer), object);\n    \n    // ----------------------------- Triangle objects + braces -----------------------------\n    \n    transform = Transform(vec2(0.7, 0.26), vec2(1.0, 1.0), PI / 2.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object = create_symmetrical_braces(baseUV, transform, 3.0f, 0.015, SMOOTH_BORDER_SIZE, 0.05, crop);\n    \n    transform = Transform(vec2(0.7, -0.26), vec2(1.0, 1.0), -PI / 2.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object += create_symmetrical_braces(baseUV, transform, 3.0f, 0.015, SMOOTH_BORDER_SIZE, 0.05, crop);\n    \n    transform = Transform(vec2(0.0, 0.0), vec2(1.0, 1.0), 0.0);\n    crop = vec4(-1.0, 1.0, -0.26, 0.26);\n    object = max(object, create_symmetrical_braces(baseUV, transform, 4.0f, 0.7035, SMOOTH_BORDER_SIZE, 0.0025, crop));\n    \n    color = mix(color, mix(DARK_RED_COLOR, vec3(0.7, 0.0, 0.0), animation_timer), object);\n    \n    // ----------------------------- Central pannel -----------------------------\n    \n    transform = Transform(vec2(0.0, 0.0), vec2(1.0, 1.0), 0.0);\n    object = create_circle_pannel(baseUV, transform,  0.4, SMOOTH_BORDER_SIZE, 0.033);\n    color = mix(color, mix(BASE_COLOR, DARK_RED_COLOR , animation_timer), object);\n    \n    \n    // ----------------------------- Vertical bars -----------------------------\n    \n    transform = Transform(vec2(0.0, 0.0), vec2(0.6, 1.1), 0.0);\n    crop = vec4(-0.3, 0.3, -0.5, 0.5);\n    object = create_brace(baseUV, transform, 4.0f, 0.4, SMOOTH_BORDER_SIZE, 0.009, crop);\n    \n    transform = Transform(vec2(0.5, 0.3554), vec2(0.5, 2.0), PI / 2.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object = max(object,create_symmetrical_braces(baseUV, transform, 3.0f, 0.015, SMOOTH_BORDER_SIZE, 0.05, crop));\n    \n    transform = Transform(vec2(0.5, -0.3554), vec2(0.5, 2.0), -PI / 2.0);\n    crop = vec4(-1.0, 1.0, -0.5, 0.5);\n    object = max(object,create_symmetrical_braces(baseUV, transform, 3.0f, 0.015, SMOOTH_BORDER_SIZE, 0.05, crop));\n    \n    color = mix(color, mix(BASE_COLOR, DARK_RED_COLOR , animation_timer), object);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0f);\n    //fragColor = vec4(baseUV, 0.0f, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[516, 516, 572, 572, 647], [649, 649, 683, 683, 732], [734, 734, 789, 789, 856], [858, 858, 946, 946, 1091], [1093, 1093, 1191, 1191, 1388], [1390, 1390, 1485, 1485, 1817], [1819, 1819, 1926, 1926, 2132], [2134, 2134, 2247, 2247, 2642], [2644, 2644, 2772, 2772, 2959], [2961, 2961, 3089, 3089, 3543], [3546, 3546, 3687, 3687, 4032], [4034, 4034, 4052, 4052, 4059], [4061, 4061, 4118, 4168, 10373]], "test": "untested"}
{"id": "7dVfRd", "name": "Motion Graphics Doodle", "author": "TekF", "description": "Simple 2D render of fast moving shapes/patterns, rendered multiple times to get high quality motion blur and anti-aliasing.\nChange the STYLE define from 1 to 4 to see some nice variations.", "tags": ["motionblur", "antialiasing", "motiongraphics"], "likes": 18, "viewed": 356, "published": 3, "date": "1658933371", "time_retrieved": "2024-07-30T16:38:33.967363", "image_code": "// choose between a few different presets, or mess with the numbers for a preset to create your own!\n#define STYLE 1\n\n#if STYLE==1\n    // Clean\n    const int SAMPLES_PER_PIXEL = 12;\n    const float PIXEL_SCALE = 1.;\n    const float FPS = 60.;\n    const float SHUTTER_DURATION = 0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 1.; // relative to minimum for anti-aliasing\n\n    // subtley blow out red so it feels a tad flourescent\n    const vec3 palette[3] = vec3[](\n            vec3(.8),\n            vec3(3,.12,.1),\n            vec3(.06)\n        );\n#endif\n\n#if STYLE==2\n    // Neon Grunge Stop-motion\n    const int SAMPLES_PER_PIXEL = 12;\n    const float PIXEL_SCALE = 4.;\n    const float FPS = 12.;\n    const float SHUTTER_DURATION = 0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 3.; // relative to minimum for anti-aliasing\n\n    // negative + overbright colours for that \"my camera can't handle strong colour\" neon look\n    const vec3 palette[3] = vec3[](\n            vec3(-6,.5,8),\n            vec3(.03,.03,-1),\n            vec3(3,-1,.3)\n        );\n#endif\n\n\n#if STYLE==3\n    // Daylight out of focus\n    const int SAMPLES_PER_PIXEL = 64;\n    const float PIXEL_SCALE = 1.;\n    const float FPS = 60.;\n    const float SHUTTER_DURATION = 0.3; // relative to 1 frame duration\n    #define DISC_OF_CONFUSION_RADIUS iResolution.x*.05\n\n    // subtley blow out red so it feels a tad flourescent\n    const vec3 palette[3] = vec3[](\n            vec3(7,4,2),\n            vec3(.1,.12,.16),\n            vec3(.05,.055,.065)\n        );\n#endif\n\n#if STYLE==4\n    // Video Grunge\n    const int SAMPLES_PER_PIXEL = 30;\n    const float PIXEL_SCALE = 3.;\n    const float FPS = 30.;\n    const float SHUTTER_DURATION = 8.*0.7; // relative to 1 frame duration\n    const float DISC_OF_CONFUSION_RADIUS = 8.; // relative to minimum for anti-aliasing\n\n    // negative + overbright colours for that \"my camera can't handle strong colour\" neon look\n    const vec3 palette[3] = vec3[](\n            vec3(.2,1,-2),\n            vec3(0,-1,2),\n            vec3(3,.2,-1)\n        );\n#endif\n\nvec3 quasirandomFactor3 = vec3(0.8191725,0.6710436,0.5497005);\n\n#define M1 1597334677U     //1719413*929\n#define M2 3812015801U     //140473*2467*11\n#define M3 3299493293U     //467549*7057\n\n#define F0 (1.0/float(0xffffffffU))\n\n#define hash(n) n*(n^(n>>15))\n\n#define coord1(p) (p*M1)\n#define coord2(p) (p.x*M1^p.y*M2)\n#define coord3(p) (p.x*M1^p.y*M2^p.z*M3)\n\nfloat hash1(uint n){return float(hash(n))*F0;}\nvec2 hash2(uint n){return vec2(hash(n)*uvec2(0x1U,0x3fffU))*F0;}\nvec3 hash3(uint n){return vec3(hash(n)*uvec3(0x1U,0x1ffU,0x3ffffU))*F0;}\nvec4 hash4(uint n){return vec4(hash(n)*uvec4(0x1U,0x7fU,0x3fffU,0x1fffffU))*F0;}\n\n\nvec2 UVAnimation( in vec2 uv, in float time )\n{\n    float time2 = time*.3;\n    float a = (floor(time2)+smoothstep(.0,.2,fract(time2))) * .618*6.283;\n    uv = uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n    uv += (time*vec2(5,2) + sin(time)*vec2(2,3))*4.;\n    return uv;\n}\n\nvec3 animation( in vec2 fragCoord, in float time )\n{\n    vec2 screenUV = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    \n    screenUV *= exp2(2.6+.6*sin(time*.2));\n    \n    screenUV *= PIXEL_SCALE; // delete this to make PIXEL_SCALE actually zoom\n\n    vec2 uv = UVAnimation(screenUV,time);\n\n//    vec2 check = fract(uv)-.5; return mix( vec3(.3,0,.1), vec3(.5,1,.2), step(0.,check.x*check.y) );\n\n    vec2 cameraFloor = UVAnimation(vec2(0),time);\n    float gridStep = 1.41;\n    vec2 gridFloor = floor(uv/gridStep);\n    vec2 gridFrac = abs(fract(uv/gridStep)-.5)*2.;\n    \n    float thresh = 1.*smoothstep(14.,0.,length(gridFloor*gridStep-1.5-cameraFloor));\n    \n    float gridChecker = float((int(gridFloor.x)^int(gridFloor.y))&1);\n\n    vec3 colour = mix(\n            palette[0], palette[1],\n            \n            // different patterns:\n            //step( max(gridFrac.x,gridFrac.y), thresh )\n            //step( length(gridFrac), thresh*1.41 )\n            step( (1.-mix( thresh, max(thresh*2.-.2,thresh), gridChecker ))*1.41, length(gridFrac) )\n            //step( gridFrac.x+gridFrac.y, thresh*2. )\n        );\n\n\n// I'd like a pattern with some features of different sizes, and different colours - more like motion graphics\n// e.g. maybe a rectangle that lags behind the scroll but follows the rotation\n\n    vec2 rectPos = UVAnimation(vec2(0), time-.5)+vec2(7,0);\n//    vec2 rectUV = uv-rectPos;\n    vec2 rectUV = UVAnimation(screenUV,time-.3)-rectPos;\n    vec2 rectUV1 = abs(rectUV+vec2(1,0)) - vec2(5,1.2);\n    vec2 rectUV2 = abs(rectUV+vec2(0,1)) - vec2(1.2,5);\n    colour = mix( colour,\n            palette[2],\n            max(max(\n                step(abs(min(min(max(rectUV1.x,rectUV1.y),length(rectUV-vec2(4,0))-1.2),length(rectUV-vec2(-3.5,-3.5))-1.))-.1,.0),\n                step(max(rectUV2.x,rectUV2.y),.0) ),\n                step(length(rectUV-vec2(0,5.8)),1.4)\n            )\n        );\n    \n    return colour;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 fragCoord )\n{\n    // zoom so I can look at aa\n    fragCoord = floor(fragCoord/PIXEL_SCALE+iResolution.xy*(.5-.5/PIXEL_SCALE));\n\n    float time = floor(iTime*FPS)/FPS;\n\n    fragColour.rgb = animation(fragCoord,iTime);\n\n    int sampleCount = SAMPLES_PER_PIXEL;\n    fragColour.rgb = vec3(0);\n    for ( int tap=0; tap < sampleCount; tap++ )\n    {\n        float idx = float(tap)+dot(vec3(time*FPS,fragCoord),quasirandomFactor3);\n        vec3 jitter = fract( idx * quasirandomFactor3 ); // quasirandom sequence\n\n        // break up regularity\n        // adapted from http://extremelearning.com.au/a-simple-method-to-construct-isotropic-quasirandom-blue-noise-point-sequences/\n        jitter = fract( jitter + hash3(coord1(uint(idx*256.))) * 0.238  / sqrt(float(sampleCount)) );        \n\n        jitter = jitter.yxz; // tweak order to reduce patterned artefacts\n\n        // disc of confusion not perfect pixel\n        float discRadius = 0.7071 * DISC_OF_CONFUSION_RADIUS;\n        jitter.x *= 6.283185;\n        jitter.y = sqrt(jitter.y);\n        //jitter.y *= smoothstep(0.,1.,jitter.y); discRadius *= 2.; // softer look\n        jitter.xy = vec2(cos(jitter.x),sin(jitter.x))*jitter.y*discRadius;\n        \n        fragColour.rgb += animation(fragCoord+jitter.xy,time+jitter.z*SHUTTER_DURATION/FPS);\n    }\n    fragColour.rgb /= float(sampleCount);\n    \n//fragColour.rgb = .5+.5*cos(vec3(.9,1.9,3.9)*6.283*fragColour.g);\n    \n/*    // tone mapping - squash bright colours so they never quite hit 1\n    const float whitePointSoftening = .1;\n    float brightness = dot(fragColour.rgb,vec3(0.21,0.72,0.07));\n    float toneMapped = mix( brightness, 1.-length(vec2(1.-brightness,whitePointSoftening))), .5 );\n    //fragColour.rgb *= toneMapped/max(brightness,.001); // per overall brightness\n    fragColour.rgb = mix( fragColour.rgb, 1.-sqrt((1.-fragColour.rgb)*(1.-fragColour.rgb) + whitePointSoftening*whitePointSoftening)), .5 ); // per component\n*/\n    \n    // linear to sRGB\n    fragColour.rgb = mix( fragColour.rgb*12.92, 1.055*pow(fragColour.rgb,vec3(1./2.4))-.055, step(.0031308,fragColour.rgb) );\n    fragColour.a = 1.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2481, 2481, 2501, 2501, 2527], [2528, 2528, 2547, 2547, 2592], [2593, 2593, 2612, 2612, 2665], [2666, 2666, 2685, 2685, 2746], [2749, 2749, 2796, 2796, 3013], [4945, 4945, 5003, 5035, 7104]], "test": "untested"}
{"id": "NdKfW3", "name": "Simple double ended truchet(BW)", "author": "mrange", "description": "License CC0: Simple double ended truchet\nSeems I am having a truchet kind of week. Anyway, from experimenting \nwith Wave Function Collapse algorithms or rather cheating it I figured\nI could use the fake idea to create double ended truchets\n ", "tags": ["2d", "truchet"], "likes": 9, "viewed": 228, "published": 3, "date": "1658921036", "time_retrieved": "2024-07-30T16:38:35.144216", "image_code": "// License CC0: Simple double ended truchet in B/W\n// Seems I am having a truchet kind of week. Anyway, from experimenting \n// with Wave Function Collapse algorithms or rather cheating it I figured\n// I could use the fake idea to create double ended truchets\n// Turned out ok and I thought another truchet shader wouldn't hurt.\n\n// A B/W version of: https://www.shadertoy.com/view/fdVfDc\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat cell(vec2 p, float off, float linew) {\n  float r = 0.5+off;\n  float d0 = length(p-0.5)-r; \n  float d1 = length(p+0.5)-r;\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - linew;\n  return d;\n}\n\nfloat truchet_var(float h, float cs, vec2 cp, float off, float linew) {\n  float hs = h >= 0.5 ? 1.0 : -1.0;\n  cp = hs > 0.0 ? cp : vec2(cp.y, -cp.x);\n\n  return cell(cp, off*hs*cs, linew);\n}\n\nvec3 effect(vec2 p) {\n  float hoff0 = 0.5+0.5*sin(0.5*p.x)*sin(0.5*p.y);\n  float hoff1 = 0.5+0.5*cos(0.33*p.x)*cos(0.66*p.y);\n  \n  const float z = 3.0;\n  float aa = 2.0/RESOLUTION.y;\n  aa *= z;\n  p *= z;\n\n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n\n  float h0 = hash(cn);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(8677.0*h0);\n  float cs = mod(cn.x+cn.y, 2.0) >= 1.0 ? -1.0 : 1.0; \n\n  const float off = 0.1;\n  const float linew = 0.01;\n  float d0 = truchet_var(h1, cs, cp, off, linew*mix(1.0, 2.0, hoff0));\n  float d1 = truchet_var(h2, cs, cp, -off, linew*mix(1.0, 2.0, hoff1));\n\n  vec3 col = vec3(0.0);\n  \n  const vec3 dcol0 = vec3(0.9); \n  const vec3 dcol1 = vec3(0.9); \n\n  float f0 = smoothstep(aa, -aa, d0);\n  float f1 = smoothstep(aa, -aa, d1);\n\n  float shd0 = 1.0-exp(-5.0*max(z*d0, 0.0));\n  float shd1 = 1.0-exp(-5.0*max(z*d1, 0.0));\n  \n  if (h0 > 0.5) {\n    col = mix(col, dcol0, f0);\n    col *= shd1;\n    col = mix(col, dcol1, f1);\n  } else {\n    col = mix(col, dcol1, f1);\n    col *= shd0;\n    col = mix(col, dcol0, f0);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  const float r = 20.0;\n  const float spd = 0.5;\n  p += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n   \n  vec3 col = effect(p);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfW3.jpg", "access": "api", "license": "cc0-1.0", "functions": [[448, 508, 529, 529, 599], [601, 601, 645, 645, 797], [799, 799, 870, 870, 988], [990, 990, 1011, 1011, 2059], [2061, 2061, 2116, 2116, 2388]], "test": "untested"}
{"id": "ssGBWc", "name": "The Amusement Park", "author": "wcvanvan", "description": "Whitted Ray Tracing\nNUS course group project", "tags": ["raytracing"], "likes": 24, "viewed": 875, "published": 3, "date": "1658907196", "time_retrieved": "2024-07-30T16:38:36.393874", "image_code": "//============================================================================\n// Constants.\n//============================================================================\n\nconst float PI = 3.1415926536;\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Position the camera.\nvec3 CAM_LOOKAT = vec3( 0.3, 1.1, 0.0 );\nvec3 CAM_UP_VEC = vec3( 0.0, 1.0, 0.0 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 45.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 2;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 3;\nconst int NUM_MATERIALS = 10;\nconst int NUM_PLANES = 5;\nconst int NUM_SPHERES = 11;\nconst int NUM_STICKS = 40;\nconst int NUM_ROLLING_BALLS = 30;\n\n// Constants for the spikey\nconst float EDGLEN_SPIKEY = 0.8;\nconst float EDGRAD_SPIKEY = 0.056;\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Stick_t {\n    vec3 vertexA;\n    vec3 vertexB;\n    float radius;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n};\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nSphere_t RollingBalls[NUM_ROLLING_BALLS];\nStick_t Stick[NUM_STICKS];\nLight_t Light[NUM_LIGHTS];\nMaterial_t Material[NUM_MATERIALS];\n\n//============================================================================\n// Initialize the spikey (star body)\n//============================================================================\nvoid InitSpikey(){\n\n    float size = EDGLEN_SPIKEY;\n\n    // translate direction\n    vec3 transDirec = vec3 (0.0, size * 1.1135 + EDGRAD_SPIKEY, 1.2);\n\n    // Verteces\n\n    vec3 vtx00 = size * vec3( 0.0   , -1.1135,  0.8574) + transDirec;\n    vec3 vtx01 = size * vec3( 0.8090, -1.1135,  0.2629) + transDirec;\n    vec3 vtx02 = size * vec3( 0.5   , -1.1135, -0.6882) + transDirec;\n    vec3 vtx03 = size * vec3(-0.5   , -1.1135, -0.6882) + transDirec;\n    vec3 vtx04 = size * vec3(-0.8090, -1.1135,  0.2629) + transDirec;\n\n    vec3 vtx10 = size * vec3( 0.0   , -0.2629,  1.3764) + transDirec;\n    vec3 vtx11 = size * vec3( 1.3090, -0.2629,  0.4253) + transDirec;\n    vec3 vtx12 = size * vec3( 0.8090, -0.2629, -1.1135) + transDirec;\n    vec3 vtx13 = size * vec3(-0.8090, -0.2629, -1.1135) + transDirec;\n    vec3 vtx14 = size * vec3(-1.3090, -0.2629,  0.4253) + transDirec;\n\n    vec3 vtx20 = size * vec3( 0.0   ,  0.2629, -1.3764) + transDirec;\n    vec3 vtx21 = size * vec3(-1.3090,  0.2629, -0.4253) + transDirec;\n    vec3 vtx22 = size * vec3(-0.8090,  0.2629,  1.1135) + transDirec;\n    vec3 vtx23 = size * vec3( 0.8090,  0.2629,  1.1135) + transDirec;\n    vec3 vtx24 = size * vec3( 1.3090,  0.2629, -0.4253) + transDirec;\n\n    vec3 vtx30 = size * vec3( 0.0   ,  1.1135, -0.8574) + transDirec;\n    vec3 vtx31 = size * vec3(-0.8090,  1.1135, -0.2629) + transDirec;\n    vec3 vtx32 = size * vec3(-0.5   ,  1.1135,  0.6882) + transDirec;\n    vec3 vtx33 = size * vec3( 0.5   ,  1.1135,  0.6882) + transDirec;\n    vec3 vtx34 = size * vec3( 0.8090,  1.1135, -0.2629) + transDirec;\n\n    // edges (sticks)\n    vec3 a; vec3 b; vec3 c; vec3 d;\n    for (int i = 0; i < NUM_STICKS; i++){\n        Stick[i].radius = EDGRAD_SPIKEY;\n    }\n\n    // pyrimid0: 00 12 21 33\n    a = vtx00; b = vtx12; c = vtx21; d = vtx33;\n    Stick[ 0].vertexA = a; Stick[ 0].vertexB = b; Stick[ 0].materialID = 3;\n    Stick[ 1].vertexA = a; Stick[ 1].vertexB = c; Stick[ 1].materialID = 3;\n    Stick[ 2].vertexA = a; Stick[ 2].vertexB = d; Stick[ 2].materialID = 3;\n    Stick[ 3].vertexA = b; Stick[ 3].vertexB = c; Stick[ 3].materialID = 3;\n    Stick[ 4].vertexA = b; Stick[ 4].vertexB = d; Stick[ 4].materialID = 3;\n    Stick[ 5].vertexA = c; Stick[ 5].vertexB = d; Stick[ 5].materialID = 3;\n\n    // pyrimid1: 01 13 22 34\n    a = vtx01; b = vtx13; c = vtx22; d = vtx34;\n    Stick[ 6].vertexA = a; Stick[ 6].vertexB = b; Stick[ 6].materialID = 4;\n    Stick[ 7].vertexA = a; Stick[ 7].vertexB = c; Stick[ 7].materialID = 4;\n    Stick[ 8].vertexA = a; Stick[ 8].vertexB = d; Stick[ 8].materialID = 4;\n    Stick[ 9].vertexA = b; Stick[ 9].vertexB = c; Stick[ 9].materialID = 4;\n    Stick[10].vertexA = b; Stick[10].vertexB = d; Stick[10].materialID = 4;\n    Stick[11].vertexA = c; Stick[11].vertexB = d; Stick[11].materialID = 4;\n\n    // pyrimid2: 02 14 23 30\n    a = vtx02; b = vtx14; c = vtx23; d = vtx30;\n    Stick[12].vertexA = a; Stick[12].vertexB = b; Stick[12].materialID = 5;\n    Stick[13].vertexA = a; Stick[13].vertexB = c; Stick[13].materialID = 5;\n    Stick[14].vertexA = a; Stick[14].vertexB = d; Stick[14].materialID = 5;\n    Stick[15].vertexA = b; Stick[15].vertexB = c; Stick[15].materialID = 5;\n    Stick[16].vertexA = b; Stick[16].vertexB = d; Stick[16].materialID = 5;\n    Stick[17].vertexA = c; Stick[17].vertexB = d; Stick[17].materialID = 5;\n\n    // pyrimid3: 03 10 24 31\n    a = vtx03; b = vtx10; c = vtx24; d = vtx31;\n    Stick[18].vertexA = a; Stick[18].vertexB = b; Stick[18].materialID = 6;\n    Stick[19].vertexA = a; Stick[19].vertexB = c; Stick[19].materialID = 6;\n    Stick[20].vertexA = a; Stick[20].vertexB = d; Stick[20].materialID = 6;\n    Stick[21].vertexA = b; Stick[21].vertexB = c; Stick[21].materialID = 6;\n    Stick[22].vertexA = b; Stick[22].vertexB = d; Stick[22].materialID = 6;\n    Stick[23].vertexA = c; Stick[23].vertexB = d; Stick[23].materialID = 6;\n\n    // pyrimid4: 04 11 20 32\n    a = vtx04; b = vtx11; c = vtx20; d = vtx32;\n    Stick[24].vertexA = a; Stick[24].vertexB = b; Stick[24].materialID = 7;\n    Stick[25].vertexA = a; Stick[25].vertexB = c; Stick[25].materialID = 7;\n    Stick[26].vertexA = a; Stick[26].vertexB = d; Stick[26].materialID = 7;\n    Stick[27].vertexA = b; Stick[27].vertexB = c; Stick[27].materialID = 7;\n    Stick[28].vertexA = b; Stick[28].vertexB = d; Stick[28].materialID = 7;\n    Stick[29].vertexA = c; Stick[29].vertexB = d; Stick[29].materialID = 7;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initialize the rolling pyrimid and the pink stick.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitBSModels(){\n    // size\n    float size = 0.55;\n    float ballRad = 0.1;\n\n    // translate direction\n    vec3 transDirec = vec3(1.5, ballRad, -0.1);\n\n    for (int i = 0; i < NUM_SPHERES; i++){\n        Sphere[i].radius = ballRad;\n        Sphere[i].materialID = 0;\n    }\n\n    Sphere[0].center = size * vec3(0.0, sqrt(6.0), 0.0) + transDirec;\n    Sphere[1].center = size * vec3(cos(iTime)         , 0.0, sin(iTime)         ) + transDirec;\n    Sphere[2].center = size * vec3(cos(iTime+PI*0.667), 0.0, sin(iTime+PI*0.667)) + transDirec;\n    Sphere[3].center = size * vec3(cos(iTime+PI*1.333), 0.0, sin(iTime+PI*1.333)) + transDirec;\n\n    Stick[30].vertexA = Sphere[0].center; Stick[30].vertexB = Sphere[1].center;\n    Stick[31].vertexA = Sphere[0].center; Stick[31].vertexB = Sphere[2].center;\n    Stick[32].vertexA = Sphere[0].center; Stick[32].vertexB = Sphere[3].center;\n    Stick[33].vertexA = Sphere[1].center; Stick[33].vertexB = Sphere[2].center;\n    Stick[34].vertexA = Sphere[1].center; Stick[34].vertexB = Sphere[3].center;\n    Stick[35].vertexA = Sphere[2].center; Stick[35].vertexB = Sphere[3].center;\n\n    Stick[30].radius = ballRad / 2.5; Stick[30].materialID = 1;\n    Stick[31].radius = ballRad / 2.5; Stick[31].materialID = 1;\n    Stick[32].radius = ballRad / 2.5; Stick[32].materialID = 1;\n    Stick[33].radius = ballRad / 2.5; Stick[33].materialID = 1;\n    Stick[34].radius = ballRad / 2.5; Stick[34].materialID = 1;\n    Stick[35].radius = ballRad / 2.5; Stick[35].materialID = 1;\n\n    ballRad = 0.14;\n    Sphere[4].center = vec3(-0.7, ballRad, 2.2);\n    Sphere[5].center = vec3( 0.5, ballRad, 2.5);\n    Sphere[4].radius = ballRad; Sphere[4].materialID = 0;\n    Sphere[5].radius = ballRad; Sphere[5].materialID = 0;\n    Stick[36].vertexA = Sphere[4].center; Stick[36].vertexB = Sphere[5].center;\n    Stick[36].radius = ballRad / 2.5; Stick[36].materialID = 8;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// the balls are rolling in a heart-shaped trajectory\n/////////////////////////////////////////////////////////////////////////////\nvoid InitRollingBalls() {\n\n    // translate direction\n    vec3 transDirec = vec3(1.0, -0.1, 0.8);\n\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++)\n    {\n        float sizeOfHeart = 1.42;\n        float zPos = -2.0;\n        float yOffset = sizeOfHeart + 1.0;\n\n        RollingBalls[i].center.x = sizeOfHeart * sin( float(100 * i + 1) * iTime);\n\n        float x = RollingBalls[i].center.x;\n        if (cos(float(100 * i + 1) * iTime) > 0.0)\n        {\n            RollingBalls[i].center.y = sqrt(sizeOfHeart * abs(x) - pow(x, 2.0)) + yOffset;\n        } else {\n            RollingBalls[i].center.y = (-sizeOfHeart - 0.5) * sqrt(sqrt(sizeOfHeart) - sqrt(abs(x))) + yOffset;\n        }\n        RollingBalls[i].center.z = zPos;\n\n        RollingBalls[i].center += transDirec;\n        RollingBalls[i].radius = 0.1;\n        RollingBalls[i].materialID = 8;\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    // Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 0;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n\n    Plane[2].A = 0.0;\n    Plane[2].B = 1.0;\n    Plane[2].C = 0.0;\n    Plane[2].D = 10.0;\n    Plane[2].materialID = 9;\n\n    Plane[3].A = 1.0;\n    Plane[3].B = 0.0;\n    Plane[3].C = 0.0;\n    Plane[3].D = -10.0;\n    Plane[3].materialID = 0;\n\n    Plane[4].A = 1.0;\n    Plane[4].B = 0.0;\n    Plane[4].C = 0.0;\n    Plane[4].D = 10.0;\n    Plane[4].materialID = 9;\n\n    // Spikey.\n    InitSpikey();\n\n    // Box.\n    InitBSModels();\n\n    // Rolling Balls.\n    InitRollingBalls();\n\n    // Spheres.\n    // rolling sphere\n    Sphere[6].center = vec3( -2.0 - sin(1.3*iTime), 0.3, 0.5 + 1.2 * cos(1.3*iTime) );\n    Sphere[6].radius = 0.24;\n    Sphere[6].materialID = 3;\n\n    // back sphere\n    Sphere[7].center = vec3( 0.2, 0.5, -1.0 );\n    Sphere[7].radius = 0.5;\n    Sphere[7].materialID = 2;\n\n    // frount sphere\n    Sphere[8].center = vec3( 1.45, 0.25, 1.55 );\n    Sphere[8].radius = 0.25;\n    Sphere[8].materialID = 4;\n\n    // slipping sphere\n    Sphere[9].center = vec3( abs(sin(2.0*iTime))+2.1, 0.15, 0.2*abs(sin(2.0*iTime))+0.5);\n    Sphere[9].radius = 0.15;\n    Sphere[9].materialID = 0;\n\n    // jumpping sphere\n    Sphere[10].center = vec3( -2.0, 2.0*abs(sin(2.0*iTime))+0.15, 0.5 );\n    Sphere[10].radius = 0.15;\n    Sphere[10].materialID = 5;\n\n    // Balls - Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n\n    // Balls - Azure material.\n    Material[1].k_d = vec3( 63.0, 95.0, 132.0 ) / 255.0;\n    Material[1].k_a = 0.2 * Material[1].k_d;\n    Material[1].k_r = 2.0 * Material[1].k_d;\n    Material[1].k_rg = 0.5 * Material[1].k_r;\n    Material[1].n = 64.0;\n\n    // Balls - White material.\n    Material[2].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n\n    // Spikey - yellow.\n    Material[3].k_d = vec3( 255.0, 221.0, 169.0 )/255.0;\n    Material[3].k_a =  0.2 * Material[3].k_d;\n    Material[3].k_r =  2.0 * Material[3].k_d;\n    Material[3].k_rg = 0.5 * Material[3].k_r;\n    Material[3].n = 128.0;\n\n    // Spikey - blue.\n    Material[4].k_d = vec3( 207.0, 231.0, 245.0 )/255.0;\n    Material[4].k_a =  0.2 * Material[4].k_d;\n    Material[4].k_r =  2.0 * Material[4].k_d;\n    Material[4].k_rg = 0.5 * Material[4].k_r;\n    Material[4].n = 128.0;\n\n    // Spikey - violet.\n    Material[5].k_d = vec3( 201.0, 175.0, 195.0 )/255.0;\n    Material[5].k_a =  0.2 * Material[5].k_d;\n    Material[5].k_r =  2.0 * Material[5].k_d;\n    Material[5].k_rg = 0.5 * Material[5].k_r;\n    Material[5].n = 128.0;\n\n    // Spikey - crimson.\n    Material[6].k_d = vec3( 161.0, 72.0, 66.0 )/255.0;\n    Material[6].k_a =  0.2 * Material[6].k_d;\n    Material[6].k_r =  2.0 * Material[6].k_d;\n    Material[6].k_rg = 0.5 * Material[6].k_r;\n    Material[6].n = 128.0;\n\n    // Spikey - purple.\n    Material[7].k_d = vec3( 104.0, 84.0, 141.0 )/255.0;\n    Material[7].k_a =  0.2 * Material[7].k_d;\n    Material[7].k_r =  2.0 * Material[7].k_d;\n    Material[7].k_rg = 0.5 * Material[7].k_r;\n    Material[7].n = 128.0;\n\n    // Rolling Balls - red.\n    Material[8].k_d = vec3( 244.0, 128.0, 135.0) / 255.0;\n    Material[8].k_a =  0.2 * Material[8].k_d;\n    Material[8].k_r =  2.0 * Material[8].k_d;\n    Material[8].k_rg = 0.5 * Material[8].k_r;\n    Material[8].n = 128.0;\n\n    // Walls - white.\n    Material[9].k_d = vec3( 200.0,200.0, 200.0) / 255.0;\n    Material[9].k_a =  0.2 * Material[9].k_d;\n    Material[9].k_r =  vec3(0.0);;\n    Material[9].k_rg = vec3(0.0);\n    Material[9].n = 128.0;\n\n\n    // Lighting Coeffecient\n    float lightCoeff = 1.0 / 12.5;\n\n    // Light 1.\n    Light[0].position = vec3(2.0*cos(1.1*iTime)+0.5, 8.0, 2.0*sin(1.1*iTime)+2.0) * 1.2;\n    Light[0].I_a      = vec3(7.0, 1.0, 4.0) * lightCoeff;\n    Light[0].I_source = vec3(7.0, 1.0, 4.0) * lightCoeff;\n\n    // Light 2.\n    Light[1].position = vec3(2.0*cos(1.1*iTime+PI*0.667)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*0.667)+2.0) * 1.2;\n    Light[1].I_a      = vec3(1.0, 4.0, 7.0) * lightCoeff;\n    Light[1].I_source = vec3(1.0, 4.0, 7.0) * lightCoeff;\n\n    // Light 3.\n    Light[2].position = vec3(2.0*cos(1.1*iTime+PI*1.333)+0.5, 8.0, 2.0*sin(1.1*iTime+PI*1.333)+2.0) * 1.2;\n    Light[2].I_a      = vec3(4.0, 7.0, 1.0) * lightCoeff;\n    Light[2].I_source = vec3(4.0, 7.0, 1.0) * lightCoeff;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n\n    vec3  v = ray.o - sph.center;\n    float b = dot(ray.d, v);\n    float c = dot(v, v) - sph.radius*sph.radius;\n    float d = b*b - c;\n    if (d > 0.0){\n        d = sqrt(d);\n        t = -b-d;\n        if (t >= tmin && t <= tmax) {\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize( hitPos-sph.center );\n            return true;\n        }\n        t = -b + d;\n        if (t >= tmin && t <= tmax) {\n            hitPos = ray.o + t * ray.d;\n            hitNormal = normalize( hitPos-sph.center );\n            return true;\n        }\n    }\n    return false;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n\n    vec3  v = ray.o - sph.center;\n    float b = dot(ray.d, v);\n    float c = dot(v, v) - sph.radius*sph.radius;\n    float d = b*b - c;\n    if (d > 0.0){\n        d = sqrt(d);\n        float t = -b - d;\n        if (t >= tmin && t <= tmax) return true;\n\n        t = -b + d;\n        if (t >= tmin && t <= tmax) return true;\n    }\n    return false;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\n\n// copied from https://www.shadertoy.com/view/Xt3SzX\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n        float y = baoa + t*bard;\n        // body\n        if( y>0.0 && y<baba ) return t;\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 ) return -b - sqrt(h);\n    }\n    return -1.0;\n}\n\nvec3 capNormal( in vec3 pos, in vec3 a, in vec3 b, in float r )\n{\n    vec3  ba = b - a;\n    vec3  pa = pos - a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return (pa - h*ba)/r;\n}\n\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n\n    if (t >= 0.0 && t <= tmax){\n        hitPos = ray.o + t * ray.d;\n        hitNormal = capNormal(hitPos, stk.vertexA, stk.vertexB, stk.radius);\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a stick and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectStick( in Stick_t stk, in Ray_t ray, in float tmin, in float tmax)\n{\n    float t = capIntersect( ray.o, ray.d, stk.vertexA, stk.vertexB, stk.radius );\n    if (t >= 0.0 && t >= tmin && t <= tmax){\n        return true;\n    } else {\n        return false;\n    }\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSth = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    for (int i = 0; i < NUM_PLANES; i++){\n        if (IntersectPlane(Plane[i], ray,DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitNormal)){\n            hasHitSth = true;\n            nearest_t = temp_t;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitMatID = Plane[i].materialID;\n        }\n    }\n    for (int i = 0; i < NUM_SPHERES; i++){\n        if (IntersectSphere(Sphere[i], ray,DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitNormal)){\n            hasHitSth = true;\n            nearest_t = temp_t;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n    for (int i = 0; i < NUM_STICKS; i++){\n        if (IntersectStick(Stick[i], ray, DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitNormal)){\n            hasHitSth = true;\n            nearest_t = temp_t;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitMatID = Stick[i].materialID;\n        }\n    }\n    for (int i = 0; i < NUM_ROLLING_BALLS; i++){\n        if (IntersectSphere(RollingBalls[i], ray, DEFAULT_TMIN,nearest_t,temp_t,temp_hitPos,temp_hitNormal)){\n            hasHitSth = true;\n            nearest_t = temp_t;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitMatID = RollingBalls[i].materialID;\n        }\n    }\n    \n    // One of the output results.\n    hasHit = hasHitSth;\n    if ( !hasHitSth ) return BACKGROUND_COLOR;\n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n\n    for (int i = 0; i < NUM_LIGHTS; i++){\n        Light_t light = Light[i];\n        Ray_t shadowRay;\n        shadowRay.o = nearest_hitPos;\n        shadowRay.d = normalize(light.position - nearest_hitPos);\n        float maxTime = (light.position - nearest_hitPos).x / shadowRay.d.x;\n        hasHitSth = false;\n\n        if (dot(shadowRay.d, nearest_hitNormal) > 0.0){\n            if (!hasHitSth){\n                for (int i = 0; i < NUM_PLANES; i++){\n                    hasHitSth = IntersectPlane(Plane[i], shadowRay, DEFAULT_TMIN, maxTime);\n                    if (hasHitSth){ break; }\n                }\n            }\n            if (!hasHitSth){\n                for (int i = 0; i < NUM_SPHERES; i++){\n                    hasHitSth = IntersectSphere(Sphere[i], shadowRay, DEFAULT_TMIN, maxTime);\n                    if (hasHitSth){ break; }\n                }\n            }\n            if (!hasHitSth){\n                for (int i = 0; i < NUM_STICKS; i++){\n                    hasHitSth = IntersectStick(Stick[i], shadowRay, DEFAULT_TMIN, maxTime);\n                    if (hasHitSth){ break; }\n                }\n            }\n            if (!hasHitSth){\n                for (int i = 0; i < NUM_ROLLING_BALLS; i++){\n                    hasHitSth = IntersectSphere(RollingBalls[i], shadowRay, DEFAULT_TMIN, maxTime);\n                    if (hasHitSth){ break; }\n                }\n            }\n        }\n        I_local += PhongLighting(normalize(light.position - nearest_hitPos), normalize(nearest_hitNormal), normalize(ray.o - nearest_hitPos), hasHitSth, Material[nearest_hitMatID], light);\n\n    }\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n\n    return I_local;\n}\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    vec4 initCamPos = vec4( -1.0, 1.1, 5.0, 1.0 );\n    float rotateRadian = -60.0 * abs(sin(0.1 * iTime-5.25)) * PI / 180.0;\n    mat4 rotateMat = mat4(\n                        vec4(cos(rotateRadian), 0.0, -sin(rotateRadian), 0.0),\n                        vec4(0.0, 1.0, 0.0, 0.0),\n                        vec4(sin(rotateRadian), 0.0, cos(rotateRadian), 0.0),\n                        vec4(0.0, 0.0, 0.0, 1.0)\n                        );\n\n    vec3 CAM_POS    = (initCamPos * rotateMat).xyz + vec3(0.0, 0.0, 0.5);\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( CAM_POS - CAM_LOOKAT );\n    vec3 cam_x_axis = normalize( cross(CAM_UP_VEC, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    pRay.o = CAM_POS;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis );\n\n\n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n\n        nextRay = Ray_t( hitPos, normalize( reflect(nextRay.d, hitNormal) ) );\n    }\n\n    fragColor = vec4( I_result, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3001, 3196, 3214, 3214, 7586], [7588, 7798, 7818, 7830, 9680], [9683, 9893, 9918, 9946, 10743], [10745, 10927, 10945, 10970, 15676], [15680, 16176, 16330, 16330, 16660], [16664, 16996, 17079, 17079, 17291], [17295, 17813, 17970, 17970, 18547], [18551, 18884, 18969, 18969, 19316], [19836, 19889, 19971, 19971, 20659], [20661, 20661, 20726, 20726, 20852], [20854, 20854, 21009, 21009, 21295], [21298, 21630, 21712, 21712, 21903], [21906, 22260, 22390, 22390, 22802], [22806, 23595, 23708, 23799, 27686], [27689, 28050, 28107, 28107, 29875]], "test": "untested"}
{"id": "sdGBD3", "name": "Infinite roguelike dungeon 3", "author": "jarble", "description": "Another infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 6, "viewed": 305, "published": 3, "date": "1658901068", "time_retrieved": "2024-07-30T16:38:37.186755", "image_code": "float threshold = .9;\nint iters = 8;\n\n#define noise2D(p) float((p.x * 68657387u ^ p.y * 361524851u + p.x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2,bool b1){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < abs(float(b1)-threshold));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false,l=false;\n    uint sum = 0u;\n    float n = 0.;\n    for(int i = 0; i++ < iters;\n    //Multiply and divide by prime numbers to get interesting patterns\n    I = (I)*2u/3u+uvec2(i)*2u\n    //I = (I)*7u/11u+uvec2(i)*2u\n    ){\n        //vertical tunnels\n        //I.y += uint(n*2.);\n        \n        //I += uint(i/2+1);\n        n =\n            noise2D(I)\n            //(noise2D(I)-n/2.)\n        ;\n        //I += uvec2(i); //another interesting pattern\n        sum += uint(b);\n        //I -= sum+1u;\n        //I += uint(b);\n        l=labyrinth(I,n,b),\n        b =\n            !b || l\n            //!b||labyrinth(I,n,b)&&labyrinth(I/2u,n,b)\n            //!b || l && n < .5+sin(iTime)/2.\n            //!b && l\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return mod(floor(a),b);\n}\n\nvec2 mainSound1(int samp, float time){\n\n float t0=time, s1 =\n      8.\n ;\n  float f1 = floor(time*s1);\n  time *= 2.;\n  \n  float\n  m4 =\n      fmod(time,2.)\n  ,\n  t=\n      time\n  ,\n  m1 =\n      fmod(t,s1)\n  ,\n  m3 =\n      fmod(floor(t*m1/s1),s1)\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n    \n  float a=sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = 32.*pow(2.,(m3+m2)/5.+2.)/2.;\n\n  return abs(.5-vec2(fract(time*nb*.998)\n   ,fract(time*nb)))*a;\n\n}\n\nvec2 mainSound(int a,float b){\n    //b *= 4.;\n    return mainSound1(a,b)-mainSound1(a,b/2.)/2.-mainSound1(a,b/4.)/4.-mainSound1(a,b/8.)/8.;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 169, 169, 273], [275, 275, 311, 311, 1291]], "test": "untested"}
{"id": "sdyfW3", "name": "my_test_rainbow", "author": "dill", "description": "rainbow with mix", "tags": ["2d"], "likes": 0, "viewed": 151, "published": 3, "date": "1658899241", "time_retrieved": "2024-07-30T16:38:38.152173", "image_code": "#define PI 3.14159265359\n\nvec3 colorA = vec3(0.149,0.141,0.912);\nvec3 colorB = vec3(1.000,0.833,0.224);\n\n float plot (vec2 st, float pct){\n   return  smoothstep( pct-0.01, pct, st.y*1.65) -\n          smoothstep( pct, pct+0.01, st.y*1.65);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n\n    vec3 pct = vec3(uv.x);\n\n     pct.r = smoothstep(0.0,1.0, 1.-uv.x);\n     pct.g = sin((1.-uv.x)*PI);\n     pct.b = pow(1.-uv.x,0.5);\n\n    color = mix(colorA, colorB, pct);\n  \tcolor = mix(vec3(1.0,1.0,1.0),color,plot(uv,pct.g));\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyfW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 138, 138, 240], [241, 241, 298, 348, 687]], "test": "untested"}
{"id": "sdGBW3", "name": "Infinite roguelike dungeon 2", "author": "jarble", "description": "Another infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 6, "viewed": 244, "published": 3, "date": "1658893326", "time_retrieved": "2024-07-30T16:38:38.952035", "image_code": "float threshold = .8;\nint iters = 6;\n\n#define noise2D(p) float((p.x * 68657387u ^ p.y * 361524851u + p.x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2,bool b1){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < abs(float(b1)-threshold));\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false,l1=false;\n    for(int i = 0; i++ < iters;I =\n    I*2u/3u\n    //I*13u/17u\n    ){\n        I += uint(i/2+2);\n        float n = noise2D(I);\n        //I += uvec2(i); //another interesting pattern\n        l1=labyrinth(I,n,b),\n        b =\n            !b || l1\n            //!b||labyrinth(I/3u,n,b)&&labyrinth(I,n,b)\n            //!b || l1 || n > (8.*abs(.5-fract(iTime/16.))-.5)\n            //!b || l1 && n > .1\n            //!(b || l1)\n            //!b && l1\n            //!b != l1\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    if (!b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    return\n        mod(floor(a),b)\n        //mod(floor(a)*floor(a*8./b),b)\n    ;\n}\nvec2 mainSound(int samp, float time){\n\n float t0=time, s1 =\n      8.\n ;\n  //time += floor(time+s1)/s1;\n  //time *= 2.;\n  \n  float\n  m4 =\n      fmod(time,2.)\n  ,\n  t=\n      time\n  ;\n  float m2 =\n      1. + fmod(t*s1+floor(time/2.)*2.,s1)\n  ;\n    \n  float a = 64.*sqrt((1.-sqrt(max(fract(t/s1/s1),fract(t/s1)))))*.2,\n\n  nb = time*pow(2.,(m4+m2)/5.+6.5);\n\n  return abs(.5-vec2(fract(nb*.998)\n   ,fract(nb)))*a;\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 169, 169, 273], [275, 275, 311, 311, 1068]], "test": "untested"}
{"id": "fdGfWc", "name": "nave ref", "author": "jorge2017a2", "description": "nave ref", "tags": ["naveref"], "likes": 4, "viewed": 198, "published": 3, "date": "1658887748", "time_retrieved": "2024-07-30T16:38:39.789795", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//nave reflect-----26-jul-2022\n\nfloat tg;\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n//iq\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n//https://www.shadertoy.com/view/WlsSWS\nfloat pathterrain(float x,float z)\n{   // Common height function for path and terrain\n    return  sin(x*.5 )*1.+cos(z*.3 )*0.3 +cos(x*3.+z )*0.1+sin(x-z*.2 )*0.2;\n}\n\n\n//noise\n///https://www.shadertoy.com/view/ftd3zX\nfloat random(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat noise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(a, b, u.x) + (c - a)* u.y * (1.0 - u.x) +(d - b) * u.x * u.y;\n}\n\nfloat fbm(vec2 p) {\n    float v = 0.0;\n    float a = 1.;\n    mat2 rotMat = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.5));\n    for(int i = 0; i < 2; ++i) {\n        p = 1.6 * rotMat * p + 100.;\n        a *= 0.5;\n        v += a * noise(p);\n    }\n    return v;\n}\n\nvec2 nave(vec3 p)\n{\n    vec2 res= vec2(9999.0, -1.0);  \n    vec3 p0=p;\n    \n     float d1a= sdEllipsoid(p, vec3(7.0,5.0,10.0) );\n    float d1b= sdEllipsoid(p, vec3(7.0,5.0,10.0) );\n    p.z-=5.0;\n    float d2a= sdBox(p, vec3(8.0,6.0,7.0) );\n    p.z+=10.0;\n    float d2b= sdBox(p, vec3(8.0,6.0,5.0) );\n    \n    d1a=Difference(d1a, d2a);\n    d1b=Difference(d1b, d2b);\n    p=p0;\n    //cruz\n    float d3a= sdBox(p,vec3(0.5,6.0,11.0) );\n    float d3b= sdBox(p,vec3(10.0,0.5,11.0) );\n    \n    float d1aa= Intersect(d1a,d3a);\n    float d1bb= Intersect(d1a,d3b);\n    res =opU2(res, vec2(d1a,201.0));\n    res =opU2(res, vec2(d1b,2.0));\n    res =opU2(res, vec2(d1aa,0.0));\n    res =opU2(res, vec2(d1bb,0.0));\n    p.y+=1.0;\n    float d4a=sdBox(p, vec3(12.,0.5,1.0) );\n    res =opU2(res, vec2(d4a,0.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n    float h1= pathterrain(p.x*0.5,p.z);\n\tfloat planeDist1 = p.y+10.0+h1;  //piso inf\n    \n    res =opU2(res, vec2(planeDist1,7.0));\n    float t=iTime;\n    p.y+=3.0*sin(t)-5.0;\n    p.x+=3.0*cos(t);\n    p.z-=tg;\n    p= rotate_y(p, clamp(sin(iTime*0.5),-0.25,0.25));\n    vec2 res2= nave(p-vec3(0.0,15.0,0.0));\n    res =opU2(res, res2);\n    p=p0;\n    float n1=fbm(floor(p.xz*0.35));\n        \n    if (n1>0.5)\n    {\n        p.x= opRep1D( p.x, 10.0 );\n        p.z= opRep1D( p.z, 5.0 );\n        p.y-=5.0;\n        float d4a= sdBox(p,vec3(5.0,5.0*n1,5.0)-0.01 );\n        res =opU2(res, vec2(d4a,4.0));\n    }\n    else\n    {\n        p.x= opRep1D( p.x, 5.0 );\n        p.z= opRep1D( p.z, 10.0 );\n        float d4a= sdBox(p,vec3(5.0,5.0*n1+5.0,5.0) )-0.01;\n        res =opU2(res, vec2(d4a,4.0));\n    }\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n       return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n   \treturn sky;\n   \n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n   if (id_color==201 ) return vec3(1.0);\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd) \n{   vec3 p,colobj,col = vec3(0.0),result;\n\tvec2 t;\n    vec3 rcol=vec3(0);\n    \n    for(int i=0; i<3;i++)\n    {  vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n       if(hit.x<MAX_DIST)\n       { // geometry, hit position, normal, reflect\n\t    p =ro + rd * hit.x;\n        vec3 nor=GetNormal(p);\n\t\tvec3 ref = reflect(rd, nor);\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        \n        result= lightingv3(nor, p,light_pos1,rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd,ro,colobj,hit.x)*light_color2;\n        rcol= result/2.0;\n        rcol= (ACESFilm(rcol)+linear2srgb(rcol)+rcol+ exposureToneMapping(3.0, rcol))/4.0 ; \n             // set up the ray orgin and direction for reflection.\n\t\tro = p + nor*0.001;\n        if (int(hit.y)==201) { rd =ref; rcol-=vec3(0.15); }\n              // lighten intensity on each successive reflect.\n\t\tif(i == 0) col = rcol;\n\t\telse col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t  } \n     else if(hit.x>MAX_DIST)\n    col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n\t}\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mouseUV = iMouse.xy/iResolution.xy; // Range: <0, 1>\n   \n    float t0=iTime;\n    tg=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    \n   vec3 ro=vec3(0.0,7.0,-25.0+tg);\n    vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[503, 503, 535, 535, 619], [621, 665, 709, 709, 736], [737, 737, 777, 777, 804], [805, 805, 850, 850, 878], [880, 880, 916, 916, 961], [963, 963, 997, 997, 1093], [1094, 1094, 1128, 1128, 1219], [1220, 1220, 1254, 1254, 1345], [1348, 1353, 1390, 1390, 1473], [1475, 1515, 1551, 1600, 1679], [1682, 1731, 1753, 1753, 1825], [1827, 1827, 1848, 1848, 2164], [2166, 2166, 2185, 2185, 2424], [2426, 2426, 2445, 2445, 3234], [3236, 3236, 3261, 3261, 4137], [4139, 4139, 4163, 4163, 4325], [4327, 4327, 4375, 4375, 4654], [4657, 4657, 4701, 4701, 5022], [5024, 5024, 5061, 5061, 5318], [5320, 5320, 5343, 5343, 5498], [5500, 5500, 5590, 5590, 6550], [6552, 6552, 6584, 6584, 6788], [6790, 6790, 6860, 6860, 6994], [6996, 6996, 7023, 7023, 7112], [7114, 7114, 7172, 7172, 7220], [7222, 7222, 7245, 7245, 7357], [7359, 7359, 7391, 7391, 8462], [8464, 8464, 8521, 8521, 9033]], "test": "untested"}
{"id": "ssGBzd", "name": "n-dimensional raymarcher", "author": "u004fu0077u004f", "description": "Forked from gcgac's 4D and 5D raymarchers. Shows a 3D cross section of an nD scene where n is an arbitrary number. The balls are not changing size; only the camera position is changing. Hold mouse 1: X is -30 to 30 on 4th axis, Y is -30 to 30 on 5th axis.", "tags": ["raymarching", "raymarcher", "4d", "5d"], "likes": 1, "viewed": 227, "published": 3, "date": "1658877308", "time_retrieved": "2024-07-30T16:38:40.538792", "image_code": "// [vvv] TRY CHANGING THIS [vvv]\n#define DIMENSIONS 6\n// [^^^] TRY CHANGING THIS [^^^]\n#define vecn float[DIMENSIONS]\nvecn vecn_add(vecn a, vecn b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]+b[i];\n    return c;\n}\nvecn vecn_sub(vecn a, vecn b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]-b[i];\n    return c;\n}\nvecn vecn_sub(vecn a, float b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]-b;\n    return c;\n}\nvecn vecn_mul(vecn a, float b) {\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]*b;\n    return c;\n}\nfloat vecn_length(vecn a) {\n    float len = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) len += a[i]*a[i];\n    return sqrt(len);\n}\nvecn vecn_normalize(vecn a) {\n    float len = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) len += a[i]*a[i];\n    len = sqrt(len);\n    vecn c;\n    for (int i=0; i<DIMENSIONS; ++i) c[i] = a[i]/len;\n    return c;\n}\nfloat vecn_distance(vecn a, vecn b) {\n    float dist = 0.;\n    for (int i=0; i<DIMENSIONS; ++i) {\n        float c = abs(a[i]-b[i]);\n        dist += c*c;\n    }\n    return sqrt(dist);\n}\nconst int rand_w = 64;\nint rand_i;\nfloat rand() {\n    vec4 texel = texelFetch(iChannel0, ivec2(rand_i%rand_w, rand_i/rand_w), 0);\n    switch ((rand_i++)%4) {\n        case 0:\n            return texel.r;\n        case 1:\n            return texel.g;\n        case 2:\n            return texel.b;\n        default:\n            return texel.a;\n    }\n}\nvec3 rgb;\nfloat sde;\nvecn pos;\nconst float maxl = 10000.0;\nfloat t;\nfloat sphere_sde(vecn ray, vecn position, float radius, vec3 col) {\n    float d = vecn_distance(position, ray)-radius;\n    if (d < sde) {\n        rgb = col;\n        sde = d;\n    }\n    return d;\n}\nfloat calc_sdf(vecn ray) {\n    sde = maxl;\n    #if DIMENSIONS == 4\n        float d1 = sphere_sde(ray, vecn(-20.0,  0.0, 70.0,  10.0), 20.0, vec3(1, 0, 0));\n        float d2 = sphere_sde(ray, vecn(  0.0,  0.0, 70.0, -20.0), 20.0, vec3(0, 0, 1));\n        float d3 = sphere_sde(ray, vecn(-10.0, 15.0, 75.0,  30.0), 30.0, vec3(0, 1, .5));\n    #else\n        rand_i = 0;\n        for (int i=0; i<DIMENSIONS; ++i) {\n            vecn position;\n            position[0] = (rand()*2.-1.)*20.;\n            position[1] = (rand()*2.-1.)*10.;\n            position[2] = (rand()*2.-1.)*5.+70.;\n            for (int i=3; i<DIMENSIONS; ++i) position[i] = (rand()*2.-1.)*30.;;\n            float radius = rand()*10.+20.;\n            vec3 col = vec3(rand(), rand(), rand());\n            sphere_sde(ray, position, radius, col);\n        }\n    #endif\n    return sde;\n}\nvec4 raycol(vecn orig, vecn dir, float ml) {\n    float len = 0.0;\n    float sde = ml;\n    float steps = 0.0;\n    pos = orig;\n    while (len < ml && sde > 0.1) {\n        sde = calc_sdf(pos);\n        pos = vecn_add(pos, vecn_mul(dir, sde));\n        len += sde;\n        steps += 1.0;\n    }\n    return vec4(rgb, steps);\n}\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vecn pos;\n    pos[0] = 0.;\n    pos[1] = 0.;\n    pos[2] = -11.;\n    for (int i=3; i<DIMENSIONS; ++i) {\n        pos[i] = cos((float(i)/float(DIMENSIONS)+1.)*iTime)*20.;\n    }\n    #if DIMENSIONS >= 4\n        if (iMouse.z > 0.) {\n            pos[3] = (iMouse.x/iResolution.x*2.-1.)*30.;\n            #if DIMENSIONS >= 5\n                pos[4] = (iMouse.y/iResolution.y*2.-1.)*30.;\n            #endif\n        }\n    #endif\n    vecn direction;\n    direction[0] = uv.x;\n    direction[1] = uv.y;\n    direction[2] = 1.;\n    for (int i=3; i<DIMENSIONS; ++i) direction[i] = 0.; // \"aRrAy CoNsTrUcToR nEeDs OnE aRgUmEnT pEr ArRaY eLeMeNt\"\n    direction = vecn_normalize(direction);\n    vec4 o;\n    float steps;\n    o = raycol(pos, direction, 1000.0);\n    if (sde <= 0.1) {\n        steps = o.w;\n        rgb = o.xyz;\n        rgb /= steps/2.0;\n        fragColor = vec4(rgb, 1.0);\n    }\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 149, 149, 232], [233, 233, 264, 264, 347], [348, 348, 380, 380, 460], [461, 461, 493, 493, 573], [574, 574, 601, 601, 700], [701, 701, 730, 730, 908], [909, 909, 946, 946, 1092], [1128, 1128, 1142, 1142, 1435], [1504, 1504, 1571, 1571, 1699], [1700, 1700, 1726, 1726, 2542], [2543, 2543, 2587, 2587, 2860]], "test": "untested"}
{"id": "7sGBDV", "name": "Second Wave Function Collapser", "author": "mrange", "description": "// CC0: Second attempt to fake Wave Function Collapse\n// I watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\n// The algorithm AFAIK doesn't fit shader world that well.\n// But I thought I could fake it.\n", "tags": ["2d"], "likes": 25, "viewed": 397, "published": 3, "date": "1658862487", "time_retrieved": "2024-07-30T16:38:41.573027", "image_code": "// CC0: Second attempt to fake Wave Function Collapse\n// I watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\n// The algorithm AFAIK doesn't fit shader world that well.\n// But I thought I could fake it.\n// So randomizing rotations of out a 6 shapes in all grid tiles that don't touch each other\n// Then in the connecting grid tiles I select a shape to match the surrounding randomized cells\n\n// I thought it was a bit interesting and a bit different from how I usually do when doing truchet patterns so I shared\n\n// See only the randomized tiles\n//#define RANDOMIZED_TILES_ONLY\n\n// See the debugging dots\n//#define DEBUG_DOTS\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nconst float linew = 0.02;\nconst float circle = 0.1;\n\nfloat halfPlane(vec2 p) {\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  return p.y < 0.0 ? d0 : d1;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d2 = length(p)-circle;\n  float d = min(d0, d1);\n  d = min(d, d2);\n  d = max(d, -d2);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_corner(vec2 p) {\n  float d0 = length(p-0.5)-0.5;\n  float d = d0;\n  d = abs(d);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_line(vec2 p) {\n  float d0 = abs(p.y);\n  float d = d0;\n  d -= linew;\n  return d;\n}\n\nfloat cell1(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d2 = length(p)-circle;\n  float d = \n    p.x > 0.0\n    ? min(d0, d1)\n    : d0\n    ;\n  d = min(d, d2);\n  d = max(d, -d2);\n    \n  d -= linew;\n  return d;\n}\n\nfloat cell3(vec2 p) {\n  float d0 = halfPlane(p);\n  float d2 = length(p)-circle;\n  float d = d0;\n  d = min(d, d2);\n  d = max(d, -d2);\n  d -= linew;\n  return d;\n}\n\nfloat cell4(vec2 p) {\n  float d = length(p)-circle;\n  d = abs(d);\n  d -= linew;\n  return d;\n}\n\nconst int distribution[16] = int[](\n    0                   // cell0\n  , 1 , 1               // cell1\n  , 2 , 2 , 2 , 2 , 2   // cell2_corner\n  , 3 , 3 , 3 , 3 , 3   // cell2_line\n  , 4 , 4               // cell3\n  , 5                   // cell4\n  );\n\nvoid selector(vec2 cn, out int rot, out int shape) {\n  float h0 = hash(cn);\n  float h1 = fract(h0*8677.0);\n  rot   = int(floor(4.0*h1));\n  shape = distribution[int(floor(16.0*h0))];\n}\n\nconst bool open[6*4] = bool[](\n//  left    top     right   bottom\n    false , false , false , false   // cell0\n  , true  , false , false , false   // cell1\n  , true  , false , false , true    // cell2_corner\n  , false , true  , false , true    // cell2_line\n  , true  , false , true  , true    // cell3\n  , true  , true  , true  , true    // cell4\n  );\n\nbool isOpen(int off, vec2 cn) {\n  int rot;\n  int shape;\n  selector(cn, rot, shape);\n  int r = 0x3&(off+rot);\n  return open[shape*4+r];\n}\n\n\nfloat df(vec2 p) {\n  const mat2[4] rots = mat2[](ROT(0.0*TAU/4.0),ROT(1.0*TAU/4.0),ROT(2.0*TAU/4.0),ROT(3.0*TAU/4.0)); \n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n  \n  if (mod(cn.x+cn.y, 2.0) == 0.0) {\n    int rot;\n    int shape;\n    selector(cn, rot, shape);\n    cp *= rots[rot];\n    switch(shape) {\n    case 0:\n       return cell0(cp);\n    case 1:\n      return cell1(cp);\n    case 2:\n      return cell2_corner(cp);\n    case 3:\n      return cell2_line(cp);\n    case 4:\n      return cell3(cp);\n    case 5:\n      return cell4(cp);\n   default:\n      return length(p);\n    }\n  } else {\n    float d = 1E6;\n\n    int ol = isOpen(2, cn+vec2(-1.0, 0.0)) ? 0 : 1;\n    int ot = isOpen(3, cn+vec2( 0.0, 1.0)) ? 0 : 2;\n    int or = isOpen(0, cn+vec2( 1.0, 0.0)) ? 0 : 4;\n    int ob = isOpen(1, cn+vec2( 0.0,-1.0)) ? 0 : 8;\n\n#ifdef DEBUG_DOTS\n    const float dbgw = 0.025;\n    // Debugging code\n    if (ol == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2(-1.0, 0.0))-dbgw);\n    }\n    if (ot == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, 1.0))-dbgw);\n    }\n    if (or == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 1.0, 0.0))-dbgw);\n    }\n    if (ob == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, -1.0))-dbgw);\n    }\n#endif\n\n    int sel = ol + ot + or + ob;\n    float ds = length(cp)-linew;\n\n#ifdef RANDOMIZED_TILES_ONLY\n\n#else\n    // Yikes, this would nice to find a neat little improvement too\n    switch(sel) {\n    case 0:\n      ds = cell4(cp);\n      break;\n    case 1:\n      ds = cell3(-cp.yx);\n      break;\n    case 2:\n      ds = cell3(cp);\n      break;\n    case 4:\n      ds = cell3(cp.yx);\n      break;\n    case 8:\n      ds = cell3(-cp);\n      break;\n    case 3:\n      ds = cell2_corner(vec2(cp.y, -cp.x));\n      break;\n    case 6:\n      ds = cell2_corner(cp);\n      break;\n    case 9:\n      ds = cell2_corner(-cp);\n      break;\n    case 12:\n      ds = cell2_corner(vec2(-cp.y, cp.x));\n      break;\n    case 5:\n      ds = cell2_line(cp);\n      break;\n    case 10:\n      ds = cell2_line(cp.yx);\n      break;\n    case 7:\n      ds = cell1(cp.yx);\n      break;\n    case 11:\n      ds = cell1(-cp);\n      break;\n    case 13:\n      ds = cell1(-cp.yx);\n      break;\n    case 14:\n      ds = cell1(cp);\n      break;\n    case 15:\n      ds = cell0(cp);\n      break;\n    default:\n      break;\n    }\n    d = min(d, ds);\n#endif    \n    return d;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  float z = mix(0.25, 0.05, smoothstep(0.25, -0.25, cos(TIME*TAU/20.0)));\n  vec2 dp = p;\n  const float spd = 2.0;\n  const float r = 10.0;\n  dp /= z;\n  dp += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n  float d = df(dp)*z;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[853, 913, 934, 934, 1004], [1059, 1059, 1084, 1084, 1163], [1165, 1165, 1186, 1186, 1353], [1355, 1355, 1383, 1383, 1473], [1475, 1475, 1501, 1501, 1568], [1570, 1570, 1591, 1591, 1798], [1800, 1800, 1821, 1821, 1960], [1962, 1962, 1983, 1983, 2055], [2309, 2309, 2361, 2361, 2492], [2848, 2848, 2879, 2879, 2984], [5348, 5348, 5403, 5403, 5879]], "test": "untested"}
{"id": "ssyBDK", "name": "PT workshop 2S: Ray-triangle tes", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 2: Implementing a ray-triangle intersection test.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 126, "published": 3, "date": "1658855134", "time_retrieved": "2024-07-30T16:38:42.460654", "image_code": "// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\n// A triangle along with some shading parameters\nstruct triangle_t {\n    // The positions of the three vertices (v_0, v_1, v_2)\n    vec3 positions[3];\n    // A vector of length 1, orthogonal to the triangle (n)\n    vec3 normal;\n    // The albedo of the triangle (i.e. the fraction of\n    // red/green/blue light that gets reflected) (a)\n    vec3 color;\n    // The radiance emitted by the triangle (for light sources) (L_e)\n    vec3 emission;\n};\n\n\n// Checks whether a ray intersects a triangle\n// \\param out_t The ray parameter at the intersection (if any) (t)\n// \\param origin The position at which the ray starts (o)\n// \\param direction The direction vector of the ray (d)\n// \\param tri The triangle for which to check an intersection\n// \\return true if there is an intersection, false otherwise\nbool ray_triangle_intersection(out float out_t, vec3 origin, vec3 direction, triangle_t tri) {\n    vec3 v0 = tri.positions[0];\n    mat3 matrix = mat3(-direction, tri.positions[1] - v0, tri.positions[2] - v0);\n    vec3 solution = inverse(matrix) * (origin - v0);\n    out_t = solution.x;\n    vec2 barys = solution.yz;\n    return out_t >= 0.0 && barys.x >= 0.0 && barys.y >= 0.0 && barys.x + barys.y <= 1.0;\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Trace a ray against a single triangle and display t\n    triangle_t tri;\n    tri.positions[0] = vec3(0.555999935, -0.000000119, 0.548799932);\n    tri.positions[1] = vec3(0.555999935, -0.000000119, 0.000000040);\n    tri.positions[2] = vec3(0.555999935, -0.559199989, 0.000000040);\n    tri.normal = vec3(-1.0, 0.0, -0.0);\n    tri.color = vec3(0.730000019, 0.246000007, 0.250999987);\n    tri.emission = vec3(0.0, 0.0, 0.0);\n    float t;\n    out_color.rgb = vec3(0.0);\n    if (ray_triangle_intersection(t, camera_position, ray_direction, tri))\n        out_color.rgb = vec3(0.7 * t);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 501, 612, 612, 732], [1182, 1532, 1626, 1626, 1938], [1941, 1941, 1998, 2051, 3185]], "test": "untested"}
{"id": "7sGBDK", "name": "PT workshop 1S: Primary rays", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 1: Generating camera rays for a pinhole camera.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 126, "published": 3, "date": "1658854867", "time_retrieved": "2024-07-30T16:38:43.197683", "image_code": "// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    vec3 image_plane_pos = left_bottom + x * right + y * up;\n    return normalize(image_plane_pos - camera_position);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Display the ray direction as color (mapping [-1,1] to [0, 1])\n    out_color.rgb = ray_direction * 0.5 + vec3(0.5);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 501, 612, 612, 732], [735, 735, 792, 845, 1516]], "test": "untested"}
{"id": "7dGBDK", "name": "PT workshop 1: Primary rays", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 1: Generating camera rays for a pinhole camera.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 1, "viewed": 944, "published": 3, "date": "1658854790", "time_retrieved": "2024-07-30T16:38:46.806035", "image_code": "// Computes the direction vector of a primary ray\n// \\param x, y Coordinates between 0 and 1 for the pixel that the ray\n//      passes through (x, y)\n// \\param camera_position Position vector for the camera (o)\n// \\param left_bottom Position vector for the left bottom corner of\n//      the image plane (c)\n// \\param right, up Direction vectors towards the right and top end\n//      of the image plane (r, u)\n// \\return A direction vector of length 1 for a ray through the\n//      specified pixel (d)\nvec3 get_primary_ray_direction(float x, float y, vec3 camera_position, vec3 left_bottom, vec3 right, vec3 up) {\n    // TODO\n    return vec3(0.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    // Define the camera position and the view plane\n    vec3 camera_position = vec3(0.278, 0.8, 0.2744);\n    vec3 middle = camera_position - vec3(0.0, 0.8, 0.0);\n    vec3 up = vec3(0.0, 0.0, 0.56);\n    float aspect = float(iResolution.x) / float(iResolution.y);\n    vec3 right = aspect * vec3(-0.56, 0.0, 0.0);\n    vec3 left_bottom = middle - 0.5 * right - 0.5 * up;\n    // Compute the camera ray\n    vec2 tex_coord = pixel_coord / iResolution.xy;\n    vec3 ray_direction = get_primary_ray_direction(\n        tex_coord.x, tex_coord.y, camera_position, left_bottom, right, up);\n    // Display the ray direction as color (mapping [-1,1] to [0, 1])\n    out_color.rgb = ray_direction * 0.5 + vec3(0.5);\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 501, 612, 624, 648], [651, 651, 708, 761, 1432]], "test": "untested"}
{"id": "sdGBDK", "name": "PT workshop 0S: Hello ShaderToy", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 0: Trivial exercise to get to know ShaderToy.\nSolved.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 0, "viewed": 98, "published": 3, "date": "1658854628", "time_retrieved": "2024-07-30T16:38:47.805364", "image_code": "// Returns the background color that gets displayed\nvec3 get_background_color() {\n    return vec3(0.0, 0.0, 1.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    out_color.rgb = get_background_color();\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 81, 81, 115], [118, 118, 175, 175, 244]], "test": "untested"}
{"id": "ssyfWK", "name": "PT workshop 0: Hello ShaderToy", "author": "christoph_peters", "description": "A simple path tracer written for educational purposes.\nExercise 0: Trivial exercise to get to know ShaderToy.\nhttps://www.intel.com/content/www/us/en/developer/videos/path-tracing-workshop-part-1.html", "tags": ["educational", "pathtracing", "exercises"], "likes": 2, "viewed": 864, "published": 3, "date": "1658854397", "time_retrieved": "2024-07-30T16:38:48.964265", "image_code": "// Returns the background color that gets displayed\nvec3 get_background_color() {\n    // TODO\n    return vec3(1.0, 0.0, 0.0);\n}\n\n\nvoid mainImage(out vec4 out_color, in vec2 pixel_coord) {\n    out_color.rgb = get_background_color();\n    out_color.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 81, 93, 127], [130, 130, 187, 187, 256]], "test": "untested"}
{"id": "fsyfWV", "name": "Wave Function Collapse faking", "author": "mrange", "description": "CC0: First attempt to fake Wave Function Collapse\nI watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\nThe algorithm AFAIK doesn't fit shader world that well.\nBut I thought I could fake it.\n", "tags": ["2d"], "likes": 9, "viewed": 323, "published": 3, "date": "1658847804", "time_retrieved": "2024-07-30T16:38:50.004484", "image_code": "// CC0: First attempt to fake Wave Function Collapse\n// I watched Coding Challenge 171: Wave Function Collapse: https://www.youtube.com/watch?v=rI_y2GAlQFM\n// The algorithm AFAIK doesn't fit shader world that well.\n// But I thought I could fake it.\n// So randomizing rotations of a basic shape in all grid cells that don't touch each other\n// Then in the connecting grid cells I select a shape to match the surrounding randomized cells\n// Looks rather plane ATM but if one use a randomized shape as well as rotation that should improve\n// the result I think\n\n// I thought it was a bit interesting and a bit different from how I usually do when doing truchet patterns so I shared\n\n// See only the randomized cells\n// #define RANDOMIZED_CELLS_ONLY\n\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nconst float linew = 0.02;\n\nfloat halfPlane(vec2 p) {\n  float d0 = length(p);\n  float d1 = abs(p.x);\n  return p.y < 0.0 ? d0 : d1;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat vmax(vec2 v) {\n  return max(v.x, v.y);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat corner(vec2 p) {\n  return length(max(p, vec2(0))) + vmax(min(p, vec2(0)));\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d = min(d0, d1);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_corner(vec2 p) {\n  float d0 = corner(-p);\n  float d = d0;\n  d = abs(d);\n  d -= linew;\n  return d;\n}\n\nfloat cell2_line(vec2 p) {\n  float d0 = abs(p.y);\n  float d = d0;\n  d -= linew;\n  return d;\n}\n\nfloat cell1(vec2 p) {\n  float d0 = abs(p.x);\n  float d1 = abs(p.y);\n  float d = \n    p.x > 0.0\n    ? min(d0, d1)\n    : d0\n    ;\n    \n  d -= linew;\n  return d;\n}\n\nfloat cell3(vec2 p) {\n  float d = halfPlane(p);\n  d -= linew;\n  return d;\n}\n\nfloat cell4(vec2 p) {\n  float d = length(p);\n  d -= linew;\n  return d;\n}\n\nint rotation(float h) {\n  return int(floor(4.0*h));\n}\n\nfloat df(vec2 p) {\n  const mat2[4] rots = mat2[](ROT(0.0*TAU/4.0),ROT(1.0*TAU/4.0),ROT(2.0*TAU/4.0),ROT(3.0*TAU/4.0)); \n  vec2 cp = p-0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n  \n  float x = cn.x+cn.y;\n  \n  float h0 = hash(cn);\n\n  if (mod(x, 2.0) == 0.0) {\n    cp *= rots[rotation(h0)];\n    // Randomizing the cell shape should lead to more interesting patterns \n    return cell1(cp);\n  } else {\n    float d = 1E6;\n#if defined(RANDOMIZED_CELLS_ONLY)\n#else\n    int ol = (0x3&(2+rotation(hash(cn+vec2(-1.0, 0.0))))) == 0 ? 0 : 1;\n    int ot = (0x3&(3+rotation(hash(cn+vec2( 0.0, 1.0))))) == 0 ? 0 : 2;\n    int or = (0x3&(0+rotation(hash(cn+vec2( 1.0, 0.0))))) == 0 ? 0 : 4;\n    int ob = (0x3&(1+rotation(hash(cn+vec2( 0.0,-1.0))))) == 0 ? 0 : 8;\n\n    const float dbgw = 0.025;\n    // Debugging code\n    if (ol == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2(-1.0, 0.0))-dbgw);\n    }\n    if (ot == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, 1.0))-dbgw);\n    }\n    if (or == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 1.0, 0.0))-dbgw);\n    }\n    if (ob == 0) {\n      d = min(d, length(cp-4.0*dbgw*vec2( 0.0, -1.0))-dbgw);\n    }\n\n    int sel = ol + ot + or + ob;\n    float ds = length(cp)-linew;\n\n    // Yikes\n    switch(sel) {\n    case 0:\n      ds = cell4(cp);\n      break;\n    case 1:\n      ds = cell3(-cp.yx);\n      break;\n    case 2:\n      ds = cell3(cp);\n      break;\n    case 4:\n      ds = cell3(cp.yx);\n      break;\n    case 8:\n      ds = cell3(-cp);\n      break;\n    case 3:\n      ds = cell2_corner(vec2(cp.y, -cp.x));\n      break;\n    case 6:\n      ds = cell2_corner(cp);\n      break;\n    case 9:\n      ds = cell2_corner(-cp);\n      break;\n    case 12:\n      ds = cell2_corner(vec2(-cp.y, cp.x));\n      break;\n    case 5:\n      ds = cell2_line(cp);\n      break;\n    case 10:\n      ds = cell2_line(cp.yx);\n      break;\n    case 7:\n      ds = cell1(cp.yx);\n      break;\n    case 11:\n      ds = cell1(-cp);\n      break;\n    case 13:\n      ds = cell1(-cp.yx);\n      break;\n    case 14:\n      ds = cell1(cp);\n      break;\n    case 15:\n      ds = cell0(cp);\n      break;\n    default:\n      break;\n    }\n\n    d = min(d, ds);\n#endif    \n    return d;\n  }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  const float z = 0.2;\n  vec2 dp = p;\n  const float spd = 0.5;\n  const float r = 10.0;\n  dp += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n  dp /= z;\n  float d = df(dp)*z;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[926, 986, 1007, 1007, 1077], [1106, 1106, 1131, 1131, 1210], [1212, 1298, 1318, 1318, 1344], [1346, 1432, 1454, 1454, 1514], [1516, 1516, 1537, 1537, 1636], [1638, 1638, 1666, 1666, 1749], [1751, 1751, 1777, 1777, 1844], [1846, 1846, 1867, 1867, 2006], [2008, 2008, 2029, 2029, 2083], [2085, 2085, 2106, 2106, 2157], [2159, 2159, 2182, 2182, 2212], [4380, 4380, 4435, 4435, 4860]], "test": "untested"}
{"id": "fsyfWK", "name": "task2_draft", "author": "Zhang_guoxi", "description": "task2", "tags": ["3d"], "likes": 2, "viewed": 245, "published": 3, "date": "1658845505", "time_retrieved": "2024-07-30T16:38:51.231204", "image_code": "void mainImage( out vec4 f, in vec2 w )\n{\n     f = texelFetch(iChannel0, ivec2(w), 0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//============================================================================\n// PROJECT ID:\n//\n// GROUP NUMBER:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// STUDENT NAME:\n// NUS User ID.:\n//\n// COMMENTS TO GRADER:\n//\n//============================================================================\n\n\n// FRAGMENT SHADER FOR SHADERTOY\n// Run this at https://www.shadertoy.com/new\n// See documentation at https://www.shadertoy.com/howto\n\n// Your browser must support WebGL 2.0.\n// Check your browser at https://webglreport.com/?v=2\n\n\n//============================================================================\n// Constants.\n//============================================================================\n\nconst vec3 BACKGROUND_COLOR = vec3( 0.1, 0.2, 0.6 );\n\n// Vertical field-of-view angle of camera. In radians.\nconst float FOVY = 50.0 * PI / 180.0;\n\n// Use this for avoiding the \"epsilon problem\" or the shadow acne problem.\nconst float DEFAULT_TMIN = 10.0e-4;\n\n// Use this for tmax for non-shadow ray intersection test.\nconst float DEFAULT_TMAX = 10.0e6;\n\n// Equivalent to number of recursion levels (0 means ray-casting only).\n// We are using iterations to replace recursions.\nconst int NUM_ITERATIONS = 6;\n\n// Constants for the scene objects.\nconst int NUM_LIGHTS = 2;\nconst int NUM_MATERIALS = 5;\nconst int NUM_PLANES = 2;\nconst int NUM_SPHERES = 2;\nconst int NUM_TORUS = 1;\nconst int NUM_BOXS = 4;\n\n//----------------------------------------------------------------------------\n// The lighting model used here is similar to that shown in\n// Lecture Topic B08 (Basic Ray Tracing). Here it is computed as\n//\n//     I_local = SUM_OVER_ALL_LIGHTS {\n//                   I_a * k_a +\n//                   k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ]\n//               }\n// and\n//     I = I_local  +  k_rg * I_reflected\n//----------------------------------------------------------------------------\n\n\n//============================================================================\n// Global scene data.\n//============================================================================\n//Geometry objects\nPlane_t Plane[NUM_PLANES];\nSphere_t Sphere[NUM_SPHERES];\nTorus_t Torus[NUM_TORUS];\nBox_t Box[NUM_BOXS];\n//Lights\nLight_t Light[NUM_LIGHTS];\n//Materials\nMaterial_t Material[NUM_MATERIALS];\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Initializes the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid InitScene()\n{\n    /*// Horizontal plane.\n    Plane[0].A = 0.0;\n    Plane[0].B = 1.0;\n    Plane[0].C = 0.0;\n    Plane[0].D = 0.0;\n    Plane[0].materialID = 3;\n\n    // Vertical plane.\n    Plane[1].A = 0.0;\n    Plane[1].B = 0.0;\n    Plane[1].C = 1.0;\n    Plane[1].D = 3.5;\n    Plane[1].materialID = 0;\n    */\n    // Center bouncing sphere.\n    Sphere[0].center = vec3( 0.0, abs(sin(6.2831 * iTime)) + 0.7, 0.0 );\n    Sphere[0].radius = 0.7;\n    Sphere[0].materialID = 1;\n\n    // Circling sphere.\n    Sphere[1].center = vec3( 1.5 * cos(iTime), 0.5 + abs(cos(6.2831 * iTime)), 1.5 *sin(iTime) );\n    Sphere[1].radius = 0.5;\n    Sphere[1].materialID = 2;\n    \n    Torus[0].x = 2.0;\n    Torus[0].y = 0.5;\n    Torus[0].materialID = 2;\n    \n    Box[0].size = vec3(.3,.3,.3);\n    Box[0].center = vec3(3.0*cos(iTime),sin(iTime)+1.5,3.0*sin(iTime));\n    Box[0].materialID = 4;\n    \n    Box[1].size = vec3(.3,.3,.3);\n    Box[1].center = vec3(3.0*cos(iTime+PI/2.0),sin(iTime+PI)+1.5,3.0*sin(iTime+PI/2.0));\n    Box[1].materialID = 4;\n    \n    Box[2].size = vec3(.3,.3,.3);\n    Box[2].center = vec3(3.0*cos(iTime-PI/2.0),sin(iTime+HalfPI)+1.5,3.0*sin(iTime-PI/2.0));\n    Box[2].materialID = 4;\n    \n    Box[3].size = vec3(.3,.3,.3);\n    Box[3].center = vec3(3.0*cos(iTime+PI),cos(iTime+3.0*HalfPI)+1.5,3.0*sin(iTime+PI));\n    Box[3].materialID = 4;\n    \n    // Silver material.\n    Material[0].k_d = vec3( 0.5, 0.5, 0.5 );\n    Material[0].k_a = 0.2 * Material[0].k_d;\n    Material[0].k_r = 2.0 * Material[0].k_d;\n    Material[0].k_rg = 0.5 * Material[0].k_r;\n    Material[0].n = 64.0;\n    Material[0].ior = -1.0;\n    Material[0].fuzz = 0.1;\n\n    // Gold material.\n    Material[1].k_d = vec3( 1.0, 1.0, 1.0 );\n    Material[1].k_a = 0.0 * Material[1].k_d;\n    Material[1].k_r = 0.2 * Material[1].k_d;\n    Material[1].k_rg = 2.0 * Material[1].k_r;\n    Material[1].n = 32.0;\n    Material[1].ior = 1.5;\n    Material[1].fuzz = 0.0;\n    // Green plastic material.\n    Material[2].k_d = vec3( 0.0, 0.8, 0.0 );\n    Material[2].k_a = 0.2 * Material[2].k_d;\n    Material[2].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[2].k_rg = 0.5 * Material[2].k_r;\n    Material[2].n = 128.0;\n    Material[2].ior = -1.0;\n    Material[2].fuzz = 0.0;\n    \n    Material[3].k_d = vec3( 0.01, 0.01, 0.01 );\n    Material[3].k_a = 0.1 * Material[3].k_d;\n    Material[3].k_r = 0.0 * Material[3].k_d;\n    Material[3].k_rg = 0.9 * Material[0].k_r;\n    Material[3].n = 64.0;\n    Material[3].ior = 1.1;\n    Material[3].fuzz = 0.0;\n    \n    //Box material.\n    Material[4].k_d = vec3( 0.2, 0.2, 0.2 );\n    Material[4].k_a = 0.2 * Material[2].k_d;\n    Material[4].k_r = vec3( 1.0, 1.0, 1.0 );\n    Material[4].k_rg = 0.5 * Material[2].k_r;\n    Material[4].n = 128.0;\n    Material[4].ior = -1.0;\n    Material[4].fuzz = 0.0;\n\n    // Light 0.\n    Light[0].position = vec3( 4.0, 8.0, -3.0 );\n    Light[0].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[0].I_source = vec3( 1.0, 1.0, 1.0 );\n\n    // Light 1.\n    Light[1].position = vec3( -4.0, 8.0, 0.0 );\n    Light[1].I_a = vec3( 0.1, 0.1, 0.1 );\n    Light[1].I_source = vec3( 1.0, 1.0, 1.0 );\n}\n\nvoid evaluateMatrial(in Material_t)\n{\n    \n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes (I_a * k_a) + k_shadow * I_source * [ k_d * (N.L) + k_r * (R.V)^n ].\n// Input vectors L, N and V are pointing AWAY from surface point.\n// Assume all vectors L, N and V are unit vectors.\n/////////////////////////////////////////////////////////////////////////////\nvec3 PhongLighting( in vec3 L, in vec3 N, in vec3 V, in bool inShadow,\n                    in Material_t mat, in Light_t light )\n{\n    if ( inShadow ) {\n        return light.I_a * mat.k_a;\n    }\n    else {\n        vec3 R = reflect( -L, N );\n        float N_dot_L = max( 0.0, dot( N, L ) );\n        float R_dot_V = max( 0.0, dot( R, V ) );\n        float R_dot_V_pow_n = ( R_dot_V == 0.0 )? 0.0 : pow( R_dot_V, mat.n );\n\n        return light.I_a * mat.k_a +\n               light.I_source * (mat.k_d * N_dot_L + mat.k_r * R_dot_V_pow_n);\n    }\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec3 CastRay( in Ray_t ray,\n              out bool hasHit, out vec3 hitPos, out vec3 hitNormal, out vec3 k_rg,out float ior, out float fuzz )\n{\n    // Find whether and where the ray hits some object.\n    // Take the nearest hit point.\n\n    bool hasHitSomething = false;\n    float nearest_t = DEFAULT_TMAX;   // The ray parameter t at the nearest hit point.\n    vec3 nearest_hitPos;              // 3D position of the nearest hit point.\n    vec3 nearest_hitNormal;           // Normal vector at the nearest hit point.\n    int nearest_hitMatID;             // MaterialID of the object at the nearest hit point.\n\n    float temp_t;\n    vec3 temp_hitPos;\n    vec3 temp_hitNormal;\n    bool temp_hasHit;\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Try interesecting input ray with all the planes and spheres,\n    //   and record the front-most (nearest) interesection.\n    // * If there is interesection, need to record hasHitSomething,\n    //   nearest_t, nearest_hitPos, nearest_hitNormal, nearest_hitMatID.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    \n    /*for (int i = 0; i < NUM_PLANES; i++ ) {\n        temp_hasHit = IntersectPlane(Plane[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n\n        if (temp_hasHit && temp_t < nearest_t ) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Plane[i].materialID;\n        }\n        \n    }\n    */\n    \n    for (int i = 0; i < NUM_SPHERES; i++ ) {\n        temp_hasHit = IntersectSphere(Sphere[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Sphere[i].materialID;\n        }\n    }\n    \n    for (int i = 0; i < NUM_BOXS; i++ ) {\n        temp_hasHit = IntersectBox(Box[i], ray, DEFAULT_TMIN, DEFAULT_TMAX,\n                      temp_t, temp_hitPos, temp_hitNormal);\n        if (temp_hasHit && temp_t < nearest_t) {\n            hasHitSomething = true;\n            nearest_t = temp_t;\n            nearest_hitPos = temp_hitPos;\n            nearest_hitNormal = temp_hitNormal;\n            nearest_hitMatID = Box[i].materialID;\n        }\n    }\n    \n    hasHit = hasHitSomething;\n    if ( !hasHitSomething ) return texture(iChannel1,ray.d).rgb;;\n    \n    if(false){\n        float bump_r = 0.25*(sin(.5*iTime)+1.0);\n        vec2 c = nearest_hitPos.xz+vec2(0,iTime);\n        vec2 p = fract(c)-vec2(0.5);\n        if(length(p)<bump_r){\n            float d = length(p)/bump_r;\n            float bumpZ = cos(d*PI/2.0);\n            nearest_hitNormal = normalize(vec3(p.x,p.y,bumpZ));\n        }\n    }\n        \n\n    vec3 I_local = vec3( 0.0 );  // Result color will be accumulated here.\n\n    /////////////////////////////////////////////////////////////////////////////\n    // TASK:\n    // * Accumulate lighting from each light source on the nearest hit point.\n    //   They are all accumulated into I_local.\n    // * For each light source, make a shadow ray, and check if the shadow ray\n    //   intersects any of the objects (the planes and spheres) between the\n    //   nearest hit point and the light source.\n    // * Then, call PhongLighting() to compute lighting for this light source.\n    /////////////////////////////////////////////////////////////////////////////\n\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n    Ray_t ShadowRay[NUM_LIGHTS];\n    bool inshadow[NUM_LIGHTS];\n    for (int i = 0; i < NUM_LIGHTS; i++ ) {\n        ShadowRay[i].o = nearest_hitPos;\n        ShadowRay[i].d = normalize(Light[i].position - ShadowRay[i].o);\n\n        for (int j = 0; j < NUM_SPHERES; j++ ) {\n            if(!inshadow[i]) {\n            inshadow[i] = IntersectSphere(Sphere[j], ShadowRay[i], DEFAULT_TMIN,\n                distance(nearest_hitPos, Light[i].position));\n            }\n        }\n        for(int j = 0; j < NUM_PLANES; j++ ) {\n            if(!inshadow[i]) {\n            inshadow[i] = IntersectPlane(Plane[j], ShadowRay[i], DEFAULT_TMIN,\n                distance(nearest_hitPos, Light[i].position));\n            }\n        }\n        \n\n        I_local += PhongLighting( ShadowRay[i].d, nearest_hitNormal, -ray.d, inshadow[i],\n            Material[nearest_hitMatID], Light[i] );\n    }\n\n\n    // Populate output results.\n    hitPos = nearest_hitPos;\n    hitNormal = nearest_hitNormal;\n    k_rg = Material[nearest_hitMatID].k_rg;\n    ior = Material[nearest_hitMatID].ior;\n    fuzz = Material[nearest_hitMatID].fuzz;\n    return I_local;\n}\n\nfloat reflectance(float cosine, float ref_idx) {\n    // Use Schlick's approximation for reflectance.\n    float r0 = (1.0-ref_idx) / (1.0+ref_idx);\n    r0 = r0*r0;\n    return r0 + (1.0-r0)*pow((1.0 - cosine),5.0);\n}\n\nvec3 my_refract(vec3 uv,vec3 n,float etai_over_etat,float pR) {\n    if(dot(-uv,n)>=0.0){\n        etai_over_etat = 1.0/etai_over_etat;\n    }else{\n         n = -n;\n    }\n    float cos_theta = min(dot(-uv, n), 1.0);\n    float sin2_theta = 1.0 - cos_theta*cos_theta;\n    bool total_internal_reflect = etai_over_etat*etai_over_etat*sin2_theta > 1.0;\n    if(total_internal_reflect||reflectance(cos_theta,etai_over_etat)>pR)\n       return reflect(uv, n);\n    return refract(-uv,n,etai_over_etat);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Execution of fragment shader starts here.\n// 1. Initializes the scene.\n// 2. Compute a primary ray for the current pixel (fragment).\n// 3. Trace ray into the scene with NUM_ITERATIONS recursion levels.\n/////////////////////////////////////////////////////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    InitScene();\n    \n    //Seed for\n    vec2 p = (-iResolution.xy + 2.*fragCoord - 1.)/iResolution.y;\n    float seed = float(baseHash(floatBitsToUint(p - iTime)))/float(0xffffffffU);\n\n    // Scale pixel 2D position such that its y coordinate is in [-1.0, 1.0].\n    vec2 pixel_pos = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    // Position the camera.\n    vec2 mouse_pos = iMouse.xy /iResolution.xy;\n    vec3 cam_pos = 6.0*normalize(vec3(sin(0.11 * iTime + 3.0*mouse_pos.x), 0.8*mouse_pos.y, cos(0.11 * iTime + 3.0*mouse_pos.x))) - vec3(0.0,0.1,0.0);\n    //vec3 cam_pos = vec3( 2.5*1.5, (min(0.5,max(-0.5,sin(0.5*iTime)))+0.6)*3.0, 2.5*1.5 );\n    vec3 cam_lookat = vec3( 0.25, 1.0, 0.0 );\n    vec3 cam_up_vec = vec3( 0.0, 1.0, 0.0 );\n\n    // Set up camera coordinate frame in world space.\n    vec3 cam_z_axis = normalize( cam_pos - cam_lookat );\n    vec3 cam_x_axis = normalize( cross(cam_up_vec, cam_z_axis) );\n    vec3 cam_y_axis = normalize( cross(cam_z_axis, cam_x_axis));\n\n    // Create primary ray.\n    float pixel_pos_z = -1.0 / tan(FOVY / 2.0);\n    Ray_t pRay;\n    float aperture = .0;\n    float focus_dist = 1.0;\n    vec2 rd = aperture / 2.0 * random_in_unit_disk(seed);\n    vec3 offset = cam_x_axis*rd.x + cam_y_axis*rd.y;\n    pRay.o = cam_pos + offset;\n    pRay.d = normalize( pixel_pos.x * cam_x_axis  +  pixel_pos.y * cam_y_axis  +  pixel_pos_z * cam_z_axis);\n    \n    // Start Ray Tracing.\n    // Use iterations to emulate the recursion.\n\n    vec3 I_result = vec3( 0.0 );\n    vec3 compounded_k_rg = vec3( 1.0 );\n    Ray_t nextRay = pRay;\n\n    for ( int level = 0; level <= NUM_ITERATIONS; level++ )\n    {\n        bool hasHit;\n        vec3 hitPos, hitNormal, k_rg;\n        float ior,fuzz;\n\n        vec3 I_local = CastRay( nextRay, hasHit, hitPos, hitNormal, k_rg,ior,fuzz );\n\n        I_result += compounded_k_rg * I_local;\n\n        if ( !hasHit ) break;\n\n        compounded_k_rg *= k_rg;\n        \n        if(ior<0.0){\n            vec3 reflected = reflect(nextRay.d, hitNormal);\n            nextRay = Ray_t( hitPos, reflected+fuzz*random_in_unit_sphere(seed));\n        }\n        else{\n            float pr = hash1(seed);\n            nextRay = Ray_t( hitPos, normalize(my_refract(nextRay.d, hitNormal,ior,pr)));\n        }\n           \n            \n    }\n    fragColor = vec4((I_result+texelFetch(iChannel0, ivec2(fragCoord),0).rgb)*0.6,1.0);\n}\n", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.1415926536;\nconst float HalfPI = PI/2.0;\n\nuint baseHash( uvec2 p ) {\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\n\nfloat hash1( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    return float(n)/float(0xffffffffU);\n}\n\nvec2 hash2( inout float seed ) {\n    uint n = baseHash(floatBitsToUint(vec2(seed+=.1,seed+=.1)));\n    uvec2 rz = uvec2(n, n*48271U);\n    return vec2(rz.xy & uvec2(0x7fffffffU))/float(0x7fffffff);\n}\n\nfloat cuberoot( float x ) { return sign(x)*pow(abs(x),1.0/3.0); }\n\nvec3 random_in_unit_sphere(float seed) {\n    float u = hash1(seed);\n    float v = hash1(seed);\n    float theta = u*2.0*PI;\n    float phi = acos(2.0*v-1.0);\n    float r = cuberoot(hash1(seed));\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    float x = r*sinPhi*cosTheta;\n    float y = r*sinPhi*sinTheta;\n    float z = r*cosPhi;\n    return vec3(x,y,z);\n}\n\nvec2 random_in_unit_disk(float seed){\n    vec2 h = hash2(seed) * vec2(1,6.28318530718);\n    float phi = h.y;\n    float r = sqrt(h.x);\n    return r*vec2(sin(phi),cos(phi));\n}\n\n//============================================================================\n// Define new struct types.\n//============================================================================\nstruct Ray_t {\n    vec3 o;  // Ray Origin.\n    vec3 d;  // Ray Direction. A unit vector.\n};\n\nstruct Plane_t {\n    // The plane equation is Ax + By + Cz + D = 0.\n    float A, B, C, D;\n    int materialID;\n};\n\nstruct Sphere_t {\n    vec3 center;\n    float radius;\n    int materialID;\n};\n\nstruct Torus_t {\n    float x;\n    float y;\n    int materialID;\n};\n\nstruct Box_t{\n    vec3 center;\n    vec3 size;\n    int materialID;\n};\n\nstruct Light_t {\n    vec3 position;  // Point light 3D position.\n    vec3 I_a;       // For Ambient.\n    vec3 I_source;  // For Diffuse and Specular.\n};\n\nstruct Material_t {\n    vec3 k_a;   // Ambient coefficient.\n    vec3 k_d;   // Diffuse coefficient.\n    vec3 k_r;   // Reflected specular coefficient.\n    vec3 k_rg;  // Global reflection coefficient.\n    float n;    // The specular reflection exponent. Ranges from 0.0 to 128.0.\n    float ior;\n    float fuzz;\n};\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is such an intersection, outputs the value of t, the position\n// of the intersection (hitPos) and the normal vector at the intersection\n// (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n\n    // We have a hit -- output results.\n    t = t0;\n    hitPos = ray.o + t0 * ray.d;\n    hitNormal = normalize( N );\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pln, in Ray_t ray, in float tmin, in float tmax )\n{\n    vec3 N = vec3( pln.A, pln.B, pln.C );\n    float NRd = dot( N, ray.d );\n    float NRo = dot( N, ray.o );\n    float t0 = (-pln.D - NRo) / NRd;\n    if ( t0 < tmin || t0 > tmax ) return false;\n    return true;\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the\n// smaller t, the position of the intersection (hitPos) and the normal\n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 oc = ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float half_b = dot(oc,ray.d);\n    float c = dot(oc,oc) - sph.radius * sph.radius;\n    \n    float discr = half_b*half_b - a*c;\n    if(discr>=0.0){\n        float sqrtd = sqrt(discr);\n        t = (-half_b-sqrtd)/a;\n        hitPos = ray.o + t * ray.d;\n        vec3 normal = normalize(hitPos - sph.center);\n        hitNormal = normal;\n        return (t >= tmin && t<= tmax);\n        \n    }\n    \n    return false;\n\n}\n\n\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    vec3 oc = ray.o - sph.center;\n    float a = dot(ray.d,ray.d);\n    float half_b = dot(oc,ray.d);\n    float c = dot(oc,oc) - sph.radius * sph.radius;\n    \n    float discr = half_b*half_b - a*c;\n    if(discr>=0.0){\n        float sqrtd = sqrt(discr);\n        float t1 = (-half_b-sqrtd)/a;\n        float t2 = (-half_b+sqrtd)/a;\n        return ((t1 >= tmin && t1<= tmax) || (t2 >= tmin && t2 <= tmax));\n    }\n    \n    return false;\n}\n\nbool IntersectTorus( in Torus_t tor, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ray.o,ray.o);\n    float n = dot(ray.o,ray.d);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(ray.d.xy,ray.d.xy) + k;\n    float k1 = n*k - Ra2*dot(ray.d.xy,ray.o.xy);\n    float k0 = k*k - Ra2*dot(ray.o.xy,ray.o.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )\n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = tmax;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        hitPos = ray.o + t*ray.d;\n        hitNormal = normalize( hitPos*(dot(hitPos,hitPos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n        return (t >= tmin && t<= tmax);\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return false;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    hitPos = ray.o+t*ray.d;\n    hitNormal = normalize( hitPos*(dot(hitPos,hitPos)-tor.y*tor.y - tor.x*tor.x*vec3(1.0,1.0,-1.0)));\n    return (t >= tmin && t<= tmax);\n}\n\n\nbool IntersectTorus( in Torus_t tor, in Ray_t ray, in float tmin, in float tmax)\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ray.o,ray.o);\n    float n = dot(ray.o,ray.d);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(ray.d.xy,ray.d.xy) + k;\n    float k1 = n*k - Ra2*dot(ray.d.xy,ray.o.xy);\n    float k0 = k*k - Ra2*dot(ray.o.xy,ray.o.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )\n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n        return (t >= tmin && t<= tmax);\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return false;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return (t >= tmin && t<= tmax);\n}\n\nbool IntersectBox( in Box_t box, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec3 hitNormal)\n{\n    vec3 ro = ray.o;\n    ray.o -= box.center;\n    vec3 m = sign(ray.d)/max(abs(ray.d), 1e-8);\n    vec3 n =m*ray.o;\n    vec3 k = abs(m)*box.size;\n    \n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    if( tN>tF || tF<=0.0) return false;\n    \n    if(tN >= tmin && tF<=tmax){\n        t = tN;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    if(tF >= tmin && tF <= tmax){\n        t = tF;\n        hitPos = ro + t*ray.d;\n        hitNormal = -sign(ray.d)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n        return true;\n    }\n    \n    return false;\n}\n                     \n", "sound_code": "// Created by inigo quilez - iq/2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\nfloat base( in float time )\n{\n    float y = 0.0;\n\n    {\n    float f = 220.0;\n    float im = 10.0 + 9.0*sin(0.25*6.2831*time);\n    float v = 0.0;\n    //v += 1.0*sin( 6.2831*f*time*1.0 + 1.0*im*sin(0.25*6.2831*f*time) );\n    v += 0.3*sin( 6.2831*f*time*0.5 + 8.0*im*sin(0.5*6.2831*f*time) );\n    v *= exp(-2.0*fract(8.0*time));\n    y += 0.3*v;\n    }\n\n    {\n    float t = fract(time*2.0);\n    float f = 220.0*exp(-5.0*t);\n    float a = sin( 6.2831*f*t*0.5 );\n    float v = 0.0;\n    v += clamp(a*8.0,-1.0,1.0)*(exp(-10.0*t) + exp(-1.0*t));\n    v += a*8.0*exp(-1.0*t);\n    y += 0.4*v;\n    }\n\n    return y;\n}\n\n\nvec2 mainSound( in int samp, float time )\n{\n    float y = 0.0;\n    float s = 1.0;\n    float o = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        y += s*base( time-o );\n        s *= 0.2;\n        o += 0.25;\n    }\n \n    \n    return vec2(y*0.15);\n}\n", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 88]], "test": "untested"}
{"id": "NsGfWK", "name": "Simple duo scale truchet", "author": "mrange", "description": "CC0: Simple duo scale truchet\nRead a bit about Wave Function Collapse algorithm to generate truchet like patterns \nStarted implementing it and was immedietly bored by it as I didn't write a shader.\nSo I wrote a shader instead.", "tags": ["2d", "truchet"], "likes": 10, "viewed": 269, "published": 3, "date": "1658840074", "time_retrieved": "2024-07-30T16:38:52.267434", "image_code": "// CC0: Simple duo scale truchet\n// Read a bit about Wave Function Collapse algorithm to generate truchet like patterns \n// Started implementing it and was immedietly bored by it as I didn't write a shader.\n// So instead I revisited the idea of multiscale truchet patterns.\n// Created a quick little duo scale truchet.\n// Much more fun\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat df0(vec2 p, float linew) {\n  vec2 cp = p - 0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n\n  float h0 = hash(cn);\n  cp = h0 > 0.5 ? cp : vec2(cp.y, -cp.x);\n  float d0 = length(cp-0.5)-0.5;\n  float d1 = length(cp+0.5)-0.5;\n  \n  float d = d0;\n  d = min(d, d1);\n  \n  d = abs(d) - linew*3.0;\n  return d;\n}\n\nfloat df1(vec2 p, float linew) {\n  vec2 cp = p - 0.5;\n  vec2 cn = round(cp);\n  cp -= cn;\n\n  float h0 = hash(cn);\n  float h1 = hash(cn+123.4);\n  \n  if (h1 > 0.66) {\n    return df0(p*3.0, linew)/3.0;\n  }\n  \n  vec2 cp2 = cp;\n  cp2 = abs(cp2);\n  cp = h0 > 0.5 ? cp : vec2(cp.y, -cp.x);\n  float d0 = length(cp-0.5)-0.5;\n  float d1 = length(cp+0.5)-0.5;\n  float d2 = length(cp2-0.5)-1.0/6.0;\n  \n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - linew;\n  d = min(d, abs(d2)-linew);\n  \n  return d;\n}\n\nfloat df(vec2 p, float f) {\n  float linew = mix(0.0, 0.05, f);\n  return df1(p, linew);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  const float z = 0.25;\n  vec2 dp = p;\n  const float spd = 0.5;\n  const float r = 10.0;\n  dp += r*sin(vec2(sqrt(0.5), 1.0)*TIME*spd/r);\n  dp /= z;\n  float f = mix(0.01, 0.05, texture(iChannel0, 0.00125*dp).x);\n  f *= 30.0;\n  f = tanh(f);\n  float d = df(dp, f)*z;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5*f), smoothstep(aa, -aa, d));\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[396, 456, 477, 477, 547], [549, 549, 581, 581, 849], [851, 851, 883, 883, 1341], [1343, 1343, 1370, 1370, 1431], [1433, 1433, 1488, 1488, 2010]], "test": "untested"}
{"id": "NsVfWy", "name": "Rainbow Sand Experiment", "author": "fenix", "description": "Trying to make a sand-like effect. The idea is to move particles within 2x2 cells ensuring no loss of mass.\n* Mouse: spawn particles\n* Mouse + shift: remove particles\n* Space: reset", "tags": ["simulation", "particles", "sand"], "likes": 4, "viewed": 219, "published": 3, "date": "1658818926", "time_retrieved": "2024-07-30T16:38:53.230858", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Particles are capable of falling or sliding down a slope greater than 45 degrees. \n//  Particle motion is performed within 2x2 cells. Buffer A's cells are in a natural\n//  alignment: cell 0, 0 includes the four cells (0 ... 1, 0 ... 1). Buffer B is offset\n//  by 1, 1 so it can advect particles across buffer A's cell boundaries. Buffers C and D\n//  are just copies of A and B respectively to get twice the integration speed.\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 ifc = ivec2(fragCoord);\n    vec4 top = texelFetch(iChannel0, ivec2(ifc.x, ifc.y & ~1), 0);\n    vec4 bottom = texelFetch(iChannel0, ivec2(ifc.x, ifc.y | 1), 0);\n    fragColor = max(top, bottom);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const int COLOR_CYCLE_FRAMES = 6000;\n\nfloat length2(vec2 x)\n{\n    return dot(x, x);\n}\n\nfloat square(float x)\n{\n    return x * x;\n}\n\nvec4 rainbow(int i)\n{\n    switch(i)\n    {\n        case 0:\n            return vec4(1.0, 0.0, 0.0, 1.0);\n        case 1:\n            return vec4(1.0, 0.5, 0.0, 1.0);\n        case 2:\n            return vec4(1.0, 1.0, 0.0, 1.0);\n        case 3:\n            return vec4(0.0, 1.0, 0.0, 1.0);\n        case 4:\n            return vec4(0.0, 0.0, 1.0, 1.0);\n        case 5:\n            return vec4(0.25, 0.0, 0.5, 1.0);\n        case 6:\n            return vec4(0.5, 0.0, 0.7, 1.0);\n    }\n}\n\nconst int COLOR_CHANGE_FRAMES = 200;\nvec4 colorByFrame(int frame)\n{   \n    int colorIndex = (frame / COLOR_CHANGE_FRAMES) % 7;\n    int nextColorIndex = (colorIndex + 1) % 7;\n    int blendIndex = frame % COLOR_CHANGE_FRAMES;\n    float blend = float(blendIndex) / float(COLOR_CHANGE_FRAMES);\n    return mix(rainbow(colorIndex), rainbow(nextColorIndex), blend);\n}\n\nconst float PI = 3.141592653598793;\n\nvec2 rotate(float a)\n{\n    return vec2(sin(a), cos(a));\n}\n\nvoid spawnSand(int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (fragColor == vec4(0.0, 0.0, 0.0, 1.0))\n    {\n        float centerSpeedup = (sin(float(frame) * 0.001) * 0.5 + 0.5) * 0.02;\n        float centerTime = (float(frame) * (0.001 + centerSpeedup) - PI * 0.5);\n        vec2 spawnCenter = vec2(sin(centerTime) * 0.45 + 0.5, 0.95) * res.xy;\n        \n        if (mouse.z > 0.0 && mouse.y > res.y * 0.9)\n        {\n            spawnCenter.x = mouse.x;\n        }\n\n        float rotateTime = float(frame) * 0.1;\n        const float SPAWN_DISTANCE = 30.0;\n        vec2 spawnPoints[3] = vec2[](spawnCenter + SPAWN_DISTANCE * rotate(rotateTime),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime + PI * (2.0 / 3.0)),\n                                     spawnCenter + SPAWN_DISTANCE * rotate(rotateTime - PI * (2.0 / 3.0)));\n\n        for (int i = 0; i < 3; ++i)\n        {\n            if (length2(spawnPoints[i] - fragCoord) < square(res.x * 0.003))\n            {\n                fragColor = colorByFrame(frame + COLOR_CHANGE_FRAMES * i);\n            }\n        }\n    }\n}\n\nconst vec4 EMPTY = vec4(0.0, 0.0, 0.0, 1.0);\n\nvoid removeSand(sampler2D mipSampler, int frame, vec2 fragCoord, vec3 res, vec4 mouse, inout vec4 fragColor)\n{\n    if (mouse.z > 0.0 && mouse.y < res.y * 0.9)\n    {\n        vec2 removePos = mouse.xy;\n\n        if (length2(removePos - fragCoord) < square(res.x * 0.02))\n        {\n            fragColor = EMPTY;\n        }\n    }\n    \n    vec3 fullTest0 = textureLod(mipSampler, vec2(0.2, 0.6), 3.0).xyz;\n    vec3 fullTest1 = textureLod(mipSampler, vec2(0.4, 0.4), 3.0).xyz;\n    vec3 fullTest2 = textureLod(mipSampler, vec2(0.6, 0.4), 3.0).xyz;\n    vec3 fullTest3 = textureLod(mipSampler, vec2(0.8, 0.6), 3.0).xyz;\n    \n    int deleteInterval = 1000;\n    if (any(greaterThan(fullTest0, vec3(0))) &&\n        any(greaterThan(fullTest1, vec3(0))) &&\n        any(greaterThan(fullTest2, vec3(0))) &&\n        any(greaterThan(fullTest3, vec3(0))))\n    {\n        deleteInterval = 10;\n    }\n    \n    if ((frame % deleteInterval == 0) && fragCoord.y < 1.0)\n    {\n        fragColor = EMPTY;\n    }\n    //fragColor = fullTest0;\n}\n\nvoid evolveByCells(sampler2D sampler, ivec2 coord, ivec2 offset, ivec2 ires, out vec4 fragColor)\n{\n    ivec2 cellCoord = (coord - offset) / 2;\n    ivec2 llCell = cellCoord * 2 + offset;\n    ivec2 lrCell = llCell + ivec2(1, 0);\n    ivec2 ulCell = llCell + ivec2(0, 1);\n    ivec2 urCell = llCell + ivec2(1, 1);\n    \n    if (!all(lessThan(urCell, ires)) || (offset != ivec2(0) && (coord.x == 0 || coord.y == 0)))\n    {\n        fragColor = texelFetch(sampler, coord, 0);\n        return;\n    }\n    \n    vec4 ulValue = texelFetch(sampler, ulCell, 0);\n    vec4 urValue = texelFetch(sampler, urCell, 0);\n    vec4 llValue = texelFetch(sampler, llCell, 0);\n    vec4 lrValue = texelFetch(sampler, lrCell, 0);\n    ulValue.w = urValue.w = llValue.w = lrValue.w = 1.0;\n    \n    bvec4 cell = bvec4(ulValue != EMPTY, urValue != EMPTY, llValue != EMPTY, lrValue != EMPTY);\n    \n    if (cell == bvec4(true,  false,\n                      false, false) ||\n        cell == bvec4(true,  false,\n                      false, true)||\n        cell == bvec4(true,  true,\n                      false, true))\n    {\n        // left side falls\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, false) ||\n             cell == bvec4(false, true,\n                           true, false) ||\n             cell == bvec4(true, true,\n                           true, false))\n    {\n        // right side falls\n        lrValue = urValue;\n        urValue = EMPTY;\n    }\n    else if (cell == bvec4(true, true,\n                           false, false))\n    {\n        // both sides fall\n        lrValue = urValue;\n        urValue = EMPTY;\n        llValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(true, false,\n                           true, false))\n    {\n        // left side collapses\n        lrValue = ulValue;\n        ulValue = EMPTY;\n    }\n    else if (cell == bvec4(false, true,\n                           false, true))\n    {\n        // right side collapses\n        llValue = urValue;\n        urValue = EMPTY;\n    }\n\n    if (coord == llCell)\n    {\n        fragColor = llValue;\n    }\n    else if (coord == lrCell)\n    {\n        fragColor = lrValue;\n    }\n    else if (coord == ulCell)\n    {\n        fragColor = ulValue;\n    }\n    else if (coord == urCell)\n    {\n        fragColor = urValue;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(0), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame == 0 || keyDown(32))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    else\n    {\n        ivec2 coord = ivec2(fragCoord);\n        \n        evolveByCells(iChannel0, coord, ivec2(1), ivec2(iResolution.xy), fragColor);\n        spawnSand(iFrame, fragCoord, iResolution, iMouse, fragColor);\n        removeSand(iChannel1, iFrame, fragCoord, iResolution, iMouse, fragColor);\n    }\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVfWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[734, 734, 791, 791, 997]], "test": "untested"}
{"id": "fsVBDy", "name": "Chromastort", "author": "LudoCrypt", "description": "Distortion blends two images together based on color. Moving your mouse left and right controls how much it mixes. Moving your mouse up and down controls how much it distorts. Go ahead and use this wherever you want!", "tags": ["mix", "distortion", "distort"], "likes": 0, "viewed": 202, "published": 3, "date": "1658813731", "time_retrieved": "2024-07-30T16:38:54.014761", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 mouse = (iMouse.z == 0.0 ? iResolution.xy / 2.0 : iMouse.xy) / iResolution.xy;\n    float dispFactor = mouse.x;\n    float intensity = mouse.y;\n    fragColor = mix(texture(iChannel0, vec2(uv.x, uv.y + dispFactor * (texture(iChannel1, uv).r * intensity))), texture(iChannel1, vec2(uv.x, uv.y + (1.0 - dispFactor) * (texture(iChannel0, uv).r * intensity))), dispFactor);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVBDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 477]], "test": "untested"}
{"id": "7syfDy", "name": "IBL Anisotropic Analysis", "author": "BeardThings", "description": "Exploring the curves of our RGB values as our reflection becomes more anisotropic", "tags": ["curves", "ibl", "analysis"], "likes": 0, "viewed": 34, "published": 3, "date": "1658798764", "time_retrieved": "2024-07-30T16:38:54.851524", "image_code": "//#define VIEW_SDF\n//#define VIEW_THETA\n#define VIEW_PHI\n//#define VIEW_ISOTROPIC_VALUE\n#define VIEW_FOURIER\n#define FOURIER_N 4\n//#define VIEW_COEFS\n#define LERP_COEF\n\n// Note: Can we find a function to minimize the error on which\n//       point we should pick here?\n#define PHI_P 0.8\n\n// What point along our function do we start to see the energy decay?\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat SDF(vec3 p, out vec3 c)\n{\n    vec3 d = normalize(p);\n    \n    float theta = acos(d.y);\n    float phi = atan(d.z,d.x);\n    phi = phi < 0.0 ? 2.0*Pi + phi : phi;\n    vec4 v = texture(iChannel0,vec2(phi/(2.0*Pi), theta/Pi*2.0));\n    float r = v.r/v.a;\n\n    if(theta >= Pi*0.5)\n    {\n        r = 0.0;\n    }\n\n    c = vec3(1.0,1.0,1.0)*r;\n    return sphere(p, r);\n}\n\nvec3 Norm(vec3 p)\n{\n    const float cEps = 0.01;\n \n    vec3 c;\n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0),c\t) - SDF(p - vec3(cEps, 0, 0),c),\n\t\t\tSDF(p + vec3(0, cEps, 0),c\t) - SDF(p - vec3(0, cEps, 0),c),\n\t\t\tSDF(p + vec3(0, 0, cEps),c\t) - SDF(p - vec3(0, 0, cEps),c)\n\t\t)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n#ifdef VIEW_PHI\n    vec4 li = texture(iChannel0, vec2(fragCoord.x/iResolution.x,iMouse.x/iResolution.x));\n#elif defined(VIEW_THETA)\n    vec4 li = texture(iChannel0, vec2(iMouse.x/iResolution.x,fragCoord.x/iResolution.x));\n#endif\n    li.rgb *= 1.0/li.a;\n    \n    float lr = clamp(1.0-abs(li.r - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    float lg = clamp(1.0-abs(li.g - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    float lb = clamp(1.0-abs(li.b - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    \n// View PHI as basis\n#ifdef VIEW_FOURIER\n    float v = 0.0;\n    for(int i = 0; i < FOURIER_N; i++)\n    {\n#ifdef LERP_COEF\n    #ifdef VIEW_PHI\n        int phi = int(iResolution.y*PHI_P);\n    #else\n        int phi = int(PHI_P * iResolution.y);\n    #endif \n\n        vec4 coef0 = texelFetch(iChannel2, ivec2(i, 0), 0);\n        vec4 coef1 = texelFetch(iChannel2, ivec2(i, phi), 0);\n        \n    #ifdef VIEW_PHI\n        float t = iMouse.x/iResolution.x/PHI_P;\n    #else\n        float t = fragCoord.x / iResolution.x/PHI_P;\n    #endif\n        \n        vec4 coef = mix(coef0, coef1, smoothstep(0.0, 1.0, t*t));\n#else // LERP_COEF\n\n    #ifdef VIEW_PHI\n        int y = int(iMouse.x/iResolution.x*iResolution.y)+1;\n    #elif defined(VIEW_THETA)\n        int y = int(fragCoord.x/iResolution.x*iResolution.y)+1;\n    #endif // VIEW_PHI\n        vec4 coef = texelFetch(iChannel2, ivec2(i, y), 0);\n#endif // LERP_COEF\n\n#ifdef VIEW_PHI\n        float x = fragCoord.x/iResolution.x;\n#elif defined(VIEW_THETA)\n        float x = iMouse.x / iResolution.x;\n#endif\n\n        v += dot(coef, basis(x, float(i*2)));\n    }\n    \n#if defined(LERP_COEF)\n\n#if defined(VIEW_THETA)\n    float p = length(fragCoord.xy-vec2(PHI_P*iResolution.x, v*iResolution.y));\n    p = max((5.0-p),0.0);\n    lr += p;\n    lg += p;\n    lb += p;\n#elif defined(VIEW_PHI)\n    lr += int(fragCoord.x) == int(PHI_P * iResolution.x) ? 1.0 : 0.0;\n    lg += int(fragCoord.x) == int(PHI_P * iResolution.x) ? 1.0 : 0.0;\n    lb += int(fragCoord.x) == int(PHI_P * iResolution.x) ? 1.0 : 0.0;\n#endif\n    \n#endif // LERP_COEF\n    \n    lr += clamp(1.0-abs(v - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    lg += clamp(1.0-abs(v - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    lb += 0.0;\n#endif // VIEW_FOURIER\n    \n#ifdef VIEW_ISOTROPIC_VALUE\n    vec4 ti = texture(iChannel0, vec2(fragCoord.x/iResolution.x,0.0));\n    ti.rgb /= ti.a;\n    lr += clamp(1.0-abs(ti.r - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    lg += clamp(1.0-abs(ti.g - uv.y)*(iResolution.y/3.0),0.0,1.0);\n    lb += clamp(1.0-abs(ti.b - uv.y)*(iResolution.y/3.0),0.0,1.0);\n#endif // VIEW_ISOTROPIC_VALUE\n    \n    fragColor.rgb = vec3(lr,lg,lb);\n    \n#ifndef VIEW_SDF\n    fragColor.rgb += li.rgb*0.5;\n#else\n    vec4 final = vec4(0.0,0.0,0.0,0.0);\n    {\n        vec2 screenSpace = uv * 2.0 - 1.0;\n\n        float time = iTime * 0.25;\n        vec3 o = vec3(sin(time), 0.0, cos(time)) * 2.0;\n\n        vec3 f = normalize(vec3(-o.x,0.0,-o.z));\n        vec3 u = vec3(0,1,0);\n        vec3 r = normalize(cross(f, u));\n\n        vec3 direction = normalize(f * 2.0 + \n                             r * screenSpace.x * iResolution.x / iResolution.y +\n                             u * screenSpace.y);\n        final = vec4(lr,lg,lb,0.0) + pow(texture(iChannel1, direction), vec4(SHARPNESS));\n    \n        float d = 0.0;\n        for(float i = 0.; i < 64.; ++i)\n        {\n            vec3 pos = o + direction * d;\n\n            vec3 c;\n            float sdf = SDF(pos,c);\n            d += sdf*0.4;\n\n            const float EPSILON = 0.01;\n            if(sdf < EPSILON)\n            {   \n                final.rgb = vec3(1.0,1.0,1.0)\n                    *(abs(dot(Norm(pos),vec3(0.707,0.0,0.707)))*0.8+0.2);\n                break;\n            }\n        }\n    }\n    fragColor.rgb += final.rgb;\n#endif // VIEW_SDF\n\n#ifdef VIEW_COEFS\n    fragColor.rgb = abs(texelFetch(iChannel2, ivec2(1.0,int(fragCoord.y)),0).rgb)*40.0;\n#endif // VIEW_COEFS\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ITERATIONS_PER_FRAME 128.0\n#define ROUGHNESS 0.05\n\nfloat rcp(float a) { return 1.0 / a; }\n\n// http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\nconst float golden = (1.0 + sqrt(5.0))/2.0;\nvec2 fibonacci_2d(float i, float N)\n{\n    return vec2(fract(i/golden),i/N);\n}\n\nvec3 hemisphere_ggx_h(float r1, float r2, float a)\n{\n\tfloat cosTheta = sqrt((1.0-r1)*rcp(r1*(a*a-1.0)+1.0));\n\tfloat sinTheta = sqrt(1.0 - cosTheta*cosTheta);\n\tfloat phi = 2.0 * Pi * r2;\n\treturn vec3( sinTheta*cos(phi), sinTheta*sin(phi), cosTheta );\n}\n\nfloat ggx_pdf(float roughness, float hdotn, float vdoth)\n{\n\tfloat t = hdotn*hdotn*roughness*roughness - (hdotn*hdotn - 1.0);\n\tfloat D = (roughness*roughness)/(t*t)*rcp(Pi);\n\treturn D*hdotn*rcp(4.0*abs(vdoth));\n}\n\nmat3x3 basis_from_normal(vec3 n)\n{\n\t// Frisvad ONB from https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf\n\t// revised from Pixar https://graphics.pixar.com/library/OrthonormalB/paper.pdf#page=2&zoom=auto,-233,561\n\tfloat s = n.z>=0.0?1.0:-1.0;\n\tfloat a = -rcp(s + n.z);\n\tfloat b = n.x*n.y*a;\n\tvec3 i = vec3( 1.0 + s * n.x*n.x*a, s * b, -s * n.x );\n\tvec3 j = vec3(b, s + n.y*n.y*a, -n.y);\n\n\treturn mat3x3(i, j, n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prev = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(prev.a >= MAX_ITERATIONS)\n    {\n        fragColor = prev;\n        return;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    float phi = uv.x * 2.0 * Pi;\n    float theta = uv.y * Pi * 0.5;\n    \n    vec3 acc = prev.rgb;\n    \n    vec3 r = normalize(vec3(0.0, 0.8, 0.707));\n    mat3x3 rb = basis_from_normal(r);\n    vec3 n = rb*vec3(cos(phi)*sin(theta),sin(phi)*sin(theta),cos(theta));\n    vec3 v = normalize(reflect(-r, n));\n    \n    mat3x3 b = basis_from_normal(n);\n    for(float i = prev.a; i < prev.a+ITERATIONS_PER_FRAME; i+=1.0)\n    {\n        const float roughness = ROUGHNESS;\n        vec2 r = fibonacci_2d(i, MAX_ITERATIONS);\n        vec3 h = b*hemisphere_ggx_h(r.x, r.y, roughness);\n        \n        vec3 l = reflect(-v,h);\n        if(dot(n,l)>0.0)\n        {\n            vec3 s = pow(srgb_to_linear(texture(iChannel0, l.xzy).rgb),vec3(SHARPNESS));\n            acc += s;\n        }\n    }\n    fragColor = vec4(acc, prev.a + ITERATIONS_PER_FRAME);\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SHARPNESS 5.0\n#define MAX_ITERATIONS (256.0*64.0)\n\nconst float Pi = 3.14159;\n\nvec3 srgb_to_linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}\n\nvec4 basis(float x, float t)\n{\n    float uv = x * 2.0 * Pi;\n    return vec4(\n        cos((t+0.0)*uv),\n        sin((t+0.0)*uv),\n        cos((t+1.0)*uv),\n        sin((t+1.0)*uv));\n}", "buffer_b_code": "//#define QUANTIZE pow(2.0,7.0)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 p = ivec2(fragCoord);\n    float iter = texelFetch(iChannel0, ivec2(0, 0), 0).a;\n    vec4 prev = texelFetch(iChannel1, ivec2(fragCoord), 0);\n    if(iter >= MAX_ITERATIONS && all(equal(prev, vec4(0.0))))\n    {\n        vec4 b = vec4(0.0);\n        for(int x = 0; x < int(iResolution.x); x++)\n        {\n            vec4 rgb = texelFetch(iChannel0, ivec2(x, p.y), 0);\n            rgb *= 1.0/rgb.a;\n            b += rgb.r * basis(float(x)/iResolution.x, float(p.x*2))*2.0*Pi/iResolution.x/Pi;\n        }\n\n        if(p.x == 0)\n        {\n            b.rg /= 2.0;\n        }\n        \n#ifdef QUANTIZE\n        b = clamp(round(b * QUANTIZE)/QUANTIZE, -1.0, 1.0);\n#endif\n        fragColor = b;\n    }\n    else\n    {\n        fragColor = prev;\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 389, 389, 417], [419, 419, 450, 450, 784], [786, 786, 805, 805, 1073], [1075, 1075, 1132, 1132, 5050]], "test": "untested"}
{"id": "7dGfDy", "name": "Infinite roguelike dungeon", "author": "jarble", "description": "An infinite roguelike dungeon map.", "tags": ["maze", "dungeon", "labyrinth", "roguelike"], "likes": 8, "viewed": 337, "published": 3, "date": "1658788236", "time_retrieved": "2024-07-30T16:38:55.780041", "image_code": "float threshold = .5;\nint iters = 4;\n\n#define noise2D(p) float((p.x * 68657387u ^ p.y * 361524851u + p.x) % 890129u) / 890128.\n\nbool labyrinth(uvec2 U,float n2){\n    bvec2 b = bvec2(U & 1u);\n    return (b.x && b.y || b.x != b.y  && n2 < threshold);\n}\n\nvoid mainImage(out vec4 O, vec2 U) {\n    uvec2 I = uvec2( U/8.+ iTime*8.);\n    O = vec4(1);\n    bool b = false,l1=false;\n    float n = 0.;\n    for(int i = 0; i++ < iters;I =\n    I*2u/3u\n    //I*13u/17u\n    ){\n        //I += uvec2(i%2);\n        //I += uint(i/2);\n        I += 1u; //another interesting pattern\n        //I += uint(b);\n        n =\n            noise2D(I)\n            //(noise2D(I)+n)/2.\n            //more dungeon patterns\n            //noise2D((I/3u)+(I/2u))\n            //noise2D((I/uint(1+i)))\n        ;\n        l1=labyrinth(I,n),\n        b =\n            !b || l1\n            //!b || labyrinth(I,n)||labyrinth(I/3u,n)\n            //!b || l1 || n > (8.*abs(.5-fract(iTime/16.))-.5)\n            //!(b || l1)\n            //!b && l1\n        ;\n        O -= float(n > .125)/float(iters)/4.;\n        \n        //some random-looking distortion (using prime numbers)\n        //I += I.yx/(31u)-I.yx/(29u)+I.yx/(23u);\n    }\n    if (b) O = 1.-O;\n}", "image_inputs": [], "sound_code": "\n#define fmod(x,y) floor(max(mod(floor(-(x))*3.,y),mod(floor(x)*4.,y)))\n\nvec2 mainSound1(int samp, float time){\n  \n  float s1 =\n      4.,\n\n  s2 = 6.,\n\n  m1 =\n      fmod(time/s1+s1,s2)\n      //fmod(time/s1+float(samp)+s1,s2)\n  ,\n  t=\n      time\n  ,\n  m4 =\n      fmod(t+s1,s2)\n  ,\n  m3 =\n      fmod((t+m4)*s1/(m1+.5),s2);\n\n  /*\n  for(int i = 0; i < 3; i++){\n      t *= pow(2.,fmod(t/2.,2.)-1.);\n      m3 = fmod(t*s1-m3,s2);\n  }\n  */\n\n  t *=\n      s1*s1/pow(2.,fmod(t/s1,3.)-1.)\n  ;\n\n  float m2 =\n      1. + fmod(t/s1,s1);\n  ;\n  \n  float a=\n      64./4.*pow((1.-sqrt(fract(t/s1)))/4.,2.)\n  ;\n  \n  \n  float nb = 4.*time*pow(2.,(m3+m2)/5.+6.5)/pow(2.,fmod(t/s1,3.)-1.);\n\n  return\n      (abs(.5-vec2(fract(nb*.998),fract(nb*2.))))*a\n  ;\n\n}\n\nvec2 mainSound(int a,float b){\n    return\n        mainSound1(a,b)\n        //mainSound1(a,b)*abs(1.-mainSound1(a,-b*2.))\n        //vec2(mainSound1(a,b/2.).x,mainSound1(a,b).y/8.)\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[128, 128, 161, 161, 250], [252, 252, 288, 288, 1202]], "test": "untested"}
{"id": "7syfWG", "name": "Tesla Valve w/ Bypass", "author": "fenix", "description": "Suggestions from users ttg (add bypass) and elenzil (particle color). The bypass worked a treat! The colors look cool but the particles mix so much that the effect is, meh.\n*u/d arrows for debug render modes*\n*l/r arrows to reset sim*\n*mouse to interact*", "tags": ["2d", "voronoi", "simulation", "fluid", "particles", "liquid", "sph"], "likes": 12, "viewed": 308, "published": 3, "date": "1658786426", "time_retrieved": "2024-07-30T16:38:56.735487", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Same basic engine as \"Self supporting SPH\" https://www.shadertoy.com/view/7ddfRB\n//  Tesla valves were invented in 1920 by Nikola Tesla, but had little practical\n//  use until researchers recently used it to create a microfluidic pump.\n//\n//      https://en.wikipedia.org/wiki/Tesla_valve\n//\n//  I'm not sure why (yet) but the fluid is a lot more active at lower resolutions.\n//  The valve \"works\" though at multiple resolutions, letting relatively more fluid\n//  through from right to left than left to right. The left/right cycle is 3600 frames\n//  long and is controlled by ANIMATE_FRAMES.\n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles into a density texture (used for rendering only)\n//  Buffer D blurs the density (used for rendering only)\n// ---------------------------------------------------------------------------------------\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvec2 texGrad(sampler2D sampler, vec2 fragCoord)\n{\n    float dx = texture(sampler, (fragCoord + vec2(1.0, 0.0))/iResolution.xy).w\n             - texture(sampler, (fragCoord - vec2(1.0, 0.0))/iResolution.xy).w;\n    float dy = texture(sampler, (fragCoord + vec2(0.0, 1.0))/iResolution.xy).w\n             - texture(sampler, (fragCoord - vec2(0.0, 1.0))/iResolution.xy).w;\n    return vec2(dx, dy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    float wallSd = distanceFromWalls(p, iResolution, frames);\n    \n    vec4 background = textureLod(iChannel2, fragCoord/iResolution.xy, 5.0);\n    bool debugRender = mod(state.w, 2.0) > 0.1;\n    bool debugColor = state.w > 1.9;\n    \n    float lDensity = texture(iChannel0, fragCoord/iResolution.xy).w;\n    if (debugRender) lDensity = 0.0;\n    vec2 lNorm2 = texGrad(iChannel0, fragCoord);\n    vec3 lNorm = vec3(-lNorm2.x, 1.0, -lNorm2.y);\n    lNorm = normalize(lNorm);\n\n    vec4 waterColor = vec4(1.0, 0.0, 0.0, 0.0);\n    if (debugColor) waterColor = texture(iChannel0, fragCoord/iResolution.xy);\n    \n    vec4 water = texture(iChannel2, fragCoord/iResolution.xy + lNorm2 * 0.2) * waterColor;\n    float waterSpec = computeSpecular(0.8, 20.0, lNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.7+p.x * 0.3, 0.5 - p.y * 0.3));\n    water.xyz += vec3(waterSpec) * 10.0;\n\n    vec4 scene = mix(background, water, smoothstep(0.5, 1.0, lDensity));\n\n    // Handle animated steel UVs for moving (particle compressing) walls\n    float sideShift = 0.0;\n    if (fragCoord.x > iResolution.x * 0.875)\n    {\n        if (frames > ANIMATE_FRAMES * 0.475)\n        {\n            frames = ANIMATE_FRAMES * 0.475;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.6)\n        {\n            sideShift = -sideShift;\n        }\n    }\n    else if (fragCoord.x < iResolution.x * 0.125)\n    {\n        if (frames > ANIMATE_FRAMES * 0.975)\n        {\n            frames = ANIMATE_FRAMES * 0.975;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.5)\n        {\n            sideShift = -sideShift;\n        }\n    }\n\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y + sideShift) * 0.004);\n    vec3 steelNorm = texture(iChannel1, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p, iResolution, frames) * (1.0 - smoothstep(0.02, 0.05, -wallSd));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(scene, steel, smoothstep(0.02, 0.03, -wallSd));\n    \n    if (debugRender) fragColor.xyz += texture(iChannel0, fragCoord/iResolution.xy).xyz;\n\n    fragColor.w = 1.0;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 5000; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float ANIMATE_FRAMES = 3600.0;\nconst float COLOR_CYCLE_FRAMES = 1800.0;\n\nconst float PI = 3.141592653598793;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox(in vec2 p, in vec2 boxCenter, in vec2 boxSize)\n{\n    p -= boxCenter;\n    vec2 d = abs(p)-boxSize;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat sdArc( in vec2 p, in vec2 sc, in float ra, float rb )\n{\n    // sc is the sin/cos of the arc's aperture\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nconst float h1ang = 1.8;\nconst mat2 h1rot = mat2(cos(h1ang), -sin(h1ang), sin(h1ang), cos(h1ang));\nconst float h2ang = PI - h1ang;\nconst mat2 h2rot = mat2(cos(h2ang), -sin(h2ang), sin(h2ang), cos(h2ang));\nconst float lang = 1.7;\nconst mat2 lrot = mat2(cos(lang), -sin(lang), sin(lang), cos(lang));\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    time = mod(time, ANIMATE_FRAMES);\n    float rightTime = min(ANIMATE_FRAMES * 0.45, time);\n    float leftTime = min(ANIMATE_FRAMES * 0.45, time - ANIMATE_FRAMES * 0.5);\n    if (leftTime > 0.0) rightTime = 0.0;\n    const float COMPRESS_RATE = 1.0 / (0.55 * ANIMATE_FRAMES);\n    float minDist = 1e30;\n    point.y *= resolution.y / resolution.x;\n    point *= 2.0;\n    minDist = min(minDist, point.x + 1.9);\n    minDist = min(minDist, 1.9 - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    minDist = min(minDist, sdBox(point, vec2(0.0, 0.0), vec2(1.35, 5.00)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, 2.0 - rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, -2.0 + rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, 2.0 - leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, -2.0 + leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(-0.67, 0.04)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(-0.07, -0.27)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(0.53, 0.04)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(1.13, -0.27)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.3, -0.09)), vec2(0.0, 0.0), vec2(0.04, 0.4)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.4, -0.11)), vec2(0.0, 0.0), vec2(0.04, 0.3)));\n    minDist = max(minDist, -sdArc(point + vec2(0.0, 3.65), vec2(sin(0.35), cos(0.35)), 4.0, 0.03));\n    if (leftTime > 0.0)\n    {\n        minDist = min(minDist, sdBox(point, vec2(1.66, 0.0), vec2(0.4, 0.05)));\n    }\n    else\n    {\n        minDist = min(minDist, sdBox(point, vec2(-1.66, 0.0), vec2(0.4, 0.05)));\n    }\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define COLOR 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    \n    float color;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, COLOR), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.color = particleData5.x;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case COLOR:  \n        return vec4(p.color, 0.0, 0.0, 0.0);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only MAX_PARTICLES * NUM_PARTICLE_DATA_TYPES pixels are actually used.\n\nconst float PARTICLE_REPEL = 0.00005;\nconst float IDEAL_DENSITY = 20.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType > LR_NEIGHBORS)\n    {\n        if (iFrame == 0 || frames == 0.0)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * vec2(0.25, 1.8) + vec2(0.7, -0.9);\n            data.vel = vec2(0);\n            data.color = 0.0;\n        }\n        else if (frames == ANIMATE_FRAMES * 0.5)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * vec2(0.25, 1.8) + vec2(-0.95, -0.9);\n            data.vel = vec2(0);\n            data.color = 0.0;\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.3 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n           \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            ++numSolverParticles;\n\n            // Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos / dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist / PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    // Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    // Integrate pos\n                    particles[i].pos += particles[i].vel / float(NUM_ITERATIONS);\n                }\n            }\n            \n            // Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n                   \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, frames);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, frames - 1.0);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, frames);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n            }\n            \n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n            \n            float colorX = data.pos.x;\n            if (state.x > ANIMATE_FRAMES * 0.5) colorX = -colorX;\n            if (colorX > 0.67)\n            {\n                data.color = mod(state.x / COLOR_CYCLE_FRAMES, 0.5) * 2.0;\n            }\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 1;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int p = int(h*float(MAX_PARTICLES));\n            vec2 randXY = fxGetParticleData(p, POS_VEL).xy;\n            insertion_sort(bestIds, bestDists, p, length2(randXY - data.pos));\n        }\n\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    //if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 old = fxGetClosest(ivec2(fragCoord));\n    ivec4 new = ivec4(-1);\n    \n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    insertion_sort(new, dis, old.x, distance2Particle(old.x, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.y, distance2Particle(old.y, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.z, distance2Particle(old.z, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.w, distance2Particle(old.w, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Render particles and manage persistent state\n\nconst float PARTICLE_RENDER_SIZE = 0.04;\nconst float PARTICLE_DEBUG_RENDER_SIZE = 0.01;\n\nvec3 colorByValue(float value)\n{    \n    if (value > 2.0 / 3.0)\n    {\n        return mix(vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), value * 3.0 - 2.0);\n    }\n    else if (value > 1.0 / 3.0)\n    {\n        return mix(vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), value * 3.0 - 1.0);\n    }\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), value * 3.0);\n}\n\nvoid renderParticle(in fxParticle p, in float debugSize, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest);\n\n    fragColor.w += max(0.0, PARTICLE_RENDER_SIZE - sqrt(dist)) / PARTICLE_RENDER_SIZE;\n    fragColor.xyz += colorByValue(p.color) * max(0.0, debugSize - sqrt(dist)) / debugSize;\n    \n    // Render neighbor lines\n    if (debugSize <= PARTICLE_DEBUG_RENDER_SIZE)\n    {\n        for(int i = 0; i < 4; i++){\n            ivec4 neighbors = p.neighbors[i];\n            for (int j = 0; j < 4; ++j)\n            {\n                int cid = neighbors[j];\n                if(cid==-1 || cid >= MAX_PARTICLES || cid == 0) continue;\n\n                vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n                if (length(otherPos - p.pos) < 0.1)\n                {\n                    float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                    fragColor.xyz += 0.3* max(0.0, PARTICLE_DEBUG_RENDER_SIZE * 0.4 - sqrt(distToLin)) / (PARTICLE_DEBUG_RENDER_SIZE);\n                }\n            }\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        vec4 state = texture(iChannel2, vec2(0));\n\n        if (iFrame == 0 || keyDown(39) || iResolution.xy != state.yz)\n        {\n            state = vec4(0.0, iResolution.x, iResolution.y, 0.0);\n        }\n        else if (keyDown(37))\n        {\n            state = vec4(ANIMATE_FRAMES * 0.5, iResolution.x, iResolution.y, 0.0);\n        }\n        else\n        {\n            state.x += 1.0;\n            if (state.x > ANIMATE_FRAMES || keyDown(32))\n            {\n                state.x = 0.0;\n            }\n        }\n        state.w = 0.0;\n        if (keyDown(38))\n        {\n            state.w += 1.0;\n        }\n        else if (keyDown(40))\n        {\n            state.w += 2.0;\n        }\n        fragColor = state;\n        return;\n    }\n    \n    vec4 state = texture(iChannel3, vec2(0));\n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n    \n        float debugSize = PARTICLE_DEBUG_RENDER_SIZE;\n        if (!keyDown(38)) debugSize *= 5.0;\n        renderParticle(particle, debugSize, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 7; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .01; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).w;                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = textureLod(iChannel0, u / iResolution.xy, 0.0);\n    O.w = convol2D(U); return;\n  //  O = convol1D(U,vec2(1,0));\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syfWG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1184, 1184, 1347, 1347, 1552], [1554, 1554, 1603, 1603, 1948], [1950, 1950, 2003, 2003, 4538]], "test": "untested"}
{"id": "7sGBWy", "name": "casita otra", "author": "jorge2017a2", "description": "casita otra", "tags": ["casitaotra"], "likes": 14, "viewed": 196, "published": 3, "date": "1658782447", "time_retrieved": "2024-07-30T16:38:57.605163", "image_code": "///-------image\n//por jorge2017a2\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n#define pi 3.14159265359\n///------casita otra---25-jul-2022\nfloat opRep1D( float p,float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he )\n{\n    vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n    p.x = abs(p.x);\n    vec2 ca = vec2(p.x-min(p.x,(p.y<0.0)?r1:r2), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat sdParallelogram( in vec2 p, float wi, float he, float sk )\n{\n    vec2 e = vec2(sk,he);\n    p = (p.y<0.0)?-p:p;\n    vec2  w = p - e; w.x -= clamp(w.x,-wi,wi);\n    vec2  d = vec2(dot(w,w), -w.y);\n    float s = p.x*e.y - p.y*e.x;\n    p = (s<0.0)?-p:p;\n    vec2  v = p - vec2(wi,0); v -= e*clamp(dot(v,e)/dot(e,e),-1.0,1.0);\n    d = min( d, vec2(dot(v,v), wi*he-abs(s)));\n    return sqrt(d.x)*sign(-d.y);\n}\n\n\n// Basic Geometry Functions.\n//https://www.shadertoy.com/view/7dGfWW\nfloat sdCircle(in vec2 p, float radius, vec2 pos, float prec)\n{\n      return smoothstep(0.0,prec,radius - length(pos-p));\n}\n\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{  p = vec2( dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{   const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(100.0) );\n}\n\nfloat fbm(vec2 uv)\n{   float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 casa3Color(vec2 p, vec3 col, int frente, int puerta, int techo )\n{   vec3 colF=getColor(frente);\n    vec3 colP=getColor(puerta);\n    vec3 colT=getColor(techo);\n    \n    float d1= sdBox(p, vec2(3.5,2.5) );\n    float d2=sdTriangleIsosceles(vec2(p.x,-p.y)-vec2(4.5,-5.3), vec2(1.2,3.2) );\n    float d3=sdBox(p-vec2(-1.5,-0.4), vec2(0.8,0.8) ); //ventana\n    float d4=sdBox(p-vec2(1.5,-1.0), vec2(0.8,1.5) ); //puerta\n    float d5= sdParallelogram(p-vec2(0.0,3.6), 4.0, 1.9, 0.5 ); //techo\n    float d6= sdParallelogram(p.yx-vec2(0.6,4.3), 2.5, 0.795, 0.5 ); //lateral\n    \n    float d7=sdBox(p-vec2(1.7,3.5), vec2(0.8,0.8));\n    float d8=sdBox(p-vec2(-1.7,3.5), vec2(0.8,0.8));\n    float d7a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2(-0.8,2.8), vec2(1.0,1.5) );\n    float d8a=sdTriangleIsosceles(vec2(p.x,p.y)-vec2( 2.5,2.8), vec2(1.0,1.5) );\n    \n    col= DrawFigBorde(colF,col, d1 );// frente\n    col= DrawFigBorde(vec3(0.1),col, d6 );  //lateral1\n    col= DrawFigBorde(vec3(0.0),col, d2 ); //lateral2\n    col= DrawFigBorde(vec3(0.0,0.5,0.5),col, d3 ); //ventana\n    col= DrawFigBorde(colP,col, d4 ); //puerta\n    col= DrawFigBorde(colT,col, d5 ); //techo\n    col= DrawFigBorde(vec3(0.0),col, d7a ); //sombra\n    col= DrawFigBorde(vec3(0.0),col, d8a ); //sombra 2\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d7 ); //ventana fijo\n    col= DrawFigBorde(vec3(0.0,0.0,1.0),col, d8 ); //ventana 2 fijo\n    return col;\n}\n\nvec3 HacerMonte(vec2 uv, vec3 colOut)\n{   float t=0.0;\n    uv.y-=8.0;\n     uv.x+=t*5.0;\n    float n = fbm(uv*0.05)*5.0;\n    float nc = noise2d(uv*vec2(0.5,10.))*0.05;\n    float d = uv.y+n-3.;\n    colOut= DrawFigBorde(vec3(0.25,0.50,0.0)+nc,colOut,d );\n    return colOut;\n}\n\n\nvec3 HacerAgua(vec2 uv, vec3 colOut)\n{   float t=iTime;\n     uv.x+=t*12.0;\n     float mx=5.0*sin(uv.x+t*5.0);\n     float my=10.0*cos(uv.y+t*5.0+mx*0.5);\n    vec2 v2=vec2(mx, my);\n    float nc2 = noise2d(uv*vec2(0.5,10.))*0.05 *length(v2);\n    float d2 = uv.y+sin(nc2*0.5)+3.5;\n    colOut= DrawFigBorde(vec3(0.15,0.2,0.9)+nc2,colOut,d2 );\n    return colOut;\n}\n\nvec3 pastoyCielo(vec2 p, vec3 colOut)\n{   float h=p.y-4.0; //piso\n    float sky=4.0-p.y; //cielo\n    \n    float noise = texture(iChannel0, vec2(p.x, p.y + 0.8)*0.25).r*1.5;\n    float noisesky = texture(iChannel0,vec2(p.x+iTime, p.y + 0.8)*0.05).r*1.5;\n    vec3 colbg=vec3(0.2,1.0,0.2)*clamp(noise,0.0,1.0);\n    vec3  colsky=vec3(0.45,0.7,1.0)-p.y*0.03;\n    vec3 colbgsky=colsky*noisesky;\n    \n    colOut= DrawFigBorde(colbgsky, colOut, sky);\n    colOut= HacerMonte(p,colOut);\n    colOut= DrawFigBorde(colbg, colOut, h);\n    colOut=HacerAgua(p,colOut);\n    return colOut;\n}\n\n//https://www.shadertoy.com/view/7dGfWW\nvec3 luna2(vec2 p, vec3 colOut)\n{    float FD1 = sdCircle(p,2.50,vec2(-2.70,1.0),0.01);\n     float DS1 = sdCircle(p,2.76,vec2(-3.0,1.0),0.5);\n     float Croissant1 = FD1 - DS1;\n     colOut += clamp(Croissant1,0.0,1.0);    \n    return colOut;\n}\n\n//https://www.shadertoy.com/view/7dGfWW\nvec3 luna(vec2 p, vec3 colOut)\n{ float d1= sdCircle(p, 3.0 );\n    float d2= sdCircle(p-vec2(-0.6,-0.3), 3.0 );\n    float dif1= differenceSDF(d1, d2);\n    float Croissant1=d1-d2;\n    float dc=clamp(Croissant1,0.0,1.0);\n      colOut= DrawFigBorde(vec3(0.5,0.2,0.8), colOut, dif1);\n    return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.5);\n    float esc=25.0;\n    uv*=esc;\n    uv.x+=iTime*5.0;\n    vec2 uv0=uv;\n    \n    vec3 col=vec3(1.0);\n    col=pastoyCielo(uv,col);\n    float cCol =floor( mod(floor(uv.x/(esc)),3.0)); //Current column of uv\n    uv.x= opRep1D( uv.x-5.0,12.5);\n    vec3 col2;\n    \n    \n    if(mod(cCol, 3.0) == 0.0)\n        col=casa3Color(uv, col, 1, 2, 2 );\n    \n    if(mod(cCol, 3.0) == 1.0)\n        col=casa3Color(uv, col, 3, 4, 5 );\n           \n    if(mod(cCol, 3.0) == 2.0)\n        col=casa3Color(uv, col, 6, 7, 8 );\n       \n    uv=uv0;\n    uv.x = opRep1D(uv.x, 85.0 );\n    col= luna(uv*0.45-vec2(1.0,12.0), col);\n    col= luna2(uv*0.25-vec2(-1.0,5.0), col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[340, 375, 410, 410, 455], [461, 461, 508, 508, 535], [536, 536, 579, 579, 606], [607, 607, 655, 655, 683], [686, 686, 748, 748, 878], [882, 882, 919, 919, 993], [995, 995, 1030, 1030, 1053], [1055, 1055, 1107, 1107, 1223], [1226, 1226, 1251, 1251, 1270], [1271, 1271, 1296, 1296, 1315], [1316, 1316, 1352, 1352, 1380], [1383, 1383, 1448, 1448, 1758], [1760, 1760, 1811, 1811, 2119], [2121, 2121, 2187, 2187, 2529], [2532, 2601, 2664, 2664, 2724], [2727, 2876, 2897, 2897, 3014], [3016, 3016, 3044, 3044, 3526], [3528, 3528, 3548, 3548, 3808], [3810, 3810, 3881, 3881, 5226], [5228, 5228, 5267, 5267, 5500], [5503, 5503, 5541, 5541, 5861], [5863, 5863, 5902, 5902, 6435], [6437, 6477, 6510, 6510, 6720], [6722, 6762, 6794, 6794, 7061], [7063, 7063, 7120, 7120, 7953]], "test": "untested"}
{"id": "NdGfDy", "name": "Pastel Cake Smoothie (Spiral)", "author": "cutesthypnotist", "description": "free aa", "tags": ["spiral", "aa", "pastel"], "likes": 7, "viewed": 635, "published": 3, "date": "1658766010", "time_retrieved": "2024-07-30T16:38:58.544650", "image_code": "// The MIT License\n// Copyright 2021 Kit\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n#define TIMESCALE 1.0\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    vec4 ui = texture(iChannel1,q);\n    vec3 col = vec3(0.);\n    float t = iTime * TIMESCALE;\n    col.gb = texture(iChannel0, fragCoord.xy / iResolution.xy).gb;\n    col.r = texture(iChannel0, fragCoord.xy / iResolution.xy \n            + step(length(texture(iChannel0, fragCoord.xy / iResolution.xy)), 0.) \n            * vec2(0.006 + 0.006 * sin(t / 3.141592), 0.)).r;\n    col = mix(col,ui.rgb, ui.a*.8);\n    \n    fragColor = vec4( col, 1. );    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//FabriceNeyret\n#define HEX(x) vec3((ivec3(x) >> ivec3(16, 8, 0)) & 255) / 255.\n\n//https://www.shadertoy.com/view/4djSRW\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n\n\n// https://www.shadertoy.com/view/stK3Rm\n// The MIT License\n// Copyright 2021 Charles Lohr\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n#define HIGHQ\n#define BORDERIZE\n\n\nconst int shader5x7[144] = int[144](\n\t0x00000000, 0x00000000, 0x000000f6, 0x60006000, 0xfe280000, 0x0028fe28, 0x92ff9264, 0xc8c6004c, \n\t0x00c62610, 0x046a926c, 0x0000000a, 0x00000060, 0x42241800, 0x42000000, 0x00001824, 0x083e0814, \n\t0x10100014, 0x0010107c, 0x06010000, 0x10100000, 0x00101010, 0x00060600, 0x04020000, 0x00201008, \n\t0xa2928a7c, 0x4200007c, 0x000002fe, 0x928a8642, 0x82840062, 0x008cd2a2, 0xfe482818, 0xa2e40008, \n\t0x009ca2a2, 0x9292523c, 0x8e80000c, 0x00c0a090, 0x9292926c, 0x9260006c, 0x00789492, 0x006c6c00, \n\t0x6d000000, 0x0000006e, 0x82442810, 0x28280000, 0x00282828, 0x10284482, 0x8a800000, 0x00006090, \n\t0x525a423c, 0x907e0034, 0x007e9090, 0x929292fe, 0x827c006c, 0x00448282, 0x448282fe, 0x92fe0038, \n\t0x00828292, 0x809090fe, 0x827c0080, 0x005c9292, 0x101010fe, 0x828200fe, 0x008282fe, 0xfe818102, \n\t0x10fe0080, 0x00824428, 0x020202fe, 0x40fe0002, 0x00fe4020, 0x081020fe, 0x827c00fe, 0x007c8282, \n\t0x909090fe, 0x827c0060, 0x007a848a, 0x949890fe, 0x92640062, 0x004c9292, 0x80fe8080, 0x02fc0080, \n\t0x00fc0202, 0x040204f8, 0x02fc00f8, 0x00fc021c, 0x281028c6, 0x20c000c6, 0x00c0201e, 0xa2928a86, \n\t0xfe0000c2, 0x00008282, 0x08102040, 0x82000004, 0x0000fe82, 0x40804020, 0x01010020, 0x00010101, \n\t0x20400000, 0x2a040000, 0x001e2a2a, 0x222214fe, 0x221c001c, 0x00042222, 0x1422221c, 0x2a1c00fe, \n\t0x00102a2a, 0x40483e08, 0x25180020, 0x003e2525, 0x202010fe, 0x2200001e, 0x000002be, 0x00be0102, \n\t0x08fe0000, 0x00002214, 0x02fe8200, 0x203e0000, 0x001e2018, 0x2020103e, 0x221c001e, 0x001c2222, \n\t0x2424183f, 0x24180018, 0x003f1824, 0x2020103e, 0x2a120010, 0x0000242a, 0x227e2020, 0x023c0022, \n\t0x00023c02, 0x04020438, 0x023c0038, 0x003c0204, 0x14081422, 0x39000022, 0x003e0505, 0x322a2a26, \n\t0x6c100000, 0x00008282, 0x00ee0000, 0x82820000, 0x0000106c, 0x08102010, 0x00000010, 0x00000000\n );\n \nconst int ipow10[12] = int[12]( 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 2147483647, 2147483647 );\n#define calc_ipow10(x) ipow10[x]\n//#define calc_ipow10(x) int(round(pow(10.0,float(x))))\n\n#define _SPACE 0\n#define _BANG 1\n#define _A 33\n#define _B 34\n#define _C 35\n#define _D 36\n#define _E 37\n#define _F 38\n#define _G 39\n#define _H 40\n#define _I 41\n#define _J 42\n#define _K 43\n#define _L 44\n#define _M 45\n#define _N 46\n#define _O 47\n#define _P 48\n#define _Q 49\n#define _R 50\n#define _S 51\n#define _T 52\n#define _U 53\n#define _V 54\n#define _W 55\n#define _X 56\n#define _Y 57\n#define _Z 58\n\n#define _a 65\n#define _b 66\n#define _c 67\n#define _d 68\n#define _e 69\n#define _f 70\n#define _g 71\n#define _h 72\n#define _i 73\n#define _j 74\n#define _k 75\n#define _l 76\n#define _m 77\n#define _n 78\n#define _o 79\n#define _p 80\n#define _q 81\n#define _r 82\n#define _s 83\n#define _t 84\n#define _u 85\n#define _v 86\n#define _w 87\n#define _x 88\n#define _y 89\n#define _z 90\n\n\n#ifdef HIGHQ\n\n// Perform a fake \"texel\" lookup, and return all 4 cells.\nvec4 g5x7d( int ch, vec2 uv )\n{\n    ivec2 cell = ivec2(uv);\n    int x = ch * 6 + cell.x;\n    ivec2 xres = ivec2( x, x-1 );\n    // Fixup gross edges.\n    if( cell.x >= 6 ) xres.x = 0; //Special shader5x7 #0 is all zeroes.\n    ivec2 cv = ivec2( shader5x7[xres.x/4], shader5x7[xres.y/4] );\n    ivec2 movfs = (xres%4)*8;\n    cv = (cv>>movfs)&0xff;\n    ivec4 value  = ivec4(\n        cv>>(cell.yy-1), \n        cv>>(cell.yy+0))&1;\n\n    return vec4(value.yxwz);\n}\n\n\nvec2 fast_inverse_smoothstep( vec2 x )\n{\n    // Uncomment for blobbier letters\n    //return x;\n    return 0.5 - sin(asin(1.0-2.0*x)/3.0); //Inigo Quilez trick.\n}\n\nvec2 roundstep( vec2 x )\n{\n\tvec2 coss = cos( x*3.14159 + 3.14159 );\n\tvec2 sins = sign( coss );\n\tcoss = abs( coss );\n\tcoss = pow( coss, vec2( 1.0 ) );\n\tcoss *= sins;\n\treturn coss / 2.0 + 0.5;\n}\n\n\nvec3 char5x7( int ch, vec2 uv )\n{\n#ifdef BORDERIZE\n    uv *= vec2( 7./6., 9./8. );\n    uv += vec2( 0.0, 0.0);\n    \n#else\n    uv += vec2( 0., -.25);\n#endif\n    vec4 d = g5x7d( ch, uv );\n\n    vec2 lp;\n    lp = fast_inverse_smoothstep(fract( uv ));\n    \n    float top =  mix( d.x, d.y, lp.x );\n    float bottom = mix( d.z, d.w, lp.x );\n    float v = ( mix( top, bottom, lp.y ) );\n\n    // This makes it be a harder edge (But still kinda soft)\n    v = (v-.15)*( 25.+ 1./length( dFdx(uv) + dFdy(uv) ));\n    \n    v = clamp( v, 0., 1. );\n    \n    vec3 col = mix( vec3( 0, 0, 0 )*.5, vec3( 0., uv.y+3., 10.0 )/10.0, float(v) );\n    //vec3 col = mix( vec3( 0, 0, 0 )*.5, vec3( 10., 10., 10.0 )/10.0, float(v) );\n    return col;\n\n}\n\n#else\n\n\nvec3 char5x7( int ch, vec2 uv )\n{\n#ifdef BORDERIZE\n    uv *= vec2( 7./6., 9./8. );\n    if( uv.x < 0. || uv.y < 0. || uv.x > 6. || uv.y > 8. ) return vec3(1.);\n#endif\n    ivec2 cell = ivec2(uv);\n    int x = ch * 6 + int(cell.x);\n    int cv = shader5x7[x/4];\n    int movfs = (x%4)*8;\n    int value  = ((cv>>(movfs+cell.y))&1);\n    int value2 = ((cv>>(movfs+int(uv.y+.5)))&1);\n    if( uv.y >= 7.0 ) value2 = 0;\n    vec3 col = mix( vec3( value2, 0, value2 )*.5, vec3( cell.y+3, cell.y+3, 10.0 )/10.0, float(value) );\n    \n    return col;\n}\n\n#endif\n\n\nvec3 print5x7int( int num, vec2 uv, int places, int leadzero )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 6, 8. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x)/6;\n    int marknegat = -1;\n    if( num < 0 )\n    {\n        marknegat = places-int(log(-float(num))/log(10.0))-2;\n    }\n    num = abs(num);\n    int nn = (num/calc_ipow10(places-posi-1));\n    if( posi == marknegat )\n        nn = -3;\n    else if( nn <= 0 && posi != places-1)\n        nn = leadzero;\n    else\n        nn %= 10;\n    int ch = nn+48-32;\n    return char5x7( ch, fract(cuv)*vec2(6.,8.) );\n}\n\n\n// Zero Leading Integer Print\nvec3 print5x7intzl( int num, vec2 uv, int places )\n{\n    vec2 cuv = uv*vec2( places, 1. );\n    vec2 luv = cuv*vec2( 6, 8. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x)/6;\n    int nn = (num/calc_ipow10(places-posi-1));\n    nn %= 10;\n    int ch = nn+48-32;\n    return char5x7( ch, fract(cuv)*vec2(6.,8.) );\n}\n\nvec3 print5x7float( float num, vec2 uv, int wholecount, int decimalcount )\n{\n    vec2 cuv = uv*vec2( wholecount+decimalcount+1, 1. );\n    vec2 luv = cuv*vec2( 6, 8. );\n    ivec2 iuv = ivec2( luv );\n    int posi = int(iuv.x)/6;\n    int nn = -2;\n    \n    int marknegat = -1;\n    if( num < 0.0 )\n    {\n        marknegat = wholecount-2-int(log(-num)/log(10.0));\n    }\n    \n    num = abs(num);\n    num +=  pow(.1f,float(decimalcount))*.499;\n    int nv = int( num );\n    \n    if( posi < wholecount )\n    {\n        int wholediff = posi - wholecount+1;\n        float v = (pow( 10.0 , float(wholediff)));\n        int ni = int( float(nv) * v);\n        if( posi == marknegat ) nn = -3;\n        else if( ni <= 0 && wholediff != 0 ) nn = -16; //Blank out.\n        else         nn = ni%10;\n    }\n    else if( posi > wholecount )\n    {\n        num -= float(nv);\n        nn = int( num * pow( 10.0 , float(posi-wholecount)));\n        nn %= 10;\n    }\n    int ch = nn+48-32;\n\n    return char5x7( ch, fract(cuv)*vec2( 6, 8. ));\n}\n", "buffer_a_code": "#define AA 24.\n#define SWIRLY 0.75\n#define SCALE 4.\n#define THIC 0.25\n#define TIMESCALE 6.0\n\n\n\nvec3 hue(float x) {\n    x = 1.5 + 1.5 * cos(sin(x / 6.283185) * 6.283185);\n    return clamp(abs(vec3(x) - vec3(1., 2., 3.)), 0., 1.);\n}\n\n//https://www.shadertoy.com/view/sljfW1\nvec3 color(float r, float aa) {\n    float mix0 = smoothstep(0., aa, r);\n    float mix1 = smoothstep(0., aa, r - 0.25);\n    float mix2 = smoothstep(0., aa, r - 0.5);\n    float mix3 = smoothstep(0., aa, r - 0.75);\n    \n    vec3 color0 = HEX(0x009BE8);\n    vec3 color1 = HEX(0xEB0072);\n    vec3 color2 = HEX(0xfff100);\n    vec3 color3 = hue(r);\n    \n    return (\n        color0 * (mix0 - mix1) +\n        color1 * (mix1 - mix2) +\n        color2 * (mix2 - mix3) +\n        color3 * (mix3 - mix0 + 1.)\n    );\n}\n\n\nvoid mainImage( out vec4 O, in vec2 FC )\n{\n    vec2 R = iResolution.xy;\n    vec2 U = ( FC - 0.5 * R ) / R.y;   \n    vec2 m = ( iMouse.xy - 0.5 * R) * 2.0 / R.y;\n    float t = mod(-iTime, 6.283285 / 2.) * TIMESCALE;\n    \n    // Which side of screen?\n    // Now with janky mouse control.\n    float side = iMouse.z > 0. ? ( FC.x - (0.5 + 0.3 * m.x) * R.x) : ( FC.x - (0.5 + sin(iTime)*0.20) * R.x );\n    //side = 5.;\n    \n    float dist = log2( length(U) ) * SCALE;\n    float angle = atan(U.x,U.y);\n    vec2 derv = vec2( dFdx(dist), dFdy(dist) );\n    float width = ( side > 0. ) \n        ? length(derv) \n        : fwidth(dist);\n        \n    // Apply anti-aliasing.\n    float aa = min( AA, AA * width );\n    float swirls1 = smoothstep(\n        -aa, \n        aa * width, \n        THIC - 0.5 + 0.5 * sin(  dist  * SWIRLY + angle + t)\n    );\n    float swirls2 = smoothstep(\n        -aa, \n        aa * width, \n        THIC - 0.5 + 0.5 * cos(  dist  * SWIRLY + angle + t)\n    );    \n\n    vec2 s = vec2(\n        swirls1, \n        swirls2 \n    );\n    // Screen divider\n    float divider = min( side * side / 8., 1.);\n        \n    O = vec4(divider * \n        clamp(normalize(mix(\n            //hue( s.x + t * 0.1 ) , \n            //hue( s.y + t * 0.1 ) , \n            color( s.x , length(derv)) * 2.0, \n            color( s.y , length(derv))  * 2.0 ,             \n            0.5\n        ))*1.5,0.0,1.0), 1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    // Normalized pixel coordinates (from 0 to 1)\n\n    \n    vec2 uvtrue = fragCoord.xy / iResolution.xy;\n    vec2 uvorig = fragCoord.xy / iResolution.yy;\n    vec3 col = vec3( 0.0 );\n\n    \n    if(  uvtrue.y < .05 && uvtrue.x < 0.5 )\n    {\n        ivec4 lines[6] = ivec4[6]( \n            ivec4( 0, _P, _a, _s ),\n            ivec4( _t,  _e, _l, 0 ),\n            ivec4(  _C, _a, _k,  _e ),\n            ivec4( 0, _S, _m, _o ),\n            ivec4( _o, _t, _h, _i ), \n            ivec4( _e, 0, 0, 0 )\n            );\n            \n        ivec2 cell = ivec2(floor(uvorig*vec2(160.)/vec2(6.,8.)));\n        vec2 px = mod(uvorig*160.,vec2(6.,8.));\n        col += char5x7( lines[cell.x/4][cell.x%4], px );\n    }\n\n    fragColor = vec4( col , step(1., length(col)));\n}\n", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGfDy.jpg", "access": "api", "license": "mit", "functions": [[1087, 1087, 1144, 1144, 1631]], "test": "untested"}
{"id": "fdyfDG", "name": "Triangle blur fork", "author": "LoganDark", "description": "Fork of triangle blur from three.js that looks better", "tags": ["blur"], "likes": 2, "viewed": 281, "published": 3, "date": "1658760110", "time_retrieved": "2024-07-30T16:38:59.401359", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.xy;\n\tfragColor = triangleBlur(iChannel0, uv, vec2(0, RADIUS) / iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.14159265359\n#define ITER 5.0\n#define RADIUS iMouse.x / iResolution.x * 256.0\n\nfloat rand(const in vec2 uv) {\n\tconst float a = 12.9898, b = 78.233, c = 43758.5453;\n\tfloat dt = dot(uv.xy, vec2(a, b));\n\tfloat sn = mod(dt, PI);\n\treturn fract(sin(sn) * c);\n}\n\nvec3 fromLinear(vec3 linearRGB) {\n\tbvec3 cutoff = lessThan(linearRGB, vec3(0.0031308));\n\tvec3 higher = vec3(1.055)*pow(linearRGB, vec3(1.0/2.4)) - vec3(0.055);\n\tvec3 lower = linearRGB * vec3(12.92);\n\treturn mix(higher, lower, cutoff);\n}\n\nvec3 toLinear(vec3 sRGB) {\n\tbvec3 cutoff = lessThan(sRGB, vec3(0.04045));\n\tvec3 higher = pow((sRGB + vec3(0.055))/vec3(1.055), vec3(2.4));\n\tvec3 lower = sRGB/vec3(12.92);\n\treturn mix(higher, lower, cutoff);\n}\n\nvec4 triangleBlur(const in sampler2D sampler, const in vec2 uv, const in vec2 delta) {\n\tfloat offset = rand(uv) - 0.5;\n\n\tvec4 sum = vec4(0.0);\n\tfloat total = 0.0;\n\n    for (float t = -ITER; t <= ITER; t++) {\n\t\tfloat percent = (t + offset) / (ITER + 1.0);\n\t\tfloat weight = 1.0 - abs(percent);\n\n\t\tvec2 loc = uv + delta * percent;\n\t\tif (!any(lessThan(loc, vec2(0.0))) && !any(greaterThan(loc, vec2(1.0)))) {\n\t\t\tvec4 srgb = texture(sampler, uv + delta * percent);\n\t\t\tsum += vec4(toLinear(srgb.rgb), srgb.a) * weight;\n\t\t\ttotal += weight;\n\t\t}\n\t}\n\n\tvec4 linear = sum / total;\n\treturn vec4(fromLinear(linear.rgb), linear.a);\n}", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord/iResolution.xy;\n\tfragColor = triangleBlur(iChannel0, uv, vec2(RADIUS, 0) / iResolution.xy);\n}", "buffer_a_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyfDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 170]], "test": "untested"}
{"id": "7sVBRd", "name": "Cloudy Could Call", "author": "leon", "description": "atmospherically unbreathable ", "tags": ["noise", "tunnel", "cloud"], "likes": 49, "viewed": 1151, "published": 3, "date": "1658750701", "time_retrieved": "2024-07-30T16:39:00.277018", "image_code": "\n// Cloudy Could Call\n//\n// - inadequat volumetric rendering\n// - incorrect ambient occlusion\n// - blue noise cache-misÃ¨re\n// - chiaroscuro simulacrum\n// - nimitz protean clouds wannabe\n//\n// \"AtmosphÃ¨re ! AtmosphÃ¨re ! Est-ce que j'ai une gueule d'atmosphÃ¨re ?\"\n// - Arletty (1938)\n\n// Buffer A : cloud rendering\n// Buffer B : temporal anti aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// global\nfloat noise;\n\n// spicy fbm gyroid noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 6; ++i) {\n        seed.z -= iTime*.1+result*.1;\n        result += abs(gyroid(seed/a))*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    noise = fbm(p*.5);\n    float dist = -length(p.xy)+2. - noise*noise;\n    return dist*.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(0,0,5);\n    vec3 ray = normalize(vec3(uv,-1));\n    \n    // animated blue noise by Alan Wolfe\n    // https://www.shadertoy.com/view/XsVBDR\n    const float c_goldenRatioConjugate = 0.61803398875;\n    vec4 rng = texture(iChannel0, fragCoord / vec2(1024.0));\n    rng = fract(rng + float(iFrame%256) * c_goldenRatioConjugate);\n    \n    // raymarch\n    float maxDist = 10.;\n    const float count = 20.;\n    float total = 0.;\n    float dense = 0.;\n    for (float steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        dist *= 0.7+0.3*rng.x;\n        // sort of volumetric march\n        if (dist < .1*rng.z) {\n            dense += .2;\n            dist = .02;\n        }\n        total += dist;\n        if (dense >= 1. || total > maxDist) break;\n        pos += ray * dist;\n    }\n    \n    // cloud color\n    float n = noise;\n    #define getAO(dir,k) smoothstep(-k,k,map(pos+dir*k)-map(pos-dir*k))\n    float ao = getAO(vec3(0,0,1),(.1*rng.x+.1));\n    color = .5+.5*cos(vec3(1,2,3)*.5+ao+pos.z*.3-uv.y);\n    color *= .2+.8*n;\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[355, 355, 412, 412, 494]], "test": "untested"}
{"id": "7dKBzd", "name": "Spherical linear interpolation", "author": "mrange", "description": "CC0: Slerp - spherical linear interpolation\nFrom: https://en.wikipedia.org/wiki/Slerp\nInterpolating between 2 vectors using spherical linear interpolation\n", "tags": ["2d", "tech"], "likes": 5, "viewed": 282, "published": 3, "date": "1658747482", "time_retrieved": "2024-07-30T16:39:01.401013", "image_code": "// CC0: Slerp - spherical linear interpolation\n// From: https://en.wikipedia.org/wiki/Slerp\n// Interpolating between 2 vectors\n// Left side is a normalized mix/lerp which looks decent when the angles are small between the two input vectors\n// As angle nears 180 there's a speedup and slowdown happening\n// Right side uses slerp that has a linear speed, sometimes more desirable\n\n// According to the wikipedia article slerp is generalizable to any dimension so I threw in a vec3 version too, not tested.\n\n// I suppose there's already a slerp on this site somewhere\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat segment(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp(dot(pa,ba)/dot(ba,ba), 0.0, 1.0);\n  return length(pa - ba*h);\n}\n\nvec2 slerp(vec2 p0, vec2 p1, float t) {\n  // https://en.wikipedia.org/wiki/Slerp\n  float d = dot(p0, p1)*inversesqrt(dot(p0, p0)*dot(p1, p1));\n  float o = acos(d);\n  float c = inversesqrt(1.0-d*d); // Cheaper than computing (1.0/sin(o))?\n  return (sin((1.0-t)*o)*p0 + sin(t*o)*p1)*c; \n}\n\nvec3 slerp(vec3 p0, vec3 p1, float t) {\n  // https://en.wikipedia.org/wiki/Slerp\n  float d = dot(p0, p1)*inversesqrt(dot(p0, p0)*dot(p1, p1));\n  float o = acos(d);\n  float c = inversesqrt(1.0-d*d); // Cheaper than computing (1.0/sin(o))?\n  return (sin((1.0-t)*o)*p0 + sin(t*o)*p1)*c; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n\n  float n = floor(p.x);\n  p.x = fract(p.x)-0.5;\n  \n  vec3 col = vec3(0.01);\n  if (abs(n+0.5) < 1.0) {\n    const float r = 0.4;\n    float t = smoothstep(-0.9, 0.9, sin(TIME));\n    vec2 p0 = r*vec2(0., 1.0)*ROT(-1.5*sin(sqrt(0.5)*TIME));\n    vec2 p1 = r*vec2(1.0, 0.0);\n    vec2 p2 =\n      (n == 0.0)\n      ? slerp(p0, p1, t)\n      : r*normalize(mix(p0, p1, t))\n      ;\n  \n    float lw = aa*2.0;\n    float d0 = segment(p, vec2(0.0), p0)-lw;\n    float d1 = segment(p, vec2(0.0), p1)-lw;\n    float d2 = segment(p, vec2(0.0), p2)-lw;\n    float dc = length(p) - r;\n    col = mix(col, vec3(0.1, 0.1, 0.1), smoothstep(aa, -aa, dc));\n    col = mix(col, vec3(0.5, 0.0, 0.0), smoothstep(aa, -aa, d0));\n    col = mix(col, vec3(0.0, 0.5, 0.0), smoothstep(aa, -aa, d1));\n    col = mix(col, vec3(0.5, 0.5, 0.0), smoothstep(aa, -aa, d2));\n  }\n  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[682, 800, 839, 839, 948], [950, 950, 989, 1030, 1236], [1238, 1238, 1277, 1318, 1524], [1526, 1526, 1583, 1583, 2593]], "test": "untested"}
{"id": "ssVBRt", "name": "Painted mosaic 2", "author": "jarble", "description": "A tessellated tile pattern.", "tags": ["fractal", "mosaic", "tessellation"], "likes": 4, "viewed": 338, "published": 3, "date": "1658731421", "time_retrieved": "2024-07-30T16:39:02.261711", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    vec2 t2 = vec2(0.);\n    float p1 = sign(uv.x);\n    for(int k = 0; k < 6; k++){\n        p1 *= sign(uv.x);\n        uv = (uv+t2/1.5);\n        //if(uv.y>uv.x) uv = uv.yx; else uv *= -sign(uv.y-uv.x);\n        t2 = -p1*triangle_wave(uv-1.5);\n        uv = t2-p1*triangle_wave(uv.yx);\n        \n        col.x = (max(uv.y-uv.x,0.)-col.x);\n        col = abs(col.yzx-col.x/3.);\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVBRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 702]], "test": "untested"}
{"id": "NsVBzt", "name": "Luminous Darkly Cloud", "author": "leon", "description": "love is in the air", "tags": ["noise", "cloud", "moon", "lightning"], "likes": 61, "viewed": 1159, "published": 3, "date": "1658716967", "time_retrieved": "2024-07-30T16:39:03.104460", "image_code": "\n// Luminous Darkly Cloud\n//\n// - inadequat volumetric rendering\n// - incorrect ambien occlusion\n// - overloading gyroid fbm noise\n// - fake lightning\n// - random point of view\n//\n// \"but with the right numbers, it looks nice!\"\n\n// globals\nconst vec3 cloudColor = vec3(0.702,0.776,1.000);\nconst vec3 lightColor = vec3(1.000,0.812,0.400);\nfloat glow, cycle, noise, columns, index;\nvec3 target;\nbool flash;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    noise = fbm(p+vec3(0,0,iTime*.2));\n    \n    // cloud\n    float dist = length(p*vec3(1,2,1))-1.;\n    dist -= noise*.5;\n    dist *= .3;\n    \n    if (flash) {\n        // mouse control\n        if (iMouse.z > 0.5) {\n            p.yz *= rot(1.5);\n            p.xy *= rot(-target.x*2.);\n            p.yz *= rot(target.y*2.);\n        }\n\n        // lightning\n        float fade = smoothstep(3.,0.,p.y);\n        p -= fbm(p+cycle)*.3*fade;\n        float c = pModPolar(p.xz, columns);\n        p.x += .5*min(0.,max(-p.y,0.)-2.);\n        float shape = max(p.y+1., length(p.xz)*2.);\n        glow += .02/shape;\n        dist = min(dist, shape);\n    }\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // salt\n    vec3 rng = hash33(vec3(fragCoord, iFrame));\n    \n    // coordinates\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(0);\n    vec3 pos = vec3(0,-1,5);\n    vec3 ray = lookAt(pos, vec3(0), uv, 1.);\n    \n    // timeline\n    float time = iTime*5.;\n    float anim = fract(time);\n    index = floor(time);\n    float alea = step(.9, hash11(index));\n    cycle = index;\n    columns = 1.+floor(6.*hash11(index+186.));\n    glow = 0.;\n    flash = alea > .01;\n    \n    // mouse interaction\n    if (iMouse.z > 0.) {\n        vec2 mouse = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        target = vec3(floor(mouse*10.)/10.,0);\n        cycle = hash12(iMouse.xy);\n        columns = ceil(5.*hash12(iMouse.xy+76.));\n        flash = true;\n        anim = 0.;\n    }\n    \n    // raymarch\n    float maxDist = 10.;\n    const float count = 30.;\n    float steps = 0.;\n    float total = 0.;\n    float dense = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        dist *= 0.7+0.3*rng.x;\n        // sort of volumetric march\n        if (dist < .1) {\n            dense += .02;\n            dist = .02;\n        }\n        total += dist;\n        if (dense >= 1. || total > maxDist) break;\n        pos += ray * dist;\n    }\n    \n    // cloud color\n    color = cloudColor;\n    #define getAO(dir,k) smoothstep(-k,k,map(pos+dir*k)-map(pos-dir*k))\n    color *= .5+.5*getAO(vec3(0,1,0),.5);\n    color *= .5+.5*getAO(vec3(0,1,0),2.);\n    color *= dense;\n    \n    // lightning color\n    color += lightColor * pow(glow, 2.) * (1.-anim);\n    color = clamp(color, 0., 1.);\n    \n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// Mercury\n// https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 6.28/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// fbm gyroid noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        result += pow(abs(gyroid(seed/a)),3.)*a;\n        a /= 2.;\n    }\n    return result;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVBzt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[406, 434, 453, 453, 1115], [1117, 1117, 1174, 1186, 2823]], "test": "untested"}
{"id": "sdGBzd", "name": "[DRG] Sequential Screen Update", "author": "Draugurinn", "description": "The makers of Nubis (real time cloud rendering) used a quarter res buffer to update 1/16th of the pixels each frame. The previous frame is reprojected so there is always something on the screen. Which pixels are updated depends upon their screen coords.", "tags": ["pixel", "optimisation"], "likes": 5, "viewed": 272, "published": 3, "date": "1658687551", "time_retrieved": "2024-07-30T16:39:03.954187", "image_code": "// There is no reprojection here. This shader simply showcases\n// how to selectively render to pixels within each block.\n\n// Controls the frequency at which we cycle through the matrix\nconst int PIXEL_SWITCH_DELAY = 32;\n\n// 4x4 Bayer Matrix\n\n// The matrix specifies the order to use to select pixels within the 4x4 block\n\n// | 11 |  7 | 10 |  6 |\n// |----|----|----|----|\n// |  3 | 15 |  2 | 14 |\n// |----|----|----|----|\n// |  9 |  5 | 12 |  8 |\n// |----|----|----|----|\n// |  1 | 13 |  4 | 16 |\n\nconst ivec2[] pixel = ivec2[]\n(\n    ivec2( 0, 0),\n    ivec2( 2, 2),\n    ivec2( 0, 2),\n    ivec2( 2, 0),\n    ivec2( 1, 1),\n    ivec2( 3, 3),\n    ivec2( 1, 3),\n    ivec2( 3, 1),\n    ivec2( 0, 1),\n    ivec2( 2, 3),\n    ivec2( 0, 3),\n    ivec2( 2, 1),\n    ivec2( 1, 0),\n    ivec2( 3, 2),\n    ivec2( 1, 2),\n    ivec2( 3, 0)\n);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalised pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\n    // Time varying pixel colour\n    vec4 col = 0.5 + 0.5 * cos(iTime + uv.xyxy + vec4(0,2,4,0));\n    \n    int idx = (iFrame / PIXEL_SWITCH_DELAY) % 16;\n    \n    if (ivec2(fragCoord) % 4 == pixel[idx])\n    {\n        fragColor = col;\n        return;\n    }\n\n    // Output to screen\n    fragColor = vec4(0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[821, 821, 878, 928, 1278]], "test": "untested"}
{"id": "sdVfzy", "name": "Tesla Valve", "author": "fenix", "description": "This is far from the best fluid sim, and the valve itself is far from ideal. And yet somehow it still demonstrates the basic principle that more fluid gets through one way than the other.\n*l/r arrows to reset sim*\n*mouse to interact*", "tags": ["2d", "voronoi", "simulation", "fluid", "particles", "liquid", "sph"], "likes": 34, "viewed": 844, "published": 3, "date": "1658685249", "time_retrieved": "2024-07-30T16:39:05.146000", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Same basic engine as \"Self supporting SPH\" https://www.shadertoy.com/view/7ddfRB\n//  Tesla valves were invented in 1920 by Nikola Tesla, but had little practical\n//  use until researchers recently used it to create a microfluidic pump.\n//\n//      https://en.wikipedia.org/wiki/Tesla_valve\n//\n//  I'm not sure why (yet) but the fluid is a lot more active at lower resolutions.\n//  The valve \"works\" though at multiple resolutions, letting relatively more fluid\n//  through from right to left than left to right. The left/right cycle is 3600 frames\n//  long and is controlled by ANIMATE_FRAMES.\n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles into a density texture (used for rendering only)\n//  Buffer D blurs the density (used for rendering only)\n// ---------------------------------------------------------------------------------------\n\nfloat computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular;\n}\n\nvec2 texGrad(sampler2D sampler, vec2 fragCoord)\n{\n    float dx = texture(sampler, (fragCoord + vec2(1.0, 0.0))/iResolution.xy).x\n             - texture(sampler, (fragCoord - vec2(1.0, 0.0))/iResolution.xy).x;\n    float dy = texture(sampler, (fragCoord + vec2(0.0, 1.0))/iResolution.xy).x\n             - texture(sampler, (fragCoord - vec2(0.0, 1.0))/iResolution.xy).x;\n    return vec2(dx, dy);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    float wallSd = distanceFromWalls(p, iResolution, frames);\n    \n    vec4 background = textureLod(iChannel2, fragCoord/iResolution.xy, 5.0);\n    \n    float lDensity = texture(iChannel0, fragCoord/iResolution.xy).x;\n    vec2 lNorm2 = texGrad(iChannel0, fragCoord);\n    vec3 lNorm = vec3(-lNorm2.x, 1.0, -lNorm2.y);\n    lNorm = normalize(lNorm);\n\n    vec4 water = texture(iChannel2, fragCoord/iResolution.xy + lNorm2 * 0.2) * vec4(1.0, 0.0, 0.0, 0.0);\n    float waterSpec = computeSpecular(0.8, 20.0, lNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.7+p.x * 0.3, 0.5 - p.y * 0.3));\n    water.xyz += vec3(waterSpec) * 2.0;\n\n    vec4 scene = mix(background, water, smoothstep(0.5, 1.0, lDensity));\n\n    // Handle animated steel UVs for moving (particle compressing) walls\n    float sideShift = 0.0;\n    if (fragCoord.x > iResolution.x * 0.875)\n    {\n        if (frames > ANIMATE_FRAMES * 0.475)\n        {\n            frames = ANIMATE_FRAMES * 0.475;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.6)\n        {\n            sideShift = -sideShift;\n        }\n    }\n    else if (fragCoord.x < iResolution.x * 0.125)\n    {\n        if (frames > ANIMATE_FRAMES * 0.975)\n        {\n            frames = ANIMATE_FRAMES * 0.975;\n        }\n        sideShift = frames * 0.25;\n        if (fragCoord.y < iResolution.y * 0.5)\n        {\n            sideShift = -sideShift;\n        }\n    }\n\n    vec2 steelCoord = vec2(fragCoord.x * 2.0, (fragCoord.y + sideShift) * 0.004);\n    vec3 steelNorm = texture(iChannel1, steelCoord/iResolution.xy).xyz;\n    steelNorm.xz += getNormalFromWalls(p, iResolution, frames) * (1.0 - smoothstep(0.02, 0.05, -wallSd));\n\n    steelNorm = normalize(steelNorm);\n    float steelSpec = computeSpecular(0.8, 15.0, steelNorm, normalize(vec3(1.0, -1.0, 1.0)), vec3(0.0, 1.75-p.x, 0.5 - p.y));\n    vec4 steel = vec4(vec3(steelSpec), 1.0) * 0.5 + 0.3;\n\n    fragColor = mix(scene, steel, smoothstep(0.02, 0.03, -wallSd));\n\n    fragColor.w = 1.0;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 5000; \nconst float PARTICLE_REPEL_SIZE = 0.01;\n\nconst float ANIMATE_FRAMES = 3600.0;\n\nconst float PI = 3.141592653598793;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat sdBox(in vec2 p, in vec2 boxCenter, in vec2 boxSize)\n{\n    p -= boxCenter;\n    vec2 d = abs(p)-boxSize;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdHorseshoe( in vec2 p, in vec2 c, in float r, in vec2 w )\n{\n    p.x = abs(p.x);\n    float l = length(p);\n    p = mat2(-c.x, c.y, c.y, c.x)*p;\n    p = vec2((p.y>0.0 || p.x>0.0)?p.x:l*sign(-c.x),\n             (p.x>0.0)?p.y:l );\n    p = vec2(p.x,abs(p.y-r))-w;\n    return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nconst float h1ang = 1.8;\nconst mat2 h1rot = mat2(cos(h1ang), -sin(h1ang), sin(h1ang), cos(h1ang));\nconst float h2ang = PI - h1ang;\nconst mat2 h2rot = mat2(cos(h2ang), -sin(h2ang), sin(h2ang), cos(h2ang));\nconst float lang = 1.7;\nconst mat2 lrot = mat2(cos(lang), -sin(lang), sin(lang), cos(lang));\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    time = mod(time, ANIMATE_FRAMES);\n    float rightTime = min(ANIMATE_FRAMES * 0.45, time);\n    float leftTime = min(ANIMATE_FRAMES * 0.45, time - ANIMATE_FRAMES * 0.5);\n    if (leftTime > 0.0) rightTime = 0.0;\n    const float COMPRESS_RATE = 1.0 / (0.55 * ANIMATE_FRAMES);\n    float minDist = 1e30;\n    point.y *= resolution.y / resolution.x;\n    point *= 2.0;\n    minDist = min(minDist, point.x + 1.9);\n    minDist = min(minDist, 1.9 - point.x);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    minDist = min(minDist, sdBox(point, vec2(0.0, 0.0), vec2(1.35, 5.00)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, 2.0 - rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(0.8, -2.0 + rightTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, 2.0 - leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = min(minDist, sdBox(point, vec2(-0.8, -2.0 + leftTime * COMPRESS_RATE), vec2(2.0, 1.0)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(-0.67, 0.16)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(-0.07, -0.14)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h1rot*(point - vec2(0.53, 0.16)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdHorseshoe(h2rot*(point - vec2(1.13, -0.14)), vec2(0.13, 1.0), 0.1, vec2(0.8, 0.04)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.3, 0.04)), vec2(0.0, 0.0), vec2(0.04, 0.4)));\n    minDist = max(minDist, -sdBox(lrot*(point - vec2(1.4, 0.02)), vec2(0.0, 0.0), vec2(0.04, 0.3)));\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define NUM_PARTICLE_DATA_TYPES 5\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only MAX_PARTICLES * NUM_PARTICLE_DATA_TYPES pixels are actually used.\n\nconst float PARTICLE_REPEL = 0.00005;\nconst float IDEAL_DENSITY = 20.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    vec4 state = texture(iChannel3, vec2(0));\n    float frames = state.x;\n\n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL)\n    {\n        if (iFrame == 0 || frames == 0.0)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * vec2(0.1, 1.8) + vec2(0.8, -0.9);\n            data.vel = vec2(0);\n        }\n        else if (iFrame == 0 || frames == ANIMATE_FRAMES * 0.5)\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * vec2(0.1, 1.8) + vec2(-0.9, -0.9);\n            data.vel = vec2(0);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.3 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n           \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            ++numSolverParticles;\n\n            // Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos / dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist / PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    // Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    // Integrate pos\n                    particles[i].pos += particles[i].vel / float(NUM_ITERATIONS);\n                }\n            }\n            \n            // Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n                   \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, frames);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, frames - 1.0);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, frames);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n            }\n            \n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        int searchIterations = 1;\n        if (iFrame < 5)\n        {\n            searchIterations = 10;\n        }\n        for(int k = 0; k < searchIterations; k++)\n        {\n            //random hash. We should make sure that two pixels in the same frame never make the same hash!\n            float h = hash(\n                iFragCoord.x + \n                iFragCoord.y*int(iResolution.x) + \n                iFrame*int(iResolution.x*iResolution.y) +\n                k\n            );\n            //pick random id of particle\n            int p = int(h*float(MAX_PARTICLES));\n            vec2 randXY = fxGetParticleData(p, POS_VEL).xy;\n            insertion_sort(bestIds, bestDists, p, length2(randXY - data.pos));\n        }\n\n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    //if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 old = fxGetClosest(ivec2(fragCoord));\n    ivec4 new = ivec4(-1);\n    \n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(1e6);\n\n    insertion_sort(new, dis, old.x, distance2Particle(old.x, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.y, distance2Particle(old.y, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.z, distance2Particle(old.z, screen2world(fragCoord)));\n    insertion_sort(new, dis, old.w, distance2Particle(old.w, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Render particles and manage persistent state\n\nconst float PARTICLE_RENDER_SIZE = 0.04;\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    //if (p.density < 50.0) return;\n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest);\n\n    //fragColor.w += max(0.0, PARTICLE_SDF_SIZE - sqrt(dist)) / PARTICLE_SDF_SIZE;\n    //fragColor.xyz += 1000.2 * p.pressure * particleColor(p.uv) * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n    //vec3 color = vec3(000.0*p.pressure, 30.0*length(p.vel), 0.012*p.density);\n    vec3 color = vec3(2);//p.uv.y, sin(p.uv.y*23.0)*0.5 + 0.5, cos(p.uv.y* 10.0)*0.5 + 0.5);\n    fragColor.xyz += color * max(0.0, PARTICLE_RENDER_SIZE - sqrt(dist)) / PARTICLE_RENDER_SIZE;\n    \n    // Render neighbor lines\n    #if 0\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= MAX_PARTICLES || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += 0.3*color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) / (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    if (ivec2(fragCoord) == ivec2(0))\n    {\n        vec4 state = texture(iChannel2, vec2(0));\n\n        if (iFrame == 0 || keyDown(39) || iResolution.xy != state.yz)\n        {\n            state = vec4(0.0, iResolution.x, iResolution.y, 0.0);\n        }\n        else if (keyDown(37))\n        {\n            state = vec4(ANIMATE_FRAMES * 0.5, iResolution.x, iResolution.y, 0.0);\n        }\n        else\n        {\n            state.x += 1.0;\n            if (state.x > ANIMATE_FRAMES || keyDown(32))\n            {\n                state.x = 0.0;\n            }\n        }\n        fragColor = state;\n        return;\n    }\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 7; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .01; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).x;                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = textureLod(iChannel0, u / iResolution.xy, 0.0);\n    O.x = convol2D(U); return;\n  //  O = convol1D(U,vec2(1,0));\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVfzy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1184, 1184, 1347, 1347, 1552], [1554, 1554, 1603, 1603, 1948], [1950, 1950, 2003, 2003, 4204]], "test": "untested"}
{"id": "fdGfR3", "name": "Inter Membrane Space", "author": "leon", "description": "another Lipschitz discontinuity", "tags": ["noise", "abstract", "gyroid"], "likes": 30, "viewed": 640, "published": 3, "date": "1658669989", "time_retrieved": "2024-07-30T16:39:10.135659", "image_code": "\n// Inter Membrane Space\n\n// Buffer A : raymarching and lighting\n// Buffer B : temporal anti aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat details;\n\nfloat map(vec3 p)\n{\n    // spicy fbm cyclic gyroid noise\n    details = sin(iTime*.2-fbm(p)+length(p));\n    return max(abs(details*.05), p.z+2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // salt\n    vec3 rng = hash33(vec3(fragCoord, iFrame));\n    \n    // coordinates\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(0);\n    vec3 ray = normalize(vec3(uv, -1.));\n    ray.xy *= rot(-.7);\n    vec3 pos = ray*(.5+.5*rng.z);\n    \n    // raymarch\n    float maxDist = 5.;\n    const float count = 100.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*rng.x;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // lighting\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        vec2 noff = vec2(.001,0); // NuSan https://www.shadertoy.com/view/3sBGzV\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n        float top = dot(reflect(ray, normal), vec3(0,1,0))*.5+.5;\n        vec3 tint = .5+.5*cos(vec3(1,2,3)+pos.y+details*6.);\n        color = vec3(0.2) + vec3(.8)*top;\n        color += tint * .5;\n        color *= shade*shade;\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [], "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// fbm gyroid noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 5; ++i) {\n        result += gyroid(seed/a+result/a)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 160, 242]], "test": "untested"}
{"id": "NdyBRd", "name": "Weird sunday shader", "author": "mrange", "description": "CC0: Weird sunday shader\nI saw some pretty neat logo art and tried to recreate my old (1993) hacker handle (Lance) in that style\nKind of succeeded but then it was much more fun distorting the coordinate system\nThought it looks kind of neat so ", "tags": ["2d"], "likes": 8, "viewed": 289, "published": 3, "date": "1658661170", "time_retrieved": "2024-07-30T16:39:11.372352", "image_code": "// CC0: Weird sunday shader\n// I saw some pretty neat logo art and tried to recreate my old (1993) hacker handle (Lance) in that style\n// Kind of succeeded but then it was much more fun distorting the coordinate system\n// Thought it looks kind of neat so sharing it.\n\n\n// 0.45 looks neat too\n#define COLORTUNE   0.0\n\n\n#define TIME        iTime\n#define TTIME       (TAU*TIME)\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define SCA(a)      vec2(sin(a), cos(a))\n\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst float df_size = 0.2;\nconst float df_linew = 0.04*df_size;\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat arc(vec2 p, vec2 sc, float ra, float rb) {\n  p.x = abs(p.x);\n  return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                abs(length(p)-ra)) - rb;\n}\n\nfloat segmentx(vec2 p, float l) {\n  p.x = abs(p.x);\n  p.x -= 0.5*l;\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  float d = p.x > 0.0 ? d1 : d0;\n  return d;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n  const vec3 k = 0.5*vec3(-sqrt(3.0), 1.0, sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\nvec2 toSmith(vec2 p)  {\n  // z = (p + 1)/(-p + 1)\n  // (x,y) = ((1+x)*(1-x)-y*y,2y)/((1-x)*(1-x) + y*y)\n  float d = (1.0 - p.x)*(1.0 - p.x) + p.y*p.y;\n  float x = (1.0 + p.x)*(1.0 - p.x) - p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nvec2 fromSmith(vec2 p)  {\n  // z = (p - 1)/(p + 1)\n  // (x,y) = ((x+1)*(x-1)+y*y,2y)/((x+1)*(x+1) + y*y)\n  float d = (p.x + 1.0)*(p.x + 1.0) + p.y*p.y;\n  float x = (p.x + 1.0)*(p.x - 1.0) + p.y*p.y;\n  float y = 2.0*p.y;\n  return vec2(x,y)/d;\n}\n\nfloat df_fork(vec2 p) {\n  const vec2 n = SCA(-PI/12.0);\n  p.x = abs(p.x);\n  p -= n*min(0.0, dot(p, n))*2.0;\n  return abs(p.x);\n}\n\nfloat df_l(vec2 p) {\n  vec2 p0 = p;\n  p0.x -= -df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1.y -= -df_size;\n  float d1 = segmentx(p1, df_size*sqrt(8.0/3.0));\n  \n  float d = d0;\n  d = min(d, d1);\n  \n  return d-df_linew;\n}\n\nfloat df_a(vec2 p) {\n  const float sc = sqrt(43.0/24.0);\n  const vec2 n = SCA(-PI/6.0);\n  p.y -= -df_size*sqrt(11.0/96.0);\n\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0 -= n*min(0.0, dot(p0, n))*2.0;\n  float d0 = df_fork(p0-vec2(0.0, sc*df_size));\n\n  vec2 p1 = p;\n  float d1 = segmentx(p1, sqrt(4.0/3.0)*sc*df_size);\n  float d = d0;\n  d = min(d, d1);\n  return d-df_linew;\n}\n\nfloat df_n(vec2 p) {\n  vec2 p0 = p;\n  p0.x = abs(p0.x);\n  p0.x -= df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1 *= ROT(-PI/4.0);\n  float d1 = segmentx(p1, df_size*2.0);\n  \n  float d = d0;\n  d = min(d, d1);\n  \n  return d-df_linew;\n}\n\nfloat df_c(vec2 p) {\n  p = -p.yx;\n  return arc(p, SCA(5.0*PI/6.0), df_size, df_linew);\n  \n}\n\nfloat df_e(vec2 p) {\n  vec2 p0 = p;\n  p0.x -= -df_size*sqrt(2.0/3.0);\n  p0 = p0.yx;\n  float d0 = segmentx(p0, df_size*2.0);\n  \n  vec2 p1 = p;\n  p1.y = abs(p1.y);\n  p1.y -= df_size;\n  float d1 = segmentx(p1, df_size*sqrt(8.0/3.0));\n  \n  vec2 p2 = p;\n  float d2 = segmentx(p2, df_size);\n  \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  \n  return d-df_linew;\n}\n\nvec3 df(vec2 p) {\n  vec2 op = p;\n  p.y -= df_size*sqrt(11.0/96.0);\n\n  const float sz = df_size*2.4;\n  p.x -= sz;\n  vec2 pl = p;\n  pl.x -= -2.0*sz;\n  float dl = df_l(pl);\n\n  vec2 pa = p;\n  pa.x -= -1.0*sz;\n  float da = df_a(pa);\n\n  vec2 pn = p;\n  pn.x -= 0.0*sz;\n  float dn = df_n(pn);\n  \n  vec2 pc = p;\n  pc.x -= 1.0*sz;\n  float dc = df_c(pc);\n  \n  vec2 pe = p;\n  pe.x -= 2.0*sz;\n  float de = df_e(pe);\n\n  vec2 ph = op;\n  ph.y -= -0.025;\n  ph = ph.yx;\n  float dh = -hexagon(ph, 1.99);\n  \n  float d = dl;\n  d = min(d, da);\n  d = min(d, dc);\n  d = min(d, dn);\n  d = min(d, de);\n  \n  return vec3(d, length(pa), dh);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nvec2 transform(vec2 p) {\n  float a = TTIME/55.0;\n  p *= 3.3;\n  vec2 p0 = toSmith(p);\n  p0 += vec2(1.0, -1.0)*mix(-1.0, 1.0, smoothstep(-0.25, 0.25, -sin(0.5*a)));\n  vec2 p1 = toSmith(p);\n  p1 *= ROT(-a);\n  p = fromSmith(p0*p1.yx);\n  p *= ROT(0.5*dot(p, p));\n  p -= -TIME*0.1;\n  return p;\n}\n\nvec3 effect(vec2 p) {\n  const float iz = 4.0;\n  p = transform(p);\n  float aa = iz*length(fwidth(p))*sqrt(0.5);\n  vec2 n = hextile(p);\n  p *= iz;\n  vec3 d3 = df(p);\n  float d = d3.x;\n  float g = d3.y;\n  float dd = d3.z;\n  const float hoff = COLORTUNE;\n  const vec3 bcol  = HSV2RGB(vec3(hoff+0.64, 0.9, 1.5));\n  const vec3 gcol  = HSV2RGB(vec3(hoff+0.61, 0.9, 1.0));\n  const vec3 bbcol = HSV2RGB(vec3(hoff+0.64, 0.75, 0.66));\n  const vec3 scol  = HSV2RGB(vec3(hoff+0.55, 0.925, 3.0));\n \n  float amb = mix(0.025, 0.1, tanh_approx(0.1+0.25*g+0.33*p.y));\n\n  vec3 col = vec3(0.0);\n  \n  col = mix(col, 5.0*sqrt(amb)*bcol, smoothstep(aa, -aa, d));\n  col = mix(col, 4.0*sqrt(amb)*bbcol, smoothstep(aa, -aa, dd));\n  col += 0.125*bcol*exp(-12.0*max(min(d, dd), 0.0));\n  col += gcol*amb;\n  col += scol*aa;\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);;\n  col *= smoothstep(0.0, 4.0, TIME-dot(p, p));\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[786, 786, 808, 808, 954], [1249, 1349, 1368, 1368, 1455], [1457, 1564, 1590, 1590, 1774], [1776, 1836, 1864, 1930, 2006], [2008, 2126, 2174, 2174, 2302], [2304, 2304, 2337, 2337, 2465], [2467, 2585, 2617, 2617, 2803], [2805, 2805, 2828, 2908, 3047], [3049, 3049, 3074, 3153, 3292], [3294, 3294, 3317, 3317, 3422], [3424, 3424, 3444, 3444, 3698], [3700, 3700, 3720, 3720, 4068], [4070, 4070, 4090, 4090, 4355], [4357, 4357, 4377, 4377, 4448], [4450, 4450, 4470, 4470, 4815], [4817, 4817, 4834, 4834, 5431], [5433, 5534, 5562, 5661, 5988], [5990, 5990, 6014, 6014, 6279], [6281, 6281, 6302, 6302, 7091], [7093, 7093, 7148, 7148, 7394]], "test": "untested"}
{"id": "7sKfzc", "name": "Painted mosaic", "author": "jarble", "description": "A tessellated tile pattern.", "tags": ["fractal", "mosaic", "tessellation"], "likes": 5, "viewed": 246, "published": 3, "date": "1658643855", "time_retrieved": "2024-07-30T16:39:12.346747", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        float p1 = sign(uv.x);\n        uv = (uv+t2/1.5)/(1.5+p1*.5);\n        \n        //if(uv.y>uv.x) uv = uv.yx; else uv *= -sign(uv.y-uv.x);\n        t2 = -p1*triangle_wave(uv-.5);\n        uv = t2-p1*triangle_wave(uv.yx);\n        \n        col.x = max(uv.y-uv.x,col.x/4.)+col.x-.5;\n        col = abs(col.yzx-col.x/(4.));\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 713]], "test": "untested"}
{"id": "7dKfzc", "name": "Fractal microbes", "author": "jarble", "description": "A vaguely biological-looking fractal pattern.", "tags": ["fractal", "bacteria", "microbes"], "likes": 8, "viewed": 189, "published": 3, "date": "1658642638", "time_retrieved": "2024-07-30T16:39:13.322140", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 15; k++){\n        float p1 = sign(uv.x);\n        uv = (uv/(1.5+p1*.5)+t2/1.5)/1.5;\n        t2 = -p1*triangle_wave(uv-.5);\n        uv = t2-p1*triangle_wave(uv.yx);\n        \n        col.x = max(uv.y-uv.x,col.x/3.)+col.x-.5;\n        col = abs(col.yzx-vec3(col.x)/(3.));\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKfzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 650]], "test": "untested"}
{"id": "sdKBRc", "name": "Neon flower quilt", "author": "jarble", "description": "A glowing arrangement of flowers and foliage.", "tags": ["fractal", "flower", "plant", "quilt"], "likes": 6, "viewed": 354, "published": 3, "date": "1658627795", "time_retrieved": "2024-07-30T16:39:14.409233", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/16.0;\n    vec2 t2 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        float p1 = sign(uv.x);\n        t2 *= (1.+p1)/2.;\n        uv = (uv+t2)/1.5;\n        t2 = -p1*triangle_wave(uv-.5);\n        uv = t2-p1*triangle_wave(uv.yx);\n        vec2 uv1 = uv+triangle_wave(uv.yx+iTime/4.)/4.;\n        col.x = min(p1*(uv1.y-uv1.x),col.x)+col.x;\n        col = abs(col.yzx-vec3(col.x)/(3.));\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 708]], "test": "untested"}
{"id": "NdKfz3", "name": "hello rgb", "author": "0xff", "description": "hello webgl", "tags": ["2d", "helloworld", "color", "rgb"], "likes": 4, "viewed": 199, "published": 3, "date": "1658599399", "time_retrieved": "2024-07-30T16:39:15.355702", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.x;\n    fragColor = vec4(abs(cross(vec3(uv,sin(iTime)),vec3(cos(iTime),uv))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 197]], "test": "untested"}
{"id": "7dyBz3", "name": "BezierExtrude", "author": "Del", "description": "Extrude a SDF along a Quadratic Bezier segment, correctly oriented to spline tangent\nthis example uses a box, hold mouse button to show torus\nTwist was added just for fun, be careful with the twist as it will distort the distance :)\n\n", "tags": ["raymarch", "bezier", "quadratic", "tangent", "extrude"], "likes": 50, "viewed": 824, "published": 3, "date": "1658578068", "time_retrieved": "2024-07-30T16:39:16.130630", "image_code": "// Extrude a SDF along a Quadratic Bezier segment, correctly oriented to tangent\n//\n// based on IQ's https://www.shadertoy.com/view/ldj3Wh , I just added orientation \n//\n// added a couple of minor optimizations\n// might be worth passing in the up vector instead of just using (0,1,0)\n// made it shiny because we got some likes :)\n\n#define TWIST 1 // set this to zero if you want to see just spline oriented sdf\n\n// returns xyz = position, w = spline position (t)\nvec4 sdBezierExtrude(vec3 pos, vec3 A, vec3 B, vec3 C)\n{    \n    // check for colinear\n    //if (abs(dot(normalize(B - A), normalize(C - B)) - 1.0) < 0.0001)\n    //    return sdLinearSegment(pos, A, C);\n\n\t// first, calc curve T value\n    vec3 a = B - A;\n    vec3 b = A - 2.0*B + C;\n    vec3 c = a * 2.0;\n    vec3 d = A - pos;\n\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\tfloat t;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        t = clamp(uv.x+uv.y-kx, 0.0, 1.0);\n        // 1 root\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 _t = clamp( vec3(m+m,-n-m,n-m)*z-kx, 0.0, 1.0);\n\t\t// 3 roots, but only need two\n\t\tvec3 r1 = d + (c + b * _t.x) * _t.x;\n\t\tvec3 r2 = d + (c + b * _t.y) * _t.y;\n\t\t//t = length(r2.xyz) < length(r1.xyz) ? _t.y : _t.x;\n        t = dot(r2,r2) < dot(r1,r1) ? _t.y : _t.x; // quicker\n        \n    }\n    \n    // now we have t, calculate splineposition and orient to spline tangent\n    //t = clamp(t,0.1,0.9); // clamp spline start/end\n    \n    vec3 _tan = normalize((2.0 - 2.0 * t) * (B - A) + 2.0 * t * (C - B));  // spline tangent\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 binormal = normalize(cross(up, _tan));\n    vec3 _normal = cross(_tan, binormal);\n//\tvec3 t1 = normalize(cross(_normal, _tan));\n\tvec3 t1 = cross(_normal, _tan); // no need to normalize this?\n\tmat3 mm = mat3(t1, cross(_tan, t1), _tan);\n    pos.xyz = mix(mix(A, B, t), mix(B, C, t), t) - pos; // spline position\n    return vec4(pos.xyz*mm, t);\n}\n\n// iq\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// iq\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nmat2 rot(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat map( in vec3 pos )\n{\n    vec3 a = vec3(-5.5,0.0,0.0);\n    vec3 b = vec3(0.0,sin(iTime*1.1)*6.0,(0.5+sin(iTime*2.8)*0.5)*5.0);\n    vec3 c = vec3(5.5,0.0,0.0);\n    vec4 bz = sdBezierExtrude(pos,a,b,c);\n\n    // twist is optional...\n    #if TWIST==1\n    {\n        float twist = (0.5+sin(iTime*1.8)*0.5)*1.1;\n        bz.xy *= rot( (3.14*twist) * bz.w);\n    }\n    #endif\n\n    float d;\n    if (iMouse.z>0.5)\n        d = sdTorus(bz.xyz,vec2(0.75,0.35)); // use a torus\n    else\n    {\n        d = sdBox(bz.xyz, vec3(1.2,0.1,0.01))-0.15; // use a box\n        d = min(length(bz.xyz)-0.3,d); // show the spline center with a sphere  :)\n    }\n    #if TWIST==1\n    d*=0.8;  //twist modifier will distort the distance, so adjust it so it doesn't overshoot\n    #endif\n    \n    return d;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.01;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n    \n    float yy = 4.0;\n    \n\tvec3 ro = vec3( 9.*cos(an), yy, 9.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.01 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        vec3 col = vec3(0.22,0.1,0.4)*smoothstep(1.0,0.0,abs(p.y));\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 rf = reflect(ww, nor);\n            float sha = map(pos+rf) + .5;\n            float factor = sha*length(sin(rf*3.)*0.5+0.5)/sqrt(2.);\n            col = mix(vec3(0.15,0.05,0.26), vec3(0.28,0.6,0.2), factor) + pow(factor*0.7, 6.);\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[412, 463, 519, 696, 2353], [2355, 2361, 2392, 2392, 2483], [2485, 2491, 2524, 2524, 2579], [2581, 2581, 2600, 2600, 2658], [2660, 2660, 2686, 2686, 3438], [3440, 3486, 3518, 3518, 3755]], "test": "untested"}
{"id": "NdGBRc", "name": "Fraunhoffer interference", "author": "Suslik", "description": "Exact fraunhoffer formula for thin film interference", "tags": ["fraunhoffer"], "likes": 7, "viewed": 409, "published": 3, "date": "1658551521", "time_retrieved": "2024-07-30T16:39:16.895585", "image_code": "//reference image0: https://static.projects.iq.harvard.edu/files/styles/os_files_xlarge/public/science-demonstrations/files/thinfilminterference-freeze-wide-2-640x360.jpg\n//reference image1: https://static.projects.iq.harvard.edu/files/styles/os_files_xlarge/public/science-demonstrations/files/thinfilminterference-freeze-top-2-640x360.jpg\n\n//source article with reference images: https://sciencedemonstrations.fas.harvard.edu/presentations/thin-film-interference\n\n\nvec3 sinc(vec3 val)\n{\n  return sin(val) / val;\n}\n\n//reference: https://en.wikipedia.org/wiki/Double-slit_experiment#Classical_wave-optics_formulation\nvec3 Fraunhoffer(vec3 lambda, float theta, float d, float b)\n{\n  float pi = 3.141592f;\n  float s = sin(theta);\n  vec3 c = cos(pi * d * s / lambda);\n  vec3 sc = sinc(pi * b * s / lambda);\n  return c * c * sc * sc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 lambda = vec3(612.0f, 535.0f, 465.0f); //primaries' wavelengths, these values are exact\n    float period = 0.1f; //i failed to get anything visually meaningful with large values of this constant. using sin(theta)~theta gives perfectly viable results.\n    vec3 col = Fraunhoffer(lambda, uv.x * period, 50.0f / period, 5000.0f / period) * 4.0f; //all constants here are arbitrary and depend on the interferometer geometry\n    //col.rgb = vec3(col.r);\n    col += vec3(0.1f); //\"specular\" to match source image better. technically not part of diffraction\n    fragColor = vec4(pow(col, vec3(1.0f / 2.2f)), 1.0f); //linear->srgb\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[467, 467, 488, 488, 515], [517, 617, 679, 679, 831], [833, 833, 890, 890, 1565]], "test": "untested"}
{"id": "fsGfz3", "name": "Simple thin film interference", "author": "Suslik", "description": "Simple thin film interference test", "tags": ["interference", "physics", "thinfilminterference"], "likes": 4, "viewed": 431, "published": 3, "date": "1658548124", "time_retrieved": "2024-07-30T16:39:17.804156", "image_code": "//reference image: https://static.projects.iq.harvard.edu/files/styles/os_files_xlarge/public/science-demonstrations/files/thinfilminterference-freeze-wide-2-640x360.jpg\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 lambda = vec3(612.0f, 535.0f, 465.0f); //primaries' wavelengths\n    vec3 omega = uv.x / lambda;\n    vec3 col = vec3(cos(omega * 20000.0f) * 0.5f + 0.5f); //20000 is an arbitrary scale constant\n    col = mix(vec3(0.25f), col, exp(-omega * 1000.0f)); //smudge the interference pattern towards the right end\n    //col.rgb = vec3(col.b);\n    fragColor = vec4(pow(col, vec3(1.0f / 2.2f)), 1.0f); //linear->srgb\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGfz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 170, 227, 227, 685]], "test": "untested"}
{"id": "fdGBz3", "name": "Fractal mosaic 5", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.", "tags": ["fractal", "mosaic"], "likes": 13, "viewed": 457, "published": 3, "date": "1658544364", "time_retrieved": "2024-07-30T16:39:18.752620", "image_code": "#define fmod(x,y) mod(floor(x),y)\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    //a += sign(a.y)/2.;\n    return abs(fract((a+vec2(1.,0.5))*scale)-.5);\n}\n\n\n#define triwave_(p) abs(fract(.5+p/4.0)-.5)*2.\n#define triwave1_(p) (abs(fract(p/8.0)-.5)-abs(fract(p/2.0)-.5)/2.)\nfloat t1_(vec2 c, vec2 p){\n    return triwave_((.5 - length( min(p=fract(p*sign(triwave1_(c*c.y))), 1.-p.yx) )));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    float scale = 1.5;\n    for(int k = 0; k < 9; k++){\n        \n        //uv.x -= t1_(floor(uv),floor(uv));\n        \n        float offset =\n            //Change this to get lots of interesting patterns\n            0.\n            //.25\n            //float(k)/2.\n        ;\n        //uv +=\n            //floor(uv+vec2(1.,.5))/1.5\n            //floor(uv+vec2(0.,1.))/1.5\n        //;\n        //uv.x += floor(uv.x*4.)/4.;\n        \n        //uv.x += fmod(uv.x,1.5); //lace pattern\n        float p1 = sign(uv.x);\n        //t2 /= 1.5; //makes an interesting tessellation\n        //t2 *= (1.5+p1)/2.; //another interesting tessellation\n        uv = (uv+t2)/scale;\n        //uv *= sign(uv.y-uv.x);\n        //uv = abs(uv);\n        //uv += floor(t2.y-t2.x)/2.;\n        \n        //uv = max(uv,uv*sign(uv.yx-uv));\n        t2 = -p1*triangle_wave(uv-.5+offset,scale);\n        uv = t2-p1*triangle_wave(uv.yx+offset,scale);\n        \n        //celtic knot patterns\n        //uv *= 1. + sign(uv.y-uv.x)/9.;\n        \n        col.x =\n            max(uv.y-uv.x,0.)+col.x-.5\n            //fract(max(uv.y-uv.x,0.)+col.x-.5+iTime) //color cycling\n        ;\n        col = abs(col.yzx-col.x/3.);\n        \n        //if(uv.x < uv.y) uv.x += 1.;\n\n        //uv -= .5;\n        //col = abs(col*col-col.yzx);\n        //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "sound_code": "float fmod(float a, float b){\n    //divide by powers of 2 to get interesting rhythms\n    float a1 = floor(a);\n    //a /= 1. + mod(floor(a1/32.),2.);\n    //a /= 1. + mod(floor(a1/16.),2.);\n    //a /= 1. + mod(floor(a1/8.),2.);\n    //a /= 1. + mod(floor(a1/4.),2.);\n    //a /= 1. + mod(floor(a1/2.),2.);\n    return\n        mod(floor(a),b)\n        //mod(floor(a+floor(a/b)),b)\n        //mod(floor(a)+floor(a+floor(a/b)),b)\n    ;\n}\n#define fmod1(x,y) mod(floor(x+floor(t0*y)),y)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n#define fmax(x,y,z) max(fmod(x,z),fmod(y,z))\n#define fpow(x,y) pow(y,fmod(x,y))\n#define floor1(x) floor(x)*floor(mod((x)/2.,2.))\n\nvec2 mainSound(int samp, float t){\n  \n  float tempo = 1.;\n  t /= tempo;\n  t /= 1.5;\n  \n  t += fpow(t*4.,2.)*fpow(t/4.,2.);\n  \n  float t0=t, s1 =\n      8.;\n  t = t + floor(t+floor(t/s1))/s1;\n  //t += fpow(t*4.,2.)*fpow(t/4.,2.);\n  float\n  m1 =\n      fmod(t,s1)\n  ,\n  z1 =\n      (1.+fmod(t+floor(t*s1),2.))\n  ;\n  t /=\n      1.+fmod(floor(t+floor(t*s1)+z1),2.)\n  ;\n  //t += fpow(t*4.,2.)*fpow(t/4.,2.);\n  float m3 =\n      fmod((t*8.+m1),s1)\n  ;\n  t /=\n      1.+fmod(floor(t*s1+floor(t/s1+z1)),2.)\n  ;\n  float a=sqrt((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3+z1)/5.+9.)*tempo;\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGBz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 75, 100, 152], [270, 270, 296, 296, 385], [388, 388, 445, 445, 2066]], "test": "untested"}
{"id": "7sVBzK", "name": "The Mathematics of Perception", "author": "morisil", "description": "Mint your own iteration of this endless video synthesis on fx(hash):\n\nhttps://www.fxhash.xyz/generative/slug/the-mathematics-of-perception\n", "tags": ["grid", "chromatic", "aberration", "depthoffield", "iterative", "perception", "infinitivespace"], "likes": 32, "viewed": 710, "published": 3, "date": "1658517587", "time_retrieved": "2024-07-30T16:39:19.634263", "image_code": "// Copyright Kazimierz Pogoda, 2022 - https://xemantic.com/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work in any form,\n// including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it.\n// I share this Work for educational purposes, and you can link to it,\n// through an URL, proper attribution and unmodified screenshot, as part\n// of your educational material. If these conditions are too restrictive\n// please contact me and we'll definitely work it out.\n\n// copyright statement borrowed from Inigo Quilez\n\n/*\nDescripition copied from fx(hash), where this system is mintable in unique\niterations:\n\nhttps://www.fxhash.xyz/generative/slug/the-mathematics-of-perception\n\nThis system, called The Mathematics of Perception, emerged from a\nseries of thought experiments. Our xemantic collective applies philosophy\nto facts about the world. The physics behind sensory experience is already\ndeeply researched. But what makes certain experiences evoke certain\nfeelings and affectionate states in the broader sense? I want to evoke\nemotions with algorithms. This research is needed for bigger immersive\ninstallations, using certain aesthetics for telling various narratives.\nHowever I am not a video artist, I don't cut and transform existing frames.\nI synthesize them with equations. The process can be described as\nsculpting in light and time with math.\n\nGenerating video-experience, which is perceptually pleasant, usually\ninvolves 3D modeling. There is no 3D per se involved in this system, not\neven so called ray marching. It represents an optical illusion of infinitive\nspace coded as a single GLSL fragment shader.\n\nIt started with a sketch - how to show an unlimited grid of lights,\noverlapping each other in perspective and movement.\n\nThen I added depth of field simulation, to blur the light discs depending\non perceived distance. Usually generating things \"out of focus\" is surprisingly\nexpensive to compute. Here simplicity of mathematical analytic formula\ncame very handy without extra cost.\n\nAfter depth of field, the simulation of connected chromatic aberration\nfollowed. This alone is the actual source of color in this system.\n\nBy accident I discovered that I can also introduce simulated refractions.\nIt's hard to believe how much this simple addition improved the experience.\nThe \"refraction\" is not fully following the physics of perception. It is\n\"impossible\" on purpose, still believable optical illusion. If you feel\noniric and escheresque, probably it's thanks to this single line of code.\n\nThe waves are important as well. Usually I use trigonometric functions for\nexpressing motion. They have this ability of producing oscillation cycles\nwe observe everywhere in the physical world. From rocking in our cradles,\nlater observing branches of a tree when the wind blows, through experience\nof music, which is unconscious perception of ratios between waves, we relate\nto this kind of swinging movement. This is how we dance.\n\nEach minted variant of this system will have different base parameters and\nmotion, providing similar, but unique experience. I hope that due to\ndifferences, each of them might evoke slightly different emotions.\nTherefore this drop is to please your senses, but also to continue with\nour experiment. After minting each variant please write us back how you\nfeel out it.\n\nKazik Pogoda\nthe mother of xemantic\n */\n\nconst int ITERATIONS = 15;\nconst float PI = 3.14159265359;\n\nmat2 rotate2d(in float angle){\n  return mat2(cos(angle),-sin(angle), sin(angle),cos(angle));\n}\n\nfloat shape(in vec2 st, in float size, in float blur) {\n  vec2 modSt = mod(st, 1.) * 2. - 1.;\n  float dist = length(modSt);\n  return smoothstep(size + blur, size - blur, dist);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = (2.* fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n  vec3 color = vec3(0);\n  float luma = .5;\n  vec2 layerSt = st * (cos(iTime * .115) * .6 + .8);\n  layerSt *= rotate2d(cos(iTime * .023 + 5.) * PI + PI);\n\n  for (int i = 0; i < ITERATIONS; i++) {\n    vec2 gridSt = layerSt + vec2(cos(iTime * .013) * 6. + 6., cos(iTime * .011) * 6. + 6.);\n    layerSt *= rotate2d(-cos(iTime * .0012) * PI + 1.);\n\n    float depth = (float(i) + .5) / float(ITERATIONS);\n    float focusDepth = depth - (cos(iTime * .73) * .5 + .5) * .8 + .1;\n    float blur = .05 + focusDepth * focusDepth * .4;\n\n    float chromaticAberration = cos(iTime * .15) * .2 + .2;\n    float shapeSize = + .3 + cos(iTime * .074) * .2;\n    vec3 shapeColor = vec3(\n      shape(gridSt - st * chromaticAberration * blur, shapeSize, blur),\n      shape(gridSt, shapeSize, blur),\n      shape(gridSt + st * chromaticAberration * blur, shapeSize, blur)\n    ) * luma;\n\n    layerSt += st * shape(gridSt, shapeSize, .5) * cos(iTime * .081) * .6;\n    layerSt *= cos(iTime * .23) * .05 + 1.1;\n    color += shapeColor;\n    luma *= .85;\n  }\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sVBzK.jpg", "access": "api", "license": "proprietary-license", "functions": [[3596, 3596, 3626, 3626, 3690], [3692, 3692, 3747, 3747, 3870]], "test": "untested"}
{"id": "fdGSz1", "name": "BLF 3D Quadratic Bezier", "author": "iY0Yi", "description": "This is a 3D version of @zlnimda's quadratic bezier shader.\n[url]https://www.shadertoy.com/view/3tlSzH[/url]\nShamelessly, I've not understood his algorithm, but it has a more robust distance field than many others in shallow angles.", "tags": ["bezier", "quadratic", "cardano", "maptoy"], "likes": 16, "viewed": 564, "published": 3, "date": "1658504872", "time_retrieved": "2024-07-30T16:39:20.797153", "image_code": "// \"Quadratic Bezier SDF\" by zlnimda\n// https://www.shadertoy.com/view/3tlSzH\n/* ----------------\n*\tzlnimda wrote this file and is under license CC-BY-SA-4.0 \n* \t( see legal notice: https://creativecommons.org/licenses/by-sa/4.0/legalcode )\n/* ----------------\n* \tBezier algo from my previous shader: https://www.shadertoy.com/view/Mt33zr\n* \tPoints and distance view from iq: https://www.shadertoy.com/view/MlKcDD\n*/\n\n#define UI_AXIS 1\n#define UI_GRID_2D 1\n#define UI_GRID_3D 0\n#define UI_ISOLINE 0\n\n#define VIEW_QUAD 1\n\n#define DBG_MATCAP 0\n#define DBG_NORMAL 0\n#define DBG_COST 0\n\n#define CAM_SCALE 1.\n#define TURN_TABLE 0\n#define TURN_TABLE_SPEED .5\n\n// Cardano's method : https://en.wikipedia.org/wiki/Cubic_function#Cardano's_method\nvec3 Cardan(float p, float q){\n    float p3 = p*p*p;\n    float D = - (4.*p3+27.*q*q);\n    if (D > 0.){\n        float a = 2.*sqrt(-p/3.);\n        float b = acos(sqrt(27./(-p3))*-q/2.)/3.;\n        return vec3(a*cos(b), a*cos(b+2.*PI/3.), a*cos(b+4.*PI/3.));\n    }\n    else if (D < 0.){\n        float coef = 1./3.;\n        float DD = sqrt(-D/27.);\n        float u = (-q+DD)/2.;\n        u = sign(u)*abs(pow(abs(u), 1./3.));\n        float v = (-q-DD)/2.;\n        v = sign(v)*pow(abs(v), 1./3.);\n        return vec3(u + v);\n    }\n    else{\n        if (p == 0. || q == 0.)\n            return vec3(0.);\n        float r = 3.*q/p;\n        float r2 = -3.*q / (2.*p);\n        return vec3(r, r2, r2);\n    }\n}\n\n// Resolve cubic equation\nvec3 resolveEqDeg3(float a, float b, float c, float d){\n    vec3 A = vec3(b, c, d) / a;\n    float p = A.y - A.x*A.x/3.;\n    float q = A.x*(2.*A.x*A.x-9.*A.y)/27.+A.z;\n    return Cardan(p, q) - (b / (3.*a));\n}\n\n// bezier formula following bernstein Bez(t) = E(i->n)Bern(t).Pi with t=[0,1]\n// Deg3 -> Bez(t) = (1-t)ÃÂ²P0 + 2t(1-t)P1 +tÃÂ²P2    \nvec3 BezierDeg3(vec3 p0, vec3 p1, vec3 p2, float t){\n    return p0*pow(1.-t, 2.) + p1*2.*t*(1.-t) + p2*t*t;\n}\n\n// Main element to bezier curve SDF\nfloat sdBezier(vec3 pos, vec3 p0, vec3 p1, vec3 p2, float r1, float r2){\n    // dP/dt(t) = 2(A+Bt)\n    // simplified from \n    // dP/dt(t) = -2(1-t)P0 + 2(1-2t)P1 + 2tP2\n    vec3 A = p1-p0;\n    vec3 B = p2-p1-A;\n    \n    // search for equation\n    // MP.dP/dt = 0\n    vec3 M = p0 - pos;\n    vec3 t = resolveEqDeg3(dot(B, B), dot(A, B)*3., dot(A,A)*2.+dot(M,B), dot(M,A));\n    \n    t = clamp(t, vec3(0), vec3(1));\n    \n    // displacement along t\n    //#define wv(tel) (cos(tel*PI*200.)*.00125)\n    #define wv(tel) 0.\n    \n    #define rr (r2/r1)\n    #define f(x) ((x)*(1.-rr)+rr)\n    float d = length(pos-BezierDeg3(p0, p1, p2, t.x))-r1*f(1.-t.x)+wv(t.x);\n    d = min(d, length(pos-BezierDeg3(p0, p1, p2, t.y))-r1*f(1.-t.y)+wv(t.y));\n    d = min(d, length(pos-BezierDeg3(p0, p1, p2, t.z))-r1*f(1.-t.z)+wv(t.z));\n    d = min (d, length(p0-pos)-r2*rr);\n    return d;\n}\n\nfloat map(vec3 p){\n    vec3 q = p;\n    //q.y+=((iMouse.x/iResolution.x)-.5);\n    //q.xz += gfbm(q.xy*vec2(10,20), 1, .5)*.03;\n    float d = 100.;\n    d = min(d, sdBezier(q, vec3(0), vec3(1,.5,0), vec3(sin(iTime)*.5,0,cos(iTime)*.5), .15, .1));\n    d = min(d, sdBezier(q, vec3(sin(iTime)*.5,0,cos(iTime)*.5), vec3(sin(iTime)*1.-1.,-.5,cos(iTime)*1.), vec3(cos(iTime)*.5,0,sin(iTime)*.5), .1, .09));\n    return d;\n}\n\nrender();\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//   __  __    __    ____  ____  _____  _  _ \n//  (  \\/  )  /__\\  (  _ \\(_  _)(  _  )( \\/ )\n//   )    (  /(__)\\  )___/  )(   )(_)(  \\  / \n//  (_/\\/\\_)(__)(__)(__)   (__) (_____) (__) \n//\n//  Version: 1.0.5\n//\n//  This is a \"Maptoy\" template.\n//  I wanted an editor dedicated to distance functions, so I created it in Shadertoy.\n//  You can bookmark this page, fork, and edit it.\n//  I've tried to keep everything but the map functions in the Common tab.\n//\n//  Update:\n//\n//  1.0.5 @ 2022/09/14    \n//        - Fixed long compilation in Quad view.\n//\n//  1.0.4 @ 2021/11/03    \n//        - Added Isoline draw.\n//\n//  1.0.3 @ 2021/10/22    \n//        - Added Matcap debug mode.\n//\n//  1.0.2 @ 2021/10/20    \n//        - Added Quad view mode.\n//\n//  1.0.1 @ 2021/10/15    \n//        - Added Axis draw.\n//        - Added Hotkeys for Camera View angle.\n//         ( Numpad-1:Front / Numpad-3:Side / Numpad-7:Top / Numpad-0:Toggle free/fixed )\n//\n//  1.0.0 @ 2021/10/14   \n//        - Released.\n//\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n// Setting\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#define THM_BACKGROUND (vec3(0.071,0.071,0.071)*.8)\n#define THM_GRID vec3(0.078,0.078,0.078)\n#define THM_ISOLINE vec3(.2)\n#define THM_ISOMIX .8\n#define THM_GEOM_DARK vec3(0.000,0.000,0.000)\n#define THM_GEOM_LIGHT vec3(0.820,0.820,0.820)\n#define THM_MATCAP_TYPE 1\n// Matcaps 0:CURVATURE/1:METAL/2:RED_WAX\n\n#define DIST_MIN .001\n#define DIST_MAX 10.\n#define STEP_MAX 100\n#define INIT_CAM_POS vec3(0,0,2)\n\n// Utils\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*2.)\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define R(p, a) p=p*mat2(cos(a),sin(a),-sin(a),cos(a))\nvec2 rot(vec2 p, float r){ R(p, r); return p; }\nvec3 rot(vec3 p, vec3 r){ R(p.xz, r.y), R(p.yx, r.z), R(p.zy, r.x); return p; }\n\n// Borrowed from \"Infinite 3D Grid Planes\" by peepsalot:\n// https://www.shadertoy.com/view/Ndy3Rm\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat plane( in vec3 ro, in vec3 rd, in vec4 p ){\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nfloat grid(in vec2 p, in vec2 dpdx, in vec2 dpdy, float N){\n    const float scl = 0.5;\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 1.0 / N - w; // see \n    vec2 b = p - w;\n    vec2 i = clamp(\n      ( floor(a) + min(fract(a) * N, 1.0)\n       -floor(b) - min(fract(b) * N, 1.0)\n      ) / (N*w)\n      , vec2(0), vec2(1));\n    return (1.0 - i.x) * (1.0 - i.y);\n}\nfloat grid_lookup(in vec3 ro, in vec3 rd, float resDist, in vec4 pln, float scale, float lineRatio){\n    float t = plane(ro, rd, pln);\n    if (t > 0.0 && t<resDist)\n    {\n        vec3 p = (ro + t * rd);\n        vec2 uv = scale*(p.yz * pln.x + p.xz * pln.y + p.xy * pln.z);\n        return clamp(1.0 - grid(uv, dFdx(uv), dFdy(uv), 2.0 * lineRatio), 0.0, 1.0);\n    } else {\n        return 0.0;\n    }\n}\n\n// https://iquilezles.org/articles/intersectors\n// infinite cylinder defined by a base point cb, a normalized axis ca and a radious cr\nvec2 cylIntersect( in vec3 ro, in vec3 rd, in vec3 cb, in vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec2(-1.0); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\n\n// \"iResolution, iMouse, iDate, etc\" by FabriceNeyret2:\n// https://www.shadertoy.com/view/llySRh\n// --- chars\nint CAPS=0;\n#define low CAPS=32;\n#define caps CAPS=0;\n#define spc  U.x-=.5;\n#define C(c) spc col+= char(U,64+CAPS+c).rgb;\n#define _a 1\n#define _b 2\n#define _c 3\n#define _d 4\n#define _e 5\n#define _f 6\n#define _g 7\n#define _h 8\n#define _i 9\n#define _j 10\n#define _k 11\n#define _l 12\n#define _m 13\n#define _n 14\n#define _o 15\n#define _p 16\n#define _q 17\n#define _r 18\n#define _s 19\n#define _t 20\n#define _u 21\n#define _v 22\n#define _w 23\n#define _x 24\n#define _y 25\n#define _z 26\n\n// render(): general ray marching code.\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nfloat cost = 0.;\n#define C_MOUSE vec2(0,0)\n#define C_CAMERA vec2(1,0)\n#define C_MOUSE_VEC vec2(2,0)\n#define C_MOUSE_POS vec2(3,0)\n#define CAM_DIST 6.\n#define render() \\\nint char_id = -1; vec2 char_pos, dfdx, dfdy; \\\nvec4 char(vec2 p, int c) {\\\n    vec2 dFdx = dFdx(p/16.), dFdy = dFdy(p/16.);\\\n    if ( p.x>.25&& p.x<.75 && p.y>.1&& p.y<.85 ) /* thighly y-clamped to allow dense text*/\\\n        char_id = c, char_pos = p, dfdx = dFdx, dfdy = dFdy;\\\n    return vec4(0);\\\n}\\\nvec4 draw_char() {\\\n    int c = char_id; vec2 p = char_pos;\\\n    return (c < 0)? vec4(0,0,0,1e5) : textureGrad( iChannel1, p/16. + fract( vec2(c, 15-c/16) / 16. ), dfdx, dfdy );\\\n}\\\nvec4 fetch(vec2 coord){\\\n    return texelFetch(iChannel0, ivec2(coord), 0);\\\n}\\\nstruct Ray{\\\n\tvec3 origin;\\\n\tvec3 direction;\\\n}ray;\\\nvec3 calcNormal(vec3 p){\\\n  vec3 n=vec3(0);\\\n  for(int i=0; i<4; i++){\\\n    vec3 e=DIST_MIN*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\\\n    n+=e*map(p+e);\\\n  }\\\n  return normalize(n);\\\n}\\\n/* Camera localized normal*/\\\nvec3 campos, camup;\\\nvec3 localNormal(vec3 p) {\\\n    vec3 n = calcNormal(p), ln;\\\n    vec3 side = cross(campos, camup);\\\n    return vec3(dot(n,  side), dot(n,  camup), dot(n,  -ray.direction));\\\n}\\\nfloat march(vec3 ro, vec3 rd){\\\n    float t=DIST_MIN, d;\\\n    for(int i=0; i<STEP_MAX; i++)\\\n    {\\\n        t+=d=map(ro+rd*t);\\\n        if (d<DIST_MIN) return t;\\\n        if (t>DIST_MAX) return DIST_MAX;\\\n        cost++;\\\n    }\\\n    return DIST_MAX;\\\n}\\\nvec2 forceView = vec2(0);\\\nvoid setupRay(vec2 uv){\\\n\tvec3 up = vec3(0,1,0);\\\n    vec3 pos = normalize(vec3(1)) * CAM_DIST;\\\n    if(sign(iMouse.z)>.0 && (forceView.x<.5))\\\n        pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y<.5 && bool(TURN_TABLE))\\\n        pos = normalize(vec3(sin(iTime*TURN_TABLE_SPEED), -1, cos(iTime*TURN_TABLE_SPEED))) * CAM_DIST;\\\n    else if(fetch(C_CAMERA).y>.5 || forceView.x>.5){\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) pos = vec3(0,0,1) * CAM_DIST;/*FRONT*/\\\n        if(num==3) pos = vec3(-1,0,0) * CAM_DIST;/*SIDE(LEFT)*/\\\n        if(num==7) {up=vec3(0,0,1); pos = vec3(0,-1,0) * CAM_DIST;/*TOP*/\\\n        if(num==0) pos = normalize(vec3(sin(iMouse.x/iResolution.x*PI*2.), (iMouse.y/iResolution.y-.5)*4., cos(iMouse.x/iResolution.x*PI*2.))) * CAM_DIST;}\\\n    }\\\n    else {\\\n        vec4 mou = abs(texelFetch(iChannel0, ivec2(C_MOUSE), 0));\\\n        pos = normalize(vec3(sin(mou.x/iResolution.x*PI*2.), (mou.y/iResolution.y-.5)*4., cos(mou.x/iResolution.x*PI*2.))) * CAM_DIST;\\\n        if(length(mou.xyz)<=.0)pos=INIT_CAM_POS;\\\n    }\\\n    vec3 cw = normalize(-pos);\\\n    vec3 cu = normalize(cross(cw, up));\\\n    vec3 cv = normalize(cross(cu, cw));\\\n    campos = cw, camup = cv;\\\n\tuv *= CAM_SCALE/CAM_DIST;\\\n\tfloat perspective = 1.5;\\\n\tfloat fv = acos(dot(cw, normalize(cu * uv.x)));\\\n\tfloat screenSize = (CAM_DIST*perspective / (2.0 * tan(abs(fv) / 2.0)));\\\n\tvec3 virtscreen = pos + cw * 2.0 + (cu * uv.x + cv * uv.y) * screenSize;\\\n\tray.origin = -pos + (cu * uv.x + cv * uv.y) * (0.7 + 0.2 * perspective) * screenSize;\\\n\tray.direction = normalize(virtscreen - ray.origin);\\\n}\\\nfloat plaIntersect( in vec3 ro, in vec3 rd, in vec4 p )\\\n{\\\n    return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\\\n}\\\nvec3 renderRect(vec2 fragCoord){\\\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y, U;\\\n    setupRay(uv);\\\n    vec3 col= THM_BACKGROUND;\\\n    float t= march(ray.origin, ray.direction);\\\n    if(t<DIST_MAX){\\\n        vec3 p = ray.origin + ray.direction * t;\\\n        col = vec3(.5);\\\n        vec3 n = localNormal(p);\\\n\t\tvec3 lightPos = vec3(-2,2,-2);\\\n    \tvec3 li = normalize(lightPos-p);\\\n\t\tfloat dif = dot(n,li)*.5+.5;\\\n        col = mix(THM_GEOM_DARK, THM_GEOM_LIGHT, dif);\\\n        if(bool(DBG_NORMAL))col = (n*.5+.5)*.5;\\\n        if(bool(DBG_MATCAP)){\\\n            float depth = distance(ray.origin, p);/*/DIST_MAX;*/\\\n            n = localNormal(p);\\\n            /* Compute curvature */\\\n            vec3 dx = dFdx(n);\\\n            vec3 dy = dFdy(n);\\\n            vec3 xneg = n - dx;\\\n            vec3 xpos = n + dx;\\\n            vec3 yneg = n - dy;\\\n            vec3 ypos = n + dy;\\\n            float sgn = (dot(localNormal(p),vec3(1,0,0))>0.)? 1. : -1.;\\\n            float curvature = (cross(xneg, xpos).y - cross(yneg, ypos).x) * 4.0 / depth;\\\n            /* Compute surface properties */\\\n            if(THM_MATCAP_TYPE == 0){\\\n                vec3 light = vec3(0.0);\\\n                vec3 ambient = vec3(curvature + 0.5);\\\n                vec3 diffuse = vec3(0.0);\\\n                vec3 specular = vec3(0.0);\\\n                float shininess = 0.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 1){\\\n                float corrosion = clamp(-curvature * 8.0, 0.0, 1.0);\\\n                float shine = clamp(curvature * 3.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.047,0.067,0.094);\\\n                vec3 diffuse = mix(mix(vec3(0.259,0.380,0.290), vec3(0.431,0.549,0.549), corrosion),\\\n                vec3(0.761,0.655,0.439), shine) - ambient;\\\n                vec3 specular = mix(vec3(0), vec3(1) - ambient - diffuse, shine);\\\n                float shininess = 128.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }else if(THM_MATCAP_TYPE == 2){\\\n                float dirt = clamp(0.15 - curvature * 5.0, 0.0, 1.0);\\\n                vec3 light = normalize(vec3(0.0, 1.0, 10.0));\\\n                vec3 ambient = vec3(0.251,0.082,0.008);\\\n                vec3 diffuse = mix(vec3(0.565,0.224,0.078), vec3(0.996,0.843,0.843), dirt) - ambient;\\\n                vec3 specular = mix(vec3(0.3) - ambient, vec3(0.0), dirt);\\\n                float shininess = 16.0;\\\n                /* Compute final color */\\\n                float cosAngle = dot(n, light);\\\n                col = ambient +\\\n                diffuse * max(0.0, cosAngle) +\\\n                specular * pow(max(0.0, cosAngle), shininess);\\\n            }\\\n            col = pow(col, vec3(2.));\\\n        }\\\n    }\\\n    float gsi = 2.;\\\n    float gsf = 10.;\\\n    float gli = 50.;\\\n    float glf = 20.;\\\n    float gx = max(grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(1, 0, 0, 0), gsi, gli));\\\n    float gz = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 1, 0, 0), gsi, gli));\\\n    float gy = max(grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsf, glf), grid_lookup(ray.origin, ray.direction, t, vec4(0, 0, 1, 0), gsi, gli));\\\n    vec3 g=vec3(0);\\\n    if(bool(UI_GRID_2D))\\\n        g = vec3(gz);\\\n    if(iMouse.z<.5 && (fetch(C_CAMERA).y>.5 || bool(UI_GRID_3D) || forceView.x>.5))\\\n        g = vec3(gx+gy+gz)*.333;\\\n    if(bool(DBG_COST))\\\n        col.r+=cost/float(STEP_MAX);\\\n    col = mix(col, THM_GRID, g);\\\n    if(bool(UI_ISOLINE)) {\\\n        vec4 n;\\\n        int num;\\\n        if(forceView.x>.5) num = int(forceView.y);\\\n        else num = int(fetch(C_CAMERA).x);\\\n        if(num==1) n = vec4(0,0,1,0);\\\n        if(num==7) n = vec4(0,1,0,0);\\\n        if(num==3) n = vec4(1,0,0,0);\\\n        if(num==0) n = vec4(0,1,0,0);\\\n        float pd = plaIntersect(ray.origin, ray.direction, normalize(n));\\\n        float inpd = map(ray.origin + ray.direction * pd);\\\n        float major = smoothstep(.0051, .005, abs(mod(inpd, 1.)-.5));\\\n        float minor = smoothstep(.0051, .005, abs(mod(inpd+.05, .1)-.05));\\\n        col = mix(col, THM_BACKGROUND*.5, (1.-float(pd<t))*THM_ISOMIX);\\\n        col = mix(col, vec3(.35)*col, step(0., -inpd));\\\n        col = mix(col, mix(col, vec3(THM_ISOLINE), mix(major, minor, .333)), .9);\\\n    }\\\n    col = pow(col, vec3(.4545));\\\n    if(bool(UI_AXIS)){\\\n        float at = .005;\\\n        float axisX = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(1,0,0), at).x;\\\n        if(axisX>0. && (bool(UI_ISOLINE) || axisX<t))col=vec3(0.451,0.145,0.110);\\\n        float axisY = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,1,0), at).x;\\\n        if(axisY>0. && (bool(UI_ISOLINE) || axisY<t))col=vec3(0.267,0.471,0.129);\\\n        float axisZ = cylIntersect(ray.origin, ray.direction, vec3(0), vec3(0,0,1), at).x;\\\n        if(axisZ>0. && (bool(UI_ISOLINE) || axisZ<t))col=vec3(0.267,0.424,0.671);\\\n    }\\\n    U = ( fragCoord/iResolution.y - vec2(0, (1.-.075)) ) * 20.;\\\n    int num;\\\n    if(forceView.x>.5) num = int(forceView.y);\\\n    else num = int(fetch(C_CAMERA).x);\\\n    caps C(_c) low C(_a)C(_m)C(_e)C(_r)C(_a) caps C(-6) spc\\\n    if(num==1){caps C(_f) low C(_r)C(_o)C(_n)C(_t)}\\\n    if(num==7){caps C(_t) low C(_o)C(_p)}\\\n    if(num==3){caps C(_s) low C(_i)C(_d)C(_e)}\\\n    if(num==0){caps C(_f) low C(_r)C(_e)C(_e)}\\\n    col = mix(col, pow(vec3(.8),vec3(.4545)), draw_char().xxx);\\\n    return col;\\\n}\\\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\\\n    if(bool(VIEW_QUAD)){\\\n        vec3 Res = vec3(iResolution.xy, 0);\\\n        forceView = vec2(1,1);\\\n        vec2 offset;\\\n        if(fragCoord.x<Res.x*.5-2. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,1);offset=Res.zz;}\\\n        else if(fragCoord.x<Res.x*.5-2. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(1,7);offset=Res.zy;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y<Res.y*.5-1. )\\\n        {forceView = vec2(1,3);offset=Res.xz;}\\\n        else if(fragCoord.x>Res.x*.5+1. && fragCoord.y>Res.y*.5+1. )\\\n        {forceView = vec2(0,0);offset=Res.xy;}\\\n        fragColor = vec4(renderRect(fragCoord*2.-offset),1);\\\n        if((fragCoord.x>Res.x*.5-1. && fragCoord.x<Res.x*.5+1.) || (fragCoord.y>Res.y*.5-1. && fragCoord.y<Res.y*.5+1.))fragColor = vec4(pow(THM_GRID,vec3(.4545)),1);\\\n    }else{\\\n        fragColor = vec4(renderRect(fragCoord),1);\\\n    }\\\n}int dummy\\\n\n", "buffer_a_code": "// References:\n// \"Special Shadertoy features\" by Fabrice: https://shadertoyunofficial.wordpress.com/2016/07/20/special-shadertoy-features/\n// \"keyboard debugging\" by mattz: https://www.shadertoy.com/view/4dGyDm\n// \"Input - Keyboard\" by iq: https://www.shadertoy.com/view/lsXGzf\n// \"Input - Mouse\" by iq: https://www.shadertoy.com/view/Mss3zH\n\n// Shows how to use the mouse input (only left button supported):\n//\n//      mouse.xy  = mouse position during last button down\n//  abs(mouse.zw) = mouse position during last button click\n// sign(mouze.z)  = button is down\n// sign(mouze.w)  = button is clicked\n\nconst int K_NUMP_0 = 96;\nconst int K_NUMP_1 = 97;\nconst int K_NUMP_2 = 98;\nconst int K_NUMP_3 = 99;\nconst int K_NUMP_4 = 100;\nconst int K_NUMP_5 = 101;\nconst int K_NUMP_6 = 102;\nconst int K_NUMP_7 = 103;\nconst int K_NUMP_8 = 104;\nconst int K_NUMP_9 = 105;\n\n#define ID(c) (distance(C, c)<1.)\n#define getState(k)    ((texelFetch( iChannel0, ivec2(k, 0), 0 ).x)>.5)\n#define getKeypress(k) ((texelFetch( iChannel0, ivec2(k, 1), 0 ).x)>.5)\n#define getToggle(k)   ((texelFetch( iChannel0, ivec2(k, 2), 0 ).x)>.5)\n        \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame < 2 ) {\n        fragColor = vec4(0);\n        return;\n    }\n    \n    vec2 C = fragCoord;\n    vec4 last = texelFetch(iChannel1, ivec2(C), 0);\n    \n    if(ID(C_MOUSE)){\n    \n        // Mouse\n        if(sign(iMouse.z)>.0)\n            fragColor = iMouse;\n        else\n            fragColor = last;\n        return;\n        \n    }\n    else\n    if(ID(C_CAMERA)){\n    \n        // Numpad\n        fragColor = last;\n        bool isFreeCamera = bool(last.y);\n        \n        if(getKeypress(K_NUMP_0) && sign(iMouse.z)<=.0)fragColor = vec4(last.x, !isFreeCamera, 0, 0);\n        \n        //if(getState(K_NUMP_0))fragColor = vec4(0, true, 0, 0);\n        if(getState(K_NUMP_1))fragColor = vec4(1, true, 0, 0);\n        //if(getState(K_NUMP_2))fragColor = vec4(2, true, 0, 0);\n        if(getState(K_NUMP_3))fragColor = vec4(3, true, 0, 0);\n        //if(getState(K_NUMP_4))fragColor = vec4(4, true, 0, 0);\n        //if(getState(K_NUMP_6))fragColor = vec4(6, true, 0, 0);\n        if(getState(K_NUMP_7))fragColor = vec4(7, true, 0, 0);\n        //if(getState(K_NUMP_8))fragColor = vec4(8, true, 0, 0);\n        //if(getState(K_NUMP_9))fragColor = vec4(9, true, 0, 0);\n        return;\n        \n    }\n    else\n    {\n        // Blank\n        fragColor = vec4(0.0,0.0,1.0,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGSz1.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[654, 738, 768, 768, 1433], [1435, 1461, 1516, 1516, 1669], [1671, 1806, 1858, 1858, 1915], [1917, 1953, 2025, 2122, 2818], [2820, 2820, 2838, 2838, 3233]], "test": "untested"}
{"id": "NdVfzK", "name": "Monterey wannabe", "author": "mrange", "description": "CC0 - Monterey wannabe\nWatching a few streams I enjoy the MacOS Monterey wallpaper. I am a sucker for intense colors.\nHere's my interpretation of the wallpaper in shader form\n", "tags": ["wallpaper", "monterey"], "likes": 41, "viewed": 758, "published": 3, "date": "1658498183", "time_retrieved": "2024-07-30T16:39:21.747612", "image_code": "// CC0 - Monterey wannabe\n// Watching a few streams I enjoy the MacOS Monterey wallpaper\n// I am a sucker for intense colors\n// Here's my interpretation of the wallpaper in shader form\n\n#define RESOLUTION    iResolution\n#define TIME          iTime\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nvec4 alphaBlend(vec4 back, vec4 front) {\n  float w = front.w + back.w*(1.0-front.w);\n  vec3 xyz = (front.xyz*front.w + back.xyz*back.w*(1.0-front.w))/w;\n  return w > 0.0 ? vec4(xyz, w) : vec4(0.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nvec3 alphaBlend(vec3 back, vec4 front) {\n  return mix(back, front.xyz, front.w);\n}\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n  //  Found this somewhere on the interwebs\n  //  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 p) {\n  float a = dot (p, vec2 (127.1, 311.7));\n  return fract(sin(a)*43758.5453123);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.shadertoy.com/view/XslGRr\nfloat vnoise(vec2 p) {\n  vec2 i = floor(p);\n  vec2 f = fract(p);\n    \n  vec2 u = f*f*(3.0-2.0*f);\n\n  float a = hash(i + vec2(0.0,0.0));\n  float b = hash(i + vec2(1.0,0.0));\n  float c = hash(i + vec2(0.0,1.0));\n  float d = hash(i + vec2(1.0,1.0));\n  \n  float m0 = mix(a, b, u.x);\n  float m1 = mix(c, d, u.x);\n  float m2 = mix(m0, m1, u.y);\n  \n  return m2;\n}\n\nfloat heightFactor(vec2 p) {\n  return 2.0*smoothstep(0.0, 1.25, abs(p.x)-0.05)+1.0;\n}\n\nfloat hifbm(vec2 p) {\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nfloat lofbm(vec2 p) {\n  float hf = heightFactor(p);\n  const float aa = 0.5;\n  const float pp = 2.0-0.;\n\n  float sum = 0.0;\n  float a   = 1.0;\n  \n  for (int i = 0; i < 2; ++i) {\n    sum += a*vnoise(p);\n    a *= aa;\n    p *= pp;\n  }\n  \n  return hf*sum;\n}\n\nvec3 offset(float z) {\n  float a = z*0.5;\n  vec2 p = vec2(0.33, 0.1)*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n//  vec2 p = vec2(0.0, 0.0);\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/(2.0*eps);\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/(2.0*eps);\n}\n\nfloat hiheight(vec2 p) {\n  return hifbm(p)-1.8;\n}\n\nfloat loheight(vec2 p) {\n  return lofbm(p)-2.15;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, vec3 npp, vec3 off, float n) {\n  vec2 p = (pp-off*2.0*vec3(1.0, 1.0, 0.0)).xy;\n\n  const vec2 stp = vec2(0.5, 0.33); \n  float he    = hiheight(vec2(p.x, pp.z)*stp);\n  float lohe  = loheight(vec2(p.x, pp.z)*stp);\n\n  float d = p.y-he;\n  float lod = p.y - lohe;\n\n  float aa = distance(pp, npp)*sqrt(1.0/3.0);\n\n  float df = tanh_approx(max(0.225*distance(ro, pp)-0.4, 0.));\n  float hf = mix(0.66, 1.1, df);\n  float gf = tanh_approx(exp(-2.0*lod));\n  float yf = smoothstep(2.5, -1.0, pp.y);\n  vec3 acol = hsv2rgb(vec3(hf, 1.0, mix(0.2, 1.0, df)));\n  vec3 gcol = hsv2rgb(vec3(hf, 1.0, 1.0-gf));\n  \n  float t = smoothstep(aa, -aa, d);\n  t *= mix(1.0, yf, sqrt(df));\n  t = max(t, gf*yf*yf);\n  vec3 col = vec3(0.0);\n  col += acol;\n  col += 0.5*gcol;\n  \n  return vec4(col, t);\n}\n\nvec3 skyColor(vec3 ro, vec3 rd, vec3 nrd) {\n  const vec3 sky = HSV2RGB(vec3(0.66, 0.2, 1.0));\n  return sky;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  vec2 np = p + 2.0/RESOLUTION.y;\n  const float rdd = 2.0;\n  vec3 rd = normalize(-p.x*uu + p.y*vv + rdd*ww);\n  vec3 nrd = normalize(-np.x*uu + np.y*vv + rdd*ww);\n\n  const float planeDist = 1.0-0.4;\n  const int furthest = 12;\n  const int fadeFrom = max(furthest-3, 0);\n\n  const float fadeDist = planeDist*float(fadeFrom);\n  const float maxDist  = planeDist*float(furthest);\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd, nrd);\n\n  vec4 acol = vec4(0.0);\n  const float cutOff = 0.995;\n  bool cutOut = false;\n\n  for (int i = 1; i <= furthest; ++i) {\n    float pz = planeDist*nz + planeDist*float(i);\n\n    float pd = (pz - ro.z)/rd.z;\n\n    vec3 pp = ro + rd*pd;\n    \n    if (pd > 0.0 && acol.w < cutOff) {\n      vec3 npp = ro + nrd*pd;\n\n      vec3 off = offset(pp.z);\n\n      vec4 pcol = plane(ro, rd, pp, npp, off, nz+float(i));\n\n      float nz = pp.z-ro.z;\n      float fadeIn = smoothstep(maxDist, fadeDist, pd);\n      float fadeOut = smoothstep(0.0, planeDist, pd);\n      pcol.w *= fadeIn;\n      pcol.w *= fadeOut;\n\n      acol = alphaBlend(pcol, acol);\n    } else {\n      cutOut = true;\n      acol.w = acol.w > cutOff ? 1.0 : acol.w;\n      break;\n    }\n\n  }\n\n  vec3 col = alphaBlend(skyCol, acol);\n// To debug cutouts due to transparency  \n//  col += cutOut ? vec3(1.0, -1.0, 0.0) : vec3(0.0);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  const mat2 rot = ROT(0.1); \n  float z  = TIME*0.3333;\n  vec3 ro   = offset(z);\n  vec3 dro  = doffset(z); \n  vec3 ddro = ddoffset(z);\n  dro.zy *= rot;\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+2.*ddro), ww));\n  vec3 vv = cross(ww, uu);\n\n  vec3 col = color(ww, uu, vv, ro, p);\n  \n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = vec3(0.0);\n  col = effect(p, q);\n  col += 2.0*smoothstep(4.0, 0.0, TIME+length(p-vec2(0.0, 1.0)));\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVfzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[526, 526, 548, 548, 694], [989, 1049, 1089, 1089, 1248], [1250, 1310, 1350, 1350, 1392], [1394, 1494, 1515, 1515, 1588], [1589, 1689, 1711, 1711, 1760], [1762, 1869, 1895, 1895, 2079], [2081, 2141, 2169, 2235, 2311], [2313, 2373, 2393, 2393, 2475], [2477, 2561, 2583, 2583, 2917], [2919, 2919, 2947, 2947, 3004], [3006, 3006, 3027, 3027, 3258], [3260, 3260, 3281, 3281, 3512], [3514, 3514, 3536, 3536, 3712], [3714, 3714, 3737, 3737, 3818], [3820, 3820, 3844, 3844, 3927], [3929, 3929, 3953, 3953, 3978], [3980, 3980, 4004, 4004, 4030], [4032, 4032, 4100, 4100, 4837], [4839, 4839, 4882, 4882, 4948], [4950, 4950, 5006, 5006, 6338], [6340, 6340, 6369, 6369, 6707], [6709, 6709, 6765, 6765, 7051]], "test": "untested"}
{"id": "sdyfRK", "name": "Shadertoy glitchy logo", "author": "bitless", "description": "Based on Cyberpunk 2077 wallpaper [https://store.kde.org/p/1570955/]", "tags": ["2d", "logo", "glitch", "shadertoy"], "likes": 26, "viewed": 824, "published": 3, "date": "1658471681", "time_retrieved": "2024-07-30T16:39:22.815756", "image_code": "// Author: bitless\n// Title: Shadertoy glitchy logo\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\nconst vec2[103] v = vec2[](vec2(-.286,.5),vec2(-.46,.061),vec2(-.354,-.017),vec2(-.5,-.37),vec2(-.442,-.374),vec2(-.33,-.172),vec2(-.329,.112),vec2(-.385,.112),vec2(-.289,.397),vec2(-.257,.263), //\nvec2(-.231,.263),vec2(-.356,-.314),vec2(-.331,-.37),vec2(-.276,-.073),vec2(-.254,-.081),vec2(-.295,-.357),vec2(-.256,-.288),vec2(-.208,-.017),vec2(-.268,.005),vec2(-.186,.354), //\nvec2(-.193,.1),vec2(-.116,-.033),vec2(-.127,-.366),vec2(-.242,-.345),vec2(-.205,-.053),vec2(-.151,-.099), //\nvec2(-.183,-.161),vec2(-.203,-.263),vec2(-.154,-.268), //\nvec2(.001,.074),vec2(-.066,-.331),vec2(-.11,-.374),vec2(-.113,-.09),vec2(-.034,.082),vec2(.004,.315),vec2(.047,.435), //\nvec2(-.036,.013),vec2(-.098,-.124),vec2(-.071,-.275), //\nvec2(.007,.009),vec2(-.044,-.264),vec2(-.021,-.333),vec2(.053,-.264),vec2(.065,-.171),vec2(-.002,-.218),vec2(.004,-.175),vec2(.061,-.146),vec2(.071,-.077),vec2(.015,-.088),vec2(.02,-.052),vec2(.088,-.04),vec2(.094,.009), //\nvec2(.1,.022),vec2(.054,-.371),vec2(.07,-.447),vec2(.097,-.216),vec2(.155,-.437),vec2(.163,-.316),vec2(.126,-.202),vec2(.187,-.144),vec2(.213,.059), //\nvec2(.113,-.062),vec2(.105,-.117),vec2(.118,-.142),vec2(.166,-.085),vec2(.184,.004), //\nvec2(.27,.349),vec2(.246,.159),vec2(.187,.221),vec2(.173,.094),vec2(.236,.077),vec2(.167,-.38),vec2(.278,-.367),vec2(.303,-.242),vec2(.213,-.303),vec2(.262,.077),vec2(.291,.059),vec2(.31,.17),vec2(.268,.142),vec2(.296,.418), //\nvec2(.339,.13),vec2(.289,-.115),vec2(.318,-.227),vec2(.288,-.348),vec2(.36,-.412),vec2(.397,-.119),vec2(.38,.156), //\nvec2(.352,.077),vec2(.313,-.112),vec2(.343,-.289),vec2(.379,-.147), //\nvec2(.39,.168),vec2(.405,-.121),vec2(.432,-.212),vec2(.366,-.453),vec2(.33,-.491),vec2(.383,-.5),vec2(.454,-.237),vec2(.5,.215),vec2(.487,.422),vec2(.47,.124),vec2(.432,-.052),vec2(.389,.31));\n\n\n//Inigo Quiles article \"Simple color palettes\" \n//https://iquilezles.org/articles/palettes/\n#define pal(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) )\n\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n////////////////////////////////////////\n\nfloat noise11( in float f ) //gradient noise 1D \n{\n    float i = floor( f );\n    f -= i;\n    \n    float u = f*f*(3.-2.*f);\n\n    return mix(hash11( i ), hash11( i + 1. ) , u);\n}\n\nfloat noise12( in vec2 f ) //gradient noise 2D\n{\n    vec2 i = floor( f );\n    f -= i;\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( hash12( i + vec2(0,0) ), \n                     hash12( i + vec2(1,0) ), u.x),\n                mix( hash12( i + vec2(0,1) ), \n                     hash12( i + vec2(1,1) ), u.x), u.y);\n}\n\n\n// IQ's polygon distance field function\n// https://iquilezles.org/articles/distfunctions2d/\n// https://www.shadertoy.com/view/wdBXRW\n\nfloat sdPolygon( in vec2 p, in int f, in int num )\n{\n    //const int num = v.length();\n    float d = dot(p-v[f],p-v[f]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j+f] - v[i+f];\n        vec2 w =    p - v[i+f];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i+f].y, \n                            p.y <v[j+f].y, \n                            e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s=-s;  \n    }\n    \n    return s*sqrt(d);\n}\n\nfloat logo(vec2 gr) //drawing logo\n{\n    float d = sdPolygon(gr,0,10); //S\n    d = min (d,sdPolygon(gr,10,10)); //h\n    d = min (d,sdPolygon(gr,20,6)); //a\n    d = max (d,-sdPolygon(gr,26,3));\n    d = min (d,sdPolygon(gr,29,7)); //d\n    d = max (d,-sdPolygon(gr,36,3));\n    d = min (d,sdPolygon(gr,39,13)); //e\n    d = min (d,sdPolygon(gr,52,9)); //r\n    d = max (d,-sdPolygon(gr,61,5));\n    d = min (d,sdPolygon(gr,66,14)); //t\n    d = min (d,sdPolygon(gr,80,7)); //o\n    d = max (d,-sdPolygon(gr,87,4));\n    return min (d,sdPolygon(gr,91,12)); //y\n}\n\nvoid mainImage( out vec4 O, in vec2 g )\n{\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)/r.y;\n    \n    float xs = noise11 (floor(uv.y*20.))*sin(floor(uv.y*.5)+iTime); //x-shift for big horizontal stripes\n    xs*=xs*xs;\n    \n    float x = (uv.x+xs*.05)*20. //vertical stripes\n        , cl = floor(x);        //stripe id\n    x -= cl;                    //stripe local x\n    \n    float h = hash11(cl-1.);    //color of previous stripe\n    h = mix(hash11(cl),h,step(x,sin(iTime+h*10.)*.4+.4));  //mixing color of current and previous stripe to draw moving stripes\n    \n    h = sin(h*.7-noise11(uv.x-iTime*1.2)*2.)*.5+.5;  //adding big moving noise for stripes color\n    \n    vec3 C = pal(h,vec3(.8,.5,.3),vec3(.4,1,.7),vec3(1,.2,.6),vec3(.9,.07,.7))*.5-.45; //define background color using palette function\n    \n    C = C * (.5 + sin(uv.y*600.)*.5); //add small horizontal strips (like on analog TV)  \n    \n    cl = noise11 (floor((uv.x+xs*.05)*200.)+iTime)*noise12(vec2(uv.x*5.,iTime)); // adding cyan vertical stripes to background\n    C = mix (C, vec3(0,1,1),cl*cl*cl*.6);\n\n    cl = noise11 (floor(uv.y*200.)+iTime)*noise12(vec2(uv.y*10.,0)+iTime); //adding orange horizontal stripes to background\n    cl*=cl*cl;\n    C = mix (C, vec3(1,.7,0),cl);\n\n    vec2 xy = uv+vec2((xs-cl)*.05+.1,0); //define the coords for the logo with offsets on the horizontal wide stripes and thin orange ones \n    \n    h = noise11(iTime); //adding periodical \"block coding artifacts\"\n    x = 20.;      //num of cells\n    h = h*h*h*noise12(floor(uv*x)); //noise strength\n    xy = ((xy*x-floor(xy*x))*(1.-h*.6)+floor(xy*x))/x; //scale cells\n    \n    ///// drawing logo background\n    cl = noise11(floor(iTime*20.)/4.+.2)*6.28; //strength of the logo shift\n    x = logo(xy*vec2(.5-noise11(iTime)*.1,2.)+vec2(-1,1)*.01+vec2(sin(cl),cos(cl))*.01);  //distance field to logo (scale + shift relative to foreground + noise shift) \n    C = mix (C, vec3(0), smoothstep(.5,.0,x)*.5);   //black shadow on background \n    C = mix (C, vec3(smoothstep(.01,-.03,x),0,0), smoothstep(.005,0.,x-.01)); //logo \"side faces\" (black to red)\n    C = mix (C, vec3(.8,0,.8), smoothstep(.005,-.005,abs(x-.02))*h*.5);        // cyan outline \n\n    ///// drawing logo foreground\n    cl = noise11(floor(iTime*20.)/4.)*6.28; // //strength of the logo shift (and 0.2 seconds earlier than the backgroud)\n    x = logo(xy*vec2(.5-noise11(iTime)*.1,2.)+vec2(sin(cl),cos(cl))*.01); //distance field to logo \n    C = mix (C, vec3(1.-xs,.8-xs*.4,xs*.2), smoothstep(.1,0.,x)*.1); //yellow glow\n    C = mix (C, vec3(1.-xs,.8-xs*.5,xs*.2), smoothstep(.005,0.,x)); //foreground\n    C = mix (C, vec3(0), smoothstep(2./r.y,0.,abs(x-.002)-.001)*.7); //black outline\n    C = mix (C, vec3(.0,.8,.8), smoothstep(.005,-.005,abs(x-.02))*.5*h);   //magenta outline\n\n    C *= (.9 + sin(uv.y*600.)*.2); //add small horizontal strips (like on analog TV)  \n    O = vec4(C,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyfRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2282, 2363, 2386, 2386, 2471], [2473, 2473, 2495, 2495, 2613], [2656, 2656, 2706, 2706, 2832], [2834, 2834, 2882, 2882, 3159], [3296, 3296, 3348, 3382, 3963], [3965, 3965, 4001, 4001, 4516], [4518, 4518, 4559, 4559, 7419]], "test": "untested"}
{"id": "7dKfzy", "name": "building reflect", "author": "jorge2017a2", "description": "building reflect", "tags": ["buildingreflect"], "likes": 12, "viewed": 243, "published": 3, "date": "1658434551", "time_retrieved": "2024-07-30T16:39:23.864951", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//building reflect----21/jul/2022\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 edificioA(vec3 p, float alto, float opcol)\n{\tvec2 res= vec2(9999.0, -1.0);  \n\n    p.x=abs(p.x)-20.0;\n    float d1= sdBox(p, vec3(10.8,alto,10.0) );\n    float d1a= sdBox(p-vec3(0.0,-3.0,0.0), vec3(11.25,0.125,11.25) );\n    float d1b= sdBox(p-vec3(0.0,-4.0,0.0), vec3(11.25,0.125,11.25) );\n    float d1c= sdBox(p-vec3(0.0,alto,0.0), vec3(11.25,0.125,11.25) );\n    \n    p.xy= opRep2D( p.xy, vec2(3.0,3.0) );\n    //ventanas\n    float d2a= sdBox(p-vec3(0.0,0.0,0.0), vec3(1.0,1.0,15.0) );\n    float d1d= sdBox(p-vec3(0.0,0.0,0.0), vec3(0.15,1.0,15.0) ); ///division\n    float difd1= Difference(d1, d2a);\n    float d1i=Intersect(d1, d2a);\n    d1d=Intersect(d1, d1d);\n    res =opU2(res, vec2(d1,opcol));\n    res =opU2(res, vec2(d1a,1.0));\n    res =opU2(res, vec2(d1b,1.0));\n    res =opU2(res, vec2(d1c,1.0));\n    res =opU2(res, vec2(d1i,201.0));\n    res =opU2(res, vec2(d1d,0.0));    \n    return res;\n}   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\t\n    //calle\n    p.y-=5.0;\n    p.z= opRep1D( p.z, 30.0 );\n    float d1a= sdBox(p-vec3(0.0,-14.0,0.0), vec3(30.0,0.5,20.0) );\n    float d1b= sdBox(p-vec3(0.0,-14.0,0.0), vec3(0.25,1.0,8.0) );\n    d1b=Intersect(d1a, d1b);\n    \n    res =opU2(res, vec2(d1a,9.0));\n    res =opU2(res, vec2(d1b,8.0));\n    \n    p=p0;\n    p.y-=5.0;\n    vec2 resA= edificioA(p,16.0,2.0);\n    vec2 resB= edificioA(p-vec3(.0,-4.0,-30.),10.0,11.0);\n    vec2 resC= edificioA(p-vec3(.0,-4.0,40.),30.0,16.);\n    res =opU2(res, resA);\n    res =opU2(res, resB);\n    res =opU2(res, resC);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color<40) {colobj=getColor(int( id_color)); return colobj;}\n   if(id_color==201) {return getColor(int(1));} \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd) \n{   vec3 p,colobj,col = vec3(0.0),result;\n\tvec2 t;\n    vec3 rcol=vec3(0);\n    \n    for(int i=0; i<3;i++)\n    {  vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n       if(hit.x<MAX_DIST)\n       { // geometry, hit position, normal, reflect\n\t    p =ro + rd * hit.x;\n        vec3 nor=GetNormal(p);\n\t\tvec3 ref = reflect(rd, nor);\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        \n        result= lightingv3(nor, p,light_pos1,rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd,ro,colobj,hit.x)*light_color2;\n        rcol= result/2.0;\n        rcol= (ACESFilm(rcol)+linear2srgb(rcol)+rcol+ exposureToneMapping(3.0, rcol))/4.0 ; \n             // set up the ray orgin and direction for reflection.\n\t\tro = p + nor*0.001;\n        if (int(hit.y)==201) { rd =ref; rcol-=vec3(0.15); }\n              // lighten intensity on each successive reflect.\n\t\tif(i == 0) col = rcol;\n\t\telse col = mix(rcol, col, 1.0 - exp(-0.8*float(i)));\n\t  } \n     else if(hit.x>MAX_DIST)\n    col = mix(render_sky_color(rd), col, 1.0 - exp(-0.8*float(i)));\n\t}\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,80.0);\n    \n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,-17.0,-60.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd,radians(-5.0+(-20.0+20.0*sin(t*0.25))));\n   \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKfzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 508, 508, 529], [530, 530, 562, 562, 646], [648, 648, 692, 692, 719], [720, 720, 760, 760, 787], [788, 788, 833, 833, 861], [863, 863, 899, 899, 944], [945, 945, 984, 984, 1028], [1030, 1030, 1064, 1064, 1160], [1161, 1161, 1195, 1195, 1286], [1287, 1287, 1321, 1321, 1412], [1414, 1414, 1463, 1463, 2314], [2319, 2319, 2344, 2344, 2983], [2985, 2985, 3009, 3009, 3171], [3173, 3173, 3221, 3221, 3500], [3502, 3502, 3546, 3546, 3867], [3869, 3869, 3906, 3906, 4163], [4165, 4165, 4255, 4255, 5203], [5205, 5205, 5237, 5237, 5437], [5439, 5439, 5509, 5509, 5646], [5648, 5648, 5675, 5675, 5764], [5766, 5766, 5824, 5824, 5872], [5874, 5874, 5897, 5897, 6009], [6011, 6011, 6043, 6043, 7114], [7116, 7116, 7173, 7173, 7687]], "test": "untested"}
{"id": "7sKfRG", "name": "3D Grid Crawler", "author": "mla", "description": "Inspired by: [url]https://www.shadertoy.com/view/sdyfRy[/url], with the \"spider\" crawling around a 3D grid.\n\nJust computes distances for a single octant (so checks 27 segments rather than 125).", "tags": ["3d", "spider", "crawler"], "likes": 20, "viewed": 348, "published": 3, "date": "1658419994", "time_retrieved": "2024-07-30T16:39:25.173452", "image_code": "////////////////////////////////////////////////////////////////\n//\n// 3D Grid Crawler\n// Inspired by https://www.shadertoy.com/view/sdyfRy\n//\n// Mouse: moves viewpoint\n// <up>/<down>: zoom in/out\n// 'g': show grid edges\n// 'r': autorotation\n//\n////////////////////////////////////////////////////////////////\n\nbool dorotate = true;\nbool dotranslate = false;\n\nfloat vradius = 0.1; // Vertex radius\nfloat eradius = 0.05; // Edge radius\nfloat maxdist = 20.0;\n\nfloat eyedist = 6.0;      // Distance of eye from origin\nvec3 light = vec3(0,2,1); // Light direction\nint numsteps = 200;       // Maximum raymarching steps\nfloat precis = 1e-3;      // Raymarching precision\n\nfloat de(vec3 z, out int type) {\n  int N = 2; // Box size is 2N+1 \n  \n  // Firstly, compute distance to grid vertices & edges.\n  type = 0;\n  vec3 cell = round(z);\n  float dist = length(z-cell)-vradius;\n  if (key(CHAR_G)) {\n    // Show grid edges\n    float dist1 = length(z.xy-cell.xy);\n    dist1 = min(dist1,length(z.yz-cell.yz));\n    dist1 = min(dist1,length(z.zx-cell.zx));\n    dist1 -= 0.6*eradius;\n    if (dist1 < dist) { dist = dist1; type = 2; }\n  }\n  // Find centre of crawler\n  vec3 p = vec3(2,0,0);\n  p.xy = rotate(p.xy,iTime);\n  p.yz = rotate(p.yz,0.618*iTime);\n  // If outside crawler sphere, return\n  if (dot(z-p,z-p) > float((N+1)*(N+1))) return dist;\n  vec3 q = round(p); // Nearest grid point to crawler\n  z -= p; q -= p; // Rebase at p\n  vec3 signs = sign(z); // Defines octant\n  float maxlen = float(N)+0.5; // Max length of length\n  float dist2 = 1e8;\n  for (int i = 0; i <= N; i++) {\n    for (int j = 0; j <= N; j++) {\n      for (int k = 0; k <= N; k++) {\n        vec3 r = q+vec3(i,j,k)*signs;\n        if (dot(r,r) > maxlen*maxlen) break;\n        dist2 = min(dist2,segment2(z,vec3(0),r));\n      }\n    }\n  }\n  dist2 = sqrt(dist2) - eradius;\n  if (dist2 < dist) { dist = dist2; type = 1; }\n  return dist;\n}\n\nfloat de(vec3 z) {\n  int type;\n  return de(z,type);\n}\n\nvec3 getbackground(vec3 r) {\n  if (key(CHAR_B)) return vec3(0);\n  return vec3(1,1,0.8);\n}\n\nvec3 getbasecolor(int type) {\n  if (type == 0) return vec3(0.2);\n  if (type == 1) return 0.2+0.8*vec3(1,0,0);\n  if (type == 2) return 0.2+0.8*vec3(0,0,1);\n  if (type == 3) return 0.2+0.8*vec3(1,1,0);\n  return vec3(1,0,1);\n}\n\nfloat march(vec3 q, vec3 r) {\n  float t = 0.01; // Total distance so far.\n  for (int i = 0; i < numsteps; i++) {\n    //assert(i < 50);\n    vec3 p = q+t*r;\n    float d = de(p);\n    if (abs(d) < precis) return t;\n    t += 0.8*d;\n    // We might go backwards!\n    if (t < 0.0 || t > maxdist) break;\n  }\n  return -1.0;\n}\n\n// Get the normal of the surface at point p.\nvec3 getnormal(vec3 p, float t) {\n  float eps = 1e-3;\n  vec2 e = vec2(eps,0);\n  return normalize(vec3(de(p + e.xyy) - de(p - e.xyy),\n                        de(p + e.yxy) - de(p - e.yxy),\n                        de(p + e.yyx) - de(p - e.yyx)));\n}\n\n// Rotate according to mouse position\nvec3 transformframe(vec3 p) {\n  if (iMouse.x > 0.0) {\n    // Full range of rotation across the screen.\n    float phi = (2.0*iMouse.x-iResolution.x)/iResolution.x*PI;\n    float theta = (2.0*iMouse.y-iResolution.y)/iResolution.y*PI;\n    p.yz = rotate(p.yz,theta);\n    p.zx = rotate(p.zx,-phi);\n  }\n  // autorotation\n  if (dorotate) {\n      float t = iTime;\n      p.yz = rotate(p.yz,-t*0.05);\n      p.zx = rotate(p.zx,-t*0.0618);\n  }\n  return p;\n}\n\n// Follow ray from q, direction r.\nvec3 raycolor(vec3 q, vec3 r) {\n  float t = march(q,r);\n  if (t < 0.0) return getbackground(r);\n  vec3 p = q+t*r;\n  vec3 normal = getnormal(p,t);\n  int type = 0;\n  de(p,type);\n  vec3 color = getbasecolor(type);\n  float ambient = 0.3;\n  vec3 lightdir = normalize(light);\n  float diffuse = 0.7*clamp(dot(normal,lightdir),0.0,1.0);\n  color *= ambient+ diffuse;\n    if (!key(CHAR_S)) {\n    float specular = pow(max(0.0,dot(reflect(lightdir,normal),r)),4.0);\n    color += specular;\n  }\n  if (!key(CHAR_F)) color = mix(color,getbackground(r),clamp(t/(maxdist),0.0,1.0));\n  return color;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n  int AA = 1;\n  //if (key(CHAR_A)) AA = 2;\n  dorotate = !key(CHAR_R);\n  eyedist += (0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec3 eye = vec3(0,0,eyedist);\n  eye = transformframe(eye);\n  light = transformframe(light);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = (2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y;\n      vec3 ray = vec3(z,-2);\n      ray = transformframe(ray);\n      ray = normalize(ray);\n      col += raycolor(eye,ray);\n    }\n  }\n  col /= float(AA*AA);\n  col = pow(col,vec3(0.4545)); // Gamma\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.14159;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;;\n}\n\nconst int KEY_ALT = 18;\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )\n\n// Squared distance from p to segment (a,b)\nfloat segment2(vec3 p, vec3 a, vec3 b) {\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  vec3 t = pa - ba * h;\n  return dot(t,t);\n}\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nfloat hash(vec2 p) {\n  uint ux = uint(int(p.x));\n  uint uy = uint(int(p.y));\n  uint h = ihash(ux^(uy<<16));\n  return float(h)/pow(2.0,32.0);\n}", "buffer_a_code": "void mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x); // Column number\n  int j = int(uv.y); // Row\n  if (iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (j == 0) {\n    // First row - key count\n    // Do key repeat here as well?\n    float w1 = keystate(i,0).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      // Don't count key changes when ALT pressed\n      if (keystate(KEY_ALT,0).x == 0.0 && w1 != 0.0) {\n        t.x++; t.y = iTime;\n      }\n    }\n    // Key repeat - only when shader is running!\n    // Should have longer pause after first key press.\n    if (t.w != 0.0 && keystate(KEY_ALT,0).x == 0.0 && iTime-t.y > 0.25) {\n      t.x++; t.y = iTime;\n    }\n  }\n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[667, 667, 699, 699, 1890], [1892, 1892, 1910, 1910, 1945], [1947, 1947, 1975, 1975, 2036], [2038, 2038, 2067, 2067, 2261], [2263, 2263, 2292, 2292, 2579], [2581, 2626, 2659, 2659, 2872], [2874, 2912, 2941, 2941, 3356], [3358, 3393, 3424, 3424, 3975], [3977, 3977, 4028, 4028, 4678]], "test": "untested"}
{"id": "NdKBzy", "name": "Kuwahara Filter: Multi-Pass", "author": "tida", "description": "Modification of the following shader: https://www.shadertoy.com/view/3tKXWy\nDid make a short video on youtube to describe the functionality of kernel convolve:\nhttps://www.youtube.com/watch?v=ytPIjZSJDVA", "tags": ["filter", "kuwahara", "multipass"], "likes": 15, "viewed": 561, "published": 3, "date": "1658415865", "time_retrieved": "2024-07-30T16:39:26.018194", "image_code": "#define ACTIVATE_FILTER 1\n#define X_RANGE 20.0\n#define Y_RANGE\t5.0\n\n\n// 2; for Classical Kuwahara\n#define COUNT 4     \n\n// 0.5 for smoothing  1.0 no smoothing\n#define SMOOTH 1.0\n\nfloat GetPixelAngle(vec2 uv)\n{\n    float GradientX = 0.0;\n    float GradientY = 0.0;\n    \n    float SobelX[9] = float[9](-1.0, -2.0, -1.0, \n        \t\t\t\t0.0, 0.0, 0.0, \n        \t\t\t\t1.0, 2.0, 1.0);\n        \n    float SobelY[9] = float[9](-1.0, 0.0, 1.0,\n        \t\t\t   -2.0, 0.0, 2.0,\n        \t\t\t   -1.0, 0.0, 1.0);\n        \n    int i = 0;\n    \n    for (float x = -1.0; x <= 1.0; x++)\n    {\n        for (float y = -1.0; y <= 1.0; y++)\n        {\n            vec2 offset = vec2(x,y);\n            vec2 Coords = uv + offset;\n            vec3 PixelColor = texture(iChannel0, Coords).rgb;\n            float PixelValue = dot(PixelColor, vec3(0.3, 0.59, 0.11));\n            \n            GradientX += PixelValue * SobelX[i];\n            GradientY += PixelValue * SobelY[i];\n            i++;\n        }\n    }\n    \n    return atan(GradientY/GradientX);\n}\n\nvec4 GetKernelMeanAndVariance(vec2 uv, vec4 Range, mat2 RotationMatrix)\n{\n    vec3 Mean = vec3(0.0);\n    vec3 Variance = vec3(0.0);\n    float Samples = 0.0;\n    \n    for (float x = Range.x; x <= Range.y; x++)\n    {\n            // The outer row pixels can be weighted by the Smooth Slider which give a more smoother appearance at abput 0.5\n            float fsmooth = 1.0f;\n            if (abs(x) == abs(Range.x-Range.y)) {fsmooth = SMOOTH;} \n            \n         \n        for (float y = Range.z; y <= Range.w; y++)\n        {            \n            vec2 offset = vec2(0.0);\n            \n            offset = vec2(x,y) * RotationMatrix;\n\n            \n            vec2 Coords = (uv + offset) / iResolution.xy;\n            vec3 PixelColor = texture(iChannel0, Coords).rgb*fsmooth;\n            \n            Mean+= PixelColor;\n            Variance += PixelColor * PixelColor;\n            Samples = Samples +1.0f * fsmooth;\n        }\n    }\n    \n    Mean /= Samples;\n    Variance = Variance / Samples - Mean * Mean;\n    \n    float TotalVariance = Variance.r + Variance.g + Variance.b;\n    return vec4(Mean.r, Mean.g, Mean.b, TotalVariance);\n}\n\nvec3 KuwaharaFilter(vec2 uv)\n{    \n    vec4 Range;\n    vec4 FinalColorMin = vec4(0.0f);\n    float MinVariance = 999.9;\n    \n    float Angle = GetPixelAngle(uv);\n    \n    for (int i = 1; i < COUNT; i = i + 1) {\n        float Angle0 = Angle + 3.1515f*2.0f*float(i-1)/float(COUNT);           \n        mat2 RotationMatrix = mat2(cos(Angle0), -sin(Angle0),\n                               sin(Angle0), cos(Angle0));  \n        Range = vec4(0.0, X_RANGE, 0, Y_RANGE);\n        vec4 MeanAndVariance1 = GetKernelMeanAndVariance(uv, Range, RotationMatrix);\n    \n        Range = vec4(0.0, X_RANGE, -Y_RANGE, 0.0);\n        vec4 MeanAndVariance2 = GetKernelMeanAndVariance(uv, Range, RotationMatrix);            \n\n        if (MeanAndVariance1.w < MinVariance) { FinalColorMin = MeanAndVariance1; MinVariance = MeanAndVariance1.w;}\n        if (MeanAndVariance2.w < MinVariance) { FinalColorMin = MeanAndVariance2; MinVariance = MeanAndVariance2.w;}\n    }\n    return FinalColorMin.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec3 Color = vec3(0.0);\n    \n     #if ACTIVATE_FILTER > 0\n    Color = KuwaharaFilter(fragCoord);\n    #else \n    Color = texture(iChannel0, fragCoord/iResolution.xy).rgb;\n    #endif\n    fragColor = vec4(Color.rgb, 1.);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[179, 179, 209, 209, 1018], [1020, 1020, 1093, 1093, 2156], [2158, 2158, 2188, 2188, 3128], [3130, 3130, 3187, 3187, 3414]], "test": "untested"}
{"id": "7syfWz", "name": "Triangle Grid Spiral Weave", "author": "Shane", "description": "Utilizing a 2D simplex grid to produce an animated interlinked three pronged spiral pattern.", "tags": ["2d", "grid", "triangle", "spiral", "bump", "weave", "triskelion"], "likes": 64, "viewed": 637, "published": 3, "date": "1658413206", "time_retrieved": "2024-07-30T16:39:32.794077", "image_code": "/*\n\n    Triangle Grid Spiral Weave\n    --------------------------\n    \n    Utilizing a 2D simplex grid to produce an animated interlinked three \n    pronged spiral pattern. I guess another way to put it would be \n    unwrapping a well known icosahedral weave pattern and placing it on a \n    2D plane. :)\n    \n    I love perusing images of various mathematical objects online. Among\n    my favorites are polyhedral weaves. Anyone who's done this will know\n    that descriptions of the construction process are hard to come by, so \n    I'm always left trying to figure it out on my own. Thankfully, I enjoy \n    that kind of thing. Icosahedral based weaves are easier to decipher, \n    since they consist of equilateral spherical triangles, which means you \n    can usually map them to a 2D equilateral triangle grid.\n    \n    With the aforementioned in mind, the purpose of this particular example \n    was to work within the confines of a simple 2D simplex space in \n    preparation for conversion to a 3D icosahedral setting. Rightly or\n    wrongly, I made the decision not to use Bezier curves, since it'd make \n    3D conversion at an acceptable frame rate very difficult.\n    \n    Constructing the spiral objects in each cell using basic distance field\n    shapes -- like circles and triangles -- involved more trial and error \n    than I had hoped, but it turned out to be a relatively simple process \n    in the end.\n    \n    I wasn't going to post a 2D version, but after putting this together, I \n    got bored and added highlights and a few other things until it looked \n    presentable. I'll post the icosaheral version next... unless I get \n    sidetracked with some interesting Shadertoy post. :)\n    \n    \n    \n    Other examples:\n    \n    // A relatively simple 3D weave, and one of the many really \n    // nice Shadertoy examples that slipped under the radar.\n    Moorish Rose - athibaul\n    https://www.shadertoy.com/view/tdVfDz\n\n    // I made a much simpler interlocked 2D hexagonal pattern a while ago.\n    Hexagonal Interlacing - Shane\n    https://www.shadertoy.com/view/llfcWs\n\n\n*/\n\n// Inner object color - Orange: 0, Green: 1.\n#define COLOR 0\n\n// Variable width edges.\n//#define VARIABLE_WIDTH\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smin(vec2 a, vec2 b, float k){\n\n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n/*\n// Commutative smooth maximum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nvec2 smax(vec2 a, vec2 b, float k){\n    \n   vec2 f = max(vec2(0), 1. - abs(b - a)/k);\n   return max(a, b) + k*.25*f*f;\n}\n*/\n\n\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning. By the way, this\n// will partition all repeat grid triangles, not just equilateral ones.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Triangle scale: Smaller numbers mean smaller triangles, oddly enough. :)\nfloat scale = 1./3.;\n\nfloat gTri;\n\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    // Rectangle scale.\n    vec2 rect = (vec2(1./.8660254, 1))*scale;\n    // Skewing half way along X, and not skewing in the Y direction.\n    vec2 sk = vec2(rect.x*.5, 0)/scale; // 12 x .2\n\n    // Skew the XY plane coordinates.\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //gTri = p.x/rect.x < -p.y/rect.y? 1. : -1.;\n    // Base on the bottom (-1.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 1. : -1.;\n   \n    // Puting the skewed coordinates back into unskewed form.\n    p = unskewXY(p, sk);\n    \n \n    // Vertex IDs for each partitioned triangle.\n    if(gTri<0.){\n        vID = vec2[3](vec2(-.5, .5), vec2(.5, -.5), vec2(.5));\n    }\n    else {\n        vID = vec2[3](vec2(.5, -.5), vec2(-.5, .5), vec2(-.5));\n    }\n    \n    // Triangle vertex points.\n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // Equilateral equivalent to: (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n    \n    // Specific centered triangle ID.\n    ctr = vID[2]/3.; //(vID[0] + vID[1] + vID[2])/3.;//vID[2]/2.;\n    id += ctr;\n    // Not used here, but for jigsaw pattern creation, etc, the vertex IDs\n    // need to be correctly centered too.\n    //vID[0] -= ctr; vID[1] -= ctr; vID[2] -= ctr; \n\n\n    // Triangle local coordinates (centered at the zero point) and \n    // the central position point (which acts as a unique identifier).\n    return vec4(p, id);\n}\n\n// IQ;s signed distance to an equilateral triangle.\n// https://www.shadertoy.com/view/Xl2yDW\nfloat sdEqTri(in vec2 p, in float r){\n\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if(p.x + k*p.y>0.) p = vec2(p.x - k*p.y, -k*p.x - p.y)/2.;\n    p.x -= clamp(p.x, -2.*r, 0.);\n    return -length(p)*sign(p.y);\n}\n\nfloat dist(vec2 p){\n    \n    return length(p);\n    \n    //p = abs(p);\n    //return max(p.y*.8660254 + p.x*.5, p.x);\n\n}\n\n//////////\n// Rendering a colored distance field onto a background. I'd argue that\n// this one simple function is the key to rendering most vector styled\n// 2D Photoshop effects onto a canvas. I've explained it in more detail\n// before. Here are the key components:\n//\n// bg: background color, fg: foreground color, sf: smoothing factor,\n// d: 2D distance field value, tr: transparency (0 - 1).\nvec3 blend(vec3 bg, vec3 fg, float sf, float d, float tr){\n\n     return mix(bg, fg, (1. - smoothstep(0., sf, d))*tr);\n}\n\n\n// Signed distance to a line passing through A and B.\nfloat distLineS(vec2 p, vec2 a, vec2 b){\n\n   b -= a; \n   return dot(p - a, vec2(-b.y, b.x)/length(b));\n}\n\n \n\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec2 p0, vec2 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n \n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    // Global scaling and translation.\n    float gSc = 1.;\n    // Smoothing factor, based on global scaling.\n    float sf = 1./iResolution.y*gSc;\n    // Depending on perspective; Moving the oject toward the bottom left, \n    // or the camera in the north easterly (top right) direction. \n    vec2 p = rot2(3.14159/12.)*uv*gSc - vec2(-1, -.57735*0.)*iTime/50.;\n    \n \n    // Global coordinate copy.\n    vec2 oP = p;\n    \n    // Light direction.\n    vec2 ld = normalize(vec2(-1, -1.5));\n\n\n    // Cell coordinate, ID and triangle orientation id.\n    // Cell vertices and vertex ID.\n    vec2[3] v, vID;\n    \n    // Returns the local coordinates (centered on zero), cellID, the \n    // triangle vertex ID and relative coordinates.\n    scale = 1./3.;\n    vec4 p4 = getTriVerts(oP, vID, v);\n    p = p4.xy;\n    vec2 triID = p4.zw; \n    \n    // Background cell triangle and highlight triangle sample.\n    vec2 qt = p*vec2(1, gTri);\n    float tr = (max(abs(qt.x)*.8660254 + qt.y*.5, -qt.y));\n    qt = (p - ld*.005)*vec2(1, gTri);\n    float trHi = (max(abs(qt.x)*.8660254 + qt.y*.5, -qt.y));\n     \n\n    \n    // Vertices and corresponding highlight.\n    float vert = 1e5, vertHi = 1e5;\n    vec2[3] mid, midA, midB;\n    float sL = length(v[0] - v[1]);\n    // Larger numbers push the points toward edges, but bring the rings closer.\n    float offs = 1./(8. + sin(iTime/3.)*4.); \n    \n    // Spiral thickness factor.\n    float th = 0.; \n    \n    // Triangle center: Trivial here.\n    vec2 cntr = vec2(0); //(v[0] + v[1] + v[2])/3.;\n \n    \n    // Nearest vertex, and edge mid-points and offsets on either side.\n    for(int i = 0; i<3; i++){\n        \n        int ip1 = (i + 1)%3;\n        \n        // Nearest vertex point.\n        vert = min(vert, length(p - v[i]));\n        vertHi = min(vertHi, length(p - ld*.005 - v[i]));\n        \n        // Mid edge point, and complimentary offsets.\n        mid[i] = mix(v[i], v[ip1], .5);\n        midA[i] = mix(v[i], v[ip1], .5 - offs);\n        midB[i] = mix(v[i], v[ip1], .5 + offs);\n\n    }  \n    \n    \n    // The two cell objects (top and bottom). Each consist of curved \n    // spiral arms attached to a central shape.\n    vec2 obj = vec2(1e5); \n    vec2 objHi = vec2(1e5); \n    \n    // Creating three spiral arms. How you do that is up to you. I've\n    // rendered three arcs centered on the triangle center and cutting\n    // offset mid-points on each edge. I could have taken a faster\n    // polar approach, but was using the process for nonsymmetrical \n    // examples... I won't bore you with the details, suffice to say \n    // that this is not a processor intensive example anyway and I'll \n    // make the conversion later.\n    //\n    for(int i = 0; i<3; i++){\n        \n        int ip2 = (i + 2)%3;\n        \n        // The origin and radius of the circle that will become the\n        // spiral arc for this edge. It's centered just off the midway\n        // point, and its radius is the distance from the triangle cell\n        // center to a point on the other side.\n        vec2 o = midB[i];\n        float r = length(midA[0]);\n        \n        // The bottom arcs.\n        vec2 q = p;\n        float ring = abs(dist(q - o) - r); // Arc, or ring.\n        // Cutting the arc in half by restricting it to one third of the triangle.\n        // By the way, there are only three partitions needed per sample, and I'm \n        // calculating six all up, which is wasteful and lazy, but not too costly.\n        // Either way, I'll fix it up later.\n        ring = max(ring, max(distLineS(q, cntr, mid[i]), \n                             distLineS(q, mid[ip2], cntr))); // \n        obj.x = min(obj.x, ring); // Bottom spiral arm object.\n        \n        // For the top spirals, we reflect across the X-axis -- You can \n        // see this visually. Practically speaking, it means flipping the\n        // X-coordinate and using the same functions again.\n        q *= vec2(-1, 1);\n        ring = abs(dist(q - o) - r);\n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                              distLineS(q, mid[ip2], cntr)));\n        obj.y = min(obj.y, ring); // Top spiral arm object.\n \n        // Highlighting sample calculations. Doing the same as above, but \n        //at a slightly offset position in the direction of the light.\n        q = p - ld*.005;\n        ring = abs(dist(q - o) - r);\n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                             distLineS(q, mid[ip2], cntr)));\n        objHi.x = min(objHi.x, ring);\n \n        q *= vec2(-1, 1); \n        ring = abs(dist(q - o) - r); \n        ring = max(ring, max(distLineS(q, cntr, mid[i]),  \n                             distLineS(q, mid[ip2], cntr)));\n        objHi.y = min(objHi.y, ring);\n        \n      \n    }\n    \n    // Roughly turning the central triangle to coincide with the changing spiral\n    // arm rotation. It's a hack due to the fact that we're not using Bezier curves, \n    // but it's close enough.\n    float angR = -3.14159/10. + angle(midA[0] - cntr, (v[2] - v[1]));//-3.14159/15.\n    // Central triangle, and its offset sample.\n    vec2 trR = rot2(-angR)*p*vec2(1, gTri);\n    vec2 trRRef = rot2(-angR)*(p*vec2(-1, 1))*vec2(1, gTri);\n    vec2 trM = vec2(sdEqTri(trR, sL/6.), sdEqTri(trRRef, sL/6.));\n    trR = rot2(-angR)*(p - ld*.005)*vec2(1, gTri);\n    trRRef = rot2(-angR)*((p - ld*.005)*vec2(-1, 1))*vec2(1, gTri);\n    vec2 trM2 = vec2(sdEqTri(trR, sL/6.), sdEqTri(trRRef, sL/6.));\n\n    // Adding a bit of thickness. Where you apply this depends on the look you're\n    // after. A lot of it is trial and error.\n    obj -= sL/12.;\n    objHi -= sL/12.;\n    \n    // Smoothly blending the spiral arms with a central shape. It's not mandatory,\n    // but it adds visual interest.\n    //\n    // Triangles.\n    obj = smin(obj, trM - sL/16., .03);//*max(1. - length(p)/sL, 0.)\n    objHi = smin(objHi, trM2 - sL/16., .03);//*max(1. - length(p)/sL, 0.)\n    // Circles: Cheap, but not as neat. \n    //obj = smin(obj, vec2(length(p) - sL/7.), .06);\n    //objHi = smin(objHi, vec2(length(p - ld*.005) - sL/7.), .06);\n  \n\n     // Applying extra thickness here put the emphasis on the triangle.\n     obj -= sL/24.;//*max(1. - length(p)/sL*1.4, 0.);\n     objHi -= sL/24.;//*max(1. - length(p - ld*.005)/sL*1.4, 0.);\n\n \n  \n    /*\n    // Degug. Untangling the weave.\n    if(gTri<0.){ \n        float tmp = ln.x; ln.x = ln.y; ln.y = tmp;\n        tmp = lnHi.x; lnHi.x = lnHi.y; lnHi.y = tmp;\n    }\n    */\n    \n    // Directional gradient values for hightlighting.\n    \n    // Pinwheel objects.\n    vec2 b = max(objHi - obj, 0.)/.005;\n    b = pow(b, vec2(4))*2.5;\n    //\n    // Vertex rivot objects.\n    float bVert = max(vertHi - vert, 0.)/.005;\n    bVert = pow(bVert, 4.)*2.5;\n    //\n    // Background triangles.\n    float bTr = max(trHi - tr, 0.)/.005;\n    //bTr = pow(bTr, 4.)*2.5;\n    \n    // Background line pattern.\n    const float lNum = 96.;\n    float lnD = (rot2(6.2831/3.)*oP).x;\n    float tLns = smoothstep(0., sf, (abs(fract(lnD*lNum - .333) - .5)*2. - .333)/lNum/2.);\n   \n    \n    // Background color.\n    vec3 bCol = vec3(.125);\n    // Outer object color.\n    vec3 oCol = vec3(.1); // Outer rim.\n    // Inner object color\n    #if COLOR == 0\n    vec3 oCol2 = vec3(3, .6, .1);  // Orange.\n    #else\n    vec3 oCol2 = vec3(.2, 1.2, .5); // Green.\n    #endif\n    // Mixing the colors a little.\n    //oCol2 = mix(oCol2, oCol2.xzy, length(p)/length(midA[0])/4.);\n    oCol2 = mix(oCol2, oCol2.xzy, dot(sin(uv*3. - cos(uv.yx*6.)), vec2(.1)) + .2);\n    \n      // Bump color.\n    vec3 bumpCol = vec3(.92, .97, 1);\n  \n    // Apply lines to the colors.\n    oCol2 *= tLns*.5 + .5;\n    bCol *= tLns*.5 + .5;\n    \n    // Initiating the scene to the bump mapped triangle grid background.\n    vec3 col = bCol + bumpCol*bTr*.3;\n    \n   \n\n    // Rendering some triangles onto the background, but leaving the edges.\n    col = blend(col, col*2., sf*2., abs(tr - scale/3.) - .004, 1.);\n    col = blend(col, vec3(0), sf, abs(tr - scale/3.) - .002, 1.);\n    \n   \n    \n    // Resolution factor for shadow width -- It's a hack to make sure shadows\n    // have the same area influence at different resolutions. If you think it's\n    // confusing, you'll get no arguments from me. :)\n    float resF = iResolution.y/450.;\n    \n    // Triangle grid vertices.\n    vert -= .035; // Vertex radius.\n    vertHi -= .035;\n    col = blend(col, vec3(0), sf*8.*resF, vertHi, .5); // Drop shadow.\n    col = blend(col, vec3(0), sf, vert, 1.);  // Dark edge.\n    col = blend(col, oCol + bumpCol*bVert*.3, sf, vert + .005, 1.); // Outer.\n    col = blend(col, vec3(0), sf, vert + .018, 1.); // Inner dark edge.\n    col = blend(col, oCol*.7 + bumpCol*bVert*.2, sf, vert + .018 + .005, 1.); // Inner.\n    col = blend(col, col*1.5, sf*1., abs( vert + .018 + .005 - .007) - .002, 1.); // Highlight.\n\n    \n    // The object layers: Shadows, edges, highlights, etc. Start on the outside,\n    // then work inwards adding layers (using the \"blend\" function) as you go.\n    //\n    // Edge thickness factor.\n    \n    #ifdef VARIABLE_WIDTH\n    th = sL/(9.5 + (sin(iTime/4.)*.5 + .5)*10.5); // Variable width edges. \n    #else\n    th = sL/12.; // Constant width.\n    #endif\n\n    // Lower spiral arms.\n    vec3 svCol = col; // For transparency.\n    col = blend(col, vec3(0), sf*12.*resF, objHi.x, .5); // Drop shadow.\n    col = blend(col, vec3(0), sf, obj.x, 1.); // Dark outer edge.\n    col = blend(col, mix(oCol + bumpCol*b.x*.3, svCol, .15), sf, obj.x + .005, 1.); // Outer color.\n    col = blend(col, vec3(0), sf, obj.x + th, 1.); // Dark inner edge.\n    col = blend(col, mix(oCol2 + bumpCol*b.x*.3, svCol, .25), sf, obj.x + th + .005, 1.); // Inner.\n    col = blend(col, col*1.5, sf*1., abs(obj.x + th - .005) - .002, 1.); // Highlight.\n   \n    // The upper spiral arms.\n    svCol = col;\n    col = blend(col, vec3(0), sf*12.*resF, objHi.y, .5);\n    col = blend(col, vec3(0), sf, obj.y, 1.);\n    col = blend(col, mix(oCol + bumpCol*b.y*.3, svCol, .15), sf, obj.y + .005, 1.);\n    col = blend(col, vec3(0), sf, obj.y + th, 1.);\n    col = blend(col, mix(oCol2 + bumpCol*b.y*.3, svCol, .25), sf, obj.y + th + .005, 1.);\n    col = blend(col, col*1.5, sf*1., abs(obj.y + th - .005) - .002, 1.);\n    \n    \n \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.);\n    // Colored variation.\n    //col = mix(col.zyx, col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , 1./16.));\n\n    \n    // Rough gamma correction.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2218, 2251, 2273, 2273, 2331], [2334, 2362, 2383, 2383, 2446], [2449, 2672, 2707, 2707, 2788], [3363, 3426, 3454, 3454, 3484], [3486, 3551, 3581, 3581, 3620], [5753, 5846, 5883, 5883, 6092], [6094, 6094, 6113, 6113, 6212], [6214, 6609, 6667, 6667, 6728], [6731, 6785, 6825, 6825, 6889], [6894, 7019, 7049, 7049, 7106]], "test": "untested"}
{"id": "NdGfzG", "name": "38+ Video Transitions", "author": "mrmcsoftware", "description": "I originally wrote this as a \"filter\" to create transition frames for videos (C program which outputted PPM files). Then I ported it to GLSL. Adjust lines 12-23 to suit your preferences, This is an improved version of my 33 Video Transitions shader.\n", "tags": ["video", "transition", "transitions", "videotransition", "videoeffects", "videotransitioneffects"], "likes": 18, "viewed": 1102, "published": 3, "date": "1658409961", "time_retrieved": "2024-07-30T16:39:33.976915", "image_code": "/*\n\n  Video Transitions v2.0 by Mark Craig (Copyright Â© 2022)\n\n    I originally wrote this as a \"filter\" to create transition frames\n  for videos (C program which outputted PPM files).  But eventually,\n  I figured it could be relatively easily ported to GLSL - this is the\n  result.\n\n*/\n\nint n = 100;           // number of \"frames\" in transition\nfloat sa = .05;        // smooth amount - size of smooth edges\nbool roto = true;      // if true, rotate transitions that can optionally rotate\nfloat rota = 360.0;    // amount of rotation from start to end of transition\nint rn = 1, rd = 0;    // select based on whether to start with full\n//int rn = 0, rd = -1; //   frame of source1 (only for some transitions)\n//bool altdir = false;   // if true, change direction of rolls\nbool altdir = true;   // if true, change direction of rolls\nint alttype = 0;       // alternate slide up center type (0-8 or 9-17 for slide in)\n\n#define SPEEDADJ .375\n//#define NEEDMOD 1\n//#define SELECTTRANS // uncomment to enable @morimea's transition selector mods\n                      // If selector mods are chosen, click and hold down left\n                      // mouse button on desired transition\n\n#define imod(a,b) (int((float(a)-(float(b)*floor(float(a)/float(b))))))\n\n#define iGlobalTime (iTime / SPEEDADJ)\n\n#define num_transitions 38\n\n// macros for selecting/mixing the textures\n\n#define MEM2 col = alt ? col1 : col2;\n#define MEM1 col = alt ? col2 : col1;\n#define MEM12 col = alt ? v1 * col2 + v2 * col1 : v1 * col1 + v2 * col2;\n#define MEM1S { col = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz; }\n#define MEM2S { col = alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz; }\n\n// Solve some incompatibilities\n\n#define atan2 atan\n#define fmod mod\n#define texture2D texture\n\n// Useful values\n\n#define _TWOPI 6.283185307\n#define M_PI 3.141592654\n\nfloat intersect(vec2, vec2, vec2, vec2);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nvec2 uv = fragCoord.xy / iResolution.xy, uv2;\n#ifdef SELECTTRANS\n// I modified @morimea's mod to make effects start at top and progress in order to bottom\nuv.y = 1.0 - uv.y;\nuv *= vec2(6.,7.); int idx = int(floor(uv.x) + floor(uv.y) * 6.);\nvec2 im = iMouse.xy / iResolution.xy; im.y = 1.0 - im.y;\nif (iMouse.z > 0.) { im *= vec2(6., 7.); idx = int(floor(im.x) + floor(im.y) * 6.); uv /= vec2(6., 7.); }\nelse { uv = fract(uv); }\nuv.y = 1.0 - uv.y;\n#endif\nbool alt = false;\nint type, i, i2, j, v;\nvec3 col, col3;\nfloat v1, v2;\nfloat ye, yfe, dx, dy, cx, cy, rad, slope, theta, xc1, yc1, b, rad0, rad2;\nfloat xc2, yc2, b2, cx2, cy2, r1, vy1, vy2, dx2, dy2, ro, ri, ang, a, a1;\nfloat r, r2, l, l2, theta2, theta3, tang, ang1, ang2, angt, angs, c1, s1;\nfloat xc0, yc0;\nvec2 p1, p2, po, pd;\n\nfloat aspect = iResolution.y / iResolution.x;\nvec3 col1 = texture2D(iChannel0, uv).xyz;\nvec3 col2 = texture2D(iChannel1, uv).xyz;\n#ifdef NEEDMOD\ni = imod(int(iGlobalTime * 20.0) , n);\n#ifndef SELECTTRANS\ntype = imod((int(iGlobalTime * 20.0) / n) , num_transitions);\nif (imod(type , 2) == 1) { alt = true; } else { alt = false; }\n#else\ntype = idx;\nif (imod(int(iGlobalTime * 20.0) , (n*2)) < n) { alt = true; } else { alt = false; }\n#endif\n#else\ni = int(iGlobalTime * 20.0) % n;\n#ifndef SELECTTRANS\ntype = (int(iGlobalTime * 20.0) / n) % num_transitions;\nif (type % 2 == 1) { alt = true; } else { alt = false; }\n#else\ntype = idx;\nif (int(iGlobalTime * 20.0) % (n*2) < n) { alt = true; } else { alt = false; }\n#endif\n#endif\n\n//type = 32;\n\n// some of these equations are long, so I'll forego extra spaces\n\n// was a switch, but some GPUs won't do switch\n\n\t\tif (type==0) // fade in/out\n\t\t\t{\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tMEM12\n\t\t\t}\n\t\telse if (type==1) // window down with soft edge\n\t\t\t{\n\t\t\tye=1.0-float(i)/float(n-1);\n\t\t\tyfe=ye+sa;\n\t\t\tif (uv.y<=ye) MEM1\n\t\t\telse if (uv.y>yfe) MEM2\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv2=float(uv.y-ye)/sa; if (v2>1.0) { v2=1.0; } v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==2) // increasing box\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==3) // increasing diamond\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM1\n\t\t\telse if (dy>slope*dx+cy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==4) // increasing circle\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\tif (sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy))>rad) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==5) // increasing and decreasing diamonds\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx) MEM2\n\t\t\telse if (dy>slope*dx+cy) MEM2\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\t}\n\t\telse if (type==6) // four corner vanish\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=cx*float(i+rn)/float(n+rd);\n\t\t\tdy=cy*float(i+rn)/float(n+rd);\n\t\t\tif ((uv.x>cx-dx)&&(uv.x<cx+dx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.y<cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.y>cy)&&(uv.x>cx-dx)&&(uv.x<cx+dx)) MEM2\n\t\t\telse if ((uv.x<cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse if ((uv.x>cx)&&(uv.y>cy-dy)&&(uv.y<cy+dy)) MEM2\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==7) // increasing circle with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx/aspect*cx/aspect+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+10.0*sa;\n\t\t\trad2=rad+sa;\n\t\t\tr1=sqrt((uv.x-cx)/aspect*(uv.x-cx)/aspect+(uv.y-cy)*(uv.y-cy));\n\t\t\tif (r1>rad2) MEM1\n\t\t\telse if (r1>rad) { v1=(r1-rad)/(rad2-rad); v2=1.0-v1; MEM12 }\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==8) // increasing diamond with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(i+rn)/float(n+rd));\n\t\t\t//rad2=rad+7.0*sa;\n\t\t\trad2=rad+.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cx2) MEM1\n\t\t\telse if (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+b2;\n\t\t\t\tv1=(dy-vy1)/(vy2-vy1); v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==9) // increasing & decreasing diamonds w/ soft edge\n\t\t\t{\n\t\t\tfloat xc1s,yc1s,xc2s,yc2s,rads,rad2s,bs,b2s,cxs,cys,cx2s,cy2s;\n\n\t\t\tcx=.5; cy=.5;\n\t\t\trad0=sqrt(cx*cx+cy*cy)/2.0;\n\t\t\trad=sqrt(cx*cx+cy*cy)*(float(n-(i+1))/float(n+rd))/2.0;\n\t\t\t//rads=rad+7.0*sa;\n\t\t\trads=rad+.7*sa;\n\t\t\trad2=rad0+(rad0-rad);\n\t\t\t//rad2s=rad2-7.0*sa;\n\t\t\trad2s=rad2-.7*sa;\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\txc2=rad2*cos(theta); yc2=rad2*sin(theta);\n\t\t\txc1s=rads*cos(theta); yc1s=rads*sin(theta);\n\t\t\txc2s=rad2s*cos(theta); yc2s=rad2s*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tb2=yc2-slope*xc2;\n\t\t\tbs=yc1s-slope*xc1s;\n\t\t\tb2s=yc2s-slope*xc2s;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tcy2=b2; cx2=(-b2/slope);\n\t\t\tcys=bs; cxs=(-bs/slope);\n\t\t\tcy2s=b2s; cx2s=(-b2s/slope);\n\t\t\tdy=abs(.5-uv.y);\n\t\t\tdx=abs(.5-uv.x);\n\t\t\tif (dx>cxs) MEM2\n\t\t\telse if (dy>slope*dx+cys) MEM2\n\t\t\telse if (dy>slope*dx+cy)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b;\n\t\t\t\tvy2=slope*dx+bs;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\tif (dy>slope*dx+cy2) MEM1\n\t\t\telse if (dy>slope*dx+cy2s)\n\t\t\t\t{\n\t\t\t\tvy1=slope*dx+b2;\n\t\t\t\tvy2=slope*dx+b2s;\n\t\t\t\tv2=(dy-vy1)/(vy2-vy1); v1=1.0-v2;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==10) // increasing box with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tdx=(cx*float(i+rn)/float(n+rd));\n\t\t\tdy=(cy*float(i+rn)/float(n+rd));\n\t\t\tdx2=(cx*float(i+rn)/float(n+rd)+sa);\n\t\t\tdy2=(cy*float(i+rn)/float(n+rd)+sa);\n\t\t\tif ((uv.x>=cx-dx)&&(uv.x<=cx+dx)&&(uv.y>=cy-dy)&&(uv.y<=cy+dy)) MEM2\n\t\t\telse if ((uv.x>=cx-dx2)&&(uv.x<=cx+dx2)&&(uv.y>=cy-dy2)&&(uv.y<=cy+dy2))\n\t\t\t\t{\n\t\t\t\tif ((abs(uv.x-cx)>dx)&&(abs(uv.y-cy)>dy))\n\t\t\t\t\t{\n\t\t\t\t\tif (abs(uv.y-cy)-dy>abs(uv.x-cx)-dx) v1=float(abs(uv.y-cy)-dy)/(sa);\n\t\t\t\t\telse v1=float(abs(uv.x-cx)-dx)/(sa);\n\t\t\t\t\t}\n\t\t\t\telse if (abs(uv.x-cx)>dx) { v1=float(abs(uv.x-cx)-dx)/(sa); }\n\t\t\t\telse if (abs(uv.y-cy)>dy) { v1=float(abs(uv.y-cy)-dy)/(sa); }\n\t\t\t\tv2=1.0-v1; MEM12\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==11) // rotating vanishing (gets smaller) square with fade in new/fade out old\n\t\t\t{\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=max(0.00001,(float(n-(i+1))/float(n+rd)));\n\t\t\txc1=(uv.x-.5)*iResolution.x; yc1=(uv.y-.5)*iResolution.y;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2+iResolution.x/2.0; uv2.y=yc2+iResolution.y/2.0;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<=iResolution.y))\n\t\t\t\t{\n\t\t\t\tuv2/=iResolution.xy;\n\t\t\t\tcol3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz;\n\t\t\t\t}\n\t\t\telse { col3 = vec3(0,0,0); }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==12) // rotating vanishing (gets smaller) square with fade out old\n\t\t\t{\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=max(0.00001,(float(n-(i+1))/float(n+rd)));\n\t\t\txc1=(uv.x-.5)*iResolution.x; yc1=(uv.y-.5)*iResolution.y;\n\t\t\txc2=(xc1*c1-yc1*s1)/rad;\n\t\t\tyc2=(xc1*s1+yc1*c1)/rad;\n\t\t\tuv2.x=xc2+iResolution.x/2.0; uv2.y=yc2+iResolution.y/2.0;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<=iResolution.y))\n\t\t\t\t{\n\t\t\t\tuv2/=iResolution.xy;\n\t\t\t\tcol3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz;\n\t\t\t\t}\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\t\telse if (type==13) // increasing flower with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { r=theta2/ang*(ro-ri)+ri; }\n#else\n\t\t\tif (i2%2==0) { r=theta2/ang*(ro-ri)+ri; }\n#endif\n\t\t\telse { r=(1.0-theta2/ang)*(ro-ri)+ri; }\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==14) // increasing star with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tang=36.0*M_PI/180.0;\n\t\t\tro=(1.0/aspect)/.731*(float(i+rn)/float(n+rd));\n\t\t\ta1=234.0*M_PI/180.0;\n\t\t\tl=(sqrt((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro))))/2.0;\n\t\t\ta1=162.0*M_PI/180.0;\n\t\t\tl2=((ro*cos(a1)*ro*cos(a1))+((ro*sin(a1)-ro)*(ro*sin(a1)-ro)));\n\t\t\tri=(ro-sqrt(l2-l*l))/cos(36.0*M_PI/180.0);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tpo.x=po.y=0.0;\n\t\t\tyc1=1.0-uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1)+vy1;\n\t\t\ttheta2=fmod(abs(theta),ang);\n\t\t\ti2=int((180.0*theta/M_PI)/36.0);\n#ifdef NEEDMOD\n\t\t\tif (imod(i2,2)==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#else\n\t\t\tif (i2%2==0) { p1.x=ri; p1.y=0.0; p2.x=ro*cos(ang); p2.y=ro*sin(ang); }\n#endif\n\t\t\telse { p1.x=ro; p1.y=0.0; p2.x=ri*cos(ang); p2.y=ri*sin(ang); }\n\t\t\tpd.x=cos(theta2); pd.y=sin(theta2);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==15) // dissolve\n\t\t\t{\n\t\t\t// easier to use this common shadertoy random number gen rather than the one I used in original\n\t\t\tint v=int(fract(sin(dot(uv, vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==16) // split horizontal\n\t\t\t{\n\t\t\tcy=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.y<cy-ye) MEM1\n\t\t\telse if (uv.y>=cy+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==17) // split vertical\n\t\t\t{\n\t\t\tcx=.5;\n\t\t\tye=1.0/2.0*float(i+rn)/float(n+rd);\n\t\t\tif (uv.x<cx-ye) MEM1\n\t\t\telse if (uv.x>=cx+ye) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==18) // slide\n\t\t\t{\n\t\t\tye=float(i+rn)/float(n+rd);\n\t\t\tuv2.x=uv.x;\n\t\t\tuv2.y=uv.y+ye;\n\t\t\tif (uv.y>=1.0-ye) MEM2\n\t\t\telse MEM1S\n\t\t\t}\n\t\telse if (type==19) // window right with soft edge\n\t\t\t{\n\t\t\tye=float(i)/float(n-1);\n\t\t\tyfe=ye+(10.0*sa);\n\t\t\tif (uv.x<=ye) MEM2\n\t\t\telse if (uv.x>yfe) MEM1\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tv1=(uv.x-ye)/(10.0*sa); if (v1>1.0) { v1=1.0; } v2=1.0-v1;\n\t\t\t\tMEM12\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==20) // inset down right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==21) // inset down left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if (1.0-uv.y>=dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==22) // inset up right\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif (uv.x>=dx) MEM1\n\t\t\telse if (uv.y>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==23) // inset up left\n\t\t\t{\n\t\t\tdx=float(i+rn)/float(n+rd);\n\t\t\tdy=float(i+rn)/float(n+rd);\n\t\t\tif ((1.0-uv.x)>dx) MEM1\n\t\t\telse if ((uv.y)>dy) MEM1\n\t\t\telse MEM2\n\t\t\t}\n\t\telse if (type==24) // pixelate\n\t\t\t{\n\t\t\t// this is simpler (not as good) as my original non-glsl code\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\tif (i<n/2) { j=int(float(i)/(float(n)/2.0)*50.0); }\n\t\t\telse { j=int(float(n-i-1)/(float(n)/2.0)*50.0); }\n\t\t\tif (j<1) { j=1; }\n\t\t\tuv2.x=float(int(uv.x*iResolution.x/float(j))*j)/iResolution.x;\n\t\t\tuv2.y=float(int(uv.y*iResolution.y/float(j))*j)/iResolution.y;\n\t\t\tcol = v1 * (alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz) + v2 * (alt ? texture2D(iChannel0, uv2).xyz : texture2D(iChannel1, uv2).xyz);\n\t\t\t}\n\t\telse if (type==25) // fan in\n\t\t\t{\n\t\t\ttheta2=M_PI*float(i+rn)/float(n+rd);\n\t\t\tdy=1.0/4.0; dx=1.0/2.0; dy2=1.0*3.0/4.0;\n\t\t\txc1=M_PI/180.0*sa; cy=.5;\n\t\t\ttheta=atan2(abs(dx-uv.x),dy-uv.y);\n\t\t\ttheta3=atan2(abs(dx-uv.x),uv.y-dy2);\n\t\t\tif ((theta<theta2)||(theta3<theta2)) MEM2\n\t\t\telse if (abs(theta2-M_PI)<=.00001) MEM2\n\t\t\telse if ((theta<theta2+xc1)&&(uv.y<=cy)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse if (theta3<theta2+xc1) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==26) // fan out\n\t\t\t{\n\t\t\ttheta2=_TWOPI*float(i+rn)/float(n+rd);\n\t\t\tdx=1.0/4.0; dy=.5; dx2=1.0*3.0/4.0; cx=.5;\n\t\t\txc1=M_PI/180.0*sa;\n\t\t\ttheta=M_PI+atan2(1.0-uv.y-dy,dx-uv.x);\n\t\t\ttheta3=M_PI+atan2(1.0-uv.y-dy,uv.x-dx2);\n\t\t\tif (theta2<=M_PI)\n\t\t\t\t{\n\t\t\t\tif ((theta<theta2)&&(theta3<theta2)) MEM2\n\t\t\t\telse if ((theta<theta2+xc1)&&(uv.x<=cx)) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse if ((theta3<theta2+xc1)&&(uv.x>=cx)) { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse MEM1\n\t\t\t\t}\n\t\t\telse\n\t\t\t\t{\n\t\t\t\tif ((theta>theta2+xc1)&&(uv.x<=cx)) MEM1\n\t\t\t\telse if ((theta3>theta2+xc1)&&(uv.x>=cx)) MEM1\n\t\t\t\telse if (!((theta>theta2)&&(theta3>theta2))) MEM2\n\t\t\t\telse if (uv.x<=cx) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\telse { v1=(theta3-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\t\t}\n\t\t\t}\n\t\telse if (type==27) // fan up\n\t\t\t{\n\t\t\ttheta2=M_PI/2.0*float(i+rn)/float(n+rd);\n\t\t\tdy=0.0; dx=1.0/2.0; xc1=M_PI/180.0*sa;\n\t\t\ttheta=atan2(abs(dx-uv.x),1.0-uv.y);\n\t\t\tif (theta<theta2) MEM2\n\t\t\telse if (theta<theta2+xc1) { v1=(theta-theta2)/xc1; v2=1.0-v1; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==34) // roll\n\t\t\t{\n\t\t\ttheta=(altdir?M_PI:-M_PI)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tuv2.x=((1.0-uv.x)*iResolution.x*c1-uv.y*iResolution.y*s1);\n\t\t\tuv2.y=((1.0-uv.x)*iResolution.x*s1+uv.y*iResolution.y*c1);\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<iResolution.y))\n\t\t\t\t{ uv2/=iResolution.xy; uv2.x=1.0-uv2.x; MEM1S }\n\t\t\telse { MEM2 }\n\t\t\t}\n\t\telse if (type==35) // roll2\n\t\t\t{\n\t\t\ttheta=(altdir?M_PI:-M_PI)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tuv2.x=(uv.x*iResolution.x*c1-uv.y*iResolution.y*s1);\n\t\t\tuv2.y=(uv.x*iResolution.x*s1+uv.y*iResolution.y*c1);\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<iResolution.y))\n\t\t\t\t{ uv2/=iResolution.xy; MEM1S }\n\t\t\telse { MEM2 }\n\t\t\t}\n\t\telse if (type==36) // roll3\n\t\t\t{\n\t\t\ttheta=(altdir?-M_PI:M_PI)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tuv2.x=(uv.x*iResolution.x*c1-(1.0-uv.y)*iResolution.y*s1);\n\t\t\tuv2.y=(uv.x*iResolution.x*s1+(1.0-uv.y)*iResolution.y*c1);\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<iResolution.y))\n\t\t\t\t{ uv2/=iResolution.xy; uv2.y=1.0-uv2.y; MEM1S }\n\t\t\telse { MEM2 }\n\t\t\t}\n\t\telse if (type==37) // roll4\n\t\t\t{\n\t\t\ttheta=(altdir?-M_PI:M_PI)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\tuv2.x=((1.0-uv.x)*iResolution.x*c1-(1.0-uv.y)*iResolution.y*s1);\n\t\t\tuv2.y=((1.0-uv.x)*iResolution.x*s1+(1.0-uv.y)*iResolution.y*c1);\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<iResolution.y))\n\t\t\t\t{ uv2/=iResolution.xy; uv2=1.0-uv2; MEM1S }\n\t\t\telse { MEM2 }\n\t\t\t}\n\t\telse if (type==28) // bars\n\t\t\t{\n\t\t\tint v=int(fract(sin(dot(vec2(uv.y,0), vec2(12.9898, 78.233)))* 43758.5453)*float(n-1));\n\t\t\tif (i>v) MEM2 else MEM1\n\t\t\t}\n\t\telse if (type==33) // slide up center\n\t\t\t{\n\t\t\tbool In=false;\n\t\t\tif (alttype>8) { v=alttype-9; In=true; } else { v=alttype; }\n\t\t\tif (In) { rad=(float(i+1)/float(n+rd)); }\n\t\t\telse { rad=(float(n-(i+1))/float(n+rd)); }\n\t\t\tif (v==0) { cx=.5; cy=0.0; xc1=.5-rad/2.0; yc1=0.0; }\n\t\t\telse if (v==1) { cx=1.0; cy=.5; xc1=1.0-rad; yc1=.5-rad/2.0; }\n\t\t\telse if (v==2) { cx=.5; cy=1.0; xc1=.5-rad/2.0; yc1=1.0-rad; }\n\t\t\telse if (v==3) { cx=0.0; cy=.5; xc1=0.0; yc1=.5-rad/2.0; }\n\t\t\telse if (v==4) { cx=1.0; cy=0.0; xc1=1.0-rad; yc1=0.0; }\n\t\t\telse if (v==5) { cx=cy=1.0; xc1=1.0-rad; yc1=1.0-rad; }\n\t\t\telse if (v==6) { cx=0.0; cy=1.0; xc1=0.0; yc1=1.0-rad; }\n\t\t\telse if (v==7) { cx=cy=0.0; xc1=0.0; yc1=0.0; }\n\t\t\telse if (v==8) { cx=cy=.5; xc1=.5-rad/2.0; yc1=.5-rad/2.0; }\n\t\t\tuv.y=1.0-uv.y;\n\t\t\tif ((uv.x>=xc1)&&(uv.x<=xc1+rad)&&(uv.y>=yc1)&&(uv.y<=yc1+rad))\n\t\t\t\t{\n\t\t\t\tuv2.x=(uv.x-xc1)/rad;\n\t\t\t\tuv2.y=1.0-(uv.y-yc1)/rad;\n\t\t\t\tif (In) { MEM2S } else { MEM1S }\n\t\t\t\t}\n\t\t\telse if (In) { MEM1 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==29) // diagonal down right\n\t\t\t{\n\t\t\trad=sqrt(2.0+2.0)*(1.0-(float(i+rn)/float(n+rd)));\n\t\t\tslope=-1.0/1.0;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1-sa;\n\t\t\tcy=b; cx=(-b/slope);\n\t\t\tdy=abs(uv.y);\n\t\t\tdx=abs(1.0-uv.x);\n\t\t\t//if (dx>cx-sa) MEM2\n\t\t\tif (dy>slope*dx+cy+sa) MEM2\n\t\t\telse if (dy>slope*dx+cy) { v2=(dy-(slope*dx+cy))/(sa); v1=1.0-v2; MEM12 }\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==30) // diagonal cross out\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\trad=sqrt(cx*cx+cy*cy)/2.0*(float(i+rn)/float(n+rd));\n\t\t\tslope=-cy/cx;\n\t\t\ttheta=atan(-slope);\n\t\t\txc1=rad*cos(theta); yc1=rad*sin(theta);\n\t\t\tb=yc1-slope*xc1;\n\t\t\tcy=b; cx=(-b/slope); vy1=sa;\n\t\t\tdy=(uv.y-.5);\n\t\t\tdx=(uv.x-.5);\n\t\t\tif (!(((dy>slope*dx+cy)||(dy<slope*dx-cy))&&((dy>(-slope)*dx+cy)||(dy<(-slope)*dx-cy)))) MEM2\n\t\t\telse if ((sa!=0.0)&&(!(((dy>slope*dx+cy+vy1)||(dy<slope*dx-cy-vy1))&&\n\t\t\t\t((dy>(-slope)*dx+cy+vy1)||(dy<(-slope)*dx-cy-vy1)))))\n\t\t\t\t{\n\t\t\t\tif ((dx>=0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>-slope*dx) { v1=(dy-(-slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((-slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx>=0.0)&&(dy<0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\telse if ((dx<0.0)&&(dy>=0.0))\n\t\t\t\t\t{\n\t\t\t\t\tv1=v2=0.0;\n\t\t\t\t\tif (dy>slope*dx) { v1=(dy-(slope*dx+cy))/vy1; v2=1.0-v1; }\n\t\t\t\t\telse { v1=((slope*dx-cy)-dy)/vy1; v2=1.0-v1; }\n\t\t\t\t\tMEM12\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\telse MEM1\n\t\t\t}\n\t\telse if (type==31) // increasing gear with soft edge\n\t\t\t{\n\t\t\tcx=.5; cy=.5;\n\t\t\tro=sqrt(cx*cx+cy*cy)/.9*float(i+rn)/float(n+rd);\n\t\t\tif (roto) { vy1=float(i+rn-1)/float(n+rd)*rota*M_PI/180.0; }\n\t\t\telse { vy1=0.0; }\n\t\t\tri=ro*.9;\n\t\t\tpo.x=po.y=0.0;\n\t\t\tangt=5.0;\n\t\t\tangs=2.5;\n\t\t\ttang=(angt+angs)*2.0;\n\t\t\tang=tang*M_PI/180.0;\n\t\t\tyc1=uv.y-cy;\n\t\t\txc1=(uv.x-cx)/aspect;\n\t\t\ttheta=atan2(xc1,yc1);\n\t\t\ttheta2=fmod(theta+M_PI+vy1,ang);\n\t\t\tif (theta2<=angt*M_PI/180.0) { r1=r2=ri; ang2=angt; ang1=theta2; }\n\t\t\telse if (theta2<=(angt+angs)*M_PI/180.0) { r1=ri; r2=ro; ang2=angs; ang1=theta2-angt*M_PI/180.0; }\n\t\t\telse if (theta2<=(angt+angs+angt)*M_PI/180.0) { r1=r2=ro; ang2=angt; ang1=theta2-(angt+angs)*M_PI/180.0; }\n\t\t\telse { r1=ro; r2=ri; ang2=angs; ang1=theta2-(angt+angs+angt)*M_PI/180.0; }\n\t\t\tang2*=(M_PI/180.0);\n\t\t\tp1.x=r1; p1.y=0.0; p2.x=r2*cos(ang2); p2.y=r2*sin(ang2);\n\t\t\tpd.x=cos(ang1); pd.y=sin(ang1);\n\t\t\tr=intersect(po,pd,p1,p2);\n\t\t\tr2=sqrt(xc1*xc1+yc1*yc1);\n\t\t\tif (r2>r+sa) { MEM1 } else if (r2>r) { v1=(r2-r)/(sa); v2=1.0-v1; MEM12 } else { MEM2 }\n\t\t\t}\n\t\telse if (type==32) // rotating expanding square with fade in new/fade out old\n\t\t\t{\n\t\t\ttheta=-_TWOPI*(float(i+rn)/float(n+rd));\n\t\t\tc1=cos(theta); s1=sin(theta);\n\t\t\trad=(float(n-(i+1))/float(n+rd));\n\t\t\txc1=(uv.x-.5)*iResolution.x; yc1=(uv.y-.5)*iResolution.y;\n\t\t\txc2=rad*(xc1*c1-yc1*s1);\n\t\t\tyc2=rad*(xc1*s1+yc1*c1);\n\t\t\tuv2.x=xc2+iResolution.x/2.0; uv2.y=yc2+iResolution.y/2.0;\n\t\t\tif ((uv2.x>=0.0)&&(uv2.x<=iResolution.x)&&(uv2.y>=0.0)&&(uv2.y<=iResolution.y))\n\t\t\t\t{\n\t\t\t\tuv2/=iResolution.xy;\n\t\t\t\tcol3 = alt ? texture2D(iChannel1, uv2).xyz : texture2D(iChannel0, uv2).xyz;\n\t\t\t\t}\n\t\t\telse { col3 = alt ? col1 : col2; }\n\t\t\tv1=float(n-(i+1))/float(n-1); v2=1.0-v1;\n\t\t\t//col=col3;\n\t\t\tcol = alt ? v1*col3+v2*col1 : v1*col3+v2*col2;\n\t\t\t}\n\nfragColor = vec4(col, 1.0);\n}\n\nfloat intersect(vec2 origin, vec2 direction, vec2 point1, vec2 point2)\n{\nvec2 v1, v2, v3;\nfloat dot, t1, t2;\n\nv1.x = origin.x - point1.x;\nv1.y = origin.y - point1.y;\nv2.x = point2.x - point1.x;\nv2.y = point2.y - point1.y;\nv3.x = -direction.y;\nv3.y = direction.x;\ndot = v2.x * v3.x + v2.y * v3.y;\nif (abs(dot) < 0.000001) return(-1000.0);\nt1 = (v2.x * v1.y - v2.y * v1.x) / dot;\nt2 = (v1.x * v3.x + v1.y * v3.y) / dot;\nif ((t1 >= 0.0) && (t2 >= 0.0) && (t2 <= 1.0)) return(t1);\nreturn(-1000.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGfzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22255, 22255, 22327, 22327, 22750]], "test": "untested"}
{"id": "7sGBzy", "name": "blur", "author": "assfafa", "description": "learn blur", "tags": ["learnblur"], "likes": 0, "viewed": 187, "published": 3, "date": "1658395367", "time_retrieved": "2024-07-30T16:39:35.072984", "image_code": "float gsblur(float x,float y,float sigma){\n    return float(1./(2.*3.1415926*sigma*sigma))*exp(-((x*x+y*y)/(2.*sigma*sigma)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float blur = max(5.,floor(iMouse.x/100.)+5.);\n    \n    float boxma = 1./ (blur*blur*4.);\n    \n    float sigma = blur/2.5;  \n    \n    float gaussblur = clamp(sign(uv.x-0.33333)-sign(uv.x-0.66666),0.,1.);\n    float errorblur = clamp(sign(uv.x-0.66666),0.,1.); \n    \n    \n    vec4 boxcolor= vec4(0.);\n    vec4 gausscolor= vec4(0.);\n    vec4 errorcolor= vec4(0.);//ä¸ä¸ªåkawaseåéçæ¨¡ç³ kawaseå¾å¤æ¬¡pass ææè¿å¯ä»¥å°±çä¸äº\n    \n    \n    for(float i=-blur;i<blur;i++){\n       for(float l=-blur;l<blur;l++){\n       \n          vec2 exy = vec2(i,l)/iResolution.xy;\n          float weight = gsblur(i,l,sigma);\n          \n          \n          boxcolor += texture(iChannel0,uv + exy)*boxma;\n          gausscolor+= texture(iChannel0, uv + exy)*weight;\n          \n          \n          \n        }\n        vec2 just = (vec2(i,i)/iResolution.xy)-((1./iResolution.xy)*0.5);\n        vec2 aga = (vec2(i,-i)/iResolution.xy)-((1./iResolution.xy)*0.5);\n        float weight = 1./(blur*2.*2.);\n        \n        \n        errorcolor += texture(iChannel0, uv+just)*weight;\n        errorcolor += texture(iChannel0, uv+aga)*weight;\n    }\n    \n    \n    \n    vec4 color = vec4(0.);\n    \n    color = mix(mix(boxcolor ,gausscolor,gaussblur),errorcolor,errorblur);\n    \n    fragColor =color;\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 128], [130, 130, 187, 187, 1519]], "test": "untested"}
{"id": "sdyfRy", "name": "spider crawler 3D", "author": "FabriceNeyret2", "description": "3D version of https://www.shadertoy.com/view/NsKBDw\nand https://twitter.com/KomaTebe/status/1549001155338018818\n\nmouse controls camera.", "tags": ["raymarching", "short", "reproduction"], "likes": 35, "viewed": 540, "published": 3, "date": "1658394898", "time_retrieved": "2024-07-30T16:39:36.198974", "image_code": "// 3D version of https://www.shadertoy.com/view/NsKBDw\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n\nfloat line(vec3 p, vec3 a,vec3 b) {                       // line SDFÂ²\n    p -= a, b -= a;\n    p -= b * clamp(dot(p, b) / dot(b, b), 0., 1.); \n    return dot(p,p); \n}\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9., d; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),          // ray direction\n          p = 30./R, q,                                   // marching point along ray \n          M = iMouse.z > 0. ? .5*(iMouse.xyz/R -.5)\n               :  vec3( 10,4,0)/1e2*cos(.5*iTime+vec3(0,11,0)); // auto demo\n          \n    vec2 P =  3.*cos(iTime+vec2(0,11)) + sin(2.1*iTime+vec2(0,12)), I; // spider location\n\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {        // march scene\n        q = p; t=1e2;\n        q.yz *= rot(-1. -6.*M.y),                         // rotations\n        q.xy *= rot(6.*M.x); \n        if (length(vec3(P,.5)-q) < 6. )                   // sphere box\n        for( int k=0; k<25; k++) {                        // get spider legs\n            d = dot( I = vec2(k%5,k/5)-2. - fract(P), I);\n            d > 1. && d < 4. ? t = min(t, line(q, vec3(I+P,0),vec3(P,1) ) ) : t;\n         }\n        t = sqrt(t)-.05;                                  // convert to line SDF\n        q.xy = fract(q.xy+.5)-.5;                         // grid of points\n        t = min(t, length(q)-.02);\n        p += .5*t*D;                                      // step forward = dist to obj          \n     }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyfRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 145, 180, 216, 312], [313, 313, 349, 349, 1583]], "test": "untested"}
{"id": "NdyBzG", "name": "Gradient flower", "author": "VPaltoDance", "description": "Some collapse", "tags": ["distancefield", "flower", "smoothstep"], "likes": 6, "viewed": 316, "published": 3, "date": "1658367207", "time_retrieved": "2024-07-30T16:39:37.467581", "image_code": "#define PI 3.14159265359\n#define CIRCLE_SCALE 10.0f\n#define COLOR_1_v3 vec3(0.5f, 0.1f, 0.0f)\n#define COLOR_2_v3 vec3(0.95f, 0.2f, 0.8f)\n\nfloat beatFunc(float time, vec2 uv)\n{\n    //float beat = 0.5+0.5*sin((time*4.0 - 0.25)*2.0*PI) * exp(-length(uv) * 50.0);   \n    //return beat;//mix(0.0f, beat, fract(time) < 0.5);\n    \n    float tt = mod(time,1.5)/1.5;\n    float ss = pow(tt,.2)*0.5 + 0.5;\n    return 1.0 - ss*0.3*sin(tt*6.2831*3.0)*exp(-tt*4.0)*exp(-length(uv)*2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 baseUV = uv - 0.5f;\n    baseUV.x *= iResolution.x / iResolution.y;\n    baseUV.x *= 1.1*uv.y + 1.1;\n    baseUV.y *= 1.6*uv.y  + 1.4;\n    \n    float beat_func = beatFunc(iTime, baseUV);\n    baseUV *= (beat_func) ;\n    \n    \n   \n    float phi = atan(baseUV.y, baseUV.x);\n    float phi_func = 0.04 + 0.02 * sin(phi * 10.0);\n    \n    float dist = length(baseUV) ;\n    float pattern = phi_func + dist; // pattern distance field\n    \n    float frac_pattern = fract(CIRCLE_SCALE * (pattern + 0.1f * iTime));    \n    float circle_pattern = frac_pattern - smoothstep(0.95f, 1.0f, frac_pattern);\n    \n    vec3 uvcol = 0.5 + 0.5*cos(iTime+ 0.0f * baseUV.xyx + dist * 2.0f + vec3(1,2,4));\n    vec3 uvcols = 0.25 + 0.25*sin(iTime+ 0.0f * baseUV.xyx + dist * 2.0f + vec3(1,2,4));\n    \n    vec3 col = mix(uvcols, uvcol, circle_pattern);\n \n    // Output to screen\n    fragColor = vec4(col, 1.0f);\n    //fragColor = vec4(pattern);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyBzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 175, 318, 474], [476, 476, 533, 583, 1547]], "test": "untested"}
{"id": "7dKBW1", "name": "Soft Springs", "author": "oneshade", "description": "At some point I'd like to have a way to simulate atoms bonding and interacting realistically.", "tags": ["2d", "simulation", "particles", "bonding"], "likes": 19, "viewed": 282, "published": 3, "date": "1658353241", "time_retrieved": "2024-07-30T16:39:38.470899", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 50.0;\n    float unit = 100.0 / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    //uv.x -= 6.0 * iTime;\n\n    for (int i=0; i < PARTICLES; i++) {\n        vec2 pos = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n        color = mix(color, vec3(1.0), smoothstep(unit, 0.0, length(uv - pos) - 0.1));\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 Hash12(in float x) {\n    x += iDate.w;\n\tvec3 p3 = fract(x * vec3(0.1031, 0.103, 0.0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    fragColor = vec4(0.0);\n    ivec2 iFragCoord = ivec2(fragCoord);\n\n    if (iFrame == 0 && iFragCoord.x < PARTICLES && iFragCoord.y == 0) {\n        // Random (100 particles)\n        /**/\n        fragColor.xy = (Hash12(fragCoord.x + 274.937) - 0.5) * 50.0;//(vec2(mod(fragCoord.x, 10.0), floor(fragCoord.x / 10.0)) - 5.0) * 0.8;\n        fragColor.zw = (Hash12(fragCoord.x + 385.583) - 0.5) * 5.0;\n        /**/\n\n        // Newton cradle+ (12 particles)\n        /**\n        fragColor = vec4((fragCoord.x - 5.0) * 3.0, 0.0, 0.0, 0.0);\n        if (iFragCoord.x == 9) fragColor = vec4(20.0, 0.0, -9.0, 0.0);\n        if (iFragCoord.x == 10) fragColor = vec4(20.0, -2.0, -9.0, 0.0);\n        if (iFragCoord.x == 11) fragColor = vec4(20.0, 2.0, -9.0, 0.0);\n        /**/\n\n        // Bond gun (3 particles)\n        /**\n        if (iFragCoord.x == 0) fragColor = vec4(10.0, 0.0, -1.0, 0.0);\n        if (iFragCoord.x == 1) fragColor = vec4(0.0, -2.0, 0.0, 0.0);\n        if (iFragCoord.x == 2) fragColor = vec4(0.0, 2.0, 0.0, 0.0);\n        /**/\n\n        // Double oscillator tunnel (22 particles)\n        /**\n        fragColor = vec4((fragCoord.x - 5.0) * 5.0, 2.5, 0.0, 0.0);\n        if (iFragCoord.x > 9) fragColor = vec4((fragCoord.x - 15.0) * 5.0, -2.5, 0.0, 0.0);\n        if (iFragCoord.x == 20) fragColor = vec4(-35.0, 0.0, 7.0, 0.0);\n        if (iFragCoord.x == 21) fragColor = vec4(35.0, 0.0, -7.0, 0.0);\n        /**/\n\n        // Speed adder (4 particles)\n        /**\n        if (iFragCoord.x == 0) fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        if (iFragCoord.x == 1) fragColor = vec4(-10.0, 0.0, 1.0, 0.0);\n        if (iFragCoord.x == 2) fragColor = vec4(-7.1, 7.1, 0.71, -0.71);\n        if (iFragCoord.x == 3) fragColor = vec4(-7.1, -7.1, 0.71, 0.71);\n        if (iFragCoord.x > 0) fragColor.zw *= 2.0;\n        /**/\n\n        // Quadruple bond/accelerator (16 particles)\n        /**\n        if (iFragCoord.x == 0) fragColor = vec4(-10.0, 10.0, 0.0, 0.0);\n        if (iFragCoord.x == 1) fragColor = vec4(-20.0, 10.0, 2.0, 0.0);\n        if (iFragCoord.x == 2) fragColor = vec4(-17.1, 17.1, 1.42, -1.42);\n        if (iFragCoord.x == 3) fragColor = vec4(-10.0, 20.0, 0.0, -2.0);\n        if (iFragCoord.x == 4) fragColor = vec4(10.0, 10.0, 0.0, 0.0);//\n        if (iFragCoord.x == 5) fragColor = vec4(20.0, 10.0, -2.0, 0.0);//\n        if (iFragCoord.x == 6) fragColor = vec4(17.1, 17.1, -1.42, -1.42);//\n        if (iFragCoord.x == 7) fragColor = vec4(10.0, 20.0, 0.0, -2.0);//\n        if (iFragCoord.x == 8) fragColor = vec4(10.0, -10.0, 0.0, 0.0);\n        if (iFragCoord.x == 9) fragColor = vec4(20.0, -10.0, -2.0, 0.0);\n        if (iFragCoord.x == 10) fragColor = vec4(17.1, -17.1, -1.42, 1.42);\n        if (iFragCoord.x == 11) fragColor = vec4(10.0, -20.0, 0.0, 2.0);\n        if (iFragCoord.x == 12) fragColor = vec4(-10.0, -10.0, 0.0, 0.0);//\n        if (iFragCoord.x == 13) fragColor = vec4(-20.0, -10.0, 2.0, 0.0);//\n        if (iFragCoord.x == 14) fragColor = vec4(-17.1, -17.1, 1.42, 1.42);//\n        if (iFragCoord.x == 15) fragColor = vec4(-10.0, -20.0, 0.0, 2.0);//\n        /**/\n\n        // Orbit (2 particles)\n        /**\n        if (iFragCoord.x == 0) fragColor = vec4(-0.4847908745, 0.0, 0.0, 2.0);\n        if (iFragCoord.x == 1) fragColor = vec4(0.4847908745, 0.0, 0.0, 0.0);\n        /**/\n    }\n\n    else {\n        fragColor = texelFetch(iChannel0, iFragCoord, 0);\n        vec2 force = vec2(0.0);\n        for (int i=0; i < PARTICLES; i++) {\n            if (i != iFragCoord.x) {\n                vec2 particle = texelFetch(iChannel0, ivec2(i, 0), 0).xy;\n\n                vec2 to = particle - fragColor.xy;\n                float dist = length(to);\n                vec2 dir = to / dist;\n\n                //float y = exp(2.55 - 2.63 * dist);\n                float y = exp(2.55 - 2.63 * dist);\n                float strength = 37.4 * (1.0 - y) * y;\n\n                force += dir * strength;\n            }\n        }\n\n        vec2 accel = force;// / mass;\n        fragColor.zw += accel * dt;\n        fragColor.xy += fragColor.zw * dt;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PARTICLES 100\n#define dt 0.01", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKBW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 455]], "test": "untested"}
{"id": "7dKfDw", "name": " Remix of spider crawler", "author": "totetmatt", "description": "Original from FabriceNeyret2  https://www.shadertoy.com/view/NsKBDw\nWas looking for something else, but found this quite interesting. ", "tags": ["remix"], "likes": 10, "viewed": 275, "published": 3, "date": "1658343721", "time_retrieved": "2024-07-30T16:39:39.333593", "image_code": "float L(vec2 p, vec2 a,vec2 b) {               // draw line\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );                       \n}\nvec2 hexgrid(inout vec2 p){\n    const vec2 sz = vec2(1.,1.73),hs=sz*.5;\n  \n    vec2 pa = mod(p,sz)-hs;\n    vec2 pb = mod(p-hs,sz)-hs;\n    vec2 pc = dot(pa,pa) < dot(pb,pb) ? pa:pb;\n    vec2 n = (p-pc+hs)/sz;\n    p = pc;\n    return round(n*2.)*.5;\n    \n  \n  }\n#define S(v) smoothstep(4.*15./iResolution.y,0.,v)  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n      uv *=10.;\n  vec2 uuv = uv*.5;\n  vec2 n = hexgrid(uv);\n  uv*=4.;\n  vec3 col = vec3(0.);\n  float gy = dot(sin(n),cos(n.xy));\n\tvec2 I = floor(uv),J, M=vec2(sin(iTime+gy+n.x+n.y*.2)*.2,cos(iTime+gy+n.x*.2+n.y)*.5);\n  for(int k=0;k<25;k++){\n      J = I + vec2(k%5-2,k/5-2);\n      float d=  length(J-M);\n      d> 1. && d < 2. ? col +=S(L(uv,J,M))*vec3(1.):col;\n     \n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dKfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 59, 170], [171, 171, 198, 198, 429], [484, 484, 541, 591, 1058]], "test": "untested"}
{"id": "sdKBDw", "name": "newtons_fract_simple", "author": "graygoose", "description": "nfract", "tags": ["fractal", "simple"], "likes": 3, "viewed": 214, "published": 3, "date": "1658338252", "time_retrieved": "2024-07-30T16:39:40.288040", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define NROOTS 3\nvec2 roots[NROOTS];\n\n#define SCALE(v, mx, a, b) (a + (v * (b - a) / mx))\nvec2 scale(vec2 mn, vec2 mx, mat2 bounds) {\n    return vec2(SCALE(mn.x, mx.x, bounds[0][0], bounds[0][1]),\n                SCALE(mn.y, mx.y, bounds[1][0], bounds[1][1]));\n}\n\nvec3 hueShift(vec3 color, float hue) {\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\n    // screen\nvec2 wrap(in vec2 p, in vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n\n// math\n    //Generic 3x3 filter - vec3(center, edges, diagonals)\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, .05)\nvec4 filter3x3(in vec2 pos, in vec3 kernel, in sampler2D channel, in vec2 reso) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            \n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}\n\n\n    // Sobel\n#define SOBEL_EDGE_COLOR vec4(0.753,0.380,0.796,1.)\nvec4 sobel(in vec2 pos, in sampler2D channel, in vec2 reso) {\n    // \n    mat3 SX = mat3( 1.0,  2.0,  1.0, \n                    0.0,  0.0,  0.0, \n                   -1.0, -2.0, -1.0);\n    mat3 SY = mat3(1.0, 0.0, -1.0, \n                   2.0, 0.0, -2.0, \n                   1.0, 0.0, -1.0);\n\n    vec4 T = texelFetch(channel, ivec2(pos), 0);\n\n    mat3 M = mat3(0.);\n    for(int i=0; i<3; i++) {\n        for(int j=0; j<3; j++) {\n            vec4 A = texelFetch(channel, ivec2(pos + vec2(i-1, j-1)), 0);\n            M[i][j] = length(A);\n        }\n    }\n    \n    float gx = dot(SX[0], M[0]) + dot(SX[1], M[1]) + dot(SX[2], M[2]);\n    float gy = dot(SY[0], M[0]) + dot(SY[1], M[1]) + dot(SY[2], M[2]);\n    \n    \n    // TODO factor into float sobel() and move this to a buffer pass.\n    float g = sqrt(gx*gx + gy*gy);\n    g = smoothstep(0.15, 0.98, g);\n\n    return mix(T, SOBEL_EDGE_COLOR, g);\n}", "buffer_a_code": "int get_nearest_root(vec2 z){\n    int index = 0; float dist = 1000.;\n    \n    for(int i = 0; i < NROOTS; i++){\n        float d = length(z - roots[i]);\n        if(d < dist){\n            index = i; dist = d;\n        }\n    }\n    \n    return index;\n}\n\nvec2 newton_iter(in vec2 z){\n    vec2 sum = vec2(0.);\n\n    for(int j = 0; j < NROOTS; j++){\n        vec2 dist = z - roots[j];\n        float delta = dot(dist, dist);\n        if (delta < 0.0001) return z;\n        \n        sum += vec2(dist.x, -dist.y) / delta;\n    }\n    \n    return z - (vec2(sum.x, -sum.y) / (sum.x*sum.x+sum.y*sum.y));\n}\n\n\n#define ITER_COUNT 15\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Roots associated with Polynomial being iterated.\n    roots = vec2[NROOTS](vec2(  0.0, -1.+sin(iTime)), \n                         vec2(  0.5,          0.866), \n                         vec2( -0.5,          0.866));\n\n    // scale math space\n    vec2 z = scale(fragCoord.xy, iResolution.xy, mat2(-1.25, 1.25, -.5, 1.)); \n    \n    // calculate pixel convergence & color\n    for(int i = 0; i < ITER_COUNT; i++){\n        z = newton_iter(z);\n    }\n    \n    // coloring\n    int col_index = get_nearest_root(z);\n    vec3 col = vec3(col_index-0==0,col_index-1==0,col_index-2==0);\n    \n    fragColor = vec4(hueShift(col, cos(iTime)), 1.);\n}", "buffer_a_inputs": [], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 C0 = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    vec4 C1 = texelFetch(iChannel1, ivec2(fragCoord.xy), 0);\n    vec4 L0 = filter3x3(fragCoord.xy, LAPLACIAN, iChannel0, iResolution.xy);\n    vec4 G1 = filter3x3(fragCoord.xy, GAUSSIAN, iChannel1, iResolution.xy);\n    \n    fragColor = C0 + G1;\n    fragColor *= -L0 / (2.-C0);\n    \n    fragColor += C1 + G1;\n    fragColor *= 0.49;\n    fragColor += -L0 / (2.-C1);\n\n    \n    fragColor += G1 + L0;\n    fragColor *= 0.49;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 122]], "test": "untested"}
{"id": "sdVfWw", "name": "ShaderRunner", "author": "yasuo", "description": "The ShaderRunner is running through from Portland to CA on I-5. He is hangry and rushing into the In-N-Out.", "tags": ["shaderrunner"], "likes": 21, "viewed": 356, "published": 3, "date": "1658336628", "time_retrieved": "2024-07-30T16:39:41.185641", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define SkewX(a) mat2(1,tan(a),0,1)\n#define SkewY(a) mat2(1,0,tan(a),1)\n#define Skew(a) mat2(1,tan(a.x),tan(a.y),1)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(234.56,789.34));\n    p+=dot(p,p+34.56);\n    return fract(p.x+p.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdUnevenCapsule( vec2 p, float r1, float r2, float h )\n{\n    p.x = abs(p.x);\n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(p,vec2(-b,a));\n    if( k < 0.0 ) return length(p) - r1;\n    if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n    return dot(p, vec2(a,b) ) - r1;\n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\nvec3 cuctusTex(vec2 p, vec3 col, float m){\n    p*=80.0;\n    p.x = fract(p.x)-0.5;\n    float d = abs(p.x)-0.2;\n    d = max(m,d);\n    return mix(col,vec3(0.0,0.6,0.0),S(d,-0.05));\n}\n\nvec3 cactus(vec2 p, vec3 col){\n    p*=2.0;\n    \n    vec2 id = floor(p)-0.5;\n    float n = Hash21(id);\n    float h = clamp(n, 0.3, 0.4);\n    \n    p.x = mod(p.x,1.0)-0.5;\n    p.y+=0.58;\n    \n    vec2 prevP = p;\n    \n    p.x*=0.7;\n    p.y+=0.015;\n    float shadow = length(p)-0.08;\n    col = mix(col,vec3(0.0),S(shadow,-0.15));\n    \n    p = prevP;\n    \n    p*=Rot(radians(10.0));\n    float size = 0.05;\n    float d = sdSegment(p,vec2(0.0,h),vec2(0.0,0.0))-size;\n    if(n<0.5){\n        float d2 = sdSegment(p,vec2(0.0,0.07),vec2(0.1,0.07))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(0.0,0.1),vec2(-0.1,0.1))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(0.1,0.2),vec2(0.1,0.07))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(-0.1,0.25),vec2(-0.1,0.1))-size;\n        d = min(d,d2);\n    } else {\n        float d2 = sdSegment(p,vec2(0.0,0.1),vec2(0.1,0.1))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(0.0,0.07),vec2(-0.1,0.07))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(0.1,0.2+(h*0.2)),vec2(0.1,0.1))-size;\n        d = min(d,d2);\n        d2 = sdSegment(p,vec2(-0.1,0.25),vec2(-0.1,0.07))-size;\n        d = min(d,d2);\n    }\n    \n    d = max(-p.y-0.02,d);\n    col = mix(col,vec3(0,0.3,0),S(d,-0.05));\n    col = cuctusTex(p,col, d);\n    return col;\n}\n\nvec3 rock(vec2 p, vec3 col){\n    p*=4.0;\n    p.y+=1.0;\n    \n    vec2 id = floor(p)-0.5;\n    float n = Hash21(id);\n    float h = clamp(n, 0.5 ,1.5);\n    float h2 = clamp(n, 1.3 ,2.0);\n    \n    p.y*= 2.5;\n    p.y+= sin(h2)*0.3;\n    p.x+=0.2;\n    p.x = mod(p.x,1.4)-0.7;\n    p.x*=h2;\n    float d = length(p)-0.2;\n    d = max((abs(p.y)-0.15),d);\n    \n    float a = radians(-30.0*h);\n    p.x+=0.16;\n    float slice = dot(p,vec2(cos(a),sin(a)));\n    d = max(-slice,d);\n    a = radians(50.0*h);\n    p.x-=0.35;\n    slice = dot(p,vec2(cos(a),sin(a)));\n    d = max(slice,d);\n    \n    p.x+=0.2;\n    p.y+=0.1;\n    float shadow = length(p)-0.3;\n    col = mix(col,vec3(0.0),S(shadow,-0.4));\n    \n    float nc = noise2d(p*20.)*0.2;\n    col = mix(col,vec3(0.6,0.5,0.2)+nc,S(d,-0.07));\n    \n    return col;\n}\n\nfloat sdTri(vec2 p, vec2 s){\n    p*=vec2(0.7,1.2);\n    p.x-=s.x*0.5;\n    float d = B(p,s);\n    float a = radians(45.);\n    p.y = abs(p.y);\n    float mask = dot(p,vec2(cos(a),sin(a)));\n    d = max(mask,d);\n    return d;\n}\n\nvec3 PolyRunner(vec2 p, vec3 col){\n    p*=2.0;\n    vec2 prevP = p;\n    \n    // feather back\n    p*=Rot(radians(10.*sin(iTime*30.0)));\n    p*=SkewX(0.95);\n    p.y*=1.1;\n    \n    float d = sdTri(p-vec2(-0.01,0.0),vec2(0.12));\n    col = mix(col,vec3(0.3,0.6,0.8),S(d,0.0));\n    \n    // head hair\n    p = prevP;\n    p*=Rot(radians(31.));\n    p*=vec2(1.0,2.5);\n    p-=vec2(0.,0.68);\n    d = sdTri(p,vec2(0.05));\n    col = mix(col,vec3(0.1,0.7,0.9),S(d,0.0));\n    \n    // neck\n    p = prevP;\n    p.x*=2.0;\n    p.x-=0.2;\n    p.y-=0.02;\n    p*=SkewY(-0.9);\n    p*=Rot(radians(90.));\n    d = sdTri(p,vec2(0.12));\n    col = mix(col,vec3(0.3,0.7,0.8),S(d,0.0));\n    \n    // mouth\n    p = prevP;\n    p*=Rot(radians(11.));\n    p*=vec2(1.0,1.7);\n    p-=vec2(0.142,0.39);\n    \n    d = sdTri(p,vec2(0.05));\n    col = mix(col,vec3(0.9,0.9,0.1),S(d,0.0));\n    \n    // body\n    p = prevP;\n    p*=vec2(0.5,1.1);\n    p-=vec2(0.02,-0.09);\n    p*=Rot(radians(90.));\n    d = sdTri(p,vec2(0.07));\n    col = mix(col,vec3(0.5,0.7,0.8),S(d,0.0));\n    \n    // feather front\n    p = prevP;\n    p*=Rot(radians(12.*sin(iTime*35.0)));\n    p*=SkewX(0.95);\n    d = sdTri(p-vec2(-0.01,-0.03),vec2(0.08));\n    col = mix(col,vec3(0.1,0.4,0.7),S(d,0.0));    \n    \n    // animated legs\n    p = prevP;\n    p.y*=1.3;\n    p.x-=0.03;\n    p.y+=0.23;\n    p*=Rot(radians(800.0*iTime));\n    d = abs(length(p)-0.12)-0.03;\n    d = max(-(abs(p.y)-0.05),d);\n    \n    col = mix(col,vec3(0.7,0.5,0.5),S(d,-0.05));\n    \n    p = prevP;\n    p.y*=1.3;\n    p.x-=0.03;\n    p.y+=0.23;\n    p*=Rot(radians(750.0*iTime+50.));\n    d = abs(length(p)-0.08)-0.03;\n    d = max(-(abs(p.y)-0.03),d);\n    \n    col = mix(col,vec3(0.5,0.5,0.1),S(d,-0.05));\n    \n    return col;\n}\n\nfloat dCharI(vec2 p){\n    float d = B(p,vec2(0.01,0.04));\n    return d;\n}\n\nfloat dCharN(vec2 p){\n    vec2 prevP = p;\n    p.x = abs(p.x)-0.03;\n    float d = B(p,vec2(0.01,0.04));\n    p = prevP;\n    p*=Rot(radians(-30.));\n    float d2 = B(p,vec2(0.01,0.06));\n    p = prevP;\n    d2 = max((abs(p.y)-0.04),d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat dCharO(vec2 p){\n    float d = abs(length(p)-0.03)-0.01;\n    return d;\n}\n\nfloat dCharU(vec2 p){\n    vec2 prevP = p;\n    float d = abs(length(p)-0.03)-0.01;\n    d = max(p.y,d);\n    p.x = abs(p.x)-0.03;\n    p.y-=0.02;\n    float d2 = B(p,vec2(0.01,0.02));\n    d = min(d,d2);\n    return d;\n}\n\nfloat dCharT(vec2 p){\n    vec2 prevP = p;\n    float d = B(p,vec2(0.01,0.04));\n    p.y-=0.03;\n    float d2 = B(p,vec2(0.03,0.01));\n    return min(d,d2);\n}\n\nfloat dInNOut(vec2 p){\n    float d = dCharI(p-vec2(-0.3,0.0));\n    float d2 = dCharN(p-vec2(-0.24,0.0));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.18,0.0),vec2(0.01));\n    d = min(d,d2);\n    d2 = dCharN(p-vec2(-0.12,0.0));\n    d = min(d,d2);\n    d2 = B(p-vec2(-0.06,0.0),vec2(0.01));\n    d = min(d,d2);\n    d2 = dCharO(p-vec2(0.,0.0));\n    d = min(d,d2);\n    d2 = dCharU(p-vec2(0.09,0.0));\n    d = min(d,d2);\n    d2 = dCharT(p-vec2(0.17,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 inNOut(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    float d = dInNOut(p);\n    col = mix(col,vec3(1.0,0.0,0.0),S(d,0.0));\n    \n    p-=vec2(-0.08,-0.09);\n    p*=Rot(radians(-28.));\n    d = sdUnevenCapsule(p,0.02,0.035,0.25);\n    p = prevP;\n    p-=vec2(0.1,0.09);\n    p*=Rot(radians(-80.));\n    float d2 = sdUnevenCapsule(p,0.01,0.035,0.3);\n    d = min(d,d2);\n    p = prevP;\n    \n    p*=Rot(radians(11.));\n    d2 = sdTri(p-vec2(0.09,0.107),vec2(0.04));\n    d = min(d,d2);\n    \n    p = prevP;\n    d = max(-(abs(p.y)-0.055),d);\n    \n    col = mix(col,vec3(1.,0.9,0.0),S(d,0.0));\n    return col;\n}\n\nvec3 speechBaloon(vec2 p, vec3 col){\n    p*=2.0;\n    vec2 prevP = p;\n    p.x*= 0.6;\n    float d = length(p)-0.2;\n    float d2 = length(p-vec2(-0.1,-0.25))-0.03;\n    d = min(d,d2);\n    p = prevP;\n    d2 = length(p-vec2(-0.23,-0.33))-0.03;\n    d = min(d,d2);\n    col = mix(col,vec3(1.0),S(d,0.0));\n    p = prevP;\n    col = inNOut(p-vec2(0.07,-0.04),col);\n    \n    return col;\n}\n\nfloat remap(float value, float low1, float high1, float low2, float high2) {\n    return low2 + (high2 - low2) * (value - low1) / (high1 - low1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    float zoom = 1.0;\n    \n    if(iMouse.z>0.){\n        uv*=zoom+0.3-remap(m.y,-0.7,0.7,0.0,0.3);\n    } else {\n        uv*=zoom;\n    }\n    \n    vec2 prevUV = uv;\n    \n    float slowestSpeed = 0.5;\n    float mediumSpeed = 1.3;\n    float fastestSpeed = 3.0;\n    \n    uv.x+=iTime*slowestSpeed;\n    uv*=15.0;\n    \n    vec3 col = mix(vec3(0.6,0.9,1.0),vec3(0.5,0.9,1.0),uv.y);\n    \n    // distant mountains\n    float n = fbm(uv*0.05)*5.0;\n    float nc = noise2d(uv*vec2(0.5,10.))*0.05;\n    float d = uv.y+n-3.;\n    col = mix(col,vec3(0.5,0.8,1.0)+nc,S(d,0.0));\n    \n    // sun\n    uv = prevUV;\n    uv.x+=sin(iTime*0.5)*0.05;\n    d = length(uv-vec2(0.5,0.3))-0.1;\n    col = mix(col,vec3(1.0),S(d,-0.07));\n    \n    // clouds\n    uv = prevUV;\n    uv.y-=0.62;\n    uv*=5.0;\n    n = fbm(uv - vec2(-iTime*slowestSpeed,iTime*(slowestSpeed*0.5)))*0.6;\n    uv*= n;\n    float clouds = B(uv,vec2(2.0,0.4));\n    col = mix(col,vec3(0.5,0.9,1.0)+n*0.2,S(clouds,-0.2));\n    \n    uv = prevUV;\n    uv.x+=iTime*mediumSpeed;\n    uv*=15.0;\n    \n    // closest mountains\n    uv-=vec2(0.3);\n    n = fbm(uv*0.1)*3.0+abs(sin(uv.x*0.1)*2.0);\n    d = uv.y+n-1.;\n    col = mix(col,vec3(0.6,0.5,0.1)-(n*0.05),S(d,0.0));\n    \n    uv+=vec2(0.3);\n    n = fbm(uv*0.1)*3.0+abs(sin(uv.x*0.1)*2.0);\n    d = uv.y+n-1.;\n    nc = noise2d(uv*vec2(0.5,10.))*0.1;\n    col = mix(col,vec3(1.5,0.8,0.5)-(n*0.05)+nc,S(d,0.0));\n    \n    uv = prevUV;\n    d = 0.0;\n    float scene = mod(iTime,30.0);\n    if(scene >=10. && scene<20.){\n        col = mix(col,vec3(0.9,0.4,0.1)*col*1.2,S(d,0.0));\n    } else if(scene >= 20.){\n        col = mix(col,vec3(0.1,0.4,0.9)*col*1.5,S(d,0.0));\n    }\n    \n    uv = prevUV;\n    d = uv.y+0.3;\n    col = mix(col,vec3(0.7),S(d,0.0));\n    \n    uv.y += 0.28;\n    d = (abs(uv.y)-0.07);\n    uv.x+=iTime*fastestSpeed;\n    n = noise2d(uv*100.)*0.05;\n    col = mix(col,vec3(0.9,0.9,0.6)+n,S(d,-0.05));\n    \n    uv = prevUV;\n    uv.x+=iTime*fastestSpeed;\n    col = rock(uv,col);\n    \n    uv = prevUV;\n    uv.x+=iTime*fastestSpeed;\n    col = cactus(uv,col);\n    \n    uv = prevUV;\n    uv.x+=sin(iTime)*0.1;\n    uv.y+=0.35;\n    uv*=5.0;\n    uv.x*=1.5;\n    uv*=Rot(radians(12.0));\n    uv.y*=mix(1.5,6.0,smoothstep(-1.0,1.0,uv.x));\n    float smokeD = B(uv,vec2(0.6,0.01))*fbm(uv - vec2(-iTime*3.0,iTime*0.01));\n    col = mix( col, (vec3(0.95)), 1.0-smoothstep(0.05,0.5,smokeD) );\n    \n    uv = prevUV;\n    uv.x+=sin(iTime)*0.1;\n    col = PolyRunner(uv-vec2(0.22,-0.3),col);\n    \n    uv = prevUV;\n    uv.x+=iTime*fastestSpeed;\n    uv.y+=0.5;\n    uv*=2.0;\n    uv.x = fract(uv.x)-0.5;\n    d = B(uv,vec2(0.2,0.02));\n    col = mix(col,vec3(1.),S(d,0.));\n    \n    uv = prevUV;\n    uv.x+=sin(iTime)*0.1;\n    col = speechBaloon(uv-vec2(0.47,0.),col);\n    \n    uv = prevUV;\n    uv.x+=mod(iTime,5.)*fastestSpeed;\n    col+=noise2d(uv*100.0)*0.05;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[321, 321, 343, 343, 433], [435, 495, 547, 547, 666], [668, 728, 790, 790, 1029], [1031, 1180, 1201, 1201, 1335], [1337, 1337, 1365, 1365, 1868], [1870, 1870, 1890, 1890, 2152], [2154, 2154, 2196, 2196, 2333], [2335, 2335, 2365, 2365, 3650], [3652, 3652, 3680, 3680, 4443], [4445, 4445, 4473, 4473, 4665], [4667, 4667, 4701, 4701, 6372], [6374, 6374, 6395, 6395, 6447], [6449, 6449, 6470, 6470, 6719], [6721, 6721, 6742, 6742, 6798], [6800, 6800, 6821, 6821, 7013], [7015, 7015, 7036, 7036, 7168], [7170, 7170, 7192, 7192, 7646], [7648, 7648, 7679, 7679, 8243], [8245, 8245, 8281, 8281, 8620], [8622, 8622, 8698, 8698, 8768], [8770, 8770, 8827, 8827, 11795]], "test": "untested"}
{"id": "7sKfWw", "name": "voronoi_test_goose", "author": "graygoose", "description": "voronoi", "tags": ["voronoi", "noise"], "likes": 0, "viewed": 205, "published": 3, "date": "1658335789", "time_retrieved": "2024-07-30T16:39:42.039358", "image_code": "#define N 10\n#define ZOOM 1.\n#define SEED 5\n\n\n\nvec2 roots(int offset) {\n    if (offset == -1) return iMouse.xy;\n    \n    float s = rand(offset);\n    return vec2(0.5+sin(iTime)*rand(SEED*offset), 0.5+cos(iTime)*rand(SEED*offset+1));\n}\n\n\nvoid mainImage(out vec4 O, in vec2 Q) {\n    vec2 z = SS(Q);\n    \n    float nearestDist = 100.0;\n    int nearestIndex = 0;\n    for (int i = 0; i < N; i++) {\n        float dist = cms(z - roots(i));\n        if (dist < nearestDist) {\n            nearestDist = dist;\n            nearestIndex = i;\n        }\n    }\n  \n    vec3 col = vec3(roots(nearestIndex), 0.0);\n    for (int i = 0; i < N; i++) {\n        col = draw_point(col, z, roots(i), 0.00001);\n    }\n\n    O = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "#define R iResolution.xy\n#define SS(p) (2. * p / R.xy - vec2(0.5))\n\nfloat cms(vec2 c) { \n    return c.x * c.x + c.y * c.y; \n}\n\nvec3 draw_point(vec3 col, vec2 pos, vec2 pt, float r){\n    return cms(pos - pt) < r ? vec3(1) : col;\n}\n\nfloat rand(int seed){\n    return fract(sin(float(seed) * 78.233) * 43758.5453);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 71, 71, 233], [236, 236, 275, 275, 713]], "test": "untested"}
{"id": "fsVBDm", "name": "testing101", "author": "thebtype", "description": "tsting api", "tags": ["cineshader"], "likes": 3, "viewed": 3042, "published": 3, "date": "1658330824", "time_retrieved": "2024-07-30T16:39:42.918010", "image_code": "// domain warping based on the master's notes at https://iquilezles.org/articles/warp\n\n// NOISE ////\nvec2 hash2( float n )\n{\n    return fract(sin(vec2(n,n+1.0))*vec2(13.5453123,31.1459123));\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.500000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\n    f += 0.015625*noise( p );\n\n    return f/0.96875;\n}\n\n// -----------------------------------------------------------------------\n\nfloat pattern(in vec2 p, in float t, in vec2 uv, out vec2 q, out vec2 r, out vec2 g)\n{\n\tq = vec2(fbm(p), fbm(p + vec2(10, 1.3)));\n    \n    float s = dot(uv.x + 0.5, uv.y + 0.5);\n    r = vec2(fbm(p + 4.0 * q + vec2(t) + vec2(1.7, 9.2)), fbm(p + 4.0 * q + vec2(t) + vec2(8.3, 2.8)));\n    g = vec2(fbm(p + 2.0 * r + vec2(t * 20.0) + vec2(2, 6)), fbm(p + 2.0 * r + vec2(t * 10.0) + vec2(5, 3)));\n    return fbm(p + 5.5 * g + vec2(-t * 7.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // noise\n    vec2 q, r, g;\n    float noise = pattern(fragCoord * vec2(.004), iTime * 0.007, uv, q, r, g);\n    \n    // base color based on main noise\n    vec3 col = mix(vec3(0.1, 0.4, 0.4), vec3(0.5, 0.7, 0.0), smoothstep(0.0, 1.0, noise));\n    \n    // other lower-octave colors and mixes\n    col = mix(col, vec3(0.35, 0.0, 0.1), dot(q, q) * 1.0);\n    col = mix(col, vec3(0, 0.2, 1), 0.2*g.y*g.y);\n    col = mix(col, vec3(.3, 0, 0), smoothstep(0.0, .6, 0.6*r.g*r.g));\n    col = mix(col, vec3(0, .5, 0), 0.1*g.x);\n    \n    // some dark outlines/contrast and different steps\n    col = mix(col, vec3(0), smoothstep(0.3, 0.5, noise) * smoothstep(0.5, 0.3, noise));\n    col = mix(col, vec3(0), smoothstep(0.7, 0.8, noise) * smoothstep(0.8, 0.7, noise));\n    \n    // contrast\n    col *= noise*2.0;\n    \n    // vignette\n    col *= 0.70 + 0.65 * sqrt(70.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 101, 124, 124, 192], [194, 194, 220, 220, 604], [659, 659, 680, 680, 985], [1063, 1063, 1149, 1149, 1502], [1504, 1504, 1561, 1611, 2603]], "test": "untested"}
{"id": "NsKBDm", "name": "one wavelet curve fitting", "author": "lomateron", "description": "do you know a better method?", "tags": ["neuralnetwork"], "likes": 11, "viewed": 316, "published": 3, "date": "1658329220", "time_retrieved": "2024-07-30T16:39:43.772723", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 u = 2.*(fragCoord*2.-iResolution.xy)/iResolution.y*pi;\n    vec2 m = 8.*(iMouse.xy*2.-iResolution.xy)/iResolution.y;\n    //draw points of curve\n    float b = 4.;\n    float a = 0.;\n    for(int i = 0; i < POINTS; ++i)\n    {\n        a = max(a,1.-b*length(u-pnt(i)));\n    }\n    //draw wave\n    vec4 a0 = A(vec2(0.5,0));\n    vec4 a1 = A(vec2(1.5,0));\n    vec2 c  = wav(u.x,a0.x,a0.y)*a0.zw;\n    a = max(a,1.-8.*abs(c.x+c.y-u.y));\n\n    fragColor = vec4(a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define pi 3.141592\n#define POINTS 32                                          //how many points in curve\n#define dipo (.5/float(POINTS))                            //division by number of points\nvec2 wav(float x, float pos, float frq)\n{\n    x -= pos;\n    float x2 = x*frq;\n    return cos(x2-vec2(0,.5)*pi)/exp(x2*x2*.1);\n}\nvec2 pnt(int i)//get a point from curve the wave will fit into\n{\n    vec2 a = vec2(0);\n    float x = mod(float(i)+.5,float(POINTS));                       \n          //x = float(i);\n          //x = (x/64.*2.-1.)*8.;\n          x = (fract(cos(x*1234.56789)*3456.98765)*2.-1.)*8.;//get random pos in curve\n    float y = cos(x+.7)/exp(x*x*.1)*4.                       //curve equation\n             +(fract(cos(x*2345.76543)*4536.76543)*2.-1.)*.0;//add noise to curve\n    return vec2(x,y);\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 a0 = A(vec2(0.5,0));//wave properties x=pos y=frq z=cosAmpl w=sinAmpl\n    vec4 a1 = A(vec2(1.5,0));//xy=convolution*error when wave pos+.05\n                             //zw=convolution*error when wave pos-.05\n    vec4 a2 = A(vec2(2.5,0));//x=error when wave freqency*  1.001\n                             //y=error when wave freqency*1/1.001\n    vec4 a3 = A(vec2(3.5,0));//for experimenting \n    if(iFrame==0){a0 = vec4(6.,.5,0,0);\n                  a1 = vec4(0);\n                  a2 = vec4(0);\n                  a3 = vec4(0);}\n    \n    vec2 p  = pnt(iFrame);\n    vec2 w1 = wav(p.x,a0.x    ,a0.y          );\n    vec2 w2 = wav(p.x,a0.x+.02,a0.y          );\n    vec2 w3 = wav(p.x,a0.x-.02,a0.y          );\n    vec2 w4 = wav(p.x,a0.x    ,a0.y*exp( .02));\n    vec2 w5 = wav(p.x,a0.x    ,a0.y*exp(-.02));\n    float r = p.y-dot(w1,a0.zw);\n    a0.zw += r*w1*.1;\n    a1.xy += (w2*p.y*r               - a1.xy)*dipo;\n    a1.zw += (w3*p.y*r               - a1.zw)*dipo;\n    a2.x  += (abs(p.y-dot(w4,a0.zw)) - a2.x )*dipo;\n    a2.y  += (abs(p.y-dot(w5,a0.zw)) - a2.y )*dipo;\n    a0.x += length(a1.xy)-length(a1.zw);\n    a0.y *= exp((a2.y-a2.x)*.2);\n    if(fragCoord.x==0.5){fragColor = a0;}\n    if(fragCoord.x==1.5){fragColor = a1;}\n    if(fragCoord.x==2.5){fragColor = a2;}\n    if(fragCoord.x==3.5){fragColor = a3;}\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 518]], "test": "untested"}
{"id": "fdKBDm", "name": "2nd deepest NOR 4inputs", "author": "lomateron", "description": "twin of the deepest for 4inputs\nit takes 14 NORs to compute\nlooks nearly the same but as inverted color", "tags": ["binaryfunction"], "likes": 3, "viewed": 180, "published": 3, "date": "1658328439", "time_retrieved": "2024-07-30T16:39:44.616467", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define pi 3.141592653589793238\nfloat nor(float a, float b)\n{\n    return (+cos(pi*(a*0.+b*0.))\n            +cos(pi*(a*0.+b*1.))\n            +cos(pi*(a*1.+b*0.))\n            +cos(pi*(a*1.+b*1.)))*.25;//change .25 to something else\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    //float â â â â â â â â â¡â¡â¡â¡â¡â¡â¡â¡ = A(u+vec2( 1, 0)).x;\n    //float â â â â â¡â¡â¡â¡â â â â â¡â¡â¡â¡ = A(u+vec2( 0, 1)).x;\n    //float â â â¡â¡â â â¡â¡â â â¡â¡â â â¡â¡ = A(u+vec2(-1, 0)).x;\n    //float â â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡ = A(u+vec2( 0,-1)).x;\n    //float â¡â¡â¡â¡â¡â¡â¡â¡â â â â â â â â  = nor( â â â â â â â â â¡â¡â¡â¡â¡â¡â¡â¡ , â â â â â â â â â¡â¡â¡â¡â¡â¡â¡â¡ ); \n    //float â¡â¡â¡â¡â â â â â¡â¡â¡â¡â â â â  = nor( â â â â â¡â¡â¡â¡â â â â â¡â¡â¡â¡ , â â â â â¡â¡â¡â¡â â â â â¡â¡â¡â¡ );\n    //float â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡â  = nor( â â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡ , â â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡ );\n    //float â¡â¡â¡â¡â â â â â â â â â â â â  = nor( â â â â â â â â â¡â¡â¡â¡â¡â¡â¡â¡ , â â â â â¡â¡â¡â¡â â â â â¡â¡â¡â¡ );\n    //float â â â â â â â â â â â â â¡â¡â¡â¡ = nor( â¡â¡â¡â¡â¡â¡â¡â¡â â â â â â â â  , â¡â¡â¡â¡â â â â â¡â¡â¡â¡â â â â  );\n    //float â â â â â¡â¡â¡â¡â¡â¡â¡â¡â â â â  = nor( â¡â¡â¡â¡â â â â â â â â â â â â  , â â â â â â â â â â â â â¡â¡â¡â¡ );\n    //float â¡â¡â â â â â â â â â â â¡â¡â â  = nor( â â â â â¡â¡â¡â¡â¡â¡â¡â¡â â â â  , â â â¡â¡â â â¡â¡â â â¡â¡â â â¡â¡ );\n    //float â â â¡â¡â â â â â â â â â â â¡â¡ = nor( â â â â â¡â¡â¡â¡â¡â¡â¡â¡â â â â  , â¡â¡â â â â â â â â â â â¡â¡â â  );\n    //float â â â â â¡â¡â â â¡â¡â â â â â â  = nor( â â â¡â¡â â â¡â¡â â â¡â¡â â â¡â¡ , â¡â¡â â â â â â â â â â â¡â¡â â  );\n    //float â¡â¡â â â â â¡â¡â â â¡â¡â¡â¡â â  = nor( â â â¡â¡â â â â â â â â â â â¡â¡ , â â â â â¡â¡â â â¡â¡â â â â â â  );\n    //float â â â¡â¡â¡â¡â â â¡â¡â â â â â â  = nor( â¡â¡â â â â â¡â¡â â â¡â¡â¡â¡â â  , â â â â â â â â â â â â â¡â¡â¡â¡ );\n    //float â â â¡â â¡â â â â¡â â â â â â¡â  = nor( â¡â¡â â â â â¡â¡â â â¡â¡â¡â¡â â  , â â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡ );\n    //float â â¡â â â â â â¡â â â â¡â â¡â â¡ = nor( â â â¡â¡â¡â¡â â â¡â¡â â â â â â  , â¡â â¡â â¡â â¡â â¡â â¡â â¡â â¡â  );\n    //float â¡â â â¡â â¡â¡â â â¡â¡â â¡â â â  = nor( â â â¡â â¡â â â â¡â â â â â â¡â  , â â¡â â â â â â¡â â â â¡â â¡â â¡ );\n    float a = A(u+vec2(-1,-1)).x;\n    float b = A(u+vec2( 0,-1)).x;\n    float c = A(u+vec2(+1,-1)).x;\n    float d = A(u+vec2( 0,-2)).x;\n    float e = nor( a , a );\n    float f = nor( b , b );\n    float g = nor( d , d );\n    float h = nor( a , b );\n    float i = nor( e , f );\n    float j = nor( h , i );\n    float k = nor( j , c );\n    float l = nor( j , k );\n    float m = nor( c , k );\n    float n = nor( l , m );\n    float o = nor( n , i );\n    float p = nor( n , d );\n    float q = nor( o , g );\n          o = nor( p , q );\n          //o  = nor(o,o);\n    if(iFrame==0)\n    {\n        o = fract(cos(dot(u,vec2(1234.1234,4321.4321)))*1234.5678);\n        o *= float(u.x>100.&&u.x<110.);\n        o = +float(u.x==000.5)*1.\n            +float(u.x==111.5)*0.\n            +float(u.x==222.5)*0.;\n        //o = round(o);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=A(u).x;}\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdKBDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "NsKBDw", "name": "spider crawler", "author": "FabriceNeyret2", "description": "reproducing https://twitter.com/KomaTebe/status/1549001155338018818\n\nmouse control ( click bottom left for demo back ) ", "tags": ["2d", "short", "golf", "reproduction", "3tweets"], "likes": 23, "viewed": 375, "published": 3, "date": "1658317859", "time_retrieved": "2024-07-30T16:39:45.634745", "image_code": "// readable version below\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.* ( u+u - R ) / R.y,\n         M = iMouse.xy, D;\n    M = length(M)<10. ?  2.*cos(iTime+vec2(0,11)) + sin(2.1*iTime+vec2(0,12))\n                      :  5.*( M+M - R ) / R.y, // mouse control\n    O-=O;\n    for( int k=0; k<25; k++) {\n        float d = dot( D = vec2(k%5,k/5)-2. - fract(M), D);\n        d > 1. && d < 4.                       // draw AA line\n            ? O += max(0., 1.-R.y/15.* length( U-M - D * clamp( dot(U-M,D)/d, 0.,1.) ) )\n            : O;\n     }\n}\n\n\n\n\n\n\n/** // --- 407 chars\n\n#define S(v) smoothstep(15./R.y,0.,v)          // antialiasing\n\nfloat L(vec2 p, vec2 a,vec2 b) {               // draw line\n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );                       \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 5.* ( u+u - R ) / R.y, I = floor(U),\n         M = iMouse.xy, J;\n    M = length(M)<10. ? 2.*cos(iTime+vec2(0,11)) + sin(2.1*iTime+vec2(0,12))\n                      : 5.*( M+M - R ) / R.y, // mouse control\n    O-=O;\n    for( int k=0; k<25; k++) {\n        J = I + vec2(k%5-2,k/5-2);\n        float d = length( J - M );\n        d > 1. && d < 2. ?  O += S(L( U, J, M)) : O;\n    }\n // O += S(length(U-I));                       // show grid dots\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsKBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 65, 65, 578]], "test": "untested"}
{"id": "fdVBDw", "name": "Circle Repetition SDF", "author": "iq", "description": "Computing the SDF of a limited number of copies of a base SDF object constrained to a circle.", "tags": ["2d", "distancefield", "sdf", "repetition", "limited"], "likes": 41, "viewed": 908, "published": 3, "date": "1658317428", "time_retrieved": "2024-07-30T16:39:46.471508", "image_code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Computing the SDF of a limited number of copies of a base\n// SDF object constrained to a circle.\n\n// Related techniques:\n//\n// Elongation  : https://www.shadertoy.com/view/Ml3fWj\n// Rounding    : https://www.shadertoy.com/view/Mt3BDj\n// Onion       : https://www.shadertoy.com/view/MlcBDj\n// Metric      : https://www.shadertoy.com/view/ltcfDj\n// Combination : https://www.shadertoy.com/view/lt3BW2\n// Repetition  : https://www.shadertoy.com/view/3syGzz\n// Extrusion2D : https://www.shadertoy.com/view/4lyfzw\n// Revolution2D: https://www.shadertoy.com/view/4lyfzw\n//\n// More information here: https://iquilezles.org/articles/distfunctions\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdBox( in vec2 p, in vec2 b ) \n{\n    vec2 q = abs(p) - b;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n// the SDF we want to repeat\nfloat sdBase( in vec2 p, vec2 id, float sp, in float time )\n{\n    float d;\n    if( sin(time/2.0)>0.0 )\n    {\n        d = sdBox( p, vec2(0.1,0.1)*sp ) - 0.2*sp;\n    }\n    else\n    {\n        if( mod(id.x+id.y,2.0)>0.5 )\n          d = sdBox( p, vec2(0.2*sp) );\n        else\n          d = sdBox( p, vec2(0.2,0.02)*sp ) - 0.3*sp;\n    }\n    return d;\n}\n\n// the point of this shader\nfloat sdCircularRepetition( in vec2 p, float ra, float sp, float time )\n{\n    // make grid\n    vec2 id0 = round(p/sp);\n    \n    // snap to circle\n    if( dot(id0,id0)>ra*ra ) id0 = round(normalize(id0)*ra);\n    \n    // scan neighbors\n    float d = 1e20;\n    for( int j=-2; j<=2; j++ ) // increase this search window\n    for( int i=-2; i<=2; i++ ) // for large values of ra\n    {\n        vec2 id = id0 + vec2(i,j);\n        if( dot(id,id)<=ra*ra )\n        {\n            vec2 q = p-sp*id;\n            d = min( d, sdBase(q,id,sp,time) );\n        }\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\t\n    float time = iTime + 0.001;\n    \n    // circle radius and cell size, to be tuned for your needs\n    float ra = floor(3.0 + 8.0*(0.5-0.5*cos(time)));\n    float sp = 0.8/ra;\n\n    // sdf\n    float d = sdCircularRepetition( p, ra, sp, time );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-32.0*abs(d));\n\tcol *= 0.8 + 0.2*cos( 120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.009,abs(d)) );\n   \n    if( iMouse.z>0.001 )\n    {\n    d = sdCircularRepetition( m, ra, sp, time );\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVBDw.jpg", "access": "api", "license": "mit", "functions": [[1721, 1770, 1808, 1808, 1890], [1892, 1921, 1982, 1982, 2267], [2269, 2297, 2370, 2387, 2862], [2864, 2864, 2921, 2921, 3811]], "test": "untested"}
{"id": "7dGfWw", "name": "Minimal Fluidish Simulacre", "author": "leon", "description": "fluidicly incorrect", "tags": ["fluid", "small"], "likes": 61, "viewed": 1086, "published": 3, "date": "1658309242", "time_retrieved": "2024-07-30T16:39:47.388057", "image_code": "\n// Minimal Fluidish Simulacre\n\n// found by accident that shifting pixels\n// on a height map with the slope direction\n// calculated by sampling neighbors at random long range\n// produces somehow turbulent fluid movement\n\n// i'm amazed that it produces such organic patterns\n// when there is no perlin noise, no gyroid, no force fields\n// just white grainy noise and slope movement\n\n// this accident is dedicated to Cornus Ammonis\n// which works inspired me in so many ways\n// and because this shader looks like a drunken version of his work\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Dave Hoskins https://www.shadertoy.com/view/4djSRW\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define T(uv) texture(iChannel0,uv).a\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // the salt of life\n    float noise = hash13(vec3(fragCoord, iFrame));\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // random spawn\n    float height = clamp(.001/noise,0.,1.);\n    \n    // mouse interaction\n    if (iMouse.z > 0.)\n        height += clamp(.02/length(uv-iMouse.xy/iResolution.xy), 0., 1.);\n    \n    // move uv toward slope direction\n    vec2 e = vec2(.2*noise,0);\n    vec2 normal = normalize(vec2(T(uv+e.xy)-T(uv-e.xy),T(uv+e.yx)-T(uv-e.yx)));\n    uv += 5. * normal * noise / iResolution.xy;\n\n    // accumulate and fade away\n    height = max(height, texture(iChannel0, uv).a - .005*noise);\n    \n    // lighting\n    e = vec2(2./iResolution.y, 0);\n    normal = normalize(vec2(T(uv+e.xy)-T(uv-e.xy),T(uv+e.yx)-T(uv-e.yx)));\n    float light = dot(normal, vec2(0,-1))*.5+.5;\n    \n    fragColor = vec4(vec3(light*height), height);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[542, 542, 599, 599, 681]], "test": "untested"}
{"id": "fdGfWh", "name": "SD gradient", "author": "kosmonaut", "description": "normal (gradient) of a signed distance function. Click for SDF visualization.", "tags": ["signeddistancefield"], "likes": 3, "viewed": 165, "published": 3, "date": "1658302714", "time_retrieved": "2024-07-30T16:39:48.619764", "image_code": "//#define SD_POINT\n\n//#define vis0\n//#define vis1\n\nfloat sdFunc(vec2 fragPos)\n{\n\n    #ifdef SD_POINT\n    \n    return length(point * iResolution.xy - fragPos) - (80. + 40.*sin(iTime*0.5));\n    \n    #endif\n    \n    float sdf_angle = 1. + iTime / 2.;\n    \n    fragPos -= vec2(0.5, 0.5) * iResolution.xy;\n    fragPos *= mat2(cos(sdf_angle),-sin(sdf_angle),sin(sdf_angle),cos(sdf_angle)); \n    fragPos -= vec2(0.0, -0.2) * iResolution.xy;\n    vec2 d = abs(fragPos) - vec2(110.,20.); \n    \n    float rect = min(max(d.x,d.y),0.0) + length(max(d,0.0)); \n    \n    vec2 d2 = abs(fragPos) - vec2(20.,110.); \n    float rect2 = min(max(d2.x,d2.y),0.0) + length(max(d2,0.0));\n    \n    float circle = distance(fragPos, vec2(150., 150.)) - 60.;\n    circle = min(circle, distance(fragPos, vec2(-150, 150.)) - 120.);\n    \n    \n \treturn min(min(rect, circle), rect2);\n    \n}\n\nvec4 colorFunc( vec2 fragCoord )\n{\n    vec4 color;\n    float sd = sdFunc(fragCoord);\n    \n    float eps = 0.1;\n    \n    vec2 normal = vec2(sd - sdFunc(fragCoord - vec2(eps, 0)), sd - sdFunc(fragCoord - vec2(0, eps)));\n    normal = normalize(normal);\n    \n    // fix the normal to 0.1\n    //normal = (normal + vec2(1,1))*.5;\n    vec2 grad = normal;\n    //grad = (grad + vec2(1,1))*.5;\n    \n    #ifdef vis0\n    color = vec4(1,1,1,1);\n    if(sd < 0.) \n    {\n        color = vec4(0.4,0.4,1,1);\n    }\n    return color;\n    #endif\n    \n    #ifdef vis1\n    color = vec4( abs(sd / max(iResolution.x, iResolution.y))*10. );\n    if(sd < 0.)\n    color = vec4(color.r, 0, 0, 1);\n    return color;\n    #endif\n    \n    if(iMouse.z > 0.)\n    {\n        color = vec4( fract(sd / max(iResolution.x, iResolution.y) * 20.) );\n    }\n    else\n    {\n        color = vec4(grad,0,1);\n    }\n    \n    if(sd < 0.) \n    {\n        color = vec4(0.4,0.4,1,1);\n    }\n   \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = colorFunc(fragCoord);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 79, 79, 855], [857, 857, 891, 891, 1814], [1817, 1817, 1874, 1874, 1914]], "test": "untested"}
{"id": "ssGfDw", "name": "Pseudo Particles ", "author": "Plento", "description": " A WIP concept in making a ton of individual point particles. Energy is definitely not being conserved properly but so far it looks ok. Use the MOUSE to drag stuff around and press A to zoom in while using the mouse.", "tags": ["2d", "mouse", "experiment", "fluid", "particles", "physics", "mass"], "likes": 29, "viewed": 758, "published": 3, "date": "1658291892", "time_retrieved": "2024-07-30T16:39:49.476473", "image_code": "/*\n    By Cole Peterson (Plento)\n    \n    \n    An experiment in making a ton of stuff that look like particles.\n    Still some things to work out but so far Im happy.\n    \n    Cells store mass and velocity.\n    \n    Use the mouse to drag stuff around.\n    \n    Press A to zoom while using the mouse.\n    \n*/\n\n\nvoid zoom(inout vec2 u){\n    u -= iMouse.xy;\n    u *= .6;\n    u += iMouse.xy;\n}\n\nvec3 pal(float t){\n    return 0.5+0.44*cos(vec3(1.4, 1.1, 1.4)*t + vec3(1.1, 6.1, 4.4) + .5);\n}\n\n// Main color\nvec3 color(vec2 u, vec4 bA){\n    float t = abs(bA.z*2.) + abs(bA.w*4.) + 3.6*length(bA.zw);\n    vec3 col = vec3(clamp(bA.x, 0., 1.)) * pal(t*.2 + .3);\n    return col * 3.6;\n}\n\n\n// glow effect\nfloat glow(vec2 u){\n    vec2 uv = u / R;\n    float blur = 0.;\n\n    const float N = 3.;\n    \n    for(float i = 0.; i < N; i++)\n    {\n        blur += texture(iChannel0, uv + vec2(i*.001, 0.), 1.1).x;\n        blur += texture(iChannel0, uv - vec2(i*.001, 0.), 1.1).x;\n    \n        blur += texture(iChannel0, uv + vec2(0., i*.001), 1.1).x;\n        blur += texture(iChannel0, uv - vec2(0., i*.001), 1.1).x;\n    }\n        \n    return blur / N*4.;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = u / R;\n        \n    if(KEY(65., 0.) > 0.) zoom(u);\n\n    vec4 bA = A(u);\n\n    vec3 col = color(u, bA);\n\n    float g = glow(u);\n    \n    col += 0.08*g*pal(1.5*length(bA.zw));\n    \n    f = vec4(sqrt(clamp(col, 0.0, 1.0)), 1.0);\n}\n\n\n\n\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2((iMouse.xy - .5*R) / R.y)\n#define KEY(v,m) texelFetch(iChannel3, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n\n#define A(p) texelFetch(iChannel0,  ivec2(p), 0)\n#define B(p) texelFetch(iChannel1,  ivec2(p), 0)\n#define C(p) texelFetch(iChannel2,  ivec2(p), 0)\n#define D(p) texelFetch(iChannel3,  ivec2(p), 0)\n\n\n\n// Add the force coming from the side\n#define SIDE_FORCE\n\n\n\n// Constants\nconst vec2 UP = vec2(0., 1.);\nconst vec2 DOWN = vec2(0., -1.);\nconst vec2 LEFT = vec2(-1., 0.);\nconst vec2 RIGHT = vec2(1., 0.);\nconst vec2 UPL = vec2(-1., 1.);\nconst vec2 DOWNL = vec2(-1., -1.);\nconst vec2 UPR = vec2(1., 1.);\nconst vec2 DOWNR = vec2(1., -1.);\n\n\n\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n", "buffer_a_code": "/*\n    Buffer A: \n    \n    Track cell's mass and velocity.\n    \n    4 main things hapening.\n    \n    1. Add mass to cell proportional  to: (change in mass) * (dot(mass gradient direction, cell  velocity))\n    2. Subtract mass from cell proportional to: (average mass of neighborhood) * (dot(mass gradient direction, cell  velocity))\n    3. Apply acceleration to cell velocity: CellVelocity += (VelocityAverage - CellVelocity) \n    4. Apply a gravity ish force to cell velocity. This \"de snakes\" the particles and clumps them into points.\n    \n    x = mass\n    zw = velocity\n    \n*/\n\n\n \n// Neighborhood averages\nvec4 Grad(vec2 u)\n{\n    float h = 1.;\n    \n    vec4 up = A((u + vec2(0., h)));\n    vec4 down = A((u - vec2(0., h)));\n    vec4 left = A((u - vec2(h, 0.)));\n    vec4 right = A((u + vec2(h, 0.)));\n    \n    \n    vec4 upl = A((u + UPL));\n    vec4 downl = A((u + DOWNL));\n    vec4 upr = A((u + UPR));\n    vec4 downr = A((u + DOWNR));\n    \n    vec4 avg = (up+down+left+right+upr+downr+upl+downl) / 8.;\n    return avg;\n}\n\n// Direction of most mass relative to cell\nvec2 massGrad(vec2 u)\n{\n    float up = A((u + UP)).x;\n    float down = A((u + DOWN)).x;\n    float left = A((u + LEFT)).x;\n    float right = A((u + RIGHT)).x;\n\n    float upl = A((u + UPL)).x;\n    float downl = A((u + DOWNL)).x;\n    float upr = A((u + UPR)).x;\n    float downr = A((u + DOWNR)).x;\n    \n    vec2 cm = vec2(0., 0.);\n    cm += up*UP;\n    cm += down*DOWN;\n    cm += left*LEFT;\n    cm += right*RIGHT;\n    \n    cm += upl*UPL;\n    cm += downl*DOWNL;\n    cm += upr*UPR;\n    cm += downr*DOWNR;\n    \n    return cm;\n}\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    \n    // bA.x = mass, bA.zw = velocity\n    vec4 bA = A(u);\n    \n    vec4 grad = Grad(u); // Gradient at point of cell\n    vec2 vAvg = grad.zw; // Average velocity of surrounding cells\n    vec2 acc = vAvg - bA.zw; // Cell acceleration\n    acc = clamp(acc, -1., 1.);\n\n    bA = mix(bA, grad, .02); // Substitute in a little bit of the average\n\n    vec2 mg = massGrad(u); // Direction relative to current cell of most mass\n\n    float massAvg = grad.x; // Average surrounding mass\n    float massDif = massAvg - bA.x; // How fast the mass should be changing\n    \n    // Add and subtract mass from cell based on how much its moving in the direction of most mass\n    // and how fast the mass is changing\n    float dp = dot(mg, bA.zw); // How much the cell is moving toward the center of mass gradient\n    bA.x -= dp*massAvg;\n    bA.x += .999*dp*massDif;\n    \n    // Apply acceleration\n    bA.zw += acc;\n    \n    // Apply a gravity ish force (clumps stuff into single points)\n    float r = max(length(mg), 1.);\n    float grav = -(3.5*massAvg*bA.x) / (r*r);\n    bA.zw -= (mg)*grav;\n    \n    // Apply some friction\n   // bA.zw -= bA.zw*.0003;\n    \n    \n    // Add stuff with mouse\n    if(iMouse.z > 0.){\n       vec2 v = (C(u).xy - iMouse.xy);\n       if(length(v) < 100.){\n        \n            float d = length(iMouse.xy-u);\n            float frc = .065*exp2(-d*.025);       \n        \n            bA.zw -= frc * v;    \n            bA.x+=.08*frc;\n        }\n    }\n   \n    \n    #ifdef SIDE_FORCE\n    // Apple a small force coming from the left and add some mass\n    float sf = .002*ss(R.x, 0., u.x * 0.9);\n    bA.zw += sf*vec2(1., 0.);\n    bA.x += .06*sf;\n    #endif\n   \n    // Inita\n    if(iFrame < 8){\n        bA = vec4(0);\n        \n        if(hash12(u*343. + 232.) < .1){\n            bA.zw = 12.*(2.*hash22(u*543. + 332.) - 1.);\n            bA.x = hash22(u*543. + 332.).x;\n        }\n    }\n    \n    \n    bA.zw = clamp(bA.zw, -120., 120.);\n    bA.x = clamp(bA.x, 0., 1.);\n   \n    \n    f = bA;\n \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Store mouse last pos nothin to see here\nvoid mainImage( out vec4 f, in vec2 u ){\n    f = vec4(iMouse.xy, 0., 0.);\n}", "buffer_c_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[310, 310, 334, 334, 389], [391, 391, 409, 409, 486], [488, 502, 530, 530, 676], [679, 694, 713, 713, 1135], [1138, 1138, 1178, 1178, 1419]], "test": "untested"}
{"id": "fdGfDw", "name": "Eslimi-1", "author": "zorba20002", "description": "islamic", "tags": ["islamic"], "likes": 8, "viewed": 270, "published": 3, "date": "1658243355", "time_retrieved": "2024-07-30T16:39:50.235444", "image_code": "float node(vec2 uv, vec2 pos, float r){\n    uv.x = abs(uv.x);\n    uv/=r;\n    float c = (uv.y<pos.y?step(dot(uv-pos-vec2(0.,.45),normalize(vec2(1.,-1.61803398875))),1.):\n            step(dot(uv-pos,normalize(vec2(1.61803398875,1.))),1.)) \n            - \n            (uv.y<pos.y?step(dot(uv-pos-vec2(0.,.45),normalize(vec2(1.,-1.61803398875))),1.-0.05):\n            step(dot(uv-pos,normalize(vec2(1.61803398875,1.))),1.-0.05))\n            ;\n\n    return c;\n}\n\nmat2 rotate2d(float _angle){\n        return mat2(cos(_angle),sin(_angle),\n                    -sin(_angle),cos(_angle));\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/\n        (iResolution.y < iResolution.x ? iResolution.y : iResolution.x);\n      \n    float col = 0.;  \n    float scale = 10.;\n    vec3 res = vec3(0.);\n    uv*=scale;\n\n    float foldNum = 12.;\n    for (float i=0.;i<foldNum;i+=1.){\n        uv = rotate2d(2.*3.1415/foldNum) *uv;\n        float var = 1.+0.5*(sin(-2.*iTime+i*2.*3.1415/foldNum)+1.)/4.;\n        col = node(uv, vec2(0.,2.), var);\n        res.r = max(res.r, col*cos(iTime/10.));\n        res.g = max(res.g, col*sin(iTime/10.));\n        res.b = max(res.b, col * var);\n    }\n\n    \n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 455], [457, 457, 485, 485, 583], [585, 585, 642, 642, 1262]], "test": "untested"}
{"id": "fdGfWw", "name": "Tectonic Turbulence Timelapse", "author": "leon", "description": "planet earth is alive", "tags": ["terrain", "fluid", "planet"], "likes": 22, "viewed": 425, "published": 3, "date": "1658240014", "time_retrieved": "2024-07-30T16:39:50.994415", "image_code": "\n// Tectonic Turbulence Timelapse\n\n// buffer A: fake fluid simulation\n// buffer B: raymarching terrain and rendering\n// buffer C: temporal anti aliasing\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// the fluidish simulacre buffer\n// basically a animated heightmap fading with turbulence\n\n// fbm gyroid noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        seed.z += iTime*.1;\n        result += (gyroid(seed/a))*a;\n        a /= 3.;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // init\n    if (iFrame < 1) {\n        fragColor = vec4(1,1,1,1);\n        return;\n    }\n    \n    // coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // noise\n    vec3 blue = texture(iChannel1, fragCoord/1024.).rgb;\n    \n    // shape\n    vec2 spawn = hash22(fragCoord)*2.-1.;\n    float shape = length(p-spawn);\n    float shade = smoothstep(.1,.0,shape);\n    \n    // force\n    vec2 offset = vec2(0);\n    \n    // bubble\n    vec2 pp = fract(p*.5-vec2(.5,iTime*.2))-.5;\n    float lpp = length(pp);\n    float mask = smoothstep(.5,.0,lpp);\n    offset -= pp*mask*10.;\n    \n    // expansion\n    vec4 data = texture(iChannel0, uv);\n    vec3 unit = vec3(blue.x*60./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv - unit.xz)-TEX(uv + unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        0.)-.001);\n    offset -= normal.xy;\n    \n    // turbulence\n    vec3 seed = vec3(p*4.,p.x);\n    float angle = fbm(seed)*6.28;\n    offset += vec2(cos(angle),sin(angle));\n    \n    // fading\n    vec4 frame = texture(iChannel0, uv+offset/iResolution.xy);\n    shade = max(shade, frame.r-iTimeDelta*.2);\n    fragColor = vec4(shade);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define TEX(uv) texture(iChannel0, uv).r\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);   \n}", "buffer_b_code": "\n// raymarching buffer\n// rendering the heightmap from buffer A\n// with lighting and coloring\n\nfloat height;\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // uv scroll and mirror\n    vec2 uv = p.xz*.1-.5;\n    uv.y -= iTime*.1;\n    uv = abs(mod(uv+1.,2.)-1.);\n    \n    // heightmap\n    height = texture(iChannel0, uv).r;\n    dist = p.y + height;\n    \n    return dist;\n}\n\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in float shade)\n{\n    // water, sand, grass and snow gradient\n    float h = 1.-height;\n    vec3 tint = vec3(0,0,2.*h);\n    tint = mix(tint, vec3(1), smoothstep(0.,.2,h-.3));\n    tint = mix(tint, vec3(h*.5,h,0), smoothstep(0.,.1,h-.4));\n    tint = mix(tint, vec3(1), smoothstep(0.,.2,h-.5));\n    \n    // lighting\n    color = tint * pow(dot(normal, vec3(0,1,0.))*.5+.5, 10.);\n    color += dot(normal, ray)*.5+.5;\n    color *= shade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(0,1,1.5);\n    vec3 ray = lookAt(pos, vec3(0), p, 1.);\n    \n    // noise\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    \n    // raymarch\n    const float count = 20.;\n    float steps = 0.;\n    float total = 0.;\n    float maxDist = 30.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < 4.*total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*white.z;\n        ray += white * total*.0005;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n\n        // NuSan https://www.shadertoy.com/view/3sBGzV\n        vec2 noff = vec2(.01,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n\n        coloring(color, pos, normal, ray, shade);\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 211, 211, 293]], "test": "untested"}
{"id": "ssGfDh", "name": "Battuto Vase", "author": "fenix", "description": "* I realize this runs very slowly, sorry about that. Probably needs spatial partitioning\n* Buffer A renders the ground, which is referenced during the ray march\n* Marching code derived from Liquid in glass by tmst: https://www.shadertoy.com/view/3tfcRS", "tags": ["sdf", "refraction", "glass", "vase", "battuto"], "likes": 7, "viewed": 357, "published": 3, "date": "1658213350", "time_retrieved": "2024-07-30T16:39:52.038623", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Buffer A renders all the rays that bounce off the table.\n//\n//  Marching code in common buffer derived from Liquid in glass by tmst:\n//      https://www.shadertoy.com/view/3tfcRS\n//\n//  Kind of trying to make something that looks like this (except polished):\n//      https://www.originalmuranoglass.com/images/stories/virtuemart/product/nightsky.jpg \n//\n//  I realize this is very slow and probably needs some kind of spatial partitioning. I could\n//  make slicing planes at the midpoints between each cutting sphere. Maybe I'll try that for\n//  version 2.0, unless someone beats me to it.\n//\n// ---------------------------------------------------------------------------------------\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip)\n{\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCamera(in vec2 uv, out vec3 camPos, out vec3 nvCamDir) {\n    float animate = iTime;\n    vec2 mouseAng = vec2(animate * 0.17, PI*0.3 + 0.1*cos(animate * 0.27));\n    if (iMouse.z > 0.0)\n        mouseAng += vec2(8.0*iMouse.x / iResolution.x,0.8*iMouse.y / iResolution.y);\n        \n    float radius = 5.0 + 2.0 * cos(animate * 0.1);\n    camPos = vec3(0.0, 1.0, 0.0) + radius * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = vec3(0.0);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord)\n{\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(iChannel0, camPos, nvCamDir, color, nvRayOut);\n\n    return blendOnto(color, SKYBOX(nvRayOut));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = mainColor(fragCoord);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ===============================\n// Table render\n// ===============================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 oldRes = texelFetch(iChannel0, ivec2(0, 0), 0);\n    bool init = oldRes.xyz != iResolution || iFrame == 0; // Init at the beginning or if the resolution changes\n    \n    if (init)\n    {\n        fragColor = vec4(GROUND_COLOR);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            // Store the resolution in the first pixel\n            fragColor = vec4(iResolution, iFrame);\n        }\n    }\n    else\n    {\n        int framesSinceReset = iFrame - int(oldRes.w);\n        \n        vec4 oldColor;\n        oldColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n\n        // Shoot a ray in a random direction\n        vec2 camUV = (fragCoord.xy / iResolution.xy) * TABLE_SIZE + TABLE_MIN;\n        vec3 camPos = vec3(camUV.x, TABLE_HEIGHT, camUV.y);\n        vec3 nvRayCur = noise(ivec3(iFrame * int(fragCoord.x), int(fragCoord.y) * iFrame, int(fragCoord.x * fragCoord.y))).xyz;\n        nvRayCur = normalize(nvRayCur);\n        if (nvRayCur.y < 0.0) nvRayCur.y = -nvRayCur.y;\n\n        vec4 newColor;\n        vec3 nvRayOut;\n        march(iChannel0, camPos, nvRayCur, newColor, nvRayOut);\n        \n        if (ivec2(fragCoord) == ivec2(0, 0))\n        {\n            fragColor = oldRes;\n        }\n        else\n        {\n            // Compute the average over time\n            fragColor = oldColor * float(framesSinceReset) / float(framesSinceReset + 1) + newColor / float(framesSinceReset + 1);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define LAST_FRAME iChannel0\n#define SKYBOX(v) vec3(dot(v, vec3(-0.4, 1.0, 0.4)))\nconst vec2 TABLE_MIN = vec2(-15.0, -15.0);\nconst vec2 TABLE_MAX = vec2(2.0, 2.0);\nconst vec2 TABLE_SIZE = TABLE_MAX - TABLE_MIN;\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\nfloat length2(vec3 v)\n{\n    return dot(v, v);\n}\n\nfloat square(float x)\n{\n    return x*x;\n}\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 15.0\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdfSphere(vec3 p, vec3 pos, float radius)\n{\n    return length(p - pos) - radius;    \n}\n\nfloat sdfInterior(vec3 p)\n{\n    return sdfSphere(p * vec3(2.0, 1.0, 2.0), vec3(0.0, 1.5, 0.0), 1.4);\n}\n\nconst ivec2 DIVS = ivec2(20, 20);\nconst vec2 DIVS_REL = vec2(DIVS) / (2.0 * PI);\nconst vec2 DIVS_NOISE = vec2(0.2, 0.3);\nconst float CUT_DIST = 3.3;\n\nvec3 getCutPos(vec2 spherical)\n{\n    vec2 spherical2 = spherical;\n    spherical2.x += PI;\n    spherical2 = mod(spherical2, vec2(PI * 2.0));\n    spherical2.x -= PI;\n    vec2 dirNoise = noise(ivec2(spherical2 * 100.0)).xy - 0.5;\n    vec2 spherical3 = spherical2 + dirNoise * DIVS_NOISE;\n    float sinX = sin(spherical3.x);\n    float sinY = sin(spherical3.y);\n    float cosX = cos(spherical3.x);\n    float cosY = cos(spherical3.y);\n\n    vec3 dir = vec3(sinY * cosX, cosY, sinY * sinX);\n    float radius = 0.75 + 0.25 * (abs(dir.y)) + 0.15 * dir.y;\n    return CUT_DIST * dir * radius;\n}\n\nvec3 pointCache[9]; // Store the most recently used points we already computed using some expensive trig functions\nvec2 cachedFor; // Remember what spherical voxel we have the points cached for\n\nfloat sdfGlass(vec3 p)\n{\n    vec3 delta = p;\n    float sd = sdfSphere(p, vec3(0), 3.0);\n\n    vec2 spherical = vec2(atan(delta.z, delta.x), atan(length(delta.xz), delta.y));\n    spherical = (floor(spherical * DIVS_REL) + 0.5) / DIVS_REL;//vec2((floor(theta * THETA_DIVS) + 0.5) / THETA_DIVS, (floor(phi * PHI_DIVS) + 0.5) / PHI_DIVS)\n\n    if (spherical != cachedFor)\n    {\n        // This would probably benefit from some kind of spatial partitioning, but for this version caching the positions per\n        // spherical \"voxel\" at least helps.\n        pointCache[0] = getCutPos(spherical + vec2(-1, -1) / DIVS_REL);\n        pointCache[1] = getCutPos(spherical + vec2(-1,  0) / DIVS_REL);\n        pointCache[2] = getCutPos(spherical + vec2(-1,  1) / DIVS_REL);\n        pointCache[3] = getCutPos(spherical + vec2( 0, -1) / DIVS_REL);\n        pointCache[4] = getCutPos(spherical + vec2( 0,  0) / DIVS_REL);\n        pointCache[5] = getCutPos(spherical + vec2( 0,  1) / DIVS_REL);\n        pointCache[6] = getCutPos(spherical + vec2( 1, -1) / DIVS_REL);\n        pointCache[7] = getCutPos(spherical + vec2( 1,  0) / DIVS_REL);\n        pointCache[8] = getCutPos(spherical + vec2( 1,  1) / DIVS_REL);\n        \n        cachedFor = spherical;\n    }\n    \n    sd = max(sd, - sdfSphere(p, pointCache[0], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[1], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[2], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[3], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[4], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[5], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[6], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[7], 1.3));\n    sd = max(sd, - sdfSphere(p, pointCache[8], 1.3));\n\n    float vase = max(-sdfInterior(p), sd);\n    \n    return max(vase, delta.y - 2.3);\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0) ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0) ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0) ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0) ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS) ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS) )  \\\n    ))\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n// rendering engine forked from Liquid in glass by tmst https://www.shadertoy.com/view/3tfcRS\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 50\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_COLOR vec3(0.1, 0.1, 1.0)\n#define GLASS_OPACITY 1.1\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n\n#define TABLE_HEIGHT -1.0\nconst float GROUND_COLOR = 0.515;\n\nvec4 computeSpecular(\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    const float specularCoefficient = 0.8;\n    const float specularExponent = 80.0;\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvoid march(in sampler2D tableSampler, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n\n    vec3 pCam = pRay;\n    vec3 pLight = pLightO;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = nvRayIn;\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur;\n        if (\n            (length2(centerToCur) > square(BOUNDING_SPHERE_RADIUS)) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) {\n            if (nvRayCur.y < 0.0)\n                color = blendOnto(color, vec4(GROUND_COLOR, GROUND_COLOR, GROUND_COLOR, 1.0));\n            else\n                color = blendOnto(color, vec4(SKYBOX(nvRayCur), 1.0));\n            break;\n        }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n\n        float sdGlass = sdfGlass(pCur);\n        vec3 dpStep = abs(sdGlass) * nvRayCur;\n\n        if (curSubstance == SUBSTANCE_AIR)\n        {\n            if (sdGlass < SDF_EPS)\n            {\n                vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n\n                if (dot(nvGlass,nvRayCur) < 0.0) \n                {\n                    curSubstance = SUBSTANCE_GLASS;\n\n                    vec4 sColor = computeSpecular(\n                        nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                    );\n                    color = blendOnto(color, sColor);\n\n                    // Schlick approximation\n                    float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                    float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                    float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                    vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                    color = blendOnto(color, valRefl*vec4(SKYBOX(nvRefl), 1.0));\n\n                    dpStep = sdGlass*nvRayCur;\n                    dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                    nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n                }\n            }\n        }\n        else if (curSubstance == SUBSTANCE_GLASS)\n        {\n            vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur);\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            color = blendOnto(color, length(dpStep) * clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n            }\n        } \n\n        pCur += dpStep;\n        \n        if (pCur.y <= TABLE_HEIGHT)\n        {\n            float t = (TABLE_HEIGHT - pCur.y) / dpStep.y;\n            pCur += t * dpStep;\n            \n            vec3 tableColor;\n            if (any(lessThan(pCur.xz, TABLE_MIN)) || any(greaterThan(pCur.xz, TABLE_MAX)))\n            {\n                tableColor = vec3(GROUND_COLOR);\n            }\n            else\n            {\n                vec2 tableUV = (pCur.xz - TABLE_MIN) / TABLE_SIZE;\n                tableColor = texture(tableSampler, tableUV).xyz;\n                vec2 deltaFromSide = max(vec2(0), abs(tableUV - 0.5) - 0.4);\n                float distFromSide = max(deltaFromSide.x, deltaFromSide.y) * 10.0;\n                tableColor = mix(vec3(GROUND_COLOR), tableColor, 1.0 - distFromSide);\n            }\n            color = blendOnto(color, tableColor);\n            break;\n        }\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = nvRayCur;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGfDh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1051, 1051, 1114, 1114, 1293], [1295, 1295, 1359, 1359, 1865], [1953, 1953, 1985, 1985, 2235], [2237, 2237, 2292, 2292, 2332]], "test": "untested"}
{"id": "sdyBDW", "name": "Function Layout Test p02z", "author": "NEAR_DREAM_UNITY", "description": "Getting a taste of the power of functional rather than procedural generation:\nWith procedural generation you can make millions of items,\nbut with functional generation you can make an infinite number of items.", "tags": ["test"], "likes": 2, "viewed": 271, "published": 3, "date": "1658176596", "time_retrieved": "2024-07-30T16:39:52.858432", "image_code": "#define  BuildingsPerQuad  2\n#define  AA                6.\nfloat    AA_Recip          = 1. / AA;\nfloat    AA_Sq             = AA * AA;\n\n\nfloat  Building  (ivec3 id, vec2 bq) {\n    // `id.xy` is the quad's lower grid coord.\n    // `id.z` is the building n per quad.\n    // `bq` is from [0,2) from the quad's corner.\n    // So layout range is pos:[0,1),size:[0,1):\n\n    #define H4(N) hash(uvec2(N * 1000 + id.x, id.z * 1000 + id.y))\n    \n    #define I4(N) (0.75 + 0.25 * sin(6.1414 * (H4(N) + 2. * iTime)))\n    \n    //DEV Can remove later:\n    #define C4(N) clamp(mod(I4(N), 1.), 0., 1.)\n    vec2 pos = vec2(H4(1), H4(2));\n    vec2 size = vec2(I4(3), I4(4));\n    float height = 0.25 + 0.75 * H4(5);\n    bool hit = (  pos.x <= bq.x\n        &&        pos.y <= bq.y\n        &&        bq.x <= pos.x + size.x\n        &&        bq.y <= pos.y + size.y);\n    return hit ? height : 0.;\n}\n\n\nfloat  AllBuildings  (vec2 q) {\n    // q = q_ipart + q_fpart\n    ivec2  q_ipart  = ivec2(floor(q));\n    vec2   q_fpart  = q - vec2(q_ipart);\n    float  v        = 0.;  //DEV length(0.1 * q_fpart);\n   \n    for (int xi = -1; xi <= 0; ++xi)\n    for (int yi = -1; yi <= 0; ++yi) {\n        ivec2  quad_ipart  = q_ipart + ivec2(xi, yi);\n        vec2   quad_fpart  = q - vec2(quad_ipart);\n        for (int bi = 0; bi < BuildingsPerQuad; ++bi)\n            v = max(v, Building(ivec3(quad_ipart, bi), quad_fpart));\n    }\n\n    return v;\n}\n\n\nvec3  HotColour  (float value) {\n    return 0.5 + 0.5 * cos(3.141 * (\n        vec3(1.5, 1., 0.) + value\n    ));\n}\n\n\nvoid  mainImage  (out vec4 o, vec2 p) {\n    o = vec4(0.);\n    for (float aax = 0.5; aax < AA; ++aax)\n    for (float aay = 0.5; aay < AA; ++aay) {\n        vec2 aap = p + vec2(aax, aay) * AA_Recip - 0.5;\n        vec2 q = (aap * 2. - iResolution.xy) / iResolution.y; \n        q *= 502. - 500. * cos(0.5 * iTime);\n        q += 100. * iTime * normalize(iResolution.xy);\n        float v = AllBuildings(q);\n        o += vec4(HotColour(v), 1.);\n    }\n    o /= AA_Sq;\n}\n\n", "image_inputs": [], "common_code": "\n\n//---- \"Integer Hash - III\" from https://www.shadertoy.com/view/4tXyWN\n// Copyright Â© 2017 Inigo Quilez\n// The MIT License: Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nfloat hash( uvec2 x )\n{\n    uvec2 q = 1103515245U * ( (x>>1U) ^ (x.yx   ) );\n    uint  n = 1103515245U * ( (q.x  ) ^ (q.y>>3U) );\n    return float(n) * (1.0/float(0xffffffffU));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyBDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 175, 362, 876], [879, 879, 910, 939, 1406], [1409, 1409, 1441, 1441, 1522], [1525, 1525, 1564, 1564, 1985]], "test": "untested"}
{"id": "ssyBWW", "name": "deepest NOR 4inputs", "author": "lomateron", "description": "this is the deepest NOR network for 4 inputs that exist\nbecause it takes a minimun of 15 NORs to compute\nand no other NOR network with 4 inputs takes more than 15 NORs to compute\nup next ... deepest 5 input NOR function...", "tags": ["binaryfunction"], "likes": 4, "viewed": 221, "published": 3, "date": "1658167055", "time_retrieved": "2024-07-30T16:39:53.872720", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define pi 3.141592653589793238\nfloat nor(float a, float b)\n{\n    return (+cos(pi*(a*0.+b*0.))\n            +cos(pi*(a*0.+b*1.))\n            +cos(pi*(a*1.+b*0.))\n            +cos(pi*(a*1.+b*1.)))*.25;//change .25 to something else\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float a = A(u+vec2(-1,-1)).x;\n    float b = A(u+vec2( 0,-1)).x;\n    float c = A(u+vec2(+1,-1)).x;\n    float d = A(u+vec2( 0,-2)).x;\n    float o1 = nor(a,b);  float o0 = o1;\n    float o2 = nor(o1,a); \n    float o3 = nor(o1,b);\n          a  = nor(o2,o3);\n          b  = c;\n          o1 = nor(a,b);\n          o2 = nor(o1,a);\n          o3 = nor(o1,b);\n    float o4 = nor(o2,o3);\n    float o5 = nor(o4,o4);\n    float d2 = nor(d,d);\n          o5 = nor(o5,d2);\n          o4 = nor(o4,o0);\n          o4 = nor(o4,o4);\n          o4 = nor(o4,d);\n    float o  = nor(o4,o5);\n    if(iFrame==0)\n    {\n        //o = fract(cos(dot(u,vec2(1234.1234,4321.4321)))*1234.5678);\n        //o *= float(u.x>100.&&u.x<111.);\n        o = float(u.x==111.5);\n        //o = round(o);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=A(u).x;}\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "fdyBDD", "name": "smooth NOR", "author": "lomateron", "description": "anything can be computed using only NOR or only NAND\nthis uses NOR\nI think this is one of the highest entropy NOR combinations for 4 inputs that has symetry across the 2Dspace", "tags": ["binaryfunction"], "likes": 7, "viewed": 242, "published": 3, "date": "1658163073", "time_retrieved": "2024-07-30T16:39:54.751370", "image_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = A(fragCoord);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define A(u) texture(iChannel0,(u)/iResolution.xy)\n#define pi 3.141592653589793238\nfloat nor(float a, float b)\n{\n    return (+cos(pi*(a*0.+b*0.))\n            +cos(pi*(a*0.+b*1.))\n            +cos(pi*(a*1.+b*0.))\n            +cos(pi*(a*1.+b*1.)))*.25;//change .25 to something else\n}\nvoid mainImage( out vec4 fragColor, in vec2 u )\n{\n    float a = A(u+vec2(-1,-1)).x;\n    float b = A(u+vec2( 0,-1)).x;\n    float c = A(u+vec2(+1,-1)).x;\n    float d = A(u+vec2( 0,-2)).x;\n    float o1 = nor(a,b);\n    float o2 = nor(o1,a);\n    float o3 = nor(o1,b);\n          a  = nor(o2,o3);\n          b  = c;\n          o1 = nor(a,b);\n          o2 = nor(o1,a);\n          o3 = nor(o1,b);\n          a  = nor(o2,o3);\n          b  = d;\n          o1 = nor(a,b);\n          o2 = nor(o1,a);\n          o3 = nor(o1,b);\n    float o  = nor(o2,o3);\n          o  = nor(o,o);\n    if(iFrame==0)\n    {\n        o = fract(cos(dot(u,vec2(1234.1234,4321.4321)))*1234.5678);\n        o *= float(u.x>100.&&u.x<110.);\n        o = +float(u.x==000.5)*.4799\n            +float(u.x==111.5)*1.\n            +float(u.x==222.5)*0.;\n        //o = round(o);\n    }\n    if(iFrame!=0&&int(u.y)!=(iFrame%int(iResolution.y))){o=A(u).x;}\n    fragColor = vec4(o);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 108, 108, 140]], "test": "untested"}
{"id": "fsGBWW", "name": "kaleido fun", "author": "zorba20002", "description": "mirror", "tags": ["mirror"], "likes": 2, "viewed": 204, "published": 3, "date": "1658142665", "time_retrieved": "2024-07-30T16:39:55.516324", "image_code": "float circle(vec2 uv, vec2 pos, float r){\n    float d= length(uv-pos);\n    float c= smoothstep(r,r-0.01,d)-smoothstep(r-0.01,r-0.02,d);\n    return c;\n}\n\nmat2 rotate2d(float _angle){\n        return mat2(cos(_angle),sin(_angle),\n                    -sin(_angle),cos(_angle));\n    }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/\n        (iResolution.y < iResolution.x ? iResolution.y : iResolution.x);\n      \n    float col = 0.;  \n\n    for (float i=0.;i<20.;i+=1.){\n        uv = rotate2d(sin((i*3.14/4.)-(sin(iTime/10.)+sin(iTime/12.))/2.)) *uv;\n        uv.x =  abs(uv.x-sin(i/100.*3.14/4.)-sin(iTime/1000.)) ;\n    }\n\n    col += circle(uv, vec2(0.2, 0.2), 0.2);\n    col += circle(uv, vec2(0.2, 0.3), 0.2);\n    float ang = 1.-atan(-uv.x, -uv.y);\n    vec3 res = vec3(col, ang/10., ang*(sin(2.5+iTime/10.)+1.)/10.);\n    \n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 151], [153, 153, 181, 181, 279], [280, 280, 337, 337, 911]], "test": "untested"}
{"id": "ssVfD1", "name": "circle-sqare-grid", "author": "zorba20002", "description": "grid", "tags": ["grid"], "likes": 5, "viewed": 251, "published": 3, "date": "1658142525", "time_retrieved": "2024-07-30T16:39:56.466783", "image_code": "float circle(vec2 uv, vec2 pos, float r, float ratio){\n    uv = abs(uv);\n    float d= (1.-ratio)*length(uv-pos)+ratio*1.39*dot(uv,normalize(vec2(1,1)));\n    float c= smoothstep(r,r-0.01,d)-smoothstep(r-d/10.,r-d/10.-0.01,d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/\n        (iResolution.y < iResolution.x ? iResolution.y : iResolution.x);\n      \n    float col = 0.;  \n    float scale = 10.;\n    \n    uv*=scale;\n    float gridSize = 0.5;\n\n    vec2 gv = fract(uv)-gridSize;\n    vec2 id = floor(uv);\n    float ratio = (sin(iTime+atan(id.y/id.x)*17.)+1.)/2.;\n    if(uv.x>-scale*0.3 && uv.x<scale*0.3 && uv.y>-scale*0.3 && uv.y<scale*0.3){\n        col += circle(gv, vec2(0,0), gridSize, ratio);\n    }\n    vec3 res = vec3(\n        col*((ratio+1.)/2.), \n        col*atan(.1*sin(id.y)+sin(5.+iTime/11.)), \n        col*atan(0.1*sin(id.x)+cos(iTime/13.)));\n    \n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 240], [242, 242, 299, 299, 970]], "test": "untested"}
{"id": "7sKfD1", "name": "Get, set, and toggle state", "author": "u004fu0077u004f", "description": "Click the bottom left button to switch to state 1 (red, green, and yellow).\nClick the bottom right button to switch to state 2 (blue, magenta, cyan, and white).\nClick the top right button to toggle.\nSpecial thanks to sixstring982, FabriceNeyret2, and iq.", "tags": ["beginner", "state"], "likes": 7, "viewed": 366, "published": 3, "date": "1658142066", "time_retrieved": "2024-07-30T16:40:00.437167", "image_code": "#define CHARACTERS_WIDE 16\n#define CHARACTERS_WIDE_F float(CHARACTERS_WIDE)\n#define CHARACTER_WIDTH 1./CHARACTERS_WIDE_F\n#define CHARACTERS_TALL 16\n#define CHARACTERS_TALL_F float(CHARACTERS_TALL)\n#define CHARACTER_HEIGHT 1./CHARACTERS_TALL_F\n#define CHARACTER_SAMPLER iChannel1\nvoid draw_character(inout vec4 color, vec2 uv, vec2 pos, uint index) {\n    uv -= pos;\n    if (uv.x < 0. || uv.y < 0. || uv.x >= CHARACTER_WIDTH || uv.y >= CHARACTER_HEIGHT) return;\n    uv.x += mod(float(index), CHARACTERS_WIDE_F)*CHARACTER_WIDTH;\n    uv.y += (CHARACTERS_TALL_F-floor(float(index)/CHARACTERS_TALL_F)-1.)*CHARACTER_HEIGHT;\n    vec4 text_color = texture(CHARACTER_SAMPLER, uv);\n    color.rgb = mix(color.rgb, vec3(1.), text_color.rrr);\n}\n#define C(index) {\\\n    draw_character(color, uv+vec2(CHARACTER_WIDTH*.25, 0.), pos, index);\\\n    pos.x += CHARACTER_WIDTH*.5;\\\n}\n\n#define MEM_SAMPLER iChannel0\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 uv = coord/iResolution.xy;\n    //color = texture(MEM_SAMPLER, uv); return; // Debug\n    color.a = 1.;\n    vec4 state = mem_read_cell(MEM_SAMPLER, MEM_STATE_CELL);\n    vec2 pos = vec2(0., 1.-CHARACTER_HEIGHT);\n    if (state == MEM_STATE_1) {\n        color.rgb = vec3(uv.x, uv.y, 0.)*.5;\n        C(0x53u);C(0x74u);C(0x61u);C(0x74u);C(0x65u);C(0x20u);C(0x31u); // \"State 1\"\n    } else if (state == MEM_STATE_2) {\n        color.rgb = vec3(uv.x, uv.y, 1.)*.5;\n        C(0x53u);C(0x74u);C(0x61u);C(0x74u);C(0x65u);C(0x20u);C(0x32u); // \"State 2\"\n    } else {\n        color.rgb = vec3(1., 0., 1.);\n        C(0x57u);C(0x54u);C(0x46u);C(0x21u);C(0x3fu); // \"WTF!?\"\n    }\n    if (\n        is_in_button(uv, BUTTON_STATE_1_MINS, BUTTON_STATE_1_MAXS)\n        || is_in_button(uv, BUTTON_STATE_2_MINS, BUTTON_STATE_2_MAXS)\n        || is_in_button(uv, BUTTON_STATE_TOGGLE_MINS, BUTTON_STATE_TOGGLE_MAXS)\n    ) {\n        color.rgb = mix(color.rgb, vec3(0.), .75);\n        pos = BUTTON_STATE_1_MINS;\n        C(0x53u);C(0x65u);C(0x74u);C(0x20u);C(0x31u); // \"Set 1\"\n        pos = BUTTON_STATE_2_MINS;\n        C(0x53u);C(0x65u);C(0x74u);C(0x20u);C(0x32u); // \"Set 1\"\n        pos = BUTTON_STATE_TOGGLE_MINS;\n        C(0x54u);C(0x6fu);C(0x67u);C(0x67u);C(0x6cu);C(0x65u); // \"Toggle\"\n    }\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MEM_SAMPLER iChannel0\nvoid mainImage(out vec4 color, vec2 coord) {\n    uint cell = uint(coord.y)*MEM_W+uint(coord.x);\n    switch (cell) {\n        case MEM_STATE_CELL:\n            // I was scratching my head for ages trying to figure out why the following line wasn't working properly.\n            // It took me too long to realize recompiling the shader doesn't reset the time.\n            color = iFrame == 0 ? MEM_STATE_1 : mem_read_cell(MEM_SAMPLER, cell);\n            if (iMouse.w > 0.) {\n                vec2 uv = iMouse.xy/iResolution.xy;\n                if (is_in_button(uv, BUTTON_STATE_1_MINS, BUTTON_STATE_1_MAXS)) {\n                    color = MEM_STATE_1;\n                } else if (is_in_button(uv, BUTTON_STATE_2_MINS, BUTTON_STATE_2_MAXS)) {\n                    color = MEM_STATE_2;\n                } else if (is_in_button(uv, BUTTON_STATE_TOGGLE_MINS, BUTTON_STATE_TOGGLE_MAXS)) {\n                    color = color == MEM_STATE_1 ? MEM_STATE_2 : MEM_STATE_1;\n                }\n            }\n            break;\n        default:\n            color = vec4(0.);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MEM_W 64u\n#define MEM_H 64u\nvec4 mem_read_cell(sampler2D sampler, uint cell) {\n    return texelFetch(sampler, ivec2(int(cell%MEM_W), int(cell/MEM_W)), 0);\n}\n#define MEM_STATE_CELL 0u\n#define MEM_STATE_1 vec4(0., 0., 0., 1.)\n#define MEM_STATE_2 vec4(1., 0., 0., 1.)\n#define is_in_button(uv, mins, maxs) uv.x >= mins.x && uv.y >= mins.y && uv.x < maxs.x && uv.y < maxs.y\n#define BUTTON_STATE_1_MINS vec2(.1, .1)\n#define BUTTON_STATE_1_MAXS vec2(.45, .45)\n#define BUTTON_STATE_2_MINS vec2(.55, .1)\n#define BUTTON_STATE_2_MAXS vec2(.9, .45)\n#define BUTTON_STATE_TOGGLE_MINS vec2(.55, .55)\n#define BUTTON_STATE_TOGGLE_MAXS vec2(.9, .9)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 349, 349, 730], [892, 892, 936, 936, 2215]], "test": "untested"}
{"id": "ssKBWh", "name": "sun -k-2-2d- ", "author": "jorge2017a2", "description": "sun -k-2-2d- ", "tags": ["sunk22d"], "likes": 8, "viewed": 214, "published": 3, "date": "1658109456", "time_retrieved": "2024-07-30T16:40:01.486362", "image_code": "//por jorge2017a2\n//sun -k-2-2d-  ///17-jul-2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n///IQ\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n\nvec4 pisotria(vec2 p,vec3 colOut)\n{\n   vec2 pr= Rotate( p, vec2(0.0),0.79);\n   \n   float d1a= sdBox(pr,vec2(2.5) );\n   float d1b= sdBox(pr,vec2(2.0) );\n   float dif1= differenceSDF(d1a, d1b);\n   \n   float d2a= sdBox(p-vec2(0.0,3.0),vec2(4.,3.0) );\n   dif1= differenceSDF(dif1, d2a);\n   \n   colOut= DrawFigBorde(vec3(0.0), colOut,abs(dif1) );\n   return vec4(colOut, abs(dif1)-0.1); \n   \n}\n\nvec4 dobletriaB(vec2 uv, vec3 colOut)\n{   vec2 uv0=uv;\n    uv.x=opRep1D( uv.x, 16.0);    \n    vec4 col1=pisotria(uv,colOut);\n    uv.x+=4.;\n    uv.y+=4.0;\n    vec4 col2=pisotria(vec2(uv.x,-uv.y),colOut);\n    float d1a=col1.w;\n    float d1c=col2.w;\n    float unitd=unionSDF(d1a, d1c);\n    colOut= DrawFigBorde(vec3(0.0), colOut,unitd);\n    return vec4( colOut,unitd);\n}\n\nvec3 dobletriaC(vec2 uv, vec3 colOut)\n{   vec2 uv0=uv;\n    vec4 col1=dobletriaB(uv, colOut);\n    vec4 col2=dobletriaB(uv-vec2(8.0,0.0), colOut);\n    float d1=col1.w;\n    float d2=col2.w;\n    float unitd=unionSDF(d1, d2);\n    colOut= DrawFigBorde(vec3(0.0), colOut,unitd);\n    return colOut;\n}\n\nvec3 pisof2(vec2 uv, vec3 colOut)\n{   vec2 uv0=uv;\n    uv.y+=18.;\n    vec3 col=colOut;\n    vec2 pr=uv-vec2(0.0,6.0);\n    pr.x=opRep1D(pr.x, 16.0);\n    pr.y=abs(pr.y)-5.0;\n    float d1a= sdBox(pr,vec2(8.0,0.5) );\n    d1a=abs(d1a)-0.2;\n    col= dobletriaC(uv-vec2(0.0,10.0),col);\n    col= dobletriaC(vec2(uv.x,-uv.y)-vec2(0.0,-2.0),col);\n    col= DrawFigBorde(vec3(0.0),col,d1a);    \n    return col;\n}   \n\nvec3 AnilloAncho(vec2 p, float r, float ancho,  vec3 colOut)\n{   float d2a= sdCircle(p, r );\n    float d2b= sdCircle(p, r-ancho);\n    float dif2= differenceSDF(d2a, d2b);\n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col, dif2 );\n    return col;\n}\n\n/// Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3 AnilloBloque(vec2 p, vec2 med, vec3 colOut)\n{   float d1a= sdBox(p,med);\n    float d1b= sdBox(p,med-vec2(0.5));\n    float dif1= differenceSDF(d1a, d1b);\n    dif1=abs(dif1)-0.15;\n    colOut= DrawFigBorde(vec3(0.0),colOut,dif1);\n    \n    vec3 colbg=tex3D( iChannel0, vec3(mod(p.xy,5.0),1.0)/256.0, vec3(1.0) )*2.0;\n    colbg=vec3((colbg.x+colbg.y+colbg.z)/3.0);\n    colOut= DrawFigBorde(colbg,colOut,d1b);\n    return colOut;\n}\n\nvec3 estrellaCirculo(vec2 p, vec3 colOut)\n{   float r; int n; float m;\n    r=8.0;n=8; m=5.0;\n    float d1a= sdStar(p, r, n, m); // m=[2,n]\n \n     r=5.0;n=8; m=5.0;\n    float d1b= sdStar(p, r, n, m); // m=[2,n]\n    float dif1= differenceSDF(d1a, d1b);\n    \n    colOut= DrawFigBorde(vec3(0.0),colOut,dif1);\n    colOut=AnilloAncho(p, 2.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 1.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 8.0, 0.5, colOut);\n    colOut=AnilloAncho(p, 9.0, 0.5, colOut);\n    colOut= AnilloBloque(p-vec2(0.0,-19.0), vec2(7.0,10.0), colOut);\n    return colOut;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.25);\n    float esc=25.0;\n    uv*=esc;\n    //uv+=vec2(0.0,2.0*sin(iTime));\n    vec3 col=vec3(1.0);   \n     col= pisof2(uv,col);\n     col= estrellaCirculo(uv-vec2(0.0,23.0), col);\n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[331, 331, 367, 367, 412], [418, 418, 465, 465, 492], [493, 493, 536, 536, 563], [564, 564, 612, 612, 640], [643, 643, 705, 705, 835], [838, 854, 902, 902, 980], [982, 982, 1019, 1019, 1093], [1095, 1095, 1130, 1130, 1153], [1155, 1155, 1207, 1207, 1323], [1325, 1325, 1350, 1350, 1369], [1370, 1370, 1395, 1395, 1414], [1415, 1415, 1451, 1451, 1479], [1481, 1549, 1619, 1677, 2113], [2116, 2116, 2151, 2151, 2503], [2505, 2505, 2544, 2544, 2872], [2874, 2874, 2913, 2913, 3166], [3168, 3168, 3203, 3203, 3567], [3572, 3572, 3634, 3634, 3835], [3837, 3861, 3911, 3911, 4140], [4142, 4142, 4192, 4192, 4571], [4573, 4573, 4616, 4616, 5147], [5149, 5149, 5206, 5206, 5564]], "test": "untested"}
{"id": "7sKBWh", "name": "Glowing carpet", "author": "jarble", "description": "Another fractal carpet pattern.", "tags": ["fractal", "carpet", "rug"], "likes": 9, "viewed": 239, "published": 3, "date": "1658109302", "time_retrieved": "2024-07-30T16:40:02.467738", "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    return to_return;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 1.5*3.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv += vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    float scale = 1.5;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 9; k++){\n            float p1 = sign(uv.x);\n            uv += t2;\n            uv /= scale;\n            t2 = p1*triangle_wave(uv-.5);\n            t3 = -p1*triangle_wave(uv.yx);\n            uv = t2+t3;\n            col.x = min(uv.x-uv.y+col.x*p1,-p1*col.x/3.);\n            col = abs(col.yzx-vec3(col.x)/3.);\n        }\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 109], [111, 111, 168, 168, 846]], "test": "untested"}
{"id": "NdKfW1", "name": "simple -crux-2d-", "author": "jorge2017a2", "description": "simple -crux-2d-", "tags": ["simplecrux2d"], "likes": 6, "viewed": 190, "published": 3, "date": "1658103545", "time_retrieved": "2024-07-30T16:40:03.428171", "image_code": "//por jorge2017a2\n//simple -crux-2d---17-jul/2022\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n///oneshade    \nvec2 Rotate(in vec2 p, in vec2 o, in float r) \n{   float c = cos(r), s = sin(r);\n    return (p - o) * mat2(c, -s, s, c) + o;\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n\nvec3 cruzdos(vec2 p, vec3 colOut)\n{   vec2 p0=p;\n    vec2 pr= Rotate(p,vec2(0.0),0.79) ;\n    float  d1a=sdBox(pr,vec2(3.0));\n    float  d1b=sdBox(pr,vec2(2.5));\n    float dif= differenceSDF(d1a, d1b);\n    \n    p.x=abs(p.x)-5.0;\n    p.y=abs(p.y)-0.1;\n    float d2a= sdTriangleIsosceles( p,vec2(2.0) );\n    \n    p=p0.yx;\n    p.x=abs(p.x)-5.0;\n    p.y=abs(p.y)-0.1;\n    float d2b= sdTriangleIsosceles( p,vec2(2.0) );\n    vec3 colbg= vec3(0.0);\n    colOut= DrawFigBorde(colbg, colOut, dif);\n    colOut= DrawFigBorde(colbg, colOut,d2a);\n    colOut= DrawFigBorde(colbg, colOut,d2b);\n    return colOut;        \n}\n\n\nvec3 triangulosdiv(vec2 p, vec3 colOut)\n{   vec2 pr= Rotate(p,vec2(0.0),0.79) ;\n    float  d1a=sdBox(pr,vec2(7.0));\n    float  d1b=sdBox(pr,vec2(6.5));\n    \n    float  d2a=sdBox(p,vec2(0.5,15.0));  //linea vertical\n    float  d2b=sdBox(p,vec2(15.0,0.5));  //linea hor\n    \n    float dif1= differenceSDF(d1a, d1b);\n    dif1= differenceSDF(dif1, d2a);\n    dif1= differenceSDF(dif1, d2b);\n    \n    colOut= DrawFigBorde(vec3(0.0), colOut, dif1);\n    return colOut;        \n}\n\nvec3 triangulosdivMed(vec2 p, vec2 med ,vec3 colOut)\n{   vec2 pr= Rotate(p,vec2(0.0),0.79) ;\n    float  d1a=sdBox(pr,med);\n    float  d1b=sdBox(pr,med-vec2(0.5));\n    \n    float  d2a=sdBox(p,vec2(0.5,20.0));  //linea vertical\n    float  d2b=sdBox(p,vec2(20.0,0.5));  //linea hor\n    \n    float dif1= differenceSDF(d1a, d1b);\n    dif1= differenceSDF(dif1, d2a);\n    dif1= differenceSDF(dif1, d2b);\n    \n    colOut= DrawFigBorde(vec3(0.0), colOut, dif1);\n    return colOut;        \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,0.0);\n    float esc=12.0;\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n    \n    float t=iTime;\n    uv= Rotate(uv,vec2(0.0),sin(2.01+t-2.0*cos(t+ 3.0*sin(t)))) ;\n     \n    col= cruzdos(uv, col);\n    col= triangulosdivMed(uv, vec2(7.0),col);\n    col= triangulosdivMed(uv, vec2(9.0),col);\n    col= triangulosdivMed(uv, vec2(11.0),col);\n    col= triangulosdivMed(uv, vec2(13.0),col);\n    col= triangulosdivMed(uv, vec2(15.0),col);\n    \n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[332, 332, 368, 368, 413], [419, 419, 466, 466, 493], [494, 494, 537, 537, 564], [565, 565, 613, 613, 641], [644, 644, 706, 706, 836], [838, 854, 902, 902, 980], [983, 983, 1020, 1020, 1094], [1097, 1097, 1122, 1122, 1141], [1142, 1142, 1167, 1167, 1186], [1187, 1187, 1223, 1223, 1251], [1255, 1255, 1306, 1306, 1614], [1617, 1617, 1652, 1652, 2222], [2225, 2225, 2266, 2266, 2695], [2697, 2697, 2751, 2751, 3178], [3180, 3180, 3237, 3237, 3867]], "test": "untested"}
{"id": "fdVfWh", "name": "dotshader", "author": "Fililip", "description": "Dot shader.", "tags": ["shader", "dot"], "likes": 1, "viewed": 214, "published": 3, "date": "1658093432", "time_retrieved": "2024-07-30T16:40:04.335744", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    uv = uv * vec2(iResolution.x / iResolution.y, 1.0) - vec2(0.38, 0.0);\n    \n    vec2 maskUV = vec2(0.0);\n    \n    vec2 modUVT = uv - vec2(iTime * 0.1, 0.0);\n    vec2 modUVB = uv + vec2(iTime * 0.1, 0.0);\n    \n    if (mod(uv.y, 0.2) < 0.1)\n        maskUV = mod(modUVT, 0.1);\n    else\n        maskUV = mod(modUVB, 0.1);\n    \n    maskUV -= mod(uv, 0.01);\n\n    float mask = smoothstep(0.05, 0.02, distance(maskUV, vec2(0.05)));\n    \n    vec3 col = vec3(1.0);\n    \n    float uvX = floor((modUVT.y + 0.1) * 10.0);\n    float uvY = floor((modUVT.x + 0.1) * 10.0);\n    \n    col.r *= cos(uvX * 12.0 + iTime * 5.0) * 0.25 + 0.5;\n    col.g *= sin(uvY * 12.2 + iTime * 6.0) * 0.25 + 0.5;\n    col.b *= sin(uvX * 12.4 + iTime * 7.0) * 0.25 + 0.5;\n    \n    fragColor = vec4(col, 1.0) * mask;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVfWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 888]], "test": "untested"}
{"id": "NsVBWh", "name": "sun -kk-2d-", "author": "jorge2017a2", "description": "sun 2d", "tags": ["sun2d"], "likes": 7, "viewed": 184, "published": 3, "date": "1658089547", "time_retrieved": "2024-07-30T16:40:05.436800", "image_code": "//por jorge2017a2\n//sun kk-2d\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec2 opAngRep( vec2 p, float a )\n{\n\tvec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;\n    \n    return vec2(polar.y * vec2(cos(polar.x),sin(polar.x)));\n}\n\nvec2 opAngRepFull( vec2 p, float numItem )\n{   vec2 rep2 = opAngRep(p, tau / numItem);\n    return rep2;\n}\n\n\nvec3 circulo(vec2 p, vec3 colOut )\n{   vec2 prep=opAngRepFull( p, 8.0 );\n    float d1= sdBox(prep, vec2(3.2,0.25) );\n    float d2a= sdCircle(p, 3.0 );\n    float d2b= sdCircle(p, 2.5 );\n    float dif2= differenceSDF(d2a, d2b);\n    float dif3=differenceSDF(dif2, d1);\n    vec3 col= colOut;\n    col= DrawFigBorde(vec3(.0,0.0,0.0), col, dif3 );\n    return col;\n}\n\n\nvec3 estrellaC(vec2 p, vec3 colOut )\n{   vec2 prep=opAngRepFull( p, 19.0 );\n    vec2 a, b;\n    a=vec2(0.0,0.0);\n    b=vec2(4.5,0.0);\n    a= rotatev2(a, radians(20.0));\n    b= rotatev2(b, radians(20.0));\n    float d1a= sdSegment( prep-vec2(4.,0.0),a,b );\n    \n    a=vec2(0.0,0.0);\n    b=vec2(4.5,0.0);\n    a= rotatev2(a,-radians(20.0));\n    b= rotatev2(b,-radians(20.0));\n    float d1b= sdSegment( prep-vec2(4.0,0.0),a,b );\n\n    float d2a= sdCircle(p, 4.0 );\n    float d2b= sdCircle(p, 3.5 );\n    float dif2= differenceSDF(d2a, d2b);\n    \n    d1a=abs(d1a)-0.1;\n    d1b=abs(d1b)-0.1;\n    \n    float unitd=unionSDF(d1a, d1b);\n    unitd=unionSDF(unitd, dif2);\n    \n    vec3 col= colOut;\n    col= DrawFigBorde(vec3(.0,0.0,0.0), col, unitd );\n    return col;\n}\n\n\nvec3 AnilloBasic(vec2 p, float r, vec3 colOut)\n{   float d2a= sdCircle(p, r );\n    float d2b= sdCircle(p, r-0.5 );\n    float dif2= differenceSDF(d2a, d2b);\n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col, dif2 );\n    return col;\n}\n\n\nvec3 AnilloAncho(vec2 p, float r, float ancho,  vec3 colOut)\n{   float d2a= sdCircle(p, r );\n    float d2b= sdCircle(p, r-ancho);\n    float dif2= differenceSDF(d2a, d2b);\n    vec3 col=colOut;\n    col= DrawFigBorde(vec3(0.0,0.0,0.0), col, dif2 );\n    return col;\n}\n\nvec3 estrellaG(vec2 p, vec3 colOut )\n{\n    vec2 prep=opAngRepFull( p, 19.0 );\n    vec2 a, b;\n    a=vec2(0.0,0.0);\n    b=vec2(7.5,0.0);\n    a= rotatev2(a, radians(20.0));\n    b= rotatev2(b, radians(20.0));\n    float d1a= sdSegment( prep-vec2(7.0,0.0),a,b );\n    \n    a=vec2(0.0,0.0);\n    b=vec2(7.5,0.0);\n    a= rotatev2(a,-radians(20.0));\n    b= rotatev2(b,-radians(20.0));\n    float d1b= sdSegment( prep-vec2(7.0,0.0),a,b );\n   vec3 col= colOut;\n    \n    col=AnilloAncho(p,13.0,0.5, col);\n    col=AnilloAncho(p,14.5,0.7, col);\n    d1a=abs(d1a)-0.3;\n    d1b=abs(d1b)-0.3;\n    \n    float unitd=unionSDF(d1a, d1b);\n    col= DrawFigBorde(vec3(.0,0.0,0.0), col, unitd );\n    \n    return col;\n}\n\nvec3 circuloBloque(vec2 p, vec3 colOut )\n{   vec2 prep=opAngRepFull( p, 8.0 );\n    float d1= sdBox(prep, vec2(18.5,3.) );\n    float d2a= sdCircle(p, 20.0 );\n    float d2b= sdCircle(p, 14.5 );\n    float dif2= differenceSDF(d2a, d2b);\n    float dif3=differenceSDF(dif2, d1);\n    vec3 col= colOut;\n    col= DrawFigBorde(vec3(.0,0.0,0.0), col, dif3 );\n    return col;\n}\n\nvec3 todoSol(vec2 uv, vec3 colOut)\n{   vec3 col=colOut;\n    col= circulo(uv,col );\n    col= estrellaC(uv, col);\n    col= estrellaG(uv, col);\n    col= circuloBloque(uv,col );\n    return col;\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,0.0);\n    float t=iTime;\n    float esc=13.0+3.0*sin(t);\n    uv*=esc;\n    vec2 uv0=uv;\n    vec3 col=vec3(1.0);\n   \n    col=todoSol(uv,col);\n    uv.x= opRep1D( uv.x, 40.0+5.0*sin(-t) );\n    col=todoSol(uv,col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsVBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[312, 312, 348, 348, 393], [399, 399, 446, 446, 473], [474, 474, 517, 517, 544], [545, 545, 593, 593, 621], [624, 624, 686, 686, 816], [819, 819, 853, 853, 948], [950, 950, 987, 987, 1061], [1063, 1063, 1098, 1098, 1121], [1123, 1123, 1175, 1175, 1291], [1322, 1322, 1356, 1356, 1524], [1526, 1526, 1570, 1570, 1631], [1634, 1634, 1670, 1670, 1992], [1995, 1995, 2033, 2033, 2749], [2752, 2752, 2800, 2800, 3000], [3003, 3003, 3065, 3065, 3266], [3268, 3268, 3306, 3306, 3957], [3959, 3959, 4001, 4001, 4324], [4326, 4326, 4362, 4362, 4517], [4524, 4524, 4581, 4581, 4972]], "test": "untested"}
{"id": "fsGBD1", "name": "LOADING minimal", "author": "manu210404", "description": "I tried my best to recreate this amazing post on r/loadingicon:\n[url]https://www.reddit.com/r/loadingicon/comments/ets3a9/everything_is_awesome_about_this_loading_animation/[/url]\n", "tags": ["loading", "arc", "loadinganimation"], "likes": 8, "viewed": 259, "published": 3, "date": "1658074336", "time_retrieved": "2024-07-30T16:40:06.249627", "image_code": "\n#define Q a *= 3.14159;\\\n          vec2 s=vec2(sin(a),cos(a));\n\n\nfloat A( vec2 p, float a) // By iq: https://www.shadertoy.com/view/wl23RK\n{\n    Q\n    p.x = abs(p.x);\n    return ((s.y*p.x>s.x*p.y) ? length(p-s*.7) : \n                                  abs(length(p)-.7)) - .13;\n}\n\nmat2 D( float a ) // rotation matrix\n{\n    Q\n    return mat2( s.y,-s.x,s.x,s.y );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 r = iResolution.xy, p = (2.*U - r)/r.y;\n    \n    \n    float T = iTime*3., \n          d = A( p*D(1.-.125*floor(T)),.4375 ), // distance to longest arc\n          i;\n    \n    for (i = 0.; i < 1.; i+=.5)\n        d = min( A( p*D(mix( -.5,.625, fract(T/2.+i) ) -.125*T ), .0625), d ); // distance to shorter arcs (\"pellets\")\n\n    O = vec4(smoothstep( .01,.0,d));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsGBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[366, 366, 404, 404, 772]], "test": "untested"}
{"id": "ssyBWh", "name": "Fractal mosaic 4", "author": "jarble", "description": "A variant of my \"Banded mosaic\" pattern with a more interesting color palette.", "tags": ["fractal", "mosaic"], "likes": 12, "viewed": 403, "published": 3, "date": "1658072333", "time_retrieved": "2024-07-30T16:40:07.004608", "image_code": "float fmod(float x,float y){return mod(floor(x),y);}\n\n\nvec2 triangle_wave(vec2 a,float scale){\n    return abs(fract((a+vec2(1.,0.5))*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 36.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0 + vec2(iTime/2.0,iTime/3.0)/t1/8.0;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec2 t2 = vec2(0.);\n    float scale = 1.5;\n    for(int k = 0; k < 12; k++){\n        float p1 = sign(uv.x);\n        //t2 *= (1.+p1);\n\n\n        uv = (uv+t2)/scale;\n        //uv = abs(uv);\n        t2 = -p1*triangle_wave(uv-.5,scale);\n        uv =\n            t2-p1*triangle_wave(uv.yx,scale)\n            //fract(t2-p1*triangle_wave(uv.yx,scale))\n            //t2-p1*triangle_wave(uv.yx+fmod(t2.x/1.5,2.),scale);\n        ;\n        col.x = max(uv.y-uv.x-col.x,col.x*3.);\n        col = abs(col.yzx-col.x/3.);\n        //if(uv.x < uv.y) col = abs(col.x-col.yzx);\n        //if(uv.x < uv.y) uv.x += 1.;\n\n        //uv -= .25;\n        //if(t2.x<t2.y||t2.x>t2.y) {uv=uv.yx;t2=t2.yx;}\n    }\n    fragColor = vec4(col*3.,1.0);\n}\n", "image_inputs": [], "sound_code": "#define fmod(x,y) mod(floor(x),y)\n#define fmod1(x,y) mod(floor(x+floor(t0)),y)\n#define fmod2(x,y) mod(floor(y*((x)/y+floor((x)/y)/y)),y)\n\n#define smod(x,y) floor(mod(floor(x)*floor(x),y))\n#define sqmod(x,y) floor(mod(floor(x)*floor(x),y*y)/y)\n#define floor1(x) floor(x)*floor(mod((x)/2.,2.))\n\nvec2 mainSound(int samp, float t){\n  float tempo = 1.;\n  t /= tempo;\n  \n  float t0=t, s1 =\n      8.;\n  float m1 = 0.,m3=0.;\n  for(int i = 0; i < 5; i++){\n  \n  t = t + m1/s1;\n  \n  m1 =\n      max(floor(m3+m1/s1),fmod(t,s1));\n      \n  t /=\n      (1.+fmod(t*s1,2.))\n\n  ;\n  m3 =\n      max(floor(m1+m3/s1),fmod(t,s1));\n  t *=\n      (1.+fmod(t*s1,2.))\n  ;\n  }\n  float a=sqrt((1.-sqrt(fract(t*s1))))*.2,\n\n  nb = pow(2.,(m3)/5.+7.)*tempo;\n\n  return vec2(fract(t*nb*.998)*a\n   ,fract(t*nb)*a);\n\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 52], [55, 55, 94, 94, 146], [148, 148, 205, 205, 1149]], "test": "untested"}
{"id": "fdyfD1", "name": "chientrm: Circle", "author": "chientrm", "description": "circle", "tags": ["circle"], "likes": 0, "viewed": 152, "published": 3, "date": "1658070461", "time_retrieved": "2024-07-30T16:40:07.778539", "image_code": "vec3 sdfCircle(vec2 uv, float r, vec2 offset) {\n    float d = length(uv-offset) - r;\n    \n    return d > 0. ? vec3(0.) : 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n    vec2 offset = vec2(sin(iTime*2.)*0.2, cos(iTime*2.)*0.2);\n    vec3 col = sdfCircle(uv, .2, offset);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdyfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 169], [171, 171, 228, 228, 428]], "test": "untested"}
{"id": "sdGBWh", "name": "chientrm Square", "author": "chientrm", "description": "square", "tags": ["square"], "likes": 1, "viewed": 161, "published": 3, "date": "1658070432", "time_retrieved": "2024-07-30T16:40:08.555463", "image_code": "vec2 rotate(vec2 uv, float th) {\n  return mat2(cos(th), sin(th), -sin(th), cos(th)) * uv;\n}\n\nvec3 sdfSquare(vec2 uv, float size, vec2 offset) {\n  float x = uv.x - offset.x;\n  float y = uv.y - offset.y;\n  vec2 rotated = rotate(vec2(x,y), iTime);\n  float d = max(abs(rotated.x), abs(rotated.y)) - size;\n  return d > 0. ? vec3(1.) : vec3(1., 0., 0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 offset = vec2(0.0, 0.0);\n    vec3 col = sdfSquare(uv, 0.2, offset);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 91], [93, 93, 143, 143, 349], [351, 351, 408, 408, 614]], "test": "untested"}
{"id": "NdyBD1", "name": "Understanding", "author": "SanderVanhove", "description": "Using Fractal Brownian Motion and a Kaleidoscope to make some trippy effects.\n\nThe code is very readable, so check it out!", "tags": ["2d", "kaleidoscope", "brauwnian"], "likes": 6, "viewed": 592, "published": 3, "date": "1658067553", "time_retrieved": "2024-07-30T16:40:09.333382", "image_code": "vec3 hash(vec3 p){\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise_3d(in vec3 p){\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n\nfloat fbm (vec2 uv, float amplitude, int octaves, float lacunarity, float gain) {\n\tfloat value = 0.;\n\t\n\tfor (int i = 0; i < octaves; i++) {\n\t\tvalue += amplitude * abs(noise_3d(vec3(uv, iTime * .5)) * 7.);\n\t\tuv *= lacunarity;\n\t\tamplitude *= gain;\n\t}\n\t\n\treturn value;\n}\n\nvec2 kaleidoscope(vec2 uv) {\n\tif (uv.x > .5)\n\t\tuv.x = 1. - uv.x;\n\tif (uv.y > .5)\n\t\tuv.y = 1. - uv.y;\n\n\tif (uv.x > uv.y) {\n\t\tfloat old_x = uv.x;\n\t\tuv.x = uv.y;\n\t\tuv.y = old_x;\n\t}\n\t\n\treturn uv;\n}\n\nvec2 rotate2D(vec2 uv, float angle) {\n\tuv -= .5;\n\tuv = mat2(vec2(cos(angle), -sin(angle)), vec2(sin(angle), cos(angle))) * uv;\n\tuv += .5;\n\treturn uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord.xy/iResolution.xy - vec2(.25, 0.);\n    uv.x *= iResolution.x/iResolution.y;\n\n    uv = rotate2D(uv, iTime * .1);\n\tuv = kaleidoscope(uv);\n\tuv = rotate2D(uv, iTime * -.05);\n\tfloat n = fbm(uv * 3., .5, 10, sin(iTime * .1) * 1. + 5., abs(sin(iTime * .2)) * .5 + .1);\n\tn = sin(iTime) * .4 + 1.2 - n;\n\tn = n * n * n * n;\n\t\n\tvec2 color_uv = fragCoord/iResolution.xy - vec2(.5);\n\tcolor_uv *= 2.5;\n\tvec3 color = mix(vec3(.9, 0., 0.1), vec3(.6, sin(iTime) * .2 + .5, .8), length(color_uv));\n\n    // Output to screen\n    fragColor.rgb = mix(color, vec3(0.), 1. - n);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 187], [189, 189, 215, 215, 1040], [1042, 1042, 1123, 1123, 1309], [1311, 1311, 1339, 1339, 1504], [1506, 1506, 1543, 1543, 1657], [1659, 1659, 1716, 1766, 2347]], "test": "untested"}
{"id": "fdGfW1", "name": "HardSurface Sphere [2]", "author": "tdhooper", "description": "Tiling the sphere with triangle voronoi patterns, polished version of [url]https://www.shadertoy.com/view/fsKBRR[/url]", "tags": ["voronoi", "geodesic"], "likes": 107, "viewed": 2228, "published": 3, "date": "1658064939", "time_retrieved": "2024-07-30T16:40:10.284838", "image_code": "//#define SHOW_DATA\n//#define GREEN_BG\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat unlerp(float low, float high, float value) {\n    return (value - low) / (high - low);\n}\n\n\n// --------------------------------------------------------\n// Icosahedral domain mirroring\n// knighty https://www.shadertoy.com/view/MsKGzw\n// \n// Also get the face normal, and tangent planes used to\n// calculate the uv coordinates later.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc);\n    pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    pca *= 0.794654;\n    pab *= 0.850651;\n}\n\nvoid fold(inout vec3 p) {\n\tfor(int i=0;i<Type;i++){\n\t\tp.xy = abs(p.xy);\n        p -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n}\n\n\nfloat vmin(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nvec2 triTile(vec2 p)\n{ \n    vec2 hx = p * mat2(1,-1./1.73, 0,2./1.73);\n    vec3 g = vec3(hx, 1.-hx.x-hx.y);\n    vec3 id = floor(g);\n    g = fract(g); \n    if (length(g) > 1.) g = 1. - g;\n    vec3 axis = primaryAxis(g);\n    float y = -(1./3. - vmin(g));\n    float x = (vmax((1.-axis.yzx) * g) - vmax((1.-axis) * g)) * cos(1. / (PI / 3.));\n    return vec2(x,y);\n}\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 col;\n    vec3 emissive;\n    int id;\n    float metallic;\n    bool isBound;\n};\n\nfloat smin(float a, float b, float k){\n    float f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\nfloat smax(float a, float b, float k) {\n    return -smin(-a, -b, k);\n}\n\nfloat cmin(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat cmax(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n\nfloat pReflect(inout vec3 p, vec3 planeNormal, float offset, float soft) {\n    float t = dot(p, planeNormal)+offset;\n    float tr = sqrt(t * t + soft);\n    p = p + (-t + tr) * planeNormal;\n    return sign(t);\n}\n\n\nModel map(vec3 p) {\n    p.z*= -1.;\n    \n    #ifdef LOOP\n    pR(p.xz, .6);\n    pR(p.yz, -.5);\n    p = erot(p, normalize(pbc), fract(gTime / gDuration / gSpeed + .2) * PI * 2. * (1./5.));\n    #else\n    p = erot(p, normalize(pca), fract(gTime / gDuration / gSpeed + .2) * PI * 2. * (1./3.));\n    #endif\n\n\n    float r = 2.;\n\n    vec3 col = normalize(p) * .5 + .5;\n    \n    vec3 face, ab, atob;\n\n    fold(p);\n    \n    pReflect(p, vec3(1,0,0), 0., .0001);\n    pReflect(p, vec3(0,1,0), 0., .0001);\n    pReflect(p, normalize(vec3(-1,-1.6,.615)), 0., .0001);\n    \n    face = pca;\n    atob = pbc - pab;\n    ab = pab;\n    \n    vec3 vv = normalize(face - ab);\n    vec3 uu = normalize(atob);\n    vec3 ww = face;\n    mat3 m = mat3(uu,vv,ww);\n       \n    vec3 pp = p / dot(p, face);\n    \n    vec2 uv = (pp * m).xy;\n    \n    col = vec3(uv * vec2(1,-1), 0);\n     \n    float d = length(p) - 2.;\n    \n    vec4 data = texture(iChannel0, uv * vec2(1,-1) * vec2(1,2.));\n    float border = data.r * r * .66;\n    float tile = data.b;\n    int id = int(data.g);\n    float mask = data.a;\n\n    float o = mix(-.25, .0, pow(tile/2., .5));\n   \n    float ito = ((linearstep(.2, .6 + o, tFract(gTime)) - pow(linearstep(.8 + o, .9 + o, tFract(gTime)), 4.)));\n \n    if (tile == 1.) {\n        ito *= -1.;\n    }\n\n    float inn = mix(.1, .4, tile/2.);\n    \n    ito *= .06;\n    r += ito;\n       \n    float ws = 1.;\n    float w = mix(.025, .1, mod(tile + 1., 3.) / 2.) * ws;\n\n    \n    float d0 = d;\n    \n    vec2 p2 = vec2(border, length(p) - r);\n    d = p2.y;\n    d = smin(d, dot(p2 - vec2(.005,0), normalize(vec2(-2.6,1))), .005);\n    d = smax(d, p2.y - inn * .4, .005);\n\n    if (id == 0) {\n        float ii = mix(.25, .04, tile/3.);\n        if (tile == 2.) {\n            d = cmax(d, -(abs(border - .2)), .01);\n        }\n    }\n    else\n    {\n       d = smax(d, dot(p2 - vec2(.1, inn * .4), normalize(vec2(1,1))), .005);\n       d = cmin(d, max(d - .01, (abs(border - .1))), .01);\n    }\n    \n    d = max(d, -(border - w / 6.));\n        \n    border *= 1.5;\n    inn *= 1.5;\n    \n    #ifndef NIGHT_MODE\n        col = vec3(.6);\n\n        if (id == 1 && tile == 1.) {\n            col *= .4;\n        }\n\n        if (id == 1 && tile == 0.) {\n            col *= .7;\n        }\n\n        if (id == 1 && tile == 2.) {\n            col *= 1.1;\n        }\n\n        col = mix(col, vec3(.15), (1.-smoothstep(.01 * ws*1.5, .04*ws*1.5, abs(border * 6. - inn))));\n\n    #else\n        col = vec3(.015);\n\n        if (id == 1 && tile == 1.) {\n            col *= .333;\n        }\n\n        if (id == 1 && tile == 0.) {\n            col *= .666;\n        }\n\n        if (id == 1 && tile == 2.) {\n            col *= 1.;\n        }\n\n        if (id == 0) {\n            col *= .2;\n        }\n    #endif\n\n    \n    ito= max(ito, 0.);\n    col = mix(col, vec3(0), smoothstep(r + .025 - ito, r - .025 - ito, length(p)) * step(border, w + .01));\n        \n    col *= clamp(border * 5. + .7, 0., 1.);\n    //col *= clamp(border * 15. + .2, 0., 1.);\n    \n    \n    vec3 emissive = vec3(0);\n    if (tile == 1.) {\n        float l = (1. - clamp(abs(border - .2) * 100., 0., 1.)) * 2.;\n        l += (1. - clamp(abs(border - .2) * 15., 0., 1.)) * .1;\n        emissive += vec3(0,.8,.5) * l;\n        \n        float lt = tFract(gTime - .4);\n        float ramp = 1. - linearstep(.025, .07, lt);\n        ramp += linearstep(.8, .9, lt);\n        ramp *= mix(1., sin(lt * 150.) * .5 + .5, linearstep(1.2, .9, lt));\n        \n        emissive *= ramp;\n    }\n    \n    col *= .95;\n    \n    float metallic = 1. - smoothstep(.0, .1 + .2 * mask * mask, abs(border * 6. - inn));\n    //metallic *= mask * mask;\n    //metallic = smoothstep(.01, .0, border);\n    \n    #ifndef NIGHT_MODE\n\n        if (id == 1) {\n            col *= .4;\n        }\n\n    #else\n\n        if (id == 1)\n        {\n            col *= .5;\n        }\n        \n        if (tile == 2.) {\n            col *= .33;\n        }\n\n        if (id == 0 && tile == 0.) {\n            id = 4;\n            metallic = 1.;\n            col *= 1.25;\n        }\n\n        if (id == 1 && tile != 1.) {\n            id = 4;\n            metallic = 1.;\n            col *= 1.25;\n        }\n    #endif\n        \n    return Model(d, col, emissive, id, metallic, false);\n}\n\nModel mapDebug(vec3 p) {\n    Model m = map(p);\n    return m;\n    \n    float d = -p.z;\n    m.d = max(m.d, -d);\n    d = abs(d) - .01;\n    if (d < m.d) {\n        return Model(d, vec3(0), vec3(0), 9, 0., false);\n    }\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\n// origin sphere intersection\n// returns entry and exit distances from ray origin\nvec2 iSphere( in vec3 ro, in vec3 rd, float r )\n{\n\tvec3 oc = ro;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - r*r;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvec3 render( vec2 p )\n{\n    #ifdef CROP\n    p /= 2.6;\n    #endif\n    \n    vec2 tuv = p;\n    \n    //tuv *= .333;\n    //pR(tuv, PI / 12.);\n    vec3 col = (vec3(.8) - p.y * .33) * .65;\n    \n    #ifdef NIGHT_MODE\n    col = vec3(0);\n    #endif\n\n    \n    float w = fwidth(length(p)) / 2.;\n\n    #ifndef LOOP\n    float k = 1. / length(tuv) * 1.25;\n    tuv = vec2(k, atan(tuv.x/tuv.y) * 1.101) * 1.;\n    #ifdef LOOP2\n    tuv += vec2(0,1) * fract(gTime / gDuration / gSpeed + .2) * 1.73;\n    #else\n    tuv += vec2(-.25,.5) * gTime * .25 * .5;\n    #endif\n    tuv = triTile(tuv);\n    vec4 data = texture(iChannel0, tuv * vec2(1,-1) * vec2(1,2.) * 1.43);\n    \n    float lp = length(p) - .05;\n    \n    float ga = smoothstep(.9, 1.1, lp);\n    ga *= smoothstep(1.9, 1.1, lp);\n    ga = .01 * ga - .005;\n\n    float gb = smoothstep(.6, 1., lp);\n    gb *= smoothstep(1.5, 1., lp);\n    gb = .01 * gb - .005;\n    \n\n    float g = smoothstep(ga + w, ga - w, abs(data.x));\n    g += smoothstep(gb + w, gb - w, abs(data.x - .1));\n    \n    #ifdef NIGHT_MODE\n    col += vec3(0,.8,.5) * g * .01;\n    #else\n    col += vec3(0,.8,.5) * g;\n    #endif\n\n    //col = vec3(.03);\n    \n    float e = unlerp(1.7, .95, length(p));\n    e = mix(.2, .00, e);\n    //e = .06;\n    \n    //data.r /= k;\n\n    float ms = smoothstep(1.8, .9, length(p));\n    \n    #ifdef NIGHT_MODE\n    col += vec3(.001) * step(data.r, e) * .15;\n    #else\n    col += vec3(1) * step(e, data.r) * .15 * ms;\n    #endif\n\n    \n    \n    \n    #else\n    col = vec3(.5);\n        #ifdef NIGHT_MODE\n        col *= 0.;\n        #endif\n\n    #endif\n    \n    #ifdef GREEN_BG\n    col *= vec3(0,.8,.5) * 1.8;\n    #endif\n    \n    \n    //col = mix(col, vec3(1,0,0), clamp(unlerp(1., .75, length(p)), 0., 1.));\n    \n    \n    //return vec3(1) * step(data.x, .01);\n    \n    vec3 camPos = vec3(0,0,9);\n    \n    vec2 im = iMouse.xy / iResolution.xy - .5;\n    \n    if (iMouse.x <= 0.)\n    {\n        im = vec2(0);\n    }\n    \n    im += vec2(.66,.3);\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 1.5);\n    \n    vec3 camTar = vec3(0);\n    \n    #ifdef CROP\n    camTar.y = 1.2;\n    #endif\n    \n    mat3 camMat = calcLookAtMatrix(camPos, camTar, vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec2 bound = iSphere(camPos, rayDirection, 2.3);\n    if (bound.x < 0.) {\n    \treturn col;\n    }\n\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    float closestPass = 1e12;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .9;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = mapDebug(rayPosition);\n        dist = model.d;\n        \n        if ( ! model.isBound) {\n            closestPass = min(closestPass, dist);\n        }\n        \n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        \n        vec3 lin = vec3(0);\n        \n        #ifndef NIGHT_MODE\n\n            vec3 rd = rayDirection;\n            vec3 lig = normalize(vec3(-.1,1,-.1));\n            vec3 hal = normalize(lig - rd );\n\n            float dif, spe;\n\n            dif = clamp(dot(lig, nor) * .75 + .4, 0., 1.);\n            dif += sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 )) * .5;\n            spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), 100.);\n            spe *= dif;\n            spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);\n            lin += 1.3 * col * dif;\n            lin += 6. * spe;\n\n            lig = normalize(vec3(.5,-1,.5));\n            hal = normalize(lig - rd );\n\n            dif = clamp(dot(lig, nor), 0., 1.);        \n            spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), 100.);\n            spe *= dif;\n            spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);       \n            float m = clamp(dot(lig, normalize(rayPosition)) + 1., 0., 1.) * 1.5;\n            lin += 1. * col * dif * vec3(0,.8,.5) * m;\n            lin += 6. * spe * vec3(0,.8,.5) * m;\n\n            col = lin;\n\n            col += model.emissive;\n\n        #else\n\n            vec3 rd = rayDirection;\n            vec3 lig = normalize(vec3(-.4,1,-.1));\n            vec3 hal = normalize(lig - rd );\n\n            float dif, spe;\n            \n            float metallic = model.metallic * 1.;\n\n            dif = clamp(dot(lig, nor), 0., 1.);\n            dif *= clamp(dot(lig, normalize(rayPosition)), 0., 1.);\n            spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), mix(50., 150., metallic)) * (1. + 3. * metallic);\n            spe *= dif;\n            spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);\n            lin += 2.2 * col * dif;\n            lin += 2. * spe;\n\n            lin += .1 * col * sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n\n            lig = normalize(vec3(.5,-.25,0.5));\n            hal = normalize(lig - rd );\n\n            dif = clamp(dot(lig, nor), 0., 1.);    \n            dif *= clamp(dot(lig, normalize(rayPosition)), 0., 1.);\n            spe = pow(clamp(dot(nor, normalize(lig - rd)), 0., 1.), mix(50., 150., metallic)) * (1. + 3. * metallic);\n            spe *= dif;\n            spe *= .04 + .96 * pow(clamp(1. - dot(hal, lig), 0., 1.), 5.);       \n            lin += 2.2 * col * dif * vec3(0,.8,.5);\n            lin += 2. * spe * vec3(0,.8,.5);\n\n            col = lin;\n\n            vec3 met = texture(iChannel1, reflect(rd, nor)).xyz;\n\n            col *= mix(vec3(1), met * 10., model.metallic);\n            \n            col += model.emissive * .2;\n            \n        #endif\n                \n        \n        if (model.id == 9) {\n           col = vec3(1,.5,.5) * fract(map(rayPosition).d * 20.);\n        }\n    }\n    else\n    {\n        #ifndef NIGHT_MODE\n            col = mix(col, vec3(.1), smoothstep(.015 + w*2., .015 - w*2., closestPass));\n        #endif\n    }\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    initTime(iTime);\n\n    #ifdef SHOW_DATA\n        vec4 data = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        data.x = fract(data.x * 100.);\n        fragColor = data;\n        return;\n    #endif\n    \n    init();\n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    // AA from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    #endif\n\t\t\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    #ifndef NIGHT_MODE\n    // colour grading from tropical trevor's scripts\n    // https://github.com/trevorvanhoof/ColorGrading\n    vec3 uGain = vec3(.0);\n    vec3 uLift = vec3(.2);\n    vec3 uOffset = vec3(-.225);\n    vec3 uGamma = vec3(.3);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1./2.2) );\n    \n    #else\n    \n    vec3 uGain = vec3(4.);\n    vec3 uLift = vec3(.0);\n    vec3 uOffset = vec3(.0);\n    vec3 uGamma = vec3(.0);\n    col = pow(max(vec3(0.0), col * (1.0 + uGain - uLift) + uLift + uOffset), max(vec3(0.0), 1.0 - uGamma));\n    col = pow( col, vec3(1./2.2) );\n    \n    #endif\n    \n    fragColor = vec4(col, 0);\n}\n\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define PI 3.14159265359\n\nmat3 scaleM(float s) {\n    return mat3(\n        s, 0, 0,\n        0, s, 0,\n        0, 0, 1\n    );\n}\n\nmat3 rotM(float a) {\n    return mat3(\n        cos(a), sin(a), 0,\n        -sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nmat3 transM(vec2 v) {\n    return mat3(\n        1, 0, v.x,\n        0, 1, v.y,\n        0, 0, 1\n    );\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nvoid calcAngleOffset(float tf, float ts, out float angle, out vec2 offset) {\n    float time = tf + ts;\n    angle = time;\n    offset = vec2(0, time);\n    \n    #ifndef LOOP\n    #ifndef LOOP2\n    return;\n    #endif\n    #endif\n    \n    #ifdef NIGHT_MODE\n    float to = timeOffset / timeGap + 17.;\n    #else\n    float to = timeOffset / timeGap;\n    #endif\n    // 39 54 80 82 83 110 141 142 146 155 156 161 166\n\n    angle = 0.;\n    if (mod(tf, 3.) == 2.) {\n        angle += mod(tf, 3.) + ts * -2.;\n    } else{\n        angle += mod(tf, 3.) + ts;\n    }\n    angle *= 1.;\n    angle += to;\n    \n    #ifdef NIGHT_MODE\n    angle = .0;\n    #endif\n    \n    vec3 ba = max(vec3(0), mod(vec3(tf + 2., tf + 1., tf), 3.) - 1.);\n    vec3 bb = max(vec3(0), mod(vec3(tf + 3., tf + 2., tf + 1.), 3.) - 1.);\n    vec3 bary = mix(ba, bb, ts);\n    \n    \n\n    #ifndef NIGHT_MODE\n    vec2 o1 = vec2(0,0);\n    vec2 o2 = vec2(-1.,-.3);\n    vec2 o3 = vec2(.3,-.333);\n    #else\n    float p3 = PI * 2. / 3.;\n    vec2 o1 = vec2(sin(0.),cos(0.)) * .8;\n    vec2 o2 = vec2(sin(p3),cos(p3)) * .8;\n    vec2 o3 = vec2(sin(p3*2.),cos(p3*2.)) * .8;\n    #endif\n    \n    offset = (bary.x * o1 + bary.y * o2 + bary.z * o3);\n    \n    #ifdef NIGHT_MODE\n    offset += 5.0;\n    offset += 2.05;\n    offset += 2.75;\n    offset.y -= .2;\n    offset.x += .05;\n    \n    //offset += 1.5;\n    //offset.x += .25;\n    \n    offset += 15. + vec2(-.25,0);\n    \n   // offset += 11. + vec2(.2,-.3);\n    #endif\n    \n    offset.y += to;\n}\n\n\nmat3 gridTransformation(out float scale) {\n    float tf = tFloor(gTime);\n    float ts = easeSnap(linearstep(.3, .8, tFract(gTime)));\n\n    scale = 2.5;\n        \n    float angle;\n    vec2 offset;\n    calcAngleOffset(tf, ts, angle, offset);  \n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * -.08 * angle);\n    m *= transM(offset * -.78);\n    return m;\n}\n\nmat3 gridTransformation2(out float scale) {\n    float tf = tFloor(gTime);\n    float ts = easeOutBack(linearstep(.6, .9, tFract(gTime)), 1.70158);\n    \n    scale = 3.5;\n   \n    float angle;\n    vec2 offset;\n    calcAngleOffset(tf, ts, angle, offset);  \n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * -.08 * angle * .5);\n    m *= rotM(PI * 2./3.);\n    m *= transM((offset * -0.78 * .5).yx);\n    return m;\n}\n\nfloat effectMask(vec2 uv) {\n    return sin(length(uv) * 12. + 1.) * .5 + .5;\n}\n\n// --------------------------------------------------------\n// Triangle Voronoi\n// tdhooper https://www.shadertoy.com/view/ss3fW4\n// iq https://shadertoy.com/view/ldl3W8\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nconst float s3 = sin(PI / 3.);\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdTri(vec3 t) {\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdBorder(vec3 tbRel, vec2 pt1, vec2 pt2) {\n    \n    vec3 axis = primaryAxis(-tbRel);\n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n\n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2./3.;\n        \n    vec2 ca, cb;\n    float side;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        ca = corner + max(0., dot(corner, -norB)) * norB;\n        cb = corner + min(0., dot(corner, -norA)) * norA;\n    } else {\n        corner = pt1 - corner;\n        ca = corner + max(0., dot(corner, -norA)) * norA;\n        cb = corner + min(0., dot(corner, -norB)) * norB;\n    }\n    \n    side = step(dot(corner, dir * mat2(0,-1,1,0)), 0.);\n    corner = mix(ca, cb, side);\n    \n    float d = length(corner);\n\n    return d;\n}\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec2 cellPoint(vec2 n, vec2 f, vec2 cell, bool gaps) {\n    vec2 coord = n + cell;\n    vec2 o = hash2( n + cell );\n    if (gaps && hash2(o.yx * 10.).y > .5) {\n        return vec2(1e12);\n    }\n    #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n    #endif\t\n    vec2 point = cell + o - f;\n    return point;\n}\n\nvec4 voronoi(vec2 x, bool gaps)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 closestCell, closestPoint;\n\n    const int reach = 3;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(i, j);\n        vec2 point = cellPoint(n, f, cell, gaps);\n        float dist = vmax(sdTriEdges(point));\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCell = cell;\n        }\n    }\n\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(i, j);\n        vec2 point = cellPoint(n, f, cell, gaps);\n\n        vec3 triEdges = sdTriEdges(closestPoint - point);\n        float dist = vmax(triEdges);\n\n        if( dist > 0.00001 ) {\n            closestDist = min(closestDist, sdBorder(triEdges, closestPoint, point));\n        }\n    }\n\n    return vec4(closestDist, closestCell + n, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    initTime(iTime);\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= vec2(1,-1);\n    uv.y /= 2.;\n    \n    if (uv.x > uv.y * -2.) {\n        fragColor = vec4(0);\n        return;\n    }\n\n    float scl;\n    mat3 m = gridTransformation(scl);\n\n    vec2 uvm = mul(uv, m);\n\n    vec4 v = voronoi(uvm, false);\n    float d = v.x / scl;\n    vec2 localPt = v.yz;\n    vec2 worldPt = mul(localPt, inverse(m));\n    vec2 seed = hash2(localPt);\n    float id = 0.;\n    float tile = mod(localPt.x + localPt.y, 3.);\n\n    if (tile == 0.)\n    {\n        m = gridTransformation2(scl);\n        v = voronoi(mul(uv, m), false);\n        d = min(d, v.x / scl);\n        localPt = v.yz;\n        worldPt = mul(localPt, inverse(m));\n        seed = hash2(localPt + seed * 10.);\n        id = 1.;\n        tile = mod(localPt.x + localPt.y, 3.);\n    }\n\n    float mask = effectMask(worldPt);\n    \n    mask = texture(iChannel1, uvm * .25).r;\n    \n    fragColor = vec4(d, id, tile, mask);\n}\n\n", "buffer_a_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define LOOP\n//#define LOOP2\n//#define NIGHT_MODE\n//#define CROP\n\n\n// skaplun https://www.shadertoy.com/view/7tf3Ws\nfloat easeOutBack(float x, float t) {\n    float c1 = t;\n    float c3 = c1 + 1.;\n\n    return 1. + c3 * pow(x - 1., 3.) + c1 * pow(x - 1., 2.);\n}\n\nfloat easeInOutBack(float x) {\n    float c1 = 1.70158;\n    float c2 = c1 * 1.525;\n\n    return x < .5\n      ? (pow(2. * x, 2.) * ((c2 + 1.) * 2. * x - c2)) / 2.\n      : (pow(2. * x - 2., 2.) * ((c2 + 1.) * (x * 2. - 2.) + c2) + 2.) / 2.;\n}\n\nfloat easeSnap(float x) {\n    x = pow(x, .75);\n    x = easeInOutBack(x);\n    return x;\n}\n\nfloat linearstep(float a, float b, float t) {\n    return clamp((t - a) / (b - a), 0., 1.);\n}\n\n#ifdef LOOP\nfloat timeOffset = (92. + 100.) * (3./4.);\nfloat timeGap = 3.;\n#else\n#ifdef LOOP2\n    float timeOffset = (92. + 100.);\n    float timeGap = 4.;\n#else\n    float timeOffset = (92. + 100.);\n    float timeGap = 4.;\n#endif\n#endif\n\nfloat gTime;\nfloat gDuration;\nfloat gSpeed;\n\nvoid initTime(float time) {\n    gTime = time;\n    gSpeed = 1.;\n    gDuration = 14.;\n    \n    #ifdef LOOP\n    gSpeed = 1.5;\n    gDuration = (3. * timeGap) / gSpeed; // 6\n    gTime /= gDuration;\n    gTime = fract(gTime);\n    gTime *= gDuration;\n    gTime *= gSpeed;\n    gTime += .25;\n    #endif\n    \n    #ifdef LOOP2\n    gSpeed = 1.;\n    gDuration = (3. * timeGap) / gSpeed; // 12\n    gTime /= gDuration;\n    gTime = fract(gTime);\n    gTime *= gDuration;\n    gTime *= gSpeed;\n    //gTime += .25;\n    #endif\n}\n\nfloat tFloor(float time) {\n    time += timeOffset;\n    time -= timeGap / 3.;\n    return floor(time / timeGap);\n}\n\nfloat tFract(float time) {\n    time += timeOffset;\n    time -= timeGap / 3.;\n    return fract(time / timeGap) * timeGap * .5;\n}\n\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 149, 181, 181, 226], [228, 304, 342, 342, 404], [406, 406, 456, 456, 499], [881, 881, 894, 894, 1174], [1176, 1176, 1201, 1201, 1295], [1298, 1298, 1318, 1318, 1356], [1358, 1358, 1378, 1378, 1416], [1418, 1418, 1440, 1440, 1779], [2030, 2030, 2068, 2068, 2179], [2181, 2181, 2220, 2220, 2251], [2253, 2253, 2292, 2292, 2341], [2343, 2343, 2382, 2382, 2431], [2434, 2434, 2508, 2508, 2644], [2647, 2647, 2666, 2666, 6839], [6841, 6841, 6865, 6865, 7070], [7207, 7207, 7227, 7227, 7251], [7253, 7322, 7348, 7348, 7549], [7551, 7551, 7601, 7601, 7744], [7746, 7828, 7877, 7877, 8045], [8047, 8047, 8070, 8070, 14105]], "test": "untested"}
{"id": "NdKfDR", "name": "LOADING", "author": "manu210404", "description": "I tried my best to recreate this amazing post on r/loadingicon:\n[url]https://www.reddit.com/r/loadingicon/comments/ets3a9/everything_is_awesome_about_this_loading_animation/[/url]\n", "tags": ["loading", "arc", "loadinganimation"], "likes": 30, "viewed": 541, "published": 3, "date": "1658063039", "time_retrieved": "2024-07-30T16:40:11.038822", "image_code": "#define PI 3.1415926535\n#define T iTime*3.\n#define PELLET_SIZE 1./16.\n#define PELLET_NUM 2\n#define THICKNESS 0.13\n#define RADIUS 0.7\n//#define COUNTER_ROT // counter rotation that keeps the arc at the same place\n#define SMOOTH_MOT // smooth motion of pellets\n#define SMOOTH_SHP // smooth shapes\n\nfloat sdArc( in vec2 p, in float a, in float ra, float rb ) // By iq: https://www.shadertoy.com/view/wl23RK\n{\n    a *= PI;\n    vec2 sc = vec2( sin(a),cos(a) );\n    p.x = abs(p.x);\n    return ((sc.y*p.x>sc.x*p.y) ? length(p-sc*ra) : \n                                  abs(length(p)-ra)) - rb;\n}\n\nmat2 rot( float a )\n{\n    a *= PI;\n    float s = sin(a), c = cos(a);\n    return mat2( c,-s,s,c );\n}\n\nfloat s( float x )\n{\n#ifdef SMOOTH_MOT\n    return smoothstep( 0.,1.,x );\n#endif\n    return x;\n}\n\nfloat sminCubic( float a, float b, float k ) // By iq: https://iquilezles.org/articles/smin/\n{\n    float h = max( k-abs(a-b), .0 )/k;\n    return min( a, b ) - h*h*h*k*(1./6.);\n}\n\nvec3 pal( float x )\n{\n    return mix( vec3(.988,.569,.086), vec3(1,.082,.537), x );\n}\n\nfloat f(float x) {\n    return -2.*PELLET_SIZE*x;\n}\n\nfloat dist(vec2 p){\n#ifdef COUNTER_ROT\n    p *= rot(-f(T-.5));\n#endif\n    int n = PELLET_NUM;\n    float N = float(n);\n\n    float d1 = sdArc( p*rot( f(floor(T)) + 1. ), \n                      .5 - PELLET_SIZE, \n                      RADIUS, \n                      THICKNESS);\n    float d2 = 9e9;\n    for (int i = 0; i < n; i++) {\n        float j = float(i);\n        float t = s( fract((T + j)/N) );\n        float a = mix( -.5, .5 - f(1.), t) + f(T);\n        d2 = min( sdArc( p * rot(a),\n                         PELLET_SIZE,\n                         RADIUS,\n                         THICKNESS), d2);\n    }\n#ifdef SMOOTH_SHP\n    float r = abs( length(p) - RADIUS ) - THICKNESS; // sdf of ring containing the arcs \n    float d = sminCubic( d1, d2, .2 );\n    return max( d, r );\n#endif\n    return min(d1, d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    vec2 p = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n\n    float d = dist( p ); // shape\n    float m = smoothstep( .01,.0,d );\n    \n    float d1 = dist( p + vec2(0.,.15) ); // shadow\n    float s = smoothstep( .2,-.4,d1 );\n    \n    m = max(s,m); // combine shadow and shape\n    \n    vec3 col = m*pal( p.x - p.y + .5 ); // color shape and shadow\n    col += 1. - m; // white background\n    col *= 1. - 1.5 * dot(uv,uv); // vignette\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[296, 296, 405, 405, 589], [591, 591, 612, 612, 690], [692, 692, 712, 712, 787], [789, 789, 883, 883, 966], [968, 968, 989, 989, 1053], [1055, 1055, 1073, 1073, 1105], [1107, 1107, 1126, 1126, 1914], [1916, 1916, 1973, 1973, 2490]], "test": "untested"}
{"id": "sdyfDR", "name": "Paraboloid - intersection", "author": "iq", "description": "Intersection of a ray and a paraboloid (revolution on the left, and paraboloid on the right).", "tags": ["2d", "raytracing", "raycasting", "intersection", "paraboloid"], "likes": 43, "viewed": 1282, "published": 3, "date": "1658054535", "time_retrieved": "2024-07-30T16:40:11.805771", "image_code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray intersection for paraboloids, which are defined as \n//\n//  f(x,y,z) = Â± aÂ²xÂ² + by Â± cÂ²zÂ² = 0\n//\n// a,b,c are the parameters of the shape. See lines 74 and 75.\n// Note making non-symmetric paraboloids is as easy as making\n// a and c not equal.\n//\n// This shader is a complement to this other shader\n// https://www.shadertoy.com/view/fddBD2\n// which handles all other quadrics execpt paraboloids.\n//\n// List of ray-surface intersectors at \n//     https://www.shadertoy.com/playlist/l3dXRf\n// and\n//     https://iquilezles.org/articles/intersectors\n\nbool clipped( in vec3 pos, vec2 clipY, float clipXZ );\n\nfloat iParaboloid(           // intersection distance. -1 if no intersection\n    in vec3  ro, in vec3 rd, // ray origin and direction\n    in vec3  abc,            // the quadric (see above)\n    in vec2  clipY,          // vertical clipping heights\n    in float clipXZ,         // horizontal clipping\n    out vec3 oNor,           // normal at intersection\n    out bool oInside )       // inside/outside identifier\n{\n    vec2 ac2 = abc.xz*abs(abc.xz);    // squared WITH sign\n    \n    float k2 = dot(rd.xz,rd.xz*ac2);\n    float k1 = dot(rd.xz,ro.xz*ac2) + rd.y*abc.y*0.5;\n    float k0 = dot(ro.xz,ro.xz*ac2) + ro.y*abc.y;\n             \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h) * sign(k2);\n\n    // entry point\n    float t = (-k1-h)/k2;\n    vec3 pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipXZ) ) \n    {\n        oInside = k2<0.0;\n        oNor = normalize( vec3(2.0*pos.x*ac2.x,abc.y,2.0*pos.z*ac2.y));\n        return t;\n    }\n\n    // exit point\n    t = (-k1+h)/k2;\n    pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipXZ) )\n    {\n        oInside = k2>0.0;\n        oNor = normalize( vec3(2.0*pos.x*ac2.x,abc.y,2.0*pos.z*ac2.y));\n        return t;\n    }\n\n    return -1.0;\n}\n\nbool clipped( in vec3 pos, vec2 y, float xz )\n{\n    return pos.y>y.x && pos.y<y.y && abs(pos.x)<xz && abs(pos.z)<xz;\n}\n\n//--------------------------------------------------------\n\n// shapes\nconst vec3 kShape[2] = vec3[2]( \n  vec3(1.0, 1.0, 1.0),    // paraboloid of revolution\n  vec3(1.0, 2.0,-1.0) );  // hyperbolic paraboloid\n    \n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    const float N = 18.0; // grid thickness\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvec2 getUV( in vec3 pos, int id )\n{\n    \n    if( id==1 ) return 8.0*pos.xz*(1.0+abs(pos.xz)*0.18);\n\n    // naive uv mapping for paraboloid\n    //return vec2(12.0,11.0)*vec2(atan(pos.x,pos.z),pos.y);\n    \n    // arc-length based, hardcoded for the y=xÂ² parabola\n    float a2 = -pos.y;\n    float a = sqrt(a2);\n    float b = sqrt(1.0+4.0*a2);\n    float l = 0.5*a*b + 0.25*log(2.0*a+b); // arch length\n    float v = sqrt(l);\n    return 12.0*vec2(atan(pos.x,pos.z), 7.0*v/3.14159);\n}\n\nvec3 getRay( in vec2 p, in vec3 uu, in vec3 vv, in vec3 ww )\n{\n    return normalize( p.x*uu + p.y*vv + 3.0*ww );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an1 = 0.4 + 0.9*smoothstep(0.7,0.9,-cos(iTime*6.283185/12.0));\n\tfloat an2 = 6.283185*iTime/12.0;\n\tvec3 ro = 12.0*vec3( cos(an1)*sin(an2), sin(an1), cos(an1)*cos(an2) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrixc\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // global normalize coordinates\n    vec2 gp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // viewport\n    int id = int(2.0*fragCoord.x/iResolution.x);\n    vec2 res = vec2( iResolution.x/2.0, iResolution.y/1.0);\n    vec2 q = vec2( mod(fragCoord.x,res.x), mod(fragCoord.y,res.y) );\n\n    // clip\n    ro.y += (id==0)?-2.2:0.0;\n    vec2  clipY = (id==0) ? vec2(-4.2,0.0) : vec2(-2.0,2.0);\n    float clipZ = (id==0) ? 4.0 : 2.0;\n    \n    // render\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(q+o)-res)/res.y;\n        #else    \n        vec2 p = (2.0*q-res)/res.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = getRay( p, uu, vv, ww );\n\n        // background\n\t    vec3 col = vec3(0.08);\n        col *= 1.0-0.3*length(gp);\n        \n        // raytrace\n        bool isInside = false;\n        vec3 nor = vec3(0.0);\n        float t = iParaboloid( ro, rd, kShape[id], clipY, clipZ, nor, isInside );\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n\n            // material\n            vec2 uv = getUV( pos, id );\n\n            // checkerboard pattern\n            {\n                col = vec3(0.6);\n                col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n                if( isInside ) col = vec3(1.5,0.6,0.0);\n            }\n            // grid lines\n            {\n                #if 0\n                // no filtering\n                col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n                #endif\n                #if 0\n                // hardware filtering\n                uv = 0.5 + uv/6.283185;\n                col *= gridTextureGradBox( uv, dFdx(uv), dFdy(uv) );\n                #endif\n                #if 1\n                // software filtering\n                // https://iquilezles.org/articles/filteringrm\n                vec2 px = vec2(p.x+2.0/res.y,p.y);\n                vec2 py = vec2(p.x,p.y+2.0/res.y);\n                vec3 rdx = getRay( px, uu, vv, ww );\n                vec3 rdy = getRay( py, uu, vv, ww );\n                vec3 posx = ro + t*rdx*dot(rd,nor)/dot(rdx,nor);\n                vec3 posy = ro + t*rdy*dot(rd,nor)/dot(rdy,nor);\n                vec2 uvx = getUV(posx, id);\n                vec2 uvy = getUV(posy, id);\n                uv  = 0.5 + uv /6.283185;\n                uvx = 0.5 + uvx/6.283185;\n                uvy = 0.5 + uvy/6.283185;\n                col *= gridTextureGradBox( uv, uvx-uv, uvy-uv );\n                #endif\n            }\n\n            // lighting\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            col *= vec3(0.2,0.3,0.4)*amb*2.0 + 0.7*vec3(1.0,0.9,0.7)*dif;\n            col += 0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n       }\n \t\n        // gamma\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n     \n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdyfDR.jpg", "access": "api", "license": "mit", "functions": [[1694, 1694, 2108, 2108, 2912], [2914, 2914, 2961, 2961, 3032], [3248, 3306, 3371, 3389, 3734], [3736, 3736, 3771, 3771, 4215], [4217, 4217, 4279, 4279, 4331]], "test": "untested"}
{"id": "NsGBWh", "name": "Wind Walker", "author": "dr2", "description": "Green power", "tags": ["gait", "walk", "strandbeest", "jansen"], "likes": 20, "viewed": 266, "published": 3, "date": "1658051057", "time_retrieved": "2024-07-30T16:40:12.743265", "image_code": "// \"Wind Walker\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Leg from the Strandbeest: see https://en.wikipedia.org/wiki/Jansen's_linkage\n\n#define AA  0   // optional antialiasing\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCylAnDf (vec3 p, float r, float w, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, lBase;\nvec2 csVane;\nfloat dstFar, tCur, szFac, spd;\nint idObj;\nconst int idBas = 1, idLnkT = 2, idLnk = 3, idAx = 4, idWhl = 5, idVane = 6, idStruc = 7;\nconst float s_a = 38.0, s_b = 41.5, s_c = 39.3, s_d = 40.1, s_e = 55.8, s_f = 39.4,\n   s_g = 36.7, s_h = 65.7, s_i = 49.0, s_j = 50.0, s_k = 61.9, s_l = 7.8, s_m = 15.0;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nstruct Leg {\n  vec2 v[8], cs[10], cswAng;\n  float wAng;\n};\nLeg leg[2];\n\n#define ACOSR(x, y, z) acos (((x) * (x) + (y) * (y) - (z) * (z)) / (2. * (x) * (y)))\n#define ATANV(v) atan ((v).y, (v).x)\n\nvoid LegConf ()\n{\n  float a[10], aa, g, s;\n  for (int k = 0; k < 2; k ++) {\n    leg[k].v[0] = vec2 (0., 0.);\n    leg[k].v[1] = leg[k].v[0] + vec2 (s_a, s_l);\n    leg[k].v[2] = leg[k].v[1] + Rot2D (vec2 (s_m, 0.), leg[k].wAng);\n    aa = ATANV (leg[k].v[2] - leg[k].v[0]);\n    s = length (leg[k].v[2] - leg[k].v[0]);\n    a[0] = aa + ACOSR (s, s_b, s_j);\n    leg[k].v[3] = leg[k].v[0] + Rot2D (vec2 (s_b, 0.), a[0]);\n    a[1] = aa - ACOSR (s, s_c, s_k);\n    leg[k].v[4] = leg[k].v[0] + Rot2D (vec2 (s_c, 0.), a[1]);\n    a[2] = ACOSR (s_b, s_d, s_e) + a[0];\n    leg[k].v[5] = leg[k].v[0] + Rot2D (vec2 (s_d, 0.), a[2]);\n    s = length (leg[k].v[5] - leg[k].v[4]);\n    g = ACOSR (s, s_c, s_d) + ACOSR (s, s_g, s_f) + pi + a[1];\n    leg[k].v[6] = leg[k].v[4] + Rot2D (vec2 (s_g, 0.), g);\n    leg[k].v[7] = leg[k].v[4] + Rot2D (vec2 (s_i, 0.), g + ACOSR (s_g, s_i, s_h));\n    a[3] = ACOSR (s_d, s_e, s_b) + a[2] - pi;\n    a[4] = ATANV (leg[k].v[4] - leg[k].v[6]);\n    a[5] = ATANV (leg[k].v[5] - leg[k].v[6]);\n    a[6] = ATANV (leg[k].v[7] - leg[k].v[6]);\n    a[7] = ATANV (leg[k].v[7] - leg[k].v[4]);\n    a[8] = ATANV (leg[k].v[3] - leg[k].v[2]);\n    a[9] = ATANV (leg[k].v[4] - leg[k].v[2]);\n    for (int j = 0; j < 10; j ++) leg[k].cs[j] = sin (- a[j] + vec2 (0.5 * pi, 0.));\n    leg[k].cswAng = sin (- leg[k].wAng + vec2 (0.5 * pi, 0.));\n  }\n}\n\nvoid LinkDf (vec3 p, vec2 v, vec2 cs, float l, int id, inout float dMin)\n{\n  vec3 q;\n  float d;\n  q = p;\n  q.xy = Rot2Cs (q.xy - v, cs);\n  d = max (PrCaps2Df (q.yx - vec2 (0., 0.5 * l), 2., 0.5 * l), abs (q.z) - 0.5);\n  DMINQ (id);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, pp;\n  float dMin, d, sx;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p.y -= lBase.y;\n  p.xz = vec2 (p.z, - p.x);\n  pp = p;\n  for (int kx = 0; kx < 2; kx ++) {\n    sx = sign (float (kx) - 0.5);\n    p.x = pp.x  + lBase.x * sx;\n    for (int k = 0; k < 2; k ++) {\n      p.z = lBase.z + pp.z * (sign (float (k) - 0.5)) * sx;\n      q = p;\n      q.z -= 4.;\n      q.xy = Rot2Cs (q.xy - leg[k].v[1], leg[k].cswAng);\n      d = PrCylAnDf (q, s_m, 2., 1.);\n      q.xy = (abs (q.x) > abs (q.y)) ? q.xy : q.yx;\n      d = min (d, max (PrBox2Df (q.xy, vec2 (s_m, 1.8)), abs (q.z) - 0.8));\n      DMINQ (idWhl);\n      for (int j = 2; j <= 7; j ++) {\n        q = p;\n        q -= vec3 (leg[k].v[j], 0.2);\n        d = PrCylDf (q, ((j < 7) ? 1.5 : 2.5), ((j == 2) ? 5. : 3.));\n        DMINQ (idAx);\n      }\n      LinkDf (p, leg[k].v[0], leg[k].cs[0], s_b, idLnkT, dMin);\n      LinkDf (p, leg[k].v[0], leg[k].cs[2], s_d, idLnkT, dMin);\n      LinkDf (p, leg[k].v[5], leg[k].cs[3], s_e, idLnkT, dMin);\n      LinkDf (p, leg[k].v[6], leg[k].cs[4], s_g, idLnkT, dMin);\n      LinkDf (p, leg[k].v[6], leg[k].cs[6], s_h, idLnkT, dMin);\n      LinkDf (p, leg[k].v[4], leg[k].cs[7], s_i, idLnkT, dMin);\n      p.z -= 1.4;\n      LinkDf (p, leg[k].v[0], leg[k].cs[1], s_c, idLnk, dMin);\n      LinkDf (p, leg[k].v[6], leg[k].cs[5], s_f, idLnk, dMin);\n      LinkDf (p, leg[k].v[2], leg[k].cs[8], s_j, idLnk, dMin);\n      p.z += 2.8;\n      LinkDf (p, leg[k].v[2], leg[k].cs[9], s_k, idLnk, dMin);\n    }\n  }\n  p = pp;\n  q = p;\n  q.x -= 20.;\n  d = PrRoundBoxDf (q, vec3 (lBase.x + 35., 2.5, lBase.z - 7.), 0.5);\n  DMINQ (idBas);\n  q = p;\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z + 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l);\n  q.x = abs (q.x) - lBase.x;\n  d = PrCylDf (q, 1.5, lBase.z - 2.);\n  DMINQ (idAx);\n  q = p;\n  q.xy -= vec2 (s_a, s_l - 1.5);\n  d = PrRoundBoxDf (q, vec3 (lBase.x, 4.5, 4.), 0.5);\n  DMINQ (idStruc);\n  q.x = abs (abs (q.x) - 0.5 * lBase.x) - 0.5 * lBase.x;\n  d = PrRoundBoxDf (q, vec3 (4., 4.5, lBase.z - 7.), 0.5);\n  DMINQ (idStruc);\n  q = p;\n  q.z = abs (abs (q.z) - 21.);\n  q -= vec3 (s_a, 27., 21.);\n  d = PrBoxDf (q, vec3 (4., 27., 1.5));\n  DMINQ (idStruc);\n  q = p;\n  q.xy -= vec2 (s_a, 50.);\n  d = PrCylDf (q, 2.5, lBase.z - 5.);\n  DMINQ (idAx);\n  q.xy = Rot2Cs (q.xy, csVane);\n  d = max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y);\n  q.xy = Rot2D (q.xy, 2. * pi / 3.);\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.xy = Rot2D (q.xy, 2. * pi / 3.);\n  d = min (d, max (abs (length (q.xy - vec2 (18., 10.)) - 20.) - 0.2, q.y));\n  q.z = abs (q.z) - 21.;\n  d = max (d, abs (q.z) - 18.);\n  DMINQ (idVane);\n  return szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.005 * (ro.xz + 5. * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, rg;\n  float dstObj, dstGrnd, sh;\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == idBas) col4 = vec4 (0.2, 0.5, 0.2, 0.1) * (0.9 +\n       0.1 * smoothstep (0.1, 0.13, fract (8. * abs (qHit.z) / 50. + 0.5)));\n    else if (idObj == idStruc) col4 = vec4 (0.4, 0.7, 0.3, 0.1);\n    else if (idObj == idLnkT) col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (0.8 +\n       0.2 * smoothstep (0.18, 0.22, abs (qHit.y)));\n    else if (idObj == idLnk) col4 = vec4 (0.9, 0.9, 1., 0.2) * (0.8 +\n       0.2 * smoothstep (0.18, 0.22, abs (abs (qHit.y) - 0.8)));\n    else if (idObj == idAx) col4 = vec4 (0.8, 0.7, 0.2, 0.2);\n    else if (idObj == idWhl) col4 = vec4 (1., 0.7, 0.3, 0.2);\n    else if (idObj == idVane) col4 = vec4 (1., 1., 0.9, 0.05) * (0.8 +\n       0.2 * smoothstep (0.18, 0.22, abs (abs (qHit.z) - 10.)));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    rg = ro;\n    rg.z += 23. * szFac * spd * tCur;\n    vn = VaryNf (0.5 * rg, vec3 (0., 1., 0.), 1. - smoothstep (0.6, 0.9, dstGrnd / dstFar));\n    col4 = 0.5 * mix (vec4 (0.8, 0.7, 0.4, 0.), vec4 (0.9, 0.9, 0.5, 0.),\n       smoothstep (0.3, 0.7, Fbm2 (0.5 * rg.xz)));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n  }\n  if (rd.y < 0. && dstObj >= dstFar) col = mix (col, vec3 (0.3, 0.4, 0.5),\n     pow (1. + rd.y, 16.));\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.25 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 0.02 * pi * tCur;\n    el -= 0.05 * pi * sin (0.01 * pi * tCur);\n  }\n  el = clamp (el, -0.4 * pi, -0.01 * pi);\n  szFac = 0.05;\n  spd = 2.5;\n  leg[0].wAng = - spd * tCur;\n  leg[1].wAng = leg[0].wAng + pi;\n  csVane = sin (3. * tCur + vec2 (0.5 * pi, 0.));\n  lBase = vec3 (60., 86., 50.);\n  LegConf ();\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 3., -50.);\n  zmFac = 6.5;\n  dstFar = 100.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.8, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCylAnDf (vec3 p, float r, float w, float h)\n{\n  return max (abs (length (p.xy) - r) - w, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGBWh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1364, 1364, 1381, 1381, 2704], [2706, 2706, 2780, 2780, 2939], [2941, 2941, 2963, 2963, 5664], [5666, 5666, 5699, 5699, 5947], [5949, 5949, 5970, 5970, 6225], [6227, 6227, 6264, 6264, 6493], [6495, 6495, 6529, 6529, 7287], [7289, 7289, 7324, 7324, 9065], [9067, 9067, 9123, 9123, 10410], [10412, 10412, 10444, 10444, 10544], [10546, 10546, 10579, 10579, 10668], [10670, 10670, 10716, 10716, 10763], [10765, 10765, 10807, 10807, 10858], [10860, 10860, 10913, 10913, 10974], [10976, 10976, 11020, 11020, 11080], [11082, 11082, 11118, 11118, 11324], [11326, 11326, 11356, 11356, 11469], [11471, 11471, 11502, 11502, 11566], [11600, 11600, 11624, 11624, 11677], [11679, 11679, 11703, 11703, 11815], [11817, 11817, 11842, 11842, 11988], [11990, 11990, 12015, 12015, 12201], [12203, 12203, 12225, 12225, 12379], [12381, 12381, 12402, 12402, 12557], [12559, 12559, 12588, 12588, 12800], [12802, 12802, 12841, 12841, 13098]], "test": "untested"}
{"id": "sdVBDz", "name": "layered planet", "author": "takahiroando", "description": "An experimental layered planet that makes it easy to extend, and customize.", "tags": ["noise", "planet"], "likes": 3, "viewed": 276, "published": 3, "date": "1658050206", "time_retrieved": "2024-07-30T16:40:13.498246", "image_code": "float hash(vec3 v3) {\n\treturn fract(sin(dot(v3, vec3(12.3, 45.6, 78.9))) * 987654.321);\n}\n\nfloat noise(vec3 v3) {\n\tvec3 i = floor(v3);\n\tvec3 f = fract(v3);\n\tvec3 b = smoothstep(0.0, 1.0, f);\n\tvec2 bin = vec2(0.0, 1.0);\n\treturn 2.0 * mix(\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxx), hash(i + bin.yxx), b.x),\n\t\t\tmix(hash(i + bin.xyx), hash(i + bin.yyx), b.x),\n\t\t\tb.y\n\t\t),\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxy), hash(i + bin.yxy), b.x),\n\t\t\tmix(hash(i + bin.xyy), hash(i + bin.yyy), b.x),\n\t\t\tb.y\n\t\t),\n\t\tb.z\n\t) - 1.0;\n}\n\nvec3 rotate_y(vec3 p, float t) {\n    vec3 a = vec3(0.0, 1.0, 0.0);\n\treturn mix(dot(a, p) * a, p, cos(t)) + cross(a, p) * sin(t);\n}\n\nfloat fbm_core(vec3 p, float amp, float freq, float mul_amp, float mul_freq) {\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 6; ++i) {\n\t\th += amp * noise(p * freq);\n\t\tamp *= mul_amp;\n\t\tfreq *= mul_freq;\n\t}\n\treturn h;\n}\n\nfloat height(vec3 p, float radius) {\n\tp = normalize(p) * radius;\n\tp = rotate_y(p, iTime * 0.1);\n\treturn fbm_core(p, 0.8, 0.2, 0.4, 2.7);\n}\n\nfloat d_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nfloat d_ground(vec3 p, float radius) {\n\treturn d_sphere(p, radius) - max(height(p, radius), 0.0);\n}\n\nvec4 rt_sphere(vec3 p, vec3 rd, float radius) {\n\tfloat hit = 0.0;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tfloat d = d_sphere(p, radius);\n\t\tp += d * rd;\n\t\tif (d < 0.01) {\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(p, hit);\n}\n\nvec3 normal(vec3 p, float r) {\n\tmat3 k = mat3(p, p, p) - mat3(0.001);\n\treturn normalize(d_ground(p, r) - vec3(d_ground(k[0], r), d_ground(k[1], r), d_ground(k[2], r)));\n}\n\nvec3 light_dir() {\n    return normalize(vec3(0.6 * sin(0.1 * iTime), 0.5, 1.0));\n}\n\nvec3 sea(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tfloat h = height(p, radius);\n\n    vec3 L = light_dir();\n\tvec3 n = normalize(p);\n\tvec3 r = reflect(rd, n);\n\tfloat dif_pow = max(0.0, dot(L, n));\n\n\tvec3 sea = vec3(0.1, 0.4, 0.9) * (0.1 * dif_pow - 2.0 * h + 0.9 * exp(max(dot(L, r), 0.0))) + 0.1 * sin(h);\n\treturn h < 0.0 ? sea * 0.5 + prev : prev;\n}\n\nvec3 ground(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tfloat h = height(p, radius);\n\tvec3 snow = vec3(1.0);\n\tvec3 sand = vec3(0.7, 0.66, 0.53);\n\tvec3 grass = vec3(0.1, 0.7, 0.3);\n\tfloat snow_r = exp(-abs(h - 0.5) * 20.0);\n\tfloat sand_r = exp(-abs(h - 0.25) * 20.0);\n\tfloat grass_r = exp(-abs(h) * 20.0);\n\tfloat sum_r = snow_r + sand_r + grass_r;\n\tvec3 dif_mat = (snow * snow_r + sand * sand_r + grass * grass_r) / sum_r;\n\tvec3 ng = normal(p, radius);\n    vec3 L = light_dir();\n\tfloat dif_pow = max(0.0, dot(L, ng));\n\tvec3 ground = vec3(0.1) + dif_mat * dif_pow;\n    return h >= 0.0 ? ground : prev;\n}\n\nvec3 cloud(vec3 prev, vec3 p, vec3 rd, float radius) {\n\tp = rotate_y(p, iTime * -0.1);\n\tp += 0.1 * iTime;\n\tfloat c = pow(clamp(abs(fbm_core(p, 1.1, 0.3, 0.5, 2.2)), 0.0, 1.0), 2.0);\n    c = clamp(c, 0.0, 0.8);\n    return mix(prev, vec3(1.0), c);\n}\n\nvec3 bg(vec2 uv) {\n    vec3 p = vec3(uv, 0.0);\n    return vec3(pow(hash(p * 123.), 56.7));\n}\n\n// here is the core idea(is this an existing idea?)\n#define LAYER(col, p, rd, radius, f) { \\\n    vec4 rt = rt_sphere(p, rd, radius); \\\n    if (rt.w > 0.0) { \\\n        col = f(col, rt.xyz, rd, radius); \\\n    }\\\n}\n\nvec3 render(vec2 uv, vec3 p, vec3 rd) {\n    vec3 col = bg(uv);\n    LAYER(col, p, rd, 7.0, sea)\n    LAYER(col, p, rd, 7.0, ground)\n    LAYER(col, p, rd, 7.1, cloud)\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 p = vec3(0.0, 0.0, 10.0);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\n\tfragColor = vec4( render(uv, p, rd), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 89], [91, 91, 113, 113, 497], [499, 499, 531, 531, 629], [631, 631, 709, 709, 840], [842, 842, 878, 878, 980], [982, 982, 1020, 1020, 1050], [1052, 1052, 1090, 1090, 1151], [1153, 1153, 1200, 1200, 1371], [1373, 1373, 1403, 1403, 1543], [1545, 1545, 1563, 1563, 1627], [1629, 1629, 1681, 1681, 1981], [1983, 1983, 2038, 2038, 2585], [2587, 2587, 2641, 2641, 2834], [2836, 2836, 2854, 2854, 2928], [3326, 3326, 3383, 3383, 3583]], "test": "untested"}
{"id": "7sKBDz", "name": "understanding matrices", "author": "FabriceNeyret2", "description": "see comments.\nMouse controls green axis = column2 of matrix M", "tags": ["tuto"], "likes": 13, "viewed": 553, "published": 3, "date": "1658047868", "time_retrieved": "2024-07-30T16:40:14.248241", "image_code": "#define R    iResolution.xy\n\nfloat line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);\n    return smoothstep( 3./R.y, 0., length(p - b * h) );  \n}\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  P = ( 2.*u - R ) / R.y +.5, V,\n          m = iMouse.xy;\n    m = length(m)>10. ? ( 2.*m - R ) / R.y + .5 : vec2(0,1);\n\n    float t = iTime;\n                           // I = column 1  J = column 2\n    mat2  M = mat2( 1.+.2*cos(t),.2*sin(t),   m.x,m.y ),         \n         iM = inverse(M);  // ( U = row 1, V = row 2 )\n                           // note that for rotations U=I, V=J since inverse = transpose\n                           \n    O-=O;\n                      // --- find where (x,y) lays in frame(I,J)\n    V = iM * P;       // vx = dot(U,P) = xCoord of P in (I,J)\n                      // vy = dot(V,P) = yCoord of P in (I,J)\n    if (min(V.x,V.y)>0. && max(V.x,V.y)<1.) O = texture(iChannel0, V );\n    \n                      // --- draw (u,v) shapes in frame(I,J)\n                      // M * (u,v) ~ dot( (I,J) , (u,v) ) = uI + vJ\n    O = mix(O, vec4(1,0,0,1), line(P, vec2(0), M *vec2(1,0) ) );\n    O = mix(O, vec4(0,1,0,1), line(P, vec2(0), M *vec2(0,1) ) );\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKBDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 64, 64, 197], [199, 199, 237, 237, 1218]], "test": "untested"}
{"id": "7dVfDR", "name": "Overlaid text", "author": "u004fu0077u004f", "description": "Display \"Hello, world!\" overlaid on top of an arbitrary background.", "tags": ["text", "beginner", "helloworld"], "likes": 2, "viewed": 200, "published": 3, "date": "1658047526", "time_retrieved": "2024-07-30T16:40:14.999233", "image_code": "// This is one of my first shaders.\n// Special thanks to FabriceNeyret2's <https://www.shadertoy.com/view/llySRh>\n// Special thanks to PrzemyslawZaworski's <https://www.shadertoy.com/view/4sBfRd>\n#define CHARACTERS_WIDE 16\n#define CHARACTERS_WIDE_F float(CHARACTERS_WIDE)\n#define CHARACTER_WIDTH 1./CHARACTERS_WIDE_F\n#define CHARACTERS_TALL 16\n#define CHARACTERS_TALL_F float(CHARACTERS_TALL)\n#define CHARACTER_HEIGHT 1./CHARACTERS_TALL_F\nvoid draw_character(inout vec4 color, in vec2 uv, in vec2 pos, in uint index) {\n    uv -= pos;\n    if (uv.x < 0. || uv.y < 0. || uv.x >= CHARACTER_WIDTH || uv.y >= CHARACTER_HEIGHT) return;\n    uv.x += mod(float(index), CHARACTERS_WIDE_F)*CHARACTER_WIDTH;\n    uv.y += (CHARACTERS_TALL_F-floor(float(index)/CHARACTERS_TALL_F)-1.)*CHARACTER_HEIGHT;\n    color.rgb = texture(iChannel0, uv).rrr;\n}\n#define C(index) {\\\n    draw_character(color, uv, pos, index);\\\n    pos.x += CHARACTER_WIDTH;\\\n}\n#define STRETCH 0\n#define FIT 1\n#define FILL 2\n#define MODE FILL\nvoid mainImage(out vec4 color, in vec2 uv) {\n    #if MODE == STRETCH\n        uv /= iResolution.xy;\n    #elif MODE == FIT\n        uv /= iResolution.y;\n        uv.x += iResolution.y/iResolution.x-1.; // Doesn't work as expected.\n        uv = mod(uv, 1.);\n    #elif MODE == FILL\n        uv /= iResolution.x;\n        uv.y -= iResolution.x/iResolution.y-2.;\n    #endif\n    color = texture(iChannel1, uv);\n    //color = vec4(uv.x, uv.y, 0., 1.);\n    vec2 pos = vec2(0., .5-CHARACTER_HEIGHT/2.);\n    C(0x48U);C(0x65U);C(0x6cU);C(0x6cU);C(0x6fU);C(0x2cU);C(0x20U);C(0x77U);C(0x6fU);C(0x72U);C(0x6cU);C(0x64U);C(0x21U);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dVfDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 439, 518, 518, 831], [994, 994, 1038, 1038, 1606]], "test": "untested"}
{"id": "sl2fRG", "name": "fun with voronoi", "author": "ArmandB", "description": "various voronoi noise uses. see common for standard functions", "tags": ["voronoi", "noise"], "likes": 4, "viewed": 249, "published": 3, "date": "1658034659", "time_retrieved": "2024-07-30T16:40:15.825025", "image_code": "float voronoi2dtaxi(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = min(n,taxiDist(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv));\n        }\n    }\n    return n;\n}\n\nfloat voronoi3dedgestaxi(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = taxiDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nfloat voronoi3dstar(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,starDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv));\n            }\n        }\n    }\n    return n;\n}\n\nfloat voronoi3dpow(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,powDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv,10.0));\n            }\n        }\n    }\n    return n;\n}\n\nfloat voronoi3dpowsmooth(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = smin(n,powDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv,3.0),6.0);\n            }\n        }\n    }\n    return n;\n}\n\nfloat voronoi3dsmooth(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = smin(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv),2.0);\n            }\n        }\n    }\n    return n;\n}\n\nfloat voronoi3dpowedges(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = powDist(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv,3.0);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*3.0;\n    float uvx = fragCoord.x/iResolution.x*5.0;\n    vec3 uv3 = vec3(uv.x,iTime/2.0,uv.y);\n    vec4 uv4 = vec4(uv3,abs(iMouse.y)/iResolution.y);\n    vec3 col = vec3(0)\n;    \n    if (uv.y < 1.0){\n        if (uvx < 1.0){\n            float n = voronoi3dedges(uv3*2.0+voronoi3d(uv3*2.0));\n            col = mix(vec3(1,0.5,0.2),vec3(0.5,0.1,0),pow(1.0-n,2.0));\n        } else if (uvx < 2.0){\n            float n = voronoi3dstar(uv3*2.0);\n            col = mix(vec3(0,0,0),vec3(1,0.7,1),max((1.0-n)-0.99,0.0)*100.0);\n        } else if (uvx < 3.0){\n            float n = voronoi3dpow(uv3*6.0);\n            col = mix(vec3(0,0,0),vec3(0.2,1,0.2),n*10.0);\n        } else if (uvx < 4.0){\n            vec3 pos = vec3(uv.x*2.0,iTime*0.5,uv.y*2.0);\n            float n = voronoi3dedgestaxi(pos);\n            float n2 = voronoi3dedgestaxi(pos + 1.0);\n            float n3 = voronoi3dedgestaxi(pos + 2.0);\n            col = mix(vec3(0.3,1,0.3),vec3(0.3,0.3,0.3),smoothstep(0.0,0.1,n));\n            col = mix(vec3(1,0.3,0.3),col,smoothstep(0.0,0.1,n2));\n            col = mix(vec3(0.3,0.3,1),col,smoothstep(0.0,0.1,n3));\n        } else if (uvx < 5.0){\n            float n = voronoi3dsmooth(uv3*2.0);\n            col = mix(vec3(0,0,0),vec3(1,0.2,0.2),n*10.0);\n        }\n    } else if (uv.y < 2.0){\n        if (uvx < 1.0){\n            float n = voronoi3dedges(uv3*3.0);\n            col = mix(vec3(0.6,0.3,0.2),vec3(0.6,1,0.6),n*10.0);\n        } else if (uvx < 2.0){\n            float n = voronoi2dedges(uv*10.0);\n            col = mix(vec3(1),vec3(0),n*5.0);\n        } else if (uvx < 3.0){\n            float n = voronoi2d(uv*distance(vec2(uvx,uv.y),vec2(2.5,1.5))*2.0);\n            col = mix(vec3(0.99,0.99,1),vec3(0.4,0.1,0),n);\n        } else if (uvx < 4.0){\n            float n = voronoi3dedges(uv3*6.0);\n            col = mix(vec3(0.3,0.2,0.3),vec3(1,1,0.8),smoothstep(0.8,0.85,n+ (sin(uv.y*20.0)/2.0+1.0)));\n        } else if (uvx < 5.0){\n            float n = voronoi3dedges(vec3(uv.x*20.0,iTime,uv.y*20.0));\n            col = mix(vec3(0.2,0.3,0.3),vec3(1,1,0.8),n);\n        }\n    } else {\n        if (uvx < 1.0){\n            float n = voronoi3d(uv3*2.0);\n            col = mix(vec3(1),vec3(0.2,0.5,0.3),1.0-n);\n        } else if (uvx < 2.0){\n            float n = voronoi2dtaxi(uv*4.0);\n            col = mix(vec3(0.8,0,0.9),vec3(0.3,0,0.6),n);\n        } else if (uvx < 3.0){\n            float n = voronoi3dpowedges(vec3(uv3.x*3.0,uv3.y*0.5,uv3.z*3.0));\n            float n2 = voronoi2d(uv*6.0);\n            col = mix(vec3(0,0.6,0.8),vec3(1,1,0.9),1.0-smoothstep(n2*0.1,n2*0.1+0.04,n));\n        } else if (uvx < 4.0){\n            float n = voronoi3dpowsmooth(uv3*4.0);\n            col = mix(vec3(0.1,0.05,0.0),vec3(1),n*5.0-0.8);\n        } else if (uvx < 5.0){\n            float n = voronoi3d(vec3(cos(uv.y*10.0+iTime),iTime,sin(uv.x*10.0+iTime)));\n            col = mix(vec3(0,0,0.5),vec3(1,1,0.5),n);\n        }\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//various alternate distance functions\n//replace distance in your vorronoi function to use them\n//https://en.wikipedia.org/wiki/Taxicab_geometry\nfloat taxiDist(float a, float b){\n    return abs(a-b);\n}\n\nfloat taxiDist(vec2 a, vec2 b){\n    return abs(a.x-b.x) + abs(a.y-b.y);\n}\n\nfloat taxiDist(vec3 a, vec3 b){\n    return abs(a.x-b.x) + abs(a.y-b.y) + abs(a.z-b.z);\n}\n\nfloat taxiDist(vec4 a, vec4 b){\n    return abs(a.x-b.x) + abs(a.y-b.y) + abs(a.z-b.z) + abs(a.w-b.w);\n}\n\nfloat powDist(float a, float b, float p){\n    float d = abs(a-b);\n    return pow(d,p);\n}\n\nfloat powDist(vec2 a, vec2 b, float p){\n    vec2 d = abs(a-b);\n    return pow(d.x,p) + pow(d.y,p);\n}\n\nfloat powDist(vec3 a, vec3 b, float p){\n    vec3 d = abs(a-b);\n    return pow(d.x,p) + pow(d.y,p) + pow(d.z,p);\n}\n\nfloat powDist(vec4 a, vec4 b, float p){\n    vec4 d = abs(a-b);\n    return pow(d.x,p) + pow(d.y,p) + pow(d.z,p) + pow(d.w,p);\n}\n\nfloat starDist(vec3 a, vec3 b){\n    vec3 d = abs(a-b);\n    return d.x*d.y + d.y*d.z + d.x*d.z;\n}\n\n//https://iquilezles.org/articles/smin/\n// power smooth min (k=8)\n// replace min with smin to smooth your vorroni noise\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//random functions from //https://www.shadertoy.com/view/4djSRW\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n//various vorronoi noises\nfloat voronoi1d(float uv){\n    //find closest distance of all cells in a radius of 3\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        n = min(n,distance(floor(uv) + float(x) + hash11(floor(uv) + float(x)),uv));\n    }\n    return n;\n}\n\nfloat voronoi2d(vec2 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            n = min(n,distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv));\n        }\n    }\n    return n;\n}\n\nfloat voronoi3d(vec3 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = min(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv));\n            }\n        }\n    }\n    return n;\n}\n\nfloat voronoi4d(vec4 uv){\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                for (int w = -1; w < 2; w++){\n                    n = min(n,distance(floor(uv) + vec4(x,y,z,w) + hash44(floor(uv) + vec4(x,y,z,w)),uv));\n                }\n            }\n        }\n    }\n    return n;\n}\n\n\n//edge distances for vorroni\nfloat voronoi1dedges(float uv){\n    //find closest & second closest distance\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            float d = distance(floor(uv) + float(x) + hash11(floor(uv) + float(x)),uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n            } else if (d < d2){\n                d2 = d;\n            }\n        }\n    }\n    //get difference\n    return abs(d1-d2);\n}\n\nfloat voronoi2dedges(vec2 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            float d = distance(floor(uv) + vec2(x,y) + hash22(floor(uv) + vec2(x,y)),uv);\n            if (d < d1) {\n                d2 = d1;\n                d1 = d;\n            } else if (d < d2){\n                d2 = d;\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nfloat voronoi3dedges(vec3 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                float d = distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv);\n                if (d < d1) {\n                    d2 = d1;\n                    d1 = d;\n                } else if (d < d2){\n                    d2 = d;\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}\n\nfloat voronoi4dedges(vec4 uv){\n    float d1 = 999.0;\n    float d2 = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                for (int w = -1; z < 2; z++){\n                    float d = distance(floor(uv) + vec4(x,y,z,w) + hash44(floor(uv) + vec4(x,y,z,w)),uv);\n                    if (d < d1) {\n                        d2 = d1;\n                        d1 = d;\n                    } else if (d < d2){\n                        d2 = d;\n                    }\n                }\n            }\n        }\n    }\n    return abs(d1-d2);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2fRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 245], [247, 247, 281, 281, 761], [763, 763, 792, 792, 1072], [1074, 1074, 1102, 1102, 1386], [1388, 1388, 1422, 1422, 1710], [1712, 1712, 1743, 1743, 2028], [2030, 2030, 2063, 2063, 2546], [2548, 2548, 2605, 2605, 5587]], "test": "untested"}
{"id": "ssVBDR", "name": "Random colour sequences", "author": "zithral", "description": "Two colour sequence generators that tend to quickly get decent coverage over the spectrum of possible colours.", "tags": ["color", "random", "palette", "sequence", "pseudorandom"], "likes": 1, "viewed": 320, "published": 3, "date": "1658033876", "time_retrieved": "2024-07-30T16:40:16.582002", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float y = fragCoord.y - 0.5*iResolution.y;\n    float x = floor(fragCoord.x / 15. /* stripe width */);\n    \n    // Pseudorandom colour generation\n    // (With a bias making consecutive colours quite different.)\n    if (y > 0.) {\n        // Approach 1: ints and relative primes.\n        int i = int(x);\n        ivec3 col = i * ivec3(158, 2*156, 3*159);\n        col = col % ivec3(255, 253, 256); // skips some channel values\n        fragColor = vec4(vec3(col)/255., 1.0);\n    } else {\n        // Approach 2: floats, phi, and powers.\n        vec3 col = vec3(1.61803398875);\n        col = fract(col) * vec3(x,x,x);\n        col = fract(col) * vec3(1,x,x);\n        col = fract(col) * vec3(1,1,x);\n        //col = vec3(phi*i, phi*i*i, phi*i*i*i); // has precision issues\n        fragColor = vec4(fract(col), 1.0);\n    }    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 879]], "test": "untested"}
{"id": "ssKfzW", "name": "Magic Eye Drawing", "author": "fenix", "description": "* This is one of those things where you're supposed to cross your eyes. You'll see 3 copies of the shading...look at the middle one.\n* Mouse: draw\n* Space: reset fluid sim\n* CFD from flockaroo's single pass CFD https://www.shadertoy.com/view/MdKXRy", "tags": ["stereogram", "cfd"], "likes": 3, "viewed": 386, "published": 3, "date": "1658004804", "time_retrieved": "2024-07-30T16:40:17.347953", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Just a little shader exploring the possibility of interactive stereograms. Mouse is \n//  required to begin the 3D effect.\n//\n// ---------------------------------------------------------------------------------------\n\nconst vec2 WRAPS = vec2(6.0, 4.0); // May want to increase/decrease according to screen size\n#define DIVERGING 0 // Set to 1 if you uncross your eyes when viewing\n#define SHADING 1 // Kinda reinforces the 3D effect but it might get in the way for some people\n\n#if DIVERGING\nconst float DIRECTION = -1.0;\n#else\nconst float DIRECTION = 1.0;\n#endif\n\nconst float PI = 3.14159265359;\nconst float fov = 50.0;\nconst vec2 LIGHT_DIR = vec2(1.0, 1.0);\n\nconst float EPSILON = 0.01;\n\nconst vec2 deltaX = vec2(1.0, 0);\nconst vec2 deltaY = vec2(0, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if SHADING\n    float dx1 = texture(iChannel1, (fragCoord + deltaX) / iResolution.xy).x -\n        texture(iChannel1, (fragCoord - deltaX) / iResolution.xy).x;\n    float dy1 = texture(iChannel1, (fragCoord + deltaY) / iResolution.xy).x -\n        texture(iChannel1, (fragCoord - deltaY) / iResolution.xy).x;\n        \n    float shadow1 = dot(LIGHT_DIR, vec2(dx1, dy1) * DIRECTION) * 0.3;\n\n    vec2 offsetCoord = fragCoord;\n    offsetCoord.x += iResolution.x / 6.0;\n    float dx2 = texture(iChannel1, (offsetCoord + deltaX) / iResolution.xy).x -\n        texture(iChannel1, (offsetCoord - deltaX) / iResolution.xy).x;\n    float dy2 = texture(iChannel1, (offsetCoord + deltaY) / iResolution.xy).x -\n        texture(iChannel1, (offsetCoord - deltaY) / iResolution.xy).x;\n        \n    float shadow2 = dot(LIGHT_DIR, vec2(dx2, dy2)) * 0.2;\n#else\n    const float shadow1 = 0.0;\n    const float shadow2 = 0.0;\n#endif\n\n    float height = texture(iChannel1, fragCoord/iResolution.xy).x;\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 backgroundUV = uv*WRAPS + vec2(height, 0.0) * 0.01 * DIRECTION;\n    backgroundUV.x = mod(backgroundUV.x, 1.0);\n    backgroundUV.y = mod(backgroundUV.y, 1.0);\n    vec2 vel = texture(iChannel0, backgroundUV).xy;\n\tfragColor = vec4(vel.x, sin(vel.x * 0.2) * 4.0, vel.y, 0.0).yxzw * 0.2 + vec4(shadow1 + shadow2);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/MdKXRy\n//\n// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n//\n// \"angRnd\" is the rotational randomness of the rotation-samples\n// \"posRnd\" is an additional error to the position of the samples (not really needed)\n// for higher numbers of \"RotNum\" \"angRnd\" can also be set to 0\n\n#define RotNum 3\n#define angRnd 1.0\n#define posRnd 0.0\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 m = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\n\nfloat hash(float seed) { return fract(sin(seed)*158.5453 ); }\nvec4 getRand4(float seed) { return vec4(hash(seed),hash(seed+123.21),hash(seed+234.32),hash(seed+453.54)); }\nvec4 randS(vec2 uv)\n{\n    //return getRand4(uv.y+uv.x*1234.567)-vec4(0.5);\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 uv, float sc)\n{\n    float ang2 = angRnd*randS(uv).x*ang;\n    vec2 p = vec2(cos(ang2),sin(ang2));\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        vec2 p2 = (p+posRnd*randS(uv+p*sc).xy)*sc;\n        vec2 v = texture(iChannel0,fract(uv+p2)).xy-vec2(0.5);\n        rot+=cross(vec3(v,0.0),vec3(p2,0.0)).z/dot(p2,p2);\n        p = m*p;\n    }\n    rot/=float(RotNum);\n    return rot;\n}\n\nvoid init( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    if (fragCoord.y < iResolution.y * 0.5)\n    {\n        fragColor.g += 5.0;\n    }\n    if (fragCoord.x < iResolution.x * 0.5)\n    {\n        fragColor.r += 5.0;\n    }\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / Res.xy;\n    vec2 scr=uv*2.0-vec2(1.0);\n    \n    float sc=1.0/max(Res.x,Res.y);\n    vec2 v=vec2(0);\n    for(int level=0;level<20;level++)\n    {\n        if ( sc > 0.7 ) break;\n        float ang2 = angRnd*ang*randS(uv).y;\n        vec2 p = vec2(cos(ang2),sin(ang2));\n        for(int i=0;i<RotNum;i++)\n        {\n            vec2 p2=p*sc;\n            float rot=getRot(uv+p2,sc);\n            //v+=cross(vec3(0,0,rot),vec3(p2,0.0)).xy;\n            v+=0.1*p2.yx*rot*vec2(-1,1); //maybe faster than above\n            p = m*p;\n        }\n      \tsc*=2.0;\n    }\n    \n    //v.y+=scr.y*0.1;\n    \n    //v.x+=(1.0-scr.y*scr.y)*0.8;\n    \n    //v/=float(RotNum)/3.0;\n    \n    fragColor=texture(iChannel0,fract(uv+v*3.0/Res.x));\n    \n    // add a little \"motor\" in the center\n    fragColor.xy += (0.01*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n    if(iFrame<=4 || keyDown(32)) init(fragColor,fragCoord);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nfloat length2(vec2 a)\n{\n    return dot(a, a);\n}\n\nvoid renderBlob(in vec2 pos, in vec2 coord, inout float color)\n{\n    float dist2 = length2(pos - coord);\n    \n    float RADIUS = iResolution.x / 5.0;\n    color += min(1.0, RADIUS / dist2);   \n    color = min(10.0, color);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float color = texelFetch(iChannel0, ivec2(fragCoord), 0).x;\n    \n    //color = max(0.0, color - 0.01);\n    color *= 0.995;\n    \n    if (iMouse.z > 0.0) renderBlob(iMouse.xy, fragCoord, color);\n    \n    fragColor = vec4(color);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKfzW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[971, 971, 1028, 1028, 2367]], "test": "untested"}
{"id": "fsVBWz", "name": "strange metaball", "author": "jorgemoag", "description": "metaball", "tags": ["metaball"], "likes": 4, "viewed": 98, "published": 3, "date": "1658000930", "time_retrieved": "2024-07-30T16:40:18.099943", "image_code": "const float EPS = 1e-3;\n\nfloat hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\nfloat noise(vec3 pos) {\n\tvec3 id = floor(pos);\n\tvec3 f = fract(pos);\n\tf = f*f*(3.-2.*f);\n\n\tfloat n = id.x + id.y * 157.0 + 113.0 * id.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise(p);\n\n\treturn f;\n}\n\nfloat map(vec3 p) {\n    float offs = fbm(7.*p + vec3(0.,iTime,0.));    \n    return length(p) - .6 - .125*offs;\n}\n\nvec3 calcNormal(vec3 pos) {\n    float h = map(pos);\n    vec2 eps = vec2(EPS, 0.0);\n    return normalize(vec3(\n        map(pos + eps.xyy) - h,\n        map(pos + eps.yxy) - h,\n        map(pos + eps.yyx) - h\n    ));\n}\n\nfloat castRay(vec3 ro, vec3 rd) {\n    float td = 0.;\n    for (float t = 0.; t < 1e3; ++t) {\n        vec3 pos = ro + td * rd;\n        float h = .4*map(pos);\n        if (h < EPS) {\n            return td;\n        }\n        td += h;\n    }\n    return -1.;\n}\n\nmat3 cam(vec3 co, vec3 ct) {\n    vec3 ww = normalize(ct - co);\n    vec3 uu = normalize(cross(ww, vec3(0.,1.,0.)));\n    vec3 vv = normalize(cross(uu, ww));\n    return mat3(uu, vv, ww);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 col = vec3(0.);\n    \n    vec3 co = vec3(sin(.2*iTime), .5, cos(.2*iTime));\n    vec3 ct = vec3(0., 0., 0.);\n    \n    vec3 rd = normalize(cam(co, ct) * vec3(uv, 1.));\n    float t = castRay(co, rd);\n    if (t > -EPS) {\n        vec3 pos = co + t * rd;\n        \n        vec3 N = calcNormal(pos);\n        \n        \n        float a1 = fbm(7.*pos + vec3(0.,iTime,0.));\n        float a2 = fbm(10.*pos + vec3(iTime,0.,0.));\n        \n        col = mix(vec3(1.,0.,0.), vec3(0.), clamp(1.5*a1,0.,1.));\n        col += vec3(1.,1.,0.)*(1.-smoothstep(0.1, 0.4, a1));\n        col += vec3(0.,0.,1.)*mix(0.1, .5, 0.3*a2);\n        \n        vec3 bg = texture(iChannel0, reflect(rd, N)).rgb;\n        \n        col += bg * mix(0.2, 1.0, pow(1.-clamp(dot(-rd, N),0.,1.),2.0));\n        \n        vec3 L = normalize(vec3(0., -1., -1));\n        col = col * clamp((0.75 + max(0.,dot(-L, N))),0.,1.);\n        \n    } else {\n    \n        float yd = pow(max(0., dot(rd, vec3(0.,-1.,0.))), 10.0);\n        col = texture(iChannel0, rd).rgb;        \n        col = mix(col, mix(vec3(1.,0.2,0.), vec3(1., 0.8, 0.), sin(3.*iTime+.5)*sin(1.*iTime)), yd);\n        \n    }\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVBWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 46, 46, 87], [89, 89, 112, 112, 454], [456, 456, 475, 475, 603], [605, 605, 624, 624, 717], [719, 719, 746, 746, 933], [935, 935, 968, 968, 1187], [1189, 1189, 1217, 1217, 1374], [1376, 1376, 1433, 1433, 2673]], "test": "untested"}
{"id": "fsVfWR", "name": "Slipgate", "author": "HazelTheWolf", "description": "images you can hear\n\nclick around to play with parameters", "tags": ["retro", "distortion", "quake", "shearing"], "likes": 3, "viewed": 282, "published": 3, "date": "1657989395", "time_retrieved": "2024-07-30T16:40:18.865895", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //square aspect ratio centered canvas\n    vec2 uv = fragCoord/iResolution.xx;\n    uv -= 0.5;\n    \n    //mouse controls\n    //zoom *= (floor(min(iMouse.x/iResolution.x,iMouse.y/iResolution.y)*16.0)/16.0)*3.0 +0.5;\n    scale += (iMouse.x/iResolution.x/48.0) - 0.3*scale;\n    phaseOffset += iMouse.xy/iResolution.xy*3.14;\n    pixelSize *= (floor(iMouse.x/iResolution.x*32.0)/32.0)*1.0 +1.0;\n    brightness += iMouse.y/iResolution.y;\n        \n    uv /= zoom;\n    \n\n    vec2 distortion = sin((uv.yx/wavelength + iTime*speed)*6.28 + phaseOffset) + uv/wavelength;\n    distortion *= scale;\n    uv += distortion;\n    \n    //quantize uvs\n    if (pixelSize > 0.0) uv = floor(uv/(pixelSize/128.0))*pixelSize/128.0;\n    \n    fragColor = texture(iChannel0,uv)*(tint+brightness);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float stars = smoothstep(1.0-starDensity,1.0,pow(pcg2d(uvec2(fragCoord)),8.0));\n    fragColor = vec4(stars);\n}", "buffer_a_inputs": [], "common_code": "float wavelength = 1.0;\nfloat speed = .1;\nfloat scale = .06;\nfloat pixelSize = .6;\nfloat starDensity = .8;\nfloat brightness = .3;\nvec2 zoom = vec2(1.0);\nvec2 phaseOffset = vec2(0.0,3.14);\nvec4 tint = vec4(.038,.024,.014,1.0)*9.0;\n\n\n\n//https://www.shadertoy.com/view/XlGcRh\nfloat pcg2d(uvec2 v)\n    {\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return (vec2(v)/float(0xffffffffu)).x;\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 99, 828]], "test": "untested"}
{"id": "NdVfWR", "name": "IFS with Field Of Space", "author": "yasuo", "description": "IFS with Field Of Space", "tags": ["ifs"], "likes": 7, "viewed": 318, "published": 3, "date": "1657989283", "time_retrieved": "2024-07-30T16:40:19.627858", "image_code": "// color clamping https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord.xy / iResolution.xy );\n    vec3 minColor = vec3(9999.);\n    vec3 maxColor = vec3(-9999.);\n    vec3 previousColor = textureLod(iChannel0,uv,100.0).rgb;\n    \n    for(int x = -1; x <= 1; ++x)\n    {\n        for(int y = -1; y <= 1; ++y)\n        {\n            vec3 color = textureLod(iChannel0,uv + vec2(x, y) / iResolution.xy,100.0).rgb; // Sample neighbor\n            minColor = min(minColor, color); // Take min and max\n            maxColor = max(maxColor, color);\n        }\n    }\n    \n    vec3 previousColorClamped = clamp(previousColor, minColor, maxColor);\n    vec3 currentColor = textureLod(iChannel0,uv,100.0).rgb;\n    vec3 res = currentColor * 0.1 + previousColorClamped * 0.9;\n    \n    //fragColor =  textureLod(iChannel0,uv,100.0);\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MAX_STEPS 128\n#define MAX_DIST 128.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define LINE_SIZE 0.02\n#define ZERO (min(iFrame,0))\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat basePattern(vec2 p, float size){\n    vec2 prevP = p;\n    p.x = abs(p.x)-size;\n    p.y = abs(p.y)-size;\n    float d = p.y;\n    float d2 = p.x;\n    return min(d,d2);\n}\n\nfloat topPt(vec2 p){\n    vec2 prevP = p;\n    float size = LINE_SIZE;\n    float d = basePattern(p,size);\n    d = max(-(p.y+size),d);\n    return d;\n}\n\nfloat bottomPt(vec2 p){\n    vec2 prevP = p;\n    float size = LINE_SIZE;\n    float d = basePattern(p,size);\n    d = max((p.y-size),d);\n    return d;\n}\n\nfloat leftPt(vec2 p){\n    vec2 prevP = p;\n    float size = LINE_SIZE;\n    float d = basePattern(p,size);\n    d = max((p.x-size),d);\n    return d;\n}\n\nfloat rightPt(vec2 p){\n    vec2 prevP = p;\n    float size = LINE_SIZE;\n    float d = basePattern(p,size);\n    d = max(-(p.x+size),d);\n    return d;\n}\n\nfloat patterm(vec2 p){\n    p*=4.0;\n    float d = 100000.0;\n    for(int i = 0; i<7; i++){\n        \n        p*=Rot(90.*float(i)+iTime*0.1);\n        p = abs(p)-1.0;\n        \n        float d2 = topPt(p);\n        if(i%2 == 0){\n            d2 = bottomPt(p);\n        }\n        \n        if(i%3 == 0){\n            d2 = leftPt(p);\n        }\n        \n        if(i%4 == 0){\n            d2 = rightPt(p);\n        }\n        d = min(d,d2);\n    }\n    \n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    float size = 0.3;\n    float d = patterm(p.xy);\n    float d2 = patterm(p.yz);\n    float d3 = patterm(p.xy);\n    d = max(sdBox(p,vec3(size)),min(min(d,d2),d3));\n    \n    d = mix(sdOctahedron(p,size+0.1),d,clamp(sin(iTime*0.5),0.1,1.0));\n    \n    return vec2(d*0.3, MATERIAL);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    float IOR = 1.62; //IOR:index of reflection\n    vec3 rdIn = refract(rd,n,1.0/IOR); \n    vec3 refTex = textureLod(iChannel0,rdIn,0.0).rgb;\n    return refTex;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        vec3 c = vec3(0.8);\n        col = reflectMaterial(p,rd,n);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -1.);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-10.0));\n        ro.xz *= Rot(radians(iTime*10.0-45.));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = vec3(1.0);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );\n    \n    uv-=vec2(-0.6,-0.32);\n    float dd = B(uv,vec2(0.25,0.15));\n    col = mix(col,vec3(0.),S(dd,0.0));\n    uv*=3.0;\n    dd = patterm(uv);\n    \n    uv = prevUV;\n    uv-=vec2(-0.6,-0.32);\n    dd = max(B(uv,vec2(0.25,0.15)),dd);\n    col = mix(col,vec3(1.),S(dd,0.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 88, 145, 145, 941]], "test": "untested"}
{"id": "7sGBzw", "name": "Cubic Grid Tiling", "author": "gehtsiegarnixan", "description": "Simple 3D Cube Grid Tiling rotated by 30 degree to have nice triangles and hexagons in 2D. ", "tags": ["3d", "grid", "triangle", "cube", "honeycomb", "tiling", "tessellation"], "likes": 6, "viewed": 192, "published": 3, "date": "1657987801", "time_retrieved": "2024-07-30T16:40:20.381841", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nSimple 3D Cubic Tiling. It looks like triangles and hexagons, because I rotated \nit a bit. What you see is the Edge Distance.\n\nThis project contains algorithms for the edge distance, center distance, ID and \nUVW coordinates of a cubeic honeycomb grid.\n\nThe caluclation for the cube gird is very fast. I wonder, if this is faster to \ncalculate 3D cubes and rotate them compated to making a 2D triangle grid the \nnormal way. Maybe I'll test that later.\n*/\n\n#define sqrt25 \t\t\t0.6324555320 //sqrt(2./5.)\n#define sqrt35 \t\t\t0.7745966692 //sqrt(3./5.)\n\n//edge distance of a Cube\nfloat cubeDist(vec3 uvw) {\n    vec3 d = abs(uvw); //mirroring along axis\n    return max(d.x, max(d.y, d.z))*2.; //*2. for 0-1 range\n}\n\n// Cube Tiling\nvec4 cubeTile(vec3 uvw) {\n    vec3 grid = fract(uvw)-.5; // centered UVW coords\n    float edist = 1.-cubeDist(grid); // edge distance\n    //float cdist = dot(grid,grid); //squared center distance\n    //vec3 id = uvw-grid; // Cells IDs\n\n    return vec4(grid, edist);\n}\n\n// scaled with offset cube tiling\nvec4 cubeCell(vec3 uvw, vec3 offset, float gridRes) {\n    vec4 cubeTiling = cubeTile(uvw*gridRes + offset);\n    vec3 tiledUV = (cubeTiling.xyz - offset)/gridRes; //cube pixaltion\n    \n    return vec4(tiledUV,cubeTiling.w);\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\n// makes RdYlBu_r colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n    float time = (0.05*iTime); // used as z dimension  \n    float gridRes = 2.5; //size of cubes\n    \n    vec3 point = vec3(uv, time); //uvw cords\n    \n    //cosmetic rotate for fun triangles otherwise it looks so square\n    point = rotate(point, (vec3(sqrt25,sqrt35,0.))); //vec3 must be normalized\n    \n    vec4 a = cubeCell(point, vec3(0.), gridRes);  \n    \n    vec3 col = RdYlBu_r(a.w); // cosmetic Colormap\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBzw.jpg", "access": "api", "license": "mit", "functions": [[1629, 1655, 1681, 1681, 1788], [1790, 1805, 1830, 1830, 2072], [2074, 2108, 2161, 2161, 2332], [2334, 2409, 2438, 2575, 2996], [2998, 3080, 3104, 3104, 3560], [3562, 3562, 3619, 3619, 4128]], "test": "untested"}
{"id": "fdGBDR", "name": "Photo Negative", "author": "deonb", "description": "Returns the negative of iChannel0", "tags": ["photo"], "likes": 0, "viewed": 369, "published": 3, "date": "1657921830", "time_retrieved": "2024-07-30T16:40:21.135826", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col =  vec4(texture(iChannel0, uv).xyz,1.0);\n\n    fragColor = vec4(1.0 - col.r, 1.0 - col.g, 1.0 - col.b, col.a); \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 230]], "test": "untested"}
{"id": "fdGfWR", "name": "Fork for Green Plasma Globe", "author": "soundmasteraj", "description": "Forking to make a green version [(original author)My first attempt at recreating a real world object.  I tried making the sphere glow based on ray position but it didn't look better and was much more expensive.]\n\nMouse drag to rotate.", "tags": ["3d", "raymarching", "rays", "plasma", "volumetric", "fork"], "likes": 7, "viewed": 605, "published": 3, "date": "1657918644", "time_retrieved": "2024-07-30T16:40:21.937682", "image_code": "// Fork of \"Plasma Globe\" by nimitz. https://shadertoy.com/view/XsjXRm\n// 2022-07-15 20:56:39\n\n// Plasma Globe by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/XsjXRm\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n//looks best with around 25 rays\n#define NUM_RAYS 13.\n\n#define VOLUMETRIC_STEPS 19\n\n#define MAX_ITER 35\n#define FAR 6.\n\n#define time iTime*1.1\n\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat noise( in float x ){return textureLod(iChannel0, vec2(x*.01,1.),0.0).x;}\n\nfloat hash( float n ){return fract(sin(n)*43758.5453);}\n\nfloat noise(in vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfp = fp*fp*(3.0-2.0*fp);\n\t\n\tvec2 tap = (ip.xy+vec2(37.0,17.0)*ip.z) + fp.xy;\n\tvec2 rg = textureLod( iChannel0, (tap + 0.5)/256.0, 0.0 ).yx;\n\treturn mix(rg.x, rg.y, fp.z);\n}\n\nmat3 m3 = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\n\n//See: https://www.shadertoy.com/view/XdfXRj\nfloat flow(in vec3 p, in float t)\n{\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec3 bp = p;\n\tfor (float i= 1.;i < 5.;i++ )\n\t{\n\t\tp += time*.1;\n\t\trz+= (sin(noise(p+t*0.8)*6.)*0.5+0.5) /z;\n\t\tp = mix(bp,p,0.6);\n\t\tz *= 2.;\n\t\tp *= 2.01;\n        p*= m3;\n\t}\n\treturn rz;\t\n}\n\n//could be improved\nfloat sins(in float x)\n{\n \tfloat rz = 0.;\n    float z = 2.;\n    for (float i= 0.;i < 3.;i++ )\n\t{\n        rz += abs(fract(x*1.4)-0.5)/z;\n        x *= 1.3;\n        z *= 1.15;\n        x -= (sin(iTime/3.1415))+time*.65*z; //added sin\n    }\n    return rz;\n}\n\nfloat segm( vec3 p, vec3 a, vec3 b)\n{\n    vec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1. );\t\n\treturn length( pa - ba*h )*.5;\n}\n\nvec3 path(in float i, in float d)\n{\n    vec3 en = vec3(0.,0.,1.);\n    float sns2 = sins(d+i*0.5)*0.22;\n    float sns = sins(d+i*.6)*0.21;\n    en.xz *= mm2((hash(i*10.569)-.5)*6.2+sns2);\n    en.xy *= mm2((hash(i*4.732)-.5)*6.2+sns);\n    return en;\n}\n\nvec2 map(vec3 p, float i)\n{\n\tfloat lp = length(p);\n    vec3 bg = vec3(0.);   \n    vec3 en = path(i,lp);\n    \n    float ins = smoothstep(0.11,.46,lp);\n    float outs = .15+smoothstep(.0,.15,abs(lp-1.));\n    p *= ins*outs;\n    float id = ins*outs;\n    \n    float rz = segm(p, bg, en)-0.011;\n    return vec2(rz,id);\n}\n\nfloat march(in vec3 ro, in vec3 rd, in float startf, in float maxd, in float j)\n{\n\tfloat precis = 0.001;\n    float h=0.5;\n    float d = startf;\n    for( int i=0; i<MAX_ITER; i++ )\n    {\n        if( abs(h)<precis||d>maxd ) break;\n        d += h*1.2;\n\t    float res = map(ro+rd*d, j).x;\n        h = res;\n    }\n\treturn d;\n}\n\n//volumetric marching\nvec3 vmarch(in vec3 ro, in vec3 rd, in float j, in vec3 orig)\n{   \n    vec3 p = ro;\n    vec2 r = vec2(0.);\n    vec3 sum = vec3(0);\n    float w = 0.;\n    for( int i=0; i<VOLUMETRIC_STEPS; i++ )\n    {\n        r = map(p,j);\n        p += rd*.03;\n        float lp = length(p);\n        \n        vec3 col = sin(vec3(.05,0.5,1.052)*3.94+r.x)*.85+0.4; // +r.y to +r.x   and changed vec3\n        \n        col.rgb *= smoothstep(.0,.015,-r.x);\n        col *= smoothstep(0.04,.2,abs(lp-1.1));\n        col *= smoothstep(0.1,.34,lp);\n        \n        sum += abs(col)*5. * (1.2-noise(lp*2.+j*13.+time*5.)*1.1) / (log(distance(p,orig)-2.)+.75);\n    }\n    return sum;\n}\n\n//returns both collision dists of unit sphere\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n    \n\t//camera\n\tvec3 ro = vec3(0.,0.,5.);\n    vec3 rd = normalize(vec3(p*.7,-1.5));\n    mat2 mx = mm2(time*.4+um.x*6.);\n    mat2 my = mm2(time*0.3+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    vec3 bro = ro;\n    vec3 brd = rd;\n\t\n    vec3 col = vec3(0.0125,0.,0.025);\n    #if 1\n    for (float j = 1.;j<NUM_RAYS+1.;j++)\n    {\n        ro = bro;\n        rd = brd;\n        mat2 mm = mm2((time*0.1+((j+1.)*5.1))*j*0.25);\n        ro.xy *= mm;rd.xy *= mm;\n        ro.xz *= mm;rd.xz *= mm;\n        float rz = march(ro,rd,2.5,FAR,j);\n\t\tif ( rz >= FAR)continue;\n    \tvec3 pos = ro+rz*rd;\n    \tcol = max(col,vmarch(pos,rd,j, bro));\n    }\n    #endif\n    \n    ro = bro;\n    rd = brd;\n    vec2 sph = iSphere2(ro,rd);\n    \n    if (sph.x > 0.)\n    {\n        vec3 pos = ro+rd*sph.x;\n        vec3 pos2 = ro+rd*sph.y;\n        vec3 rf = reflect( rd, pos );\n        vec3 rf2 = reflect( rd, pos2 );\n        float nz = (-log(abs(flow(rf*1.2,time)-.01)));\n        float nz2 = (-log(abs(flow(rf2*1.2,-time)-.01)));\n        col += (0.1*nz*nz* vec3(0.012,0.512,.5) + 0.05*nz2*nz2*vec3(0.0055,0.2,.55))*0.8;\n    }\n    \n\tfragColor = vec4(col*1.3, 1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdGfWR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[465, 465, 486, 486, 538], [539, 539, 565, 565, 617], [619, 619, 641, 641, 674], [676, 676, 700, 700, 919], [1031, 1076, 1111, 1111, 1327], [1329, 1349, 1373, 1373, 1601], [1603, 1603, 1640, 1640, 1766], [1768, 1768, 1803, 1803, 2016], [2018, 2018, 2045, 2045, 2332], [2334, 2334, 2415, 2415, 2654], [2656, 2678, 2741, 2741, 3329], [3331, 3377, 3416, 3416, 3604], [3606, 3606, 3663, 3663, 4941]], "test": "untested"}
{"id": "sdVBzm", "name": "Something's Alive Inside", "author": "murf", "description": "First experiments", "tags": ["organic"], "likes": 4, "viewed": 210, "published": 3, "date": "1657907756", "time_retrieved": "2024-07-30T16:40:22.691666", "image_code": "mat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime * .2;\n        \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0,0,-1.2);\n    vec3 lookat = vec3(0);\n    \n    vec3 fw = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0),fw)),\n        up = cross(fw,r),\n        c = ro + fw*1.,\n        i = c + uv.x * r + uv.y * up,\n        rd = normalize(i-ro);\n                \n    float ds, d0;\n    vec3 p;\n    \n    vec3 center = vec3(0);\n    float radius = .5;\n    vec3 normal = vec3(0);\n    \n    for(int i=0;i<100;i++) {\n        p = ro + rd * d0;        \n        p.xz*=rot(t);\n        \n        vec3 crd = (p-center);\n        float noise = texture(iChannel0, crd).r * mix(.01, .042, sin(t*2.1)*.5+.5);\n        radius = mix(.48, .5, (sin(p.y*p.x*mix(50.,200.,sin(t*3.)*.5+.5)*.5+.5)));\n        ds = length(p-center) - radius - noise;        \n        if(ds<0.001) break;\n        d0 += ds;\n    }\n    \n    //col.rb += sin(uv*100.);\n    \n    if(ds<0.001){\n        normal = normalize(p+.5);\n        normal = fwidth(normal)*100.;\n        col = normal;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 70], [72, 72, 129, 129, 1240]], "test": "untested"}
{"id": "ssKfRw", "name": "Cuboctahedron Edge Distance", "author": "gehtsiegarnixan", "description": "An algorithm that gives you the distance to the nearest edge of a Cuboctahedron. \n", "tags": ["3d", "distance", "edge", "fcc", "cuboctahedron"], "likes": 0, "viewed": 148, "published": 3, "date": "1657897020", "time_retrieved": "2024-07-30T16:40:23.451634", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nI made this simple edge distance function for the Cuboctahedron. \nIt's basically a cube with cut of corners.\n\nIt has mouse controls to rotated around the center.\n\nThis shape is one of the two shapes best for close packing of spheres (FCC). \nThis shape is not part of the Honeycomb group, so it doesn't tile seamlessly. \n*/\n\n#define pi              3.1415926536\n\n//Distance from the Edge of Cuboctahedron\nfloat cubocDist(vec3 p) {\n    vec3 hra = vec3(0.5); //vector to Diagonal Edge\n    \n    p = abs(p);\n    float pAB = max(p.x,p.y); //rigt and left edge  \n    float pCD = max(dot(p, hra),p.z); //diagonal and top edge\n    \n    float pABCD = max(pAB, pCD);\n    \n    //optional 0-1 range\n    return (.5-pABCD)*2.;\n}\n\n// makes winter colormap with polynimal 6\nvec3 winter(float t) {\n    const vec3 c0 = vec3(-0.000000,-0.000941,1.000471);\n    const vec3 c1 = vec3(0.000000,1.001170,-0.500585);\n    const vec3 c2 = vec3(-0.000000,0.004744,-0.002369);\n    const vec3 c3 = vec3(0.000000,-0.011841,0.005901);\n    const vec3 c4 = vec3(-0.000000,0.012964,-0.006433);\n    const vec3 c5 = vec3(0.000000,-0.005110,0.002500);\n    const vec3 c6 = vec3(-0.000000,-0.000046,0.000045);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// rotates a vetor from SirBelfer4 (https://www.shadertoy.com/view/ssc3z4)\nvec3 rotate(vec3 v, vec3 a)\n{\n    // https://math.stackexchange.com/questions/2975109/how-to-convert-euler-angles-to-quaternions-and-get-the-same-euler-angles-back-fr\n    vec4 q;\n    vec3 c = cos(a * 0.5), s = sin(a * 0.5);\n    q.x = s.x * c.y * c.z - c.x * s.y * s.z;\n    q.y = c.x * s.y * c.z + s.x * c.y * s.z;\n    q.z = c.x * c.y * s.z - s.x * s.y * c.z;\n    q.w = c.x * c.y * c.z + s.x * s.y * s.z;\n    \n    // https://blog.molecular-matters.com/2013/05/24/a-faster-quaternion-vector-multiplication/\n    vec3 qt = 2.0 * cross(q.xyz, v);\n    return v + q.w * qt + cross(q.xyz, qt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y; //centered square UVs\n    float time = fract(0.2*iTime-0.5)-0.5; // used as z dimension    \n    float size = 0.9; //size of Ico\n    \n    vec3 point = vec3(uv, time)/size; //animated uv cords    \n    \n    // controls rotates around the center\n    vec3 camRot = vec3(0.5 - iMouse.yx / iResolution.yx, 0) * 2.0 * pi;\n    camRot.y = -camRot.y;\n    point = rotate(point, camRot);\n    \n    float ico = cubocDist(point); \n    \n    ico = clamp(ico, 0.,1.); //saturate so the cmap doesn't break\n    vec3 col = winter(1.-ico); // applying cosmetic colormap\n    \n    fragColor = vec4(col,0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKfRw.jpg", "access": "api", "license": "mit", "functions": [[1445, 1487, 1512, 1512, 1796], [1798, 1840, 1862, 1862, 2308], [2310, 2385, 2414, 2551, 2972], [2974, 2974, 3031, 3031, 3675]], "test": "untested"}
{"id": "fsKBzw", "name": "Integer Hash - III - vec2âfloat", "author": "FabriceNeyret2", "description": "convenient trivial variant of IQ's https://www.shadertoy.com/view/4tXyWN  eating vec2.\nAny scalings and signing work. \n\nSee also vec3âvec3: https://www.shadertoy.com/view/NtjyWw", "tags": ["2d", "hash"], "likes": 15, "viewed": 762, "published": 3, "date": "1657870955", "time_retrieved": "2024-07-30T16:40:24.216589", "image_code": "// Fork of \"Integer Hash - III\" by iq. https://shadertoy.com/view/4tXyWN\n\nfloat hash( vec2 f )\n{   uvec2 //x = vec2BitsToUvec2 uvec2( floatBitsToUint(f.x), floatBitsToUint(f.y) ),\n          x = floatBitsToUint(f),\n          q = 1103515245U * ( x>>1U ^ x.yx    );\n    return float( 1103515245U * (q.x ^ q.y>>3U) ) / float(0xffffffffU);\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O = vec4( hash(U+iTime) );\n // O = vec4( hash(1e-5*(U+iTime)));  // histograms are ok whatever the scaling\n // O = vec4( hash(1e 5*(U+iTime)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKBzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 96, 96, 336], [338, 338, 376, 376, 526]], "test": "untested"}
{"id": "sdcBWs", "name": "Boiling Mercury Hourglass 3D", "author": "fenix", "description": "* Ray marching inspired by Liquid in Glass by tmst https://www.shadertoy.com/view/3tfcRS\n* Click the center to drag the hourglass\n* Click not-the-center to tilt the hourglass\n* Honestly it's not really supposed to be boiling but I am a n00b.", "tags": ["3d", "simulation", "sdf", "particles", "sph", "fluiddynamics"], "likes": 25, "viewed": 673, "published": 3, "date": "1657865248", "time_retrieved": "2024-07-30T16:40:25.211927", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  3D smoothed particle hydrodynamics, or at least an attempt at such.\n//\n//  Particles are attenuated by 2D distance to line segment for motion blur.\n// \n//  Buffer A computes the particle positions and a 3D voronoi\n//  Buffer B performs a traditional 2D voronoi\n//  Buffer C renders and maitains persistent state\n//\n// ---------------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PARTICLE_DEBUG_RENDER_SIZE = 0.03;\nconst float PARTICLE_VORONOI_CULL_DIST = 0.3;\nconst float PARTICLE_SDF_CULL_DIST = 0.06;\nconst int MAX_PARTICLES = 1000;\nconst vec3 GRAVITY = vec3(-0.00, -0.15, -0.1);\nconst float DENSITY_SMOOTH_SIZE = 0.5;\nconst float PARTICLE_REPEL_SIZE = 0.1;\nconst float PARTICLE_COLLISION_SIZE = 0.2;\nconst float PARTICLE_MASS = 1.0;\nconst float PARTICLE_STIFFNESS = 1.0;\nconst float IDEAL_DENSITY = 30.0;\nconst float PARTICLE_VISCOSITY = 3.5;\nconst float PARTICLE_REPEL = 0.8;\n\n// ===============================\n// Generic Helpers/Constants\n// ===============================\n\n#define PI 3.141592653589793\n#define TWOPI 6.283185307179586\n#define HALFPI 1.570796326794896\n#define SQRT2INV 0.7071067811865475\n\n#define POLAR(theta) vec3(cos(theta), 0.0, sin(theta))\n#define SPHERICAL(theta, phi) (sin(phi)*POLAR(theta) + vec3(0.0, cos(phi), 0.0))\n\n// Same as built-in 'refract' (cf. link) but replaces the case which would\n// normally result in 0 with a reflection (for total internal reflection)\n// https://www.khronos.org/registry/OpenGL-Refpages/gl4/html/refract.xhtml\nvec3 refractFix(vec3 I, vec3 N, float eta) {\n    float k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));\n    return k < 0.0\n        ? reflect(I, N) // <- 'refract' returns 0 here\n    \t: eta * I - (eta * dot(N, I) + sqrt(k)) * N;\n}\n\nvec4 blendOnto(vec4 cFront, vec4 cBehind) {\n    return cFront + (1.0 - cFront.a)*cBehind;\n}\n\nvec4 blendOnto(vec4 cFront, vec3 cBehind) {\n    return cFront + (1.0 - cFront.a)*vec4(cBehind, 1.0);\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat length2(vec3 v)\n{\n    return dot(v, v);\n}\n\n// ===============================\n// Quaternion helpers\n// (Unit quaternions: w+xi+yj+zk)\n// ===============================\n\n#define QID vec4(0.0, 0.0, 0.0, 1.0)\n\nvec4 slerp(vec4 a, vec4 b, float t) {\n    float d = dot(a, b);\n    vec4 a2 = a;\n\n    if (d < 0.0) {\n        d = -d;\n        a2 = -a;\n    }\n    if (d > 0.999) {\n        return normalize(mix(a2, b, t));\n    }\n\n    float theta = acos(d);\n    return (sin((1.-t)*theta)*a2 + sin(t*theta)*b) / sin(theta);\n}\n\nvec4 qMul(vec4 a, vec4 b) {\n    return vec4(\n        a.w*b.x + a.x*b.w + a.y*b.z - a.z*b.y,\n        a.w*b.y - a.x*b.z + a.y*b.w + a.z*b.x,\n        a.w*b.z + a.x*b.y - a.y*b.x + a.z*b.w,\n        a.w*b.w - a.x*b.x - a.y*b.y - a.z*b.z\n    );\n}\n\nvec4 qConj(vec4 q) {\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 qRot(vec3 nvAxis, float angle) {\n    return vec4(nvAxis*sin(angle*0.5), cos(angle*0.5));\n}\n\nmat3 qToMat(vec4 q) {\n    float wx = q.w*q.x, wy = q.w*q.y, wz = q.w*q.z;\n    float xx = q.x*q.x, xy = q.x*q.y, xz = q.x*q.z;\n    float yy = q.y*q.y, yz = q.y*q.z, zz = q.z*q.z;\n    return mat3(\n        1. - 2.*(yy + zz),\n             2.*(xy + wz),\n             2.*(xz - wy),\n\n             2.*(xy - wz),\n        1. - 2.*(xx + zz),\n             2.*(yz + wx),\n\n             2.*(xz + wy),\n             2.*(yz - wx),\n        1. - 2.*(xx + yy)\n    );\n}\n\n// ===============================\n// Reading/writing state\n// ===============================\n\nstruct state {\n    vec3 p; // Pendulum pivot\n    vec3 q; // Accelerate p toward this point\n    vec3 v; // Pendulum \"bob\" (relative to pivot)\n    vec3 L; // Angular momentum\n    vec4 pr; // Object rotation (unit quaternion)\n};\n\nstate readStateInternal(int iFrame, sampler2D sampler) {\n    state s = state(\n        vec3(0.0),\n        vec3(0.0),\n        vec3(0.0, -cos(0.25*PI), sin(0.25*PI)),\n        vec3(0.0, 0.5, 0.0),\n        QID\n    );\n    if (iFrame > 0) {\n        s.p = texelFetch(sampler, ivec2(0, 0), 0).xyz;\n        s.q = texelFetch(sampler, ivec2(1, 0), 0).xyz;\n        s.v = texelFetch(sampler, ivec2(2, 0), 0).xyz;\n        s.L = texelFetch(sampler, ivec2(3, 0), 0).xyz;\n        s.pr = texelFetch(sampler, ivec2(4, 0), 0);\n    }\n    return s;\n}\n\n#define readState() readStateInternal(iFrame, iChannel2)\n\nvoid writeState(in state s, in vec2 fragCoord, inout vec4 fragColor) {\n    if (abs(fragCoord.y - 0.0-0.5) < 0.5) {\n        if (abs(fragCoord.x - 0.0-0.5) < 0.5) {\n            fragColor = vec4(s.p, 1.0);\n        } else if (abs(fragCoord.x - 1.0-0.5) < 0.5) {\n            fragColor = vec4(s.q, 1.0);\n        } else if (abs(fragCoord.x - 2.0-0.5) < 0.5) {\n            fragColor = vec4(s.v, 1.0);\n        } else if (abs(fragCoord.x - 3.0-0.5) < 0.5) {\n            fragColor = vec4(s.L, 1.0);\n        } else if (abs(fragCoord.x - 4.0-0.5) < 0.5) {\n            fragColor = s.pr;\n        }\n    }\n}\n\n// ===============================\n// Camera setup\n// ===============================\n\n#define RES iResolution\n#define TAN_HALF_FOVY 0.5773502691896257\n\nvec3 nvCamDirFromClip(vec3 iResolution, vec3 nvFw, vec2 clip) {\n    vec3 nvRt = normalize(cross(nvFw, vec3(0.,1.,0.)));\n    vec3 nvUp = cross(nvRt, nvFw);\n    return normalize(TAN_HALF_FOVY*(clip.x*(RES.x/RES.y)*nvRt + clip.y*nvUp) + nvFw);\n}\n\nvoid getCameraInternal(in state s, in vec2 uv, in float iTime, in vec3 iResolution, out vec3 camPos, out vec3 nvCamDir) {\n    vec2 mouseAng = vec2(HALFPI*0.75, PI*0.45) + 0.2*vec2(cos(0.5*iTime),sin(0.5*iTime));\n    camPos = vec3(2.0, 1.0, 2.0) + 5.0 * SPHERICAL(mouseAng.x, mouseAng.y);\n\n    vec3 lookTarget = mix(vec3(0.0), s.p, 0.05);\n    vec3 nvCamFw = normalize(lookTarget - camPos);\n\n    nvCamDir = nvCamDirFromClip(iResolution, nvCamFw, uv*2. - 1.);\n}\n\n#define getCamera(X, Y, Z, W) getCameraInternal(X, Y, iTime, iResolution, Z, W)\n\n// ===============================\n// Physics, reading/writing state\n// ===============================\n\nvoid updateStateInternal(inout state s, in vec4 iMouse, in int iFrame, in float iTime, in vec3 iResolution) {\n\n    // pr (object rotation unit quaternion) gets \"slerped\" towards qr\n    float tmod = mod(float(iFrame) / 120.0, 46.0);\n    \n#if 0 // Stop auto-flip\n    vec4 qr = QID;\n#else\n    vec4 qr = (\n        tmod < 20.0 ? QID :\n        tmod < 23.0 ? qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), 0.5*PI):\n        tmod < 43.0 ? qRot(vec3( 1.0, 0.0, 0.0), PI):\n        qRot(vec3(-SQRT2INV, 0.0, SQRT2INV), -0.5*PI)\n    );\n#endif\n\n    // p (object displacement) gets \"lerped\" towards q\n    if (iMouse.z > 0.5) {\n        vec2 uvMouse = iMouse.xy / iResolution.xy;\n        vec3 camPos;\n        vec3 nvCamDir;\n        getCamera(s, uvMouse, camPos, nvCamDir);\n\n        float t = -camPos.z/nvCamDir.z;\n        if (t > 0.0 && t < 50.0) {\n            vec3 center = vec3(0.0);\n            vec3 hit = camPos + t*nvCamDir;\n            float qToCenter = distance(center, s.q);\n            vec3 delta = hit - s.q;\n            if (length2(delta) < 1.0)\n            {\n                s.q = hit;\n            }\n            else\n            {\n                float angle = -atan(delta.x, delta.y);\n                float angle2 = length(delta.xy);\n                qr = qRot(vec3(0.0, 0.0, 1.0), angle);\n                qr = qMul(qr, qRot(vec3(1.0, 0.0, 0.0), angle2));\n            }\n        }\n    }\n\n   // apply lerp p -> q and slerp pr -> qr\n    vec3 vel = 0.25*(s.q - s.p);\n    s.v = vel;\n    s.p += vel;\n    s.pr = normalize(slerp(s.pr, qr, 0.075));\n\n    // object acceleration\n    vec3 a = -0.25*(s.q - s.p) + vec3(0.0, -1.0, 0.0);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    a = prMatInv*a;\n\n    // hand-wavy torque and angular momentum\n    vec3 T = cross(s.v, a);\n    s.L = 0.96*s.L + 0.2*T;\n}\n\n#define updateState(X) updateStateInternal(X, iMouse, iFrame, iTime, iResolution)\n\n// ===============================\n// Geometry definitions\n// ===============================\n\n#define BOUNDING_SPHERE_RADIUS 4.0\n#define GLASS_THICKNESS 0.1\n\nfloat sdfPlane(vec3 planePoint, vec3 nvPlaneN, vec3 p) {\n    return dot(p - planePoint, nvPlaneN);\n}\n\nfloat sdfInterval(float a, float b, float x) {\n    return abs(x - 0.5*(a+b)) - 0.5*(b-a);\n}\n\n// From https://iquilezles.org/articles/distfunctions\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n    \nfloat sdfContainer(vec3 p, state s) {\n    vec3 d0 = abs(p - s.p - vec3(0.0, 2.09, 0.0));\n    vec3 d1 = abs(p - s.p + vec3(0.0, 2.09, 0.0));\n    float s0 = length(d0) - 1.7;\n    float s1 = length(d1) - 1.7;\n    return opSmoothUnion(s0, s1, 1.5);\n}\n\nfloat sdfGlass(vec3 p, state s) {\n    float etchDepth = 0.0; // Can sample from e.g. cubemap here for some texture\n    return sdfInterval(0.0, GLASS_THICKNESS - etchDepth, sdfContainer(p, s));\n}\n\n#define SDF_N_EPS 0.005\n#define SDF_NORMAL(sdfFn, p, s) \\\n    normalize(vec3( \\\n        sdfFn( p+vec3(SDF_N_EPS,0.0,0.0), s ) - sdfFn( p-vec3(SDF_N_EPS,0.0,0.0), s ), \\\n        sdfFn( p+vec3(0.0,SDF_N_EPS,0.0), s ) - sdfFn( p-vec3(0.0,SDF_N_EPS,0.0), s ), \\\n        sdfFn( p+vec3(0.0,0.0,SDF_N_EPS), s ) - sdfFn( p-vec3(0.0,0.0,SDF_N_EPS), s )  \\\n    ))\n    \n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define FUL_NEIGHBORS 0\n#define FUR_NEIGHBORS 1\n#define FLL_NEIGHBORS 2\n#define FLR_NEIGHBORS 3\n#define BUL_NEIGHBORS 4\n#define BUR_NEIGHBORS 5\n#define BLL_NEIGHBORS 6\n#define BLR_NEIGHBORS 7\n#define POS 8\n#define VEL 9\n#define NUM_PARTICLE_DATA_TYPES 10\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec3 pos;\n    float density;\n    vec3 vel;\n    float pressure;\n    \n    ivec4 neighbors[8];\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FUR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUL_NEIGHBORS), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BUR_NEIGHBORS), 0);\n    vec4 particleData6 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLL_NEIGHBORS), 0);\n    vec4 particleData7 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, BLR_NEIGHBORS), 0);\n    vec4 particleData8 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS), 0);\n    vec4 particleData9 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, VEL), 0);\n\n    fxParticle particle;\n    particle.pos = particleData8.xyz;\n    particle.density = particleData8.w;\n    particle.vel = particleData9.xyz;\n    particle.pressure = particleData9.w;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.neighbors[4] = ivec4(particleData4);\n    particle.neighbors[5] = ivec4(particleData5);\n    particle.neighbors[6] = ivec4(particleData6);\n    particle.neighbors[7] = ivec4(particleData7);\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case FUL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case FUR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case FLL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case FLR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case BUL_NEIGHBORS:\n        return vec4(p.neighbors[4]);\n    case BUR_NEIGHBORS:\n        return vec4(p.neighbors[5]);\n    case BLL_NEIGHBORS:\n        return vec4(p.neighbors[6]);\n    case BLR_NEIGHBORS:\n        return vec4(p.neighbors[7]);\n    case POS:  \n        return vec4(p.pos, p.density);\n    case VEL:\n        return vec4(p.vel, p.pressure);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, dataType), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nfloat distanceSquared(vec3 a, vec3 b)\n{\n    vec3 delta = a - b;\n    return dot(delta, delta);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nuvec4 hash(uvec4 x){\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzwx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\nuvec4 hash(uvec3 x0){\n    uvec4 x = x0.xyzz;\n    x = ((x >> 16u) ^ x.yzxy) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxz) * 0x45d9f3bu;\n    x = ((x >> 16u) ^ x.yzxx) * 0x45d9f3bu;\n    //x = (x >> 16u) ^ x;\n    return x;\n}\n\nvec4 noise(ivec4 p){\n    const float scale = pow(2., -32.);\n    uvec4 h = hash(uvec4(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec3 p){\n    const float scale = 1.0/float(0xffffffffU);\n    uvec4 h = hash(uvec3(p));\n    return vec4(h)*scale;\n}\n\nvec4 noise(ivec2 p){\n    return noise(ivec3(p, 0));\n}\n\nfloat SPHKernel (float x)\n{\n    x *= (1.0 / DENSITY_SMOOTH_SIZE);\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\n\nfloat SPHKernel (vec3 deltaPos)\n{\n    float x = length(deltaPos);\n    return SPHKernel(x);\n}\n\nfloat SPHgradKernel (float x)\n{\n    x *= (1.0 / PARTICLE_REPEL_SIZE);\n\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return PARTICLE_REPEL * (0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx);\n    }\n    else\n        return 0.0;\n}\n\nbool intersectSphere(in vec3 ro, in vec3 rd, in vec3 center, in float radius2, out float t) \n{ \n    float t0, t1;  //solutions for t if the ray intersects \n    // geometric solution\n    vec3 L = center - ro; \n    float tca = dot(L, rd); \n    // if (tca < 0) return false;\n    float d2 = dot(L, L) - tca * tca; \n    if (d2 > radius2) return false; \n    float thc = sqrt(radius2 - d2); \n    t0 = tca - thc; \n    t1 = tca + thc; \n\n    if (t0 > t1)\n    {\n        float temp = t0;\n        t0 = t1;\n        t1 = temp;\n    }\n    if (t0 < 0.0) { \n        t0 = t1;  //if t0 is negative, let's use t1 instead \n        if (t0 < 0.0) return false;  //both t0 and t1 are negative \n    } \n\n    t = t0; \n\n    return true; \n} \n\nfloat linePointDist2(in vec3 newPos, in vec3 oldPos, in vec3 point, out vec3 closest)\n{\n    vec3 pDelta = (point - oldPos);\n    vec3 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec3 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec3 closestDelta = closest - point;\n    return dot(closestDelta, closestDelta);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// ---------------------------------------------------------------------------------------\n// Computes the position of each particle, one per texture fragment.\n// ---------------------------------------------------------------------------------------\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec3 myPos);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 iFragCoord = ivec2(fragCoord);\n    state s = readState();\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    mat3 prMat = inverse(prMatInv);\n\n    //we only simulate PARTICLES amount of particles\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if (id >= MAX_PARTICLES) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS || dataType == VEL)\n    {\n        if (iFrame == 0 || data.pos != data.pos || keyDown(32))\n        {\n            const vec3 INIT_CENTER = vec3(0.0, 2.0, 0.0);\n            const vec3 INIT_EXTENTS = vec3(2.0, 2.0, 2.0);\n            vec3 initPos = (noise(ivec4(int(fragCoord.x) / 2, fragCoord.y, int(fragCoord.x) / 2 + 2, fragCoord.y + 2.0)).xyz - 0.5) * INIT_EXTENTS + INIT_CENTER;\n\n            data.pos = prMat*initPos + s.p;\n            data.vel = vec3(0.0, 0.0, 0.0);\n        }\n        else\n        {\n            float myDensity = PARTICLE_MASS * SPHKernel(vec3(0));\n            float newDensity = SPHKernel(vec3(0));\n            vec3 force = GRAVITY;\n            vec3 densityGrad = vec3(0);\n            \n            vec3 avgVel = data.vel * myDensity;\n\n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 8; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= MAX_PARTICLES) continue;\n                    \n                    vec4 otherPosDensity = fxGetParticleData(cid, POS);\n                    vec4 otherVelPressure = fxGetParticleData(cid, VEL);\n                    vec3 deltaPos = data.pos - otherPosDensity.xyz;\n                    float dist = length(deltaPos) + 0.001;\n                    vec3 dir = deltaPos / dist;\n                                            \n                    float neighborDensity = PARTICLE_MASS * SPHKernel(deltaPos);\n                    newDensity += neighborDensity;\n                    avgVel += otherVelPressure.xyz * neighborDensity;\n                    densityGrad += neighborDensity * deltaPos;\n                    \n                    force -= dir * SPHgradKernel(dist);\n                }\n            }       \n            \n            force += 0.1 * avgVel / newDensity - data.vel * 0.3;\n            float overDensity = max(0.0, newDensity - IDEAL_DENSITY);\n            force += overDensity * densityGrad * 0.0001;\n            \n            // Record misc solver results\n            data.density = newDensity;\n            data.pressure = PARTICLE_STIFFNESS * (newDensity - IDEAL_DENSITY);            \n\n            // Boundary\n            vec3 objectPoint = prMatInv * (data.pos - s.p) + s.p;\n            float sd = sdfContainer(objectPoint, s);\n\n            if (sd > -PARTICLE_REPEL_SIZE)\n            {\n                data.density += SPHKernel(sd) * 0.2;\n            }\n            if (sd > 0.0)\n            {\n                vec3 normal = SDF_NORMAL(sdfContainer, objectPoint, s);\n                normal = prMat * normal;\n                data.pos = data.pos - (sd) * normal;\n                data.vel += s.v;\n                if(dot(data.vel, normal) > 0.0)\n                {\n                    data.vel = reflect(data.vel, normal);\n                    //data.vel -= normal * dot(data.vel, normal);\n                    data.vel += -0.3 * data.vel;\n                }\n            }\n\n            // Apply force\n            data.vel = data.vel + force;\n\n            // Damping\n            data.vel -= data.vel * 0.1;\n            data.vel -= data.vel * length2(data.vel) * 0.1;\n            data.vel -= data.vel * 0.4 * smoothstep(10.0, 40.0, data.density);\n\n            // Clamping\n            float maxSpeed = 20000.0 / (iResolution.x + iResolution.y); // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel / myDensity;\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        ivec4 nb0 = ivec4(fxGetParticleData(id, dataType));\n        ivec4 bestIds = ivec4(-1);\n        vec4 bestDists = vec4(1e6);\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, nb0[i], dataType, data.pos);\n        }\n        \n        //random sorts\n        for (int i = 0; i < 16; ++i)\n        {\n            int searchId = int(float(MAX_PARTICLES) * hash13(vec3(iFrame, id, i)));\n            sort0(bestIds, bestDists, id, searchId, dataType, data.pos);\n        }\n        \n        fragColor = vec4(bestIds);\n        \n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec3 myPos)\n{\n    if (searchId >= MAX_PARTICLES) return; // particle recycled\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec3 nbX = fxGetParticleData(searchId, POS).xyz; \n\n    vec3 dx = nbX - myPos;\n    int dir = int((sign(dx.x) * 0.5 + 1.0) + 2.0 * (sign(dx.y) * 0.5 + 1.0) + 4.0 * (sign(dx.z) * 0.5 + 1.0));\n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    //if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nconst float PARTICLE_CULL_DIST_2 = PARTICLE_VORONOI_CULL_DIST * PARTICLE_VORONOI_CULL_DIST;\n\nfloat particleDistance(in int id, in vec3 ro, in vec3 rd)\n{\n    if(id==-1) return 1e6;\n\n    vec3 pos = fxGetParticleData(id, POS).xyz;\n    \n    float t;\n    if (intersectSphere(ro, rd, pos, PARTICLE_CULL_DIST_2, t))\n    {\n        return t;\n    }\n    else\n    {\n        return 1e6;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n   \tivec2 iFragCoord = ivec2(fragCoord);\n    state s = readState();\n\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n    \n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = ivec4(-1);\n    vec4 dis = vec4(1e6);\n        \n    ivec4 old = fxGetClosest(ivec2(fragCoord));\n    for (int i = 0; i < 4; ++i)\n    {\n        float dis2 = particleDistance(old[i], camPos, nvCamDir);\n        insertion_sort(new, dis, old[i], dis2);\n    }\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = particleDistance(id, camPos, nvCamDir);\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 3;\n    if (iFrame < 5)\n    {\n        searchIterations = 100;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        //pick random id of particle\n        int p = int(h * float(MAX_PARTICLES));//int(h*float(MAX_PARTICLES));\n        insertion_sort(new, dis, p, particleDistance(p, camPos, nvCamDir));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Ray marching inspired by Liquid in Glass by tmst https://www.shadertoy.com/view/3tfcRS\n\n// ===============================\n// Marching, lighting/materials\n// ===============================\n\n#define SDF_EPS 0.01\n#define DSTEP_ADJUST_EPS 0.02\n#define STEPS 80\n\n#define LIGHT_COLOR vec3(1.0)\n\n#define GLASS_COLOR vec3(0.0, 0.0, 0.0)\n#define GLASS_OPACITY 0.6\n\n#define IR_AIR 1.0\n#define IR_GLASS 1.5\n\n// Increase this few fewer artifacts to give your gfx card a workout\nconst int MAX_CACHED_PARTICLES = 12;\n\n// Enums\n#define SUBSTANCE_AIR 0\n#define SUBSTANCE_GLASS 1\n\nvec4 computeSpecular(\n    in float specularCoefficient,\n    in float specularExponent,\n    in vec3 nvNormal,\n    in vec3 nvFragToLight,\n    in vec3 nvFragToCam)\n{\n    vec3 blinnH = normalize(nvFragToLight + nvFragToCam);\n    float valSpecular = pow(max(0.0, dot(nvNormal, blinnH)), specularExponent);\n    valSpecular *= specularCoefficient;\n\n    return valSpecular*vec4(LIGHT_COLOR, 1.0);\n}\n\nvec4 cachedParticles[MAX_CACHED_PARTICLES];\nint numCachedParticles = 0;\n\nconst float PARTICLE_CULL_DIST_2 = PARTICLE_SDF_CULL_DIST * PARTICLE_SDF_CULL_DIST;\n\nfloat particleDistance(vec3 pos, in vec3 ro, in vec3 rd)\n{\n    float t;\n    if (intersectSphere(ro, rd, pos, PARTICLE_CULL_DIST_2, t))\n    {\n        return t;\n    }\n    else\n    {\n        return 1e6;\n    }\n}\n\nvoid cacheParticle(vec3 pos, vec3 camPos, vec3 nvCamDir)\n{\n    vec3 closest;\n    float dist2 = particleDistance(pos, camPos, camPos + nvCamDir);\n\n    for (int i = 0; i < numCachedParticles; ++i)\n    {\n        if (length2(cachedParticles[i].xyz - pos) < 0.01)\n        {\n            return;\n        }\n    }\n\n    if (numCachedParticles < MAX_CACHED_PARTICLES)\n    {\n        cachedParticles[numCachedParticles++] = vec4(pos, dist2);\n    }\n    else\n    {\n        for (int i = 0; i < MAX_CACHED_PARTICLES; ++i)\n        {\n            if (cachedParticles[i].w > dist2)\n            {\n                cachedParticles[i] = vec4(pos, dist2);\n                \n                return;\n            }\n        }\n    }\n}\n\nvoid cacheParticlesNearRay(vec2 fragCoord, vec3 camPos, vec3 nvRayDir)\n{\n    numCachedParticles = 0;\n    \n    // Disable fluid surface\n//return;\n    ivec4 nb0 = fxGetClosest(ivec2(fragCoord));\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        int particleIndex = nb0[i];\n        if (particleIndex == -1) continue;\n        fxParticle p = fxGetParticle(particleIndex);\n\n        cacheParticle(p.pos, camPos, nvRayDir);\n        \n        for (int n = 0; n < 8; ++n)\n        {\n            ivec4 neighborhood = p.neighbors[n];\n            for (int j = 0; j < 2; ++j)\n            {\n                int particleIndex = neighborhood[j];\n                if (particleIndex == -1) continue;\n                vec3 nPos = fxGetParticleData(particleIndex, POS).xyz;\n\n                cacheParticle(nPos, camPos, nvRayDir);\n            }\n        }\n    }\n}\n\n// https://iquilezles.org/articles/smin/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdfMercury(vec3 p, state s) {\n    float dglass = sdfContainer(p, s);\n    mat3 prMatInv = qToMat(qConj(s.pr));\n\n    float minDist = 1e20;\n    for (int i = 0; i < numCachedParticles; ++i)\n    {\n        minDist = smin(minDist, distance(p, prMatInv*(cachedParticles[i].xyz - s.p) + s.p) - 0.1, 8.0);\n    }\n\n    return opSubtraction(opSubtraction(minDist, dglass), dglass);\n}\n\nvoid march(in state s, in vec2 fragCoord, in vec3 pRay, in vec3 nvRayIn, out vec4 color, out vec3 nvRayOut)\n{\n    // Light (in world coordinates)\n    vec3 pLightO = pRay + vec3(0.0, 10.0, 0.0);\n\n    // Light and camera (in object coordinates)\n    mat3 prMatInv = qToMat(qConj(s.pr));\n    vec3 pCam = prMatInv*(pRay - s.p) + s.p;\n    vec3 pLight = prMatInv*(pLightO - s.p) + s.p;\n\n    // Ray while marching (in object coordinates)\n    vec3 pCur = pCam;\n    vec3 nvRayCur = prMatInv*nvRayIn;\n\n    cacheParticlesNearRay(fragCoord, pRay, nvRayIn);\n\n    color = vec4(0.0);\n    int curSubstance = SUBSTANCE_AIR;\n\n    int i=0;\n    for (; i<STEPS; i++) {\n\n        // Quick exits\n        // ----------------\n        vec3 centerToCur = pCur - s.p;\n        if (\n            (length(centerToCur) > BOUNDING_SPHERE_RADIUS) &&\n            (dot(nvRayCur, centerToCur) > 0.0)\n        ) { break; }\n\n        if (color.a > 0.95) { break; }\n\t\t// ----------------\n        \n        float sdGlass = sdfGlass(pCur, s);\n        float sdMercury = sdfMercury(pCur, s);\n        vec3 dpStep = abs(min(sdGlass, sdMercury))*nvRayCur;\n\n        vec3 nvGlass = SDF_NORMAL(sdfGlass, pCur, s);\n        vec3 nvMercury = SDF_NORMAL(sdfMercury, pCur, s);\n\n        if (curSubstance == SUBSTANCE_AIR)\n        {\n            if (sdGlass < SDF_EPS && dot(nvGlass,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_GLASS;\n\n                vec4 sColor = computeSpecular(\n                    0.8, 80.0, nvGlass, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                // Schlick approximation\n                float cosHitAngle = clamp(dot(nvGlass, -nvRayCur), 0.0, 1.0);\n                float r0 = pow((IR_GLASS-IR_AIR)/(IR_GLASS+IR_AIR), 2.0);\n                float valRefl = mix(r0, 1.0, pow(clamp(1.0 - cosHitAngle, 0.0, 1.0), 3.0)); // Modified exponent 5 -> 3\n\n                vec3 nvRefl = reflect(nvRayCur, nvGlass);\n                color = blendOnto(color, valRefl*vec4(texture(iChannel3, nvRefl).rgb, 1.0));\n\n                dpStep = sdGlass*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlass;\n                nvRayCur = refractFix(nvRayCur, nvGlass, IR_AIR/IR_GLASS);\n            }\n            else if (sdMercury < SDF_EPS && dot(nvMercury, nvRayCur) < 0.0)\n            {\n                vec4 sColor = computeSpecular(\n                    1.0, 40.0, nvMercury, normalize(pLight-pCur), normalize(pCam-pCur)\n                );\n                color = blendOnto(color, sColor);\n\n                nvRayCur = reflect(nvRayCur, nvMercury);\n            }\n        }\n        else if (curSubstance == SUBSTANCE_GLASS)\n        {\n            float sdGlassInv = -sdGlass;\n            vec3 nvGlassInv = -nvGlass;\n\n            dpStep = abs(sdGlassInv)*nvRayCur;\n\n            color = blendOnto(color, clamp(GLASS_OPACITY*sdGlassInv,0.0,1.0)*vec4(GLASS_COLOR, 1.0));\n\n            if (sdGlassInv < SDF_EPS && dot(nvGlassInv,nvRayCur) < 0.0)\n            {\n                curSubstance = SUBSTANCE_AIR;\n\n                dpStep = sdGlassInv*nvRayCur;\n                dpStep += -DSTEP_ADJUST_EPS*nvGlassInv;\n                nvRayCur = refractFix(nvRayCur, nvGlassInv, IR_GLASS/IR_AIR);\n            }\n\n        } \n        pCur += dpStep;\n    }\n\n    // Convert ray direction from object to world coordinates\n    nvRayOut = qToMat(s.pr)*nvRayCur;\n}\n\nvoid renderParticle(in vec3 pos, in vec3 camPos, in vec3 nvCamDir, in vec3 color, inout vec4 fragColor)\n{    \n    float t;\n    if (intersectSphere(camPos, nvCamDir, pos, PARTICLE_DEBUG_RENDER_SIZE * PARTICLE_DEBUG_RENDER_SIZE, t))\n    {\n        fragColor.xyz = color;\n    }\n}\n\nvoid renderAllParticles(vec2 fragCoord, vec3 camPos, vec3 nvCamDir, inout vec4 fragColor)\n{\n#if 1 // Render particles from voronoi buffer\n    ivec4 nb0 = fxGetClosest(ivec2(fragCoord));\n    \n    for (int i = 0; i < 4; ++i)\n    {\n        int particleIndex = nb0[i];\n        if (particleIndex == -1) continue;\n        vec4 pos = fxGetParticleData(particleIndex, POS);\n        \n        vec3 color = vec3(pos.w * pos.w * 0.001, 0.8, 0.0);\n        renderParticle(pos.xyz, camPos, nvCamDir, color, fragColor);\n    }\n#else // Render all particles (slow)\n    for (int particleIndex = 0; particleIndex < MAX_PARTICLES; ++particleIndex)\n    {\n        vec4 pos = fxGetParticleData(particleIndex, POS);\n        \n        vec3 color = vec3(pos.w * pos.w * 0.001, 0.8, 0.0);\n        renderParticle(pos.xyz, camPos, nvCamDir, color, fragColor);\n    }\n#endif\n}\n\n// ===============================\n// Main render\n// ===============================\n\nvec4 mainColor(vec2 fragCoord, state s) {\n    vec3 camPos;\n    vec3 nvCamDir;\n    vec2 uv = fragCoord / RES.xy;\n    getCamera(s, uv, camPos, nvCamDir);\n\n    vec4 color;\n    vec3 nvRayOut;\n    march(s, fragCoord, camPos, nvCamDir, color, nvRayOut);\n    \n    // Debug draw particles\n    //renderAllParticles(fragCoord, camPos, nvCamDir, color);\n\n    return blendOnto(color, texture(iChannel3, nvRayOut).rgb);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    state s = readState();\n\n    fragColor = mainColor(fragCoord, s);\n\n    updateState(s);\n    writeState(s, fragCoord, fragColor);\n}\n", "buffer_c_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcBWs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[620, 620, 677, 677, 741]], "test": "untested"}
{"id": "fdVBRw", "name": "The door at the end of the world", "author": "leon", "description": "final boss vibes", "tags": ["fire", "hell", "smoke"], "likes": 82, "viewed": 1224, "published": 3, "date": "1657858634", "time_retrieved": "2024-07-30T16:40:26.049687", "image_code": "\n// The door at the end of the world\n// revisiting Smell of Burning Plastic https://www.shadertoy.com/view/7dyBRm\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 blue = texture(iChannel1, fragCoord/1024.).rgb;\n    vec3 color = vec3(0);\n    \n    // masks\n    float shade = texture(iChannel0, uv).r;\n    float flame = pow(shade, 3.);\n    float smoke = pow(shade, .5);\n    float height = flame;\n    \n    // normal\n    float range = 30.*blue.x;\n    vec3 unit = vec3(range/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        height));\n        \n    // lighting\n    vec3 tint = .5+.5*cos(vec3(1,2,3)-flame*5.-4.);\n    vec3 dir = normalize(vec3(0,-.5,0.5));\n    float light = dot(normal, dir)*.5+.5;\n    light = pow(light,.5);\n    light *= (uv.y+.5); \n    color += tint * flame;\n    color += vec3(.5) * light;\n    color *= smoke;\n    color -= .1*blue.x;\n    color += smoothstep(.1,.0,1.-shade);\n    \n    // show layers\n    if (iMouse.z > 0.5) {\n        if (iMouse.x < 20.) {\n            if (uv.y < .25) {\n                color = vec3(shade);\n            } else if (uv.y < .5) {\n                color = normal;\n            } else if (uv.y < .75) {\n                color = tint;\n            } else {\n                color = vec3(.5)*light;\n            }\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// fbm gyroid cyclic noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        result += (gyroid(seed/a))*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// the fluidish simulacre\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 blue = texture(iChannel1, fragCoord/1024.).rgb;\n    \n    float dt = iTimeDelta;\n    float current = texture(iChannel0, uv).r;\n    \n    // shape\n    float shape = abs(max(abs(p.x)-.1, abs(p.y)-.2))-.01;    \n    \n    // masks\n    float shade = smoothstep(.01,.0,shape);\n    float smoke = pow(uv.y,.5);\n    float flame = 1.-uv.y;\n    float steam = pow(current, 0.2);\n    float cycle = .5 + .5 * sin(iTime-uv.x*3.);\n    \n    vec2 offset = vec2(0);\n    \n    // bubble animation cycle\n    vec2 pp = fract(p*1.-vec2(.5,iTime*.2))-.5;\n    float lpp = length(pp);\n    float mask = smoothstep(.5,.0,lpp);\n    offset += (-pp)*mask*5.;\n    \n    // ignit with bubble\n    shade *= .5+.5*mask;\n    \n    // environment\n    /*\n    vec2 q = p;\n    float c = .05;\n    q.x += floor(q.y/c)*.02+.1;\n    q.y = repeat(q.y, c);\n    shape = max(p.y+.22, abs(box(q, vec2(.1,.002))));\n    shape = min(shape, abs(length(p+vec2(0,.2))-.8));\n    shade = min(1., shade+.75*smoothstep(.01,.0,abs(shape)));\n    */\n    \n    // expansion\n    vec4 data = texture(iChannel0, uv);\n    vec3 unit = vec3(2./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv - unit.xz)-TEX(uv + unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        data.x*data.x*data.x)+.001);\n    offset -= normal.xy * smoke;\n    \n    // turbulence\n    vec3 seed = vec3(p*4.,p.y+iTime);\n    float angle = fbm(seed)*6.28*2.;\n    offset += vec2(cos(angle),sin(angle)) * flame;\n    \n    // energy loss\n    vec4 frame = texture(iChannel0, uv+offset/iResolution.xy);\n    shade = max(shade, frame.r-dt*.4);\n    fragColor = vec4(shade);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\n#define TEX(uv) texture(iChannel0, uv).r\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nfloat box (vec2 p, vec2 r) { return max(abs(p.x)-r.x,abs(p.y)-r.y); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdVBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 115, 172, 172, 1458]], "test": "untested"}
{"id": "sdGBzm", "name": "Soul Stone Melting", "author": "leon", "description": "Stone is magic apparently", "tags": ["magic", "liquid", "stone", "spell"], "likes": 8, "viewed": 433, "published": 3, "date": "1657849489", "time_retrieved": "2024-07-30T16:40:26.806663", "image_code": "// Soul Stone Melting\n// revisiting Metal Melting Flavor https://www.shadertoy.com/view/fsyBzD\n// goal at first was to make a better liquid animation\n// ended up with magic melting living stone\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat rng, mask, details;\nvec2 mouse;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float noise;\n    vec3 pp = p;\n    \n    // box shape\n    p.zy *= rot(iTime*.1);\n    dist = sdBox(p, vec3(1.75,.75,.1));\n    \n    // surface details displacement\n    noise = pow(abs(fbmSin(p*1.)),0.5);\n    details = noise;\n    dist -= noise*.1;\n    \n    // liquid displacement\n    p = pp;\n    vec3 seed = p*2.;\n    seed.y *= .3;\n    p.xz *= (1.2+p.y)*1.5;\n    noise = fbm(seed, iTime);\n    noise = pow(abs(noise),3.)*-p.y*2./length(pp.xz);\n    noise = abs(noise);\n    mask = noise;\n    dist -= noise*.3;\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(.2)*smoothstep(2.,.5,length(uv));\n    \n    // mouse interaction\n    if (iMouse.z > 0.5) {\n        mouse = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n    }\n    else mouse = vec2(0);\n    \n    // coordinates\n    vec3 pos = vec3(0,0,3);\n    vec3 at = vec3(0);\n    pos.xz *= rot(cos(iTime*.2)*.2+mouse.x);\n    pos.zy *= rot(sin(iTime*.2)*.1-mouse.y);\n    vec3 ray = lookAt(pos, at, uv, .9);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    rng = white.x;\n    \n    // blur edges\n    float dof = .2*smoothstep(.5, 2., length(uv));\n    ray.xy += vec2(cos(blue.x*6.28),sin(blue.x*6.28))*white.z*dof;\n    \n    // raymarch\n    float maxDist = 5.;\n    const float count = 30.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*blue.z;\n        ray += white * total*.01;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        // NuSan https://www.shadertoy.com/view/3sBGzV\n        vec2 noff = vec2(.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n\n        // Inigo Quilez color palette https://iquilezles.org/www/articles/palettes/palettes.htm\n        vec3 tint = .5+.5*cos(vec3(0,.3,.6)*6.283+uv.y*1.+iTime);\n\n        // lighting\n        vec3 rf = reflect(ray, normal);\n        float glow = dot(normal, ray)*.5+.5;\n        color = vec3(0.5)*mask;\n        color += vec3(.5)*pow(dot(rf, vec3(0,1,0))*.5+.5, .5)*(1.-mask);\n        color += tint*glow*mask;\n        color += tint*pow(details,2.);\n        color *= shade;\n        color += blue.x*.1;\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// gyroid fbm noises\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed, float t) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        seed.y += .05*t/a;\n        result += gyroid(seed/a)*a;\n        a /= 2.;\n    }\n    return result;\n}\nfloat fbmSin (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        result += sin(gyroid(seed/a)*3.14)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 271, 328, 328, 410]], "test": "untested"}
{"id": "7dyBRm", "name": "Smell of Burning Plastic", "author": "leon", "description": "shader fragrange", "tags": ["fire", "smoke", "plastic"], "likes": 28, "viewed": 633, "published": 3, "date": "1657845202", "time_retrieved": "2024-07-30T16:40:27.569623", "image_code": "\n// Smell of Burning Plastic\n// revisiting Liquid Toy https://www.shadertoy.com/view/fljBWc\n// with gyroid turbulences and a burning floor context\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 blue = texture(iChannel1, fragCoord/1024.).rgb;\n    vec3 color = vec3(0);\n    \n    // masks\n    float shade = texture(iChannel0, uv).r;\n    float flame = pow(shade, 6.);\n    float smoke = pow(shade, .5);\n    float height = flame;\n    \n    // normal\n    float range = 30.*blue.x;\n    vec3 unit = vec3(range/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        height));\n        \n    // lighting\n    vec3 tint = .5+.5*cos(vec3(0,.3,.6)*6.28-flame*4.-4.);\n    vec3 dir = normalize(vec3(0,-.5,0.5));\n    float light = dot(normal, dir)*.5+.5;\n    light = pow(light,.5);\n    light *= (uv.y+.5); \n    color += tint * flame;\n    color += vec3(.5) * light;\n    color *= smoke;\n    color -= .1*blue.x;\n    color += smoothstep(.1,.0,1.-shade);\n    \n    // show layers\n    if (iMouse.z > 0.5) {\n        if (iMouse.x < 20.) {\n            if (uv.x < .25) {\n                color = vec3(shade);\n            } else if (uv.x < .5) {\n                color = normal;\n            } else if (uv.x < .75) {\n                color = tint;\n            } else {\n                color = vec3(.5)*light;\n            }\n        }\n    }\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// fbm gyroid cyclic noise\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 4; ++i) {\n        result += sin(gyroid(seed/a)*3.14+iTime/a)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// the fluidish simulacre\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 blue = texture(iChannel1, fragCoord/1024.).rgb;\n    \n    float dt = iTimeDelta;\n    float current = texture(iChannel0, uv).r;\n    \n    // shape\n    float shape = p.y+.5;\n    \n    // mouse interaction\n    if (iMouse.z > 0.5) {\n        vec2 mouse = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        shape = min(shape, length(p-mouse)-.01);\n    }\n    \n    \n    // masks\n    float shade = smoothstep(.01,.0,shape);\n    float smoke = pow(uv.y,.5);\n    float flame = 1.-uv.y;\n    float steam = pow(current, 0.2);\n    float cycle = .5 + .5 * sin(iTime-uv.x*3.);\n    \n    vec2 offset = vec2(0);\n    \n    // gravity\n    offset += vec2(0,-1) * flame * cycle * steam;\n    \n    // wind\n    //offset.x += sin(iTime*.2);\n    //offset += 3.*normalize(p*rot(.1)-p) * smoothstep(.1,.0,abs(length(p)-.5));\n    \n    // expansion\n    vec4 data = texture(iChannel0, uv);\n    vec3 unit = vec3(20.*blue.x/iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv - unit.xz)-TEX(uv + unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        data.x*data.x*data.x)+.001);\n    offset -= normal.xy * (smoke + cycle) * steam;\n    \n    // turbulence\n    vec3 seed = vec3(p*2.,p.y);\n    float angle = fbm(seed)*6.28*2.;\n    offset += vec2(cos(angle),sin(angle)) * flame;\n    \n    // energy loss\n    vec4 frame = texture(iChannel0, uv+offset/iResolution.xy);\n    shade = max(shade, frame.r-dt*.2);\n    fragColor = vec4(shade);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define TEX(uv) texture(iChannel0, uv).r\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 205, 205, 1498]], "test": "untested"}
{"id": "7dGfzw", "name": "Neon Screw 2", "author": "murf", "description": "Happy accidents", "tags": ["sdf"], "likes": 1, "viewed": 135, "published": 3, "date": "1657834842", "time_retrieved": "2024-07-30T16:40:28.360509", "image_code": "mat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime * .2;\n    \n    //uv *= mat2(-cos(t),-sin(t),-sin(t),-cos(t));\n    \n    vec3 col = vec3(0);\n    //vec3 light = vec3(cos(iTime),3,sin(iTime));\n    vec3 light = vec3(0,0,5);\n    \n    vec3 ro = vec3(0,0,-1.2);\n    vec3 lookat = vec3(0);\n    \n    vec3 fw = normalize(lookat-ro),\n        r = normalize(cross(vec3(0,1,0),fw)),\n        up = cross(fw,r),\n        c = ro + fw*1.,\n        i = c + uv.x * r + uv.y * up,\n        rd = normalize(i-ro);\n                \n    float ds, d0;\n    vec3 p;\n    \n    vec3 center = vec3(0);\n    float radius = .5; //mix(.2, .5, (sin(uv.y)*.5+.5));\n    vec3 normal = vec3(0);\n    \n    for(int i=0;i<100;i++) {\n        p = ro + rd * d0;        \n        p.xz*=rot(t);\n        \n        //float noise = texture(iChannel0, normalize(p-center)).r * .01;\n        radius = mix(.4, .5, (sin(p.y*p.x*100.)*.5+.5));\n        ds = length(p-center) - radius;//- noise;        \n        if(ds<0.001) break;\n        d0 += ds;\n    }\n    \n    //col.rb += sin(uv*100.);\n    \n    if(ds<0.001){\n        normal = normalize(p+.5);\n        normal = fwidth(normal)*110.;\n        \n        vec3 lDir = normalize(light-center);\n        col += vec3(0.2,0.,0.);\n        col += vec3(1,0,0)*dot(normal,lDir);\n        //col += vec3(1)*dot(reflect(lDir, normal),rd);\n        col = clamp(vec3(0),vec3(1),col);\n        \n        col = normal;\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 70], [72, 72, 129, 129, 1578]], "test": "untested"}
{"id": "7dGfRw", "name": "Polaroid Gyroidoscopic", "author": "leon", "description": "another gyroid toy", "tags": ["simple", "gyroid"], "likes": 13, "viewed": 424, "published": 3, "date": "1657830669", "time_retrieved": "2024-07-30T16:40:29.149399", "image_code": "// playing with gyroid cyclic noise and polar coordinates\n// trying to find elegance with simplicity\n\n#define t iTime*.1\n\nfloat gyroid (vec3 seed) { return dot(sin(seed),cos(seed.yzx)); }\nfloat fbm (vec3 seed) {\n    float result = 0.;\n    float a = .5;\n    for (int i = 0; i < 3; ++i) {\n        result += sin(gyroid(seed/a)*3.+t/a)*a;\n        a /= 2.;\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 p = vec3((fragCoord-iResolution.xy/2.)/iResolution.y,0);\n    vec3 color = vec3(p*.5+.5);\n    \n    p = vec3(\n        atan(p.y,p.x) * .5,\n        log(length(p)) - t,\n        t+p.y );\n    \n    float shade = (fbm(p)+1.)/2.;\n    fragColor = vec4(mix(color,vec3(1),shade)*shade, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 148, 148, 187], [188, 188, 211, 211, 378], [379, 379, 436, 436, 729]], "test": "untested"}
{"id": "NdKfRD", "name": "Subdivided Grid Truchet Pattern", "author": "Shane", "description": "Rendering a Truchet pattern onto a randomly subdivided square grid -- otherwise known as a multiscale Truchet pattern.", "tags": ["grid", "square", "truchet", "multiscale", "quadtree", "subdivide"], "likes": 62, "viewed": 686, "published": 3, "date": "1657807173", "time_retrieved": "2024-07-30T16:40:29.902386", "image_code": "/*\n\n    Subdivided Grid Truchet Pattern\n    -------------------------------\n    \n    Rendering a Truchet pattern onto a randomly subdivided square grid. It can \n    also be referred to as a multiscale Truchet pattern. This particular \n    variation is pretty common, so there's a better than even chance that \n    you've seen some around. I put together a multiscaled Truchet example a \n    while ago, and this was one of many variations I tried out. I was saving it \n    for a pseudo 3D version, but have procrastinated on it for too long, so \n    figured I'd repackage the original and post it in 2D form.\n    \n    If it's not immediately obvious from the pattern, it's a simple rendering\n    of concentric-circle Truchet rings onto a randomly subdivided grid. \n    Uncommenting the \"SHOW_GRID\" define should make it more clear. When you\n    subdivide down a level, you simply render half the amount of concentric \n    rings in the next cell, and so forth. Common sense dictates that you should\n    choose an initial number of rings that can be halved to maintain integer \n    rings for the next subdivision; For instance, 12 rings in the big cells \n    will allow for 2 more sudivisions (12-6-3).\n    \n    This particular setup subdivides cells without considering neighbors, so \n    is shorter and easier to understand, but doesn't allow for rendering things \n    like long shadows, etc. There's a tiny bit of extra dressup code here, but \n    this is a pretty basic example with a reasonably small code footprint. A \n    simple black and white pattern would require far less code still... I'll \n    leave that as an exercise for the code golfing crowd. :)\n    \n    I would eventually like to produce a more 3D looking version. It's also \n    possible to produce these on other kinds of subdivision grids, like \n    triangles and others -- I have a triangle version floating around somewhere, \n    and a pattern mapped onto a 3D surface that I'd like to post later.\n    \n    \n    \n    Based on:\n    \n    A multiscale Truchet pattern that considers neighboring cells.\n    Quadtree Truchet - Shane\n    https://www.shadertoy.com/view/4t3BW4\n    \n    // A concentric circle Truchet pattern in under a tweet. The code \n    // contains fewer characters than it took to write this description. :)\n    70s Wallpaper - Shane\n    https://www.shadertoy.com/view/ls33DN\n    \n    \n*/\n\n\n//////////////\n\n// Stripe color - Gold: 0, Pink: 1, Green: 2, Silver: 3.\n#define COLOR 0\n\n// Background stripe shade - Black: 0, White: 1.\n#define COLORB 1\n\n// Show the randomly subdivided grid.\n//#define SHOW_GRID\n\n//////////////\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Global scale -- It's pretty lazy putting it here.\nfloat gSc = 0.;\n\n\n// The wall and floor pattern, which is just something quick and effective.\n// It's an offset row square grid pattern with some random subdivision.\nvec4 distField(vec2 p, float sc){\n    \n   \n    vec2 q = p;\n    // Partitioning into cells and providing the local cell ID\n    // and local coordinates.\n    // Offset alternate rows: I've left this out of the options, but it's \n    // possible to render some Truchet patterns on offset grids, which can \n    // produce interesting results.\n    //if(mod(floor(p.y/sc), 2.)<.5) p.x += sc/2.;\n    // Cell ID and local coordinates.\n    vec2 ip = floor(p/sc);\n    p -= (ip + .5)*sc;\n    \n    for(int i = 0; i<2; i++){\n        // Random subdivision -- One big cell becomes four smaller ones.\n        if(hash21(ip + float(i + 1)*.007)<.5){//(1./float(i + 2))\n            sc /= 2.; // Cut the scale in half.\n            p = q;\n            // New cell ID and local coordinates.\n            ip = floor(p/sc);\n            p -= (ip + .5)*sc;\n\n        }\n    }\n    \n    // Global scale copy.\n    gSc = sc;\n    \n    // Returning the local coordinates and local cell ID. Note that the \n    // distance has been rescaled by the scaling factor.\n    return vec4(p, ip);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Smoothing factor.\n    float sf = 1.5/iResolution.y;\n    \n    // Canvas coordinates with translation.\n    vec2 p = uv + vec2(1, .5)*iTime/16.;\n    \n    // Scene field calculations.\n \n     \n    // Randomly subdivided grid object.\n    float sc = iResolution.y>360.01? 1./4. : 1./4.*450./360.; // Canvas size scaling.\n    vec4 d4 = distField(p, sc);\n    //\n    // Grid cell's local coordinates and unique ID.\n    vec2 q = d4.xy;\n    vec2 iq = d4.zw;\n    \n    // Randomly rotating the square cell's local coordinates.\n    float rnd = hash21(iq*gSc + .23);\n    q = rot2(floor(rnd*36.)*6.2831/4.)*q;\n    \n    // Lighting.\n    vec2 ld = normalize(vec2(1, -2));\n    ld = rot2(floor(rnd*36.)*6.2831/4.)*ld; // Random rotation to match.\n   \n    // Grid cell square -- Used to show the grid cell outlines.\n    float bord = max(abs(q.x),abs(q.y)) -  gSc/2.; \n    \n    \n    // Concentric circle line number for the larger cells. Factors of\n    // four will work. For more subdivisions, larger factors of four\n    // are required.\n    const float lNum = 2.*4.; \n    float lW = sc/lNum; // Concentric line width.\n    float ew = lW/5.; // Edge width.\n\n    \n    // Truchet circle distances from each diagonal.\n    vec2 tr = vec2(length(q - gSc/2.), length(q + gSc/2.));\n    // Offset reading for highlighting purposes.\n    vec2 tr2 = vec2(length(q - gSc/2. - ld*.002), length(q + gSc/2. - ld*.002));\n    \n  \n    vec2 ln = abs(mod(tr, lW) - .5*lW) - .25*lW - ew/2.;\n    vec2 ln2 = abs(mod(tr2, lW) - .5*lW) - .25*lW - ew/2.;\n    \n    // Highlighting or bump factor.\n    vec2 b = max(smoothstep(0., .1, ln2 - ln), 0.)/.002;\n    b *= b*4.5; // Tweaking.\n    \n    // Truchet arcs from the mid edges.\n    //tr = abs(tr - gSc/2.) - gScx/2. + lW/4. - ew/2.;\n    // Truchet circles centered on the diagonals of side length radius. \n    tr = tr - gSc + lW/4. - ew/2.;\n    // Offset reading for highlighting purposes.\n    tr2 = tr2 - gSc + lW/4. - ew/2.;\n   \n    // Background stripe color.\n    #if COLORB == 0\n    vec3 lnColB = vec3(.1); // Black.\n    #else\n    vec3 lnColB = vec3(1); // White.\n    #endif\n    \n    // Rendering onto the background.\n    //float pat = dot(sin(uv*4. - cos(uv.yx*8.)), vec2(.15)) + .5;\n    // Fake height highlighting pattern. There's an accurate way to represent height,\n    // (angles to edges, etc) and this isn't it, but this is will do for now.\n    float pat = .8 - smoothstep(.0, 1., length(q)/(gSc/2.))*.5;\n    #if COLOR == 0\n    vec3 lnCol = mix(vec3(.65, .2, .06), vec3(1, .45, .2), pat); // Gold.\n    #elif COLOR == 1\n    vec3 lnCol = mix(vec3(.6, .3, .9), vec3(1, .1, .3), pat); // Pink.\n    #elif COLOR == 2\n    vec3 lnCol = mix(vec3(.25, .6, .1), vec3(.15, .4, .5), pat); // Green.\n    #else\n    vec3 lnCol = mix(vec3(.3), vec3(.45, .55, .7), pat); // Siver.\n    #endif   \n    \n    // Scene color -- Set to the background.\n    vec3 col = lnColB;\n \n    // Rendering the two overlapping diagonally centered Truchet circles.\n    for(int i = 0; i<2; i++){\n        // Putting the concentric lines onto the arc.\n        vec3 tCol = mix(lnColB, vec3(0), 1. - smoothstep(0., sf, ln[i])); \n        tCol = mix(tCol, lnCol, 1. - smoothstep(0., sf, ln[i] + ew)); \n        \n        // The arc itself; Drop shadow followed by coloring.\n        col = mix(col, vec3(0), (1. - smoothstep(0., sf*iResolution.y/450., tr2[i]))*.9);\n        col = mix(col, tCol*(.7 + b[i]), 1. - smoothstep(0., sf, tr[i] + ew/5.));\n \n    }\n    \n    #ifdef SHOW_GRID\n    // Show the grid.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*4., abs(bord) - .005))*.5);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(bord) - .005));\n    col = mix(col, vec3(1), 1. - smoothstep(0., sf, abs(bord) - .0005));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2610, 2643, 2665, 2665, 2723], [2726, 2754, 2775, 2775, 2838], [2912, 3060, 3093, 3093, 4111], [4114, 4114, 4170, 4205, 8048]], "test": "untested"}
{"id": "NdVfzW", "name": "Meta Mecha Tech", "author": "leon", "description": "mechanical metamorphoses with the color strips a la Chris Foss", "tags": ["abstract", "tech", "mecha", "foss"], "likes": 21, "viewed": 386, "published": 3, "date": "1657786515", "time_retrieved": "2024-07-30T16:40:30.719202", "image_code": "\n// Meta Mecha Tech\n// mechanical metamorphoses\n// with the color strips a la Chris Foss \n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat rng, material;\nvec3 coord;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    float t = 206.+iTime*.1;\n    float anim = fract(t);\n    float index = floor(t);\n    float signal = rng*sin(iTime*100.)*pow(anim,40.)*.1;\n    t = pow(anim,0.1)+index+signal;\n    float a = 1.;\n    vec3 e = vec3(.01,0.05,0.02);\n    const float count = 5.;\n    for (float i = 0.; i < count; ++i) {\n        \n        p.xz = abs(p.xz)-.15*a;\n        p.xz *= rot(t/a+i);\n        p.yz *= rot(t/a+i);\n        p = p - clamp(p, -e*a, e*a);\n        dist = min(dist, length(p.xy)-.01*a);\n        a /= 1.5;\n    }\n    \n    coord = p;\n    \n    shape = max((dist - .002), p.z+.005);\n    material = shape < dist ? 1. : 0.;\n    dist = min(dist, shape);\n    \n    return dist;\n}\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in vec2 uv, in float shade)\n{\n    // Inigo Quilez color palette\n    // https://iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 tint = .5+.5*cos(vec3(0,.3,.6)*6.283+iTime*.2+uv.y*2.);\n    vec3 rf = reflect(ray, normal);\n    \n    if (material == 0.)\n    {\n        float top = dot(rf, vec3(0,1,0))*.5+.5;\n        float glow = dot(normal, ray)*.5+.5;\n        color = vec3(0.9) * pow(dot(normal, -normalize(pos))*.5+.5, 0.5);\n        color += vec3(.5)*clamp(top,0.,1.);\n        color += tint*glow;\n        color *= shade;\n    }\n    else\n    {\n        float top = dot(rf, vec3(0,1,0))*.5+.5;\n        float front = dot(normal, vec3(0,0,1))*.5+.5;\n        color = tint;\n        color *= smoothstep(.01,.0,sin(coord.z*200.));\n        color += vec3(.5)*top;\n        color += vec3(.2)*clamp(top,0.,1.);\n        color *= shade*front;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(.2)*smoothstep(2.,.5,length(uv));\n    material = 0.;\n    \n    // coordinates\n    vec3 pos = vec3(0,0,1.2);\n    vec3 at = vec3(0);\n    pos.xz *= rot(cos(iTime*.1)*.2);\n    pos.zy *= rot(sin(iTime*.2)*.1);\n    vec3 ray = lookAt(pos, at, uv, 1.);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    rng = white.x;\n    \n    // start ahead\n    pos += ray * white.z * .2;\n    \n    // blur edges\n    float dof = .2*smoothstep(.5, 2., length(uv));\n    ray.xy += vec2(cos(blue.x*6.28),sin(blue.x*6.28))*white.z*dof;\n    \n    // raymarch\n    float maxDist = 8.;\n    const float count = 50.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*blue.z;\n        ray += white * total*.01;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        // NuSan\n        // https://www.shadertoy.com/view/3sBGzV\n        vec2 noff = vec2(.001,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n        coloring(color, pos, normal, ray, uv, shade);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[91, 167, 224, 224, 306]], "test": "untested"}
{"id": "fsKfzW", "name": "Silky Storm", "author": "leon", "description": "Shader suave", "tags": ["cloud", "abstract", "gyroid"], "likes": 16, "viewed": 443, "published": 3, "date": "1657758353", "time_retrieved": "2024-07-30T16:40:31.491138", "image_code": "\n// Silky Storm\n// gyroidisticly tunneled\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// fractal brownian motion\n// https://thebookofshaders.com/13/\nfloat fbm (vec3 p)\n{\n    float result = 0.;\n    float a = .5;\n    for (float i = 0.; i < 4.; ++i) {\n        result += sin(gyroid(p/a)*3.14+.1*iTime/a)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    // tunnel\n    float dist = max(0., -length(p.xy)+.5);\n    \n    // displace with gyroid noise\n    float t = iTime * .1;\n    vec3 s = p * 1.;\n    s.z -= t;\n    float noise = fbm(s);\n    dist -= .1*noise;\n    \n    // filaments\n    dist = min(dist, abs(noise)+max(0.,-p.z)*.003);\n    \n    return dist;\n}\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in vec2 uv, in float shade)\n{\n    // Inigo Quilez color palette\n    // https://iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 tint = .5+.5*cos(vec3(0,.3,.6)*6.283+iTime*.2+uv.y*2.);\n\n    // lighting\n    vec3 rf = reflect(ray, normal);\n    float top = dot(rf, vec3(0,1,0))*.5+.5;\n    float glow = dot(normal, ray)*.5+.5;\n    color = vec3(0.5) * pow(dot(normal, -normalize(pos))*.5+.5, 0.5);\n    color += vec3(.2)*clamp(top,0.,1.);\n    color += tint*glow;\n    color *= pow(shade,.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0);\n    \n    // coordinates\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 pos = vec3(0,0,1);\n    vec3 at = vec3(0);\n    pos.xz *= rot(cos(iTime*.1)*.2);\n    pos.zy *= rot(sin(iTime*.2)*.1);\n    vec3 ray = lookAt(pos, at, uv, 1.);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    \n    // start ahead\n    pos += ray * white.z * .2;\n    \n    // blur edges\n    float dof = .2*smoothstep(.5, 2., length(uv));\n    ray.xy += vec2(cos(blue.x*6.28),sin(blue.x*6.28))*blue.z*dof;\n    \n    // raymarch\n    float maxDist = 8.;\n    const float count = 50.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*blue.z;\n        ray += white * total*.002;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        // NuSan\n        // https://www.shadertoy.com/view/3sBGzV\n        vec2 noff = vec2(.01,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n        coloring(color, pos, normal, ray, uv, shade);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\nfloat gyroid (vec3 s)\n{\n    return dot(sin(s),cos(s.yzx));\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 119, 176, 176, 258]], "test": "untested"}
{"id": "NdKfRW", "name": "Newton's method fractal", "author": "sh1boot", "description": "Quick and dirty implementation of the 3Blue1Brown fractal described here: https://youtu.be/-RdOwhmqP5s\n\nUse mouse to grab and move roots (the little black rings).", "tags": ["fractal", "newton", "3b1b"], "likes": 0, "viewed": 259, "published": 3, "date": "1657746106", "time_retrieved": "2024-07-30T16:40:32.255096", "image_code": "vec4 getParam(int p) {\n    return texelFetch(iChannel0, ivec2(p, 0), 0);\n}\n\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y,\n                a.x * b.y + a.y * b.x);\n}\n\nvec2 cdiv(vec2 a, vec2 b) {\n    float s = 1.0 / length(b);\n    b.y = -b.y;\n    return cmul(a * s, b * s);\n}\n\nvec2 term(vec2 x, int n) {\n    vec2 r = getParam(n).rg;\n    return x - r;\n}\n\nvec2 f(vec2 x) {\n    vec2 fx = vec2(1.0, 0.0);\n    for (int i = 0; i < nroots; ++i) {\n        fx = cmul(fx, term(x, i));\n    }\n    return fx;\n}\n\nvec2 df(vec2 x) {\n    vec2 right[nroots];\n    right[nroots - 1] = vec2(1.0, 0.0);\n    for (int i = nroots - 1; i > 0; --i) {\n        right[i - 1] = cmul(right[i], term(x, i));\n    }\n    vec2 dfx = vec2(0.0);\n    vec2 left = vec2(1.0, 0.0);\n    for (int i = 0; i < nroots; ++i) {\n        dfx += cmul(left, right[i]);\n        left = cmul(left, term(x, i));\n    }\n    return dfx;\n}\n\n\nint find_nearest(vec2 uv) {\n    int nearest = 0;\n    for (int i = 1; i < nroots; ++i) {\n        if (length(term(uv, i)) < length(term(uv, nearest))) {\n            nearest = i;\n        }\n    }\n    return nearest;\n}\n\nvec3 add_roots(vec3 col, vec2 uv) {\n    // TODO: figure out proper pixel-size-aware smoothstep params.\n    for (int i = 0; i < nroots; ++i) {\n        float r = abs(0.02 - length(term(uv, i)));\n        col = mix(vec3(0.0), col, smoothstep(0.0, 0.01, r));\n    }\n    return col;\n}\n\nvec3 add_grid(vec3 col, vec2 uv) {\n    uv = fract(uv) * 5.0;\n    float h = (1.0 - smoothstep(0.0, 0.05, abs(uv.y - round(uv.y))));\n    float v = (1.0 - smoothstep(0.0, 0.05, abs(uv.x - round(uv.x))));\n    h *= uv.y < 0.5 || uv.y > 4.5 ? 0.75 : 0.25;\n    v *= uv.x < 0.5 || uv.x > 4.5 ? 0.75 : 0.25;\n    \n    col = mix(col, vec3(1.0), max(h, v));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if 0\n    vec2 mid = iResolution.xy * 0.5;\n    vec2 s = 2.0 / mid.xx;\n    vec2 uv = (fragCoord - mid) * s;\n#else\n    vec2 uv = fragToPlane(fragCoord, getParam(P_RESCALE));\n#endif\n    vec2 uv0 = uv;\n\n\n    for (int i = 0; i < max_iter; ++i) {\n        uv -= cdiv(f(uv), df(uv));\n    }\n\n\n    int nearest = find_nearest(uv);\n    vec3 col = palette[nearest % palette.length()];\n\n    col = add_grid(col, uv0);\n    col = add_roots(col, uv0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvec4 getParam(int p) {\n    return texelFetch(iChannel0, ivec2(p, 0), 0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec4 outData = vec4(0.0);\n    vec4 m = iMouse;\n    bool down = m.z > 0.0;\n    bool click = m.w > 0.0;\n    m = fragToPlane(abs(m), getParam(P_RESCALE));\n\n    int root = int(fragCoord.x);\n    if (root < nroots) {\n        outData.xy = getParam(root).xy;\n        if (iFrame < 1) {\n            outData.xy = roots[root];\n        }\n        if (down && !click) {\n            int grabbed = int(getParam(P_GRABBED).r * float(nroots));\n            if (root == grabbed) {\n                outData.xy = m.xy;\n            }\n        }\n    } else {\n        if (root == P_GRABBED) {\n            int grabbed = int(getParam(P_GRABBED).r * float(nroots));\n            if (click) {\n                grabbed = 0;\n                float d = distance(getParam(0).xy, m.xy);\n                for (int i = 1; i < nroots; ++i) {\n                    float dd = distance(getParam(i).xy, m.xy);\n                    if (dd < d) {\n                        grabbed = i;\n                        d = dd;\n                    }\n                }\n            }\n            outData.x = (float(grabbed) + 0.5) / float(nroots);\n        } else if (root == P_RESCALE) {\n            outData = getParam(P_RESCALE);\n//            if (iFrame < 1) {\n                outData = vec4(iResolution.xy * 0.5,\n                               vec2(6.2) / iResolution.xx);\n//            }\n        }\n    }\n\n    fragColor = outData;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 roots[] = vec2[](\n    vec2( 0.00, 1.00),\n    vec2( 0.00,-1.00),\n    vec2( 0.66,-0.52),\n    vec2( 0.66, 0.52),\n    vec2(-1.32, 0.00)\n#if 0\n    ,vec2( 1.20, 1.20)\n    ,vec2(-1.20, 1.20)\n    ,vec2( 1.20,-1.20)\n    ,vec2(-1.20,-1.20)\n#endif\n);\n\nconst int nroots = roots.length();\nconst int P_GRABBED = nroots + 0;\nconst int P_RESCALE = nroots + 1;\n\nconst int max_iter = 6;\n\nvec3 palette[] = vec3[](\n    vec3(.1, .7, .7),\n    vec3(.3, .7, .3),\n    vec3(.3, .3, .6),\n    vec3(.4, .2, .4),\n    vec3(.5, .7, 1.),\n    vec3(.2, .8, .7),\n    vec3(.1, .8, .3),\n    vec3(.4, .4, .8),\n    vec3(.2, .2, .5),\n    vec3(.1, .5, 1.)\n);\n\n\n\nvec2 fragToPlane(vec2 fc, vec4 scale)\n{\n    return (fc - scale.xy) * scale.zw;\n}\n\nvec4 fragToPlane(vec4 mc, vec4 scale)\n{\n    return (mc - scale.xyxy) * scale.zwzw;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKfRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 74], [76, 76, 103, 103, 184], [186, 186, 213, 213, 293], [295, 295, 321, 321, 370], [372, 372, 388, 388, 515], [517, 517, 534, 534, 895], [898, 898, 925, 925, 1111], [1113, 1113, 1148, 1215, 1390], [1392, 1392, 1426, 1426, 1755], [1757, 1757, 1814, 1814, 2282]], "test": "untested"}
{"id": "7dGfzD", "name": "Sonic Heartbeat", "author": "RaduBT", "description": "relaxing Heartbeat  1 hour\n\nCreated by WillKirkby in 2018-03-04\nEdited via https://www.shadertoy.com/view/4dcyD2#", "tags": ["sound", "heartbeat", "soundcloud"], "likes": 8, "viewed": 355, "published": 3, "date": "1657740374", "time_retrieved": "2024-07-30T16:40:33.019053", "image_code": "//// Edited via https://www.shadertoy.com/view/4dcyD2#\n//// Created by WillKirkby in 2018-03-04\n////\n/// Added heartbeat sound\n\n\n\nfloat circle(vec2 p, float r){\n\treturn r-length(p);\n}\n\nfloat scene(vec2 p){\n    vec2 p1=p;\n    if(abs(p.x)<.85&&abs(p.y)<.35)\n    \tp1=mod(p+.05,.1)-.05;\n    \n    //p-=mod(p+.05,.1)-.05;\n    float r = texture(iChannel0, vec2(length(p)*.15,0)).r;\n    return circle(p1,.06*r*r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst float cinematicAspect = 2.35;\n\tfloat currAspect = iResolution.x/iResolution.y;\n    \n    vec2 uv = fragCoord/iResolution.xy-.5;\n    uv.x *= currAspect;\n    \n    float d = scene(uv);\n    \n    fragColor = 1.-clamp(vec4(d*iResolution.y*.5),0.,1.);\n    fragColor.rgb = mix(\n    \tvec3(11,231,184)/255.,\n        vec3(30,57,77)/255.,\n        fragColor.rgb\n    );\n    \n    if (abs(uv.y) > .5*(currAspect/cinematicAspect))\n    {\n\t\tfragColor *= 0.;\n\t}\n    else\n    {\n\t\tfragColor = fragColor * (length(uv)*-.5+1.) + texture(iChannel3,fragCoord/256.)*.004;\n\t\t//                      ^ vignette           ^ noise to hide banding\n\t}\n}", "image_inputs": [{"id": 29321, "src": "https://soundcloud.com/radubt/my-heartbeat-sound-white-noise-1-hour", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 160, 160, 183], [185, 185, 205, 205, 407], [409, 409, 466, 466, 1093]], "test": "untested"}
{"id": "7dGBzD", "name": "Trippy effect - grayscale", "author": "mvaios", "description": "Trippy effect", "tags": ["grayscale"], "likes": 5, "viewed": 227, "published": 3, "date": "1657736964", "time_retrieved": "2024-07-30T16:40:33.802958", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n  \n    uv *= 3.0;\n    vec2 gv = fract(uv) - 0.5;\n    vec3 col = vec3(gv.xy, 1.);\n\n    float m = 0.;\n    float t = iTime/2.;\n\n    \n    float dist = length(uv * 4.);\n    for(int x = -2; x<=2;x++) {\n        for(int y = -2; y<=2;y++) {\n            vec2 offset = vec2(x, y); \n            float d = length(gv-offset*0.7)*1.75;\n            float tNorm = sin(dist-t) * .5 + 0.5;\n            float r = mix(0.35, 1.8, tNorm);\n\n            m += smoothstep(r*1.0001, r, d);\n        }\n    }\n    \n    col.x = mod(m/1., 1.1);\n    col.y = mod(m/1.1, 1.3);\n    col.z = mod(m/1.3, 1.4);\n    \n    float l = (col.x + col.y + col.z) / 3.0;\n    fragColor = vec4(l, l, l, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 778]], "test": "untested"}
{"id": "7syBRD", "name": "007 - Bouncing ball color mix", "author": "PiGIon", "description": "I had to study how to make a color mix and implement in my code.\n\nI noticed that I must use a vec4 with alpha for these type of calculations, now, the ball has correct color and the square drawing is correct.", "tags": ["mix", "beginner", "color", "square", "ball", "learning", "colormix", "mixnormal"], "likes": 0, "viewed": 196, "published": 3, "date": "1657733900", "time_retrieved": "2024-07-30T16:40:34.609800", "image_code": "// 2022.07.13\n// 2022.08.14 - removal of blend normal function, replaced by mix\n\n#define PI 3.14159265\n\n// matrix functions\nmat2 rot2D(float ang);\n\n// time cycling functions\nfloat cycle(float perSecond);\nfloat rangeCycle(float size, float perSec);\n\n// shape functions\nfloat circle(vec2 uv, vec2 origin, float size);\nfloat square(vec2 uv, vec2 origin, float size, float ang);\n\n// color blending functions\nvec4 blendNormal(vec4 base, vec4 blend);\n\n// returns a back and forth 0.0 to 1.0 per second\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n// returns alpha value of a circle with antiAlias\nfloat circle(vec2 uv, vec2 origin, float size) {\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n\n    return smoothstep(size + antiAlias, size - antiAlias, length(uv - origin));\n}\n\n// returns alpha value of a square with antiAlias\nfloat square(vec2 uv, vec2 origin, float size, float ang) {\n    vec2 o = (uv - origin) * rot2D(ang);\n    float antiAlias = 1.5/iResolution.y;\n    \n    vec2 range = vec2(size + antiAlias, size - antiAlias);\n    \n    return smoothstep(range.x, range.y, abs(o.x)) * smoothstep(range.x, range.y, abs(o.y));\n}\n\n// matrix rot2D based on pi\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec4 O = fragColor;\n\n    float shapeSize = 0.1 + cycle(0.3999) * 0.4;\n    vec2 shapeOrigin = vec2(rangeCycle(5., -1.88), 0.);\n\n    float c = cycle(1.);\n    // range from bottom of screen to top of screen, determined by the shape size\n    shapeOrigin.y = shapeSize - 1. + (1. - shapeSize)*(2. * c);\n    \n    vec4 bg = vec4(0., 0., 0.14, 1.);\n    vec4 cColor = vec4(0.89, 0., 0., circle(uv, shapeOrigin, shapeSize));\n\n    // I need to discover the size of the section of the circle, here, I use pythagorean theorem to do it\n    vec4 sColor = vec4(0, 0.87, 0., \n            square(uv, shapeOrigin, sqrt((pow(shapeSize/2., 2.) + pow(shapeSize/2., 2.))), rangeCycle(PI, -1.33)));\n    \n\n    O = mix(bg, cColor, cColor.w);\n    O = mix(O, sColor, sColor.w);\n    \n    fragColor = O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[446, 496, 526, 526, 871], [873, 923, 971, 971, 1138], [1140, 1190, 1249, 1249, 1494], [1496, 1524, 1547, 1547, 1607], [1609, 1640, 1684, 1684, 1739], [1741, 1741, 1798, 1798, 2643]], "test": "untested"}
{"id": "7dyfzW", "name": "FFT procedural pseudo-bluenoise", "author": "FabriceNeyret2", "description": "Power spectrum of procedural pseudo-bluenoise  https://www.shadertoy.com/view/7sGBzW\nred: radial average.", "tags": ["fft", "hash", "fourier", "bluenoise", "dft", "phase"], "likes": 14, "viewed": 590, "published": 3, "date": "1657730949", "time_retrieved": "2024-07-30T16:40:35.366776", "image_code": "// using part of \"Fourier Workflow 2 / phases info\" by FabriceNeyret2. https://shadertoy.com/view/XtScWt\n// to show the Power spectrum of procedural pseudo-bluenoise  https://www.shadertoy.com/view/7sGBzW\n\n#define SIZE (2.*floor(iResolution.x/4.*.8)) // 256. //Size must be changed in each tab.\n\n\n//Display modes\n#define MAGNITUDE 0.\n#define PHASE     1.\n#define COMPONENT 2.\n#define REAL      3.\n#define IMAG      4.\n\n//Scaling\n#define LOG 0\n#define LINEAR 1\n\n#define MAG_SCALE LOG\n\nvec4 rainbow(float x)  { return .5 + .5 * cos(6.2832*(x - vec4(0,1,2,0)/3.)); }\nvec4 rainbow(vec2 C)   { return rainbow(atan(C.y,C.x)/3.1416 + .5); }\n\nvec4 paintDFT(vec2 F, float mode) {\n    // F /= SIZE;\n    return \n         mode == MAGNITUDE \n     #if   MAG_SCALE == LOG\n                           ?  vec4(log(length(F)))\n     #elif MAG_SCALE == LINEAR\n                           ?  vec4(length(F))\n     #endif\n       : mode == PHASE     ?  rainbow(F)        \n       : mode == COMPONENT ?  .5+.5*vec4(F, 0,0)\n       : mode == REAL      ?  .5+.5*vec4(F.x)\n       : mode == IMAG      ?  .5+.5*vec4(F.y)\n       : vec4(-1); // error\n}\n\nvoid mainImage( out vec4 O,  vec2 uv )\n{\n    vec2 R = iResolution.xy, U=uv;\n     \n    vec2 pixel = ( uv - iResolution.xy/2.) / SIZE  + vec2(2,1)/2.,\n         tile  = floor(pixel),\n         stile = floor(mod(2.*pixel,2.));\n         uv = fract(pixel) * SIZE / R ;\n\n    O-=O;\n    \n    if(tile == vec2(0,0))                                             // --- Input (Left)\n        O += texture(iChannel0, uv).x;                                // initial texture\n\n    if(tile == vec2(1,0))                                             // ---DFT (Right)\n        O += .2*paintDFT(texture(iChannel1, uv).xy, MAGNITUDE),\n        uv = fract(pixel),                                            // radial average of power spectrum\n        O = mix(O,vec4(1,0,0,0), smoothstep(3./SIZE,0.,abs(uv.y-2./SIZE*texelFetch(iChannel2,ivec2(abs(uv.x*2.-1.)*SIZE,0),0).x)) );\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// source signal\n\n#define SIZE (2.*floor(iResolution.x/4.*.8)) // 256. //Size must be changed in each tab.\n\n\n#define H(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n#define blue(p) (  \\\n          (  H(p+vec2(-1,-1)) + H(p+vec2(0,-1)) + H(p+vec2(1,-1))  \\\n           + H(p+vec2(-1, 0)) - 8.* H( p )      + H(p+vec2(1, 0))  \\\n           + H(p+vec2(-1, 1)) + H(p+vec2(0, 1)) + H(p+vec2(1, 1))  \\\n          ) *.5/9. *2.1 +.5 )\n          \n          \nvoid mainImage( out vec4 O, vec2 U )\n{\n    float v = blue(U+float(iFrame));   // pseudo-blue noise\n // v = v < 0. ? -v : v > 1. ? 2.-v : v;   // folding values out of [0,1] (better histogram, visually still blue, spectrum less blue)\n // v = fract(v);                          // wrapping values out of [0,1] (no longer blue)\n    O.x = v;\n    \n // O.x = H(U+float(iFrame));              // white noise\n // O.x = texture( iChannel0, U/SIZE ).x;  // Britney noise\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fourier transform of the input\n\n// Horizontal + Vertical Discrete Fourier Transform of the input \n// 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n// ( adapted from  Flyguy's https://www.shadertoy.com/view/MscGWS# )\n\n\n#define SIZE (2.*floor(iResolution.x/4.*.8)) // 256. //Size must be changed in each tab.\n\n//#define tex(ch,x,y) texture(ch, vec2(x,y)/iResolution.xy )\n#define tex(ch,x,y)  texelFetch(ch, ivec2(x,y), 0)\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n// #define ang(a)  vec2(cos(a), sin(a))\n// vec2 cmul (vec2 a,float t) { vec2 b=ang(t); return mat2(b,-b.y,b.x)*a; } \n\nvoid mainImage( out vec4 O, vec2 uv )\n{\n    O-=O; \n    \n    if(uv.x > SIZE || uv.y > SIZE) return;\n        \n    for(float n = 0.; n < SIZE; n++)  {\n        vec2 xn = tex(iChannel0, n+.5, uv.y).xy,\n             yn = tex(iChannel1, uv.x, n+.5).zw,\n             a = - 6.2831853 * (uv-.5 -SIZE/2.) * n/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// polar average of the power spectrum\n\n#define SIZE (2.*floor(iResolution.x/4.*.8)) // 256. //Size must be changed in each tab.\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O; \n    \n    if(U.x > SIZE || U.y > 1.) return;\n    \n    float s = 0., d = U.x/2., n=0.;\n    for( float a = 0.; a < 6.283; a+=.01, n++ )\n        s += length( texelFetch(iChannel0,ivec2(SIZE/2. + d*vec2(cos(a),sin(a))),0).xy );\n    O.x = s / n;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dyfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[484, 484, 508, 508, 563], [564, 564, 588, 588, 633], [1118, 1118, 1158, 1158, 1973]], "test": "untested"}
{"id": "7sGfzW", "name": "motionblur existing shaders 2blu", "author": "FabriceNeyret2", "description": "pseudo-bluenoise variant of https://shadertoy.com/view/NsGfzz\n\nNB: spacetime sampling less blue than just time.", "tags": ["motionblur", "antialiasing", "sampling", "bluenoise", "tuto"], "likes": 15, "viewed": 513, "published": 3, "date": "1657730165", "time_retrieved": "2024-07-30T16:40:36.120760", "image_code": "// pseudo-bluenoise variant of https://shadertoy.com/view/NsGfzz\n\n// combines simple dither-motionblur existing shaders https://www.shadertoy.com/view/7dGfzW\n// with antialias existing shader https://www.shadertoy.com/view/NdyfRz\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )  // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = ( 2.*u - R ) / R.y;\n    \n    float t = iTime;\n    O-=O;\n    for(float i=0.; i<1.; i+=.1) {                                // --- drawing balls\n       t *= 1.2;\n       P = vec2( 1.2*cos(2.*t), .8*sin(3.1*t) );     \n       O += smoothstep(3./R.y, 0., length(P-U) - .15 ) * hue(i);\n   }\n}\n", "image_inputs": [], "common_code": "// pseudo-bluenoise from https://www.shadertoy.com/view/7sGBzW\n\n\n#define iTime ( iTime + blue(gl_FragCoord.xy+float(_k)*1.7)* iTimeDelta )\n\n#define H(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n#define blue(p) (  \\\n          (  H(p+vec2(-1,-1)) + H(p+vec2(0,-1)) + H(p+vec2(1,-1))  \\\n           + H(p+vec2(-1, 0)) - 8.* H( p )      + H(p+vec2(1, 0))  \\\n           + H(p+vec2(-1, 1)) + H(p+vec2(0, 1)) + H(p+vec2(1, 1))  \\\n          ) *.5/9. *2.1 +.5 )\n\n\nint _N = 5, _k;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (_k=0; _k < _N*_N; _k++ )                        \\\n   /* { mainImage0(o,U); O += o; }   /* basic. Below: combined with AA */ \\\n      { mainImage0(o,U+vec2(_k%_N-_N/2,_k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[339, 339, 377, 377, 710]], "test": "untested"}
{"id": "7dGfzW", "name": "blue motionblur existing shaders", "author": "FabriceNeyret2", "description": "Just add this Common to motion blur any shader (simple dithering with procedural white noise. bluenoise would be better but requires setting a texture. ).\n\nPseudo-bluenoise variant", "tags": ["motionblur", "sampling", "bluenoise", "tuto"], "likes": 9, "viewed": 332, "published": 3, "date": "1657729427", "time_retrieved": "2024-07-30T16:40:36.871752", "image_code": "// pseudo-bluenoise variant of https://shadertoy.com/view/NdGfzz\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )  // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = ( 2.*u - R ) / R.y;\n    \n    float t = iTime;\n    O-=O;\n    for(float i=0.; i<1.; i+=.1) {                                // --- drawing balls\n       t *= 1.2;\n       P = vec2( 1.2*cos(2.*t), .8*sin(3.1*t) );     \n       O += smoothstep(3./R.y, 0., length(P-U) - .15 ) * hue(i);\n   }\n}", "image_inputs": [], "common_code": "// pseudo-bluenoise from https://www.shadertoy.com/view/7sGBzW\n\n#define iTime ( iTime + blue(gl_FragCoord.xy)* iTimeDelta )\n\n#define H(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n#define blue(p) (  \\\n          (  H(p+vec2(-1,-1)) + H(p+vec2(0,-1)) + H(p+vec2(1,-1))  \\\n           + H(p+vec2(-1, 0)) - 8.* H( p )      + H(p+vec2(1, 0))  \\\n           + H(p+vec2(-1, 1)) + H(p+vec2(0, 1)) + H(p+vec2(1, 1))  \\\n          ) *.5/9. *2.1 +.5 )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 212, 212, 545]], "test": "untested"}
{"id": "7syBzW", "name": "Star PSF - JWST mod", "author": "starea", "description": "TAB: 1 vs many. \n      if 1: col=BlackBody(T) vs RGB ( SPACE: mouse.xy = rGB/RGb )\n\nstar proj = fraction of sensor pixel.\nBut lens+aperture diffraction yields Airy spot + cross (diffract on 2ndary mirror handles). \nAnd bright stars saturate filters.", "tags": ["astrophysics", "optics", "blackbody", "fourier", "planck", "psf"], "likes": 5, "viewed": 513, "published": 3, "date": "1657728976", "time_retrieved": "2024-07-30T16:40:37.627731", "image_code": "// Fork of \"Star PSF\" by FabriceNeyret2. https://shadertoy.com/view/XdsGWs\n// Adding a mod to simulate https://www.space.com/james-webb-space-telescope-alignment-photo\n// by Ruofei Du (ruofeidu.com), most credits owe to Dr. Neyret :)\n// \n// 2022-07-13\n\n// #### realistic display of star in Hubble images ################\n//                            Fabrice NEYRET 15 oct 2013\n// toggles:\n//    T:      tune (R)GB  vs   Planck spectrum(T)\n//    SPACE:  tune 1GB  vs RG1\n\n// see also https://www.shadertoy.com/view/Xty3zc\n//          https://www.shadertoy.com/view/tlc3zM\n\n\n#define NB_STARS 200\n#define PERS 1          // perspective\n\n#define SCALE 40.\nconst float star_luminosity = 1e3;\nvec3 star_color = vec3(1.,.3,.1)*star_luminosity;\n#define PI 3.1415927\nvec2 FragCoord, R;\n\n//--- filter integration (l0..l1) on black body spectrum(T) ---------\nfloat F(float x) \n{ return (6.+x*(6.+x*(3.+x)))*exp(-x); }\nfloat IntPlanck(float T,float lambda1,float lambda0) \n{\n\tconst float A=1.1, B=1./1.05;\n\tfloat C0 = 0.014387770, C=C0/(B*T);\n\tT = 1.; // normalised spectrum better for display :-)\n\treturn 100.*A/B*pow(100.*T/C0,4.)*( F(C/lambda1) - F(C/lambda0) );\n}\n\n// --- Planck black body color I.spectrum(Temp) -----------------------\nvec3 Planck(float T) {\n\treturn vec3(\n\t\tIntPlanck(T,.7e-6,.55e-6),   // red filter\n        IntPlanck(T,.55e-6,.49e-6),  // green filter\n        IntPlanck(T,.49e-6,.4e-6)    // blue filter\n\t\t)*1e-14;\n}\n\n//--- draw one star:  (I.filter(color)).dirac * PSF ------------------ \nvec3 draw_star(vec2 pos, float I) {\n\t// star out of screen\n    const float margin = .2;\n\tif (pos!=clamp(pos,vec2(-margin),R/R.y+margin)) return vec3(0.);\n\t\n\tpos -= FragCoord.xy/iResolution.y; \n\t\n// Airy spot = (2BesselJ(1,x)/x)^2 ~ cos^2(x-2Pi/4)/x^3 for x>>1\n// pixels >> fringes -> smoothed Airy ~ 1/x^3\n\tfloat d = length(pos)*SCALE;\n    const float ll = 0.3;\n\t\n\tvec3 col, spectrum = I*star_color;\n#if 1\n\tcol = spectrum/(d*d*d);\n#else\n\tcol = spectrum*(1.+.323*cos(d/4.+PI/2.))/(d*d*d);\n#endif\n\t\n// 2ndary mirror handles signature (assuming handles are long ellipses)\n\td = length(pos*vec2(50.,.5)*ll)*SCALE;\n\tcol += spectrum/(d*d*d);\n    \n    d = length(pos*vec2(.5,50.))*SCALE;\n\tcol += spectrum/(d*d*d);\n\n    float angle = 0.6;\n\tmat2 rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\td = length(rotationMatrix*pos*vec2(.5,50.)*ll)*SCALE;\n\tcol += spectrum/(d*d*d);\n    \n     angle = -0.6;\n     rotationMatrix = mat2(cos(angle), -sin(angle),\n                               sin(angle),  cos(angle));\t\n\n\td = length(rotationMatrix*pos*vec2(.5,50.)*ll)*SCALE;\n\tcol += spectrum/(d*d*d);\n    \n\treturn col;\n}\n\n// --- utility functions ----------------------------------\nfloat rnd ( int n ) { return fract(sin(float(n)*543.21)*43758.5453);} \nfloat srnd( int n ) { return -1.+2.*fract(sin(float(n)*543.21)*43758.5453);} \n\nbool key_toggle(float ascii) { \n\treturn (texture(iChannel0,vec2((ascii+.5)/256.,0.75)).x > 0.); \n}\n\n// --- GUI: mouse tuning ----------------------------------\nvec3 userInterface() {\n\tvec2 uv = FragCoord.xy/iResolution.y - vec2(.8,.5);\n\tvec3 col=vec3(0.); float d;\n\tvec4 mouse = iMouse/iResolution.y;\n\n\tif(!key_toggle(9.)) return col; // 'TAB' key : automatic stars field -> exit\n\t\n\tif (mouse.x+mouse.y==0.) mouse.xy=vec2(.3,.1); // 1st mouse position silly\n\t\n\td = length(uv+vec2(.8,.5)-mouse.xy); // color cursor\n\tif (d<.02) col = vec3(0.,0.,1.);\n\t\n\tif(key_toggle(84.))  // 'T' key : tune RGB vs Temperature->Planck Spectrum\n\t{   // ---  Plank Spectrum mode ---\n\t\tfloat T = 40000.*iMouse.x/iResolution.x;\n\t\tstar_color = Planck(T);\n\t\t// star_luminosity = pow(T,4.);\n\t} \n\telse \n\t{   // --- RGB mode ---\n\t\tstar_color.gb = mouse.xy*star_luminosity; \n\t\tif(key_toggle(32.))  // SPACE key: red or blue dominant, tune the 2 others\n\t\t{ star_color=star_color.bgr; col=col.bgr;}\n\t}\n\t\n\t// display the 3-filters analyzor at bottom\n\tif ((uv.y<-.4)&&(abs(uv.x)<.102)) {\n\t\tif (uv.y<-.402) col=  vec3(\n\t\t\t((uv.x>-.10)&&(uv.x<-.031))?1.:0., // red frame\n\t\t\t((uv.x>-.029)&&(uv.x<.029))?1.:0., // green frame\n\t\t\t((uv.x< .10)&&(uv.x> .031))?1.:0.  // blue frame\n\t\t)*star_color/star_luminosity;\n\tif ((abs(uv.x)<.102)&&(col.r+col.g+col.b==0.)) col = vec3(1.);\n\t}\n\t\n\treturn col;\n}\n\n\n// --- main -----------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec3 col;\n\tFragCoord = fragCoord;\n    FragCoord += iResolution.x * 0.4;\n    FragCoord *= 0.6;\n    R = iResolution.xy;\n    float t = iTime; //107.0;\n    \n\t// --- tunings (color and display mode)\n\tcol = userInterface(); \n\t\n\t// --- camera\n\tvec3 cam = vec3(.3*sin(12.+t+.3*sin(2.2*t)),\n\t\t\t\t\t.3*sin(5.+.5*t-.2*cos(t)+sin(.31*t)),\n\t\t\t\t\t.3*sin(-2.+.6*t+.16*sin(.26*t))-3.);\n\tfloat a = .7*sin(.1*t+.02*sin(.33*t) );\n\tfloat c=cos(a),s=sin(a);\n\tmat2 m = mat2(c,-s, s,c), im=mat2(c,s, -s,c);\n\t//mat3 m = mat3(c,-s,0., s,c,0., 0.,0.,1.);\n\t\n\t// --- display stars \n\tif(key_toggle(9.)) // 'TAB' key\n\t\tcol += draw_star(vec2(.8,.5),1.);  // one single centred star\n\telse \n\t{\n\t\t// background\n\t\tvec2 uv = im*(fragCoord.xy/iResolution.y)+cam.xy;\n\t\tfloat bg = texture(iChannel1,uv).r;\n\t\tcol += 0.7*exp(-7.*bg) * vec3(0.92,0.35, 0.3);\n\n\t\t// do stars\n\t\tfor (int i=0; i<NB_STARS; i++) {\n\t\t\t// random position, intensity(=surf), temperature(->color)\n\t\t\tvec3 pos = vec3(3.*srnd(6*i), 3.*srnd(6*i+1), 2.*srnd(6*i+3));\n\t\t\tfloat I = .02*exp(-15.*rnd(6*i+4));\n\t\t\tstar_color = Planck(4500.*exp(-3.*rnd(6*i+5)));\n\n\t\t\t// project to screen coords\n\t\t\tpos = pos-cam;\n\t\t\tpos.xy = m*pos.xy;\n#if PERS // perspective\n\t\t\tpos.xy /= pos.z;\n#endif\n\t\t\tif (pos.z>0.)\n\t\t\t\tcol += draw_star(pos.xy+vec2(.8,.5),I/(pos.z*pos.z));\n\t\t}\n\t}\n\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7syBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[779, 849, 868, 868, 907], [908, 908, 963, 963, 1156], [1158, 1230, 1252, 1252, 1429], [1431, 1503, 1538, 1561, 2661], [2663, 2723, 2744, 2744, 2792], [2794, 2794, 2815, 2815, 2870], [2873, 2873, 2903, 2903, 2971], [2973, 3033, 3055, 3055, 4230], [4233, 4287, 4344, 4344, 5664]], "test": "untested"}
{"id": "7sGBzW", "name": "procedural pseudo-bluenoise", "author": "FabriceNeyret2", "description": "cheap highpass of white noise using LOD1 - LOD0 (texture or procedural) produces somewhat blueish noise.\n\nPower spectrum shown here: https://www.shadertoy.com/view/7dyfzW\nHistogram shown here: https://www.shadertoy.com/view/7syfRd", "tags": ["procedural", "random", "hash", "bluenoise"], "likes": 19, "viewed": 846, "published": 3, "date": "1657728668", "time_retrieved": "2024-07-30T16:40:38.380718", "image_code": "// see ready-to-use version in Common\n\n#define hash(p)  H(p) // fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  U = u + float(iFrame);\n    float m = iResolution.x/2.,\n          v = hash(U);                           // white noise\n    if (int(u) == int(m)) {  O= vec4(1,0,0,1); return; } // red separator\n    if (u.x < m ) { O = vec4(v); return; }       // left: white noise\n    \n    v *= -9.;                                    // high-pass: LOD1 - LOD0\n    for (int k=0; k<9; k++ )\n        v += hash(U+vec2(k%3-1,k/3-1));\n    \n    v = .5+.5*v/9. *2.1;\n // v = v < 0. ? -v : v > 1. ? 2.-v : v ;        // folding values out of [0,1] (better histogram, visually still blue, spectrum less blue)\n // v = fract(v);                                // wrapping values out of [0,1] (no longer blue)\n    O = vec4(v);                                 // draw\n    \n#if 0                                            // show over/under shoot\n    if (O.x>1.) O = vec4(0,1,0,1);\n    else if (O.x<0.) O = vec4(1,0,0,1);\n#endif\n}", "image_inputs": [], "common_code": "\n#define H(p)  fract(sin(mod(dot(p, vec2(12.9898, 78.233)),6.283)) * 43758.5453)\n\n#define blue(p) (  \\\n          (  H(p+vec2(-1,-1)) + H(p+vec2(0,-1)) + H(p+vec2(1,-1))  \\\n           + H(p+vec2(-1, 0)) - 8.* H( p )      + H(p+vec2(1, 0))  \\\n           + H(p+vec2(-1, 1)) + H(p+vec2(0, 1)) + H(p+vec2(1, 1))  \\\n          ) *.5/9. *2.1 +.5 )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sGBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 158, 158, 1068]], "test": "untested"}
{"id": "fsyBzD", "name": "Metal Melting Flavor", "author": "leon", "description": "nuclear summer vibes. also mouse interactive", "tags": ["abstract", "rainbow"], "likes": 93, "viewed": 1394, "published": 3, "date": "1657722929", "time_retrieved": "2024-07-30T16:40:39.135699", "image_code": "\n// Metal Melting Flavor\n// nuclear summer vibes, also mouse interactive\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float material;\nfloat glow;\nvec3 mouse;\n\n// fractal brownian motion https://thebookofshaders.com/13/\nvec3 fbm (vec3 p)\n{\n    vec3 result = vec3(.0);\n    float a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        p.y += iTime*.005/a;\n        result += sin(texture(iChannel1, p/a).xyz*6.28)*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    vec3 pp = p;\n    float c;\n    \n    // sphere\n    dist = length(p)-1.;\n    \n    // droplets\n    c = pModPolar(p.xz, 8.);\n    vec3 rng = hash31(c);\n    p.x -= 1.-.5;\n    rng.x += sign(p.x)*.5;\n    p.x = abs(p.x)-.2;\n    p.y *= -1.;\n    float time = iTime * .2 + rng.x;\n    float anim = fract(time);\n    float index = floor(time);\n    float wave = sin(anim*3.14);\n    float h = .7+.3*pow(wave, 4.);\n    float s = .03-.03*(1.-wave);\n    shape = sdSegment(p, h, s);\n    dist = smin(dist, shape, .2);\n    shape = length(p-vec3(0,pow(anim, 10.)*200.+h,0))-.05;\n    dist = smin(dist, shape, .3*pow(anim,0.5));\n    \n    // sphere mouse interaction\n    dist = smin(dist, length(pp+mouse)-.1, .6);\n    \n    // surface details\n    vec3 seed = pp*.1;\n    vec3 noise = fbm(seed);\n    dist -= noise.x*.01;\n    \n    return dist * .5;\n}\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in vec2 uv, in float shade)\n{\n    // Inigo Quilez color palette\n    // https://iquilezles.org/www/articles/palettes/palettes.htm\n    vec3 tint = .5+.5*cos(vec3(0,.3,.6)*6.283+iTime*.2+uv.y*3.);\n    \n    // lighting\n    color = tint * pow(dot(normal, vec3(0,-1,0))*.5+.5, 10.);\n    vec3 rf = reflect(ray, normal);\n    float top = dot(rf, vec3(0,1,0))*.5+.5;\n    float glow = dot(normal, ray)*.5+.5;\n    color += vec3(.8)*pow(clamp(top,0.,1.), 4.5);\n    color += vec3(2)*pow(glow, 2.);\n    color *= pow(shade,.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // background\n    vec3 color = vec3(.2)*smoothstep(2.,.5,length(uv));\n    \n    // coordinates\n    vec3 pos = vec3(0,0,3);\n    vec3 at = vec3(0);\n    pos.zy *= rot(sin(iTime*.2)*.1);\n    vec3 ray = lookAt(pos, at, uv, 1.);\n    \n    // mouse interaction\n    if (iMouse.z > 0.5) {\n        vec2 uvm = (iMouse.xy-iResolution.xy/2.)/iResolution.y;\n        mouse = vectorAt(pos, at, uvm*2., -1.) * -1.;\n    }\n    else mouse = vec3(0);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    \n    // materialing\n    material = 0.;\n    glow = 0.;\n    float maxDist = 4.;\n    \n    // raymarch\n    const float count = 50.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*blue.z;\n        ray += white * total*.002;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // NuSan https://www.shadertoy.com/view/3sBGzV\n    vec2 noff = vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        coloring(color, pos, normal, ray, uv, shade);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\nvec3 vectorAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return (z * fov + uv.x * x + uv.y * y);\n}\n// Mercury\n// https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 6.28/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdSegment( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n// blackle\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd) {\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*3.1415);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsyBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 150, 207, 207, 289]], "test": "untested"}
{"id": "fsVBR1", "name": "Light Spectrum Therapy", "author": "leon", "description": "particles massage, when the spectrum hit at the right spot", "tags": ["abstract", "rainbow"], "likes": 45, "viewed": 765, "published": 3, "date": "1657710110", "time_retrieved": "2024-07-30T16:40:39.900654", "image_code": "\n\n// Light Spectrum Therapy\n// when the spectrum hit at the right spot\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float material;\nfloat glow;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    float shape = 100.;\n    float shape2 = 100.;\n    vec3 pp = p;\n    float scale = smoothstep(2., .0, abs(p.y));\n    \n    // sphere\n    dist = length(p)-1.;\n    \n    // eyes\n    p = pp;\n    p.z -= 1.;\n    p.x = abs(p.x)-.2;\n    shape = min(shape, sdCappedTorus(p, vec2(sin(1.),cos(1.)), .1, .001));\n    \n    // smile\n    p = pp + vec3(0,.2,-.95);\n    p.y *= -1.;\n    p.y += cos(abs(p.x)*20.)*.02;\n    shape = min(shape, sdCappedTorus(p, vec2(sin(1.),cos(1.)), .2, .001));\n    \n    // segments\n    p = pp;\n    float time = (iTime*2.);\n    float anim = fract(time);\n    float index = floor(time);\n    p = rndrot(p, hash41(index));\n    float c = pModPolar(p.xz, floor(100.*hash11(index)));\n    scale = smoothstep(2., .0, abs(p.y));\n    p.x -= .5+.5*scale;\n    p.y += (fract(time+hash11(c))*2.-1.)*10.*(.5+.5*hash11(index+96.));\n    shape2 = sdSegment(p, 2., .01) + .1*(1.-sin(anim*3.14));\n    \n    // union\n    material = shape2 < shape ? 2. : 1.;\n    shape = min(shape, shape2);\n    \n    // glow\n    glow += .001/shape;\n    \n    // union\n    material = shape < dist ? material : 0.;\n    dist = min(dist, shape);\n    \n    return dist;\n}\n\nvoid coloring (inout vec3 color, in vec3 pos, in vec3 normal, in vec3 ray, in vec2 uv, in float shade)\n{\n    // reflecting metal\n    if (material == 0.)\n    {\n        color = vec3(.0);\n        float light = dot(reflect(ray, normal), vec3(0,1,0))*.5+.5;\n        color += vec3(0.5)*pow(light, 4.5);\n\n        color *= pow(shade,.5);\n    }\n    // light\n    else \n    {\n        color = vec3(1);\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // background\n    vec3 color = vec3(.2)*smoothstep(2.,.5,length(uv));\n    \n    // coordinates\n    vec3 pos = vec3(0,.1,3);\n    vec3 at = vec3(0);\n    pos.xz *= rot(cos(iTime*.1)*.5);\n    pos.zy *= rot(sin(iTime*.2)*.2);\n    vec3 ray = lookAt(pos, at, uv, 1.);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    vec3 white = hash33(vec3(fragCoord, iFrame));\n    \n    // materialing\n    material = 0.;\n    glow = 0.;\n    float maxDist = 10.;\n    \n    // raymarch\n    const float count = 50.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > maxDist) break;\n        dist *= 0.9+0.1*blue.z;\n        ray += white * total*.01;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // NuSan https://www.shadertoy.com/view/3sBGzV\n    vec2 noff = vec2(.001,0);\n    vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < maxDist) {\n        coloring(color, pos, normal, ray, uv, shade);\n        \n        // reflection\n        if (material == 0.)\n        {\n            const float count2 = 30.;\n            ray = reflect(ray, normal);\n            ray = (ray+ blue*.5);\n            steps = 0.;\n            total = 0.;\n            for (steps = count2; steps > 0.; --steps) {\n                float dist = map(pos);\n                if (dist < total/iResolution.y || total > maxDist) break;\n                pos += ray * dist;\n                total += dist;\n            }\n            shade = steps/count2;\n            if (shade > .001 && total < maxDist) {\n                normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n                coloring(color, pos, normal, ray, uv, shade);\n            }\n         }\n    }\n    \n    // rainbow glow\n    if (material == 2.)\n    {\n        vec3 tint = .5+.5*cos(vec3(0.,.3,.6)*6.+uv.y*3.+iTime+atan(pos.x,pos.z));\n        color += tint * max(0., glow);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define repeat(p,r) (mod(p,r)-r/2.)\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n// Mercury\n// https://mercury.sexy/hg_sdf/\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 6.28/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdSegment( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\nfloat sdLink( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n// blackle\n// https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\nvec3 rndrot(vec3 p, vec4 rnd) {\n  return erot(p, normalize(tan(rnd.xyz)), rnd.w*3.1415);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVBR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 148, 205, 205, 287]], "test": "untested"}
{"id": "ssKBz1", "name": "Zeros of Riemann Zeta function", "author": "guil", "description": "Compare the Zeta function with the true value of the first 500 non trivial zeros.\nKeys from 1 to 7 change algorithm for zeta\nkey 8 is gamma, key z is zoom, key x goes directly to last zero\n", "tags": ["zeta"], "likes": 3, "viewed": 273, "published": 3, "date": "1657701523", "time_retrieved": "2024-07-30T16:40:40.929902", "image_code": "\nprecision highp float;\nconst float pi = 3.1415926535897932;\nconst float LOG2 = 0.6931471805599453;\nconst float LOGPI = 1.1447298858494002;\nconst float[1025] zeros = float[1025](\n\t14.134725,\t21.022040,\t25.010858,\t30.424876,\t32.935062,\n\t37.586178,\t40.918719,\t43.327073,\t48.005151,\t49.773832,\n\t52.970321,\t56.446248,\t59.347044,\t60.831779,\t65.112544,\n\t67.079811,\t69.546402,\t72.067158,\t75.704691,\t77.144840,\n\t79.337375,\t82.910381,\t84.735493,\t87.425275,\t88.809111,\n\t92.491899,\t94.651344,\t95.870634,\t98.831194,\t101.317851,\n\t103.725538,\t105.446623,\t107.168611,\t111.029536,\t111.874659,\n\t114.320221,\t116.226680,\t118.790783,\t121.370125,\t122.946829,\n\t124.256819,\t127.516684,\t129.578704,\t131.087689,\t133.497737,\n\t134.756510,\t138.116042,\t139.736209,\t141.123707,\t143.111846,\n\t146.000982,\t147.422765,\t150.053520,\t150.925258,\t153.024694,\n\t156.112909,\t157.597592,\t158.849988,\t161.188964,\t163.030710,\n\t165.537069,\t167.184440,\t169.094515,\t169.911976,\t173.411537,\n\t174.754192,\t176.441434,\t178.377408,\t179.916484,\t182.207078,\n\t184.874468,\t185.598784,\t187.228923,\t189.416159,\t192.026656,\n\t193.079727,\t195.265397,\t196.876482,\t198.015310,\t201.264752,\n\t202.493595,\t204.189672,\t205.394697,\t207.906259,\t209.576510,\n\t211.690863,\t213.347919,\t214.547045,\t216.169539,\t219.067596,\n\t220.714919,\t221.430706,\t224.007000,\t224.983325,\t227.421444,\n\t229.337413,\t231.250189,\t231.987235,\t233.693404,\t236.524230,\n\t237.769820,\t239.555478,\t241.049158,\t242.823272,\t244.070898,\n\t247.136990,\t248.101990,\t249.573690,\t251.014948,\t253.069987,\n\t255.306256,\t256.380714,\t258.610439,\t259.874407,\t260.805085,\n\t263.573894,\t265.557852,\t266.614974,\t267.921915,\t269.970449,\n\t271.494056,\t273.459609,\t275.587493,\t276.452050,\t278.250744,\n\t279.229251,\t282.465115,\t283.211186,\t284.835964,\t286.667445,\n\t287.911921,\t289.579855,\t291.846291,\t293.558434,\t294.965370,\n\t295.573255,\t297.979277,\t299.840326,\t301.649325,\t302.696750,\n\t304.864371,\t305.728913,\t307.219496,\t310.109463,\t311.165142,\n\t312.427801,\t313.985286,\t315.475616,\t317.734806,\t318.853104,\n\t321.160134,\t322.144559,\t323.466970,\t324.862866,\t327.443901,\n\t329.033072,\t329.953240,\t331.474468,\t333.645379,\t334.211355,\n\t336.841850,\t338.339993,\t339.858217,\t341.042261,\t342.054878,\n\t344.661703,\t346.347871,\t347.272678,\t349.316261,\t350.408419,\n\t351.878649,\t353.488900,\t356.017575,\t357.151302,\t357.952685,\n\t359.743755,\t361.289362,\t363.331331,\t364.736024,\t366.212710,\n\t367.993575,\t368.968438,\t370.050919,\t373.061928,\t373.864874,\n\t375.825913,\t376.324092,\t378.436680,\t379.872975,\t381.484469,\n\t383.443529,\t384.956117,\t385.861301,\t387.222890,\t388.846128,\n\t391.456084,\t392.245083,\t393.427744,\t395.582870,\t396.381854,\n\t397.918736,\t399.985120,\t401.839229,\t402.861918,\t404.236442,\n\t405.134387,\t407.581460,\t408.947246,\t410.513869,\t411.972268,\n\t413.262736,\t415.018810,\t415.455215,\t418.387706,\t419.861365,\n\t420.643828,\t422.076710,\t423.716580,\t425.069882,\t427.208825,\n\t428.127914,\t430.328745,\t431.301307,\t432.138642,\t433.889218,\n\t436.161006,\t437.581698,\t438.621739,\t439.918442,\t441.683199,\n\t442.904546,\t444.319336,\t446.860623,\t447.441704,\t449.148546,\n\t450.126946,\t451.403308,\t453.986738,\t454.974684,\t456.328427,\n\t457.903893,\t459.513415,\t460.087944,\t462.065367,\t464.057287,\n\t465.671539,\t466.570287,\t467.439046,\t469.536005,\t470.773655,\n\t472.799175,\t473.835232,\t475.600339,\t476.769015,\t478.075264,\n\t478.942182,\t481.830339,\t482.834783,\t483.851427,\t485.539148,\n\t486.528718,\t488.380567,\t489.661762,\t491.398822,\t493.314442,\n\t493.957998,\t495.358829,\t496.429696,\t498.580782,\t500.309085,\n\t501.604447,\t502.276270,\t504.499773,\t505.415232,\t506.464153,\n\t508.800700,\t510.264228,\t511.562290,\t512.623145,\t513.668986,\n\t515.435057,\t517.589669,\t518.234223,\t520.106310,\t521.525193,\n\t522.456696,\t523.960531,\t525.077386,\t527.903642,\t528.406214,\n\t529.806226,\t530.866918,\t532.688183,\t533.779631,\t535.664314,\n\t537.069759,\t538.428526,\t540.213166,\t540.631390,\t541.847437,\n\t544.323890,\t545.636833,\t547.010912,\t547.931613,\t549.497568,\n\t550.970010,\t552.049572,\t553.764972,\t555.792021,\t556.899476,\n\t557.564659,\t559.316237,\t560.240807,\t562.559208,\t564.160879,\n\t564.506056,\t566.698788,\t567.731758,\t568.923955,\t570.051115,\n\t572.419984,\t573.614611,\t575.093886,\t575.807247,\t577.039003,\n\t579.098835,\t580.136959,\t581.946576,\t583.236088,\t584.561706,\n\t585.984563,\t586.742772,\t588.139663,\t590.660398,\t591.725858,\n\t592.571358,\t593.974715,\t595.728154,\t596.362768,\t598.493077,\n\t599.545640,\t601.602137,\t602.579168,\t603.625619,\t604.616218,\n\t606.383460,\t608.413217,\t609.389575,\t610.839163,\t611.774210,\n\t613.599779,\t614.646238,\t615.538563,\t618.112831,\t619.184483,\n\t620.272894,\t621.709295,\t622.375003,\t624.269900,\t626.019283,\n\t627.268397,\t628.325862,\t630.473887,\t630.805781,\t632.225141,\n\t633.546858,\t635.523800,\t637.397193,\t637.925514,\t638.927938,\n\t640.694795,\t641.945500,\t643.278884,\t644.990578,\t646.348192,\n\t647.761753,\t648.786401,\t650.197519,\t650.668684,\t653.649572,\n\t654.301921,\t655.709463,\t656.964085,\t658.175614,\t659.663846,\n\t660.716733,\t662.296586,\t664.244605,\t665.342763,\t666.515148,\n\t667.148495,\t668.975849,\t670.323585,\t672.458184,\t673.043578,\n\t674.355898,\t676.139674,\t677.230181,\t677.800445,\t679.742198,\n\t681.894992,\t682.602735,\t684.013550,\t684.972630,\t686.163224,\n\t687.961543,\t689.368941,\t690.474735,\t692.451684,\t693.176970,\n\t694.533909,\t695.726336,\t696.626070,\t699.132095,\t700.296739,\n\t701.301743,\t702.227343,\t704.033839,\t705.125814,\t706.184655,\n\t708.269071,\t709.229589,\t711.130274,\t711.900290,\t712.749383,\n\t714.082772,\t716.112396,\t717.482570,\t718.742787,\t719.697101,\n\t721.351162,\t722.277505,\t723.845821,\t724.562614,\t727.056403,\n\t728.405482,\t728.758750,\t730.416482,\t731.417355,\t732.818053,\n\t734.789643,\t735.765459,\t737.052929,\t738.580421,\t739.909524,\n\t740.573807,\t741.757336,\t743.895013,\t745.344990,\t746.499306,\n\t747.674564,\t748.242754,\t750.655950,\t750.966381,\t752.887622,\n\t754.322370,\t755.839309,\t756.768248,\t758.101729,\t758.900238,\n\t760.282367,\t762.700033,\t763.593066,\t764.307523,\t766.087540,\n\t767.218472,\t768.281462,\t769.693407,\t771.070839,\t772.961618,\n\t774.117745,\t775.047847,\t775.999712,\t777.299749,\t779.157077,\n\t780.348925,\t782.137664,\t782.597944,\t784.288823,\t785.739090,\n\t786.461147,\t787.468464,\t790.059092,\t790.831620,\t792.427708,\n\t792.888653,\t794.483792,\t795.606596,\t797.263470,\t798.707570,\n\t799.654336,\t801.604246,\t802.541985,\t803.243096,\t804.762239,\n\t805.861636,\t808.151815,\t809.197783,\t810.081805,\t811.184359,\n\t812.771108,\t814.045914,\t814.870540,\t816.727738,\t818.380669,\n\t819.204642,\t820.721898,\t821.713454,\t822.197757,\t824.526294,\n\t826.039287,\t826.905811,\t828.340174,\t829.437011,\t830.895884,\n\t831.799778,\t833.003641,\t834.651915,\t836.693576,\t837.347335,\n\t838.249022,\t839.465395,\t841.036390,\t842.041354,\t844.166197,\n\t844.805994,\t846.194770,\t847.971718,\t848.489281,\t849.862274,\n\t850.645448,\t853.163113,\t854.095512,\t855.286710,\t856.484117,\n\t857.310741,\t858.904026,\t860.410671,\t861.171098,\t863.189720,\n\t864.340824,\t865.594664,\t866.423740,\t867.693123,\t868.670494,\n\t870.846902,\t872.188751,\t873.098979,\t873.908389,\t875.985285,\n\t876.600826,\t877.654698,\t879.380952,\t880.834649,\t882.386697,\n\t883.430332,\t884.198743,\t885.272304,\t886.852802,\t888.475567,\n\t889.735294,\t890.813132,\t892.386433,\t893.119118,\t894.886292,\n\t895.397920,\t896.632252,\t899.221523,\t899.858885,\t900.849740,\n\t902.243208,\t903.099674,\t904.702903,\t905.829941,\t907.656729,\n\t908.333544,\t910.186334,\t911.234951,\t912.331046,\t912.823999,\n\t914.730097,\t916.355001,\t917.825378,\t918.836535,\t919.448344,\n\t921.156396,\t922.500629,\t923.285720,\t924.773484,\t926.551553,\n\t927.850859,\t928.663659,\t929.874093,\t931.009211,\t931.852741,\n\t934.385307,\t934.995425,\t936.228649,\t937.532926,\t939.024301,\n\t939.660941,\t941.157000,\t942.052342,\t944.188036,\t945.333563,\n\t946.765842,\t947.079183,\t948.346646,\t950.151613,\t951.033249,\n\t952.727989,\t954.129719,\t954.829309,\t956.675479,\t957.510053,\n\t958.414593,\t959.459169,\t961.669572,\t963.182087,\t963.567040,\n\t965.055580,\t966.110755,\t967.371154,\t968.636302,\t970.125611,\n\t971.071491,\t973.185361,\t973.873079,\t974.774635,\t976.178502,\n\t976.917202,\t978.766672,\t980.578001,\t981.288615,\t982.396485,\n\t983.575076,\t985.186929,\t986.130515,\t986.756008,\t988.992622,\n\t990.223918,\t991.374294,\t992.728696,\t993.214581,\t994.404591,\n\t996.205336,\t997.511935,\t998.827547,\t999.791572,\t1001.349483,\n\t1002.404305,\t1003.267808,\t1004.675044,\t1005.543420,\t1008.006704,\n\t1008.795710,\t1009.806591,\t1010.569757,\t1012.410043,\t1013.058638,\n\t1014.689633,\t1016.060179,\t1017.266402,\t1018.605573,\t1019.912440,\n\t1020.917475,\t1021.544344,\t1022.885271,\t1025.265724,\t1025.707944,\n\t1027.467694,\t1028.128964,\t1029.227297,\t1030.897369,\t1031.833180,\n\t1032.812883,\t1034.612916,\t1036.195917,\t1037.024708,\t1038.087752,\n\t1039.077401,\t1040.264038,\t1041.621528,\t1043.623954,\t1044.514976,\n\t1045.107042,\t1047.089817,\t1047.987147,\t1048.953785,\t1049.996284,\n\t1051.576572,\t1053.245785,\t1054.781039,\t1055.002146,\t1056.688847,\n\t1057.100044,\t1059.133769,\t1060.139519,\t1061.501304,\t1062.915382,\n\t1064.071551,\t1065.121855,\t1066.463223,\t1067.418860,\t1067.990000,\n\t1070.535042,\t1071.618623,\t1072.543998,\t1073.570353,\t1074.747771,\n\t1076.266626,\t1076.924056,\t1078.647198,\t1079.809965,\t1081.171002,\n\t1082.952750,\t1083.295467,\t1084.183264,\t1085.647831,\t1086.911999,\n\t1088.755725,\t1089.795338,\t1090.863191,\t1091.728473,\t1093.440873,\n\t1094.284458,\t1095.433085,\t1096.401918,\t1098.841015,\t1099.360667,\n\t1100.574461,\t1101.839111,\t1102.551780,\t1103.732297,\t1105.617189,\n\t1106.774372,\t1107.774532,\t1109.158919,\t1110.444143,\t1111.443505,\n\t1112.432995,\t1113.397595,\t1115.065359,\t1116.787254,\t1117.965920,\n\t1118.684135,\t1119.473247,\t1121.155938,\t1122.458621,\t1123.101117,\n\t1125.314729,\t1125.763442,\t1127.658024,\t1128.430225,\t1129.728997,\n\t1130.391598,\t1131.495086,\t1133.708626,\t1134.885655,\t1135.562214,\n\t1136.929293,\t1138.151590,\t1138.992342,\t1140.721848,\t1141.261023,\n\t1142.858660,\t1144.782300,\t1145.485328,\t1146.576815,\t1147.501777,\n\t1148.615277,\t1149.982601,\t1151.562815,\t1152.943129,\t1153.890304,\n\t1154.697520,\t1156.621568,\t1157.432315,\t1158.001609,\t1159.480657,\n\t1161.396645,\t1162.487529,\t1163.701032,\t1164.737586,\t1165.271228,\n\t1166.943613,\t1168.086272,\t1169.698357,\t1170.463639,\t1172.120682,\n\t1173.305688,\t1174.232767,\t1175.215452,\t1176.632876,\t1177.106304,\n\t1179.701224,\t1180.653544,\t1181.267318,\t1182.582270,\t1183.712775,\n\t1185.155843,\t1185.875359,\t1187.345161,\t1188.856444,\t1189.963636,\n\t1191.482606,\t1192.218611,\t1193.324021,\t1193.857427,\t1196.034672,\n\t1197.071787,\t1198.686569,\t1199.356514,\t1200.532692,\t1201.810335,\n\t1203.137351,\t1203.855248,\t1204.985492,\t1206.870500,\t1208.471460,\n\t1208.989484,\t1209.898030,\t1211.416116,\t1212.113153,\t1213.598373,\n\t1215.389975,\t1216.183722,\t1217.174482,\t1219.050028,\t1219.614471,\n\t1220.816348,\t1221.692242,\t1222.952484,\t1225.018330,\t1225.855021,\n\t1227.231828,\t1227.917142,\t1228.793154,\t1230.584603,\t1231.562274,\n\t1232.529587,\t1234.277817,\t1235.502549,\t1236.399017,\t1237.977299,\n\t1238.457233,\t1239.490807,\t1240.813472,\t1243.078076,\t1243.538147,\n\t1244.851434,\t1245.655866,\t1247.372562,\t1248.063061,\t1249.159888,\n\t1250.672397,\t1251.659832,\t1253.673578,\t1254.431328,\t1255.408231,\n\t1256.181214,\t1257.541219,\t1258.779233,\t1260.344548,\t1261.611717,\n\t1262.556614,\t1263.676733,\t1264.957223,\t1266.179038,\t1267.200346,\n\t1267.570572,\t1270.118922,\t1271.134300,\t1272.083960,\t1273.261145,\n\t1274.196221,\t1275.092030,\t1276.842172,\t1277.763092,\t1279.332843,\n\t1280.155794,\t1281.828727,\t1283.000491,\t1283.335032,\t1284.854795,\n\t1285.695023,\t1287.410027,\t1289.165352,\t1290.104772,\t1290.417708,\n\t1291.945871,\t1293.493982,\t1294.118474,\t1295.365364,\t1296.801111,\n\t1298.256527,\t1299.405171,\t1300.490019,\t1301.495517,\t1302.346742,\n\t1303.273200,\t1305.401672,\t1306.508393,\t1307.267242,\t1308.988197,\n\t1309.421532,\t1311.056571,\t1311.966941,\t1313.031599,\t1314.052566,\n\t1316.212113,\t1317.072986,\t1318.171279,\t1318.947881,\t1319.931083,\n\t1321.628139,\t1322.258067,\t1324.224979,\t1325.237624,\t1325.981970,\n\t1327.635281,\t1329.043518,\t1329.205019,\t1330.429937,\t1331.827591,\n\t1333.673523,\t1334.747329,\t1335.694975,\t1336.690185,\t1337.688792,\n\t1338.923165,\t1340.426400,\t1341.166272,\t1342.608508,\t1344.156044,\n\t1345.477106,\t1345.731413,\t1347.519472,\t1348.017238,\t1349.085194,\n\t1351.296206,\t1352.210465,\t1353.483338,\t1353.886782,\t1355.680595,\n\t1356.605656,\t1357.771743,\t1358.460160,\t1360.393145,\t1361.393075,\n\t1363.022329,\t1363.879191,\t1364.576585,\t1365.493734,\t1367.104091,\n\t1368.330193,\t1369.686949,\t1370.973523,\t1371.686554,\t1373.202915,\n\t1374.154799,\t1375.302392,\t1376.161780,\t1377.177634,\t1379.683283,\n\t1380.148578,\t1381.073977,\t1382.345663,\t1383.297591,\t1384.444416,\n\t1385.663777,\t1387.326648,\t1387.921454,\t1389.565832,\t1390.705490,\n\t1391.853200,\t1392.644028,\t1393.433402,\t1394.884185,\t1396.544163,\n\t1397.834623,\t1398.837675,\t1399.839473,\t1400.426946,\t1402.564347,\n\t1402.973748,\t1404.006292,\t1405.666975,\t1407.085143,\t1408.136307,\n\t1409.320681,\t1410.024811,\t1411.257057,\t1411.965653,\t1413.843149,\n\t1415.585785,\t1415.781581,\t1417.102823,\t1418.696964,\t1419.422481,\n\t1420.416526,\t1421.850567,\t1422.461311,\t1424.463046,\t1425.873469,\n\t1426.645980,\t1427.365671,\t1428.592306,\t1429.650477,\t1431.218314,\n\t1432.049741,\t1433.821941,\t1434.584942,\t1435.692907,\t1437.226722,\n\t1438.006285,\t1438.949553,\t1439.622793,\t1441.960988,\t1442.911060,\n\t1444.041931,\t1445.072278,\t1445.830085,\t1447.226227,\t1448.323854\n\n);\n\n\n\n//------------------ ------------------------------------------\n// complex number operations\nvec2 cadd( vec2 a, float s ) { return vec2( a.x+s, a.y ); }\nvec2 cmul( vec2 a, vec2 b )  { return vec2( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x ); }\nvec2 cinv(vec2 z) {return vec2(z.x,-z.y)/dot(z,z);}\nvec2 cdiv( vec2 a, vec2 b )  { float d = dot(b,b); return vec2( dot(a,b), a.y*b.x - a.x*b.y ) / d; }\nvec2 csqr( vec2 a ) { return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y ); }\nvec2 csqrt( vec2 z ) { float m = length(z); return sqrt( 0.5*vec2(m+z.x, m-z.x) ) * vec2( 1.0, sign(z.y) ); }\nvec2 conj( vec2 z ) { return vec2(z.x,-z.y); }\nvec2 cpow( vec2 z, float n ) { float r = length( z ); float a = atan( z.y, z.x ); return pow( r, n )*vec2( cos(a*n), sin(a*n) ); }\nvec2 cpow( float n, vec2 z ) {  return pow( n, z.x )*vec2( cos(z.y*log(n)), sin(z.y*log(n)) ); }\nvec2 cexp( vec2 z) {  return exp( z.x )*vec2( cos(z.y), sin(z.y) ); }\nvec2 clog( vec2 z) {  return vec2( 0.5*log(z.x*z.x+z.y*z.y), atan(z.y,z.x)); }\nvec2 csin( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*sin(z.x),(r-1.0/r)*cos(z.x));}\nvec2 cpow( vec2 a, vec2 b ) {  return cexp(cmul(b,clog(a))) ;}\nvec2 ccos( vec2 z) { float r = exp(z.y); return 0.5*vec2((r+1.0/r)*cos(z.x),-(r-1.0/r)*sin(z.x));}\nvec2 clogsin(vec2 z) {\n  if (abs(z.y)<8.0)return clog(csin(z));  \n  if (z.y > 0.) return vec2(z.y - LOG2, mod(1.5*pi-z.x, 2.0*pi) - pi);\n  else return vec2(-z.y - LOG2, mod(0.5*pi+z.x, 2.0*pi) - pi);\n  \n}\n//------------------------------------------------------------\n\n\n\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvec3 col(vec2 u){\n    float r = u.x;\n    float v =min( exp(-r*.15),1.);\n    return hsv2rgb(vec3(u.y/(2.*pi),.5+.5*fract(r),.8))*v;\n}\n\n\n\n// Spouge's method for loggamma\nvec2 logspouge(vec2 z){\n    const int N = 10;\n    float c = sqrt(2.*pi);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    //s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    //return cdiv(s,z);\n    s = clog(s); \n    s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    return s-clog(z);      \n}\n\n\n// Spouge approximation for loggamma function\nvec2 loggamma(vec2 z){\n  if(z.x > 0.5) return logspouge(z);\n  return vec2(LOGPI,0)-clogsin(pi*z)-logspouge(vec2(1,0)-z);\n}\n\n\n//Basic eta def\nvec2 eta1(vec2 z){\n  const float N = 50.;\n  vec2 sum = vec2(0);\n  float s=1.;\n  for(float i = 0.; i < N; i++)\n    sum += s*cpow(i+1.,-z), s*=-1.;\n  return sum;\n}\n\n//Knopp and Hasse\nvec2 eta2(vec2 z){\n  const float N = 50.;\n  vec2 sum = vec2(0);\n  for(float i = 0.; i < N; i++){\n    vec2 term = vec2(0);\n    float s = 1.;\n    float bnk = 1./pow(2.,i+1.);\n    for(float k = 0.; k < i+1.; k++){\n       term += s*bnk* cpow(k+1.,-z);\n       bnk *= (i-k)/(k+1.);\n       s*=-1.;\n       }\n    sum += term;\n    }\n  return sum;\n}\n\n\n\n\n//Same algorithm as in mia shader but extended to N = 40\n//ek coeff are calculated on the fly\n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 eta3(vec2 s) {\n  const int N = 120;  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return sum1 + sum2;\n}\n\n//Borwein method, valid for z.x > 0 \n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 eta4(vec2 z){\n        \n    int n1=100;\n    int n2=45;\n    \n\tfloat a=1.;\n    vec2  sum1 = vec2(0.);\n    for (int i = 1; i <= n1 ; i++) {\n        sum1 += cpow(float(i),-z)*a;\n        a=-a;\n        }\n    \n    float dni = 1.;\n    float dnn = dni;\n    float val = dni;\n\tfor(int i = 1; i<=n2 ;i++){\n\t\tval *= 2.*float((n2+i-1)*(n2-i+1))/float((2*i-1)*i);\n\t\tdnn+= val;\t\t\n\t}\n    dni = 1./dnn;\n    val = dni;\n    vec2  sum2 = vec2(0.);\n    for (int i = 1; i <= n2 ; i++) {\n        float ci = 1.- dni;\n        sum2 += a*ci*cpow(float(i+n1),-z);\n        a *= -1.;\n        val *= 2.*float((n2+i-1)*(n2-i+1))/float((2*i-1)*i);\n        dni +=val;\n        }\n    return sum1+sum2;\n}\n\n\nvec2 logkhi(vec2 z){\n    return z*log(2.*pi)-vec2(log(pi),0)+clogsin(pi*z/2.)+loggamma(vec2(1.,0.)-z);\n}  \n\n//Henri Cohen, Fernando Rodriguez Villegas, and Don Zagier\n//https://people.mpim-bonn.mpg.de/zagier/files/exp-math-9/fulltext.pdf\nvec2 eta5(vec2 z){\n  const float N1 = 300.;\n  const float N2 = 48.;\n  \n  vec2 s1 = vec2(0);\n  float a = 1.0;\n  for(float i = 0.; i < N1; i++) {\n    s1 += a*(cpow(i+1., -z));\n    a = -a;\n  }\n  \n  float d= pow((3. + sqrt(8.)),N2);\n  d=(d+1./d)/2.;\n  float b=-1.,c=-d;\n  vec2 s2 = vec2(0);\n  for(float k = 0.; k < N2; k++)\n    c = b-c,\n    s2 += c*cpow(k+N1+1.,-z),\n    b *= (k+N2)/(k+0.5)*(k-N2)/(k+1.);\n    \n  return s1+s2/d;\n}\n\n\n\n//Riemann-Siegel formula\n//Valid for 0<z.x<1 and abs(z.y) very large\n//http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\nvec2 zeta6(vec2 z){\n  const float N = 100.;\n  float m = sqrt(abs(z.y)/(2.*pi));\n  vec2 sum1 = vec2(0);\n  vec2 sum2 = vec2(0);\n  for(float i = 0.; i < N; i++){\n    sum1 += cpow(i+1.,-z); \n    sum2 += cpow(i+1.,z-1.);\n    if(i>m)break;\n}    \n  return sum1 + cexp(logkhi(z)+clog(sum2));\n}\n\n//Dirichlet lambda = (eta+zeta)/2 = sum (2*i+1)**-z for i in N\n//zeta = lambda /(1-2**-z)\n//not very accurate near 0 but very accurate for large Im(z)\nvec2 lambda(vec2 z){\n  const float N = 200.;\n  vec2 sum = vec2(0);\n  \n  for(float i = 0.; i < N; i++)\n    sum += cpow(2.*i+1.,-z);\n  return sum;\n}\n\n\nvec2 logzeta(vec2 z){\n    if(z.x<.5)return logkhi(z)+clog(eta4(vec2(1.,0.)-z))-clog(vec2(1,0)-cpow(2.,z));\n    return clog(eta4(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\nvec2 zeta(vec2 z){    \n    return cexp(logzeta(z));\n}\n\nvec2 zetabrot(vec2 z){\n    for(int i = 0; i < 12; i++){\n        z=zeta(z);\n        if (dot(z,z)<.7)break;\n        }\n    return z;\n}\n\nint binarysearch(float x){\n    const int N = 1024;\n    if(x>zeros[N])return N;\n    if(x<zeros[0])return 0;\n    int n = 0;\n    int k = N/2;\n    for(int i=0;i<9;i++){\n        if(x>zeros[n+k])n+=k;\n        k/=2;\n    }\n    if(abs(zeros[n]-x)<abs(zeros[n+1]-x))return n;\n    return n+1;\n\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nvoid mainImage(out vec4 fragColor,  in vec2 fragCoord){\n  vec2 uv = (2.*fragCoord - iResolution.xy-iMouse.xy) / iResolution.y+(iMouse.xy==vec2(0.,0.)?0.:.5);;  // Map y-coordinates to [-1;1]\n  float zoom = 8.;\n  if (keypress(90)) zoom = 2.0;\n  uv *= zoom;  // Zoom out\n  float shift = 0.;\n  if (keypress(88)) shift = 800.0;\n  uv.x += iTime+shift;  // Move up in uv-space!\n  vec2 z = uv.yx;\n  if (keypress(49)) {//1\n      z = clog(eta1(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n  } else if (keypress(50)){//2\n      z = clog(eta2(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n  } else if (keypress(51)){//3\n      z = clog(eta3(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n  } else if (keypress(52)){//4\n      z = clog(eta4(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n  } else if (keypress(53)){//5\n      z = clog(eta5(z))-clog(vec2(1,0)-cpow(2.,vec2(1,0)-z));\n  } else if (keypress(54)){//6\n      z = clog(zeta6(z));  \n  } else if (keypress(55)){//7\n      z = clog(lambda(z))-clog(vec2(1,0)-cpow(2.,-z));\n  } else if (keypress(56)){//8\n      z = loggamma(z);\n  } else {\n      z = logzeta(z);\n  }\n  fragColor.rgb = col(z);\n  float size = 4.*zoom/iResolution.x;\n  if (mod(abs(uv.x),5.)<size)fragColor.rgb = vec3(0.5);\n  if (mod(abs(uv.y),5.)<size)fragColor.rgb = vec3(0.5);\n  if (abs(uv.y-.5)<size)fragColor.rgb = vec3(1);\n  float x = abs(uv.x);\n  if (abs(x-zeros[binarysearch(x)])<size)fragColor.rgb = vec3(1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssKBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[13037, 13130, 13160, 13160, 13189], [13190, 13190, 13220, 13220, 13275], [13276, 13276, 13295, 13295, 13327], [13328, 13328, 13358, 13358, 13428], [13429, 13429, 13450, 13450, 13496], [13497, 13497, 13519, 13519, 13606], [13607, 13607, 13628, 13628, 13653], [13654, 13654, 13684, 13684, 13784], [13785, 13785, 13815, 13815, 13881], [13882, 13882, 13902, 13902, 13951], [13952, 13952, 13972, 13972, 14030], [14031, 14031, 14051, 14051, 14128], [14129, 14129, 14158, 14158, 14191], [14192, 14192, 14212, 14212, 14290], [14291, 14291, 14313, 14313, 14495], [14563, 14563, 14585, 14585, 14754], [14757, 14757, 14774, 14774, 14889], [14893, 14925, 14948, 14948, 15438], [15441, 15487, 15509, 15509, 15609], [15612, 15628, 15646, 15646, 15789], [15791, 15809, 15827, 15827, 16147], [16152, 16327, 16346, 16346, 16746], [16748, 16866, 16884, 16884, 17536], [17539, 17539, 17559, 17559, 17643], [17647, 17777, 17795, 17795, 18203], [18207, 18357, 18376, 18376, 18642], [18644, 18795, 18815, 18815, 18941], [18944, 18944, 18965, 18965, 19115], [19117, 19117, 19135, 19135, 19170], [19172, 19172, 19194, 19194, 19303], [19305, 19305, 19331, 19331, 19589], [19591, 19591, 19615, 19615, 19676], [19678, 19678, 19733, 19733, 21078]], "test": "untested"}
{"id": "fsSBWt", "name": "A Blobby Mass", "author": "Plento", "description": "System where particles repel each other and also a force pushes them toward the center of the screen, making a blobby thing.", "tags": ["2d", "mouse", "particles", "blob", "soft"], "likes": 47, "viewed": 598, "published": 3, "date": "1657687861", "time_retrieved": "2024-07-30T16:40:41.698846", "image_code": "// Cole Peterson (Plento)\n\n\n/*\n    System where particles repel each other and also a force pushes them\n    toward the center of the screen, making a blobby thing.\n*/\n\n// A few drawing options\n#define DRAW_CLOUDS\n#define DRAW_PARTICLES\n#define DRAW_BORDER\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec3 col = vec3(0.);\n    \n    // Draw particles and cloudy smoothmin stuff\n    float md = 999.;\n    for(int i = 0; i < nParticles; i++){\n        float d = length(u - ch(iChannel0, vec2(i,0.)).xy);\n       \n        #ifdef DRAW_CLOUDS\n        md = smoothmin(md, d, 90.); \n        col += (ss(10.,1., md)) * (.5+.5*cos(vec3(3.0, 1.8, 0.4)*float(md)*.02));\n        #endif\n        \n        #ifdef DRAW_PARTICLES\n        col = mix(vec3(10), col, ss(.008*R.y,.008*R.y + 5., d));\n        #endif\n    }\n    \n    col /= float(nParticles);\n    col *= .6;\n    \n    // Blob border\n    #ifdef DRAW_BORDER\n    col = mix(vec3(.5), col, ss(R.y*.0003, R.y*.0003 + 0.3, abs(md*.1)));\n    #endif\n    \n    f = vec4(1.-exp(-col*col*5.), 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A: Track particles.\n\n// Apply force toward center of screen\nvec2 radialForce(vec2 pos){\n    vec2 v = R.xy*.5 - pos;\n    float d = (R.y*.5) - max(length(v), 4.);\n    return normalize(v)*(60. / (d*d));\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    ivec2 iu = ivec2(u);\n    \n    // Only do this pixel if its for a particle\n    if(iu.x < nParticles || iu.y == 0){\n        // The particle info in this pixel\n        vec4 bA = ch(iChannel0, u);\n    \n        // Loop through all particles\n        for(int i = 0; i < nParticles; i++){\n            // Not looking at self\n            if( i != iu.x){\n                // Calculate repulsive force from each particle\n                vec2 p = ch(iChannel0, vec2(i,0.)).xy;\n                vec2 v = bA.xy - p;\n     \t\t\tfloat d = max(length(v), 10.0);\t   \n                \n                // Apply repulsive force\n                bA.zw += (150.0 / (d*d))*normalize(v)*dt;\n            }\n    \t}\n        \n        // Mouse\n        if(iMouse.z > 0.){\n            vec2 v = bA.xy - iMouse.xy;\n         \tfloat r = mForce / max(length(v), .001);\n            vec2 n = normalize(v);\n            bA.zw += r*n*dt;\n        }\n        \n        // Apply force from the edges of the bounds\n        bA.zw += dt*bForce*radialForce(bA.xy);\n        \n        // Update position and velocity\n        bA.xy += bA.zw*dt;\n        //bA.zw -= friction*bA.zw*dt*iTimeDelta;\n        bA.zw -= friction*bA.zw*dt;\n        // Limit max velocity\n        bA.zw = clamp(bA.zw, -maxVel, maxVel);\n        \n        // Init\n    \tif(iFrame < 5){\n            bA.xy = hash22(u)*R.xy * 0.5 + R.xy*0.25;\n            bA.zw = vec2(0);\n    \t}\n        \n        f = bA;\n    }\n    else return;\n   \n    \n    \n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define ss(a, b, t) smoothstep(a, b, t)\n#define ch(chan, p) texelFetch(chan, ivec2(p), 0)\n\n// Number of particles\nconst int nParticles = 200;\n\n// Sim speed\nfloat dt = .7;\n\n// Radial force (force pushing inward)\nconst float bForce = 320.;\n\n// Mouse force\nconst float mForce = 250.f;\n\n// Max velocity\nconst vec2 maxVel = vec2(8.);\n\n// Particle friction\nconst float friction = .0065;\n\n\n// Dave Hoshkin hash https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat smoothmin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsSBWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 298, 298, 1027]], "test": "untested"}
{"id": "7sKfzR", "name": "Spherical Harmonic Irradiance", "author": "BeardThings", "description": "Visualization of Spherical Harmonics for illustrative purposes", "tags": ["visualization", "spherical", "harmonics"], "likes": 1, "viewed": 370, "published": 3, "date": "1657666959", "time_retrieved": "2024-07-30T16:40:42.461806", "image_code": "\n#define DISTANCE 7.0\n#define VIEW_IRRADIANCE_CURVE\n//#define VIEW_THETA\n#define VIEW_PHI\n\nconst int VIEW_SH = 0;\nconst int VIEW_IRRADIANCE = 1;\n\nconst int view = VIEW_SH;\n\nvec3 irradiance(vec3 n)\n{\n    float theta = acos(n.y);\n    float phi = atan(n.z,n.x);\n    phi = phi < 0.0 ? 2.0*PI + phi : phi;\n    return texture(iChannel1,vec2(phi/(2.0*PI), theta/PI)).rgb;\n}\n\nfloat sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nvec4 sh_cosine_projected(vec3 d)\n{\n    vec4 coefs = vec4(\n        0.88622692545,\n        -1.02332670795,\n        1.02332670795,\n        -1.02332670795);\n   return vec4(1.0,d.zyx) * coefs;\n}\n\nfloat SDF(vec3 p, out vec3 c)\n{\n    vec3 d = normalize(p);\n    vec3 r = irradiance(d);\n    \n    vec4 sh = texelFetch(iChannel2, ivec2(0,0), 0);\n    float shR = dot(sh_cosine_projected(d),sh);\n    \n    float radius = 0.0;\n    if(view == VIEW_IRRADIANCE)\n    {\n        radius = r.r;\n    }\n    else if(view == VIEW_SH)\n    {\n        radius = shR;\n    }\n\n    c = vec3(1.0,1.0,1.0) * radius/PI;\n    return sphere(p, radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    float time = iTime * 0.25;\n    vec3 o = vec3(sin(time), 0.0, cos(time)) * DISTANCE;\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = normalize(f * 2.0 + \n                         r * screenSpace.x * iResolution.x / iResolution.y +\n                         u * screenSpace.y);\n\n    fragColor = texture(iChannel0,direction);\n    \n    float d = 0.0;\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        vec3 c;\n        float sdf = SDF(pos, c);\n        d += sdf*0.4;\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {   \n            fragColor.rgb = c;\n            break;\n        }\n    }\n    \n#ifdef VIEW_IRRADIANCE_CURVE\n    {\n#ifdef VIEW_PHI\n        vec3 li = texture(iChannel1,vec2(uv.x,iMouse.x/iResolution.x)).rgb/PI;\n#elif defined(VIEW_THETA)\n        vec3 li = texture(iChannel1,vec2(iMouse.x/iResolution.x,uv.x)).rgb/PI;\n#endif\n        float r = clamp(1.0-abs(li.r - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        float g = clamp(1.0-abs(li.g - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        float b = clamp(1.0-abs(li.b - uv.y)*(iResolution.y/3.0),0.0,1.0);\n        fragColor.rgb = vec3(r,g,b)+fragColor.rgb*0.75;\n    }\n#endif // VIEW_IRRADIANCE_CURVE\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Irradiance calculation\n\nconst float golden = (1.0 + sqrt(5.0))/2.0;\nfloat N = 256.0 * 32.0;\n// Progressively refine our integration\nfloat NPerFrame = 64.0;\n\n// http://extremelearning.com.au/how-to-evenly-distribute-points-on-a-sphere-more-effectively-than-the-canonical-fibonacci-lattice/\nvec3 hemisphere_fibonacci(float i)\n{\n\tvec2 uv = vec2(fract(i/golden),i/N);\n    vec2 s = vec2(2.0*PI*uv.x,acos(1.0-uv.y));\n\n\treturn vec3(cos(s.x)*sin(s.y), cos(s.y), sin(s.x)*sin(s.y));\n}\n\nvec3 irradiance(vec3 n, float prevN)\n{\n    vec3 r = n.x < 0.99999 ? vec3(1.0,0.0,0.0) : vec3(0.0,-1.0,0.0);\n    vec3 f = normalize(cross(n,r));\n    r = normalize(cross(f,n));\n    vec3 u = n;\n    \n    vec3 ir = vec3(0.0,0.0,0.0);\n    \n    for(float n = prevN; n < prevN + NPerFrame; n += 1.0)\n    {\n        vec3 d = hemisphere_fibonacci(n);\n        vec3 rd = normalize(d.x * r + d.y * u + d.z * f);\n        ir += srgb_to_linear(texture(iChannel0, rd).rgb) * d.y;\n    }\n    ir *= 2.0 * PI;\n    \n    return ir;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 s = vec2(uv.x * 2.0 * PI, uv.y * PI);\n\n    vec3 n = vec3(cos(s.x)*sin(s.y),cos(s.y),sin(s.x)*sin(s.y));\n\n    vec4 prev = texelFetch(iChannel1, ivec2(fragCoord), 0);\n\n    if(prev.a < N)\n    {\n        float newN = prev.a + NPerFrame;\n        vec3 prevIrradiance = prev.rgb * prev.a;\n        fragColor.rgb = (prevIrradiance + irradiance(n, prev.a)) / newN;\n        fragColor.a = newN;\n    }\n    else\n    {\n        fragColor = prev;\n    }\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.1415926\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see âNumerical Methods in C: The Art of Scientific Computingâ, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    \n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for ( int i=1; i<=m; i++ ) {\n        pmm *= (-fact) * somx2;\n        fact += 2.0;\n    }\n    \n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - m));\n    float d = 4.0 * PI * float(factorial(l + m));\n    return sqrt(n/d);\n}\n\nfloat y(int l, int m, float cosTheta, float phi)\n{\n    float v = K(l, abs(m)) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    \n    if(m > 0)\n        v *= cos(float(m)*phi);\n    if(m < 0)\n        v *= sin(float(-m)*phi);\n    \n    return v;\n}\n\nvec3 srgb_to_linear(vec3 srgb)\n{\n    return pow(srgb, vec3(2.2));\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame<=10)\n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        vec2 s = vec2(uv.x * 2.0 * PI, uv.y * PI);\n\n        vec3 n = vec3(cos(s.x)*sin(s.y),cos(s.y),sin(s.x)*sin(s.y));\n\n        float phiSlice = 2.0 * PI / iResolution.x;\n        float thetaSlice = PI / iResolution.y;\n        float w = phiSlice * thetaSlice * sin(s.y);\n\n        vec3 t = srgb_to_linear(texture(iChannel0,n).rgb);\n        float l0m0 = t.r * y(0,  0, cos(s.y), s.x) * w;\n        float l1m0 = t.r * y(1, -1, cos(s.y), s.x) * w;\n        float l1m1 = t.r * y(1,  0, cos(s.y), s.x) * w;\n        float l1m2 = t.r * y(1,  1, cos(s.y), s.x) * w;\n\n        fragColor = vec4(l0m0, l1m0, l1m1, l1m2);\n    }\n}", "buffer_b_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if(iFrame <= 10)\n    {\n        vec4 l1 = vec4(0.0,0.0,0.0,0.0);\n        if(int(fragCoord.x)==0 && int(fragCoord.y)==0)\n        {\n            for(int y = 0; y < int(iResolution.y); y++)\n            {\n                for(int x = 0; x < int(iResolution.x); x++)\n                {\n                    l1 += texelFetch(iChannel0, ivec2(x,y), 0);\n                }\n            }\n        }\n        fragColor = l1;\n    }\n    else\n    {\n        fragColor = texelFetch(iChannel1, ivec2(0.0,0.0), 0);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 198, 198, 366], [368, 368, 399, 399, 427], [429, 429, 463, 463, 618], [620, 620, 651, 651, 1041], [1043, 1043, 1100, 1100, 2477]], "test": "untested"}
{"id": "NdKBzh", "name": "Flow of the Flock", "author": "Plento", "description": "Flocking example intended to demonstrate the basic idea of these kinds of algorithms. Will expand and improve it later. Mouse click randomizes their position", "tags": ["mouse", "buffer", "flocking", "boids"], "likes": 28, "viewed": 647, "published": 3, "date": "1657665007", "time_retrieved": "2024-07-30T16:40:43.215790", "image_code": "// Cole Peterson\n\n// Image: display buffer B\n\n\n/*\n    Shader is intended to show a basic flocking algorithm with no extras.\n    Algorithm can be modified to add non 360 degree view and smoothing but right now its barebones.\n    \n    Mouse click randomizes their position\n    \n*/\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec4 bB = texture(iChannel0, u / R);\n    f = vec4(.44*vec3(texture(iChannel0, u / R).w), 1.);\n    f.xyz += 1. - exp(-bB.xyz);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Buffer A: Simple particle tracking + flocking algorithm\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    \n    // Only deal with the pixels representing our boids\n    if(int(u.x) < nParticles && int(u.y) == 0){\n        vec4 bA = A(ivec2(u)); // .xy = position | .zw = velocity ie. the current Boid\n        \n        bA.xy += bA.zw*dt; // Update position\n\n        vec2 avgDir = vec2(0); // Average direction of all boids in the sight radius\n        vec2 avgPos = vec2(0); // Average position of all boids in the sight radius\n        \n        float nb = 0.; // Number of boids in sight of current boid\n        \n        // Go through all particles\n        for(int i = 0; i < nParticles; i++){\n            vec4 p = A(vec2(i, 0)); // Boid position and velocity ie \"this\" Boid\n            float d = length(bA.xy - p.xy); // Distance from this Boid to current Boid\n            \n            // This boid is in sight\n            if(d <= radius){\n                avgDir += p.zw;\n                avgPos += p.xy;\n                nb++;\n            }\n            \n            // This boid is too close, push away\n            if(d <= minSep){\n                vec2 dir = normalize(p.xy - bA.xy);\n                bA.xy -= dir * minSep*.008;\n            }\n        }\n        \n        // At least 1 boid in sight\n        if(nb > 0.){\n            avgPos /= nb;\n            bA.zw = normalize(avgDir) * speed; // Set new velocity based on avg direction\n            \n            vec2 dir = normalize(avgPos - bA.xy); // Move boid in direction of avg position of boids in sight\n            bA.zw += dir * 0.1;\n        }\n        \n        // Add some randomness to their direction\n        bA.z += .22*cos(iTime + u.x*555.);\n        bA.w += .22*sin(iTime*1.3 + u.x*355.);\n        \n        \n        // Randomize position\n        if(iMouse.z > 0.){\n           bA.xy = hash22(u*999. + 522.2 + iDate.w)*R.xy * 0.7 + R.xy*0.15;\n        }\n        \n\n        // Repeat coordinates\n        bA.xy = mod(bA.xy, R.xy);\n        \n\n        // Init boid position\n        if(iFrame < 4){\n            bA.xy = hash22(u*999. + 522.2 + iDate.w)*R.xy * 0.7 + R.xy*0.15;\n            bA.zw = (2.*hash22(u*999. + 322.2) - 1.) * .4;\n        }\n        \n        f = bA;\n    }\n    else\n        return;\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n#define KEY(v,m) texelFetch(iChannel1, ivec2(v, m), 0).x\n#define ss(a, b, t) smoothstep(a, b, t)\n#define A(p) texelFetch(iChannel0, ivec2(p), 0)\n\nconst int nParticles = 280; // Number of boids\n\nfloat dt = 0.7; // Simulation speed\n\n// Sim values\nconst float radius = 33.; // Boid sight radius\nconst float minSep = 33.; // Boid minimum seperation\nconst float speed = 2.2; // Boid movement speed \n\n// Render values\nconst float rad = 0.0075;\nconst float trail = 0.97;\n\n\nconst float obRad = 45.; // Obstacle radius\n\n// Hash from Dave Hoshkin https://www.shadertoy.com/view/4djSRW\nvec2 hash22(vec2 p){\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n", "buffer_b_code": "\n// Buffer B: Render particles and do ghosting effect (only reason it has its own buffer)\n\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec4 bB = texture(iChannel1, u / R);\n    \n    // Go through boidzz\n    for(int i = 0; i < nParticles; i++){\n        vec2 p = A(ivec2(i, 0)).xy; // Boid pos\n        vec2 v = A(ivec2(i, 0)).zw; // Boid vel\n        \n        float d = length(p - u.xy); // Distance from pixel to boid\n        vec3 c = 0.5 + 0.5*cos(vec3(4., 1., 2.)*float(i)*53.); // Boid color\n        bB.xyz = mix(bB.xyz, c, ss(rad*R.y, rad*R.y - 1., length(d))); // Add boid to color\n        \n        float sd2 = ss(.4*rad*R.y, .4*rad*R.y - 1., length(d));\n        bB.w = mix(bB.w, 1., sd2);\n    }\n    \n    // Leave trail\n    bB.xyz *= .8;\n    bB.w *= trail;\n    \n    f = bB;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdKBzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 321, 321, 453]], "test": "untested"}
{"id": "NdVfRh", "name": "Turbo Rainbow Dissolver", "author": "leon", "description": "starting an iridescent latex fetish", "tags": ["noise", "abstract", "rainbow"], "likes": 46, "viewed": 1054, "published": 3, "date": "1657664308", "time_retrieved": "2024-07-30T16:40:43.982740", "image_code": "\n// popping shapes in a turbo rainbow dissolver\n\n// main code is in Buffer A\n// Buffer B is a minimal temporal anti aliasing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// fractal brownian motion https://thebookofshaders.com/13/\n// with a \"abs(sin(value))\" twist \nvec3 fbm (vec3 p)\n{\n    vec3 result = vec3(.0);\n    float a = .5;\n    for (float i = 0.; i < 3.; ++i) {\n        result += abs(sin(texture(iChannel1, p/a).xyz*6.))*a;\n        a /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // timing\n    float time = iTime;\n    float anim = fract(time);\n    float index = floor(time);\n    \n    // noise animation\n    float scale = .1-anim*.05;\n    vec3 seed = p * scale + index * .12344;\n    vec3 noise = fbm(seed);\n    \n    // shapes and distortions\n    float size = .5*pow(anim,.2);\n    float type = mod(index, 3.);\n    dist = type > 1.5 ? sdTorus(p, vec2(size, .1)) :\n           type > .5 ? sdBox(p,vec3(size*.7)) :\n           length(p)-size;\n    dist -= anim * noise.x * .2;\n    dist += pow(anim, 3.) * noise.y;\n    \n    // scale field when highly distorted to avoid artefacts\n    return dist * (1.-anim*.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    \n    // background\n    vec3 color = vec3(.5)*smoothstep(2.,.5,length(uv));\n    \n    // coordinates\n    vec3 pos = vec3(0,0,-1.5);\n    pos.xz *= rot(iTime*.1);\n    pos.zy *= rot(sin(iTime*.2));\n    vec3 ray = lookAt(pos, vec3(0), uv, 1.5);\n    \n    // noise\n    vec3 blue = texture(iChannel0, fragCoord/1024.).xyz;\n    \n    // raymarch\n    const float count = 30.;\n    float steps = 0.;\n    float total = 0.;\n    for (steps = count; steps > 0.; --steps) {\n        float dist = map(pos);\n        if (dist < total/iResolution.y || total > 3.) break;\n        dist *= 0.9+0.1*blue.z;\n        pos += ray * dist;\n        total += dist;\n    }\n    \n    // coloring\n    float shade = steps/count;\n    if (shade > .001 && total < 3.) {\n    \n        // NuSan https://www.shadertoy.com/view/3sBGzV\n        vec2 noff = vec2(.02,0);\n        vec3 normal = normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n        \n        color = vec3(.1);\n        float light = dot(reflect(ray, normal), vec3(0,1,0))*.5+.5;\n        float rainbow = dot(normal, -normalize(pos))*.5+.5;\n        color += vec3(0.5)*pow(light, 4.5);\n        \n        // Inigo Quilez color palette https://iquilezles.org/articles/palettes/\n        color += (.5+.5*cos(vec3(0.,.3,.6)*6.+uv.y*3.+iTime))*pow(rainbow,4.);\n        color *= pow(shade,.5);\n    }\n    \n    fragColor = vec4(color, 1);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nmat2 rot(float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\nvec3 lookAt (vec3 from, vec3 at, vec2 uv, float fov)\n{\n  vec3 z = normalize(at-from);\n  vec3 x = normalize(cross(z, vec3(0,1,0)));\n  vec3 y = normalize(cross(x, z));\n  return normalize(z * fov + uv.x * x + uv.y * y);\n}\n\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}", "buffer_b_code": "// Temporal Anti Aliasing from:\n// https://www.elopezr.com/temporal-aa-and-the-quest-for-the-holy-trail/\n\n// but only the color clamping...\n// it's very subtle but I like it...\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = texture(iChannel0, uv).rgb;\n    vec3 temporal = texture(iChannel1, uv).rgb;\n    vec3 minColor = vec3(9999.), maxColor = vec3(-9999.);\n    for(int x = -1; x <= 1; ++x){\n        for(int y = -1; y <= 1; ++y){\n            vec3 c = texture(iChannel0, uv + vec2(x, y) / iResolution.xy).rgb;\n            minColor = min(minColor, c);\n            maxColor = max(maxColor, c);\n        }\n    }\n    temporal = clamp(temporal, minColor, maxColor);\n    fragColor.rgb = mix(color, temporal, 0.9);\n    fragColor.a = 1.0;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdVfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 125, 182, 182, 264]], "test": "untested"}
{"id": "ssGfR1", "name": "Frequency oscillations", "author": "ninofiliu", "description": "By piping the frame to itself, I add all the pixels at a distance r and subtract and the pixels at a distance 2*r, thereby maximizing black and white shapes of width r\n\n\"brush\" can be controlled with the mouse", "tags": ["abstract", "frequency", "backbuffer"], "likes": 9, "viewed": 297, "published": 3, "date": "1657651298", "time_retrieved": "2024-07-30T16:40:44.753679", "image_code": "void mainImage(out vec4 color, in vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    color = texture(iChannel0, uv);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float twoRadiuses(vec2 uv, float r) {\n  const int n = 20;\n  const float turn = 6.283185307179586;\n\n  // samples n points on two circles around uv\n  float ret = 0.;\n  for (int i = 0; i < n; i++) {\n    float a = float(i) / float(n) * turn;\n    // first circle (radius 1*r)\n    ret += texture(iChannel0, uv + 1. * r * vec2(cos(a), sin(a))).r;\n    // second circle (radius 2*r)\n    ret -= texture(iChannel0, uv + 2. * r * vec2(cos(a), sin(a))).r;\n  }\n  ret /= float(n) * .3;\n\n  return ret;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n  vec2 uv = coord / iResolution.xy;\n\n  // initializes the color to the color of the corresponding pixel in the last frame\n  color = texture(iChannel0, uv);\n  \n  // the radius r oscillates over time between 0 and 0.1\n  float r = .05 * (0.5 + 0.5 * cos(0.5 * iTime));\n  color += twoRadiuses(uv, r);\n  color = clamp(color, 0., 1.);\n\n  // if clicked on the shader,\n  // then the brush is at the position of the mouse\n  // else the brush position oscillates depending on some easy to get functions\n  vec2 brush = iMouse.z > 0.\n                   ? (iMouse.xy / iResolution.xy)\n                   : (0.5 + 0.3 * vec2(cos(2. * iTime), sin(3.1 * iTime)));\n                   \n  // the brush consists in a white blurry disk\n  color.rgb += clamp(4. - 70. * distance(uv, brush), 0., 1.);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGfR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 47, 47, 127]], "test": "untested"}
{"id": "ssGfRh", "name": "Walking Machine Animation 01", "author": "yasuo", "description": "The following references are that I used to make this walking machine animation:\nhttps://en.wikipedia.org/wiki/Chebyshev_lambda_linkage\nhttps://en.wikipedia.org/wiki/Chebyshev_lambda_linkage#/media/File:Tchebyshevs_plantigrade_machine.gif\n", "tags": ["machineanimation"], "likes": 21, "viewed": 378, "published": 3, "date": "1657638045", "time_retrieved": "2024-07-30T16:40:45.735054", "image_code": "#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .001\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n#define PI 3.141592653589793\n#define ZERO (min(iFrame,0))\n\nstruct MachineAnim {\n    float moveX;\n    float moveY;\n    \n    float moveX2;\n    float moveY2;\n    \n    float a1;\n    float a2;\n};\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// Modified as the 3D version of sdOrientedBox\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdOrientedBox( in vec3 p, in vec3 a, in vec3 b, float th )\n{\n    float l = length(b-a);\n    vec3  d = (b-a)/l;\n    vec3  q = (p-(a+b)*0.5);\n          q.xy = mat2(d.x,-d.y,d.y,d.x)*q.xy;\n          q = abs(q)-vec3(l,th,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);   \n}\n\nfloat sdOrientedBox2( in vec3 p, in vec3 a, in vec3 b, float th )\n{\n    float l = length(b-a);\n    vec3  d = (b-a)/l;\n    vec3  q = (p-(a+b)*0.5);\n          q.xz = mat2(d.x,-d.z,d.z,d.x)*q.xz;\n          q = abs(q)-vec3(l,th,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);   \n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xy),p.z)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvec2 getPointB(vec2 a, float len, float r){\n    return vec2(a.x-cos(r)*len,a.y-sin(r)*len);\n}\n\nvec2 getMidPoint(vec2 a, vec2 b){\n    return vec2((a.x+b.x)*0.5, (a.y+b.y)*0.5);\n}\n\n// main animation logic\nMachineAnim GetAnimationValues(){\n    float totalMoveFrame = 2.0;\n    float halfFrame = totalMoveFrame*0.5;\n    float t = mod(iTime,totalMoveFrame);\n    float moveX = 0.;\n    float moveY = 0.;\n    \n    float moveX2 = 0.;\n    float moveY2 = 0.;\n    \n    float xdist = 0.1;\n    \n    float a1 = 0.0;\n    float a2 = 0.0;\n    if(t<halfFrame){\n        float a = radians(getTime(t,halfFrame)*180.);\n        moveX = cos(a)*xdist;\n        moveY = abs(sin(a)*0.1);\n        \n        moveX2 = -xdist+cubicInOut(t)*(xdist*2.0);\n        \n        a1 = radians(90.)-a;\n        a2 = radians(-90.)-a;\n    } else if(t>=halfFrame && t<totalMoveFrame){\n        t = getTime(t-halfFrame,halfFrame);\n        moveX = -xdist+cubicInOut(t)*(xdist*2.0);\n        \n        float a = radians(t*180.);\n        moveX2 = cos(a)*xdist;\n        moveY2 = abs(sin(a)*0.1);\n        \n        a1 = radians(-90.-getTime(t,halfFrame)*180.);\n        a2 = radians(-270.-getTime(t,halfFrame)*180.);\n    }\n    \n    return MachineAnim(moveX,moveY,moveX2,moveY2,a1,a2);\n}\n\n// 2D version\nfloat chebyshevLambdaLinkageDist(vec2 uv){\n    float lineSize = 0.005;\n    \n    MachineAnim anim = GetAnimationValues();\n    \n    vec2 a1 = vec2(-0.2+anim.moveX,0.2+anim.moveY);\n    vec2 b1 = vec2(-0.2+anim.moveX,-0.2+anim.moveY);\n    \n    vec2 a1_2 = vec2(-0.2+anim.moveX2,0.2+anim.moveY2);\n    vec2 b1_2 = vec2(-0.2+anim.moveX2,-0.2+anim.moveY2);\n    \n    vec2 a2 = vec2(0.2+anim.moveX,0.2+anim.moveY);\n    vec2 b2 = vec2(0.2+anim.moveX,-0.2+anim.moveY);\n    \n    vec2 a2_2 = vec2(0.2+anim.moveX2,0.2+anim.moveY2);\n    vec2 b2_2 = vec2(0.2+anim.moveX2,-0.2+anim.moveY2);\n    \n\n    float segDLen = 0.06;\n    vec2 d1 = getPointB(vec2(-0.075,-0.05),segDLen,anim.a1);\n    vec2 e1 = getPointB(vec2(-0.075,-0.05),segDLen,anim.a2);\n    \n    vec2 d2 = getPointB(vec2(0.075,-0.05),segDLen,anim.a1);\n    vec2 e2 = getPointB(vec2(0.075,-0.05),segDLen,anim.a2);\n    \n    // something complex part\n    float dd = sdSegment(uv,a1,d1)-lineSize;\n    float dd2 = sdSegment(uv,vec2(-0.075,-0.05),d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a2,d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(-0.075,-0.05),e1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a1_2,e1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a2_2,e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(0.075,-0.05),d2)-lineSize;\n    dd = min(dd,dd2);\n    dd2 = sdSegment(uv,vec2(0.075,-0.05),e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,d1,d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,e1,e2)-lineSize;\n    dd = min(dd,dd2);\n    \n    \n    // body\n    vec2 blt = vec2(-0.2,-0.05);\n    vec2 brt = vec2(0.2,-0.05);\n    \n    vec2 mid_a1_d1 = getMidPoint(a1,d1);\n    vec2 mid_a2_d2 = getMidPoint(a2,d2);\n    \n    vec2 mid_a1_2_d1 = getMidPoint(a1_2,e1);\n    vec2 mid_a2_2_d2 = getMidPoint(a2_2,e2);    \n    \n    dd2 = sdSegment(uv,blt,mid_a1_d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,brt,mid_a2_d2)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,blt,mid_a1_2_d1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,brt,mid_a2_2_d2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,blt,brt)-lineSize;\n    dd = min(dd,dd2);\n    \n    \n    // legs\n    dd2 = sdSegment(uv,a1,b1)-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,a1_2,b1_2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,a2,b2)-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,a2_2,b2_2)-lineSize;\n    dd = min(dd,dd2);\n    \n    // foot\n    dd2 = sdSegment(uv,vec2(b1.x-0.03,b1.y),vec2(b1.x+0.03,b1.y))-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(b1_2.x-0.03,b1_2.y),vec2(b1_2.x+0.03,b1_2.y))-lineSize;\n    dd = min(dd,dd2);\n    \n    dd2 = sdSegment(uv,vec2(b2.x-0.03,b2.y),vec2(b2.x+0.03,b2.y))-lineSize;\n    dd = min(dd,dd2);    \n    \n    dd2 = sdSegment(uv,vec2(b2_2.x-0.03,b2_2.y),vec2(b2_2.x+0.03,b2_2.y))-lineSize;\n    dd = min(dd,dd2);        \n    \n    return dd;\n}\n\n// 3D version\nfloat chebyshevLambdaLinkageDist(vec3 p){\n    vec3 prevP = p;\n    float th = 0.01;\n    float z = 0.04;\n    MachineAnim anim = GetAnimationValues();\n    \n    vec3 a1 = vec3(-0.2+anim.moveX,0.2+anim.moveY,-z*2.0);\n    vec3 b1 = vec3(-0.2+anim.moveX,-0.2+anim.moveY,-z*2.0);\n    \n    vec3 a1_2 = vec3(-0.2+anim.moveX2,0.2+anim.moveY2,-z);\n    vec3 b1_2 = vec3(-0.2+anim.moveX2,-0.2+anim.moveY2,-z);\n    \n    vec3 a2 = vec3(0.2+anim.moveX,0.2+anim.moveY,z);\n    vec3 b2 = vec3(0.2+anim.moveX,-0.2+anim.moveY,z);\n    \n    vec3 a2_2 = vec3(0.2+anim.moveX2,0.2+anim.moveY2,0);\n    vec3 b2_2 = vec3(0.2+anim.moveX2,-0.2+anim.moveY2,0);\n    \n\n    float segDLen = 0.06;\n    vec3 d1 = vec3(getPointB(vec2(-0.075,-0.05),segDLen,anim.a1),-z*2.0);\n    vec3 e1 = vec3(getPointB(vec2(-0.075,-0.05),segDLen,anim.a2),-z);\n    \n    vec3 d2 = vec3(getPointB(vec2(0.075,-0.05),segDLen,anim.a1),z);\n    vec3 e2 = vec3(getPointB(vec2(0.075,-0.05),segDLen,anim.a2),0);\n    \n    // something complex part\n    float dd = sdOrientedBox(p,a1,d1,th);\n    float dd2 = sdOrientedBox(p,vec3(-0.075,-0.05,-z*2.0),d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a2,d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(-0.075,-0.05,-z),e1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a1_2,e1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a2_2,e2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(0.075,-0.05,z),d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(0.075,-0.05,0),e2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(d1.xy,-0.02),vec3(d2.xy,-0.02),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(e1.xy,-0.02),vec3(e2.xy,-0.02),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(d1.xy,-0.05),0.012,0.04);\n    dd = min(dd,dd2);    \n    dd2 = sdCappedCylinder(p-vec3(e1.xy,-0.03),0.012,0.02);\n    dd = min(dd,dd2);   \n    dd2 = sdCappedCylinder(p-vec3(d2.xy,0.01),0.012,0.04);\n    dd = min(dd,dd2);  \n    dd2 = sdCappedCylinder(p-e2,0.012,0.03);\n    dd = min(dd,dd2);       \n    \n    \n    // body\n    vec3 blt = vec3(-0.2,-0.05,0.0);\n    vec3 brt = vec3(0.2,-0.05,0.0);\n    \n    vec3 bltZ = vec3(-0.2,-0.05,-0.15);\n    vec3 brtZ = vec3(0.2,-0.05,-0.15);\n    \n    vec3 mid_a1_d1 = vec3(getMidPoint(a1.xy,d1.xy),-z*2.0);\n    vec3 mid_a2_d2 = vec3(getMidPoint(a2.xy,d2.xy),z);\n    \n    vec3 mid_a1_2_d1 = vec3(getMidPoint(a1_2.xy,e1.xy),-z);\n    vec3 mid_a2_2_d2 = vec3(getMidPoint(a2_2.xy,e2.xy),0.0);    \n    \n    dd2 = sdOrientedBox(p,vec3(blt.xy,-z*2.0),mid_a1_d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(brt.xy,z),mid_a2_d2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(blt.xy,-z),mid_a1_2_d1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,brt,mid_a2_2_d2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,blt,brt,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,blt,bltZ,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,brt,brtZ,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox2(p,vec3(-0.075,-0.05,0),vec3(-0.075,-0.05,-0.15),th);\n    dd = min(dd,dd2);\n        \n    dd2 = sdOrientedBox2(p,vec3(0.075,-0.05,0),vec3(0.075,-0.05,-0.15),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(-0.075,-0.05,0.0),0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(-0.2,-0.05,0.0),0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(0.075,-0.05,0.02),0.012,0.03);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-vec3(0.2,-0.05,0.02),0.012,0.03);\n    dd = min(dd,dd2);\n\n    dd2 = sdCappedCylinder(p-mid_a1_d1,0.012,0.01);\n    dd = min(dd,dd2);    \n    dd2 = sdCappedCylinder(p-mid_a2_d2,0.012,0.01);\n    dd = min(dd,dd2);   \n    dd2 = sdCappedCylinder(p-mid_a1_2_d1,0.012,0.01);\n    dd = min(dd,dd2);  \n    dd2 = sdCappedCylinder(p-mid_a2_2_d2,0.012,0.01);\n    dd = min(dd,dd2);   \n    \n    // legs\n    dd2 = sdOrientedBox(p,a1,b1,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,a1_2,b1_2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,a2,b2,th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,a2_2,b2_2,th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a1,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a1_2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    dd2 = sdCappedCylinder(p-a2_2,0.012,0.01);\n    dd = min(dd,dd2);\n    \n    // foot\n    dd2 = sdOrientedBox(p,vec3(b1.x-0.03,b1.y,-z*2.0),vec3(b1.x+0.03,b1.y,-z*2.0),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(b1_2.x-0.03,b1_2.y,-z),vec3(b1_2.x+0.03,b1_2.y,-z),th);\n    dd = min(dd,dd2);\n    \n    dd2 = sdOrientedBox(p,vec3(b2.x-0.03,b2.y,z),vec3(b2.x+0.03,b2.y,z),th);\n    dd = min(dd,dd2);    \n    \n    dd2 = sdOrientedBox(p,vec3(b2_2.x-0.03,b2_2.y,0.0),vec3(b2_2.x+0.03,b2_2.y,0.0),th);\n    dd = min(dd,dd2);        \n    \n    return dd;\n}\n\nvec2 GetDist(vec3 p) {\n    vec3 prevP = p;\n    p.z = abs(p.z)-0.15;\n    float d = chebyshevLambdaLinkageDist(p);\n    p = prevP;\n    float d2 = p.y+0.208;\n    d2 = sdBox(p+vec3(0,0.215,0.0),vec3(0.7,0.005,0.7));\n    vec2 model = vec2(d,MATERIAL);\n    vec2 model2 = vec2(d2,MATERIAL1);\n    \n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<3; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(10,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    //float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(0.1)*diff*occ;\n    diffCol += col*vec3(1.0)*skyDiff*occ;\n    diffCol += col*vec3(1.0)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    float IOR = 2.42; //IOR:index of reflection\n    vec3 rdIn = refract(rd,n,1.0/IOR); \n    vec3 refTex = texture(iChannel0,rdIn).rgb;\n    return refTex;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        vec3 c = vec3(1.2);\n        col = reflectMaterial(p,rd,n);\n    } else if(mat == MATERIAL1){\n        vec3 c = vec3(0.9);\n        col = diffuseMaterial(n,rd,p,c);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0.0, -0.9);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(20.0));\n        ro.xz *= Rot(radians(iTime*10.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = vec3(1.0);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );\n    \n    float dd = B(uv-vec2(-0.65,-0.32),vec2(0.2,0.14));\n    col = mix(col,vec3(0.0),S(dd,0.0));\n    \n    uv-=vec2(-0.65,-0.34);\n    uv*=2.1;\n    dd = chebyshevLambdaLinkageDist(uv);\n    col = mix(col,vec3(1.0),S(dd,0.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 536, 536, 578], [580, 687, 753, 753, 987], [989, 989, 1056, 1056, 1290], [1292, 1350, 1402, 1402, 1509], [1511, 1569, 1600, 1600, 1687], [1689, 1749, 1801, 1801, 1920], [1922, 1922, 1961, 1961, 2006], [2008, 2008, 2035, 2035, 2119], [2121, 2121, 2164, 2164, 2214], [2216, 2216, 2249, 2249, 2298], [2300, 2324, 2357, 2357, 3346], [3348, 3362, 3404, 3404, 6383], [6385, 6399, 6440, 6440, 11395], [11397, 11397, 11419, 11419, 11721], [11723, 11723, 11781, 11781, 12048], [12050, 12050, 12074, 12074, 12275], [12277, 12277, 12319, 12319, 12514], [12516, 12557, 12606, 12606, 12900], [12902, 12902, 12959, 12959, 13559], [13561, 13561, 13608, 13608, 13764], [13766, 13766, 13825, 13825, 14043], [14045, 14045, 14102, 14102, 15155]], "test": "untested"}
{"id": "sdGBRh", "name": "Spherical Harmonic Decomposition", "author": "BeardThings", "description": "Simple spherical harmonic visualization for illustrative purposes of each polar coordinate to gain insight into how each component is composed into the final product.", "tags": ["visualization", "spherical", "harmonics"], "likes": 2, "viewed": 249, "published": 3, "date": "1657635138", "time_retrieved": "2024-07-30T16:40:46.522948", "image_code": "// Visualization of associated legendre polynomials for illustrative purposes\n\n#define PI 3.1415926\n#define L 2\n#define M 0\n\n#define VERTICAL_SLICE\n//#define HORIZONTAL_SLICE\n\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see âNumerical Methods in C: The Art of Scientific Computingâ, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    if ( m > 0 ) {\n        float somx2 = sqrt((1.0-x)*(1.0+x));\n        float fact = 1.0;\n        for ( int i=1; i<=m; i++ ) {\n            pmm *= (-fact) * somx2;\n            fact += 2.0;\n        }\n    }\n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - abs(m)));\n    float d = 4.0 * PI * float(factorial(l + abs(m)));\n    return sqrt(n/d);\n}\n\nfloat y_vertical(int l, int m, float cosTheta)\n{\n    float v = K(l, m) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    return v;\n}\n\nfloat y_horizontal(int l, int m, float phi)\n{\n    float v = 1.0;\n    if(m > 0)\n        v = cos(float(m)*phi);\n    if(m < 0)\n        v = sin(float(-m)*phi);\n    return v;\n}\n\n#define D(v) clamp(1.0 - abs(v) * iResolution.y / 5.0, 0.0, 1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    float a = iResolution.y / iResolution.x;\n\n    vec2 nuv = vec2(uv.x / a, uv.y);\n    \n#ifdef VERTICAL_SLICE\n    float r = y_vertical(L, M, normalize(nuv).y);\n#endif // VERTICAL_SLICE\n\n#ifdef HORIZONTAL_SLICE\n    float r = y_horizontal(L, M, asin(normalize(nuv).y));\n#endif // VERTICAL_SLICE\n    \n    float b = D(length(nuv)-abs(r));\n    float g = D(uv.y);\n    g += clamp(1.0 - abs(uv.x)/(0.01*a), 0.0, 1.0);\n    fragColor = vec4(g + vec3(b,b,0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdGBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 198, 198, 288], [290, 529, 562, 562, 1139], [1142, 1142, 1165, 1165, 1296], [1298, 1298, 1346, 1346, 1449], [1451, 1451, 1496, 1496, 1622], [1690, 1690, 1747, 1747, 2254]], "test": "untested"}
{"id": "sdVfzR", "name": "Spooky alien music", "author": "jarble", "description": "I discovered this strange sound effect while remixing one of my bytebeat songs.", "tags": ["music", "bytebeat"], "likes": 2, "viewed": 273, "published": 3, "date": "1657587801", "time_retrieved": "2024-07-30T16:40:47.369684", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(mod(uv,sound(iTime+uv.x)),1.0,1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 mainSound( in int samp, float time )\n{\n    return sound(time);\n}", "sound_inputs": [], "common_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time);\n    int t1 = t/1024;\n    t = (t*(t1>>7)&t1)-1;\n    //t = ((t*2&t/3))|(t&t/1024)-1;\n\n    \n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 sound(float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    time += 7.;\n    time *= 16000.;\n    result += sound1(time*factor)/(factor);\n    return result;\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdVfzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 156]], "test": "untested"}
{"id": "7sKBzR", "name": "Spherical Harmonic Visualization", "author": "BeardThings", "description": "Simple spherical harmonic visualization for illustrative purposes", "tags": ["visualization", "spherical", "harmonics"], "likes": 5, "viewed": 379, "published": 3, "date": "1657585032", "time_retrieved": "2024-07-30T16:40:48.191486", "image_code": "#define PI 3.1415926\n#define L 2\n#define M 0\n//#define POLYNOMIAL\n#define DISTANCE 2.0\n\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see âNumerical Methods in C: The Art of Scientific Computingâ, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    \n    float somx2 = sqrt((1.0-x)*(1.0+x));\n    float fact = 1.0;\n    for ( int i=1; i<=m; i++ ) {\n        pmm *= (-fact) * somx2;\n        fact += 2.0;\n    }\n    \n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - m));\n    float d = 4.0 * PI * float(factorial(l + m));\n    return sqrt(n/d);\n}\n\nfloat y(int l, int m, float cosTheta, float phi)\n{\n    float v = K(l, abs(m)) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    \n    if(m > 0)\n        v *= cos(float(m)*phi);\n    if(m < 0)\n        v *= sin(float(-m)*phi);\n    \n    return v;\n}\n\nvec3 RayDirection(in vec3 \tforward,\n                  in float \tfocalDistance,\n                  in vec3 \tright,\n                  in vec3 \tup,\n                  in vec2 \tscreenSpaceCoord,\n                  in float \taspectRatioXOverY)\n{\n    return normalize(forward * focalDistance + \n                     right * screenSpaceCoord.x * aspectRatioXOverY +\n                     up * screenSpaceCoord.y);\n}\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\n\nfloat SDF(vec3 p, out vec3 c)\n{\n    vec3 d = normalize(p);\n    float cosTheta = d.y;\n    float phi = atan(d.z,d.x);\n\n    float r = y(L,M,cosTheta,phi);\n    \n#ifdef POLYNOMIAL\n    r = 1.5*y(0,0,cosTheta,phi);\n    r += 0.2*y(1,-1,cosTheta,phi);\n    r += -0.8*y(1,0,cosTheta,phi);\n    r += 0.1*y(1,1,cosTheta,phi);\n#endif // POLYNOMIAL\n    \n    float sphereIntersect = Sphere(p, abs(r));\n    \n    c = mix(vec3(1.0,0.0,0.0), vec3(0.0,1.0,0.0),sign(r)*0.5+0.5);\n    return sphereIntersect;\n}\n\nvec3 Norm(vec3 p)\n{\n    const float cEps = 0.01;\n \n    vec3 c;\n\treturn normalize\n\t(\tvec3\n\t\t(\tSDF(p + vec3(cEps, 0, 0),c\t) - SDF(p - vec3(cEps, 0, 0),c),\n\t\t\tSDF(p + vec3(0, cEps, 0),c\t) - SDF(p - vec3(0, cEps, 0),c),\n\t\t\tSDF(p + vec3(0, 0, cEps),c\t) - SDF(p - vec3(0, 0, cEps),c)\n\t\t)\n\t);\n}\n\nvec4 Sample(vec3 o, vec3 direction)\n{\n    vec4 fc;\n    \n    float d = 0.0;\n    for(float i = 0.; i < 64.; ++i)\n    {\n        vec3 pos = o + direction * d;\n\n        vec3 c;\n        float sdf = SDF(pos, c);\n        d += sdf*0.25;\n        \n        fc = vec4(direction.xy*0.5+0.5, 1.0, 1.0) *0.5;\n        \n        const float EPSILON = 0.01;\n        if(sdf < EPSILON)\n        {   \n            fc.rgb = c*(dot(Norm(pos), vec3(0.707,0.707,0.0))*0.5+0.5);\n            break;\n        }\n        \n        if(d > 30.)\n        {\n            break;\n        }\n    }\n    \n    return fc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 screenSpace = uv * 2.0 - 1.0;\n\t\n    const float height = 0.0;\n    vec3 o = vec3(sin(iTime), 0.0, -cos(iTime)) * DISTANCE;\n    \n    vec3 f = normalize(-o);\n    vec3 u = vec3(0,1,0);\n    vec3 r = normalize(cross(f, u));\n    \n    vec3 direction = RayDirection(f, \n                                  2.0, \n                                  r, \n                                  u, \n                                  screenSpace, \n                                  iResolution.x / iResolution.y);\n    \n    fragColor = Sample(o, direction);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sKBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 110, 110, 200], [202, 441, 474, 474, 1012], [1015, 1015, 1038, 1038, 1159], [1161, 1161, 1211, 1211, 1422], [1424, 1424, 1661, 1661, 1828], [1830, 1830, 1861, 1861, 1889], [1892, 1892, 1923, 1923, 2378], [2380, 2380, 2399, 2399, 2667], [2669, 2669, 2706, 2706, 3242], [3244, 3244, 3301, 3301, 3888]], "test": "untested"}
{"id": "ssVfRR", "name": "Spherical Harmonic Polynomial", "author": "BeardThings", "description": "Visualization of the associated Legendre polynomials for spherical harmonics.", "tags": ["spherical", "harmonics", "polynomials", "legendre"], "likes": 3, "viewed": 308, "published": 3, "date": "1657581541", "time_retrieved": "2024-07-30T16:40:48.995337", "image_code": "// Visualization of associated legendre polynomials for illustrative purposes\n\n#define PI 3.1415926\n#define L 2\n#define M 1\n\nint factorial(int v)\n{\n    int t = 1;\n    for(int i = 2; i < v; i++)\n    {\n        t *= i;\n    }\n    return t;\n}\n\n// Adapted from https://patapom.com/blog/SHPortal/\n// \"Evaluate an Associated Legendre Polynomial P(l,m,x) at x\n// For more, see âNumerical Methods in C: The Art of Scientific Computingâ, Cambridge University Press, 1992, pp 252-254\" \nfloat P(int l, int m, float x )\n{\n    float pmm = 1.0;\n    if ( m > 0 ) {\n        float somx2 = sqrt((1.0-x)*(1.0+x));\n        float fact = 1.0;\n        for ( int i=1; i<=m; i++ ) {\n            pmm *= (-fact) * somx2;\n            fact += 2.0;\n        }\n    }\n    if( l == m )\n        return pmm;\n\n    float pmmp1 = x * (2.0*float(m)+1.0) * pmm;\n    if ( l == m+1 )\n        return pmmp1;\n\n    float pll = 0.0;\n    for ( float ll=float(m+2); ll<=float(l); ll+=1.0 ) {\n        pll = ( (2.0*ll-1.0)*x*pmmp1-(ll+float(m)-1.0)*pmm ) / (ll-float(m));\n        pmm = pmmp1;\n        pmmp1 = pll;\n    }\n\n    return pll;\n}\n\n\nfloat K(int l, int m)\n{\n    float n = float((2*l+1)*factorial(l - abs(m)));\n    float d = 4.0 * PI * float(factorial(l + abs(m)));\n    return sqrt(n/d);\n}\n\nfloat y(int l, int m, float cosTheta)\n{\n    float v = K(l, m) * P(l, abs(m), cosTheta);\n    if(m != 0)\n        v *= sqrt(2.0);\n    return v;\n}\n\n#define D(v) clamp(1.0 - abs(v) * iResolution.y / 3.0, 0.0, 1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.0-1.0;\n\n    float a = iResolution.y / iResolution.x;\n\n    float b = D(uv.y - y(L, M, uv.x));\n    float g = D(uv.y);\n    g += clamp(1.0 - abs(uv.x)/(0.01*a), 0.0, 1.0);\n    fragColor = vec4(g + vec3(b,b,0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssVfRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 147, 147, 237], [239, 478, 511, 511, 1088], [1091, 1091, 1114, 1114, 1245], [1247, 1247, 1286, 1286, 1389], [1457, 1457, 1514, 1514, 1771]], "test": "untested"}
{"id": "fsVfRz", "name": "in-angle test: angle vs. dot", "author": "elenzil", "description": "LEFT: actual angle: acos(dot()) < thresh\nRIGHT: just dot: dot() > thresh.\n\nComparing two methods of deciding if a point is within an angle from another point.", "tags": ["angle"], "likes": 2, "viewed": 209, "published": 3, "date": "1657568087", "time_retrieved": "2024-07-30T16:40:49.825119", "image_code": "const float pi         = 3.14159265359;\nconst float deg_to_rad = pi * 2.0 / 360.0;\n\n\nvoid mainImage( out vec4 RGBA, in vec2 XY )\n{\n    const float pixelSize = 5.0;\n    \n    bool useDotProductInsteadOfActualAngle = false;\n    \n    if (XY.x > iResolution.x / 2.0) {\n        XY.x -= iResolution.x / 2.0;\n        useDotProductInsteadOfActualAngle = true;\n    }\n    \n    vec2 xy = XY;\n    xy.x = xy.x - iResolution.x / 4.0;\n    xy.y = xy.y - iResolution.y / 2.0;\n    xy = floor(xy / pixelSize + 0.5) * pixelSize;\n    \n    float coneAngle = (sin(iTime * 0.3) * 0.5 + 0.5) * 180.0 * deg_to_rad;\n    float cosConeAngle = cos(coneAngle);\n    \n    vec2 forward = vec2(0.0, -1.0);\n\n    float d = clamp(dot(forward, normalize(xy)), -1.0, 1.0);\n    float a = acos(d);\n    \n    RGBA = vec4(0.0, 0.0, 0.0, 1.0);\n    \n    bool inAngle = a < coneAngle;\n    if (useDotProductInsteadOfActualAngle) {\n        inAngle = d > cosConeAngle;\n    }\n    \n    RGBA.rgb = vec3(inAngle ? 0.6 : 0.0);\n    \n    if (length(xy) > min(iResolution.x / 4.0, iResolution.y / 2.0)) {\n        RGBA.rgb *= 0.0;\n    }\n    \n    RGBA.rgb = abs(XY.x - iResolution.x / 2.0) < 1.0 ? vec3(0.2) : RGBA.rgb;    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsVfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 130, 130, 1163]], "test": "untested"}
{"id": "7s3fDs", "name": "Zeta++", "author": "guil", "description": "Riemann zeta function using reflection.\nOriginal by Justaway: https://www.shadertoy.com/view/4lcBDs\nRevised by mia: https://www.shadertoy.com/view/wlKXzh\nI modified the algorithms to improve precision : 4 algorithms for zeta and 2 algoritms for loggamma", "tags": ["zeta", "riemann"], "likes": 5, "viewed": 232, "published": 3, "date": "1657562136", "time_retrieved": "2024-07-30T16:40:50.589076", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Riemann zeta function using reflection.\n// Original by Justaway: https://www.shadertoy.com/view/4lcBDs\n// Revised by mia: https://www.shadertoy.com/view/wlKXzh\n// Use log gamma function to avoid overflow\n//\n// Method: http://numbers.computation.free.fr/Constants/Miscellaneous/zetaevaluations.pdf\n//\n// Also optimize log sin and log cos:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\n//\n// Grid lines at Re(z) = 10n, Im(z) = 0.5 (the critical line)\n//\n// Seems accurate up to about Re(z) = 50 or so, then the reflection starts\n// to be misaligned and the purported roots come away from the critical line.\n//\n// <mouse> to move\n// g: show grid\n// r: don't do the reflection\n// x: show Borwein zeta\n// y: show zeta2\n// z: zoomed view\n//\n////////////////////////////////////////////////////////////////////////////////\n\nconst float PI = 3.141592653589793;\nconst float LOGPI = 1.1447298858494002;\nconst float LOG2PI = 1.8378770664093453;\nconst float LOG2 = 0.6931471805599453;\n\nvec2 cmul(vec2 z1, vec2 z2) {\n  return mat2(z1.x,z1.y,-z1.y,z1.x)*z2;\n}\n\nvec2 cinv(vec2 z) {\n  return vec2(z.x,-z.y)/dot(z,z);\n}\n\nvec2 cdiv(vec2 z1, vec2 z2) {\n  return cmul(z1,cinv(z2));\n}\n\nvec2 cexp(vec2 z) {\n  // If cos and sin were perfect we wouldn't need normalize\n  return exp(z.x)*normalize(vec2(cos(z.y),sin(z.y)));\n}\n\nvec2 clog(vec2 z) {\n  float r2 = dot(z,z);\n  return vec2(0.5*log(r2),atan(z.y,z.x));\n}\n\nvec2 cpow(vec2 z1, vec2 z2) {\n  return cexp(cmul(z2,clog(z1)));\n}\n\nvec2 cpow(int n, vec2 z2) {\n  return cpow(vec2(n,0),z2);\n}\n\nvec2 cpow(float x, vec2 z2) {\n  return cpow(vec2(x,0),z2);\n}\n\nvec2 csin(vec2 z) {\n    return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\nvec2 ccos(vec2 z){\n  z += vec2(0.5*PI,0);\n  return cmul(vec2(0,0.5),cexp(cmul(vec2(0,-1),z))-cexp(cmul(vec2(0,1),z)));\n}\n\n// Approximations to log(sin(z)) and log(cos(z)) from David Young:\n// https://uk.mathworks.com/matlabcentral/fileexchange/32947-logarithm-of-complex-sine-and-cosine-avoiding-overflow\nvec2 clogsin(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(1.5*pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(0.5*pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(sin(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(1.5*PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(0.5*PI+x, 2.0*PI) - PI);\n  else return clog(csin(z));\n}\n\nvec2 clogcos(vec2 z) {\n  float x = z.x, y = z.y;\n  const float ylimit = 8.0; // Approx. -log(eps)/2.0, 32 bit eps = 6e-8 \n  //z(posy) = y(posy) - 0.693147180559945 + 1i * (mod(pi-x(posy), 2*pi) - pi);\n  //z(negy) = -y(negy) - 0.693147180559945 + 1i * (mod(pi+x(negy), 2*pi) - pi);\n  //z(normal) = log(cos(z(normal)));\n  if (y > ylimit) return vec2(y - LOG2, mod(PI-x, 2.0*PI) - PI);\n  else if (y < -ylimit) return vec2(-y - LOG2, mod(PI+x, 2.0*PI) - PI);\n  else return clog(ccos(z));\n}\n\n// Lanczos approximation for Gamma function\n// See Numerical Recipes\nconst float[8] p = float[](\n  676.5203681218851,\n  -1259.1392167224028,\n  771.32342877765313,\n  -176.61502916214059,\n  12.507343278686905,\n  -0.13857109526572012,\n  9.9843695780195716e-6,\n  1.5056327351493116e-7\n);\n\nvec2 cloggammaR(vec2 z) {\n  z -= vec2(1,0);\n  vec2 x = vec2(-1.9007e-13,0); // 0.99999999999980993 - 1\n  vec2 pval;\n  int N = 8;\n  // Add smallest first for hopefully increased accuracy.\n  for (int i = N-1; i >= 0; i--) {\n    x += p[i]*cinv(z+vec2(float(i+1),0));\n  }\n  x += vec2(1,0);\n  vec2 t = z + vec2(float(N)-0.5,0);\n  // Original non-log function\n  //return cmul(cmul(cmul(vec2(sqrt(2.0*PI),0.0),cpow(t,z+vec2(0.5,0.0))),cexp(-t)),x);\n  vec2 a = vec2(0.5*LOG2PI,0);\n  vec2 b = cmul(clog(t),z+vec2(0.5,0));\n  vec2 c = -t;\n  vec2 y = a+b+c+clog(x);\n  return y;\n}\n\nvec2 cloggammaL(vec2 z) {\n  vec2 a = vec2(LOGPI,0);\n  vec2 b = clogsin(PI*z);\n  vec2 c = cloggammaR(vec2(1,0)-z);\n  vec2 y = a-b-c;\n  return y;\n}\n\nvec2 cloggamma(vec2 z) {\n  if(z.x > 0.0) return cloggammaR(z);\n  else return cloggammaL(z);\n}\n\n// Spouge's method for loggamma\nvec2 logspouge(vec2 z){\n    const int N = 16;\n    float c = sqrt(2.*PI);\n\tvec2 s = vec2(c,0.);\n    float f = 1.;\n\tfor(int k = 1; k<N ;k++){\n\t\tc = exp(float(N-k)) * pow(float(N-k),float(k)-.5)/f;\n        f *= -float(k);\n        s += c*cinv(z+vec2(float(k),0.));\n\t}\t   \n    //s = cmul(s,cmul(cexp(-z-vec2(float(N),0.)),cpow(z+vec2(float(N),0.),z+vec2(.5,0.))));\n    //return cdiv(s,z);\n    s = clog(s); \n    s += -z - vec2(float(N),0.) + cmul(z+vec2(.5,0.), clog(z+vec2(float(N),0.)));\n    return s-clog(z);      \n}\n\nvec2 loggamma(vec2 z){\n  if(z.x > 0.5) return cloggammaR(z);\n  return vec2(LOGPI,0)-clogsin(PI*z)-logspouge(vec2(1,0)-z);\n}\n    \n\n//Basic : using eta definition\nvec2 zeta1(vec2 z){\n  const float N = 256.;\n  vec2 eta = vec2(0);\n  float s=1.;\n  for(float i = 0.; i < N; i++)\n    eta += s*cpow(i+1.,-z),s*=-1.;\n  return cdiv(eta,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\n//Knopp and Hasse\nvec2 zeta2(vec2 z){\n  const float N = 64.;\n  vec2 sum = vec2(0);\n  for(float i = 0.; i < N; i++){\n    vec2 term = vec2(0);\n    float s = 1.;\n    float bnk = 1.;\n    for(float k = 0.; k < i+1.; k++){\n       term += s*bnk* cpow(k+1.,-z);\n       bnk *= (i-k)/(k+1.);\n       s*=-1.;\n       }\n    sum += term/pow(2.,i+1.);\n    }\n  return cdiv(sum,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\n//Same algorithm as in mia shader but extended to N = 40\n//ek coeff are calculated on the fly\nvec2 zeta3(vec2 s) {\n  const int N = 80;  \n\n  vec2 sum1 = vec2(0);\n  float a = 1.0;\n  for(int i = 1; i <= N; i++) {\n    sum1 += a*(cpow(float(i), -s));\n    a = -a;\n  }\n  vec2 sum2 = vec2(0);\n  a = -1.0;\n  float bk= 1.0/pow(2.,float(N));\n  float ek= bk;\n  for(int i = 0 ; i <  N; i++) {\n    sum2 += a*ek*(cpow(float(2*N-i),-s));\n    bk *= float(N-i)/float(i+1);\n    ek += bk;    \n    a = -a;\n  }\n\n  return cdiv(sum1 + sum2, vec2(1,0) - cpow(2, vec2(1,0) - s));\n}\n\n\n//Borwein method, valid for z.x > 0    \nvec2 zeta4(vec2 z){\n        \n    int n=30;\n    vec2  eta = vec2(0.);\n\tfloat sig = 1.;\n    float dnn = 1.;//pow(2.,-126.);    \n    float val = dnn;\n\tfor(int i = 1; i<=n ;i++){\n\t\tval *= 2.*float((n+i-1)*(n-i+1))/float((2*i-1)*i);\n\t\tdnn+= val;\t\t\n\t}\n    float dni = 1./dnn;\n    val = dni;\n    for (int i = 1; i < n ; i++) {\n        vec2 s = cpow(float(i),-z);\n        float ci = 1.- dni;\n        eta += sig*ci*s;\n        sig *= -1.;\n        val *= 2.*float((n+i-1)*(n-i+1))/float((2*i-1)*i);\n        dni +=val;\n        }\n    return cdiv(eta,vec2(1,0)-cpow(2.,vec2(1,0)-z));\n}\n\nvec3 gradient(float theta) {\n    vec3 color = vec3(0);\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((2.0 * PI-theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs(-theta * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,0) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 2.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,1,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(0,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 4.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    color += vec3(1,0,1) * smoothstep(0.0, 1.0, clamp(1.0 - abs((PI * 5.0 / 3.0 - theta) * PI / 3.0), 0.0, 1.0));\n    return color*(fract(theta / PI * 10.0) / 2.0 + 0.5);\n}\n\nvec3 plotDomain(vec2 z) {\n    float theta = mod(atan(z.y, z.x), 2.0 * PI);\n    float  r = length(z);\n    return gradient(theta) * (fract(log2(r)) / 2.0 + 0.5)*exp(-.05*log(r));\n}\n\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1), rgb, c.y);\n}\n\nbool keypress(int key) {\n    return texelFetch(iChannel0, ivec2(key,2),0).x != 0.0;\n}\n\nconst int CHAR_G = 71;\nconst int CHAR_R = 82;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    vec2 offset = vec2(3.0*iTime,0);\n    if (iMouse.x > 0.0) {\n      offset -= (2.0*iMouse.xy - iResolution.xy)/iResolution.x*100.0;\n    }\n    float zoom = 10.0;\n    if (keypress(CHAR_Z)) zoom = 2.0;\n    vec2 z = (zoom*uv + offset).yx; // Scale and shift\n    vec2 z0 = z; // Starting value of z\n    if (keypress(CHAR_X)) {\n      z = zeta2(z);\n    } else if (keypress(CHAR_Y)){\n      z = zeta4(z);\n    } else if (keypress(CHAR_W)){\n      z = zeta1(z);\n    } else if (keypress(CHAR_R) || z.x > 0.5){\n      z = zeta3(z);\n    } else {\n      // Reflection\n      vec2 temp = zeta3(vec2(1,0)-z);\n      temp = clog(temp);\n      temp -= loggamma(z)+vec2(LOG2,0);\n      temp += LOG2PI*z;\n      temp -= clogcos(0.5*PI*z);\n      temp = cexp(temp);\n      z = temp;\n    }\n    vec3 color = plotDomain(z);\n    //color = hsv2rgb(vec3(atan(z.y,z.x)/(2.0*PI),1,1));\n    //float k = log(length(z));\n    //k = max(k,1.0/k);\n    //color = hsv2rgb(vec3(k,1,1));\n    if (keypress(CHAR_G)) {\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.x-0.5)));\n      color = mix(vec3(0),color, smoothstep(0.0,0.03,abs(z0.y-10.0*round(z0.y/10.0))));\n    }\n    fragColor = vec4(color,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3fDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1131, 1131, 1160, 1160, 1202], [1204, 1204, 1223, 1223, 1259], [1261, 1261, 1290, 1290, 1320], [1322, 1322, 1341, 1401, 1457], [1459, 1459, 1478, 1478, 1545], [1547, 1547, 1576, 1576, 1612], [1614, 1614, 1641, 1641, 1672], [1674, 1674, 1703, 1703, 1734], [1736, 1736, 1755, 1755, 1836], [1838, 1838, 1856, 1856, 1958], [1960, 2143, 2165, 2165, 2644], [2646, 2646, 2668, 2668, 3131], [3418, 3418, 3443, 3443, 3985], [3987, 3987, 4012, 4012, 4132], [4134, 4134, 4158, 4158, 4227], [4229, 4261, 4284, 4284, 4774], [4776, 4776, 4798, 4798, 4899], [4906, 4937, 4956, 4956, 5136], [5138, 5156, 5175, 5175, 5532], [5534, 5628, 5648, 5648, 6089], [6092, 6132, 6151, 6151, 6703], [6705, 6705, 6733, 6733, 7572], [7574, 7574, 7599, 7599, 7752], [7754, 7754, 7781, 7781, 7955], [7957, 7957, 7981, 7981, 8042], [8183, 8183, 8236, 8236, 9462]], "test": "untested"}
{"id": "7dGfzR", "name": "Texture Tiling Hider Square", "author": "gehtsiegarnixan", "description": "Simpler variant of Directional Flow use to hide the repeating Tiling by rotating cells in random directions. ", "tags": ["barycentric", "flow", "pattern", "hex", "directional", "dodecahedron", "vectorfield", "stochastic", "direction", "byexample"], "likes": 7, "viewed": 334, "published": 3, "date": "1657562097", "time_retrieved": "2024-07-30T16:40:51.344058", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a simple variant of the Square Directional Flow. This one simply doesn't move.\nIt is a great way to create a non repeating tiling. \nThis uses 3 cheap hash calls, and 3 texture lookups.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n\nThis is also an alternet version of by-example stochastic textureing:\nhttps://inria.hal.science/hal-01824773\n*/\n\n//#define RepeatTiling\n//#define ShowGrid\n\n// My customized hash which is faster than a texture lookup\n// inspired by David Hoskins https://www.shadertoy.com/view/XdGfRR\n#define VPRIME1 uvec2(3480082861U, 2420690917U)\n#define VPRIME2 uvec2(1317666547U, 2149110343U)\n#define SMALLESTFLOAT (1.0 / float(0xffffffffU))\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * VPRIME1;\n\tq = (q.x & q.y) * VPRIME2;\n\treturn vec2(q) * SMALLESTFLOAT;\n}\n\n// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal \n{\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// Square tiling function, 0 and negative values don't work\ntilingVal squareTile(vec2 uv) {\n    vec2 grid = fract(uv) - 0.5;   // the cell coordinates in the grid\n\n    vec2 distanceFromCenter = abs(grid);\n    float edgeDist = (0.5 - max(distanceFromCenter.x, distanceFromCenter.y)) * 2.0;\n\n    vec2 id = uv - grid;  // ID values for the cell\n\n    return tilingVal(grid, id, edgeDist);  // make tilingVal struct\n}\n\n// Rhombus tiling function\ntilingVal rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;    \n    vec2 grid = dot(a,a) < dot(b,b) ? a : b; //UV centered in cell\n    \n    vec2 ma = abs(a);\n    vec2 mb = abs(b);\n    float eDist = (max(ma.x+ma.y,mb.x+mb.y)-0.5)*2.; //Edge Distance\n    \n    // adding tiny offset to prevent floating point errors\n    vec2 id = uv - grid  + 0.0000001; //ID values\n    return tilingVal(grid, id, eDist);  // make tilingVal struct\n}\n\n// rotates and animates texture in flowmap direction \nvec3 directionalTex (vec2 uv, vec2 flowMap) {\n    vec2 direction = normalize(flowMap); // normalize for rotation\n    uv = mat2x2(direction.y, direction.x, -direction.x, direction.y)*uv; // rotate UVs\n    \n    uv += flowMap; // offset\n    \n    return texture(iChannel0, uv).xyz; // sample texture\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}\n\n// 3 Grids blending between each other with each tile having a unique rotation and offset\nvec3 squareDirectionalNoise(vec2 uv, float gridRes, float contrast) {\n    #ifdef RepeatTiling    \n        uv = fract(uv); // repeating UVs is sometimes useful\n        // needs to be a hole number or tiling won't be seamless\n        gridRes = floor(gridRes);\n    #endif    \n    \n    uv *= gridRes; // scalue UVs to gridres\n    \n    tilingVal A = squareTile(uv); // grid A\n    tilingVal B = squareTile(uv + vec2(0.5)); // grid B offset to corner of grid A\n    tilingVal C = rhomTile(uv); // grid C\n        \n    // adding prime number to avoid 0 where hash does not work, rescale to -1-1\n    vec2 noiseA = hash22(A.id + 181.)*2.-1.;\n    \n    #ifdef RepeatTiling\n        // mod for repeating at UV=1, add prime number to avoid 0\n        vec2 noiseB = hash22(mod(B.id, gridRes) + 691.) * 2. -1.;\n        // also multiply by 2 as hash rounds UVs, adding ti\n        vec2 noiseC = hash22(mod(C.id, gridRes)*2. + 353.) * 2. -1.;\n    #else\n        vec2 noiseB = hash22(B.id + 691.)*2.-1.;\n        vec2 noiseC = hash22(C.id * 2. + 353.) * 2. -1.;\n    #endif\n    \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so constant\n    A.grid *= 2.0;\n    B.grid *= 2.0;\n    C.grid *= 2.0;\n    \n    // rotate and offset then sample texture\n    vec3 gridA = directionalTex(A.grid, noiseA);\n    vec3 gridB = directionalTex(B.grid, noiseB);\n    vec3 gridC = directionalTex(C.grid, noiseC);\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = gridA * alpha.x + gridB * alpha.y + gridC * alpha.z;\n    \n    #ifdef ShowGrid\n        // overlaying the edges of the alpha mask\n        float lineThickness = 0.05; // must be smaller than 0.1\n        vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n        return max(mask, col);\n    #else\n        return col;\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // rectangular UVs\n    vec2 uv = fragCoord/iResolution.y;    \n    // uv *= 2.; // to better see repeating tilings\n    \n    float gridRes = 3.;\n    float contrast = 4.; //1 no contrast, higher values increase contrast\n\n    vec3 col = squareDirectionalNoise(uv, gridRes, contrast);\n\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dGfzR.jpg", "access": "api", "license": "mit", "functions": [[2480, 2480, 2501, 2501, 2602], [2883, 2943, 2974, 2974, 3295], [3297, 3324, 3353, 3353, 3805], [3807, 3861, 3906, 3906, 4158], [4160, 4303, 4352, 4390, 4546], [4548, 4638, 4707, 4707, 6682], [6684, 6684, 6741, 6764, 7059]], "test": "untested"}
{"id": "fsKBRR", "name": "HardSurface Sphere", "author": "tdhooper", "description": "Tiling the sphere with triangle voronoi patterns", "tags": ["voronoi", "geodesic"], "likes": 36, "viewed": 804, "published": 3, "date": "1657553600", "time_retrieved": "2024-07-30T16:40:52.186804", "image_code": "//#define SHOW_DATA\n\n#if HW_PERFORMANCE==1\n#define AA 2\n#endif\n\n\n#define PI 3.14159265359\n#define PHI 1.618033988749895\n\n// HG_SDF\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Rotate on axis\n// blackle https://suricrasia.online/demoscene/functions/\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax, p, cos(ro))+sin(ro)*cross(ax,p);\n}\n\n\n// --------------------------------------------------------\n// Icosahedral domain mirroring\n// knighty https://www.shadertoy.com/view/MsKGzw\n// \n// Also get the face normal, and tangent planes used to\n// calculate the uv coordinates later.\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n\nint Type=5;\nvec3 nc;\nvec3 pab;\nvec3 pbc;\nvec3 pca;\n\nvoid init() {\n    float cospin=cos(PI/float(Type)), scospin=sqrt(0.75-cospin*cospin);\n    nc=vec3(-0.5,-cospin,scospin);\n    pbc=vec3(scospin,0.,0.5);\n    pca=vec3(0.,scospin,cospin);\n    pbc=normalize(pbc);\n    pca=normalize(pca);\n\tpab=vec3(0,0,1);\n    pca *= 0.794654;\n    pab *= 0.850651;\n}\n\nvoid fold(inout vec3 p) {\n\tfor(int i=0;i<Type;i++){\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2. * min(0., dot(p,nc)) * nc;\n\t}\n}\n\n\n// --------------------------------------------------------\n// Modelling\n// --------------------------------------------------------\n\nstruct Model {\n    float d;\n    vec3 col;\n};\n\nModel map(vec3 p) {\n\n    #ifdef LOOP\n        p = erot(p, normalize(pca), fract(iTime / 10.) * PI * 2. * (1./3.));\n    #endif\n\n    float r = 2.;\n\n    float bound = length(p) - r - .2;\n    if (bound > .01) {\n        return Model(bound, vec3(0));\n    }\n\n    vec3 col = normalize(p) * .5 + .5;\n    \n    vec3 face, ab, atob;\n\n    fold(p);\n    face = pca;\n    atob = pbc - pab;\n    ab = pab;\n    \n    vec3 vv = normalize(face - ab);\n    vec3 uu = normalize(atob);\n    vec3 ww = face;\n    mat3 m = mat3(uu,vv,ww);\n       \n    vec3 pp = p / dot(p, face);\n    \n    vec3 uvw = pp * m;\n\n    col = vec3(uvw.xy * vec2(1,-1), 0);\n   \n    \n    float d = length(p) - 2.;\n    \n    vec4 data = texture(iChannel0, uvw.xy * vec2(1,-2));\n\n    float kk = mix(-.5, 1., smoothstep(.4, .6, data.a));\n\n    float vd0 = data.r * 6.;\n    \n    vec2 rn0 = data.gb;\n    float rn = rn0.x;\n    float rn1 = rn0.y;\n    \n    float inn = mix(.01, .6, floor(rn1*3.)/3.);\n    float h = min(vd0, inn) * .4;\n\n    if (rn1 < .3) {\n        h -= max(0., (vd0 - .3) * .2);\n    }\n        \n    h *= kk;\n        \n    d = length(p) - r - h;\n    \n    col = vec3(.5);\n\n    float ws = .5;\n    float w = mix(.0, .1, floor(rn * 3.)/3.) * ws;\n    col = mix(col, vec3(.15), (1.-smoothstep(.01 * ws*1.5, .03*ws*1.5, abs(vd0 - inn))));\n    if (rn1 < .3) {\n        col = mix(col, vec3(.2), smoothstep(.01, .03, (vd0 - .3)));\n        col = mix(col, vec3(.05), (1.-smoothstep(.01, .04, abs(vd0 - .3))));\n    }\n    col = mix(col, vec3(0), (1.-smoothstep(w, w + .0, abs(vd0))));\n    \n    return Model(d, col);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// --------------------------------------------------------\n\nfloat vmul(vec2 v) {\n    return v.x * v.y;\n}\n\n// compile speed optim from IQ https://www.shadertoy.com/view/Xds3zN\nvec3 calcNormal(vec3 pos){\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).d;\n    }\n    return normalize(n);\n}\n\nmat3 calcLookAtMatrix(vec3 ro, vec3 ta, vec3 up) {\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(ww,up));\n    vec3 vv = normalize(cross(uu,ww));\n    return mat3(uu, vv, ww);\n}\n\nvec3 render( vec2 p )\n{\n\n    vec3 camPos = vec3(0,0,9);\n    \n    vec2 im = iMouse.xy / iResolution.xy - .5;\n    \n    if (iMouse.x <= 0.)\n    {\n        im = vec2(0);\n    }\n    \n    im += vec2(.66,.3);\n    \n    pR(camPos.yz, (.5 - im.y) * PI / 2.);\n    pR(camPos.xz, (.5 - im.x) * PI * 1.5);\n    \n    mat3 camMat = calcLookAtMatrix(camPos, vec3(0), vec3(0,1,0));\n    \n    float focalLength = 3.;\n    vec3 rayDirection = normalize(camMat * vec3(p.xy, focalLength));\n    \n    vec3 rayPosition = camPos;\n    float rayLength = 0.;\n    Model model;\n    float dist = 0.;\n    bool bg = false;\n    vec3 bgcol = vec3(.8);\n    vec3 col = bgcol;\n\n    for (int i = 0; i < 100; i++) {\n        rayLength += dist * .8;\n        rayPosition = camPos + rayDirection * rayLength;\n        model = map(rayPosition);\n        dist = model.d;\n\n        if (abs(dist) < .001) {\n        \tbreak;\n        }\n        \n        if (rayLength > 15.) {\n            bg = true;\n            break;\n        }\n    }\n    \n    if ( ! bg) {\n        col = model.col;\n        vec3 nor = calcNormal(rayPosition);\n        col *= dot(vec3(0,1,0), nor) * .75 + 1.;\n        float fog = 1. - exp((rayLength - 6.) * -1.5);\n    }\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    #ifdef SHOW_DATA\n        vec4 data = texture(iChannel0, fragCoord.xy / iResolution.xy);\n        data.x = fract(data.x * 100.);\n        fragColor = data;\n        return;\n    #endif\n    \n    init();\n    \n    vec2 o = vec2(0);\n    vec3 col = vec3(0);\n\n    // AA from iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    #endif\n\t\t\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.y;\n    \tcol += render(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n    \n    col = pow(col, vec3(1./2.2));\n\n    fragColor = vec4(col, 0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n//#define LOOP\n\n#define PI 3.14159265359\n\nmat3 scaleM(float s) {\n    return mat3(\n        s, 0, 0,\n        0, s, 0,\n        0, 0, 1\n    );\n}\n\nmat3 rotM(float a) {\n    return mat3(\n        cos(a), sin(a), 0,\n        -sin(a), cos(a), 0,\n        0, 0, 1\n    );\n}\n\nmat3 transM(vec2 v) {\n    return mat3(\n        1, 0, v.x,\n        0, 1, v.y,\n        0, 0, 1\n    );\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nmat3 gridTransformation(out float scale) {\n    float time = iTime * .06;\n    \n    scale = 6.;\n\n    mat3 m = scaleM(scale);\n    m *= rotM(PI * .3 * time);\n    m *= transM(time * vec2(0, -7.8));\n    return m;\n}\n\nmat3 gridTransformationLoop(out float scale) {\n    float time = fract(iTime / 10.);\n    \n    scale = 6.;\n\n    mat3 m = scaleM(scale);\n    m *= transM(time * vec2(0, -10.));\n    return m;\n}\n\n\nfloat effectMask(vec2 uv) {\n    return sin(length(uv) * 12. + 1.) * .5 + .5;\n}\n\n// --------------------------------------------------------\n// Triangle Voronoi https://www.shadertoy.com/view/ss3fW4\n// --------------------------------------------------------\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nconst float s3 = sin(PI / 3.);\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\nfloat sdTri(vec3 t) {\n    return max(t.x, max(t.y, t.z));\n}\n\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBorder(vec3 tbRel, vec2 pt1, vec2 pt2) {\n    \n    vec3 axis = primaryAxis(-tbRel);\n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n\n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2./3.;\n        \n    vec2 ca, cb;\n    float side;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        ca = corner + max(0., dot(corner, -norB)) * norB;\n        cb = corner + min(0., dot(corner, -norA)) * norA;\n    } else {\n        corner = pt1 - corner;\n        ca = corner + max(0., dot(corner, -norA)) * norA;\n        cb = corner + min(0., dot(corner, -norB)) * norB;\n    }\n    \n    side = step(dot(corner, dir * mat2(0,-1,1,0)), 0.);\n    corner = mix(ca, cb, side);\n    \n    float d = length(corner);\n\n    return d;\n}\n\n\nvec2 hash2( vec2 p )\n{\n\treturn textureLod( iChannel0, (p+0.5)/256.0, 0.0 ).xy;\n}\n\nvec2 cellPoint(vec2 n, vec2 f, vec2 cell, out vec2 coord) {\n    coord = n + cell;\n    #ifdef LOOP\n        vec2 e = vec2(2,9);\n        float rep = 10.;\n        coord = mod(coord+e, rep)-e;\n    #endif\n    vec2 o = hash2( coord );\n    if (hash2(o.yx * 10.).y > .5) {\n        return vec2(1e12);\n    }\n    #ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n    #endif\t\n    vec2 point = cell + o - f;\n    return point;\n}\n\nvec4 voronoi(vec2 x)\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 closestCell, closestPoint, closestCoord;\n\n    const int reach = 3;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(i, j);\n        vec2 coord;\n        vec2 point = cellPoint(n, f, cell, coord);\n        float dist = vmax(sdTriEdges(point));\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCoord = coord;\n            closestCell = cell;\n        }\n    }\n\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(i, j);\n        vec2 coord;\n        vec2 point = cellPoint(n, f, cell, coord);\n\n        vec3 triEdges = sdTriEdges(closestPoint - point);\n        float dist = vmax(triEdges);\n\n        if( dist > 0.00001 ) {\n            closestDist = min(closestDist, sdBorder(triEdges, closestPoint, point));\n        }\n    }\n\n    return vec4(closestDist, closestCoord, 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv *= vec2(1,-.5);\n    \n    if (uv.x > uv.y * -2.) {\n        fragColor = vec4(0);\n        return;\n    }    \n    \n    float scl;\n    #ifdef LOOP\n        mat3 m = gridTransformationLoop(scl);\n    #else\n        mat3 m = gridTransformation(scl);\n    #endif\n    \n    uv = mul(uv, m);\n\n    vec4 v = voronoi(uv);\n   \n    float d = v.x / scl;\n    vec2 localPt = v.yz;\n    vec2 worldPt = mul(localPt, inverse(m));\n    \n    vec2 seed = hash2(localPt * 5. / scl);\n\n    float mask = effectMask(worldPt);\n\n    fragColor = vec4(d, seed, mask);\n}\n", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsKBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 131, 163, 163, 208], [210, 286, 324, 324, 386], [768, 768, 781, 781, 1061], [1063, 1063, 1088, 1088, 1176], [1359, 1359, 1378, 1378, 2905], [3042, 3042, 3062, 3062, 3086], [3088, 3157, 3183, 3183, 3384], [3386, 3386, 3436, 3436, 3579], [3581, 3581, 3604, 3604, 4774]], "test": "untested"}
{"id": "ssGBRz", "name": "Organic growth w/ convolution", "author": "ninofiliu", "description": "Paint by dragging your mouse across!\n\nUsed a convolution matrix that accentuates certain frequencies in order to smooth out a bunch of lines that can be drawn w/ your mouse", "tags": ["convolution", "smooth", "backbuffer"], "likes": 1, "viewed": 274, "published": 3, "date": "1657549994", "time_retrieved": "2024-07-30T16:40:53.004618", "image_code": "// This just paints whatever is in BufferA\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    color = texture(iChannel0, uv);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// blur convolution\n/*\nconst int r = 1;\nconst int l = (2*r+1)*(2*r+1);\nfloat m[l] = float[](\n    0., 1., 0.,\n    1., 0., 1.,\n    0., 1., 0.\n);\nfloat mt = 4.01;\n*/\n\n// organic growth convolution\nconst int r = 1;\nconst int l = (2*r+1)*(2*r+1);\nfloat m[l] = float[](\n    -1., 5., -1.,\n    5., 0., 5.,\n    -1., 5., -1.\n);\nfloat mt = 16.1;\n\nvoid mainImage(out vec4 color, in vec2 coord) {\n    color.rgb = vec3(0.);\n\n    vec2 uv = coord / iResolution.xy;\n    vec2 mouseUv = iMouse.xy / iResolution.xy;\n    \n    for (int x = -1; x <=1; x++) {\n        for (int y = -1; y <=1; y++) {\n            int i = (y+1)*3+x+1;\n            float v = m[i] / mt;\n            color += 0.9 * v * texture(\n                iChannel0,\n                vec2(\n                    uv.x+float(x)/iResolution.x,\n                    uv.y+float(y)/iResolution.y\n                )\n            );\n        }\n    }        \n    \n    if (distance(uv, mouseUv) < 0.05 && iMouse.z > 0.) {\n        color.rgb = 1. - color.rgb;\n    }\n    \n    color.rgb = clamp(color.rgb, 0., 1.);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssGBRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 90, 90, 170]], "test": "untested"}
{"id": "NsGfzz", "name": "motionblur existing shaders 2", "author": "FabriceNeyret2", "description": "Just add this Common to motion blur any shader ( integrating time dithering with procedural white noise. bluenoise would be better but requires setting a texture. ). \n2 variants: basic, & combined with antialiasing.\nAttention: will do it on all buffers.", "tags": ["motionblur", "antialiasing", "sampling", "tuto"], "likes": 15, "viewed": 546, "published": 3, "date": "1657530832", "time_retrieved": "2024-07-30T16:40:53.822431", "image_code": "// combines simple dither-motionblur existing shaders https://www.shadertoy.com/view/NdGfzz\n// with antialias existing shader https://www.shadertoy.com/view/NdyfRz\n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )  // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = ( 2.*u - R ) / R.y;\n    \n    float t = iTime;\n    O-=O;\n    for(float i=0.; i<1.; i+=.1) {                                // --- drawing balls\n       t *= 1.2;\n       P = vec2( 1.2*cos(2.*t), .8*sin(3.1*t) );     \n       O += smoothstep(3./R.y, 0., length(P-U) - .15 ) * hue(i);\n   }\n}\n", "image_inputs": [], "common_code": "\n\n#define iTime ( iTime + fract(1e4*sin(dot(gl_FragCoord.xy+float(_k)*1.7,vec2(137,-13))))* iTimeDelta )\nint _N = 5, _k;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (_k=0; _k < _N*_N; _k++ )                        \\\n   /* { mainImage0(o,U); O += o; }   /* basic. Below: combined with AA */ \\\n      { mainImage0(o,U+vec2(_k%_N-_N/2,_k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[273, 273, 311, 311, 644]], "test": "untested"}
{"id": "NdGfzz", "name": "motionblur existing shaders", "author": "FabriceNeyret2", "description": "Just add this Common to motion blur any shader (simple dithering with procedural white noise. bluenoise would be better but requires setting a texture. ).", "tags": ["motionblur", "sampling", "tuto"], "likes": 10, "viewed": 523, "published": 3, "date": "1657530504", "time_retrieved": "2024-07-30T16:40:54.662186", "image_code": "\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )  // https://www.shadertoy.com/view/ll2cDc\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = ( 2.*u - R ) / R.y;\n    \n    float t = iTime;\n    O-=O;\n    for(float i=0.; i<1.; i+=.1) {                                // --- drawing balls\n       t *= 1.2;\n       P = vec2( 1.2*cos(2.*t), .8*sin(3.1*t) );     \n       O += smoothstep(3./R.y, 0., length(P-U) - .15 ) * hue(i);\n   }\n}", "image_inputs": [], "common_code": "#define iTime ( iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta )\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdGfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 147, 147, 480]], "test": "untested"}
{"id": "NdyfRz", "name": "postprocess existing shaders", "author": "FabriceNeyret2", "description": "easy adaptive sampling:\nJust add this Common to postprocess any shader. Example here: antialiasing ( amount _NÂ² ) + sRGB \nAttention: will do it on all buffers.\n\nMouse.x : ref separator \n", "tags": ["antialiasing", "sampling", "tuto", "easyadaptivesampling"], "likes": 26, "viewed": 863, "published": 3, "date": "1657530094", "time_retrieved": "2024-07-30T16:40:55.419162", "image_code": "// base shader: https://www.shadertoy.com/results?query=hexamaz\n\nvoid mainImage(out vec4 O, vec2 U) {\n    vec2  R =  iResolution.xy;\n    float s = iMouse.z>0. ? iMouse.x : R.x/2.;\n    if ( U.x<s) _N=1;    // just for this demo: left = no antialiasing\n\n    vec3 V =  ( ( (U) -9.*iTime ) * mat2(cos(.1 + vec4(0,11,33,0))) )\n             * mat3x2( 12, -7, 0, 14,    12, 7 ) / 1e2; \n    O = vec4( fract(  V[ 1 + int( 2.* sin( 1e5* length( ceil( V.xy )))) ]) < .1 );\n\n    if ( abs(U.x-s) < 1. ) O = vec4(1,0,0,1); // red separator\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "int _N = 3;\n#define mainImage mainImage0(out vec4 O, vec2 U);        \\\nvoid mainImage(out vec4 O, vec2 U) {                     \\\n    vec4 o; O = vec4(0);                                 \\\n    for (int k=0; k < _N*_N; k++ )                       \\\n      { mainImage0(o,U+vec2(k%_N-_N/2,k/_N-_N/2)/float(_N)); O += o; }  \\\n    O /= float(_N*_N);                                   \\\n    O = pow( O, vec4(1./2.2) );        /* to sRGB */     \\\n} \\\nvoid mainImage0", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdyfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 101, 101, 527]], "test": "untested"}
{"id": "NsGBRR", "name": "Shiny Goop", "author": "N8Shader", "description": "Goop using domain warping + phong shading... I love shaders.", "tags": ["noise", "phong", "fbm", "warping", "domain", "specular", "goop"], "likes": 7, "viewed": 330, "published": 3, "date": "1657500485", "time_retrieved": "2024-07-30T16:40:56.173146", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    //vec3 objectNormal = normalize(vec3(\n        //1.0,//length(texture(iChannel0, uv + vec2(texelSize.x, 0.0)).rgb) - length(texture(iChannel0, uv - vec2(texelSize.x, 0.0)).rgb),\n       // 1.0,\n       // 1.0,//length(texture(iChannel0, uv + vec2(0.0, texelSize.y)).rgb) - length(texture(iChannel0, uv - vec2(0.0, texelSize.y)).rgb),\n   // ));\n    vec3 objectNormal = normalize(vec3(\n        33.33 * (length(texture(iChannel0, uv + vec2(texelSize.x, 0.0)).a) - length(texture(iChannel0, uv - vec2(texelSize.x, 0.0)).a)),\n        1.0,\n        33.33 * (length(texture(iChannel0, uv + vec2(0.0, texelSize.y)).a) - length(texture(iChannel0, uv - vec2(0.0, texelSize.y)).a))\n    ));\n    vec4 texInfo = texture(iChannel0, uv);\n    vec3 diffuse = mix(texInfo.rgb, texInfo.rgb * vec3(max(dot(objectNormal, vec3(0.0, 1.0, 0.0)), 0.0)), max(2.0 * max(texInfo.a - 0.2, 0.0), 0.25));\n    vec3 spec = vec3(pow(max(dot(vec3(0.0, 1.0, 0.0), reflect(vec3(0.0, -1.0, 0.0), objectNormal)), 0.0), 32.0));\n    fragColor = vec4(diffuse + spec * (2.0 * max(texInfo.a - 0.45, 0.0) + 2.0 * max(-texInfo.a + 0.5, 0.0)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n}\n\nfloat fbm(vec4 x) {\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tvec4 shift = vec4(100.0);\n\tfor (int i = 0; i < 6; ++i) {\n\t\tv += a * snoise(x);\n\t\tx = x * 2.0 + shift;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\nfloat fbm2(vec2 uv, float s) {\n    return fbm(vec4(\n    fbm(vec4(uv, iTime * 0.1, s + 0.0)),\n    fbm(vec4(uv, iTime * 0.1, s + 10.0)),\n    fbm(vec4(uv, iTime * 0.1, s + 20.0)),\n    fbm(vec4(uv, iTime * 0.1, s + 30.0))\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    float inerpFactor = smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, 0.5 + 0.5*\n    fbm2(uv, 0.0 + iTime * 0.1)));\n    fragColor = vec4(mix(vec3(0.0, 0.75, 0.0), vec3(1.0, 0.0, 1.0), inerpFactor),inerpFactor);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsGBRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1293]], "test": "untested"}
{"id": "7ddBWl", "name": "Wind Waves of Cyclone using SDF", "author": "gehtsiegarnixan", "description": "Hex Directional Flow with a cyclone flow map and a Sinewave perpendicular to the Flow Vector like water waves", "tags": ["wave", "water", "hexagon", "sine", "hex", "gabor", "gabor", "flowmap", "vectorfield", "viridis", "cyclone", "directionalflow"], "likes": 1, "viewed": 177, "published": 3, "date": "1657478729", "time_retrieved": "2024-07-30T16:40:56.934112", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is using my Square Directional Flow algorithm \n(https://www.shadertoy.com/view/7dtBWl) with Sine waves instead of a texture.\nI also made a flowmap that is an aproximation of a tropical cyclone flowmap \n(https://www.shadertoy.com/view/fdKcWd). I wanted to aproximate the water wave height.\n\nI looked up the forumlas for the relationship between windspeed and waves, but the math\nis very complicated and I gave up. So I went for what looks alright \n(https://www.desmos.com/calculator/lewikf6y0f).\n\nThe easy water wave math can be found here \n(https://en.wikipedia.org/wiki/Dispersion_(water_waves)). Wikipeda explains the \nrelationship between water depth, wavelength and wave velocity \n(https://www.desmos.com/calculator/2nlmht2mmy). The amplitude and windspeed don't have\nsuch linear interaction, but there are formuals for observed wave spectra on the ocean\nafter long periods of steady wind (https://wikiwaves.org/Ocean-Wave_Spectra). I just can\nnot figure out how to solve for the wavespeed/wavelength for a give depth and windspeed.\nA single wave can be described by the gerstner formula \n(https://catlikecoding.com/unity/tutorials/flow/waves/), but I couldn't find how the wind\naffects the wave steepness and when exactly they break on the open sea. I found some\nhints here (http://hyperphysics.phy-astr.gsu.edu/hbase/Waves/watwav2.html) when they \nbreak. \n\nAnimating the flowmap also turned out to have some significant drawbacks. Since im sampling\na lower res hexagonal version leads to flickering waves, so you can only do it VERY slowly. \n*/\n\n#define pi              3.1415926536\n#define sqrtG           3.1320919527\n#define twoPi           6.2831853072\n\n// makes viridis colormap with polynimal 6 https://www.shadertoy.com/view/Nd3fR2\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n//shifts value range from -1-1 to 0-1\nfloat make0to1(float x) {\n    return (1.0 + x) / 2.0;\n}\n\n//shifts value range from 0-1 to -1-1\nvec2 makeM1to1(vec2 x) {\n    return (x - 0.5) * 2.0;\n}\n\n// makes a simple flowmap of a cyclone\nvec2 cycloneFlow(vec2 point, float radius, float time) {  \n    float size = 1./(1.4 * sqrt(radius)); // of the entire cyclone\n    float curl = 2.5; // kind of arbitrary but between 1-3.5 looks good\n    float hole = 1./(4.*size); // also kind of arbitrary\n    \n    //point += vec2(cos(time),sin(time))*0.1*hole; //rotating center\n    \n    float angle = atan(point.y, point.x); //angle around center\n    float dist = length(point); // distance to point\n    float spiral = fract(dist/radius + (angle-time)/twoPi);\n    \n    //right slanted donut https://www.desmos.com/calculator/ocm71awnym\n    spiral -= 1.212;\n    spiral = 1.+ (pow(1.57*(spiral)+0.8,2.)/spiral);\n        \n    float flowAngle = pi + angle -(dist*curl) -(spiral*0.8);\n    \n    // left slanted donut https://www.desmos.com/calculator/uxyefly7fi\n    float spiralStrength = 0.05;\n    float mask = (1. - spiralStrength)-(pow(dist*size-hole, 2.0)/dist);\n    mask += spiral*spiralStrength; \n    mask = clamp(mask, 0.0, 1.0);  // saturate\n    \n    vec2 flow = normalize(vec2(cos(flowAngle),sin(flowAngle)));\n    flow *= mask; // apply strength mask\n    \n    //flow = (flow+1.0)/2.0; // to save as texture\n    flow += vec2(0.0001,0.0001); //adding tiny offset so it isnt 0\n    return flow;\n}\n\n// simple square Tiling\nvec3 squareTile(vec2 uv) {\n    vec2 grid = fract(uv)-.5; //UV centered on cell\n    \n    vec2 d = abs(grid);     \n    float eDist = (0.5-max(d.x, d.y))*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values\n    return vec3(id, eDist);    \n}\n\n//rhombic shape form Manhattan distance\nvec3 rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;\n    \n    vec2 aa = abs(a);\n    float mDist = (aa.x + aa.y -.5);    \n    vec2 grid = mDist < 0. ? a : b; //UV coords\n    \n    float eDist = abs(mDist)*2.; //Edge Distance\n    \n    vec2 id = uv - grid; //ID values    \n    return vec3(id, eDist);\n}\n\n// nakes a square pixelized pattern\nvec3 squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    vec3 sTiling = squareTile(uv*gridRes + offset);    \n    vec2 tiledUV = (sTiling.xy - offset)/gridRes; //pixaltion\n    return vec3(tiledUV, sTiling.z);\n}\n\n// nakes a rhombic pixelized pattern\nvec3 rhomPixelizor(vec2 uv, float gridRes) {\n    vec3 rTiling = rhomTile(uv*gridRes);    \n    vec2 tiledUV = (rTiling.xy)/gridRes; //pixaltion\n    return vec3(tiledUV, rTiling.z);\n}\n\nfloat sinWave(vec2 uv, vec2 tiledUV, float time, float alpha, float len) {\n    float radius = 0.3; // of the first spiral \n    //cyclone like flowmap\n    vec2 flowMap = cycloneFlow(tiledUV - vec2(0.885, 0.5), radius, time*0.2);    \n    \n    float speed = length(flowMap); // Wind Speed    \n    vec2 dir = normalize(flowMap); // Wind Direction    \n    len *= pow(speed,0.5); // make slower waves smaller\n    float k = twoPi / len; //Wave Number    \n    float a = pow(speed,1.5); //Amplitude \n    float s = speed; //Steepness\n    time *= sqrtG * sqrt(len); // deep water speed\n    \n    float dD = dot(uv,dir); //Directional/Straight Wave\n    \n    //add random phase offsets for even FlowMaps or you get interference\n    //time += texture( iChannel0, tiledUV).x; \n    \n    float wave = make0to1(sin(k * (dD - time))); // make sin wave\n    //wave = (1.- pow(wave, (1.-s/2.))); //cheap gerstner height wave aprox\n    \n    wave *= a * alpha; // apply amplitue and alpha mask\n    return wave;\n}\n\n// generates pixelated directional waves\nfloat flowSquareCell(vec2 uv, vec2 offset, float gridRes, float time, float len) {    \n    vec3 pix = squarePixelizor(uv, gridRes, offset);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// generates pixelated directional waves\nfloat flowRhomCell(vec2 uv, float gridRes, float time, float len) {    \n    vec3 pix = rhomPixelizor(uv, gridRes);    \n    return sinWave(uv, pix.xy, time, pix.z, len);\n}\n\n// 3 hex pixaled flowing sin thier edges get hidden by each other\nfloat triDirectionalFlow(vec2 uv, float gridRes, float time, float len) {\n    float a = flowSquareCell(uv, vec2(0.,0.), gridRes, time, len);\n    float b = flowSquareCell(uv, vec2(0.5), gridRes, time, len);\n    float c = flowRhomCell(uv, gridRes, time, len);\n\n    return a + b + c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gridRes = 32.0; //Hex Grid Resolution\n    float waveLen = 1./ (gridRes * 3.0); // Maximum Sin Wave Length\n    float time = iTime * 0.05; // flow speed multiplier\n    \n    vec2 uv = fragCoord/iResolution.y; //centered square UVs  \n    float wave = triDirectionalFlow(uv,gridRes,time, waveLen);\n    \n    vec3 col = vec3(viridis(wave));\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddBWl.jpg", "access": "api", "license": "mit", "functions": [[2752, 2833, 2856, 2856, 3304], [3306, 3344, 3369, 3369, 3399], [3401, 3439, 3463, 3463, 3493], [3495, 3534, 3590, 3590, 4780], [4782, 4806, 4832, 4832, 5052], [5054, 5094, 5118, 5118, 5446], [5448, 5484, 5543, 5543, 5700], [5702, 5739, 5783, 5783, 5920], [5922, 5922, 5996, 5996, 6909], [6911, 6952, 7034, 7034, 7147], [7149, 7190, 7257, 7257, 7360], [7362, 7428, 7501, 7501, 7710], [7712, 7712, 7769, 7769, 8144]], "test": "untested"}
{"id": "7dtBWl", "name": "Directional Flow Square", "author": "gehtsiegarnixan", "description": "an improvement with two less texture lookups of Catlike Coding's Direction Flow [url]https://catlikecoding.com/unity/tutorials/flow/directional-flow/ [/url]", "tags": ["wave", "water", "hexagon", "flow", "hex", "directional", "dodecahedron", "vectorfield", "direction", "rohmbic", "rhom"], "likes": 11, "viewed": 384, "published": 3, "date": "1657474292", "time_retrieved": "2024-07-30T16:40:57.777856", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/* \nThis is an improvement of my Hex Directional Flow. It uses a slightly different\ngird structe that is a lot faster to compute. I think it has the same quality \nas the hexagon grid. Hexagon just uses a equilateral triangle, while square uses\na right triangle.\n\nDirectional Flow animates and rotates a texture in multiple directions with \na flowmap. This means that water wave textures can flow in multiple directions \nat the same time, while the waves point in the right direction. This is not \npossible with trational flow animation, which either has only one wind \ndirection or stretches the texture with temporal blending. The Directional Flow\ndoes this by blending in the spatial dimension. \n\nThe slightly slower Hex Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsGyDG\n\nThe classic 8 sample Directional Flow is implemented in shadertoys here:\nhttps://www.shadertoy.com/view/fsKczd\n\nHere is my Rhombic Dodecahedron Tiling to have Hex Directional Flow in 3D:\nhttps://www.shadertoy.com/view/fddfRn\n\nHere is a diffeent use case with cyclone windwaves:\nhttps://www.shadertoy.com/view/7dycDV\n\nThe earliest iteration of directional flow I could find is from 2010:\nhttps://www.rug.nl/society-business/centre-for-information-technology/research/hpcv/publications/watershader/\nBut CatlikeCoding's version is much better explained, so I recommend reading \nit as a guide:\nhttps://catlikecoding.com/unity/tutorials/flow/directional-flow/\n*/\n\n// #define ShowGrid\n\n// Square tiling function, 0 and negative values don't work\ntilingVal squareTile(vec2 uv) {\n    vec2 grid = fract(uv) - 0.5;   // the cell coordinates in the grid\n\n    vec2 distanceFromCenter = abs(grid);\n    float edgeDist = (0.5 - max(distanceFromCenter.x, distanceFromCenter.y)) * 2.0;\n\n    vec2 id = uv - grid;  // ID values for the cell\n\n    return tilingVal(grid, id, edgeDist);  // make tilingVal struct\n}\n\n// makes a square pixelized pattern\ntilingVal squarePixelizor(vec2 uv, float gridRes, vec2 offset) {\n    // generate square grid tiling\n    tilingVal tiling = squareTile(uv * gridRes + offset); \n    // generate square grid tiling    \n    tiling.id = (tiling.id - offset)/gridRes; //pixaltion    \n    return tiling;\n}\n\n// Rhombus tiling function\ntilingVal rhomTile(vec2 uv) {\n    vec2 a = fract(uv- vec2(.0, .5))-.5;\n    vec2 b = fract(uv- vec2(.5, .0))-.5;    \n    vec2 grid = dot(a,a) < dot(b,b) ? a : b; //UV centered in cell\n    \n    vec2 ma = abs(a);\n    vec2 mb = abs(b);\n    float eDist = (max(ma.x+ma.y,mb.x+mb.y)-0.5)*2.; //Edge Distance\n    \n    // adding tiny offset to prevent floating point errors\n    vec2 id = uv - grid  + 0.0000001; //ID values\n    return tilingVal(grid, id, eDist);  // make tilingVal struct\n}\n\n// makes a rhombic pixelized pattern without offset\ntilingVal rhomPixelizor(vec2 uv, float gridRes) {\n    // generate square grid tiling\n    tilingVal tiling = rhomTile(uv*gridRes);    \n    tiling.id = tiling.id / gridRes; //pixaltion    \n    return tiling;\n}\n\n// 3 pixaled flowing textures thier edges get hidden by each other\nvec3 squareDirectionalFlow(sampler2D tex, sampler2D flow, vec2 uv, \n                           float gridRes, float time, float contrast) { \n    // generate grid values\n    tilingVal A = squarePixelizor(uv, gridRes, vec2(0.)); // grid A    \n    tilingVal B = squarePixelizor(uv, gridRes, vec2(0.5)); // grid B offset to corner A\n    tilingVal C = rhomPixelizor(uv, gridRes); // grid C\n\n    // sample flow map in each grid\n    vec2 flowA = flowMap(flow, A.id);\n    vec2 flowB = flowMap(flow, B.id);\n    vec2 flowC = flowMap(flow, C.id);\n            \n    // scale UVs so the entire texture is visible in a tile\n    // the proper range is ~1-3 and artists don't read, so constant\n    A.grid *= 2.0;\n    B.grid *= 2.0;\n    C.grid *= 2.0;\n    \n    // rotate and offset then sample texture\n    vec3 gridA = PanDirectionalTex(tex, A.grid, flowA, time);\n    vec3 gridB = PanDirectionalTex(tex, B.grid, flowB, time);\n    vec3 gridC = PanDirectionalTex(tex, C.grid, flowC, time);\n    \n    //All edgeDist added = 1 -> so we can skip the more expensive C calculation\n    vec3 alpha = vec3(A.edgeDist, B.edgeDist, 1.-(A.edgeDist + B.edgeDist)); \n    \n    alpha = smoothContrast(alpha, contrast); // increase contrast\n    \n    // interpolate result\n    vec3 col = gridA * alpha.x + gridB * alpha.y + gridC * alpha.z;\n    \n#ifdef ShowGrid\n    // overlaying the edges of the alpha mask\n    float lineThickness = 0.03; // must be smaller than 0.1\n    vec3 mask = step(abs(alpha - 0.1), vec3(lineThickness));\n    return max(mask, col);\n#else\n    return col;\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = iTime* .4; // flow speed multiplier\n    float gridRes = 8.; // the number of subdivisions for the sampling of the flowmap\n    float contrast = 2.;  // 1-inf, increased the contrast between the tiles\n    \n    vec2 uv = fragCoord/iResolution.y; //square UV pattern\n\n    vec3 sdf = squareDirectionalFlow(iChannel0, iChannel1, uv, gridRes, time, contrast);\n\n#ifndef  ShowGrid   \n    sdf += vec3(0.0,0.2,0.5); //adding arbitrary watery color\n#endif\n    \n    fragColor = vec4(sdf, 0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// struct to hold 5 floats at a time of my tiling functions\nstruct tilingVal {\n    vec2 grid;       // Coordinates of the cell in the grid (UV centered on cell)\n    vec2 id;         // ID values\n    float edgeDist;  // Edge distance from the cell's center to its boundaries\n};\n\n// rotates UV by direction\nvec2 rotateUV(vec2 uv, vec2 direction)\n{\n    // Normalize the direction vector\n    direction = normalize(direction);\n\n    // Calculate the rotation matrix\n    mat2 rotationMatrix = mat2(\n        direction.x, -direction.y,\n        direction.y, direction.x\n    );\n\n    // Rotate the UV coordinates\n    return rotationMatrix * uv;\n}\n\n// rotates and animates texture in flowmap direction \nvec3 PanDirectionalTex (sampler2D sam, vec2 uv, vec2 flowMap, float time) {  \n    uv += flowMap*time; // add offset with time\n\n    uv = rotateUV(uv, flowMap); // rotate UVs\n    \n    return texture(sam, uv).xyz; // sample texture\n}\n\n// generates a -1-1 smooth flowmap\nvec2 flowMap(sampler2D sam, vec2 uv) {\n    //a random spot in the noise map, normally you use an actual flowmap\n    vec2 flowMap = texture(sam, uv*0.05).xy;\n    return flowMap * 2. -1.; // constant bias scale for -1 to 1 range\n}\n\n// Increases the steepness of Alpha while preserving 0-1 range and 1 sum\n// See 2 value example (https://www.desmos.com/calculator/dpxa6mytnv)\nvec3 smoothContrast(vec3 alpha, float contrast) {\n    // increase steepness using power\n    vec3 powAlpha = pow(alpha, vec3(contrast));\n    \n    // normalize back to precentage of 1\n    return powAlpha/(powAlpha.x + powAlpha.y + powAlpha.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtBWl.jpg", "access": "api", "license": "mit", "functions": [[2574, 2634, 2665, 2665, 2986], [2988, 3024, 3088, 3123, 3304], [3306, 3333, 3362, 3362, 3814], [3816, 3868, 3917, 3952, 4075], [4077, 4144, 4283, 4312, 5692], [5694, 5694, 5750, 5750, 6248]], "test": "untested"}
{"id": "7dcBDs", "name": "basic planet", "author": "takahiroando", "description": "A planet with land, sea, cloud.  I would be happy if I could make it shorter.", "tags": ["noise", "planet"], "likes": 8, "viewed": 309, "published": 3, "date": "1657440555", "time_retrieved": "2024-07-30T16:40:58.617610", "image_code": "float hash(vec3 v3) {\n\treturn fract(sin(dot(v3, vec3(12.3, 45.6, 78.9))) * 987654.321);\n}\n\nfloat noise(vec3 v3) {\n\tvec3 i = floor(v3);\n\tvec3 f = fract(v3);\n\tvec3 b = smoothstep(0.0, 1.0, f);\n\tvec2 bin = vec2(0.0, 1.0);\n\treturn 2.0 * mix(\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxx), hash(i + bin.yxx), b.x),\n\t\t\tmix(hash(i + bin.xyx), hash(i + bin.yyx), b.x),\n\t\t\tb.y\n\t\t),\n\t\tmix(\n\t\t\tmix(hash(i + bin.xxy), hash(i + bin.yxy), b.x),\n\t\t\tmix(hash(i + bin.xyy), hash(i + bin.yyy), b.x),\n\t\t\tb.y\n\t\t),\n\t\tb.z\n\t) - 1.0;\n}\n\nvec3 rotate_y(vec3 p, float t) {\n    vec3 a = vec3(0.0, 1.0, 0.0);\n\treturn mix(dot(a, p) * a, p, cos(t)) + cross(a, p) * sin(t);\n}\n\n\nconst float RS = 5.0;\nconst float C = 0.1; // height of cloud\nconst float RC = RS + C;\nconst float H = 1.0;\n\nfloat fbm_core(vec3 p, float amp, float freq, float mul_amp, float mul_freq) {\n\tfloat h = 0.0;\n\tfor (int i = 0; i < 6; ++i) {\n\t\th += amp * noise(p * freq);\n\t\tamp *= mul_amp;\n\t\tfreq *= mul_freq;\n\t}\n\treturn h;\n}\n\nfloat height(vec3 p) {\n\tif (length(p) > RC) return 0.0;\n\tp = normalize(p) * RS;\n\tp = rotate_y(p, iTime * 0.1);\n\treturn fbm_core(p, 0.8, 0.2, 0.4, 2.7) * H;\n}\n\nfloat d_sea(vec3 p) {\n\treturn length(p) - RS;\n}\n\nfloat d_ground(vec3 p) {\n\treturn length(p) - (max(height(p), 0.0) + RS);\n}\n\nfloat d_sphere(vec3 p, float radius) {\n\treturn length(p) - radius;\n}\n\nvec4 rt_sphere(vec3 p, vec3 rd, float radius) {\n\tfloat hit = 0.0;\n\tfor(int i = 0; i < 100; ++i) {\n\t\tfloat d = d_sphere(p, radius);\n\t\tp += d * rd;\n\t\tif (d < 0.01) {\n\t\t\thit = 1.0;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn vec4(p, hit);\n}\n\nvec3 normal_ground(vec3 p) {\n\tmat3 k = mat3(p, p, p) - mat3(0.001);\n\treturn normalize(d_ground(p) - vec3(d_ground(k[0]), d_ground(k[1]), d_ground(k[2])));\n}\n\nvec3 light_dir() {\n    return normalize(vec3(0.6 * sin(0.1 * iTime), 0.5, 1.0));\n}\n\nvec3 shade_star(vec3 p, vec3 rd) {\n\tfloat h = height(p);\n\tvec3 snow = vec3(1.0);\n\tvec3 sand = vec3(0.7, 0.66, 0.53);\n\tvec3 grass = vec3(0.1, 0.7, 0.3);\n\tfloat snow_r = exp(-abs(h - 0.5 * H) * 20.0);\n\tfloat sand_r = exp(-abs(h - 0.25 * H) * 20.0);\n\tfloat grass_r = exp(-abs(h) * 20.0);\n\tfloat sum_r = snow_r + sand_r + grass_r;\n\tvec3 dif_mat = (snow * snow_r + sand * sand_r + grass * grass_r) / sum_r;\n\tvec3 ng = normal_ground(p);\n    vec3 L = light_dir();\n\tfloat dif_pow = max(0.0, dot(L, ng));\n\tvec3 ground = vec3(0.1) + dif_mat * dif_pow;\n\n\tvec3 ns = normalize(p);\n\tvec3 rs = reflect(rd, ns);\n\n\tvec3 sea = vec3(0.1, 0.4, 0.9) * (0.1 * dif_pow - 2.0 * h / H + 0.9 * exp(max(dot(L, rs), 0.0))) + 0.1 * sin(h/H);\n\treturn h < 0.0 ? sea : ground;\n}\n\nfloat cloud(vec3 p) {\n\tp = rotate_y(p, iTime * -0.1);\n\tp += 0.1 * iTime;\n\treturn pow(clamp(abs(fbm_core(p, 1.1, 0.3, 0.5, 2.2)), 0.0, 1.0), 2.0);\n}\n\nfloat cloud_shadow(vec3 p) {\n\tp -= light_dir() * H;\n\treturn 1.0 - cloud(p) * 0.1;\n}\n\nvec3 bg(vec2 uv) {\n\tfloat t = iTime * 0.0001;\n\tvec3 from = vec3(t * 2.0, t, -1.0);\n\tfloat s = 0.1, fade = 1.0;\n\tvec3 v = vec3(0.0);\n\tfor (int r = 0; r < 20; ++r) {\n\t\tvec2 rot_uv = uv * mat2(cos(s), sin(s), -sin(s), cos(s));\n\t\tvec3 p = vec3(rot_uv, -s) * 0.25 + from;\n\t\tfloat repeat = 2.0;\n\t\tp = mod(p + 0.5 * repeat, repeat) - 0.5 * repeat;\n\t\tp *= 10.0;\n\t\tfloat pa = 0.0, a = 0.0;\n\t\tfor (int i = 0; i < 17; ++i) {\n\t\t\tp = abs(p) / dot(p, p) - 0.53;\n\t\t\ta += abs(length(p) - pa);\n\t\t\tpa = length(p);\n\t\t}\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s) * a * 0.0015 * fade;\n\t\tfade *= 0.75;\n\t\ts += 0.1;\n\t}\n\treturn v * 0.005;\n}\n\nvec3 render_base(vec2 uv, vec3 p, vec3 rd) {\n\tvec4 rt = rt_sphere(p, rd, RS);\n\tif (rt.w > 0.0) {\n\t\treturn shade_star(rt.xyz, rd) * cloud_shadow(rt.xyz);\n\t} else {\n\t\tvec3 sky_base_color = vec3(0.1, 0.4, 0.8);\n\t\tfloat sky_mix = smoothstep(RS, RS + 10.0 * C, length(rd.xy * 10.0));\n\t\treturn mix(sky_base_color, bg(uv), sky_mix);\n\t}\n}\n\nvec3 render(vec2 uv, vec3 p, vec3 rd) {\n\tvec4 rt = rt_sphere(p, rd, RC);\n\tfloat ccol = rt.w > 0.0 ? cloud(rt.xyz) : 0.0;\n\treturn mix(render_base(uv, p, rd), vec3(1.0), ccol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tvec3 p = vec3(0.0, 0.0, 10.0);\n\tvec3 rd = normalize(vec3(uv, -1.));\n\n\n\tfragColor = vec4( render(uv, p, rd), 1.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 89], [91, 91, 113, 113, 497], [499, 499, 531, 531, 629], [741, 741, 819, 819, 950], [952, 952, 974, 974, 1109], [1111, 1111, 1132, 1132, 1158], [1160, 1160, 1184, 1184, 1234], [1236, 1236, 1274, 1274, 1304], [1306, 1306, 1353, 1353, 1524], [1526, 1526, 1554, 1554, 1682], [1684, 1684, 1702, 1702, 1766], [1768, 1768, 1802, 1802, 2514], [2516, 2516, 2537, 2537, 2663], [2665, 2665, 2693, 2693, 2748], [2750, 2750, 2768, 2768, 3365], [3367, 3367, 3411, 3411, 3697], [3699, 3699, 3738, 3738, 3875], [3877, 3877, 3934, 3934, 4137]], "test": "untested"}
{"id": "sdcBDs", "name": "City Flight (with motion blur)", "author": "GregRostami", "description": "Flying through a city using simple raycasting.\nThis is one of my favorite shaders that I added dithered motion blur to.\nUse the mouse button to turn off the motion blur.", "tags": ["raytracing", "sky", "city", "buildings"], "likes": 40, "viewed": 951, "published": 3, "date": "1657440549", "time_retrieved": "2024-07-30T16:40:59.470330", "image_code": "// Fork of \"City Flight\" by athibaul. https://shadertoy.com/view/WstcRf\n// 2022-07-10 08:07:51\n\n// -----------\n// CITY FLIGHT\n// -----------\n// by Alexis THIBAULT\n//\n// Flying through a city using simple raymarching\n\n\n// This shader was inspired by the Disney Animation paper:\n//\n// Norman Moses Joseph, Brett Achorn, Sean D. Jenkins, and Hank Driskill.\n// Visualizing Building Interiors using Virtual Windows.\n// In ACM SIGGRAPH Asia 2014 Technical Briefs, December 2014.\n\n\n// Stuff that uses similar ideas\n// (marching a regular grid by raytracing the boxes, and\n//  putting stuff inside)\n//\n// \"Cubescape\" by iq\n// https://www.shadertoy.com/view/Msl3Rr\n\n\n// Update - adjusted the max number of iterations: it runs even faster now!\n//        - Use the \"volume\" noise texture instead of the 2D one in hash()\n//            (which is much more logical).\n//        - Added stars in the sky!\n\n\n// Should the windows be flashing?\n\n//Added motion blur with this line, and the \"Blue Noise\" texture in iChannel3:\n#define iTim (iTime + (iMouse.z>0. ? 0. : texelFetch(iChannel3,ivec2(fragCoord)%1024,0).r * iTimeDelta))\n\n#define PARTY_MODE 0\n\n\nvec2 boxIntersect(vec3 ro, vec3 rd, vec3 r, out vec3 normal, out vec3 normal2)\n{\n    // Compute intersection time t of ray ro+t*rd\n    // with a box of half-size r centered at 0.\n    ro *= sign(rd);\n    vec3 t1 = (-r-ro)/abs(rd);\n    vec3 t2 = (r-ro)/abs(rd);\n    float tmin = max(t1.x, max(t1.y, t1.z));\n    float tmax = min(t2.x, min(t2.y, t2.z));\n    normal = -sign(rd) * step(t1.yzx,t1.xyz) * step(t1.zxy, t1.xyz);\n    normal2 = -sign(rd) * step(t2.xyz,t2.yzx) * step(t2.xyz, t2.zxy);\n    if(tmax < tmin) return vec2(-1.);\n    return vec2(tmin, tmax);\n}\n\nvec3 hash(vec3 p)\n{\n    return textureLod(iChannel0, (floor(p)+0.5)*(1./32.), 0.).xyz;\n}\n\n#if 0\nvec3 sun = normalize(vec3(1.0, 1., 0.2));\nvec3 sunCol = vec3(1.,0.5,0.2);\nvec3 skyCol = vec3(0.4,0.65,1.0);\nvec3 horizonCol = vec3(0.6,0.7,0.8);\n#else\nvec3 sun = normalize(vec3(1.0, 1., 0.2));\nvec3 skyCol = vec3(0.01,0.02,0.07);\nvec3 horizonCol = vec3(0.002,0.005,0.02);\n#endif\n\nconst float T_MAX = 1000.;\nconst float FLOOR = -80.;\nconst float HEIGHT = 20.;\nconst vec3 blockSize = vec3(5.,5.,1000.);\n\nvec3 skyColor(vec3 rd)\n{\n    #if 0\n    vec3 col = skyCol;\n    vec3 horiz = mix(horizonCol, 2.5*sunCol, smoothstep(-1.,1.,dot(rd,sun)));\n    float horizHeight = 0.1*exp(-2.*(1.3-dot(sun, rd)));\n    col = mix(col, horiz, exp(-max(rd.z,0.)/horizHeight));\n    col *= exp(min(rd.z,0.)*15.);\n    #else\n    vec3 col = skyCol;\n    float horizHeight = 0.1;\n    col = mix(col, horizonCol, exp(-max(rd.z,0.)/horizHeight));\n    col *= exp(min(rd.z,0.)*15.);\n    #endif\n    return col;\n}\n\nvoid getCurrentBuilding(vec3 ro, out vec3 boxC,\n                        out vec3 buildingC, out vec3 buildingSize)\n{\n    boxC = 2.*blockSize*round(ro/(2.*blockSize));\n    buildingC = vec3(boxC.xy, -2.*HEIGHT) + vec3(2.,2.,0.)*(2.*hash(boxC.zxy)-1.);\n    vec2 maxSize = 4.5-abs(buildingC.xy-boxC.xy);\n    buildingSize = vec3(1,1,2.*HEIGHT) + vec3(maxSize.xy-1.,13.)*hash(boxC.yzx);\n}\n\n\nfloat sceneIntersect(vec3 ro, vec3 rd, out vec3 normal)\n{\n    float t = 0.;\n    float t0 = 0.;\n    vec3 boxC = vec3(0);\n    int i;\n    vec3 p;\n    const int ITER = 40;\n    vec3 buildingC, buildingSize;\n    vec3 _; // Dummy variable\n    for(i=0; i<ITER; i++)\n    {\n        // Intersect building in current box\n        getCurrentBuilding(ro, boxC, buildingC, buildingSize);\n    \tt = boxIntersect(ro-buildingC,\n                         rd, buildingSize, normal, _).x;\n        \n        // Intersect current box itself\n        float t1 = boxIntersect(ro-boxC, rd, blockSize, _, _).y;\n        \n        // Also intersect a floor plane and a sky plane\n        float tfloor = -(ro.z-FLOOR)/rd.z;\n        if(tfloor < 0.) tfloor = 1e5;\n        float tsky = -(ro.z - 20.)/rd.z;\n        if(tsky < 0.) tsky = 1e5;\n        \n        if(t > 0. && t < t1 && t < tfloor)\n        {\n            // We hit the building!\n        \t//p = ro+t*rd;\n            return t0+t;\n            break;\n        }\n        else if(tfloor > 0. && tfloor < t1)\n        {\n            // We hit the floor!\n            //p = ro+tfloor*rd;\n            return T_MAX;\n            normal = vec3(0,0,1);\n            return t0+tfloor;\n        }\n        else if(tsky > 0. && tsky < t1)\n        {\n            // We hit the ceiling!\n            return T_MAX;\n        }\n        // We hit nothing : march to the next cell\n        ro += (t1+0.001)*rd;\n        t0 += t1;\n        p = ro+t1*rd;\n        continue;\n    }\n    return T_MAX;\n}\n\nvoid getRoom(vec3 p, vec3 rd, out vec3 roomSize, out vec3 roomCenter,\n            out vec3 roomHash)\n{\n    \n    vec3 boxC, buildingC, buildingSize;\n    getCurrentBuilding(p, boxC, buildingC, buildingSize);\n\n    roomSize = buildingSize/(2.*round(buildingSize)+1.);\n    roomCenter = round((p-buildingC)/(2.*roomSize) + 0.1*rd)*2.*roomSize + buildingC;\n    roomHash = hash(roomCenter*10.);\n}\n\nvec3 someNoise(vec3 p)\n{\n    p *= 10.;\n    vec3 v = hash(p)*0.5;\n    p.xyz = p.yzx*1.62;\n    v += hash(p)*0.25;\n    p.xyz = p.yzx*1.62;\n    v += hash(p)*0.125;\n    return v;\n}\n\n\nvec3 computeEmission(vec3 p, vec3 rd, float t, vec3 normal,\n                    out float isInWindow)\n{\n\n    // Window emission depends on the ray direction...\n    // because we actually look at what's inside the room!\n    vec3 roomSize, roomCenter, roomHash;\n    getRoom(p, rd, roomSize, roomCenter, roomHash);\n    vec3 roomHash2 = hash(roomCenter.yzx);\n    vec3 q = abs(p-roomCenter);\n    vec3 inNormal, _;\n    vec2 inT = boxIntersect(p-roomCenter, rd, roomSize, _, inNormal);\n    vec3 roomP = p+inT.y*rd;\n    \n    float border = 0.1;\n    float muntins = roomHash2.z > 0.5 ? 0.01 : -0.1;\n    float w = t/(iResolution.y*dot(normal,-rd)); // A little anti-aliasing\n    isInWindow = (smoothstep(q.x-w, q.x+w, roomSize.x-border) * smoothstep(q.x+w, q.x-w, muntins)\n                + smoothstep(q.y-w, q.y+w, roomSize.y-border) * smoothstep(q.y+w, q.y-w, muntins))\n       \t\t    * smoothstep(q.z-w, q.z+w, roomSize.z-border) * smoothstep(q.z+w, q.z-w, muntins)\n                * step(-0.5,-normal.z);\n\n    #if PARTY_MODE\n    float thresh = 0.8 + 0.1*sin(6.28*iTim+6.28*roomHash.r);\n    float thresh2 = 0.85 + 0.05*sin(6.28*iTim+6.28*roomHash.g);\n    #else\n    float thresh=0.8, thresh2=0.85;\n    #endif\n    vec3 emission = vec3(1.,0.7,0.5)*smoothstep(thresh-0.1,thresh+0.2,roomHash.g)\n        + vec3(0.5,0.8,1.)*0.8*smoothstep(thresh2-0.1,thresh2+0.1,roomHash.b);\n    emission *= emission*3.0;\n\n    //emission = 0.5+0.5*inNormal;\n    //emission = (roomCenter - (ro+inT.y*rd));\n    vec3 noise = someNoise(roomP);\n    vec3 randomColor = mix(roomHash2, 1.-roomHash2.yzx, smoothstep(roomHash.x, roomHash.y,noise.rrr));\n    vec3 wallColor = dot(inNormal, 2.*roomHash-1.) > 0. ? vec3(1.0) : randomColor;\n    if(inNormal.z > 0.9)\n    {\n        // Floor is same color as the light, with some pattern\n        wallColor = emission*0.3;\n        vec3 floorP = roomHash2.y > 0.5 \n            ? vec3(roomP.x+roomP.y,roomP.x-roomP.y,roomP.z)*0.7\n            : roomP;\n        wallColor *= someNoise(floorP).rrr;\n    }\n    wallColor += 0.5;\n    \n    // Make ceiling not too bright\n    wallColor = mix(wallColor*2., vec3(0), 0.9*smoothstep(-roomSize.z, roomSize.z, roomP.z-roomCenter.z));\n    vec3 ligPos = roomCenter + 0.7*vec3(roomHash2.xy*2.-1.,1.)*roomSize;\n    float intensity = 0.5/dot(ligPos-roomP,ligPos-roomP);\n    vec3 insideLight = emission * clamp(dot(inNormal, normalize(ligPos-roomP)),0.,1.) * intensity * wallColor;\n    insideLight += 0.5*roomHash2*roomHash2*emission;\n    \n    // Some windows have \"curtains\"... but you can peek through :)\n    vec2 curtainW = roomSize.xy - 0.15;\n    float curtains = roomHash.x > 0.8 \n        ? 0.9*(smoothstep(q.x-w, q.x+w, curtainW.x) + smoothstep(q.y-w, q.y+w, curtainW.y))\n        : 0.0;\n    emission = mix(emission*(1.+roomHash2)*0.1, insideLight, 1.-curtains);\n    \n    emission *= isInWindow;\n\treturn emission;\n}\n\nvec3 raycast(vec3 ro, vec3 rd)\n{\n    vec3 normal, normal2;\n    float t = sceneIntersect(ro, rd, normal);\n    vec3 p = ro+t*rd;\n    // And after one bounce\n    vec3 ro2 = p + 0.01*normal, rd2 = reflect(rd, normal);\n    float t2 = sceneIntersect(ro2, rd2, normal2);\n    \n    //return (t < T_MAX) ? 0.5+0.5*normal : vec3(0);\n    \n    vec3 _; // Dummy variable\n    if(t < T_MAX)\n    {\n        // Let's do some shading!\n        float ao = 0.5+0.5*normal.z;\n        float darkVoid = smoothstep(FLOOR,0.,p.z);\n        ao *= darkVoid;\n        \n        float isInWindow, _;\n        vec3 emission = computeEmission(p, rd, t, normal, isInWindow);\n        vec3 emission2 = computeEmission(ro2+t2*rd2, rd2, t+t2, normal2, _);\n        emission2 = t2 < T_MAX ? emission2 : skyColor(rd2);\n        \n        vec3 roomSize, roomCenter, roomHash;\n        getRoom(p, rd, roomSize, roomCenter, roomHash);\n    \tvec3 surfCol = 0.4+0.5*smoothstep(0.5,0.9,roomHash.rrr)-0.2*isInWindow;\n        vec3 F0 = 0.04+vec3(0.04,0.1,0.2)*surfCol;\n        \n    \tvec3 fre = F0 + (1.-F0) * pow(clamp(1.-dot(-rd,normal),0.,1.),5.);\n        vec3 col = mix(emission, emission2, fre);\n        col = mix(vec3(0.), col, isInWindow);\n        //vec3 col = emission;\n        //col += surfCol* clamp(dot(normal, sun), 0., 1.) * sunCol  * darkVoid;\n        //col += surfCol* clamp(dot(normal, -rd), 0., 1.)  * darkVoid * 2./ t;\n        //col += surfCol*vec3(0.5,0.7,0.9) * 0.1 * (0.5+0.5*normal.z) * ao;\n        //col += surfCol* sunCol*sunCol * 0.1 * clamp(dot(normal.xy, -sun.xy), 0., 1.) * ao;\n        \n        col += surfCol * ao * 0.2 * (0.5-0.2*normal.z) \n            * smoothstep(10.0,-30.0,p.z) * vec3(1.,0.8,0.6);\n\t\t\n        col = mix(col, vec3(0.), 1.-exp(-t*0.003));\n        col = mix(col, skyColor(rd), 1.-exp(-t*0.01));\n        col *= exp(0.02*min(p.z,0.));\n        //col +=;\n        return col;\n    }\n    else\n    {\n        vec3 col = skyColor(rd);\n        // Stars\n        float stars = smoothstep(0.96,1.01,textureLod(iChannel1,(round(1.5*rd.yz/(rd.x+1.)*iResolution.y)+0.5)/256., 0.).r)\n            * smoothstep(0.0,1.0,textureLod(iChannel1,(rd.yz/(rd.x+1.)*450.)/256., 0.).r);\n        col += stars*stars*smoothstep(0.0,0.2,rd.z);\n        return col;\n    }\n}\n\nvec3 path(float t)\n{\n    //return vec3(20.*t, 20.0*sin(0.3*t), 5.0 - 2.*cos(0.5*t));\n    return vec3(20.*t, 5.+0.1*cos(0.5*t),10.*cos(0.5*t)*(1.-0.5*sin(0.1*t)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\t\n    //vec3 ro = vec3(-3.*cos(th),-3.*sin(th),2.0);\n    //vec3 target = vec3(0);\n    vec3 ro = path(iTim);\n    vec3 target = path(iTim+3.)+vec3(0.,20.*cos(0.3*iTim),-15.);\n    vec3 camFwd = normalize(target - ro);\n    vec3 camRight = normalize(cross(camFwd, vec3(0.3*cos(0.2*iTim),0,1))); // Camera tilts\n    vec3 camUp = cross(camRight, camFwd);\n    vec3 rd = normalize(camFwd + 0.7*(uv.x*camRight+uv.y*camUp));\n    \n    \n    vec3 col = raycast(ro, rd);\n    \n    // Vignette\n    col *= smoothstep(1.7,0.5,length(2.*fragCoord/iResolution.xy-1.));\n    // Tone mapping\n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3.,col));\n    // Gamma correction\n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1135, 1135, 1215, 1313, 1692], [1694, 1694, 1713, 1713, 1782], [2191, 2191, 2215, 2215, 2665], [2667, 2667, 2783, 2783, 3049], [3052, 3052, 3109, 3109, 4531], [4533, 4533, 4635, 4635, 4921], [4923, 4923, 4947, 4947, 5098], [5101, 5101, 5204, 5319, 7948], [7950, 7950, 7982, 7982, 10175], [10177, 10177, 10197, 10261, 10341], [10343, 10343, 10400, 10400, 11181]], "test": "untested"}
{"id": "7scBWs", "name": "Add Motion Blur to any shader 2", "author": "GregRostami", "description": "Add motion blur to any shader by including a simple #define in the Common pass (see comments).\nThis method uses procedural noise, instead of the textured blue noise.\nI've had SO MUCH FUN adding motion blur to YOUR shaders ... everything becomes SMOOTHER!!", "tags": ["raymarching", "motionblur", "utility", "small"], "likes": 12, "viewed": 817, "published": 3, "date": "1657435482", "time_retrieved": "2024-07-30T16:41:00.296122", "image_code": "// This is a fork of Fabrice's amazing tuto: motion blur (dithering):\n// https://www.shadertoy.com/view/wt3fDH\n//\n// Dithered motion blur adds motion blur to your shader without slowing it down.\n// \n// Thanks to Fabrice's help, you can add motion blur to your shader by simply\n// adding the \"Common\" Pass to your shader with this #define in it:\n// #define iTime (iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta)\n//\n// This is the easiest way of adding motion blur to your shader, since\n// all references to iTime in your shader stay intact.\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float T = iTime;\n    o-=o;\n    for(vec4 p = vec4(10.*cos(T), 0, 0, 30.+30.*sin(T)-40.*T), i = o-2.;\n        o.x > (p*.1*i+i).y; i+=.002)\n    o = i* texture(iChannel0, p.xw/2e2),\n    p.xy += u/iResolution.x*.1, p-=.05;\n    o++;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define iTime ( iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 565, 601, 601, 834]], "test": "untested"}
{"id": "NdcfDs", "name": "CRT Closeup ", "author": "kbx", "description": "some code snipped from other code held together with duct tape\ni apologise on the behalf of humanity for the horrible botching of code\ncredits to Mattias and Klems for making bloom and crt curve shaders", "tags": ["crt"], "likes": 0, "viewed": 165, "published": 3, "date": "1657421124", "time_retrieved": "2024-07-30T16:41:01.141861", "image_code": "\n// bloom code taken from https://www.shadertoy.com/view/Wd2XzD\n\n#define PI 3.14159265359\n#define PHI 1.61803398875\n\n#define SAMPLES 30\n#define BLOOM_RADIUS 50.5\n\n// from https://github.com/TheRealMJP/BakingLab/blob/master/BakingLab/ACES.hlsl\nconst mat3 ACESInputMat = mat3(\n    0.59719, 0.35458, 0.04823,\n    0.07600, 0.90834, 0.01566,\n    0.02840, 0.13383, 0.83777\n);\n\nconst mat3 ACESOutputMat = mat3(\n     1.60475, -0.53108, -0.07367,\n    -0.10208,  1.10813, -0.00605,\n    -0.00327, -0.07276,  1.07602\n);\n\nvec3 RRTAndODTFit( in vec3 v ) {\n    vec3 a = v * (v + 0.0245786) - 0.000090537;\n    vec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return a / b;\n}\n\nvec3 ACESFitted( in vec3 color ) {\n    color = color * ACESInputMat;\n    color = RRTAndODTFit(color);\n    color = color * ACESOutputMat;\n    color = clamp(color, 0.0, 1.0);\n    return color;\n}\n\n// Dave_Hoskins hash\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\nvec3 hash33( in vec3 p3 ){\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 bloom = vec3(0.15);\n    float totfac = 0.0;\n    \n    vec3 rnd = hash33(vec3(fragCoord, iFrame));\n    float offset = rnd.x*2.0*PI;\n    \n    // bloom\n    for (int i = 0 ; i < SAMPLES ; i++) {\n        float theta = 2.0*PI*PHI*float(i) + offset;\n        float radius = sqrt(float(i)) / sqrt(float(SAMPLES));\n        radius *= BLOOM_RADIUS;\n        vec2 offset = vec2(cos(theta), sin(theta))*radius;\n        vec2 delta = vec2( 1.0+exp(-abs(offset.y)*0.1) , 0.5);\n        offset *= delta;\n        vec4 here = textureGrad(iChannel0,(fragCoord+offset)/iResolution.xy, \n                                vec2(.02, 0), vec2(0, 0.02));\n        float fact = smoothstep(BLOOM_RADIUS, 0.0, radius);\n        bloom += here.rgb*1.05*fact;\n        totfac += fact;\n    }\n    \n    bloom /= totfac;\n    \n    // chromatic aberration\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mo = uv*2.0-1.0;\n    mo *= 0.01;\n    fragColor.r = textureLod(iChannel0, uv-mo*0.1, 0.0).r;\n    fragColor.g = textureLod(iChannel0, uv-mo*0.6, 0.0).g;\n    fragColor.b = textureLod(iChannel0, uv-mo*1.0, 0.0).b;\n    \n    // add bloom\n    fragColor.rgb += bloom;\n    // vignette\n    vec2 vi = fragCoord / iResolution.xy * 2.0 - 1.0;\n    fragColor.rgb *= (1.0-sqrt(dot(vi,vi)*0.45));\n    // tonemapping\n    fragColor.rgb = ACESFitted(fragColor.rgb);\n    // gamma correction\n    fragColor.rgb = pow( fragColor.rgb, vec3(1.0/2.2) );\n    // dithering\n    fragColor.rgb += (rnd-0.5)*0.1;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 tex2D(sampler2D _tex, vec2 _p) {\n\n  vec3 col = texture(_tex, _p).xyz;\n  if (0.5 < abs(_p.x - 0.5)) {col = vec3(0.1);}\n  return col;\n\n}\n\nvec2 curve(vec2 uv, float zoom) // taken and modded from shadertoy.com/view/Ms23DR\n{\n\tuv = (uv - 0.5) * 2.0;\n\tuv *= zoom;\t\n\tuv.x *= 1.0 + pow((abs(uv.y) / 5.0), 2.0);\n\tuv.y *= 1.0 + pow((abs(uv.x) / 4.0), 2.0);\n\tuv  = (uv / 2.0) + 0.5;\n\tuv =  uv *0.92 + 0.04;\n\treturn uv;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = curve(fragCoord/iResolution.xy, 1.15);\n\n    vec2 gv = vec2(fract(uv*vec2(150.))*2.-1.);\n\n    float wd = length(uv);\n    float d = length(gv);\n\n    float c = smoothstep(0.5,0.+.2,d);\n\n    vec3 col = tex2D(iChannel0, uv) * c;\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[509, 509, 541, 541, 665], [667, 667, 701, 701, 859], [927, 927, 953, 953, 1062], [1064, 1064, 1121, 1121, 2580]], "test": "untested"}
{"id": "fscBDs", "name": "006 - Varying bouncing ball", "author": "PiGIon", "description": "Today I tried to draw a shape over another. The square inside the bouncing ball should be green, but I don't know how to replace the color in a straight forward way without a step or if.\n\nOh, I discovered the mod function too, making repeating cycles.", "tags": ["beginner", "circle", "square", "learning"], "likes": 0, "viewed": 175, "published": 3, "date": "1657419885", "time_retrieved": "2024-07-30T16:41:01.993584", "image_code": "// 2022.07.09 rev 1\n// 2022.07.12 rev 2 - implement a rot2d function to rotate the ball\n\n#define PI 3.14159265\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\nfloat circle(vec2 uv, vec2 origin, float size) {\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n\n    return smoothstep(size + antiAlias, size - antiAlias, length(uv - origin));\n}\n\n\nmat2 rot2D(float ang) {\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang));\n}\n\nfloat square(vec2 uv, vec2 origin, float size, float ang) {\n    vec2 o = (uv - origin) * rot2D(ang);\n    float s;\n\n    float antiAlias = 1.5/iResolution.y; // TODO: don't recalculate this every time\n    \n    vec2 x = vec2(size-antiAlias);\n    vec2 y = vec2(size+antiAlias);\n    s = 1.-length(smoothstep(x, y, abs(o))); // TODO: maybe unnecessary 1 - inverse?\n\n    return s;\n}\n\n// returns -size to size cycle\nfloat rangeCycle(float size, float perSec) {\n    return mod(iTime*perSec - size, size) - .5*size;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    \n    vec3 O = fragColor.xyz;\n    \n    float shapeSize = 0.1;\n    shapeSize += cycle(0.3999) * 0.4;\n    vec2 shapeOrigin = vec2(0.);\n    \n    shapeOrigin.x += rangeCycle(5., 1.88);\n    float c = cycle(1.);\n    // range from bottom of screen to top of screen, determined by the shape size\n    shapeOrigin.y = shapeSize - 1. + (1. - shapeSize)*(2. * c);\n    \n    O += vec3(circle(uv, shapeOrigin, shapeSize)*0.89, 0., 0.1);\n    \n    // I need to discover the size of the section of the circle, here, I use pythagorean theorem to do it\n    O = vec3(O.x,\n            0.78 * square(uv, shapeOrigin, sqrt((pow(shapeSize/2., 2.) + pow(shapeSize/2., 2.))),\n            rangeCycle(PI, 1.33)), O.z);\n    \n    fragColor.xyz = O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[112, 229, 259, 1289, 1640], [1642, 1642, 1690, 1690, 1857], [1860, 1860, 1883, 1883, 1943], [1945, 1945, 2004, 2004, 2320], [2322, 2353, 2397, 2397, 2452], [2454, 2454, 2511, 2511, 3304]], "test": "untested"}
{"id": "fdtfWf", "name": "one cube challenge - voxels", "author": "DjinnKahn", "description": "\"one cube challenge\": the idea is to draw a spinning cube with very little code [url]https://www.shadertoy.com/view/4d33R8[/url]\n\nI thought using ray marching with voxels might give a good result. My code isn't really golfed, but it should be a good start", "tags": ["cube"], "likes": 5, "viewed": 262, "published": 3, "date": "1657347327", "time_retrieved": "2024-07-30T16:41:02.866251", "image_code": "// public domain\n\n////212 chars from FabriceNeyret2:\n//void mainImage( out vec4 f, vec2 u )\n//{\n//    vec3 R = iResolution, p, P = R-R; P.z-= 6.;\n//    for ( f += 1.-f;  P.z < 7.;  \n//          dot(p=sign( 2. - abs(round(p))),p) < 2. && p == p*p ? f *= .99 : f\n//        )\n//        p = P += .01*vec3( (u+u-R.xy)/R.y, 1 ), \n//        p.xz *= mat2(cos(iTime+vec4(0,33,11,0)));\n//}\n\n\nvoid mainImage( out vec4 f, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; // normalize input coord\n    \n    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) ); // rotation matrix\n        \n    float CAMERA_DIST = 6.;\n    \n    vec3 pos = m * vec3( 0., 0., -CAMERA_DIST );\n    vec3 v = m * vec3( uv, 1. );\n    \n    f = vec4(1.);    \n    for ( ; length(pos) < 7.; pos += v*.01 ) // ray-march until ray is far away\n    {\n        float CUBE_SIZE = 2.;        \n        vec3 voxelPos = round(pos); // voxel (5,5,a) or (5,a,-5) or (-5,-5,a) is ON for abs(a) <= 5\n        vec3 p = sign( CUBE_SIZE - abs(voxelPos));  // p value of (0,0,1) or (0,1,0) or (0,0,1) is ON\n        if ( length(p) <= 1. && p == abs(p) )\n        //if ( p*p-p*p.yzx == p )\n            f *= vec4(.99);\n    }\n}\n\n////213 chars from FabriceNeyret2: (old style rendering)\n//void mainImage( out vec4 f, vec2 u )\n//{\n//    vec3 R = iResolution,p;\n//  \n//    f-=f;\n//    for ( float t = 0.; t < 99.; t += .1 ) \n//        p = vec3( ( u+u - R.xy ) / R.y *t , t - 15. ), \n//        p.xz *= mat2(cos(iTime+vec4(0,33,11,0))) ,\n//        p = sign( 5. - abs(floor(p))),\n//        dot(p,p) <= 1. && p == p*p ? f += .06 : f;\n//}\n\n\n\n\n// ray-marching + voxels\n//\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y; // normalize input coord\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) ); // rotation matrix\n//        \n//    float CAMERA_DIST = 15.;\n//    \n//    vec3 pos = m * vec3( 0., 0., -CAMERA_DIST );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 25.; t += .01 ) // sample 99 positions\n//    {\n//        float CUBE_SIZE = 5.;\n//        vec3 voxelPos = floor(pos + v*t); // voxel (5,5,a) or (5,a,-5) or (-5,-5,a) is ON for abs(a) <= 5\n//        vec3 p = sign( CUBE_SIZE - abs(voxelPos));  // p value of (0,0,1) or (0,1,0) or (0,0,1) is ON\n//        if ( length(p) <= 1. && p == abs(p) )\n//        //if ( p*p-p*p.yzx == p )\n//            f += vec4(.006);\n//    }\n//}\n\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = vec3( -sin(iTime), 0., cos(iTime) ) * -15.;\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = 5. - floor(abs(pos + v*t));  \n//        //if ( p*p.yzx+p == abs(p) )\n//        if ( p*p*p*p.yzx + p == abs(p) )\n//            f += vec4(.06);\n//    }\n//}\n\n\n//void mainImage( out vec4 f, in vec2 fragCoord )\n//{\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -15. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    f = vec4(0.);\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = sign( 5. - floor(abs(pos + v*t)));  \n//        if ( p*p.yzx+p == abs(p) )\n//        //if ( p*p*p*p.yzx + p == abs(p) )\n//            f = vec4(1.);\n//    }\n//    \n//    // Output to screen\n//    //f = vec4(col);\n//}\n\n\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -15. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    float col = 0.;\n//    \n//    for ( float t = 0.; t < 99.; t += .1 )\n//    {\n//        vec3 p = 5. - floor(abs(pos + v*t));  \n//        //if ( length(p) == p.x+p.y+p.z && p.x*p.y*p.z == 0. )\n//        if ( p*p.yzx == vec3(0.) && p == abs(p) )\n//        //if ( p*p*p*p.yzx + p == abs(p) )\n//            col = 1.;\n//    }\n//    \n//    // Output to screen\n//    fragColor = vec4(col);\n//}\n//\n\n\n//float sphereCol( vec3 a, vec3 v, float r )\n//{    \n//    return 1. - ( dot(a,a) - dot(a,v)*dot(a,v)/dot(v,v) ) / (r*r);\n//}\n//\n//void mainImage( out vec4 fragColor, in vec2 fragCoord )\n//{\n//    // Normalized pixel coordinates (from 0 to 1)\n//    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n//    \n//    mat3 m = mat3( cos(iTime), 0., sin(iTime), 0., 1., 0., -sin(iTime), 0., cos(iTime) );\n//        \n//    vec3 pos = m * vec3( 0., 0., -8. );\n//    vec3 v = m * vec3( uv, 1. );\n//    \n//    vec3 spherePos = vec3( -1., 0., 0. );\n//    \n//    vec3 a = spherePos - pos;\n//    float distToSphere = dot(a,a) - dot(a,v)*dot(a,v)/dot(v,v);\n//    \n//    float col = 0.;\n//\n//    col += max( 0., sphereCol( vec3( -2., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( -1., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 0., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 1., 0., 0. ) - pos, v, 1. ) );\n//    col += max( 0., sphereCol( vec3( 2., 0., 0. ) - pos, v, 1. ) );\n//    \n//    // Output to screen\n//    fragColor = vec4(col);\n//}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtfWf.jpg", "access": "api", "license": "public-domain", "functions": [[382, 382, 431, 431, 1222]], "test": "untested"}
{"id": "fddfDX", "name": "SSGI Cornell", "author": "Tater", "description": "Rather janky ssgi I ported & modified to shadertoy, it could be much faster and better but I'm publishing it incase it might help someone else. ", "tags": ["cornell", "ssgi"], "likes": 29, "viewed": 1375, "published": 3, "date": "1657340452", "time_retrieved": "2024-07-30T16:41:03.923425", "image_code": "\n//  Common: Scene and other functions\n//Buffer A: Normals and Depth \n//Buffer B: Direct Lighting\n//Buffer C: SSGI \n//Buffer D: Denoise 1\n//   Image: Denoise 2\n\n\n//Short Explanation:\n/*\nAlgorithm is by Alexander Sannikov, as implimented in \"Legit Engine\"\nwhich (I believe) is based on \"Horizon Based Ambient Occlusion\" \n\nhttps://developer.download.nvidia.com/presentations/2008/SIGGRAPH/HBAO_SIG08b.pdf\nhttps://github.com/Raikiri/LegitEngine\n\nEach pixel traverses the depth map in a fixed numbed of directions in screen space\n\nThe points along each direction are sampled with exponential sampling,\nat each sample the horizon angle is calculated, if the sample is visible then its \nlighting contribution is calculated base on currently visible horizon. \n\nThe samples from all directions are then combined to get the lighting\n*/\n\n//still needs:\n//a better denoiser\n//proper temporal reprojection\n//better sampling pattern\n//\"deinterleaved\" rendering? (could this even work on shadertoy?) \n//faster\n//sample rejection from normal to prevent bleeding (seems to cause artifacts) (also slow, extra tap D: )\n//dynamically pick mip level for sampling\n\n//Image shader\n//Denoise Pass 2\nvec3 fragCamPos = vec3(0);\nvec3 screenToWorld(vec3 screenPos)\n{\n  screenPos.xy -= 0.5;\n  screenPos.xy /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = fragCamPos;\n  mat3 camMat = getCamMatrix(ro,vec3(0));\n  vec3 rd = camMat*normalize(vec3(screenPos.xy , 1./FOV)); \n  return ro + screenPos.z*rd;\n}\n\n//Denoise is weighted based on worldspace distance and alignment of normals\nvec3 edgeDenoise(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragSample = texture(iChannel0, uv);\n    vec3 fragNormal = fragSample.xyz;\n    float fragDepth = fragSample.w;\n    vec3 fragPos = screenToWorld(vec3(uv, fragDepth));\n    float weight = 0.0;\n    vec3 col = vec3(0);\n    float kSize = kSize2;\n    for(float i = -kSize; i <=kSize; i++){\n        for(float j = -kSize; j <=kSize; j++){\n            vec2 sampleUV = (fragCoord + vec2(i,j)*jank)/iResolution.xy;\n            vec4 dSample = texture(iChannel0, sampleUV);\n            vec3 sampleNorm = dSample.xyz;\n            float sampleDepth = dSample.w;\n            vec3 samplePos = screenToWorld(vec3(sampleUV, sampleDepth));\n            float normAlignment = clamp(dot(sampleNorm, fragNormal), 0.0, 1.0);\n            float delta = distance(samplePos, fragPos) * 0.1;\n            vec3 sampleCol = texture(iChannel2, sampleUV).rgb;\n            float sampleWeight = normAlignment / (delta + 1e-2);\n            weight += sampleWeight;\n            col += sampleCol * sampleWeight;\n        }\n    }\n    return col/weight; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Init camera position\n    fragCamPos = getCamPos(iTime,iMouse,iResolution);\n    \n    #ifdef DENOISE\n    //Get denoised image\n    fragColor.rgb = edgeDenoise(fragCoord);\n    #else\n    fragColor.rgb = texture(iChannel3,fragCoord/iResolution.xy).rgb;\n    #endif\n    //Show direct lighting on screen\n    fragColor += texture(iChannel1,fragCoord/iResolution.xy);\n    \n    //Gamma Correction\n    fragColor = pow(fragColor, vec4(1.0 / 2.2));\n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//Common Functions\n\n#define DENOISE\n\n//Defines if previous frame lighting is used to approximate bounce light\n#define BOUNCE\nconst float absorbtion = 0.3;\n\nconst float FOV = 0.95;\n\n//Camera target/look-at position\nconst vec3 look = vec3(0,0,0);\n\n//Blur/denoise kernal sizes\nconst float kSize1 = 5.0;\nconst float kSize2 = 4.0;\nconst float jank = 3.;\n\nconst float pi = 3.1415f;\n\nfloat linstep(float a, float b, float x){\n    return clamp((x - a)/(b - a), 0., 1.); \n}\n\nmat3 getCamMatrix(vec3 ro, vec3 look) {\n    vec3 f = normalize(ro - look);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f)); \n    return mat3(-r, normalize(cross(f, r)), -f);\n}\n\n//2d rotation matrix\nmat2 rot(float a){\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec3 getCamPos(float iTime, vec4 iMouse, vec3 iResolution)\n{\n    vec3 ro = vec3(0.01,0.06,12.4);\n    if(iMouse.z>0.){\n       ro.yz*=rot(2.0*(iMouse.y/iResolution.y-0.5));\n       ro.zx*=rot(-9.0*(iMouse.x/iResolution.x-0.5));\n    }\n    return ro;\n}\n\n//Blackle hash (CC0) \n#define FK(k) floatBitsToInt(cos(k))^floatBitsToInt(k)\nfloat hash(vec2 p) {\n  int x = FK(p.x); int y = FK(p.y);\n  return float((x-y*y)*(x*x+y)-x)/2.14e9;\n}\n\n\n//iq box \nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n//SDF of the scene\nfloat map(vec3 p)\n{\n    vec3 po = p;\n    float a = 0.;\n    a = -box(p,vec3(2,2,2)*2.);\n    a = max(p.z-3.9,a);\n    p-=vec3(-1.7,-3,1.7);\n    p.xz*=rot(-0.4);\n    a = min(box(p,vec3(1)*1.15),a);\n    p = po;\n    p-=vec3(1.2,-3,-1.);\n    p.xz*=rot(0.5);\n    a = min(box(p,vec3(1,3,1)*1.25),a);  \n    p = po;\n    a = max(box(p,vec3(2,2,2)*2.3),a);\n\n    return a;\n\n}\n\n//Simple way to get the color of walls\nvec3 getColor(vec3 p){\n    if(p.x>3.99)\n        return vec3(1.0,0.0,0.0);\n    if(p.x<-3.99)\n        return vec3(0.0,1.0,0.0);\n    return vec3(1.0);\n    \n}\n\nvec3 norm(vec3 p){\n    vec2 e = vec2(0.01,0.);\n    return normalize(map(p)-vec3(\n    map(p-e.xyy),\n    map(p-e.yxy),\n    map(p-e.yyx)));\n}\n\n", "buffer_a_code": "//Buffer A\n//Depth and Normals buffer\n\n//This buffer raymarches the SDF in common for depth and normals\n#define MDIST 150.0\n#define STEPS 128.0\n#define pi 3.1415926535\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 col = vec3(0);\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = getCamPos(iTime,iMouse,iResolution);\n    \n    //create camera matrix and get ray direction\n    mat3 camMat = getCamMatrix(ro,look);\n    vec3 rd = camMat*normalize(vec3(uv, 1./FOV)); \n\n    //setup sdf raymarcher\n    vec3 p = ro;\n    float rl = 0.0; \n    vec3 d;\n    bool hit = false;\n    for(float i = 0.; i<STEPS; i++){\n        p = ro+rd*rl;\n        d = map(p)*vec3(1);\n        rl+=d.x;\n        if(abs(d.x)<0.001){\n            hit = true;\n            break;\n        }\n        if(rl>MDIST)\n            break;\n    }\n    vec3 n = norm(p);\n    fragColor = vec4(n,rl);\n}", "buffer_a_inputs": [], "buffer_b_code": "//Buffer B\n//Direct lighting buffer\n\n//Just some messy code to put a square on the top of the box using depth buffer\nfloat maxNormDist(vec3 p){\n    vec3 d = abs(p);\n    return max(d.x,max(d.y,d.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec3 ro = getCamPos(iTime,iMouse,iResolution);\n    mat3 camMat = getCamMatrix(ro,look);\n    float time = iTime * 0.8;\n    vec3 rd = camMat * normalize(vec3(uv, 1./FOV)); \n    float depth = texture(iChannel0,fragCoord/iResolution.xy).w;\n    \n    vec3 pos = ro + depth * rd;\n\n    vec3 light = vec3(0.992,1.000,0.639) * 8.0 * \n    smoothstep(0., 0.1, -maxNormDist(pos + vec3(cos(time) * 0.6, -3.0, sin(time)*0.6)) + 2.0);\n    if(pos.y<3.99 || pos.y> 4.05)\n    light-=light;\n    fragColor = vec4(vec3(light),1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Buffer C\n//Screen Space GI pass\n//\n//Heavily Modified/Simplied/Partially re-written version of SSGI by Alexander Sannikov from \"Legit Engine\"\n//\n//Alexander Sannikov\n//MIT License\n//https://github.com/Raikiri/LegitEngine\n//\n\n\n//Sample directions controls noise\nconst int sampleDirs = 6;\n\n//Sample density controls accuracy \nconst float sampleDensity = 0.75; //0.0-0.9\n\nconst float ambientLightAmount = 0.001;\nconst float edgeFadeWidth = 0.1;\n\nvec3 fragCamPos = vec3(0);\n\nvec3 screenToWorld(vec3 screenPos)\n{\n  screenPos.xy -= 0.5;\n  screenPos.xy /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = fragCamPos;\n  mat3 camMat = getCamMatrix(ro,vec3(0));\n  vec3 rd = camMat*normalize(vec3(screenPos.xy , 1./FOV)); \n  return ro + screenPos.z*rd;\n}\n\nfloat HorizonContribution(vec3 rayDir, vec3 worldTangent, vec3 viewNorm, float minAngle, float maxAngle)\n{\n    minAngle *= 2.0; \n    maxAngle *= 2.0;\n    return 0.25 * (dot(rayDir, viewNorm) * (-cos(maxAngle) + cos(minAngle)) + dot(worldTangent, viewNorm) * (maxAngle - minAngle - sin(maxAngle) + sin(minAngle)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    #ifdef JITTERUV\n    fragCoord += (vec2(hash(vec2(iTime)),hash(vec2(iTime+0.5)))-0.5);\n    #endif\n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec3 fragNorm  = texture(iChannel0, uv).xyz;\n    float fragDepth = texture(iChannel0, uv,1.0).w;\n    \n    fragCamPos = getCamPos(iTime,iMouse,iResolution);\n    vec3 fragWorldPos = screenToWorld(vec3(uv, fragDepth));\n    vec3 rayDir = normalize(fragCamPos - fragWorldPos);\n\n\n    //Random rotation and linear jitter for all directions per pixel\n    //TODO: try using some low discrepancy noise/sequence\n    float seed = mod(float(iFrame),10.0); //hack to get temporally stable result :)\n    float angleOffset = hash(uv+seed) * pi * 2.0;\n    float linearOffset = hash(uv+angleOffset);\n\n    float exponentialDensity = 1.0 / sampleDensity;\n    float maxPixelDist = max(iResolution.x,iResolution.y);\n\n    vec3 indirectLight = vec3(0);\n    vec3 ambientLight = vec3(0);\n    \n    //Sample from multiple linear screenspace directions\n    for(int dirIndex = 0; dirIndex < sampleDirs; dirIndex++)\n    {\n        //get direction vector for samples in this direction \n        float dirAngle = 2.0 * pi / float(sampleDirs) * (float(dirIndex) + angleOffset);\n        vec2 dirVector = vec2(cos(dirAngle), sin(dirAngle));\n        \n        //offset world pos to get tangent vector\n        vec3 offsetWorldPos = screenToWorld(vec3((fragCoord + dirVector) / iResolution.xy, fragDepth));\n        vec3 worldTangent = normalize(rayDir + normalize(offsetWorldPos - fragCamPos));\n        \n        //Get 2d normal in the plane of the current direction\n        vec3 dirNormalPos = cross(-cross(worldTangent, rayDir), fragNorm);\n        \n        //Initial direction of horizon angle\n        vec2 projFront = vec2(dot(rayDir, dirNormalPos), dot(worldTangent, dirNormalPos));\n        \n        //ititalize max horizon angle\n        float maxAngle = atan(projFront.y, projFront.x);\n        \n        vec3 dirLight = vec3(0);\n        vec3 dirAmbient = ambientLightAmount * HorizonContribution(rayDir, worldTangent, fragNorm, 0.0, maxAngle) * getColor(fragWorldPos) * vec3(1);\n        \n        int sampleCount = int(log(maxPixelDist)/log(exponentialDensity)) + 2;\n        \n        //Sample a series of points in the stright screenspace line\n        for(int sampleIndex = 0; sampleIndex < sampleCount; sampleIndex++)\n        {\n            //Move offset along the direction with exponential sampling pattern to get\n            //screen space sample position\n            float pixelOffset = pow(exponentialDensity, float(sampleIndex) + linearOffset);\n            pixelOffset = max(pixelOffset,float(sampleIndex)*2.+1.);\n            //pixelOffset = float(sampleIndex)*7.+1. + linearOffset;\n            vec2 sampleUV = (fragCoord + dirVector * pixelOffset) / iResolution.xy;\n            \n            //If sample is offscreen then stop sampling this direction\n            if(max(sampleUV.x, sampleUV.y) > 1.0 || min(sampleUV.x, sampleUV.y) < 0.0)break;\n\n            //Calculate \"edgeFade\" to reduce intensity of light near edge of screen (avoids distracting popping)\n            vec2 d = abs(sampleUV - 0.5);\n            float mult = max(d.x, d.y);\n            float edgeFade = linstep(0.5, 0.5 - max(edgeFadeWidth,0.01), mult);\n            \n            //Sample depth and get sample horizon angle\n            float sampleDepth = textureLod(iChannel0, sampleUV.xy, 1.0).w;\n            vec3 sampleWorldPos = fragCamPos + normalize(screenToWorld(vec3(sampleUV, 1.0)) - fragCamPos) * sampleDepth;\n            vec3 worldDir = normalize(sampleWorldPos - fragWorldPos);\n            vec2 projTangetDir = vec2(dot(rayDir, worldDir), dot(worldTangent, worldDir));\n            float sampleAngle = atan(projTangetDir.y, projTangetDir.x);\n            \n            //If sampled world space position is visible then find its contribution\n            if(sampleAngle < maxAngle)\n            {\n                //Get direct lighting (sampling in higher mip to greatly improve perf, could be dynamic)\n                vec3 directLight = textureLod(iChannel1, sampleUV.xy, 3.0).rgb;\n\n                \n                //Optionaly include indirect lighting from previous frame to approximate multiple bounces\n                float absorb = 0.0;\n                #ifdef BOUNCE\n                absorb = absorbtion;\n                directLight += edgeFade * max(absorb * textureLod(iChannel2, sampleUV.xy, 3.0), 0.0).rgb;\n                #endif \n                float sampleContribution = (1.0 - absorb) * edgeFade * HorizonContribution(rayDir, worldTangent, fragNorm, sampleAngle, maxAngle);\n                \n                maxAngle = sampleAngle;\n                \n                //Add to indirect lighting and subtract from ambient\n                dirLight += directLight * sampleContribution * getColor(fragWorldPos);\n                dirAmbient -= ambientLightAmount * sampleContribution;\n            }\n        }\n        indirectLight += (dirLight) / float(sampleDirs) * 2.0;\n        ambientLight += (dirAmbient) / float(sampleDirs) * 2.0;\n    }\n    \n    //Combining ambient light with indirect light for simplicity but they could be kept seperate\n    //for more accuracy \n    indirectLight+=vec3(ambientLight);\n    \n    fragColor.rgb = indirectLight;\n\n    //Accumulate a few past frames\n    //This should probably use temporal reprojection but not enough buffers\n    \n    //if(iMouse.z<0.5)\n        fragColor.rgb = mix(texture(iChannel2,fragCoord/iResolution.xy).rgb, indirectLight, 0.15);\n        \n    //Clamp just for saftey\n    fragColor = clamp(fragColor,0.0,1.0);\n}\n\n\n\n\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Buffer D\n//Denoise pass 1\n\nvec3 fragCamPos = vec3(0);\nvec3 screenToWorld(vec3 screenPos)\n{\n  screenPos.xy -= 0.5;\n  screenPos.xy /= vec2(iResolution.y / iResolution.x, 1);\n  vec3 ro = fragCamPos;\n  mat3 camMat = getCamMatrix(ro,vec3(0));\n  vec3 rd = camMat*normalize(vec3(screenPos.xy , 1./FOV)); \n  return ro + screenPos.z*rd;\n}\n\n//Denoise is weighted based on worldspace distance and alignment of normals\nvec3 edgeDenoise(vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 fragSample = texture(iChannel0, uv);\n    vec3 fragNormal = fragSample.xyz;\n    float fragDepth = fragSample.w;\n    vec3 fragPos = screenToWorld(vec3(uv, fragDepth));\n    float weight = 0.0;\n    vec3 col = vec3(0);\n    float kSize = kSize1;\n    for(float i = -kSize; i <=kSize; i++){\n        for(float j = -kSize; j <=kSize; j++){\n            vec2 sampleUV = (fragCoord + vec2(i,j))/iResolution.xy;\n            vec4 dSample = texture(iChannel0, sampleUV);\n            vec3 sampleNorm = dSample.xyz;\n            float sampleDepth = dSample.w;\n            vec3 samplePos = screenToWorld(vec3(sampleUV, sampleDepth));\n            float normAlignment = clamp(dot(sampleNorm, fragNormal), 0.0, 1.0);\n            float delta = distance(samplePos, fragPos) * 0.1;\n            vec3 sampleCol = texture(iChannel1, sampleUV).rgb;\n            float sampleWeight = normAlignment / (delta + 1e-2);\n            weight += sampleWeight;\n            col += sampleCol * sampleWeight;\n        }\n    }\n    return col/weight; \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    //Init camera position\n    fragCamPos = getCamPos(iTime,iMouse,iResolution);\n    //Get denoised image\n    #ifdef DENOISE\n    fragColor.rgb = edgeDenoise(fragCoord);\n    #endif\n    //Clamp just for saftey\n    fragColor = clamp(fragColor,0.0,1.0);\n}\n\n", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1203, 1203, 1239, 1239, 1478], [1480, 1556, 1590, 1590, 2653], [2655, 2655, 2711, 2738, 3153]], "test": "untested"}
{"id": "NstBDX", "name": "circle path", "author": "jorge2017a2", "description": "circle path", "tags": ["circlepath"], "likes": 5, "viewed": 208, "published": 3, "date": "1657335460", "time_retrieved": "2024-07-30T16:41:04.851942", "image_code": "//----------image\n//por jorge2017a2-\n//circle path---8-jul-2022\n#define MAX_STEPS 100\n#define MAX_DIST 120.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec3 funYZ(float z)\n{   float v1,v2; \n    v1= 7.0 * sin(z * 0.15);\n    v2= 5.0 * sin(z * 0.07);\n    return vec3(v1,v2,0.0);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tp.y=p.y-5.0;\n    vec3  pf1= funYZ(p.z);\n     vec3 p1=p-pf1;\n    float mxr=1000.0; //maximo camin\n    float d1a= sdCylinderXY(p1, vec2(10.0,mxr) );\n    float d1b= sdCylinderXY(p1, vec2(5.0,mxr) );\n    p1.y-=9.0;\n    float d1c=sdBox(p1, vec3(12,10.0,1000.0) );\n    \n    d1a=Difference(d1a,d1b);\n    d1a=Difference(d1a,d1c);\n\n    p1.y+=10.0;\n    p1.z= opRep1D( p1.z, 20. );\n    float d2a= sdCylinderXY(p1, vec2(9.0,0.25) );\n    float d2b= sdCylinderXY(p1, vec2(8.0,0.26) );\n    d2a=Difference(d2a,d2b);\n    res =opU2(res, vec2(d1a,100.0));\n    res =opU2(res, vec2(d2a,101.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   \n    float d = GetDist(p).x;\n    vec2 e = vec2(.0001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.5,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.1;\n    float lightSize = 0.3;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < EPSILON || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = EPSILON + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    //diff = pow(diff, 0.75) * 4.0;   //antes\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.25,0.6)*2.0; }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    return sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*8.0+50.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0,-25.0); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 30.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,-5.0,-25.0+t);\n    vec3  pf1= funYZ(ro.z);\n    ro=ro+pf1;\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, 0.79/2.0);\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstBDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 521, 521, 605], [606, 606, 645, 645, 740], [742, 742, 786, 786, 813], [814, 814, 854, 854, 881], [882, 882, 927, 927, 955], [957, 957, 993, 993, 1038], [1040, 1040, 1074, 1074, 1170], [1171, 1171, 1205, 1205, 1296], [1297, 1297, 1331, 1331, 1422], [1425, 1425, 1446, 1446, 1550], [1552, 1552, 1577, 1577, 2236], [2238, 2238, 2262, 2262, 2430], [2432, 2432, 2480, 2480, 2759], [2762, 2762, 2806, 2806, 3126], [3128, 3128, 3165, 3165, 3425], [3428, 3428, 3518, 3518, 4522], [4524, 4524, 4573, 4573, 4733], [4735, 4735, 4767, 4767, 4967], [4969, 4969, 5039, 5039, 5132], [5134, 5134, 5161, 5161, 5250], [5252, 5252, 5310, 5310, 5358], [5360, 5360, 5383, 5383, 5495], [5497, 5497, 5528, 5528, 6156], [6158, 6158, 6215, 6215, 6729]], "test": "untested"}
{"id": "NdtfWX", "name": "Optimization of Shane's 3D Zoom", "author": "dracusa", "description": "So I was scrolling through the \"old new\" list, and I saw Shane's beautiful zoomer... Perfect occasion to check the performance of shell tiling vs. loop-based recursive geometry! Result for me is a 4x speedup, based on the plugin in fullscreen mode.", "tags": ["3d", "zoom", "infinite", "shell"], "likes": 21, "viewed": 490, "published": 3, "date": "1657330002", "time_retrieved": "2024-07-30T16:41:05.947015", "image_code": "/*\n    This is a fork of Shane's \"Infinite 3D Zoom\":\n    https://www.shadertoy.com/view/sljfDD\n\n    The purpose of the fork is to test \"shell tiling\" as an optimization for\n    infinite/recursive scenes. The original 16x loop in the map function has\n    been replaced with a single lookup, now the same geometry is only\n    calculated 2x per map call.\n\n    Imagine the scene is composed of onion layers with a given thickness,\n    aka shells in geometry. Now, check how far we are from (0,0,0), deduce\n    which shell we're in, and calculate the SDF for this shell \"tile\", with\n    its own zoom level. Tragically, this breaks the overall SDF because of\n    hard discontinuities at the edges between shells. This is worked around\n    by combining with the SDF of one adjacent shell tile.\n    \n    This optimization is a logical continuation of the series I did a\n    couple of years ago: https://www.osar.fr/notes/logspherical/\n    The technique used here is actually simpler and faster than the stuff\n    described in the article, all the trigonometry is removed.\n\n    You might notice the scene looks a bit different, this is because shell\n    tiling requires reformulating the layout in different terms. It could\n    be made more similar to the original but I'm not sure how much.\n    \n    Comments below are from Shane's original shader, except those prefixed\n    with \"dracusa edit\" to show where I made changes, mostly around lines\n    150-215. I tried to keep the original level of commentage.\n*/\n\n/*\n\n    Infinite 3D Zoom\n    ----------------\n\n\tThis is just a dressed up version of a basic cube zooming animation.\n    The animation portion was pretty straight forward, so took no time at\n    all. However, I spent way too long dressing it up to a stage where I\n    was only mildy satisfied with the result. The original had a nicer \n    reflective pass, but I couldn't afford to use it... You can't win them \n    all, but if you like drab brown-looking one pass scenes, then you'll \n    love this. :D Oh well, post and move on, as they say. :)\n    \n    For those not familiar with the infinite zoom illusion, it's a pretty\n    simple concept: In the 2D sense, you produce a miniscule object then \n    expand its size to some maximum before snapping it back to its original\n    minimum size (the fract funciton does that). On its own, it's not very\n    illusory, however, if you do the same with multiple objects at various \n    stages in the expansion process, your mind gets tricked into believing \n    that a camera is zooming toward the central object -- In reality, the \n    camera is effectively stationary. This particular example is just a 3D \n    extension on the aforementioned with various tweaks.\n    \n    Anyway, there are better zoom examples than this on Shadertoy, so if\n    that kind of thing interests you, search \"infinite zoom\" or something \n    along those lines. I have some 2D zooming animations that I might post\n    at a later date.\n    \n    \n\n\tOther examples:\n    \n    // You can't list zoom examples without referencing this.\n    // It's everywhere these days.\n    Infinite KIFS Zoom - andyalias\n    https://www.shadertoy.com/view/4sS3WV\n    \n    // Golden spiral zoom. Typical simple and stylish example\n    // by IQ.\n    Golden Ratio and Spiral - iq\n    https://www.shadertoy.com/view/fslyW4\n    \n    // One of many of KilledByAPixel's really nice zoom examples.\n    Infinity Matrix - KilledByAPixel\n    https://www.shadertoy.com/view/Md2fRR\n    \n    // Fabrice has a few examples. This is his most recent. \n    infinite zoom in rolling squares - FabriceNeyret2 \n    https://www.shadertoy.com/view/fl2Bzm\n    \n    // Awesome example -- Requires a strong GPU.\n    Bloom [skull] - tdhooper\n    https://www.shadertoy.com/view/WdScDG\n    \n    // Oldschool bump mapped zoom effect, written years ago.\n    Quasi Infinite Zoom Voronoi  - Shane\n\thttps://www.shadertoy.com/view/XlBXWw \n\n*/\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    //vec2 w = vec2( sdf, abs(pz) - h );\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .005;\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\nfloat gS;\nmat2 gR;\n\n\n// dracusa edit: pick a density and get its inverse and exp.\n// this determines how tight together the shells are.\nconst float dens = 1.25;\nconst float idens = 1./dens;\nconst float stepZoom = exp(idens);\n\n// dracusa edit: how much each shell tile is rotated\nconst float twist = .25;\n\n// dracusa edit: this defines a single shell tile\nvoid shell(vec3 p, float shellN, inout float distOut){\n    // how much scaling is applied to this shell tile.\n    float tileScale = exp(shellN*idens);\n\tp /= tileScale;\n    // constant scale to fit the original geometry into the shape of the\n    // shell as closely as possible, minimizing SDF breakage.\n    float s = .6;\n    // below is the content of Shane's loop from the original\n    // Infinite 3D Zoom:\n\n    // Adding linear XY rotation for a bit of extra visual interest. \n    // You can leave it out, if you'd prefer the boxes to look more static.\n    mat2 r = rot2(shellN*twist); \n\n    // Rotate the XY plane.\n    vec2 q = p.xy*r;\n\n    // Rounded box.\n    float box = sBoxS(q, vec2(s), .2*s*1.);\n    // Circular box option... Otherwise known as a circle. :D\n    // You'd need to make changes to the bump and texturing functions.\n    //float box = length(q) - s; \n\n    // Extrude -- Inner and outer with separation\n    float sep = .6 / (1. + 18. * tileScale);\n    float di = opExtrusion(box+.0*s, p.z - s, .25 - sep*0.4);\n    float di2 = opExtrusion(abs(box + .04*s) - .04*s, p.z - s, 0.25 + sep);\n    //di2 += smoothstep(0., .5, cos(box*80./s + .0))*.01*s;\n    di = min(di, di2);\n\n\t// dracusa edit: compensate for this tile's scaling.\n    // Optionally shorten the rays to work around dicontinuities.\n\tdi *= tileScale*.99;\n\n    // Record the minimum extruded box distance.\n    if(di<distOut){\n        distOut = di;\n        gR = r;\n        gS = tileScale*s;\n    }\n}\n\n// dracusa edit: this function is rewritten\nfloat map(in vec3 p)\n{\n    // which shell are we in?\n    float rho = log(length(p)) - iTime*.6;\n    float shellN = floor(rho*dens) + (iTime*.6)*dens;\n\t\n\t// Get distance to geometry in this and adjacent shell\n    float d = 1e5;\n\tshell(p, shellN, d);\n\tshell(p, shellN+1., d);\n\treturn d;\n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... \n    // Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .85;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n///////\n\n#define STATIC\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) {  \n     \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    \n    #ifdef STATIC\n    return fract(vec2(262144, 32768)*n); \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime/2.)*.5 + .5; \n    #endif\n}\n\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n\n/*\n// IQ's polynomial-based smooth minimum function.\nvec3 smin( vec3 a, vec3 b, float k ){\n\n    vec3 h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// The is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n\nfloat vAng;\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\nvec3 Voronoi(in vec2 p){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n#if 1\n    // Slower, but handles big numbers better.\n    vec2 n = floor(p);\n    p -= n;\n    vec2 h = step(.5, p) - 1.5;\n    n += h; p -= h;\n#else\n    vec2 n = floor(p - 1.);\n    p -= n;\n#endif\n    \n    \n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., md2, lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n    \n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n\t\tif( d<md ){\n            \n            md2 = md;\n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec2(i, j) + n; // Record the cell ID also.\n            \n            vAng = atan(o.y, o.x);\n        }\n        else if(d<md2) {\n            md2 = d; \n            \n            \n        }\n       \n    }\n\t}\n    \n\n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n\tfor( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o-mo, o-mo)>.00001 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot( 0.5*(o+mo), normalize(o-mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            //lMd = smin(lMd, lnDist, .1); \n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            lMd = sminExp(lMd, lnDist, 15.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n            \n        }\n\n    }\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    // thanks dad\n    return max(vec3(lMd, lMd2, md2 - md), 0.);\n}\n//////\n\n // Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n    // Applying a Voronoi pattern.\n    // Globals from the map function.\n    float svS = gS; // Texture sizing factor.\n    mat2 svR = gR; // Rotation matrix.\n\n    p.xy *= svR/svS;\n    n.xy *= svR;\n\n    float s = svS;\n    p.z -= s*.9;\n\n    float c = 0.;\n\n    vec3 v = Voronoi(p.xy*8.);\n\n    float vor = v.y;\n\n    // Ignore the borders.\n    float sq = sBoxS(p.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n    if(n.z<-.25 && sq<.0) {\n    \n        c = vor;\n    }\n\n    return c*svS;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, -0.9, -1); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.03*cos(iTime/2.)*0., .18, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1, .5, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 0.9; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera for extra motion sickness. :)\n\trd.xy *= rot2( sin(iTime/2.)/16. );\n\trd.xz *= rot2( sin(iTime)/32. );\n\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n  \n    // Global scaling and rotation matrix.\n    float svS = gS;\n    mat2 svR = gR;\n    \n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        vec3 sn0 = sn; // Normal with no bump.\n        \n        sn = doBumpMap(sp, sn, .5);///(1. + t/FAR*1.)\n        \n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n         \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 5.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring.   \n            \n        // Coordinatges.\n        vec3 txP = sp;\n        vec3 txN = sn;\n\n        // XY rotation and scaling.\n        txP.xy *= svR/svS;\n        txN.xy *= svR;\n\n        //txP.xy -= hash22(vec2(svS.w, svS.w*57.));\n        float s = pow(svS, 1.);\n        txP.z -= s;// - hash21(vec2(svS.w, svS.w*113.));//See distance function.\n\n\n\n        // Texture.\n        vec3 tx = tex3D(iChannel0, txP, txN);\n        texCol = .05 + tx*1.5;\n\n        // Alternative coloring.\n        //texCol = mix(texCol, vec3(dot(texCol, vec3(.299, .587, .114))), mod(svS.w, 2.)*.35);\n        // No texture.\n        //texCol = vec3(.6);\n\n\n\n        // Voronoi pattern.\n        vec3 v = Voronoi(txP.xy*vec2(8));\n\n        float vor = v.y;\n        float sq = sBoxS(txP.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n        if(sn0.z<-.5 && sq<.0) {\n\n            // Greyscale toning.\n            vec3 svCol = texCol;\n            float gr = dot(texCol, vec3(.299, .587, .114));\n            texCol = mix(texCol, vec3(gr), .15);\n\n            // Color application.\n            //vec3 iCol = (.5 + .45*cos(6.2831*svS.w/8. + vec3(0, 1, 2)*1.))*3.;\n            vec3 iCol = vec3(2);\n            vec3 iCol2 = (iCol + vec3(.1))*2.;\n            texCol = mix(texCol*iCol, texCol*.25, 1. - smoothstep(0., .1, vor - .2));\n            texCol = mix(texCol, svCol*iCol2, 1. - smoothstep(0., .04, abs(vor - .2 + .03) - .03));\n            texCol = mix(texCol, svCol*iCol2*0., 1. - smoothstep(0., .04, abs(vor) - .01));\n\n       }\n       else {\n\n           // Darker borders.\n           texCol *= .5;\n           // Lightening the edges.\n           if(sn0.z<-.25){\n               texCol = mix(texCol, texCol*3., 1. - smoothstep(0., .005, -(abs(sq - .04) - .03)));\n           }\n       }\n \n\n       \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .2 + vec3(.5, .7, 1)*spec*sh*1.);\n        \n        // Fake Fresnel reflections.\n        vec3 refl = reflect(rd, sn);\n        vec3 refTex = texture(iChannel1, refl).xyz; refTex *= refTex;\n        col = mix(col, (col + .25)*refTex*(sh + .2)*4., mix(.05, .35, fre));//*refTex*sh;\n    \n\n        // Shading.\n        col *= ao*atten;\n    \n        // dracusa edit: fig leaf in the middle\n        col = mix(col, vec3(.1,.03,.03), 1.-smoothstep(-.01, .03, length(sp)));\n       \n\t\n\t}\n    \n    // Background fog.\n    col = mix(col, vec3(.025, .015, .01), smoothstep(0., .99, t/FAR));\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n\t\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[4006, 4039, 4061, 4061, 4119], [4122, 4150, 4171, 4171, 4234], [4236, 4316, 4362, 4362, 4919], [4922, 4949, 5006, 5167, 5303], [5306, 5334, 5381, 5381, 5471], [5778, 5828, 5882, 5937, 7300], [7302, 7346, 7368, 7398, 7632], [7636, 7657, 7693, 7742, 8203], [9015, 9206, 9258, 9383, 10692], [10695, 10847, 10883, 10883, 11137], [11165, 11187, 11208, 11563, 12098], [12631, 12770, 12812, 12812, 12877], [13679, 13679, 13703, 13818, 19090], [19100, 19127, 19166, 19240, 19658], [19663, 19854, 19909, 20010, 21262], [21264, 21264, 21320, 21353, 27127]], "test": "untested"}
{"id": "sd3BWf", "name": "isosceles triangle wall", "author": "jorge2017a2", "description": "isosceles triangle wall", "tags": ["isoscelestrianglewall"], "likes": 6, "viewed": 206, "published": 3, "date": "1657312902", "time_retrieved": "2024-07-30T16:41:06.907446", "image_code": "//----------image\n//por jorge2017a2-\n//isosceles triangle wall-----08/jul/2022\n#define MAX_STEPS 100\n#define MAX_DIST 160.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{   p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nfloat puertaMed(vec2 p, vec2 med)\n{   float d1= sdBox( p,med );\n    float d2= sdTriangleIsosceles(vec2(p.x, -p.y)-vec2(0.0,-med.y*2.0), vec2(med.x,med.y+0.1) );\n    float df= Union(d1, d2);\n    return df;\n}\n\nvec3 puertaCh(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n     float d1a= puertaMed(p.xy, vec2(5.0,7.0));\n    float d2a=sdBox(p, vec3(7.0,15.0,1.0) );\n    float dfa= Intersect(d1a, d2a);   \n    float d1b= puertaMed(p.xy, vec2(4.0,6.0));\n    float d2b=sdBox(p, vec3(7.0,15.0,1.5) );\n    float dfb= Intersect(d1b, d2b);\n    float dfab= Difference(dfa, dfb);\n    res =opU2(res, vec2(dfab,100.0));\n    return vec3(res.x, res.y, d1a);\n}\n\nvec2 puertaChyGr(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);\n    vec3 p0=p;\n    p.z-=2.0;\n    vec3 pc1= puertaCh(p);\n    p=p0;\n    float d1a= puertaMed(p.xy, vec2(20.0,20.0));\n    p.z-=5.0;\n    float d2a=sdBox(p, vec3(22.0,40.0,2.0) );\n    float dfa= Intersect(d1a, d2a);\n    dfa= Difference(dfa, pc1.z);\n    res =opU2(res, vec2(pc1.x, pc1.y));\n    res =opU2(res, vec2(dfa, 101.0));\n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);\n     p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,103.0));\n    p.z= opRep1D(p.z, 40.0 );\n    vec2 pcg1= puertaChyGr(p);\n    p.z-=20.0;\n    vec2 pcg2= puertaChyGr(p);\n    res =opU2(res, pcg1 );\n    res =opU2(res, pcg2 );\n    \n    p.y-=30.0;\n    float d3a=sdBox(p, vec3(1.0,1.0,40.0) ); \n    p.y+=9.0;\n    p.x=abs(p.x)-19.0;\n    float d3b=sdBox(p, vec3(1.0,1.0,40.0) );\n    res =opU2(res, vec2(d3a,101.0) );\n    res =opU2(res, vec2(d3b,102.0) );\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 )\n    { col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.5,1.0,0.5)*2.0; }\n\tif (i==102 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,0.5,0.5)*3.0; }\n\tif (i==103 ) { return tex3D(iChannel0, p/128., nor)*vec3(0.5,0.5,0.125)*3.0;; }\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color>=100 ){ return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t0=iTime;\n    float t=mod(t0*5.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 65.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(15.0,25.0+abs(7.0*(sin(t0)+cos(t0*2.0))),-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, 0.79);\n   rd= rotate_y(rd, -0.79/2.0);\n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3BWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[505, 505, 537, 537, 621], [623, 623, 667, 667, 694], [695, 695, 735, 735, 762], [763, 763, 808, 808, 836], [838, 838, 874, 874, 919], [921, 921, 955, 955, 1051], [1052, 1052, 1086, 1086, 1177], [1178, 1178, 1212, 1212, 1303], [1305, 1305, 1342, 1342, 1416], [1418, 1418, 1469, 1469, 1756], [1758, 1758, 1793, 1793, 1964], [1966, 1966, 1989, 1989, 2395], [2397, 2397, 2423, 2423, 2795], [2797, 2797, 2822, 2822, 3375], [3377, 3377, 3401, 3401, 3563], [3565, 3565, 3613, 3613, 3892], [3894, 3894, 3938, 3938, 4259], [4261, 4261, 4298, 4298, 4555], [4557, 4557, 4580, 4580, 4735], [4737, 4737, 4827, 4827, 5785], [5787, 5787, 5836, 5836, 6158], [6160, 6160, 6230, 6230, 6317], [6319, 6319, 6346, 6346, 6435], [6437, 6437, 6495, 6495, 6543], [6545, 6545, 6568, 6568, 6680], [6682, 6682, 6713, 6713, 7274], [7276, 7276, 7333, 7333, 7865]], "test": "untested"}
{"id": "Ns3fDf", "name": "Add Motion Blur to any shader 1", "author": "GregRostami", "description": "Hold the mouse button to see the shader without motion blur.\nAdd motion blur to any shader by inserting 2 lines (see comments) at the top of any shader.\nI tried using procedural noise, instead of the textured blue noise, but I didn't like the results.\n", "tags": ["raymarching", "motionblur", "utility", "small"], "likes": 32, "viewed": 2625, "published": 3, "date": "1657307356", "time_retrieved": "2024-07-30T16:41:07.770139", "image_code": "// This is a fork of Fabrice's amazing tuto: motion blur (dithering):\n// https://www.shadertoy.com/view/wt3fDH\n\n// Dithered motion blur adds motion blur to your shader without slowing it down.\n// Hold the left mouse button to see the shader without motion blur.\n// Pause shader to see the dithered motion blur in the fast parts ... toggle with mouse.\n\n// To add motion blur to your shader:\n// 1. Add any of the #defines (see below) at the top of your shader.\n// 2. Replace all of the \"iTime\" in your shader with \"iTim\".\n// 3. Add the \"Blue Noise\" texture to iChannel3 (if available).\n\n\n// Use this #define if you want to toggle motion blur off with the mouse:\n#define iTim (iTime + (iMouse.z>0. ? 0. : texelFetch(iChannel3,ivec2(u)%1024,0).r * iTimeDelta))\n\n\n// Use this #define if you want motion blur to be always on:\n// #define iTim (iTime + texelFetch(iChannel3,ivec2(u)%1024,0).r * iTimeDelta)\n\n\n// Use this #define if you want to control the ammount of blur (Mouse Y) ... SUPER COOL!\n// #define iTim (iTime + texelFetch(iChannel3,ivec2(u)%1024,0).r * (.1*iMouse.y/iResolution.y))\n\n\n// Use this #define if you don't want to use \"Blue Noise\" texture (Fabrice's procedural noise):\n// The quality of procedural noise is not as good as \"Blue Noise\".\n// #define iTim (iTime + fract(1e4*sin(dot(gl_FragCoord.xy,vec2(137,-13))))* iTimeDelta)\n\n\nvoid mainImage(out vec4 o, vec2 u)\n{\n    float T;\n    T = iTim;   // In your shaders, this line would be \"T = iTime;\"\n    \n    o*=0.;\n    for(vec4 p = vec4(10.*cos(T), 0, 0, 30.+30.*sin(T)-40.*T), i = o-2.;\n        o.x > (p*.1*i+i).y; i+=.002)\n    o = i* texture(iChannel0, p.xw/2e2),\n    p.xy += u/iResolution.x*.1, p-=.05;\n    o++;\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3fDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1342, 1342, 1378, 1378, 1677]], "test": "untested"}
{"id": "fd3BWf", "name": "Urysohn 3D", "author": "N8Shader", "description": "It looks better in 3d. Everything does.\nHeightmap code adapted from: https://www.shadertoy.com/view/WdKGzt\n\nTopology is cool nerds.", "tags": ["uryshon"], "likes": 5, "viewed": 274, "published": 3, "date": "1657288556", "time_retrieved": "2024-07-30T16:41:08.759494", "image_code": "const float angle = 1.;\nconst mat2 m1 = mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n\nvec3 transform(vec3 p) {\n    mat2 m2 = mat2(cos(iTime),-sin(iTime),sin(iTime),cos(iTime));\n    p.yz *= m1;\n    p.xy *= m2;\n    return p;\n}\n\nconst float slopeUB= 2.;\nconst float g = sin(atan(1.,slopeUB));\n\nfloat sde(vec3 p) {\n    vec2 uv = p.xy * 0.1 + 0.5;\n        float h = 2.5 * texture(iChannel0, uv).r;\n    if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {\n        h = 0.0;\n    }\n    return (p.z-h)*g;\n    \n}\n\nvec3 rayMarch(vec3 ro, vec3 rd) {\n    vec3 p = ro + rd*0.001;\n    while(true) {\n        float d = 0.25 * sde(p);\n        if (d < 0.0001) {break;}\n        p += rd*d;\n        if (length(p-ro) > 200.) {break;}\n    }\n    return p;\n}\n\nconst vec2 helper = vec2(1e-5,0);\n\nfloat light(vec3 l, vec3 p) {\n    float d = sde(p);\n    vec3 norm = normalize(vec3(\n        10.0 * (texture(iChannel0, p.xy * 0.1 + 0.5 + vec2(1.0 / iResolution.x, 0.0)).r - texture(iChannel0, p.xy * 0.1 + 0.5 - vec2(1.0 / iResolution.x, 0.0)).r),\n        10.0 * (texture(iChannel0, p.xy * 0.1 + 0.5 + vec2(0.0, 1.0 / iResolution.y)).r - texture(iChannel0, p.xy * 0.1 + 0.5 - vec2(0.0, 1.0 / iResolution.y)).r) ,\n        1.0\n        ));\n    vec3 ld = normalize(l-p);\n    float s = max(0.,dot(ld, norm));\n    return s;\n}\n\nconst vec3 l = vec3(0,-10,5);\nconst vec3 ro = vec3(0,0,5);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 c = vec3(5.*uv,3);\n    vec3 ro_ = ro;\n    c = transform(c);\n    ro_ = transform(ro_);\n    \n    vec3 p = rayMarch(ro_, normalize(c - ro_));\n    vec2 uvp = p.xy * 0.1 + 0.5;\n    float contour =(uvp.x > 0.0 && uvp.x < 1.0 && uvp.y > 0.0 && uvp.y < 1.0) ? texture(iChannel0, uvp).b: 0.0;\n    contour = pow(contour, 5.0);\n    contour = smoothstep(0.0, 1.0, contour);\n    contour = smoothstep(0.0, 1.0, contour);\n    contour = smoothstep(0.0, 1.0, contour);\n    vec3 col = vec3(light(l, p));\n    col += vec3(0.0, 0.0, contour) * col;\n    \n    float d = length(p-ro_);\n    col -= vec3(smoothstep(0.,200.,d));\n    col = min(vec3(1),col);\n    \n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float csdf(vec2 p, vec2 c, float r) {\n    return max(length(p - c) - r, 0.0);\n}\n  float seed = 0.0;\n    highp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat rand()\n{\n    /*float result = fract(sin(seed + mod(time, 1000.0) + dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    //_Seed += 1.0;\n    seed += 1.0;\n    return result;*/\n    float result = random(vec2(100.0 * seed));\n    seed += 1.0;\n    return result;\n}\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n    float smin(float a, float b, float k) {\n      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n      return mix(b, a, h) - k * h * (1.0 - h);\n    }\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    //float dist1 = csdf(uv, vec2(0.25, 0.25), 0.1);\n    //float dist2 = csdf(uv, vec2(0.75, 0.75), 0.1);\n    float num = 1000.0;\n    float dom = 1000.0;\n    float speed = 0.1;\n    for(float i = 0.0; i < 10.0; i++) {\n                float dist = csdf(uv, vec2((0.5 + 0.5 * snoise(speed * vec2(10.0 * i, iTime))) * iResolution.x / iResolution.y, (0.5 + 0.5 * snoise(speed * vec2(iTime, i * 10.0)))), 0.0);\n        if (mod(i, 2.0) == 1.0) {\n            num = num < 1000.0 ? smin(num, dist, 0.1) : min(num, dist);\n        } else {\n           dom = dom < 1000.0 ? smin(dom, dist, 0.1) : min(dom, dist);\n        }\n    }\n    float final = num / (num + dom);\n    fragColor = vec4(vec3(final) + vec3(0.005 * cos(100.0 * final), 0.0, cos(100.0 * final)), 1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3BWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 117, 117, 231], [298, 298, 317, 317, 514], [516, 516, 549, 549, 744], [781, 781, 810, 810, 1300], [1361, 1361, 1418, 1418, 2152]], "test": "untested"}
{"id": "NscfDX", "name": "Sunset_first shader", "author": "TomoyaAT", "description": "The first shader about color made in the process of trying to learn the< book of shaders>,\n hello shader world!", "tags": ["2d", "helloworld"], "likes": 2, "viewed": 184, "published": 3, "date": "1657288514", "time_retrieved": "2024-07-30T16:41:09.664075", "image_code": "\n        float circle(vec2 uv, vec2 center, float radius)\n        {\n        float edge = 0.008;\n        float up = center.y + sqrt(pow(radius, 2.0) - pow(uv.x - center.x, 2.0));\n        float down = center.y - sqrt(pow(radius, 2.0) - pow(uv.x - center.x, 2.0));\n        return (1.0 - smoothstep(up-edge, up, uv.y)) *\n        smoothstep(down, down + edge, uv.y);\n        }\n   void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec2 st = fragCoord/iResolution.xy;\n        float m_time = 0.5 + 0.5*sin(iTime * 0.5); \n\n        float skyline = 0.276;  \n\n        // color\n        vec4 bg_col = vec4(1, 1, 1, 1);\n        vec4 color = bg_col;\n\n        // sun\n        vec2 s_center = vec2(0.5 + 0.15 * m_time,0.984-0.68*m_time);\n        float cir = circle(st, s_center, 0.080);\n        vec4 sun_col = mix(vec4(1.000,0.916,0.717,1.000),vec4(1.000,0.089,0.136,1.000), m_time);\n\n        // sky\n        float skyedge = 0.042;\n        float sky = smoothstep(skyline,skyline + skyedge,st.y);\n        vec4 skycolor_up = mix(vec4(0.376,0.891,0.985,1.000),vec4(0.293,0.393,0.710,1.000), m_time);\n        vec4 skycolor_down = mix(vec4(0.843,0.931,1.000,1.000),vec4(1.000,0.461,0.148,1.000), m_time);\n\t\t   vec4 sky_col=mix(skycolor_down, skycolor_up, (st.y-skyline) * 1.0/(1.0-skyline));\n        // sea\n        float sea = 1.0 - sky;\n        vec4 sea_col =mix( mix(vec4(0.096,0.405,0.985,1.000),vec4(0.092,0.277,0.750,1.000), m_time),\n        mix(vec4(0.216,0.985,0.966,1.000),vec4(0.517,0.830,0.045,1.000), m_time),(st.y-skyline) * 1.0/(skyline));\n\n        // reflection\n        vec4 ref_col;\n        vec4 ref_col1=mix(sun_col,sea_col,st.x);\n        vec4 ref_col2=mix(sun_col,sea_col,st.y);\n        ref_col=mix(ref_col1,ref_col2,m_time);\n        float ref_width = 0.356 - -0.054 * m_time;\n        float ref = sea * (smoothstep(\n        s_center.x+ 0.820 * st.y - ref_width,\n        s_center.x, st.x) -\n        smoothstep(s_center.x,\n        s_center.x-0.932*st.y + ref_width, st.x));\n\n        // color\n        color = (1.0 - sky)*color + sky *sky_col; \n        color = (1.0 - cir)*color +cir * sun_col; \n        color = (1.0 - sea)*color + sea * sea_col;\n    \tcolor = (1.0 - ref)*color + ref * ref_col; \n\n        fragColor = color;\n        }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[9, 9, 67, 67, 371], [375, 375, 432, 432, 2237]], "test": "untested"}
{"id": "ssdfD2", "name": "ffingerprint", "author": "jsfour", "description": "fingerprint", "tags": ["fingerprint"], "likes": 2, "viewed": 60, "published": 3, "date": "1657274314", "time_retrieved": "2024-07-30T16:41:10.576635", "image_code": "vec2 hash2( vec2 p )\n{\n\tp = vec2( dot(p,vec2(63.31,127.63)), dot(p,vec2(395.467,213.799)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43141.59265);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float invzoom = 100.;\n    vec2 uv = invzoom*((fragCoord-0.5*iResolution.xy)/iResolution.x);\n    float bounds = smoothstep(9.,10.,length(uv*vec2(0.7,0.5)));\n\n    //cumulate information\n    float a=0.;\n    vec2 h = vec2(floor(7.*iTime), 0.);\n    for(int i=0; i<50; i++){\n        float s=sign(h.x);\n        h = hash2(h)*vec2(15.,20.);\n    \ta += s*atan(uv.x-h.x, uv.y-h.y);\n    }\n    \n    //comment this out for static center\n    uv += 20.*abs(hash2(h));\n    \n    a+=atan(uv.y, uv.x); //spirallic center more likely\n\n    float w = 0.8; //row width\n    float p=(1.-bounds)*w; //pressure\n    float s = min(0.3,p); //smooth\n    float l = length(uv)+0.319*a; //base rings plus information\n    \n    //dist -> alternate pattern\n    float m = mod(l,2.);\n    float v = (1.-smoothstep(2.-s,2.,m))*smoothstep(p,p+s,m);\n    \n\tfragColor = vec4(v,v,v,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 140], [142, 142, 199, 199, 1044]], "test": "untested"}
{"id": "7sdBW2", "name": "Halo Effect", "author": "jerrywwl", "description": "Halo effect test", "tags": ["2d"], "likes": 7, "viewed": 303, "published": 3, "date": "1657267135", "time_retrieved": "2024-07-30T16:41:11.433345", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float timer=mod(iTime, 3.0);\n    float radius=2.0/timer;\n    float width=timer*2.0;\n    float ring=length(vec2(uv.x+0.2, uv.y))*radius*width-width;//(timer/4.0)-3.0;\n    ring=min(2.0, abs(1.0/(10.0*ring)));\n    ring=max(0.0, ring-timer);\n    \n    vec3 lightBlue = vec3(0.27,0.67,1.0);\n    vec3 rings=lightBlue * ring;\n\n\tfragColor = vec4(rings,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 472]], "test": "untested"}
{"id": "ssdBDj", "name": "Sine Circles MoirÃ©", "author": "EFHIII", "description": "An animation of sine circles growing & shrinking", "tags": ["moire"], "likes": 2, "viewed": 208, "published": 3, "date": "1657248161", "time_retrieved": "2024-07-30T16:41:12.298033", "image_code": "const float s = 0.01;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Normalized pixel coordinates with the origin in the center\n    vec2 uv = fragCoord - iResolution.xy / 2.;\n    \n    float v = 1004. - 1000. * cos(iTime / 10.);\n\n    float d = sqrt(uv.x * uv.x + uv.y * uv.y) * v * s;\n\n    // pixel color\n    vec3 col = vec3(0.5 + 0.5 * cos(d));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdBDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 146, 422]], "test": "untested"}
{"id": "fddBD2", "name": "Generalized Ellipsoid", "author": "iq", "description": "A single ray-surface intersector that can handle spheres, ellipsoids, cones and hyperboloids optimally, and some other shapes less optimally. It does not paraboloids in any way, which you can find here: [url]https://www.shadertoy.com/view/sdyfDR[/url]", "tags": ["3d", "quadric", "cone", "ellipsoid", "generalized", "hyperboloid"], "likes": 68, "viewed": 2048, "published": 3, "date": "1657232170", "time_retrieved": "2024-07-30T16:41:13.181670", "image_code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Ray intersection for quadrics of this particular shape:\n//\n//  f(x,y,z) = Â± aÂ²xÂ² Â± bÂ²yÂ² Â± cÂ²zÂ² - {-1,0,1} = 0\n//\n// Note this is NOT a general quadric, it does not handle\n// paraboloids. It does however handle hyperboloids, cones and\n// ellipsods optimally (as opposed to a general quadric solver),\n// and also spheres, cylinders, slabs and so on, in a non-optimal\n// way as a bonus (you should use specialized code paths for\n// those shapes, do NOT use this). See this shader for paraboloids:\n//\n// https://www.shadertoy.com/view/sdyfDR\n//\n// a,b,c,d are the parameters of the shape. a,b,c are inverse\n// radii and d is either -1, 0 or 1. See lines 91 to 100.\n//\n// Sphere                  : a>0, b=a, c=a, d= 1\n// Ellipsoid               : a>0, b>0, c>0, d= 1\n// Cone                    : a>0, b<0, c>0, d= 0\n// Hyperboloid of 1 sheets : a>0, b<0, c>0, d= 1\n// Hyperboloid of 2 sheets : a>0, b<0, c>0, d=-1\n// Cylinder                : a>0, b=0, c>0, d= 1\n// Slab                    : a>0, b=0, c=0, d= 1\n// Hyperbolic Cylinder     : a>0, b=0, c<0, d=-1\n//\n// Note I'm showing symmetric cones and hyperboloids, but\n// you can just specify different radii for each axis.\n//\n//\n// List of ray-surface intersectors at \n//     https://www.shadertoy.com/playlist/l3dXRf\n// and\n//     https://iquilezles.org/articles/intersectors\n\nbool clipped( in vec3 pos, float clipY, float clipZ );\n\nfloat iQuadricTypeA(         // intersection distance. -1 if no intersection\n    in vec3  ro, in vec3 rd, // ray origin and direction\n    in vec4  abcd,           // the quadric (see above)\n    in float clipY,          // height of clipping volume\n    in float clipZ,          // depth  of clipping volume\n    out vec3 oNor,           // normal at intersection\n    out bool oInside )       // inside/outside identifier\n{\n    vec3 r2 = abcd.xyz*abs(abcd.xyz); // squared WITH sign\n    \n    float k2 = dot(rd,rd*r2);\n    float k1 = dot(rd,ro*r2);\n    float k0 = dot(ro,ro*r2) - abcd.w;\n             \n    float h = k1*k1 - k2*k0;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h) * sign(k2);\n\n    // entry point\n    float t = (-k1-h)/k2;\n    vec3 pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipZ) ) \n    {\n        oInside = k2<0.0;\n        oNor = normalize(pos*r2);\n        return t;\n    }\n\n    // exit point\n    t = (-k1+h)/k2;\n    pos = ro + t*rd;\n    if( t>0.0 && clipped(pos,clipY,clipZ) )\n    {\n        oInside = k2>0.0;\n        oNor = normalize(pos*r2);\n        return t;\n    }\n\n    return -1.0;\n}\n\nbool clipped( in vec3 pos, float y, float z )\n{\n    return abs(pos.y)<y && abs(pos.z)<z;\n}\n\n//--------------------------------------------------------\n\n// shapes\nconst vec4 kShape[10] = vec4[10]( \n  vec4(1.0/1.6, 1.0/1.6,1.0/1.6, 1.0),  // sphere\n  vec4(1.0/1.7, 1.0/3.0,1.0/0.9, 1.0),  // ellipsoid\n  vec4(1.0/1.0, 0.0,    0.0,     1.0),  // slab\n  vec4(1.0/0.8, 0.0,   -1.0/0.8, 0.0),  // cross\n  vec4(1.0/0.8, 0.0,   -1.0/0.8,-1.0),  // hyperbolic cylinder\n  vec4(1.0/1.6, 0.0,    1.0/1.6, 1.0),  // cylinder\n  vec4(1.0/1.6, 0.0,    1.0/0.9, 1.0),  // cylinder\n  vec4(1.0/0.6,-1.0/1.2,1.0/0.6, 0.0),  // cone\n  vec4(1.0/0.3,-1.0/0.7,1.0/0.3, 1.0),  // hyperboloid of one sheet\n  vec4(1.0/0.3,-1.0/0.6,1.0/0.3,-1.0)); // hyperboloid of two sheets\n    \n\n// https://iquilezles.org/articles/filterableprocedurals/\nfloat gridTextureGradBox( in vec2 p, in vec2 ddx, in vec2 ddy )\n{\n\t// filter kernel\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    const float N = 18.0; // grid thickness\n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvec2 getUV( in vec3 pos, ivec2 id )\n{\n    if( id.y==0 && id.x>=2 ) return 11.0*pos.zy;\n    \n    return vec2(12.0,11.0)*vec2(atan(pos.x,pos.z),pos.y);\n}\n\nvec3 getRay( in vec2 p, in vec3 uu, in vec3 vv, in vec3 ww )\n{\n    return normalize( p.x*uu + p.y*vv + 3.0*ww );\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // clip height\n    float clipY = 1.0 + 2.0*smoothstep(-1.0,-0.8,-cos(iTime*6.283185/12.0));\n\n    // camera movement\t\n    float an1 = 0.4 + 0.9*smoothstep(0.7,0.9,-cos(iTime*6.283185/12.0));\n\tfloat an2 = 6.283185*iTime/6.0;\n\tvec3 ro = 12.0*vec3( cos(an1)*sin(an2), sin(an1), cos(an1)*cos(an2) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    // global normalize coordinates\n    vec2 gp = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    // viewport\n    ivec2 id  = ivec2(vec2(5.0,2.0)*fragCoord/iResolution.xy );\n    vec2  res = iResolution.xy/vec2(5.0,2.0);\n    vec2  q   = mod(fragCoord,res);\n        \n    float clipZ = (id.x>=2 && id.y==0) ? 1.4 : 2.0;\n    \n    // render\n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(q+o)-res)/res.y;\n        #else    \n        vec2 p = (2.0*q-res)/res.y;\n        #endif\n\n\t    // create view ray\n\t    vec3 rd = getRay( p, uu, vv, ww );\n\n        // background\n\t    vec3 col = vec3(0.08) * (1.0-0.3*length(gp));\n        //col += 0.1*cos( float(5*id.y+id.x)+vec3(0,2,4));\n \n        // raytrace\n        bool isInside = false;\n        vec3 nor = vec3(0.0);\n        float t = iQuadricTypeA( ro, rd, kShape[5*id.y+id.x], clipY, clipZ, nor, isInside );\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n\n\n            // material\n\n            vec2 uv = getUV( pos, id );\n\n            // checkerboard pattern\n            {\n                col = vec3(0.6);\n                col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n                if( isInside ) col = vec3(1.5,0.6,0.0);\n            }\n            // grid lines\n            {\n                #if 0\n                // no filtering\n                col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n                #endif\n                #if 0\n                // hardware filtering\n                uv = 0.5 + uv/6.283185;\n                col *= gridTextureGradBox( uv, dFdx(uv), dFdy(uv) );\n                #endif\n                #if 1\n                // software filtering\n                // https://iquilezles.org/articles/filteringrm\n                vec2 px = vec2(p.x+2.0/res.y,p.y);\n                vec2 py = vec2(p.x,p.y+2.0/res.y);\n                vec3 rdx = getRay( px, uu, vv, ww );\n                vec3 rdy = getRay( py, uu, vv, ww );\n                vec3 posx = ro + t*rdx*dot(rd,nor)/dot(rdx,nor);\n                vec3 posy = ro + t*rdy*dot(rd,nor)/dot(rdy,nor);\n                vec2 uvx = getUV(posx, id);\n                vec2 uvy = getUV(posy, id);\n                uv  = 0.5 + uv /6.283185;\n                uvx = 0.5 + uvx/6.283185;\n                uvy = 0.5 + uvy/6.283185;\n                col *= gridTextureGradBox( uv, uvx-uv, uvy-uv );\n                #endif\n            }\n\n            // lighting\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            col *= vec3(0.2,0.3,0.4)*amb*2.0 + 0.7*vec3(1.0,0.9,0.7)*dif;\n            col += 0.3*pow(clamp(dot(hal,nor),0.0,1.0),32.0)*dif;\n       }\n \t\n        // gamma\n        col = sqrt( col );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n     \n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n    \n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddBD2.jpg", "access": "api", "license": "mit", "functions": [[2473, 2473, 2893, 2893, 3577], [3579, 3579, 3626, 3626, 3669], [4334, 4392, 4457, 4475, 4820], [4822, 4822, 4859, 4859, 4973], [4975, 4975, 5037, 5037, 5089]], "test": "untested"}
{"id": "fdtfW2", "name": "005 - Square study", "author": "PiGIon", "description": "For some reason it was harder for me to understand the concept of creating a square than to create a circle. At least I found how to create a moon!\n\nBut, in a nutshell, seems like you only need to check if the .xy coords are in a range.", "tags": ["beginner", "square", "learning"], "likes": 1, "viewed": 190, "published": 3, "date": "1657229597", "time_retrieved": "2024-07-30T16:41:14.153073", "image_code": "// 2022.07.07 rev 1\n// 2022.07.13 rev 2 - fix a bug where the square calculations was wrong\n\n#define TIME_SKEW 1.0\n\n// returns a constant cycle instead of comming and going from cycle function\n// ______________________________________________\n// | iTime | perSecond | range     |   return   |\n// |_______|___________|___________|____________|\n// |0.1    |0.5        |10         |2.5         |\n// |3.4    |0.5        |10         |17          |\n// |_______|___________|___________|____________|\n//\n// doing a sin() with the return allows you to \"skew through the range\" seamlessly \nfloat constCycle(float perSecond, float range) {\n    return ((iTime + TIME_SKEW + iTimeDelta) * perSecond) * range;\n}\n\n// returns a back and forth 0.0 to 1.0 per second\nfloat cycle(float perSecond) {\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float antiAlias = 1.5/iResolution.y; // the larger the screen, the subtle is the antialias\n    \n    // this was a try to rotate the viewport with a \"rotation matrix\" which failed beautifully\n    uv *= vec2(sin(uv.x * constCycle(1., 1.)), cos(uv.y * constCycle(1., 1.)));\n    \n    vec3 c;\n    float s;\n    \n    // mistake moon :)!\n    //if (length(uv - vec2(0.05, 0.)) > sqrt(0.1 * 0.1) && length(uv) < sqrt(0.1 * 0.1 + 0.1 * 0.1)) {\n    //    s = 1.;\n    //}\n\n    // almost a square, almost! look closely\n    //s = smoothstep(0.5 - antiAlias, 0.5 + antiAlias, length(vec2(max(abs(uv.x), 0.35), max(abs(uv.y), 0.35))));\n\n    // success square! \\o/\n    //if (uv.x > -0.25 && uv.y > -0.25 && uv.x < 0.25 && uv.y < 0.25) {\n    //    s = 1.;\n    //}\n    \n    // another way to create a square\n    //vec2 q = vec4(0.25, 0.25);\n    //s = step(uv.x - q.x, 0.) * step(uv.y - q.y, 0.) * step(0., uv.x + q.x) * step(0., uv.y + q.y);\n    \n    // yet another way to do it\n    //s = step(abs(uv.x), 0.25) * step(abs(uv.y), 0.25);\n    \n    // square with antialias\n    // this version tests if the coords are within .25 range - the antiAlias variable.\n    // THIS VERSION HAS A BUG - returns 0.5 when it shouldn't in the X and Y axis\n    //s = length(smoothstep(vec2(0.25-antiAlias), vec2(0.25+antiAlias), abs(uv)));\n    \n    // mistake X pattern\n    // generates a cool effect when uv is changed\n    //s = smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(abs(uv.y) - abs(uv.x)));\n    \n    // mistake prism\n    // at least now I got to know how to make a prism!\n    //s = smoothstep(0.25-antiAlias, 0.25+antiAlias, (abs(uv.x) + abs(uv.y)) *.5);\n    \n    // square with smoothstep, kinda ugly, but works\n    s = 1.-(1.-smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(uv.x))) * (1.-smoothstep(0.25-antiAlias, 0.25+antiAlias, abs(uv.y)));\n    \n    c = mix(\n        vec3(0., 0., .8),\n        vec3(cycle(0.3) * cycle(0.2)),\n        s\n    );\n\n    fragColor = vec4(\n        c, \n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[116, 580, 628, 628, 697], [699, 749, 779, 779, 1124], [1126, 1126, 1183, 1183, 3224]], "test": "untested"}
{"id": "NdtfWj", "name": "Disco Balls", "author": "itgaz", "description": "It sparkles, it melts GPUs, I learnt something new :)", "tags": ["raymarchspheremusic"], "likes": 6, "viewed": 455, "published": 3, "date": "1657222343", "time_retrieved": "2024-07-30T16:41:16.040028", "image_code": "const float maxt = 1000.0;\nconst float mint = 0.01;\nconst int maxs = 250;\nconst vec3 grad = vec3(0.001,0,0);\nconst float PI=3.14159265;\nconst float PI_2=2.0*PI;\n\n//////////////////////\nmat3 rotX(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c));}\nmat3 rotY(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c));}\nmat3 rotZ(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1));}\nmat3 identity() {return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));}\n//////////////////////\n\nvec4 sun(vec3 p, vec4 o, vec3 c) {\n  float d = length(p-o.xyz)-o.w;\n  \n  float fft = texture(iChannel0, vec2(0.1, 1.0)).r;\n  \n  float t = iTime + (fft/2.0);\n  \n  float i = (2.0 * sin(p.x + t) * sin(p.y) * sin(p.z)) *\n            (2.0 * sin(2.0*p.x+(t*4.0)) * sin(2.0*p.y+(t*PI)) * sin(2.0*p.z-(t*3.192))) *\n            (4.0 * sin(4.0*p.x+(t*2.0)) * sin(4.0*p.y-(t*PI_2)) * sin(4.0*p.z+(t/1.3021))) *\n            (5.0 * sin(5.0*p.x-(t*0.753)) * sin(5.0*p.y+(t/2.67)) * sin(5.0*p.z-(t*13.0)));\n  c *= (i);\n  \n  d -= clamp(i, 0.0, 1.0);\n  \n  return vec4(c,d);\n}\nvec4 sphere(vec3 p, vec4 o, vec3 c) {\n  float d = length(p-o.xyz)-o.w;\n  return vec4(c,d);\n}\nvec4 minsdf(vec4 a, vec4 b) {\n  if(a.w<b.w)return a;\n  else return b;\n}\nvec4 sdf(vec3 p) {\n  vec4 t = vec4(0.0);\n  t.w=maxt;\n  \n  vec3 ballColour = vec3(1.0, 0.4, 0.0);\n  // ballColour = mod(ballColour, p);\n  t=minsdf(t, sun(p, vec4(0.0, 0.0, 0.0, 10.0), ballColour));\n  \n  t=minsdf(t, sun(p, vec4(8.0, 8.0, 0.0, 4.0), vec3(0.4, 0.4, 0.0)));\n  t=minsdf(t, sun(p, vec4(-8.0, 8.0, 0.0, 4.0), vec3(0.4, 0.4, 0.0)));\n  t=minsdf(t, sun(p, vec4(8.0, -8.0, 0.0, 4.0), vec3(0.4, 0.4, 0.0)));\n  t=minsdf(t, sun(p, vec4(-8.0, -8.0, 0.0, 4.0), vec3(0.4, 0.4, 0.0)));\n  //t=minsdf(t, sphere(p, vec4(4.0, 4.5, -8.0, 2.0), vec3(1.0, 1.0, 1.0)));\n  //t=minsdf(t, sphere(p, vec4(-4.0, 4.5, -8.0, 2.0), vec3(1.0, 1.0, 1.0)));\n  return t;\n}\n\nvec4 march(vec3 ro, vec3 rd, out vec3 n, out vec3 p) {\n  float t = 0.0;\n  for(int s=0;s<maxs;++s) {\n    p = ro + (t*rd);\n    \n    p = mod(p / 8.0, vec3(50.0)) - 0.5 * 50.0;\n    \n    vec4 newt=sdf(p);\n    \n    if(newt.w < mint) {\n      n = normalize(vec3(\n        sdf(p+grad.xyy).w - sdf(p-grad.xyy).w,\n        sdf(p+grad.yxy).w - sdf(p-grad.yxy).w,\n        sdf(p+grad.yyx).w - sdf(p-grad.yyx).w\n      ));\n      return newt;\n    }\n    \n    if(newt.w > maxt)\n    {\n      break;\n    }\n    \n    t+=newt.w;\n  }\n  \n  return vec4(0.0);\n}\n\nvec4 shade(vec3 p, vec3 n, vec3 c) {\n  float kA = 0.4;\n  vec3 cA = vec3(1.0, 1.0, 1.0);\n  \n  vec3 cD = vec3(1.0, 1.0, 1.0);\n  vec3 pD = vec3(0.0, 0.0, 0.0);\n  \n  vec3 p2D = normalize(pD - p);\n  float kD = max(0.0, dot(n, p2D));\n  \n  return vec4(((kA*cA) + (kD*cD)) * c, 1.0);\n}\nvec4 shadeBG() {\nreturn vec4(0.0);\n// return vec4(0.4*sin(0.2*iTime), 0.2*cos(iTime*0.4), 0.2, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;    \n    \n    /*\n    vec3 ro = vec3(\n      - sin(iTime) - cos(iTime) * 8.0,\n      - cos(iTime) + sin(iTime) * 2.0,\n      iTime * 2.0);\n      */\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    mat3 r = identity();\n    r *= rotZ(((iTime)*0.2));\n    r *= rotY(sin(- iTime / 2.0) * 0.25);\n    ro *= r;\n    rd *= r;\n    \n    vec3 n = vec3(0);\n    vec3 p = vec3(0);\n    vec4 c = march(ro, rd, n, p);\n    \n    if(c.w==0.0) fragColor=shadeBG();\n    else fragColor = shade(p, n, c.xyz);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 185, 205, 205, 320], [321, 321, 341, 341, 456], [457, 457, 477, 477, 592], [593, 593, 610, 610, 668], [693, 693, 727, 727, 1251], [1252, 1252, 1289, 1289, 1344], [1345, 1345, 1374, 1374, 1416], [1417, 1417, 1435, 1435, 2067], [2069, 2069, 2123, 2123, 2599], [2601, 2601, 2637, 2637, 2878], [2879, 2879, 2895, 2895, 2981], [2983, 2983, 3040, 3040, 3617]], "test": "untested"}
{"id": "fstfWj", "name": "Finite Element Method", "author": "wyatt", "description": "Magnetic field inside gapped transformer. (speed up to see final result)", "tags": ["fem"], "likes": 30, "viewed": 521, "published": 3, "date": "1657218846", "time_retrieved": "2024-07-30T16:41:20.893053", "image_code": "\nMain {\n    vec4 n = A(U+vec2(0,1))*B(U+vec2(0,1)).w;\n    vec4 e = A(U+vec2(1,0))*B(U+vec2(1,0)).w;\n    vec4 s = A(U-vec2(0,1))*B(U-vec2(0,1)).w;\n    vec4 w = A(U-vec2(1,0))*B(U-vec2(1,0)).w;\n    Q = (A(U)+(n+e+s+w))/5.;\n    float b = length(Q.xy);\n    Q = sin(3.6+0.2*b+vec4(1,2,3,4));\n    //Q = A(U).xyxy;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n\nfloat sdLine (vec2 p, vec2 a, vec2 b) {\n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}\n", "buffer_a_code": "\nMain {\n    Q = A(U);\n    float G = .2;\n    vec4 dn=vec4(0),de=vec4(0),ds=vec4(0),dw=vec4(0);\n    vec4 dQ = vec4(0);\n    { // north, so s = Q\n        vec2 u = vec2(0,1);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = Q;//A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // curl H = J\n    // div uH = 0\n        \n        dn.x += -((e-w).y-(n).x-B(U+u).x)-Q.x;\n        dn.y += +((e*eb-w*wb).x+(n*nb).y)/sb-Q.y;\n        dn.y = dn.y/(1.+G*(abs(nb-sb)+abs(eb-sb)+abs(wb-sb)));;\n    }\n    { // south, so n = Q\n        vec2 u = vec2(0,-1);\n        vec4 n = Q;//A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n        \n    // div B = 0\n    // curl B = J\n        ds.x = +((e-w).y-(-s).x-B(U+u).x)-Q.x ;\n        ds.y = -((e*eb-w*wb).x+(-s*sb).y)/nb-Q.y;\n        ds.y = ds.y/(1.+G*(abs(eb-nb)+abs(sb-nb)+abs(wb-nb)));\n    }\n    { // east, so w = Q\n        vec2 u = vec2(1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = Q;//A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        de.y = ((e).y-(n-s).x-B(U+u).x)-Q.y ;\n        de.x = ((e*eb).x+(n*nb-s*sb).y)/wb-Q.x;\n        de.x = de.x/(1.+G*(abs(nb-wb)+abs(sb-wb)+abs(eb-wb)));\n    }\n    { // west, so e = Q\n        vec2 u = vec2(-1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = Q;//A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        dw.y += -((-w).y-(n-s).x-B(U+u).x)-Q.y ;\n        dw.x += -((-w*wb).x+(n*nb-s*sb).y)/eb-Q.x;\n        dw.x = dw.x/(1.+G*(abs(nb-eb)+abs(sb-eb)+abs(wb-eb)));\n    }\n    \n     Q += 0.25*(dn+de+ds+dw);\n    \n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    Q = vec4(0);\n    if (sdLine(U,vec2(.4,.3)*R,vec2(.4,.7)*R)<2.)\n        Q.x += 1.;\n    if (sdLine(U,vec2(.6,.3)*R,vec2(.6,.7)*R)<2.)\n        Q.x -= 1.;\n   Q.w = 1.;\n   if (sdLine(U,vec2(.3,.2)*R,vec2(.3,.8)*R)<.05*R.y||\n        sdLine(U,vec2(.3,.8)*R,vec2(.7,.8)*R)<.05*R.y||\n        sdLine(U,vec2(.7,.8)*R,vec2(.7,.2)*R)<.05*R.y||\n        sdLine(U,vec2(.3,.2)*R,vec2(.7,.2)*R)<.05*R.y||\n        sdLine(U,vec2(.5,.25)*R,vec2(.5,.75)*R)<.1*R.y)\n        Q.w = 3300.;\n    \n    if (sdLine(U,vec2(.4,.5)*R,vec2(.6,.5)*R)<.03*R.y)\n       Q.w = 1.;\n       \n        \n}", "buffer_b_inputs": [], "buffer_c_code": "\nMain {\n    Q = A(U);\n    float G = .2;\n    vec4 dn=vec4(0),de=vec4(0),ds=vec4(0),dw=vec4(0);\n    vec4 dQ = vec4(0);\n    { // north, so s = Q\n        vec2 u = vec2(0,1);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = Q;//A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // curl H = J\n    // div uH = 0\n        \n        dn.x += -((e-w).y-(n).x-B(U+u).x)-Q.x;\n        dn.y += +((e*eb-w*wb).x+(n*nb).y)/sb-Q.y;\n        dn.y = dn.y/(1.+G*(abs(nb-sb)+abs(eb-sb)+abs(wb-sb)));;\n    }\n    { // south, so n = Q\n        vec2 u = vec2(0,-1);\n        vec4 n = Q;//A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n        \n    // div B = 0\n    // curl B = J\n        ds.x = +((e-w).y-(-s).x-B(U+u).x)-Q.x ;\n        ds.y = -((e*eb-w*wb).x+(-s*sb).y)/nb-Q.y;\n        ds.y = ds.y/(1.+G*(abs(eb-nb)+abs(sb-nb)+abs(wb-nb)));\n    }\n    { // east, so w = Q\n        vec2 u = vec2(1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = Q;//A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        de.y = ((e).y-(n-s).x-B(U+u).x)-Q.y ;\n        de.x = ((e*eb).x+(n*nb-s*sb).y)/wb-Q.x;\n        de.x = de.x/(1.+G*(abs(nb-wb)+abs(sb-wb)+abs(eb-wb)));\n    }\n    { // west, so e = Q\n        vec2 u = vec2(-1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = Q;//A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        dw.y += -((-w).y-(n-s).x-B(U+u).x)-Q.y ;\n        dw.x += -((-w*wb).x+(n*nb-s*sb).y)/eb-Q.x;\n        dw.x = dw.x/(1.+G*(abs(nb-eb)+abs(sb-eb)+abs(wb-eb)));\n    }\n    \n     Q += 0.25*(dn+de+ds+dw);\n    \n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nMain {\n    Q = A(U);\n    float G = .2;\n    vec4 dn=vec4(0),de=vec4(0),ds=vec4(0),dw=vec4(0);\n    vec4 dQ = vec4(0);\n    { // north, so s = Q\n        vec2 u = vec2(0,1);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = Q;//A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // curl H = J\n    // div uH = 0\n        \n        dn.x += -((e-w).y-(n).x-B(U+u).x)-Q.x;\n        dn.y += +((e*eb-w*wb).x+(n*nb).y)/sb-Q.y;\n        dn.y = dn.y/(1.+G*(abs(nb-sb)+abs(eb-sb)+abs(wb-sb)));;\n    }\n    { // south, so n = Q\n        vec2 u = vec2(0,-1);\n        vec4 n = Q;//A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n        \n    // div B = 0\n    // curl B = J\n        ds.x = +((e-w).y-(-s).x-B(U+u).x)-Q.x ;\n        ds.y = -((e*eb-w*wb).x+(-s*sb).y)/nb-Q.y;\n        ds.y = ds.y/(1.+G*(abs(eb-nb)+abs(sb-nb)+abs(wb-nb)));\n    }\n    { // east, so w = Q\n        vec2 u = vec2(1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = Q;//A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        de.y = ((e).y-(n-s).x-B(U+u).x)-Q.y ;\n        de.x = ((e*eb).x+(n*nb-s*sb).y)/wb-Q.x;\n        de.x = de.x/(1.+G*(abs(nb-wb)+abs(sb-wb)+abs(eb-wb)));\n    }\n    { // west, so e = Q\n        vec2 u = vec2(-1,0);\n        vec4 n = A(U+u+vec2(0,1));\n        vec4 e = Q;//A(U+u+vec2(1,0));\n        vec4 s = A(U+u-vec2(0,1));\n        vec4 w = A(U+u-vec2(1,0));\n        float nb = B(U+u+vec2(0,1)).w;\n        float eb = B(U+u+vec2(1,0)).w;\n        float sb = B(U+u-vec2(0,1)).w;\n        float wb = B(U+u-vec2(1,0)).w;\n    // div B = 0\n    // curl B = J\n        dw.y += -((-w).y-(n-s).x-B(U+u).x)-Q.y ;\n        dw.x += -((-w*wb).x+(n*nb-s*sb).y)/eb-Q.x;\n        dw.x = dw.x/(1.+G*(abs(nb-eb)+abs(sb-eb)+abs(wb-eb)));\n    }\n    \n     Q += 0.25*(dn+de+ds+dw);\n    \n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7dcBW2", "name": "basic scene-001", "author": "jorge2017a2", "description": "basic scene-001", "tags": ["basicscene001"], "likes": 4, "viewed": 261, "published": 3, "date": "1657202196", "time_retrieved": "2024-07-30T16:41:21.859468", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdSphere( vec3 p, float s )\n\t{ return length(p)-s;}\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat tau = atan(1.0) * 8.0;\nvec3 opAngRep( vec3 p, float a )\n{ vec2 polar = vec2(atan(p.y, p.x), length(p.xy));\n    polar.x = mod(polar.x + a / 2.0, a) - a / 2.0;    \n    return vec3(polar.y * vec2(cos(polar.x),sin(polar.x)), p.z);\n}\n\nvec3 opAngRepFull( vec3 p, float numItem )\n{   vec3 rep2 = opAngRep(p, tau / numItem); return rep2;}\n\nvec2 paredes(vec3 p)\n{\t\n    vec3 p0=p;\n    vec2 res= vec2(9999.0, -1.0); \n    p.y-=2.0;\n    float r1=3.5;\n    p.z= opRep1D(p.z,14.0 );\n    float d1a= sdBox( p, vec3(22.0,14.0,1.0) );\n    float d1b=sdCylinderXY(p, vec2(10.0,r1) );\n    p.x=abs(p.x)-24.0;\n    float d1c=sdCylinderXY(p, vec2(10.0,r1) );\n    \n    float ddif= Difference(d1a,d1b);\n    ddif= Difference(ddif,d1c);\n    res =opU2(res, vec2(ddif,100.0));\n    \n    p=p0;p.y-=2.0;\n    p.z=opRep1D(p.z,14.0 );\n    vec3 prep= opAngRepFull( p, 12.);\n    float d2=sdSphere(prep-vec3(12.0,0.0,-1.5), 1.5 );\n    res =opU2(res, vec2(d2,100.0));\n    return res; \n}   \n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); \n    p.y=p.y+10.0;\n    vec3 p0=p;\n\tfloat planeDist1 = p.y+10.0;  //piso inf\n    \n    {   p.x-=35.0;\n        p.x=abs(p.x)-35.0;\n        p.y=abs(p.y)-12.0;\n        vec2 pr1= paredes(p);\n        res =opU2(res, pr1);\n    }\n    \n    if(2.0*sin(iTime)>0.0)\n    {    \n        p=vec3(p0.x, p0.z, -p0.y);\n        p.y=opRep1D(p.y,30.0 );\n        vec2 pr2= paredes(p);\n        res =opU2(res, vec2(pr2.x, 101.));\n    }\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(0.6,0.9,0.8)*3.0; }\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj;     \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,8.0,-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   //rd= rotate_z(rd, 1.57);\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 498, 498, 519], [520, 520, 552, 552, 636], [637, 637, 676, 676, 771], [774, 774, 818, 818, 845], [846, 846, 886, 886, 913], [914, 914, 959, 959, 987], [989, 989, 1025, 1025, 1070], [1073, 1073, 1107, 1107, 1203], [1204, 1204, 1238, 1238, 1329], [1330, 1330, 1364, 1364, 1455], [1486, 1486, 1520, 1520, 1691], [1693, 1693, 1737, 1737, 1793], [1795, 1795, 1817, 1817, 2406], [2411, 2411, 2436, 2436, 2891], [2893, 2893, 2917, 2917, 3079], [3081, 3081, 3129, 3129, 3408], [3410, 3410, 3454, 3454, 3775], [3777, 3777, 3814, 3814, 4071], [4073, 4073, 4163, 4163, 5123], [5125, 5125, 5174, 5174, 5333], [5337, 5337, 5369, 5369, 5659], [5661, 5661, 5731, 5731, 5826], [5828, 5828, 5855, 5855, 5944], [5946, 5946, 6004, 6004, 6052], [6054, 6054, 6077, 6077, 6189], [6191, 6191, 6222, 6222, 6860], [6862, 6862, 6919, 6919, 7338]], "test": "untested"}
{"id": "NscfW2", "name": "ExportMusicTexture", "author": "cucucuggg", "description": "try to export music texture", "tags": ["music"], "likes": 0, "viewed": 185, "published": 3, "date": "1657178258", "time_retrieved": "2024-07-30T16:41:23.055271", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{ \n    vec2 uv = fragCoord.xy / iResolution.xy; \n    \n    float k0 = texture(iChannel0,vec2(uv.x,0.25)).r; \n\n    vec3 c1 = vec3(0.3,0.25,0.8) * k0;\n    \n    fragColor = vec4(k0,0.0,0.0,1.0);\n    \n}\n", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscfW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 250]], "test": "untested"}
{"id": "sddBDS", "name": "City Builder Cellular Automata", "author": "N8Shader", "description": "Cellular automata build city.", "tags": ["cell"], "likes": 3, "viewed": 242, "published": 3, "date": "1657152612", "time_retrieved": "2024-07-30T16:41:24.011714", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    //vec3 objectNormal = normalize(vec3(\n        //1.0,//length(texture(iChannel0, uv + vec2(texelSize.x, 0.0)).rgb) - length(texture(iChannel0, uv - vec2(texelSize.x, 0.0)).rgb),\n       // 1.0,\n       // 1.0,//length(texture(iChannel0, uv + vec2(0.0, texelSize.y)).rgb) - length(texture(iChannel0, uv - vec2(0.0, texelSize.y)).rgb),\n   // ));\n    vec3 objectNormal = normalize(vec3(\n        4.0 * (length(texture(iChannel0, uv + vec2(texelSize.x, 0.0)).rgb) - length(texture(iChannel0, uv - vec2(texelSize.x, 0.0)).rgb)),\n        1.0,\n        4.0 * (length(texture(iChannel0, uv + vec2(0.0, texelSize.y)).rgb) - length(texture(iChannel0, uv - vec2(0.0, texelSize.y)).rgb))\n    ));\n    fragColor = vec4(vec3(dot(texture(iChannel0, uv).rgb * vec3(max(dot(objectNormal, vec3(0.0, 1.0, 0.0)), 0.0)), vec3( 0.299, 0.587, 0.114 ))),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "    float seed = 0.0;\n    highp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat rand(vec2 uv)\n{\n    /*float result = fract(sin(seed + mod(time, 1000.0) + dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    //_Seed += 1.0;\n    seed += 1.0;\n    return result;*/\n    float result = random(uv + seed / 10.0);\n    seed += 1.0;\n    return result;\n}\nfloat ss(float x) {\n    return 3.0 * pow(x, 2.0) - 2.0 * pow(x, 3.0);\n}\nfloat activation(float x) {\n    if (x > 0.2) {\n        return max(ss (5.0 * x), 0.0);\n    } else {\n        return 0.0;\n    }\n}\nfloat dactivation(float x) {\n    return -4.0 * pow(x - 0.5, 2.0) + 1.0;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 texelSize = 1.0 / iResolution.xy;\n    vec4 amt = vec4(0.0);\n    if (iFrame == 0) {\n        fragColor = vec4(rand(uv), rand(uv), rand(uv), 1.0);\n    } else {\n    \n       vec4 curr = texture(iChannel0, uv);\n       float count = 0.0;\n       for(float i = -5.0; i <= 5.0; i++) {\n           for(float j = -5.0; j <= 5.0; j++) {\n               if (!(i == 0.0 && j == 0.0)) {\n                   float weight = 1.0 / (length(vec2(i, j)));\n                   amt += weight * texture(iChannel0, uv + vec2(i, j) * texelSize);\n                   count += weight;\n              }\n           }\n       }\n       amt /= count;\n       float killFactor = 0.2;\n       float changeSpeed = 0.41;\n       fragColor = vec4(mix(curr.r, max(activation(amt.r) - killFactor * (amt.g + amt.b), 0.0), changeSpeed),\n       mix(curr.g, max(activation(amt.g) - killFactor * (amt.r + amt.b), 0.0), changeSpeed),\n       mix(curr.b, max(activation(amt.b) - killFactor * (amt.g + amt.r), 0.0), changeSpeed), 1.0);\n    }\n    if (iMouse.z > 0.0) {\n        fragColor = mix(fragColor, vec4(rand(uv), rand(uv), rand(uv), 1.0), min(1.0 / (0.1 * distance(iMouse.xy, fragCoord)), 1.0));\n    }\n    fragColor = mix(fragColor, amt, 0.01);\n    fragColor *= 0.9;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1026]], "test": "untested"}
{"id": "7ddfWB", "name": "Jansen's Linkage", "author": "oneshade", "description": "Strandbeest leg mechanism. My first shader in a while!", "tags": ["automaton", "strandbeest", "leg", "linkage", "theojansen"], "likes": 32, "viewed": 261, "published": 3, "date": "1657150013", "time_retrieved": "2024-07-30T16:41:24.978130", "image_code": "// Reference: https://en.wikipedia.org/wiki/Jansen%27s_linkage\n\n#define PI 3.1415926536\n#define TAU 6.2831853072\n\nvec2 solveJoint(in vec2 a, in vec2 b, in float ra, in float rb, in float config) {\n    vec2 ba = b - a;\n    float d2 = dot(ba, ba), d = sqrt(d2);\n    float offs = (d2 + ra * ra - rb * rb) / (2.0 * ra * d);\n    return a + (ba * offs + vec2(-ba.y, ba.x) * sqrt(1.0 - offs * offs) * config) * ra / d;\n}\n\nmat2 Rotate2D(in float angle) {\n    float co = cos(angle), si = sin(angle);\n    return mat2(co, si, -si, co);\n}\n\nfloat sdLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nfloat sdGear(in float r, in float h, in float n, in vec2 uv) {\n    float teeth = (0.5 + 0.5 * cos(atan(uv.y, uv.x) * n)) * h;\n    return length(uv) - r - teeth;\n}\n\n#define drawSDF(dist, col) color = mix(color, col, smoothstep(unit, 0.0, dist))\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 200.0;\n    float unit = 400.0 / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.3);\n\n    // Moving track with black and yellow stripes\n    vec2 trackUv = uv;\n    trackUv += vec2(iTime * 60.0, 84.0);\n    trackUv.x += trackUv.y;\n    vec3 stripes = vec3(1.0, 1.0, 0.0) * mod(floor(trackUv.x / 20.0), 2.0);\n    drawSDF(trackUv.y, stripes);\n\n    // Driver gear\n    vec2 driverGearUv = uv - vec2(0.0, 7.8);\n    float motorAngle = iTime * 5.0;\n    driverGearUv *= Rotate2D(motorAngle + TAU / 20.0);\n    drawSDF(sdGear(9.0, 4.0, 10.0, driverGearUv), vec3(0.3));\n    drawSDF(length(uv - vec2(0.0, 7.8)) - 2.0, vec3(0.0));\n\n    float crankAngle = motorAngle / 2.0;\n    if (uv.x < 0.0) crankAngle = PI - crankAngle; // Offset back leg\n    uv.x = 75.0 - abs(uv.x);\n\n    // Crank gears (the ones moving the legs)\n    vec2 crankGearUv = uv - vec2(38.0, 7.8);\n    crankGearUv *= Rotate2D(crankAngle);\n    drawSDF(sdGear(23.0, 4.0, 20.0, crankGearUv), vec3(0.5));\n\n    vec2 crankShaft = vec2(38.0, 7.8);\n    vec2 crank = crankShaft + vec2(cos(crankAngle), sin(crankAngle)) * 15.0;\n    drawSDF(length(uv - crankShaft) - 2.0, vec3(0.0));\n\n    vec2 fixedPivot = vec2(0.0);\n    vec2 top = solveJoint(crank, fixedPivot, 50.0, 41.5, -1.0);\n    drawSDF(sdLine(crank, top, uv), vec3(1.0));\n    drawSDF(sdLine(top, fixedPivot, uv), vec3(1.0));\n\n    vec2 hangPivot = solveJoint(crank, fixedPivot, 61.9, 39.3, 1.0);\n    drawSDF(sdLine(crank, hangPivot, uv), vec3(1.0));\n    drawSDF(sdLine(fixedPivot, hangPivot, uv), vec3(1.0));\n\n    // Draw the main control point\n    drawSDF(length(uv - crank) - 2.0, vec3(0.0));\n\n    vec2 swingPivot = solveJoint(top, fixedPivot, 55.8, 40.1, -1.0);\n    drawSDF(sdLine(top, swingPivot, uv), vec3(1.0));\n    drawSDF(sdLine(fixedPivot, swingPivot, uv), vec3(1.0));\n\n    // Draw the fixed pivot\n    drawSDF(length(uv - fixedPivot) - 2.0, vec3(0.0));\n\n    vec2 knee = solveJoint(swingPivot, hangPivot, 39.4, 36.7, -1.0);\n    drawSDF(sdLine(swingPivot, knee, uv), vec3(1.0));\n    drawSDF(sdLine(knee, hangPivot, uv), vec3(1.0));\n\n    vec2 tip = solveJoint(hangPivot, knee, 49.0, 65.7, 1.0);\n    drawSDF(sdLine(hangPivot, tip, uv), vec3(1.0));\n    drawSDF(sdLine(knee, tip, uv), vec3(1.0));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[114, 114, 196, 196, 413], [415, 415, 446, 446, 526], [528, 528, 575, 575, 683], [685, 685, 747, 747, 847], [929, 929, 984, 984, 3282]], "test": "untested"}
{"id": "wscyD2", "name": "Raymarchy Blob Waves", "author": "itgaz", "description": "Babby's first raymarcher\n\nKind of an accident", "tags": ["playgroundraymarching"], "likes": 1, "viewed": 188, "published": 3, "date": "1657141105", "time_retrieved": "2024-07-30T16:41:25.852792", "image_code": "\nconst int maxs = 1000;\nconst float maxt = 100.0;\nconst float eps = 0.0001;\nconst vec3 gradeps = vec3(0.005, 0.0, 0.0);\nconst float PI = 3.14159265;\nconst float PI_2 = 2.0 * PI;\n\nvec3 eye = vec3(0.0, 0.0, -30.0);\n\nvec3 ambientCol = vec3(1.0, 1.0, 1.0);\nfloat kA = 0.3;\nvec3 lightPos = vec3(0.0, 2.0, -10.0);\nvec3 lightCol = vec3(1.0, 1.0, 1.0);\n\n/////////////////\n\nmat3 rotX(float t) {\n  float c = cos(t);\n  float s = sin(t);\n  return mat3(\n    vec3(1, 0, 0),\n    vec3(0, c, -s),\n    vec3(0, s, c)\n  );\n}\nmat3 rotY(float t) {\n  float c = cos(t);\n  float s = sin(t);\n  return mat3(\n    vec3(c, 0, s),\n    vec3(0, 1, 0),\n    vec3(-s, 0, c)\n  );\n}\nmat3 rotZ(float t) {\n  float c = cos(t);\n  float s = sin(t);\n  return mat3(\n    vec3(c, -s, 0),\n    vec3(s, c, 0),\n    vec3(0, 0, 1)\n  );\n}\nmat3 identity() { return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1)); }\nvec4 minSdf(in vec4 a, in vec4 b) {\n  if( a.w < b.w ) return a;\n  else return b;\n}\n\n/////////////////\n\nvec4 sdfSphere(in vec3 p, in vec4 s, in vec3 c) {\n  return vec4(c.xyz,\n    length(p-s.xyz)-s.w );\n}\n\nvec4 sdfFloor(in vec3 p, in float h, in vec3 c) {\n\n  float wobdist = length(p);\n  float wave = sin(wobdist - (iTime * 2.0));\n  float d = p.y - h - wave;\n  vec3 a = vec3(0.8, 0.2, 0.6);\n  vec3 b = vec3(0.0, 0.24, 0.64);\n  vec3 col = mix(a, b, wave);\n\n  return vec4(col, d);\n}\n\nvec4 weirdBall(in vec3 p, in vec4 s, in vec3 c) {\n\n  float fft1 = texture(iChannel0, vec2(0.1, 1.0)).r;\n  float fft2 = texture(iChannel0, vec2(0.2, 1.0)).r;\n  float fft3 = texture(iChannel0, vec2(0.3, 1.0)).r;\n  \n  float f = sin(p.x) * sin(p.y) * sin(p.z) * 1.0;\n  \n  s.y += tan(iTime - 0.5) * 4.0;\n  \n  return sdfSphere(p, s, c) + f;\n}\n\nvec4 sdf(in vec3 p) {\n  vec4 d = vec4(0.0, 0.0, 0.0, maxt);\n  d = minSdf(d, sdfFloor(p, -6.0, vec3(0.2, 0.4, 0.2)));\n  d = minSdf(d, weirdBall(p, vec4(0.0, 0.0, 0.0, 4.0), vec3(0.8 * sin(iTime), 0.8 * cos(iTime), sin(iTime/2.0))));\n  return d;\n}\n\nvec4 shade(vec3 p, vec4 c) {\n  // Calc normal\n  vec3 n = normalize(vec3(\n      sdf(p+gradeps.xyy).w - sdf(p-gradeps.xyy).w,\n      sdf(p+gradeps.yxy).w - sdf(p-gradeps.yxy).w,\n      sdf(p+gradeps.yyx).w - sdf(p-gradeps.yyx).w\n  ));\n  \n  vec3 lightDir = normalize(lightPos - p);\n  float kD = max(0.0, dot(n, lightDir));\n\n  vec3 x = ((kA * ambientCol) + (kD * lightCol)) * c.xyz;\n  return vec4(x, 1.0);\n}\n\nvec4 shadeBG() {\n  return vec4(0.2, 0.2, 0.2, 1.0);\n}\n\nvec4 march(vec3 ro, vec3 rd) {\n  float t = 0.0;\n  vec3 n;\n  for(int s = 0; s < maxs; ++s) {\n    vec3 p = ro + t*rd;\n    vec4 c = sdf(p);\n    \n    if(c.w < eps) {\n      return shade(p, c);\n    }\n    if(t>maxt) {\n      break;\n    }\n    t += c.w;\n  }\n  return shadeBG();\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    mat3 view = identity();\n    view *= rotX(0.5);\n    // view *= rotY(mod(iTime / 10.0, 1.0) * PI_2);\n    \n    float rz = 1.0;\n    vec3 ro = eye * view;\n    vec3 rd = normalize(vec3(uv.xy, rz) * view);\n    fragColor = march(ro, rd);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 385, 385, 504], [505, 505, 525, 525, 644], [645, 645, 665, 665, 784], [785, 785, 802, 802, 862], [863, 863, 898, 898, 945], [966, 966, 1015, 1015, 1065], [1067, 1067, 1116, 1116, 1341], [1343, 1343, 1392, 1392, 1679], [1681, 1681, 1702, 1702, 1926], [1928, 1928, 1956, 1973, 2329], [2331, 2331, 2347, 2347, 2384], [2386, 2386, 2416, 2416, 2655], [2657, 2657, 2714, 2714, 3011]], "test": "untested"}
{"id": "ssdBWS", "name": "Rainbow boxes", "author": "mrange", "description": "License CC0: Rainbow boxes\nWednesday hack to reproduce a commonly seen effect\n", "tags": ["hex"], "likes": 17, "viewed": 358, "published": 3, "date": "1657137042", "time_retrieved": "2024-07-30T16:41:26.989752", "image_code": "// License CC0: Rainbow boxes\n//  Wednesday hack to reproduce a commonly seen effect\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat hexagon(vec2 p, float r) {\n//  const vec3 k = vec3(-0.866025404,0.5,0.577350269);\n  const vec3 k = 0.5*vec3(-sqrt(3.0),1.0,sqrt(4.0/3.0));\n  p = abs(p);\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  return length(p)*sign(p.y);\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\nfloat cellf(vec2 p, vec2 n) {\n  const float lw = 0.01;\n  return -hexagon(p.yx, 0.5-lw);\n}\n\nvec2 df(vec2 p, out vec2 hn0, out vec2 hn1) {\n  const float sz = 0.25;\n  p /= sz;\n  vec2 hp0 = p;\n  vec2 hp1 = p+vec2(1.0, sqrt(1.0/3.0));\n\n  hn0 = hextile(hp0);\n  hn1 = hextile(hp1);\n\n  float d0 = cellf(hp0, hn0);\n  float d1 = cellf(hp1, hn1);\n  float d2 = length(hp0);\n\n  float d = d0;\n  d = min(d0, d1);\n\n  return vec2(d, d2)*sz;\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  vec2 hn0;\n  vec2 hn1;\n  p .x+= 0.05*TIME;\n  vec2 d2 = df(p, hn0, hn1);\n\n  \n  vec3 col = vec3(0.01);\n\n  float h0 = hash(hn1);\n  float h = fract(-0.025*hn1.x+0.1*hn1.y-0.2*TIME);\n  float l = mix(0.25, 0.75, h0);\n\n  if (hn0.x <= hn1.x+0.5) {\n    l *= 0.5;\n  }\n\n  if (hn0.y <= hn1.y) {\n    l *= 0.75;\n  }\n  \n  col += hsv2rgb(vec3(h, 0.5, l));\n  \n  col = mix(col, vec3(0.), smoothstep(aa, -aa, d2.x));\n  col *= mix(0.75, 1.0, smoothstep(0.01, 0.2, d2.y));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME-0.5*length(p));\n  col = clamp(col, 0.0, 1.0);\n  col = sqrt(col);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdBWS.jpg", "access": "api", "license": "cc0-1.0", "functions": [[297, 297, 319, 319, 465], [761, 879, 911, 966, 1150], [1152, 1253, 1281, 1380, 1707], [1709, 1709, 1738, 1738, 1798], [1800, 1800, 1845, 1845, 2134], [2136, 2196, 2217, 2217, 2287], [2289, 2289, 2310, 2310, 2810], [2812, 2812, 2867, 2867, 3127]], "test": "untested"}
{"id": "sdtBWS", "name": "Textile threads", "author": "jarble", "description": "A pattern that resembles a woven textile.", "tags": ["fractal", "cloth", "fabric", "textile"], "likes": 2, "viewed": 201, "published": 3, "date": "1657135650", "time_retrieved": "2024-07-30T16:41:28.110754", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64./2.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float s1 = 1.;\n    for(int k = 0; k < 9; k++){\n        uv += t2;\n        uv /= -scale;\n        float s1 = sign(t2.x-.5);\n        uv.x += s1/2.;\n        uv *= s1;\n        t2 = -triangle_wave(uv-.5-s1);\n        t3 = triangle_wave(uv.yx);\n        uv = t2-t3/(.5-s1);\n        col.x = 1.+max(uv.y-uv.x,col.x/2.);\n        col = abs(col.yzx+vec3(1.-col.x)*2.);\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 838]], "test": "untested"}
{"id": "Nscfzl", "name": "Raceway City", "author": "byt3_m3chanic", "description": "Cityscape / Raceway thing - Raymarching \nit speeds up to racing fast - just sit back and enjoy!\nturn the volume up! \nif music isnt playing - just stop/rewind and play again.", "tags": ["raymarching", "repetition", "city"], "likes": 30, "viewed": 520, "published": 3, "date": "1657124933", "time_retrieved": "2024-07-30T16:41:28.995389", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n   \n    Raceway City | Music Glow Worm | Matrix & Futurebound\n    07/06/22 | byt3_m3chanic\n\n\n*/\n\n#define M           iMouse\n#define R           iResolution\n#define T           iTime\n\n#define PI          3.14159265359\n#define PI2         6.28318530718\n\n#define S smoothstep\n#define L length\n\n#define Q(a) mat2(cos(a + vec4(3,14,36,3)))\n#define H21(a) fract(sin(dot(a,vec2(21.23,41.32)))*43758.5453)\n\n#define N(p,e) vec3(map(p-e.xyy).x,map(p-e.yxy).x,map(p-e.yyx).x)\n#define H(hs) .5+.4*cos(PI2*hs+2.*vec3(.95,.97,.90)*vec3(.95,.55,.15))\n\n// Based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 uv) {\n    vec2 i = floor(uv),\n         f = fract(uv);\n    // Four corners in 2D of a tile\n    float a = H21(i),\n          b = H21(i + vec2(1.0, 0.0)),\n          c = H21(i + vec2(0.0, 1.0)),\n          d = H21(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3. - 2.0 * f);\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b)* u.x * u.y;\n}\n\nfloat fbm ( in vec2 uv, float oct) {\n    float v = .0,a = .5;\n    vec2 shift = vec2(100.0);\n    for (float i = 0.; i < oct; ++i) {\n        v += a * noise(uv);\n        uv = Q(.15) * uv * 2.0 + shift;\n        a *= 0.5;\n    }\n    return v;\n}\n\n//scale\nconst float sz=3.,hf=sz/2.,hz=hf*.25;\nconst vec2 vc = vec2(0,.5);\n\nvec3 hp,hitp;\nvec2 sid,idi;\nfloat time=0.,slow=.0,glow=.0,shs,ghs,ffs=0.;\n\n//@Shane / Path demos\nvec2 path(in float z){ \n    vec2 p1 =vec2(2.3*sin(z * .065), 2.4*sin(z * .045));\n    vec2 p2 =vec2(1.2*cos(z * .050), 2.1*cos(z * .125));\n    return p1 - p2;\n}\n\nvec2 map(in vec3 p) {\n    p.xy-=vec2(1.5,(ffs-.5));\n    vec2 r = vec2(1e5,0);\n\n \tvec2 track = p.xy - path(p.z);\n    vec3 q = vec3(track,p.z);\n    vec3 qq=q;\n    vec2 id=floor((q.xz+hf)/sz);\n    q.xz=mod(q.xz+hf,sz)-hf;\n\n    float f = L(q.y-1.)-.1;\n    \n    float hs=H21(id);\n    shs=hs;\n    idi=id;\n\n    if(hs>.65) {\n         vec3 pp = q;\n         pp.xz=abs(pp.xz)-(hf*.5);pp.y-=.75;\n\n         f = min(L(max(abs(pp)-vec3(.01,.5,.01),0.)),f);\n         float lm =L(pp+vec3(0,.5,0))-.095;\n         f = min(lm,f);\n         slow += .00003/(.00005+lm*lm);\n    }\n\n    p.xz=abs(q.xz)-hf;q.y-=.5;\n    float g = L(max(abs(q)-vec3(hz,hf+hs,hz),0.))-.015;\n    \n    if(f<r.x) {r=vec2(f,2);hp=q;}\n    if(g<r.x) {r=vec2(g,4);hp=qq;}\n\n    return r;\n}\n\nvoid mainImage(out vec4 O, vec2 F)\n{\n    //@Fabrice time motion blur\n    time =  T+ texture(iChannel1,F/8.).r * iTimeDelta;\n    \n    ffs=clamp((3.5-T*.08),0.,3.75);\n    float mt = mod(floor(T*.5),14.);\n    \n    float sp = clamp((3.+T)*.09,0.,11.);\n    float travelSpeed = sp*time;\n    \n    float alpha = 1.;\n    \n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y),\n         id= vec2(0);\n\n    \n    vec3 C = vec3(0),\n         p = vec3(0),\n         lp = vec3(0,0,-travelSpeed),\n         ro = vec3(0,0,.25);\n         \n    float crop = clamp((-.02)+(T*.04),0.,.6);\n    if(uv.y<crop&&uv.y>-crop){\n    \n    float x = M.xy==vec2(0) || M.z<0. ? 0.: (M.y/R.y*0.5-.25)*PI;\n    float y = M.xy==vec2(0) || M.z<0. ? mt>8.?PI:0.: (M.x/R.x*2.0-1.0)*PI;\n    ro.zy*=Q(x);\n    \n    ro +=lp; \n \tlp.xy += path(lp.z);\n    ro.xy += path(ro.z);\n\n    vec3 f=normalize(lp-ro),\n         r=normalize(cross(vec3(0,1,0),f)),\n         u=normalize(cross(f,r)),\n         c=ro+f*.65,\n         i=c+uv.x*r+uv.y*u,\n         rd = i-ro;\n         \n    rd.xy = Q(-path(lp.z+2.).x/ 24. )*rd.xy;\n    rd.xz = Q( y)*rd.xz;\n\n    float clouds = max(rd.y,0.0)*1.5;\n    vec2 sv = .75*rd.xz/rd.y;\n    \n    clouds += 1.45*(-3.0+4.*S(-0.2,0.85,fbm(sv+vec2(0,T*.2),6.)));\n    clouds = mix(clouds,1.,clamp(abs(sv.y)*.075,0.,1.));\n    vec3 fde = vec3(0.212,0.212,0.212);\n    \n    vec3 sky = mix(vec3(.3),fde,clamp(clouds,0.,1.));\n    \n    float d=0.,m=0.;\n    for(int i=0; i++<164 && d<85.; ){\n        p = ro + rd * d;\n        vec2 t = map(p);\n        d+=i<32?t.x*.65:t.x;\n        m=t.y;\n    }\n\n    sid=idi;\n    hitp=hp;\n    glow=slow;\n    ghs=shs;\n\n    float t = map(p).x,\n         sd = 1.,\n         z=.01,\n         hs = H21(sid);\n  \n    vec2 e = vec2(d*.001,0);\n    vec3 l = normalize(vec3(-5,-15,5)),\n         n = t - N(p,e);\n         n = normalize(n);\n\n    for(float z=.01;z<16.;) {\n        float h = map(p+l*z).x;\n        if(h<.001) {sd=0.;break;}\n        sd = min(sd, 18.*h/z);\n        z+=h;\n        if(sd<.001) break;\n    }\n\n    float ch = mod(sid.x+sid.y,2.)*2.-1.,\n          diff = clamp(dot(n,l),.1,.9);\n          diff = mix(diff,diff*sd,.75);\n\n    vec3 h = ch>.5?vec3(.2,0,0):vec3(.7);\n    \n    if(m==2.) {\n        h=vec3(.15);\n        float sc = 1./sz,\n              px=4./R.x;\n              \n        p.xz-=hf;\n        vec2 f = fract(hitp.xz*sc)-.5;\n        float e = min(L(f.x)-.2,L(f.y)-.2),\n              d=S(px,-px,abs(abs(e)-.01)-.005);\n\n        e=S(px,-px,e);\n        h=mix(h,vec3(.01),e);\n        h=mix(h,vec3(.7),d);\n\n        float fy=mod(f.y+.05,.1)-.05;\n        e = max(L(abs(f.x)-.01)-.001,L(fy)-.03);\n\n        e=S(px,-px,e);\n        h=mix(h,vec3(.4,.2,.0),e);\n    }\n    \n    if(m==3.) h=vec3(.5);\n    if(m==4.) {\n        vec3 f = floor(hitp*16.);\n        float hs = min(H21(f.xy),H21(f.zy));\n        float lvl = .925+ghs;\n        h=hitp.y>-lvl?vec3(.05):vec3(.2);\n        if(hs>.5 &&hitp.y>-lvl) h=hs>.75?vec3(.9,.9,.2):vec3(.4);\n        if(hs<.15&&hitp.y>-lvl) h=vec3(.025);\n    }\n    \n    C = diff*h;\n    \n    glow=clamp(glow,0.,.95);\n    C = mix(C,vec3(.9,.9,.6),glow);\n    C = mix(C,fde,1.-exp(-.00004*d*d*d));\n    C = d<85. ? C : sky;\n    }\n    O = vec4(pow(C,vec3(.4545)),1);\n}\n", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29280, "src": "https://soundcloud.com/drrrrrrrrrrrrrrrrrrrrumnbassssssssssssss/glowworm", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nscfzl.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[630, 708, 734, 734, 1098], [1100, 1100, 1136, 1136, 1338], [1490, 1512, 1534, 1534, 1671], [1673, 1673, 1694, 1694, 2407], [2409, 2409, 2445, 2477, 5552]], "test": "untested"}
{"id": "fs3BWH", "name": "Spherical Icosahedral Star Weave", "author": "Shane", "description": "Using a subdivided icosahedral grid partitioning to render a star weave pattern onto the surface of a sphere.", "tags": ["bezier", "sphere", "star", "icosahedron", "polar", "knot", "dodecahedron", "polyhedron"], "likes": 71, "viewed": 890, "published": 3, "date": "1657115965", "time_retrieved": "2024-07-30T16:41:30.484408", "image_code": "/*\n\n    Spherical Icosahedral Star Weave\n    --------------------------------\n    \n    See \"Buffer A\" for an explanation.\n    \n*/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Rendering the buffer.\n    //\n    // See Buffer A for an explanation.\n    \n    // Retrieving the stored color.\n    vec4 col = texture(iChannel0, fragCoord/iResolution.xy);\n\n    // Rough gamma correction and screen presentation.\n    // \"col\" should already be above zero, but we're capping it anyway.\n    fragColor = sqrt(max(col, 0.));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\n    Spherical Icosahedral Star Weave\n    --------------------------------\n    \n    Placing an interwoven 3D polyhedral star pattern onto the surface of a\n    sphere. It's a broad description, since there doesn't appear to be a \n    general concensus on what to call these things. :)\n    \n    An interwoven 3D polyhedral star pattern is really cool to look at. \n    You may have seen it in static image form on the internet. I noticed\n    that it's a favorite amongst the 3D printed art crowd too. However, due \n    to realtime constraints and the long drawn out construction process \n    within 3D tools like Blender, they're not very common on Shadertoy.\n    \n    I remember putting in a request years ago after looking at one of Paul \n    Nylander's images, and Djinn Kahn put together an unlisted one which was \n    based on interlinked triangulated Beziers between an icosahedron and its \n    dual dodecahedron... \n    \n    Like I said, it's a drawn out process, and that is without subdivision.\n    Unfortunately, the really cool looking objects are based on subdivided \n    icosahedrons, which consist of irregular triangles, and that complicate\n    things further. The star weave usually involves multiple point Beziers,\n    which theoretically is as simple as inputting a larger number, but slows \n    things down even further.\n    \n    Therefore, I had to abandon my realtime 3D plans for the moment and \n    settle for a textured version. You may have noticed there's a bit of \n    code here, which may be a little off putting to someone who'd like to \n    make one of these. Just remember that a lot of it is prettying up, and \n    conceptually speaking, this is merely the rendering of a pattern onto a \n    curved triangle face.\n    \n    I'm going to produce a proper 3D version in static path traced form as a \n    compromise, and will upload that later. Without subdivision, a realtime \n    version is already possible, and with compromises a subdivided one would \n    be possible too, but I would like to produce a nice smooth looking one. \n    I have some ideas that I'll try out.\n    \n    As for for why the final design resembles a tacky Louis Vuitton knockoff, \n    I'm not sure how I arrived there, but I've visited a lot of tourist\n    markets in my time. :D\n   \n    \n\n\tOther examples:\n    \n    // Star objects are annoying to model at the best of times, not fun to \n    // code, and are even less fun to produce inside a pixel shader \n    // environment, so only one person has even bothered to try. Djinn Kahn \n    // has an awesome grasp of geometry, but unfortunately, not a lot of \n    // spare time, so he doesn't post often. The link is unlisted, due to the \n    // compile time being very long on some machines.\n    //\n    surface knot starting point - DjinnKahn \n    https://www.shadertoy.com/view/lly3DK\n\n*/\n\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n// Star weaves on the internet consist of five and six pronged stars over the \n// top of tri-pronged shapes, but sometimes the reverse pattern will appear.\n//#define REVERSE_PATTERN\n           \n// I've called it a scheme because I plan to expand on it, but for now\n// it's just a representation of the amount of subdisions, which is \n// one, two or none at all. The latter looks pretty boring, but allows\n// you to study the pattern and joins more closely.\n//\n// No subdivsions: 0, One subdivision: 1, Two subdivisions: 2.\n#define SCHEME 1\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n\n// Commutative smooth minimum function. Provided by Tomkh, and taken \n// from Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float k){\n\n   float f = max(0., 1. - abs(b - a)/k);\n   return min(a, b) - k*.25*f*f;\n}\n\n\n\n\n/////////\n////////\n// A 2D triangle partitioning. I've dropped in an old routine here.\n// It works fine, but could do with some fine tuning.\n\n// Skewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 skewXY(vec2 p, vec2 s){ return mat2(1, -s.yx, 1)*p; }\n\n// Unskewing coordinates. \"s\" contains the X and Y skew factors.\nvec2 unskewXY(vec2 p, vec2 s){ return inverse(mat2(1, -s.yx, 1))*p; }\n\n// Back plane triangle pattern scale.\nconst float scale = 1./2.5;\n\n\nconst vec2 rect = (vec2(1./.8660254, 1))*scale;\n// Skewing half way along X, and not skewing in the Y direction.\nconst vec2 sk = vec2(rect.x*.5, 0)/scale;\n\n\nfloat gTri;\nvec4 getTriVerts(vec2 p, inout vec2[3] vID, inout vec2[3] v){\n\n    p = skewXY(p, sk);\n    \n    // Unique position-based ID for each cell. Technically, to get the central position\n    // back, you'd need to multiply this by the \"rect\" variable, but it's kept this way\n    // to keep the calculations easier. It's worth putting some simple numbers into the\n    // \"rect\" variable to convince yourself that the following makes sense.\n\tvec2 id = floor(p/rect) + .5; \n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= id*rect; \n    \n    \n    // Equivalent to: \n    //float tri = p.x/rect.x < -p.y/rect.y? 1. : 0.;\n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? 0. : 1.;\n   \n    p = unskewXY(p, sk);\n    \n    const vec2[4] vertID = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5));\n\n\n    if(gTri>.5){\n        vID = vec2[3](vertID[0], vertID[2], vertID[1]);\n    }\n    else {\n        vID = vec2[3](vertID[2], vertID[0], vertID[3]);\n    }\n    \n    //id -= (vID[0] + vID[1] + vID[2])/3.;\n    \n    for(int i = 0; i<3; i++) v[i] = unskewXY(vID[i]*rect, sk); // Unskew.\n    \n    // Centering at the zero point.\n    vec2 ctr = v[2]/3.; // (v[0] + v[1] + v[2])/3.;\n    p -= ctr;\n    v[0] -= ctr;\n    v[1] -= ctr;\n    v[2] -= ctr;\n\n    // Centered at the zero point.\n    return vec4(p, id);\n}\n\n//////////\n/*\nfloat getTriVerts(vec2 p){\n\n    \n    // Rectangle grid vertices.\n    const vec2[4] vert = vec2[4](vec2(-.5, .5)*rect, vec2(.5)*rect, vec2(.5, -.5)*rect, vec2(-.5)*rect);\n\n    // Skew the rectangular grid.\n    p = skewXY(p, sk);\n\n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= (floor(p/rect) + .5)*rect; \n    \n    // Base on the bottom (0.) or upside down (1.);\n    gTri = dot(p, 1./rect)<0.? -1. : 1.;\n   \n    // Unskew.\n    p = unskewXY(p, sk);\n    \n    // Triangle vertex points.\n    vec2[3] v;\n    // \n    if(gTri>.0){\n        v = vec2[3](vert[0], vert[2], vert[1]);\n    }\n    else {\n        v = vec2[3](vert[2], vert[0], vert[3]);\n    }\n    \n    for(int i = 0; i<3; i++) v[i] = unskewXY(v[i], sk); // Unskew.\n    \n    // Centering at the zero point.\n    p -= v[2]/3.; // Equivalent to: (v[0] + v[1] + v[2])/3.;\n\n\n    // Centered at the zero point.\n    return length(p);\n}\n*/\n\n// Faster, more compiler friendly version for equilateral triangles.\nfloat getTriVerts(vec2 p){\n\n    \n    // Skew the rectangular grid.\n    p = skewXY(p, sk);\n\n    // Local grid cell coordinates -- Range: [-rect/2., rect/2.].\n\tp -= (floor(p/rect) + .5)*rect; \n    \n    \n    // Triangle offset point.\n    vec2 v = dot(p, 1./rect)<.0? -rect/2. : rect/2.;\n    v = unskewXY(v, sk); // Unskew.\n    \n    \n    // Unskew.\n    p = unskewXY(p, sk);\n    // Centering at the zero point.\n    p -= v/3.;\n\n    // Centered at the zero point.\n    return length(p);\n}\n//////////\n\n\n// 3D rotation via two axis rotations. I should probably drop in a\n// more concise 3D rotation formula from one of my other examples.\nvec3 rotObj(in vec3 p){\n   \n    p.xz *= rot2(iTime/3.);\n    p.yz *= rot2(iTime/6.); \n    \n    return p;\n    \n}\n\n// Sphere position: A little redundant, in this case.\nvec3 sphPos = vec3(0);\n\n\n// Scene distance function.\nfloat map(vec3 p){\n    \n    // Back wall.\n    //\n    // Using a large sphere to create a slightly curved back wall.\n    float wall = -(length(p - sphPos - vec3(0, 0, -(16. - 2.))) - 16.);\n    //float wall = -(length(p.xz - sphPos.xz - vec2(0, -(16. - 2.))) - 16.);\n    // Flat plane back wall.\n    //float wall = -p.z + 2.;// + length(p - sphPos - vec3(0, 0, 0))*.25;\n\n    // Adding subtle spherical curves in a triangle pattern on the \n    // back wall to allow more intersting light reflection.\n    float tr = getTriVerts(p.xy - vec2(0, .075));\n    wall += tr*.25;\n\n    /////    \n\n    // Rotate the sphere.\n    vec3 q = rotObj(p - sphPos);\n\n    // Sphere.\n    float sph = length(q) - .5;\n\n\n    // Overall object ID -- There are two rundundant slots there.\n    vID = vec4(sph, wall, 1e5, 1e5);\n\n    // Shortest distance.\n    return  min(sph, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n\n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //return normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\t\n    //                      m(p + e.yyx) - m(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, \n    // the lowest number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for \n        // this tidbit. So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n        if(occ>1e5) break; // Fake break for compiler reasons.\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n///////\n\n/* \n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r){\n\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n/////////\n\n \n\n/////////\n// A concatinated spherical coordinate to world coordinate conversion.\nvec3 sphericalToWorld(vec3 sphCoord){\n   \n    vec4 cs = vec4(cos(sphCoord.xy), sin(sphCoord.xy));\n    return vec3(cs.w*cs.x, cs.y, cs.w*cs.z)*sphCoord.z;\n}\n  \n\n// Useful polyhedron constants. \n#define PI 3.14159265359\n#define TAU 6.2831853\n#define PHI 1.618033988749895 \n\n//\n// Since all triangles are the same size, etc, any triangles on\n// a known icosahedron will do. The angles we need to determine are\n// the angle from the top point to one of the ones below, the top\n// point to the mid point below, and the angle from the top point\n// to the center (centroid) of the triangle.\nconst vec3 triV0 = normalize(vec3(-1, PHI,  0));\nconst vec3 triV1 = normalize(vec3(-PHI, 0,  1));//0,  1,  PHI\nconst vec3 triV2 = normalize(vec3(0,  1,  PHI));//0,  1,  PHI\nconst vec3 mid = normalize(mix(triV1, triV2, .5));\nconst vec3 cntr = normalize(triV0 + triV1 + triV2);\n\n// Angle between vectors: cos(a) = u.v/|u||v|. \n// U and V are normalized. Therefore, a = acos(u.v).\nconst float ang = acos(dot(triV0, triV1)); // Side length angle.\nconst float mAng = acos(dot(triV0, mid)); // Height angle.\nconst float cAng = acos(dot(triV0, cntr)); // Centroid angle.\n\n// The latitude (in radians) of each of the top and bottom blocks is\n// the angle between the top point (north pole) and one of the points below, \n// or the bottom point (south pole) and one of the ones above.\nconst float latBlock = ang;\nconst vec2 lat = vec2(cAng, mAng*2. - cAng);\n\n//\n\n// Returns the local world coordinates to the nearest triangle and the three\n// triangle vertices in spherical coordinates.\nvec3 getIcosTri(inout vec3 p, inout vec3[3] gVertID, const float rad){\n       \n \n    // Longitudinal scale.\n    const float scX = 5.;\n\n\n    // The sphere is broken up into two sections. The top section \n    // consists of the top row, and half the triangle in the middle\n    // row that sit directly below. The bottom section is the same,\n    // but on the bottome and rotated at PI/5 relative to the top. \n    // The half triangle rows perfectly mesh together to form the \n    // middle row or section.\n\n    // Top and bottom section coordinate systems.The bottom section is \n    // rotated by PI/5 about the equator.\n    vec3 q = p; // Top section coordinates.\n    //vec3 q2 = vec3(rot2(-PI/scX)*p.xz, p.y).xzy; // Bottom section coordinates.\n\n    // Converting to spherical coordinates.\n    // X: Longitudinal angle -- around XZ, in this case.\n    // Y: Latitudinal angle -- rotating around XY.\n    // Z: The radius, if you need it.\n\n    // Longitudinal angle for the top and bottom sections.\n    ////vec4 sph = mod(a + vec4(0, 0, PI/5., PI/5.), TAU);\n    vec4 sph = mod(atan(q.z, q.x) + vec4(0, 0, PI/5., PI/5.), TAU);\n    sph = mod((floor(sph*scX/TAU) + vec4(.5, .5, 0, 0))/scX*TAU, TAU);\n\n\n    float dist = 1e5;\n\n\n    // Top and bottom block latitudes for each of the four groups of triangle to test.\n    vec4 ayT4 = vec4(0, PI - latBlock, PI, latBlock);\n    vec4 ayB4 = vec4(latBlock, latBlock, PI - latBlock, PI - latBlock);\n    float ayT, ayB;\n\n    int id;\n\n    // Iterating through the four triangle group strips and determining the \n    // closest one via the closest central triangle point.\n    for(int i = ZERO; i<4; i++){\n\n\n        // Central vertex postion for this triangle.        \n        int j = i/2;\n        // The spherical coordinates of the central vertex point for this \n        // triangle. The middle mess is the latitudes for each strip. In order,\n        // they are: lat[0], lat[1], PI - lat[0], PI - lat[1]. The longitudinal\n        // are just the polar coordinates. The bottom differ by PI/5. The final\n        // spherical coordinate ranges from the sphere core to the surface.\n        // On the surface, all distances are set to the radius.                \n        vec3 sc = vec3(sph[i], float(j)*PI - float(j*2 - 1)*lat[i%2], rad);\n \n        // Spherical to world, or cartesian, coordinates.\n        vec3 wc = sphericalToWorld(sc);\n\n\n        float vDist = length(q - wc);\n        if(vDist<dist){\n           dist = vDist;\n           ayT = ayT4[i]; // Top triangle vertex latitude.\n           ayB = ayB4[i]; // Bottom triangle vertex latitude.\n           id = i;\n        }\n\n\n    }\n\n\n    float ax = sph[id];\n    // Flip base vertex postions on two blocks for clockwise order.\n    float baseFlip = (id==0 || id==3)? 1. : - 1.;\n\n    // The three vertices in spherical coordinates. I can't remember why\n    // I didn't convert these to world coordinates prior to returning, but\n    // I think it had to do with obtaining accurate IDs... or something. :)\n    gVertID[0] = vec3(ax, ayT, rad);\n    gVertID[1] = vec3(mod(ax - PI/5.*baseFlip, TAU), ayB, rad);\n    gVertID[2] = vec3(mod(ax + PI/5.*baseFlip, TAU), ayB, rad);\n\n    // Top and bottom poles have a longitudinal coordinate of zero.\n    if (id%2==0) gVertID[0].x = 0.;\n\n\n    return q;\n}\n/////////\n\n\n// IQ's line distance formula.\nfloat distLine(vec3 p, vec3 a, vec3 b){\n\n    p -= a; b -= a;\n    float h = clamp(dot(p, b)/dot(b, b), 0., 1.);\n    return length(p - b*h);\n}\n\n// Standard cubic Bezier interpolation.\nvec4 bezierT(in float t){ \n    float u = 1. - t;\n    return vec4(u*u*u, t*u*u*3., t*t*u*3., t*t*t);\n}\n\n// Cubic Bezier spline -- Not cheap, unfortunately, but thankfully,\n// it's good enough for this example. I was hoping there'd be a better way,\n// but so far, it appears to be the only way.\nfloat distSpline(vec3 p, vec3 p0, vec3 p1, vec3 p2, vec3 p3){\n\n    // Distance.\n    float d = 1e5, t = 0.;\n    \n    mat4x3 m43 = mat4x3(p0, p1, p2, p3);\n    \n    // It's not absolutely necessary, but I'm mapping the points\n    // to the surface of the sphere as I go along.\n    vec3 bc1 = normalize(p0)*.5;//normalize(m43*bezierT(0.))*.5;\n\n    // Several lines to approximate a smooth curve. Ouch! :) It's being called\n    // outside the raymarching loop, so we can get away with it.\n    const int N = 16;\n    for(int i = ZERO; i<N; i++){ \n    \n        vec3 bc2 = m43*bezierT(float(i + 1)/float(N));\n        bc2 = normalize(bc2)*.5; // Mapping to the surface of the sphere.\n        \n        //d = min(d, distLine(p, bc1, bc2));\n        float w = float(i)/float(N);\n        float l = length(p - bc1)/length(bc1 - bc2);\n        // Variable thickness. More at the start, but you can do it\n        // the other way around, or not at all.\n        const float th = .0075;\n        d = min(d, distLine(p, bc1, bc2) - (1. - (w + l/float(N)))*th);\n        bc1 = bc2;\n        \n        //if(d<-1e5) break;\n    }\n   \n    return d;\n}\n\n\n// Incircle of a 3D triangle: Basically the 3D extension of\n// the 2D version... I was in a hurry, but it seems about right.\n// Let me know if the logic doesn't follow.\n// \nvec3 inCircle(in vec3 v0, in vec3 v1, in vec3 v2){\n    \n    // Side lengths.\n    vec3 len = vec3(length(v2 - v1), length(v0 - v2), length(v1 - v0));\n    return mat3(v0, v1, v2)*len/dot(len, vec3(1));\n}\n\n/*\n// Angle between 3D vectors. Similar to the 2D version. It's easy to derive\n// this yourself, or look it up on the internet.\nfloat angle(vec3 p0, vec3 p1){\n\n    return acos(dot(p0, p1)/(length(p0)*length(p1)));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    float fBlend = 0.;\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 lk = vec3(0, 0, 0); // Camera position, doubling as the ray origin.\n\tvec3 ro = lk + vec3(cos(iTime/3.)*.1, .25, -1.75);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.25, .75, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\t//rd.xy *= rot2( sin(iTime)/32. );\n \t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    \n    /*\n    // Object identification: For two objects only, this is overkill,\n    // but handy when using more.\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    */\n    \n    // Object identification.\n    objID = vID[0]<vID[1]? 0 : 1;\n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        \n        // Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n       \n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 2.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\tfloat freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Texel color. \n\t    vec3 texCol = vec3(0); \n        \n        \n        // Specular reflection.\n        vec3 hv = normalize(-rd + ld); // Half vector.\n        vec3 ref = reflect(rd, sn); // Surface reflection.\n        vec3 refTx = texture(iChannel1, ref).xyz; refTx *= refTx; // Cube map.\n        float spRef = pow(max(dot(hv, sn), 0.), 16.); // Specular reflection.\n        vec3 rCol = spRef*refTx*1.; //smoothstep(.03, 1., spRef)   \n        \n        \n        // Frame blending hack to mitigate alliasing on the sphere edges.\n        fBlend = 1. - smoothstep(-.2, .2, abs(dot(rd, sn)) - .2);\n\n        // Object patterns, coloring, etc.        \n        if(objID==0){ \n        \n            // The sphere.\n            \n            // Texture position and normal.\n            vec3 txP = sp - sphPos;\n            vec3 txN = sn;\n            \n            // Rotation to match the scene movement.\n            txP = rotObj(txP);\n            txN = rotObj(txN);\n             \n            \n            // Icosahedron vertices and vertex IDs for the current cell.\n            vec3[3] gVert, gVertID;\n            \n            // Obtaining the local cell coordinates and spherical coordinates\n            // for the icosahedron cell.\n            const float rad = .5;\n            vec3 lq = getIcosTri(txP, gVertID, rad);\n   \n            gVert[0] = sphericalToWorld(gVertID[0]);//vec3(0, rad, 0);\n            gVert[1] = sphericalToWorld(gVertID[1]);\n            gVert[2] = sphericalToWorld(gVertID[2]);\n            \n            \n            vec3[3] v = gVert, vID = gVertID;\n            \n            // Edge mid points, edge tangents and exit and entry points.\n            vec3[3] vE, vN;\n            //vec3[6] vE2;\n            \n            // Edge mid points.\n            vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n            vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n            vE[2] = normalize(mix(v[2], v[0], .5))*rad;\n             \n            \n            /////\n            #if SCHEME > 0\n            // Triangle subdivision, if desired.\n            //\n            // Number of subdivisions.\n            #if SCHEME == 1\n            const int subDivNum = 1;\n            #else\n            const int subDivNum = 2;\n            #endif\n            //\n            // There'd be faster ways to do this, but this is\n            // relatively cheap, and it works well enough.\n            for(int i = ZERO; i<subDivNum; i++){\n            \n                // Create three line boundaries within the triangle to \n                // partition into four triangles. Pretty standard stuff.\n                // By the way, there are other partitionings, but this \n                // is the most common. At some stage, I'll include some\n                // others, like the three triangle version connecting the \n                // center to the vertices.\n                //\n                if(dot(lq, cross(vE[0], vE[1]))>0.){\n                    v[0] = vE[0]; v[2] = vE[1];\n                }\n                else if(dot(lq, cross(vE[1], vE[2]))>0.){\n                    v[0] = vE[2]; v[1] = vE[1];\n                }\n                else if(dot(lq, cross(vE[2], vE[0]))>0.){\n                    v[1] = vE[0]; v[2] = vE[2];\n                }\n                else {\n                    v[0] = vE[2]; v[1] = vE[0]; v[2] = vE[1];\n                }\n                \n                // Recalculating the edge mid-vectors for the next iteration.\n                vE[0] = normalize(mix(v[0], v[1], .5))*rad;\n                vE[1] = normalize(mix(v[1], v[2], .5))*rad;\n                vE[2] = normalize(mix(v[2], v[0], .5))*rad;                \n            }\n            #endif\n            /////    \n            \n  \n            // The cell center, which doubles as a cell ID,\n            // due to its uniqueness.\n            vec3 ctr = normalize((v[0] + v[1] + v[2]))*rad;\n            // The unique cell ID, which is used for randomness, etc.\n            vec3 id = ctr;\n            \n \n\n\n            // Icosahedral cell boundary.\n            //\n            // Rendering lines onto a sphere is a little different to those on a plane.\n            // Lines between points translate to great arcs between points. This is\n            // just three triangle edge borders. I normally do these individually, but\n            // discovered this matrix short cut in on of Mattz's examples. Quite obvious...\n            // once someone else did it. :)\n            mat3 mEdge = mat3(cross(v[0], v[1]), cross(v[1], v[2]), cross(v[2], v[0]));\n            vec3 ep = abs(normalize(lq)*mEdge)/length(v[0] - v[1]);  \n            //\n            // Icosahedral triangle cell boundary. If you wanted the triangle, take the\n            // \"abs\" above away.\n            float cellLine = min(min(ep.x, ep.y), ep.z) - .0035;\n \n            \n            \n            // Calculating the tangent vectors for each edge, as well as the two\n            // entry and exit points on each side of the mid-edge point. All are\n            // used to produce the random curves within each triangle cell.\n            for(int i = ZERO; i<3; i++){\n                \n                // Edge tangent vectors.\n                vN[i] = normalize(cross(v[(i + 1)%3] - v[i], v[i]));\n            } \n\n            \n\n            // Debug stuff.\n            // vec3 fiveStar = vec3(0);\n\n            // Rendering the spline curves between entry and exit points.\n            \n            float line = 1e5;\n            float line2 = 1e5;\n            \n            vec3 cn = normalize(inCircle(v[0], v[1], v[2]))*rad;\n            \n            for(int i = ZERO; i<3; i++){\n   \n                int ip1 = (i + 1)%3;  \n                int ip2 = (i + 2)%3; \n                //vec3 cntr0 =  normalize(v[0] + v[1] + v[2])*rad; \n                \n                // Edge entry points -- One on each side of the mid point.\n                float mOffs = .5/8.; // length(v[i] - v[ip1])/4.; //Edge mid point offset.\n                \n      \n                float spLn, ndg;\n                vec3 a, b, aN, bN, tN;\n                \n                // Three pronged central Bezier lines.\n                //tN = normalize(v[ip1] - v[i]);\n                // You have to set up four Bezier points to run the lines through. The end points\n                // are kind of set, since they need to begin at the center and exit at points\n                // near the midpoint of the edges. Where you place the other two points dictates\n                // the shape of the curve, and that's up to you. For me, I use vectors aN and bN \n                // that point away from \"a\" and \"b\" respectively, then I use them to estimate \n                // where the second and third points should be... Sounds annoying? It is. :D \n                // However, with practice, it gets better. :)\n                a = cn; \n                b = normalize(mix(v[i], v[ip1], .5 - mOffs))*rad;  // Just past the mid edge.\n                aN = normalize(cross(normalize(v[i] - cn)*rad, v[ip2] - v[ip1]));\n                bN = vN[i];\n\n                // How far we wish to nudge out the second and third Bezier points... \n                // That's an artform in its own right, which is just another way to say, \n                // I'm guessing. :)\n                ndg = length(a - b)/2.6;\n\n                // Take four points and render a spline curve. Rendering spline curves\n                // is simple enough, but if you're not sure, there is plenty of information\n                // on them.\n                spLn = distSpline(lq, a, normalize(a + aN*ndg)*rad, normalize(b + bN*ndg)*rad, b); \n                line = min(line, spLn);\n\n                // Five and six pronged stars eminating from the triangle vertices.\n                //tN = v[ip2] - v[ip1];\n                a = v[i];\n                b = normalize(mix(v[i], v[ip1], .5 + mOffs))*rad; // Just past the mid edge.\n                // Where you place the points is up to you. This was the tweak that I preferred.\n                aN = normalize(mix(cn, vE[ip2], .5) - v[i]);//normalize(cross(v[i], vE[ip2] - vE[ip1]));\n                bN = vN[i];\n\n                // How far we wish to nudge out the second and third Bezier points.\n                ndg = length(a - b)/2.6;\n\n\n                //vec2 q = p*vec2(-1, 1);\n                // Take four points and render a spline curve.\n                spLn = distSpline(lq, normalize(a - aN*ndg*.25)*rad, normalize(a + aN*ndg)*rad, \n                                      normalize(b + bN*ndg)*rad, b);  \n           \n                line2 = min(line2, spLn);\n                \n                // Using stupid tricks in a futile attempt to get the compile times down.\n                //if(line2<-1e8) break;\n           \n                /*\n                // Debug.\n                float ang = angle(cross(v[(i + 1)%3], v[i]), cross(v[(i + 2)%3], v[i]));\n                if(abs(ang - 6.2831/5.)<.001) fiveStar[i] = 1.;\n                */\n           }\n\n            // Give the edge some thickness.\n            #if SCHEME > 1\n            line -= .008;\n            line2 -= .008;\n            #elif SCHEME == 1\n            line -= .014;\n            line2 -= .014;\n            #else\n            line -= .025;\n            line2 -= .025;\n            #endif\n     \n            //line = 1e5; line2 = 1e5;\n            \n            // Cell vertices.\n            vec3 v3 = vec3(length(lq - v[0]), length(lq - v[1]), length(lq - v[2])); \n            float vert = min(min(v3.x, v3.y), v3.z);\n            \n            // Rounding off the centers.\n            // Rounding off the centers.\n            #if SCHEME == 1\n            line = smin(line, length(lq - cn) - .018, .015);\n            line2 = smin(line2, vert - .048, .015);\n            line2 = min(line2, vert - .05);\n            #elif SCHEME == 0\n            line = smin(line, length(lq - cn) - .033, .015);\n            line2 = smin(line2, vert - .063, .015);\n            line2 = min(line2, vert - .065);\n            #endif\n            \n            \n            \n            // Rendering the vertices, borders and Bezier curvers.\n            \n            \n            // Smoothing factor.\n            float sf = .003; \n            \n            // Triangle cell lines.\n            const float lNum = 80.;\n            float tLns = (abs(fract(cellLine*lNum - .333) - .5)*2. - .125)/lNum/2.;\n            texCol = mix(vec3(.1), vec3(0), (1. - smoothstep(0., sf, tLns))*.7);\n            \n            // Cell border lines.\n            //texCol = mix(texCol, texCol + .1, (1. - smoothstep(0., sf*2., cellLine)));\n            //texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, cellLine))*.9);\n            \n            #ifdef REVERSE_PATTERN\n            // Reversing the pattern is as simple as reversing the rendering order.\n            float tmp = line; line = line2; line2 = tmp;\n            #endif\n            \n            vec3 lCol = vec3(1, .925, .85);\n            // Other colors: vec3(.5, 1, 1.5);//vec3(.75, 1.4, .3);//vec3(1, .925, .85);\n            vec3 trCol = vec3(.8, .55, .35)/1.5; // Trim color.\n            \n  \n            // Adding some specular reflection.\n            trCol += rCol*.7;\n            lCol += rCol*.7;\n            texCol += rCol*.1;\n \n            // Rendering the bezier curves themselves. \n            \n    \n            //float sh = max(.05 - ln[i]/.025, 0.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., line))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, line));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, line + .01));\n            #if SCHEME <= 1\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(line + .00875) - .00175));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, abs(line + .005) - .001));\n            #else\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, line + .006));\n            #endif \n\n            //sh = max(.05 - ln2[i]/.025, 0.);\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., line2))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, line2));\n            texCol = mix(texCol, lCol, 1. - smoothstep(0., sf, line2 + .01));\n            #if SCHEME <= 1\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, abs(line2 + .00875) - .00175));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, abs(line2 + .005) - .001));\n            #else\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, line2 + .006));\n            #endif               \n\n            \n            // Cell vertices.\n            #if SCHEME == 1\n            vert -= .0195;\n            #elif SCHEME == 0\n            vert -= .0275;\n            #endif\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*4., vert))*.35);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, trCol, 1. - smoothstep(0., sf, vert + .005));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .0115));\n            texCol = mix(texCol, vec3(.18, .15, .12) + rCol*.5, 1. - smoothstep(0., sf, vert + .0165));\n \n            \n        }\n        else { \n        \n            //  Wall.\n            \n            \n            // Texture coordinates and normal.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            \n            // Moving the pattern down a bit.\n            txP.y -= .075;\n            \n            // Rotating the pattern for a different perspective.\n            // Would need to be matched inside the distance function too.\n            //txP.xy *= rot2(3.14159/6.);\n            \n            \n            // Cell coordinate, ID and triangle orientation id.\n            // Cell vertices and vertex ID.\n            vec2[3] v, vID;\n\n            // Returns the local coordinates (centered on zero), cellID, the \n            // triangle vertex ID and relative coordinates.\n            vec4 p4 = getTriVerts(txP.xy, vID, v);\n            vec2 p = p4.xy;\n            vec2 id = p4.zw;\n            float tri = gTri;\n            vec2 triID = id + (vID[0] + vID[1] + vID[2])/3.;\n            \n            // Smoothing factor.\n            float sf = .003;\n            \n            // Nearest vertex ID.\n            float vert = 1e5;\n            \n            vec2 vertID;\n            for(int i = 0; i<3; i++){\n                float vDist = length(p - v[i]);\n                if(vDist<vert){\n                    vert = vDist;\n                    vertID = id + vID[i];\n                }\n            }\n \n             \n            // Border triangles, bump highlights, etc. It was made up on the spot, and\n            // I'm pretty sure there'd be better ways to do it. 3D bump mapping would\n            // be better, but I'm keeping things simple and cheaper.\n            vec2 q = tri<.5? p : p*vec2(1, -1);\n            float tr = (max(abs(q.x)*.8660254 + q.y*.5, -q.y) - scale/3. + .0125)/1.;\n            tr = max(tr, -(vert - .07));\n            \n            \n            \n            // Intial background triangle color.\n            texCol = mix(texCol, vec3(.085), (1. - smoothstep(0., sf, tr))*.9);\n            \n            // Subtle reflection.\n            texCol += rCol*.1;\n            \n            // Concentric triangle lines.\n            const float lNum = 26.;\n            float tLns = (abs(fract(tr*lNum + .25) - .5)*2. - .333)/lNum/2.;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf, max(tr, tLns)))*.7);\n         \n            // Vertices with subtle reflection.\n            vert -= .0675;\n            texCol = mix(texCol, vec3(0), (1. - smoothstep(0., sf*6., vert))*.75);\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert));\n            texCol = mix(texCol, vec3(.18, .15, .12) + rCol*.7, 1. - smoothstep(0., sf, vert + .015));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., sf, vert + .035));\n            texCol = mix(texCol, vec3(.085) + rCol*.5, 1. - smoothstep(0., sf, vert + .05));\n           \n \n            \n        }\n        /*\n        // Extra objects.\n        else if(objID==2){ \n\n            texCol = vec3(1);\n        }\n        else { // Wall.\n   \n            texCol = vec3(1);\n        }\n        */\n    \n                \n        // Debug frame blending region.\n        //texCol = mix(texCol, vec3(4, .2, .1), fBlend);\n    \t\n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .3 + vec3(1, .7, .4)*spec*freS*sh);\n \n            // Shading.\n        col *= ao*atten;\n       \n\t\n\t}\n    \n \n    \n    // Background fog: Normally you wouldn't have it, but I accidently left it in\n    // and I don't want to reshade everything. :)\n    col = mix(col, vec3(0), smoothstep(0., .99, t/FAR));\n    \n    // Mix the previous frames in with no camera reprojection. It's OK, but full \n    // temporal blur will be experienced. By the way, the fringes of the sphere are\n    // blended more in a hacky attempt to reduce edge aliasing... It needs work. :)\n    vec4 preCol = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    float blend = (iFrame < 2) ? 1. : 1./(1. + fBlend*8.); \n    fragColor = mix(preCol, vec4(clamp(col, 0., 1.), 1), blend);\n    \n    // No temporal blur, for comparison.\n    //fragColor = vec4(max(aCol, 0.), 1);\n\t\n}", "buffer_a_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3BWH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 185, 303, 535]], "test": "untested"}
{"id": "sd3fWS", "name": "magnets_3viz", "author": "zithral", "description": "various ways of visualising magnetic fields, overlayed.", "tags": ["physics", "fields", "electric", "magnet"], "likes": 8, "viewed": 251, "published": 3, "date": "1657096257", "time_retrieved": "2024-07-30T16:41:31.474761", "image_code": "\n\nfloat Sigmoid (float x) {\n    return 2.0 / (1.0 + exp(-x)) - 1.0; \n}\n\nvec3 hue2rgb(float h){\n    vec3 rgb = clamp(abs(mod(h*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return rgb;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float tau = 2.*3.141;\n    \n    const int num = 4;\n    vec2[num] ps = vec2[](\n        vec2(.3, .7),\n        vec2(.7, .3),\n        vec2(.5, .8),\n        vec2(.4, .6)\n    );\n    float[num] cs = float[](+1., +1., -1., -1.);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    float t = 0.1 * iTime;\n    \n    vec3 col = vec3(0.);\n    float sum = 0.;\n    vec2 forces = vec2(0.);\n    for (int i = 0; i < num; i++) {\n        vec2 p = ps[i] * iResolution.xy;\n        float rand = fract(sin(1000.*float(i+1)));\n        vec2 offs = 0.2*iResolution.x*(1.1-rand)*vec2(cos(tau*t*rand), sin(tau*t*rand));\n        p += offs;\n        \n        \n        float c = cs[i];\n        \n        vec2 dir = p - uv;\n        float d = length(dir);\n        \n        if (d < 10.) {\n            if (c == +1.) {\n                col = vec3(1., 0.5, 0.);\n            } else {\n                col = vec3(0., 0.5, 1.);\n            }\n        }\n        \n        float f = 1./(d*d);\n        \n        sum += c * f;\n        forces += c * f * dir;\n    }\n    \n    \n    forces /= length(forces);\n    float ang = atan(forces.y, forces.x) / tau;\n    if (col == vec3(0)) {\n        col = vec3(0.1);\n        col = 0.5*hue2rgb(ang);\n        \n        float rad = 25.;\n        float size = 2.1*rad;\n        vec2 compass = round(uv/size) * size;\n        vec2 dir1 = compass - uv;\n        vec2 dir2 = -dir1;\n        float len = length(dir1);\n        if (len < rad) {\n            col = vec3(0.2);\n            len /= rad;\n            dir1 /= length(dir1);\n            dir2 /= length(dir2);\n            \n            if (length(forces-dir1) < 0.5*(1.-len)) {\n                col = vec3(0., 0.5, 1.);\n            }\n            if (length(forces-dir2) < 0.5*(1.-len)) {\n                col = vec3(1., 0.5, 0.);\n            }\n        }\n    }\n    \n    \n    \n    \n    \n    if (col != vec3(0)) {\n        sum = Sigmoid(50000.*sum);\n        float val = abs(sum);\n        \n        val = floor(fract(8.*(abs(sum)-.01))+.05);\n        \n        //float val = min(1., 1. - 1./(abs(sum)));\n        if (0.1 < val) {\n            if (sum > 0.) {\n                col = vec3(val, 0., 0.);\n            } else {\n                col = vec3(0., val, val);\n            }\n        }\n    }\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3fWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 27, 27, 70], [72, 72, 94, 94, 297]], "test": "untested"}
{"id": "fscfWB", "name": "Gilded mosaic", "author": "jarble", "description": "A gold mosaic pattern.", "tags": ["fractal", "knot", "mosaic"], "likes": 3, "viewed": 197, "published": 3, "date": "1657082532", "time_retrieved": "2024-07-30T16:41:32.318506", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nvec2 triangle_wave(vec2 a){\n    //a = rotate(a,num*radians(180.));\n    vec2 to_return = abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n    //to_return /= 1.5; //makes another interesting pattern\n    return to_return;\n    //return abs(fract((a+vec2(1.,1.5)+num)*scale)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n        float time1 = iTime/64.;\n\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float offset = 0.;\n    float offset1 = iTime/1000.;\n        vec2 t2 = vec2(0.);\n        vec2 t3 = vec2(0.);\n        for(int k = 0; k < 9; k++){\n\n            uv += t2;\n            uv /= scale;\n            t2 = triangle_wave(uv);\n            t3 = -triangle_wave(uv.yx-.5);\n            uv = t2-t3;\n            \n            col.x = (col.x+max(uv.y-uv.x,col.x))/(2.);\n            col.x = abs(col.x-.5);\n            col = abs(col.yzx-vec3(col.x/sqrt(2.)))*2.;\n        }\n\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 114], [116, 116, 143, 182, 380], [382, 382, 439, 439, 1204]], "test": "untested"}
{"id": "fscBWB", "name": "chained", "author": "jorge2017a2", "description": "chained", "tags": ["chained"], "likes": 31, "viewed": 377, "published": 3, "date": "1657075469", "time_retrieved": "2024-07-30T16:41:33.182195", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\n//Referencia\n//https://www.shadertoy.com/view/wlXSD7-------IQ\n//chained\n\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\nvec3 phit;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n//IQ\nfloat sdLink( in vec3 p, in float le, in float r1, in float r2 )\n{   vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n    return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\n//iQ\nvec4 mapCadena( in vec3 pos )\n{   // animate\n    pos.y += 0.5*iTime;\n   // paramteres\n    const float le = 0.13, r1 = 0.2, r2 = 0.09;\n    // make a chain out of sdLink's\n    vec3 a = pos;  a.y = fract(a.y    )-0.5;\n    vec3 b = pos;  b.y = fract(b.y+0.5)-0.5;\n    // evaluate two links\n    float d1=sdLink(a.xyz,le,r1,r2);\n    float d2=sdLink(b.zyx,le,r1,r2);\n    float dmin;\n    if(d1<d2 )\n     {   phit=a; dmin=d1; }\n    else\n     {   phit=b; dmin=d2; }\n     vec4 res4=vec4(dmin,phit);\n  return res4;\n}\n\nvec4 escalaCadena(vec3 p)\n{   float s=6.0;\n    vec4 res= mapCadena(p/s);res.x*=s;\n    return res;\n}\n\nvec4 minphit(vec4 mc1,vec4 mc2)\n{   float dmin=9999.9;\n    vec3 ptmphit;\n     float dist1=min(mc1.x,mc2.x);\n    if(dist1==mc1.x)\n       { ptmphit=mc1.yzw; dmin=mc1.x; }\n    else if(dist1==mc2.x)\n       { ptmphit=mc2.yzw; dmin=mc2.x; }\n    return vec4(dmin, ptmphit);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p.y=p.y-5.0;\n    vec3 p0=p;\n\t\n     p=p.yzx;\n    p.y= opRep1D( p.y, 25.0 );\n    vec4 mc1=escalaCadena(p.yzx);\n    vec4 mc2=escalaCadena(vec3(p.y,p.z,p.x)-vec3(5.0,5.0,5.0));\n    \n    p=p0;\n    p.y+=9.0;\n    p.x= opRep1D( p.x, 25.0 );\n    vec4 mc3=escalaCadena(p.yzx);\n    vec4 mc4=escalaCadena(vec3(p.y,p.z,p.x)-vec3(5.0,5.0,5.0));\n    \n    p=p0;\n    p-=vec3(10.,0.0,10.0);\n    p.z= opRep1D( p.z, 25.0 );\n    p.x= opRep1D( p.x, 25.0 );\n    vec4 mc5=escalaCadena(p);\n    vec4 mc6=escalaCadena(p-vec3(5.0,5.0,5.0));\n \n    vec4 phittmp=vec4(9999.9,0.0,0.0,0.0);\n    \n    phittmp=minphit(phittmp,mc1);\n    phittmp=minphit(phittmp,mc2);\n    phittmp=minphit(phittmp,mc3);\n    phittmp=minphit(phittmp,mc4);\n    phittmp=minphit(phittmp,mc5);\n    phittmp=minphit(phittmp,mc6);\n    \n    phit=phittmp.yzw;\n    ///corregido por ocb\n     res =opU2(res, vec2(mc1.x,100.0));\n    res =opU2(res, vec2(mc2.x,100.0));\n    res =opU2(res, vec2(mc3.x,101.0));\n    res =opU2(res, vec2(mc4.x,101.0));\n    res =opU2(res, vec2(mc5.x,102.0));\n    res =opU2(res, vec2(mc6.x,102.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ p=phit.yzx ; col=tex3D(iChannel0, p/1., nor); return col*2.0;  }\n    if (i==101 ){ p=phit.zxy ; col=tex3D(iChannel0, p/1., nor); return col*2.0;  }\n    if (i==102 ){ p=phit      ; col=tex3D(iChannel0, p/1., nor); return col*2.0;  }\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n\treturn sky;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n    if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0;        \n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,10.0,-25.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   if(6.0*sin(t)>0.0)\n       rd= rotate_y(rd, t*0.5);\n   else\n       ro=vec3(0.0+10.*sin(t),10.0,-25.0);\n     \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[546, 584, 620, 620, 665], [667, 692, 726, 726, 822], [823, 823, 857, 857, 948], [949, 949, 983, 983, 1074], [1076, 1081, 1147, 1147, 1251], [1253, 1258, 1289, 1302, 1762], [1764, 1764, 1791, 1791, 1863], [1865, 1865, 1898, 1898, 2133], [2135, 2135, 2160, 2160, 3273], [3275, 3275, 3299, 3299, 3461], [3463, 3463, 3511, 3511, 3790], [3792, 3792, 3836, 3836, 4157], [4159, 4159, 4196, 4196, 4453], [4455, 4455, 4545, 4545, 5504], [5506, 5506, 5555, 5555, 5817], [5819, 5819, 5851, 5851, 6048], [6050, 6050, 6120, 6120, 6218], [6220, 6220, 6247, 6247, 6336], [6338, 6338, 6396, 6396, 6444], [6446, 6446, 6469, 6469, 6581], [6583, 6583, 6614, 6614, 7241], [7243, 7243, 7300, 7300, 7844]], "test": "untested"}
{"id": "7ddBRs", "name": "Urysohn Lemma", "author": "N8Shader", "description": "Trivial example in R^2 of a Lemma I barely understand.", "tags": ["urysohn"], "likes": 5, "viewed": 287, "published": 3, "date": "1657046156", "time_retrieved": "2024-07-30T16:41:33.937176", "image_code": "float csdf(vec2 p, vec2 c, float r) {\n    return max(length(p - c) - r, 0.0);\n}\n  float seed = 0.0;\n    highp float random(vec2 co)\n{\n    highp float a = 12.9898;\n    highp float b = 78.233;\n    highp float c = 43758.5453;\n    highp float dt= dot(co.xy ,vec2(a,b));\n    highp float sn= mod(dt,3.14);\n    return fract(sin(sn) * c);\n}\nfloat rand()\n{\n    /*float result = fract(sin(seed + mod(time, 1000.0) + dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n    //_Seed += 1.0;\n    seed += 1.0;\n    return result;*/\n    float result = random(vec2(100.0 * seed));\n    seed += 1.0;\n    return result;\n}\nvec3 permute(vec3 x) { return mod(((x*34.0)+1.0)*x, 289.0); }\n    float smin(float a, float b, float k) {\n      float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n      return mix(b, a, h) - k * h * (1.0 - h);\n    }\nfloat snoise(vec2 v){\n  const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n           -0.577350269189626, 0.024390243902439);\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n  vec2 i1;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n  i = mod(i, 289.0);\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n  + i.x + vec3(0.0, i1.x, 1.0 ));\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n    dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    //float dist1 = csdf(uv, vec2(0.25, 0.25), 0.1);\n    //float dist2 = csdf(uv, vec2(0.75, 0.75), 0.1);\n    float num = 1000.0;\n    float dom = 1000.0;\n    float speed = 0.1;\n    for(float i = 0.0; i < 10.0; i++) {\n                float dist = csdf(uv, vec2((0.5 + 0.5 * snoise(speed * vec2(10.0 * i, iTime))) * iResolution.x / iResolution.y, (0.5 + 0.5 * snoise(speed * vec2(iTime, i * 10.0)))), 0.0);\n        if (mod(i, 2.0) == 1.0) {\n            num = num < 1000.0 ? smin(num, dist, 0.1) : min(num, dist);\n        } else {\n           dom = dom < 1000.0 ? smin(dom, dist, 0.1) : min(dom, dist);\n        }\n    }\n    float final = num / (num + dom);\n    fragColor = vec4(vec3(final) + 0.05 * vec3(max(cos(100.0 * final), 0.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddBRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 79], [333, 333, 347, 523, 608], [609, 609, 631, 631, 670], [675, 675, 714, 714, 825], [826, 826, 847, 847, 1667], [1668, 1668, 1725, 1775, 2596]], "test": "untested"}
{"id": "NddfRl", "name": "infinity ladder", "author": "jorge2017a2", "description": "infinity ladder", "tags": ["infinityladder"], "likes": 14, "viewed": 252, "published": 3, "date": "1657027908", "time_retrieved": "2024-07-30T16:41:34.798872", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//infinity ladder\n//referencia\n///https://iquilezles.org/\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n    \nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat opScaleEscalera( in vec3 p )\n{   float s=0.125;\n    return sdStairs(p.xy/s, vec2(10.0,10.0), 10.0 )*s;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p= rotate_x(p, radians(90.0));\n    p.y=p.y+15.0;  //si\n    \n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    \n    p.y= opRep1D( p.y, 20.0);\n    //cuadro\n    float d01= sdBox(p-vec3(1.0,30.0,-9.0), vec3(14.5,40.0,14.0) );\n    float d02= sdBox(p-vec3(1.0,30.0,-9.0), vec3(13.5,41.0,13.0) );\n    float d03= sdBox(p-vec3(0.0,-12.0,-8.0), vec3(16.0,1.0,16.0) );\n    d01= Difference(d01, d02);\n    res =opU2(res, vec2(d01,1.0));\n    //res =opU2(res, vec2(d03,8.0));\n    \n    float aEs=3.0;\n    float mvx=1.0;\n    float ctx=2.0; //100.0;\n    \n    vec3 p1=vec3(p0.x,p0.y,p0.z);\n    //primer escalon\n    p1.y= opRep1D( p1.y, 54.0);\n\tfloat d1a=opScaleEscalera( p1-vec3(-6.0,5.0,0.0));\n    float d2a= sdBox(p1-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3a= sdBox(p1-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1a= Intersect(d1a, d2a);\n    d1a= Union(d1a, d3a);\n    res =opU2(res, vec2(d1a,ctx));\n    \n    \n    //2do escalon\n    p.xyz=vec3(-p0.z,p0.y,p0.x);\n    p.y-=13.5;\n    p.x-=8.0+mvx;\n    p.z-=8.5+mvx;\n    p.y= opRep1D( p.y, 54.0);\n    \n    float d1b=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2b= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3b= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1b= Intersect(d1b, d2b);\n    d1b= Union(d1b, d3b);\n    res =opU2(res, vec2(d1b,ctx));\n    \n    \n    //tercero escalon\n    //p.xyz=vec3(-p0.z,p0.y,p0.x);\n    p.xyz=vec3(-p0.x,p0.y,p0.z);\n    p.y-=27.0;\n    p.x+=0.5;\n    p.z+=17.0+mvx+mvx/2.0;\n    p.y= opRep1D( p.y, 54.0);\n    float d1c=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2c= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3c= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1c= Intersect(d1c, d2c);\n    d1c= Union(d1c, d3c);\n    res =opU2(res, vec2(d1c,ctx));\n    \n    \n    //4to ultimo\n    p.xyz=vec3(p0.z,p0.y,p0.x);\n    p.y-=40.5;\n    p.x+=9.0+mvx/2.0;\n    p.z+=8.0+mvx;\n    p.y= opRep1D( p.y, 54.0);\n    float d1d=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2d= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3d= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1d= Intersect(d1d, d2d);\n    d1d= Union(d1d, d3d);\n    res =opU2(res, vec2(d1d,ctx));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n    //float shadow =0.5;// shadows\n\n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{ if (i==100 ){ vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0;} }\n\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{   if(id_color==0)  { return vec3(0.,0.,0.);}\n    if(id_color==1)  { return  vec3(1.,1.,1.);}\n    if(id_color==2)  { return  vec3(1.,0.5,0.2);}\n    if(id_color==8)  { return  vec3(0.7529,0.7529,0.7529);}\n    if(id_color>=100){ return  getColorTextura( p, nor,id_color); }\n    \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       { vec3  p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        //col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        col= ACESFilm(col) ;\n    }\n    \n    return col;\n}\n\n\n#define pi 3.14159\n#define rot(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,500.0);\n \tlight_pos1= vec3(0.0,  50.0, -20.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, -50.0, -30.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n    vec3  R = iResolution;\n    \n   vec3 ro=vec3(0.0,-7.0,-70.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   float rx = (iMouse.z >= 0.5 ? iMouse.x/iResolution.x*2.0*pi-pi\n                : 0.25*sin(0.2*iTime));\n    float ry = (iMouse.z >= 0.5 ? iMouse.y/iResolution.y*pi-pi/2.0\n                : sin(0.3*iTime)*smoothstep(-1.0, 1.0, sin(0.6*iTime)));\n                \n    rd.yz *= rot(ry);\n    rd.xz *= rot(rx);\n    rd.xy *= rot(pi/2.0);\n    \n   \n   light_pos1+=ro;\n   light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddfRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 552, 552, 636], [638, 638, 674, 674, 719], [721, 721, 765, 765, 792], [793, 793, 833, 833, 860], [861, 861, 906, 906, 934], [941, 941, 975, 975, 1071], [1072, 1072, 1106, 1106, 1197], [1198, 1198, 1232, 1232, 1323], [1325, 1325, 1350, 1350, 1369], [1370, 1370, 1395, 1395, 1414], [1415, 1415, 1451, 1451, 1479], [1482, 1482, 1535, 1547, 2427], [2429, 2429, 2465, 2465, 2539], [2541, 2541, 2566, 2566, 4847], [4849, 4849, 4873, 4873, 5035], [5037, 5037, 5085, 5085, 5364], [5367, 5367, 5411, 5411, 5732], [5734, 5734, 5771, 5771, 6028], [6030, 6030, 6053, 6053, 6208], [6210, 6210, 6300, 6300, 7285], [7287, 7287, 7336, 7336, 7408], [7412, 7412, 7482, 7482, 7760], [7762, 7762, 7789, 7789, 7878], [7880, 7880, 7938, 7938, 7986], [7988, 7988, 8011, 8011, 8123], [8125, 8125, 8156, 8156, 8732], [8808, 8808, 8865, 8865, 9670]], "test": "untested"}
{"id": "sdcBzs", "name": "Walkers 2", "author": "dr2", "description": "Walkers with lights", "tags": ["gait", "quadruped", "lightbeam"], "likes": 13, "viewed": 278, "published": 3, "date": "1657016120", "time_retrieved": "2024-07-30T16:41:35.883971", "image_code": "// \"Walkers 2\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define N_WLK 2\n\nvec3 sunDir, qHit, wPos;\nfloat tCur, dstFar, spd;\nint idObj;\nconst int idLeg = 1, idAx = 2, idFoot = 3, idPlat = 4, idTur = 5, idMnt = 6, idBrl = 7;\nbool isSh;\nconst float pi = 3.1415927;\n\nstruct Leg {\n  vec2 cs1, cs2, cs3;\n};\n\nstruct Walker {\n  Leg leg[4];\n  vec3 wPos, ltPos, bmAx;\n  vec2 csTur, csBrl;\n};\nWalker wlk[N_WLK];\n\nvec3 szLeg;\nvec2 bmCs, brlPiv;\nfloat hPlat, bLen, bWid;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid SetWlkConf ()\n{\n  vec2 e;\n  float sDir, tc, t, tH, tt, tV, limT, fUp, limEx, a1, a2, fh;\n  szLeg = vec3 (0.06, 0.15, 2.);\n  bWid = 1.5;\n  bLen = 1.5;\n  tH = 0.01;\n  tV = 0.3;\n  limT = 0.2;\n  limEx = 0.997;\n  fUp = 1.;\n  hPlat = 4. * limEx * szLeg.z * cos (atan (limT));\n  bmCs = sin (-0.015 * pi + vec2 (0.5 * pi, 0.));\n  brlPiv = vec2 (1.5, -1.4);\n  e = vec2 (1., -1.);\n  for (int j = 0; j < N_WLK; j ++) {\n    tc = tCur * spd / (hPlat * limT * 2. / 3.);\n    for (int k = 0; k < 4; k ++) {\n      t = mod (tc + float (k), 4.);\n      if (t > 1.) {\n        sDir = -1.;\n        t = (t - 1.) / 3.;\n      } else sDir = 1.;\n      tt = 0.5 - abs (t - 0.5);\n      a1 = atan (limT * (((tt < tH) ? tt * tt / tH : 2. * tt - tH) / (1. - tH) - 1.) *\n         sign (0.5 - t) * sDir);\n      fh = hPlat;\n      if (sDir > 0.) fh -= fUp * smoothstep (0., tV, tt);\n      fh *= 0.5 / cos (a1);\n      a2 = acos (0.5 * fh / szLeg.z);\n      wlk[j].leg[k].cs1 = sin (-0.5 * pi + a1 + a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs2 = sin (-2. * a2 + vec2 (0.5 * pi, 0.));\n      wlk[j].leg[k].cs3 = sin (0.5 * pi - a1 + a2 + vec2 (0.5 * pi, 0.));\n    }\n    wlk[j].csTur = sin (0.3 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       fract (0.08 * tCur)) - 1.) - pi + vec2 (0.5 * pi, 0.));\n    wlk[j].csBrl = sin (-0.03 * pi * (2. * SmoothBump (0.25, 0.75, 0.25,\n       fract (0.2 * tCur)) - 1.) + 0.08 * pi + vec2 (0.5 * pi, 0.));\n    wlk[j].wPos = wPos - vec3 (6. * float (2 * j - N_WLK + 1), 0., 0.);\n    wlk[j].ltPos = vec3 (0., hPlat, 0.) + vec3 (0., brlPiv);\n    wlk[j].ltPos.yz = Rot2Cs (wlk[j].ltPos.yz, wlk[j].csBrl * e);\n    wlk[j].ltPos.xz = Rot2Cs (wlk[j].ltPos.xz, wlk[j].csTur * e);\n    wlk[j].ltPos += wlk[j].wPos;\n    wlk[j].bmAx = vec3 (0., 0., -1.);\n    wlk[j].bmAx.yz = Rot2Cs (wlk[j].bmAx.yz, wlk[j].csBrl * e);\n    wlk[j].bmAx.xz = Rot2Cs (wlk[j].bmAx.xz, wlk[j].csTur * e);\n  }\n}\n\nfloat WlkDf (vec3 p, float dMin, Walker wk)\n{\n  vec3 q;\n  float d, qz;\n  p.y -= hPlat;\n  q = p;\n  q.y -= 0.3;\n  d = SmoothMax (-1.6 * bWid + dot (vec2 (length (q.xz), abs (q.y)),\n     sin (0.2 * pi +  vec2 (0.5 * pi, 0.))), abs (q.y) - 0.35, 0.02);\n  d = max (d, - max (PrRoundBox2Df (vec2 (abs (q.xz - vec2 (0., 0.1)) - vec2 (bWid, bLen)),\n     vec2 (0.1, 0.3), 0.05), q.y - 0.3));\n  DMINQ (idPlat);\n  q.y -= 1.25;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.xz = vec2 (q.z, - q.x);\n  if (length (q.xz) > 0.) q.xz = Rot2D (q.xz, 2. * pi * (floor (7. * atan (q.z, - q.x) /\n     (2. * pi) + 0.5) / 7.));\n  d = SmoothMax (-1.3 - dot (vec2 (q.x, abs (q.y)), sin (-0.15 * pi + vec2 (0.5 * pi, 0.))),\n     abs (q.y) - 0.82, 0.02);\n  DMINQ (idTur);\n  q = p;\n  q.xz = Rot2Cs (q.xz, wk.csTur);\n  q.yz = Rot2Cs (q.yz - brlPiv, wk.csBrl);\n  d = length (q) - 0.3;\n  DMINQ (idMnt);\n  q.z -= -0.8;\n  d = PrCylDf (q, 0.2, 0.8);\n  DMINQ (idBrl);\n  q = p;\n  q.xz = abs (q.xz) - vec2 (bWid, bLen);\n  q.y -= szLeg.y;\n  d = PrCylDf (q.yzx, 1.4 * szLeg.y, 3. * szLeg.x);\n  DMINQ (idAx);\n  for (int k = 0; k < 4; k ++) {\n    q = p;\n    q.xz += vec2 (bWid * ((k == 0 || k == 1) ? -1. : 1.), bLen * ((k == 1 || k == 3) ? -1. : 1.));\n    q.y -= szLeg.y;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs1);\n    q.z -= szLeg.z;\n    d = PrRoundBoxDf (q, szLeg - 0.02, 0.02);\n    DMINQ (idLeg);\n    q.z -= szLeg.z;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs2);\n    q.z -= szLeg.z;\n    d = PrRoundBoxDf (q, szLeg - 0.02, 0.02);\n    DMINQ (idLeg);\n    qz = q.z;\n    q.z = abs (q.z) - szLeg.z;\n    d = PrCylDf (q.yzx, 1.2 * szLeg.y, 2.5 * szLeg.x);\n    DMINQ (idAx);\n    q.z = qz - szLeg.z;\n    q.yz = Rot2Cs (q.yz, wk.leg[k].cs3);\n    d = max (max (PrCaps2Df (q.yz, szLeg.y, 0.5), abs (q.x) - 5. * szLeg.x),\n       - PrRoundBox2Df (q.xz - vec2 (0., 0.05), vec2 (0.1, 0.25), 0.05));\n    DMINQ (idFoot);\n  }\n  return dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    q = p - wlk[j].wPos;\n    d = (isSh) ? 0. : PrRoundBoxDf (q - vec3 (0., 5.2, 0.), vec3 (3., 5.2, 4.2) - 0.1, 0.1);\n    if (d < 0.3) d = WlkDf (q, dMin, wlk[j]);\n    dMin = min (d, dMin);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    d = ObjDf (p);\n    if (d < 0.0005 || dHit > dstFar || p.y < 0.) break;\n    dHit += d;\n  }\n  if (p.y < 0.) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.02 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.4, 0.5);\n  } else {\n    q = 0.01 * (ro.xz + 2. * tCur + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, sunDir), 0.);\n    skCol = 0.7 * vec3 (0.3, 0.4, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return col;\n}\n\nfloat GrndHt (vec2 p)\n{\n  return 0.7 * Fbm2 (0.2 * p.yx);\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e;\n  e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x)).xzy;\n}\n\nvec4 ConCylHit (vec3 ro, vec3 rd, vec2 cs, float rad, float len, out float dcHit)\n{\n  vec3 s, vn;\n  float dMin, d, g, a, b, w, ta;\n  dMin = 1e6;\n  ta = cs.y / cs.x;\n  g = 1. + ta * ta;\n  a = 1. - g * rd.z * rd.z;\n  b = dot (ro, rd) + (ta * rad - g * ro.z) * rd.z;\n  w = b * b - a * (dot (ro, ro) + (2. * ta * rad - g * ro.z) * ro.z - rad * rad);\n  if (w > 0. && a != 0.) {\n    d = - (b + sqrt (w)) / a;\n    s = ro + d * rd;\n    if (abs (s.z) < len) {\n      dMin = d;\n      dcHit = 1. - s.z / len;\n      vn = vec3 (cs, 0.).xzy;\n      vn.xy = Rot2Cs (vn.xy, normalize (s.xy));\n    }\n  }\n  return vec4 (dMin, vn);\n}\n\nfloat BmVal (vec3 ro, vec3 rd, float dstLim)\n{\n  vec4 dc4;\n  vec3 ror, rdr, vn;\n  vec2 e;\n  float bmVal, bmLen, bmRad, dcHit;\n  bmLen = 50.;\n  bmRad = 2.45;\n  e = vec2 (1., -1.);\n  bmVal = 0.;\n  for (int j = VAR_ZERO; j < N_WLK; j ++) {\n    ror = ro - wlk[j].wPos; \n    ror.y -= hPlat;\n    rdr = rd;\n    ror.xz = Rot2Cs (ror.xz, wlk[j].csTur);\n    ror.yz -= brlPiv;\n    ror.yz = Rot2Cs (ror.yz, wlk[j].csBrl);\n    rdr.xz = Rot2Cs (rdr.xz, wlk[j].csTur);\n    rdr.yz = Rot2Cs (rdr.yz, wlk[j].csBrl);\n    ror.z += bmLen;\n    dc4 = ConCylHit (ror, rdr, bmCs * e, bmRad, bmLen, dcHit);\n    if (dc4.x < dstLim) {\n      vn = dc4.yzw;\n      vn.yz = Rot2Cs (vn.yz, wlk[j].csBrl * e);\n      vn.xz = Rot2Cs (vn.xz, wlk[j].csTur * e);\n      bmVal = max (bmVal, max (- dot (vn, rd), 0.) / (1. + 5. * dcHit * dcHit));\n    }\n  }\n  return bmVal;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, roo, ror, rdr, bmDir;\n  float dstObj, dstGrnd, sh, nDotL, bmLen, att, bmVal, r;\n  SetWlkConf ();\n  isSh = false;\n  dstGrnd = dstFar;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    col4 = vec4 (0.85, 0.85, 0.95, 0.2);\n    if (idObj == idLeg) {\n      col4 *= 0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (4. * qHit.z - 0.5 * qHit.y) - 0.5));\n    } else if (idObj == idAx) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0.08, 0.1,\n         length (qHit.yz))) * (0.8 + 0.2 * smoothstep (0.01, 0.02, abs (abs (qHit.x) - 0.07)));\n    } else if (idObj == idFoot) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.2) * (0.8 + 0.2 * smoothstep (0.08, 0.1, abs (fract (8. *\n         qHit.x) - 0.5))) * (0.8 + 0.2 * step (0.12, length (vec2 (qHit.y, abs (qHit.z) - 0.45))));\n    } else if (idObj == idPlat) {\n      r = length (qHit.xz);\n      if (r > 2.7) col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.04, abs (dot (qHit.zx, sin (2. * pi *\n         (floor (64. * atan (qHit.z, - qHit.x) / (2. * pi) + 0.5) / 64.) + vec2 (0.5 * pi, 0.)))));\n      else col4 *= 0.8 + 0.2 * smoothstep (0.03, 0.05, abs (abs (r - 1.9) - 0.3));\n    } else if (idObj == idTur) {\n      r = length (qHit.xz);\n      col4 *= (0.8 + 0.2 * smoothstep (0.04, 0.06, abs (fract (4. * qHit.y) - 0.5))) *\n         (0.8 + 0.2 * smoothstep (0.03, 0.04, abs (r - 0.5)));\n      col4 = mix (mix (vec4 (0.8, 0., 0., -1.), 0.8 * col4, step (0.5, fract (tCur))), col4,\n         step (0.15, r));\n    } else if (idObj == idBrl) {\n      r = length (qHit.xy);\n      if (r < 0.15) col4 = vec4 (1., 1., 0.9, -1.);\n      else if (r > 0.19) col4 = mix (col4, vec4 (0.8, 0.8, 0.6, -1.),\n         step (fract (6. * qHit.z + 8. * tCur), 0.4));\n    } else if (idObj == idMnt) {\n      col4 *= 0.8;\n    }\n    vn = ObjNf (ro);\n    nDotL = max (dot (vn, sunDir), 0.);\n    nDotL *= nDotL;\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    col4 = 0.2 * mix (vec4 (0.8, 0.7, 0.5, 0.), vec4 (0.9, 1., 0.5, 0.),\n       smoothstep (0.4, 0.6, Fbm2 (0.5 * ro.xz)));\n    vn = GrndNf (ro);\n    vn = VaryNf (0.5 * ro, vn, 1.5 * (1. - smoothstep (0.3, 0.7, dstGrnd / dstFar)));\n    nDotL = max (dot (vn, sunDir), 0.);\n  } else {\n    col = 0.3 * SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar || rd.y < 0.) {\n    if (col4.a >= 0.) {\n      sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, sunDir) : 1.;\n      col = col4.rgb * (0.2 + 0.1 * max (- dot (vn, sunDir), 0.) + 0.8 * sh * nDotL) +\n         col4.a * step (0.95, sh) * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 32.);\n    } else {\n      col = col4.rgb * (0.5 + 0.5 * max (- dot (vn, rd), 0.));\n    }\n  }\n  if (dstGrnd < min (dstObj, dstFar)) {\n    for (int j = VAR_ZERO; j < N_WLK; j ++) {\n      bmDir = wlk[j].ltPos - ro;\n      bmLen = length (bmDir);\n      bmDir = normalize (bmDir);\n      att = 5. * smoothstep (-0.001, 0.0001, - dot (wlk[j].bmAx, bmDir) - bmCs.x) *\n         step (- dot (vn, bmDir), 0.) / (1. + 0.0002 * bmLen * bmLen);\n      col += att * (col4.rgb * max (dot (vn, bmDir), 0.) +\n         col4.a * pow (max (dot (bmDir, reflect (rd, vn)), 0.), 32.));\n    }\n  }\n  if (rd.y < 0. && dstObj >= dstFar) col = mix (col, 0.3 * vec3 (0.3, 0.4, 0.5),\n     pow (1. + rd.y, 16.));\n  bmVal = BmVal (roo, rd, min (min (dstObj, dstGrnd), 4. * dstFar));\n  if (bmVal > 0.) col = mix (col, vec3 (1., 1., 0.9), 0.8 * bmVal);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  spd = 2.;\n  wPos = vec3 (0., 0.01, spd * tCur);\n  az = -0.3 * pi;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.02 * pi * tCur;\n  }\n  el = clamp (el, -0.35 * pi, -0.01 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = wPos + vuMat * vec3 (0., 3., -80.);\n  zmFac = 3.5 + 3. * abs (fract (az / (2. * pi)) - 0.5);\n  dstFar = 200.;\n  sunDir = vuMat * normalize (vec3 (0.5, 0.7, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcBzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[1156, 1156, 1176, 1176, 3037], [3039, 3039, 3084, 3084, 4909], [4911, 4911, 4933, 4933, 5232], [5234, 5234, 5267, 5267, 5515], [5517, 5517, 5538, 5538, 5793], [5795, 5795, 5832, 5832, 6075], [6077, 6077, 6111, 6111, 6874], [6876, 6876, 6899, 6899, 6935], [6937, 6937, 6959, 6959, 7103], [7105, 7105, 7188, 7188, 7717], [7719, 7719, 7765, 7765, 8550], [8552, 8552, 8587, 8587, 12052], [12054, 12054, 12110, 12110, 13267], [13269, 13269, 13315, 13315, 13362], [13364, 13364, 13411, 13411, 13458], [13460, 13460, 13502, 13502, 13553], [13555, 13555, 13599, 13599, 13659], [13661, 13661, 13706, 13706, 13798], [13800, 13800, 13845, 13845, 13883], [13885, 13885, 13942, 13942, 14025], [14027, 14027, 14063, 14063, 14269], [14271, 14271, 14301, 14301, 14414], [14416, 14416, 14447, 14447, 14511], [14545, 14545, 14569, 14569, 14622], [14624, 14624, 14648, 14648, 14760], [14762, 14762, 14787, 14787, 14933], [14935, 14935, 14960, 14960, 15146], [15148, 15148, 15170, 15170, 15324], [15326, 15326, 15347, 15347, 15502], [15504, 15504, 15533, 15533, 15745], [15747, 15747, 15786, 15786, 16043]], "test": "untested"}
{"id": "fd3Bzl", "name": "Mandelbrot Set - Benjyman", "author": "Benjyman", "description": "Mandelbrot Set", "tags": ["fractal", "mandelbrot"], "likes": 2, "viewed": 189, "published": 3, "date": "1657002289", "time_retrieved": "2024-07-30T16:41:36.722729", "image_code": "#define STEPS 1028\n\nconst vec2 zoom = vec2(.251, 0.00005);\n\nconst int numColors = 6;\n\n// Colors steps to blend between.\nconst vec3[numColors] colors = vec3[numColors](\n  vec3(1.,0.,0.),\n  vec3(1.,0.,1.),\n  vec3(0.,0.,1.),\n  vec3(0.,1.,1.),\n  vec3(0.,1.,0.),\n  vec3(1.,1.,0.)\n);\n\nvec2 sqr(vec2 z) {\n  return vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2.*uv - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float time = mod(iTime/2., 23.5);\n    float zoomFactor = pow(2., time);\n    uv /= zoomFactor;\n\n    vec2 z = vec2(0.);\n    vec2 c = uv + zoom;\n    \n    int steps = 0;\n    for (; dot(z,z) < 4. && steps < STEPS; ++steps) {\n      z = sqr(z) + c;\n    }\n    \n    vec3 col = vec3(0.);\n    if (steps < STEPS) {\n      float index = mod(log2(float(steps)), float(numColors));\n      col = mix(\n              colors[int(index)],\n              colors[int(mod(index+1., float(numColors)))],\n              fract(index));\n    }\n    \n    // Fade in the transition to the start\n    if (time < 2.) {\n      col = mix(vec3(0.), col, time/2.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3Bzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 279, 297, 297, 345], [347, 347, 401, 401, 1200]], "test": "untested"}
{"id": "7d3BRl", "name": "Ellipsoid - intersection", "author": "iq", "description": "Intersection of a ray and an ellipsoid.", "tags": ["3d", "raycast"], "likes": 26, "viewed": 1070, "published": 3, "date": "1657000800", "time_retrieved": "2024-07-30T16:41:37.519598", "image_code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Intersection of a ray and an ellipsoid.\n\n// List of ray-surface intersectors at \n//     https://www.shadertoy.com/playlist/l3dXRf\n// and\n//     https://iquilezles.org/articles/intersectors\n\nvec4 iEllipsoid( in vec3 ro, in vec3 rd, in vec3 r )\n{\n    vec3 r2 = r*r;\n    float a = dot( rd, rd/r2 );\n\tfloat b = dot( ro, rd/r2 );\n\tfloat c = dot( ro, ro/r2 );\n\tfloat h = b*b - a*(c-1.0);\n\tif( h<0.0 ) return vec4(-1.0);\n\tfloat t = (-b - sqrt( h ))/a;\n    vec3 n = normalize( (ro+t*rd)/r2 );\n    return vec4(t,n);\n}\n\nvec3 pattern( in vec2 uv )\n{\n    vec3 col = vec3(0.6);\n    col += 0.4*smoothstep(-0.01,0.01,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n#define AA 3\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 1.0*cos(an), 0.4, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // radius\n        vec3  ra = vec3(0.6,0.5,0.3);\n    \n        // raytrace\n        vec4 tnor = iEllipsoid( ro, rd, ra );\n\n        float t = tnor.x;\n    \n        // shading/lighting\t\n        vec3 col = vec3(0.08)*(1.0-0.3*length(p)) + 0.02*rd.y;\n        if( t>0.0 )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = tnor.yzw;\n\n            // material\n            col = pattern( vec2(16.0,64.0)*vec2(atan(pos.y,pos.z),pos.x) );\n\n            // lighting\n            vec3 lig = normalize(vec3(0.7,0.6,0.3));\n            vec3 hal = normalize(-rd+lig);\n\t\t    float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n\t\t    float amb = clamp( 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0 );\n            \n\t\t    col *= vec3(0.2,0.3,0.4)*amb + vec3(1.0,0.9,0.7)*dif;\n            col += 0.4*pow(clamp(dot(hal,nor),0.0,1.0),12.0)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // dither to remove banding in the background\n    tot += fract(sin(fragCoord.x*vec3(13,1,11)+fragCoord.y*vec3(1,7,5))*158.391832)/255.0;\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3BRl.jpg", "access": "api", "license": "mit", "functions": [[1272, 1272, 1326, 1326, 1590], [1592, 1592, 1620, 1620, 1810]], "test": "untested"}
{"id": "fdcBzs", "name": "Multi-scale mosaic", "author": "jarble", "description": "A fractal with several levels of magnification.", "tags": ["fractal", "mosaic"], "likes": 7, "viewed": 254, "published": 3, "date": "1656990888", "time_retrieved": "2024-07-30T16:41:38.476041", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 2.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64./2.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    float s1 = 1.;\n    for(int k = 0; k < 6; k++){\n        uv += t2;\n        uv /= -scale;\n        float s1 = sign(uv.x);\n        uv.x += s1/2.;\n        uv *= s1;\n        t2 = -triangle_wave(uv-.5);\n        t3 = triangle_wave(uv.yx);\n        uv = t2-t3/(.5-s1);\n        col.x = 1.+max(uv.y-uv.x,col.x/2.);\n        col = abs(col.yzx+vec3(1.-col.x)*2.);\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcBzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 829]], "test": "untested"}
{"id": "Nd3BRs", "name": "stair lift", "author": "jorge2017a2", "description": "stair lift", "tags": ["stairlift"], "likes": 6, "viewed": 196, "published": 3, "date": "1656983349", "time_retrieved": "2024-07-30T16:41:39.309811", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//basic stair lift\n//referencia\n///https://iquilezles.org/\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdStairs( in vec2 p, in vec2 wh, in float n )\n{\n    // base\n    vec2 ba = wh*n;\n    float d = min(dot2(p-vec2(clamp(p.x,0.0,ba.x),0.0)), \n                  dot2(p-vec2(ba.x,clamp(p.y,0.0,ba.y))) );\n    float s = sign(max(-p.y,p.x-ba.x) );\n\n    // steps repetition\n#if 1\n    float dia = length(wh);\n    p = mat2(wh.x,-wh.y, wh.y,wh.x)*p/dia;\n    float lid = clamp(round(p.x/dia),0.0,n-1.0);\n    p.x = p.x - lid*dia;\n    p = mat2(wh.x, wh.y,-wh.y,wh.x)*p/dia;\n#else\n    float dia2 = dot(wh,wh);\n    p = mat2(wh.x,-wh.y,wh.y,wh.x)*p;\n    float lid = clamp(round(p.x/dia2),0.0,n-1.0);\n    p.x = p.x - lid*dia2;\n    p = mat2(wh.x,wh.y,-wh.y,wh.x)*p/dia2;\n#endif    \n\n    // single step\n    float hh = wh.y/2.0;\n    p.y -= hh;\n    \n    if( p.y>hh*sign(p.x) ) s=1.0;\n    p = (lid<0.5 || p.x>0.0) ? p : -p;\n\n    d = min( d, dot2(p-vec2(0.0,clamp(p.y,-hh,hh))) );\n    d = min( d, dot2(p-vec2(clamp(p.x,0.0,wh.x),hh)) );\n    \n    return sqrt(d)*s;\n}\n\nfloat opScaleEscalera( in vec3 p )\n{   float s=0.125;\n    return sdStairs(p.xy/s, vec2(10.0,10.0), 10.0 )*s;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p= rotate_x(p, radians(90.0));\n    p.y=p.y+15.0;  //si\n    \n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    //cuadro\n    float d01= sdBox(p-vec3(1.0,30.0,-9.0), vec3(14.5,40.0,14.0) );\n    float d02= sdBox(p-vec3(1.0,30.0,-9.0), vec3(13.5,41.0,13.0) );\n    float d03= sdBox(p-vec3(0.0,-12.0,-8.0), vec3(16.0,1.0,16.0) );\n    d01= Difference(d01, d02);\n    res =opU2(res, vec2(d01,1.0));\n    res =opU2(res, vec2(d03,8.0));\n    \n    float aEs=3.0;\n    float mvx=1.0;\n    \n     //0 escalon\n    //p.xyz=vec3(-p0.z,p0.y,p0.x);\n    p.xyz=vec3(p0.z,p0.y,p0.x);\n    p.y+=13.5;\n    p.x+=9.0+mvx/2.0;\n    p.z+=8.0+mvx;\n    float d1f=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2f= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3f= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1f= Intersect(d1f, d2f);\n    d1f= Union(d1f, d3f);\n    res =opU2(res, vec2(d1f,100.0));\n    \n    //primer escalon\n    p.xyz=vec3(p0.x,p0.y,p0.z);\n    float d1a=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2a= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3a= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1a= Intersect(d1a, d2a);\n    d1a= Union(d1a, d3a);\n    res =opU2(res, vec2(d1a,100.0));\n    \n    //2do escalon\n    p.xyz=vec3(-p0.z,p0.y,p0.x);\n    p.y-=13.5;\n    p.x-=8.0+mvx;\n    p.z-=8.5+mvx;\n    float d1b=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2b= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3b= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1b= Intersect(d1b, d2b);\n    d1b= Union(d1b, d3b);\n    res =opU2(res, vec2(d1b,100.0));\n    \n    \n    //tercero escalon\n    //p.xyz=vec3(-p0.z,p0.y,p0.x);\n    p.xyz=vec3(-p0.x,p0.y,p0.z);\n    p.y-=27.0;\n    p.x+=0.5;\n    p.z+=17.0+mvx+mvx/2.0;\n    float d1c=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2c= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3c= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1c= Intersect(d1c, d2c);\n    d1c= Union(d1c, d3c);\n    res =opU2(res, vec2(d1c,100.0));\n    \n    //4to ultimo\n    p.xyz=vec3(p0.z,p0.y,p0.x);\n    p.y-=40.5;\n    p.x+=9.0+mvx/2.0;\n    p.z+=8.0+mvx;\n    float d1d=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2d= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3d= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1d= Intersect(d1d, d2d);\n    d1d= Union(d1d, d3d);\n    res =opU2(res, vec2(d1d,100.0));\n    \n    //5 escalon //repetir\n    p.xyz=vec3(p0.x,p0.y,p0.z);\n    p.y-=54.0;\n    float d1e=opScaleEscalera( p-vec3(-6.0,5.0,0.0));\n    float d2e= sdBox(p-vec3(0.0,15.0,0.0), vec3(10.0,10.0,aEs) );\n    float d3e= sdBox(p-vec3(8.5+mvx,18.0,0.0), vec3(aEs,0.5,aEs) );\n    d1e= Intersect(d1e, d2e);\n    d1e= Union(d1e, d3e);\n    res =opU2(res, vec2(d1e,100.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 pallete(float t) {\n    vec3 a = vec3(0.2);\n    vec3 b = vec3(0.5);\n    vec3 c = vec3(1.0);\n    vec3 d = vec3(0.0, 0.33, 0.67);\n    return a + b * cos(6.28318 * (c*t + d));\n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tvec3 col;\n    if (i==100 ){ col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n    //if (i==101 ){ col=tex3D(iChannel1, p/32., nor)*vec3(0.85); return col*2.0; }\n    //if (i==102 ){ col=tex3D(iChannel1, p/32., nor)*vec3(1.0,0.5,1.0); return col*2.0; }\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{   if(id_color==0)  { return vec3(0.,0.,0.);}\n    if(id_color==1)  { return  vec3(1.,1.,1.);}\n    if(id_color==8)  { return  vec3(0.7529,0.7529,0.7529);}\n    if(id_color>=100){ return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        \n        \n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*5.0,80.0);\n \tlight_pos1= vec3(0.0,  50.0, 0.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, -50.0, -30.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,-7.0,-70.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   \n   //rd= rotate_z(rd, radians(90.0));\n   \n   \n   //light_pos1+=ro;\n   //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3BRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 553, 553, 637], [639, 639, 675, 675, 720], [722, 722, 766, 766, 793], [794, 794, 834, 834, 861], [862, 862, 907, 907, 935], [938, 938, 972, 972, 1068], [1069, 1069, 1103, 1103, 1194], [1195, 1195, 1229, 1229, 1320], [1322, 1322, 1347, 1347, 1366], [1367, 1367, 1392, 1392, 1411], [1412, 1412, 1448, 1448, 1476], [1479, 1479, 1532, 1544, 2424], [2426, 2426, 2462, 2462, 2536], [2539, 2539, 2564, 2564, 5433], [5435, 5435, 5459, 5459, 5621], [5623, 5623, 5671, 5671, 5950], [5953, 5953, 5997, 5997, 6318], [6320, 6320, 6357, 6357, 6614], [6616, 6616, 6639, 6639, 6794], [6796, 6796, 6886, 6886, 7845], [7847, 7847, 7896, 7896, 8151], [8153, 8153, 8223, 8223, 8453], [8455, 8455, 8482, 8482, 8571], [8573, 8573, 8631, 8631, 8679], [8681, 8681, 8704, 8704, 8816], [8818, 8818, 8849, 8849, 9429], [9431, 9431, 9488, 9488, 9966]], "test": "untested"}
{"id": "Nd3BRl", "name": "Sliding Tiles", "author": "mla", "description": "Just some sliding tiles. Picture reassembles after 840n+1 seconds, though the colouring is different.\n\n'g': show grid.", "tags": ["tiles", "sliding"], "likes": 10, "viewed": 318, "published": 3, "date": "1656972175", "time_retrieved": "2024-07-30T16:41:40.068782", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Sliding Tiles, mla 2022\n//\n// Checking the tile indexing works properly.\n//\n////////////////////////////////////////////////////////////////////////////////\n\nbool even(int n) { return (n&1) == 0; }\nbool odd(int n) { return !even(n); }\n\nivec2 getindex(int t, vec2 uv) {\n  // Calculate which tile appears at point uv at time t.\n  // Other patterns should be possible.\n  ivec2 ix = ivec2(floor(uv));\n  if (odd(ix.x) && odd(ix.y)) return ix; // Stationary tiles\n  ix -= t/6*2; // Tiles move 2 every 6 cycles\n  t %= 6;\n  for ( ; t != 0; t--) {\n    // A neat recurrence. Maybe this could be simplified.\n    if (even(t)) {\n      if (even(ix.x)) ix.y--;\n    } else {\n      if (even(ix.y)) ix.x--;\n    }\n  }\n  return ix;\n}\n\nvec3 slider(vec2 uv) {\n  float scale = 4.0;\n  uv *= scale;\n  vec2 uv0 = uv;\n  float px = fwidth(uv.x);\n  float t = 0.5*max(0.0,iTime-1.0);\n  int cycle = int(t);\n  t = fract(t);\n  if (even(cycle)) {\n    if (mod(uv.y,2.0) < 1.0) {\n      uv.x -= t;\n    }\n  } else {\n    if (mod(uv.x,2.0) < 1.0) {\n      uv.y -= t;\n    }\n  }\n  ivec2 ix = getindex(cycle, uv);\n  float tscale = 0.5/scale;\n  vec2 tuv = tscale*(vec2(ix)+fract(uv));\n  tuv.x /= 1.5; // Fix aspect ratio for \"London\" scene\n  tuv += 0.5;\n  tuv = mod(tuv,2.0);\n  tuv = min(tuv,2.0-tuv);\n  vec3 col = textureGrad(iChannel0,tuv,tscale*dFdx(uv0),tscale*dFdy(uv0)).rgb;\n  col = pow(col,vec3(2.2));\n  uint h = ihash(uint(ix.x*1024+ix.y));\n  col *= 0.5+0.5*h2rgb(float(h)/exp2(32.0));\n  if (!key(CHAR_G)) {\n    uv = fract(uv);\n    uv = min(uv,1.0-uv);\n    float d = min(uv.x,uv.y);\n    col = mix(vec3(0),col,smoothstep(0.0,px,d-0.015));\n  }\n  col = 2.0*col/(1.0+col);\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  vec3 col = slider(uv);\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nvec3 h2rgb(float h) {\n  vec3 rgb = clamp( abs(mod(h*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = smoothstep(0.0,1.0,rgb);\n  return rgb;\n}\n\n// const int KEY_ALT = 18;\n// const int KEY_PAGE_UP = 33;\n// const int KEY_PAGE_DOWN = 34;\n// const int KEY_LEFT = 37;\n// const int KEY_RIGHT = 39;\n// const int KEY_UP = 38;\n// const int KEY_DOWN = 40;\n\n// const int CHAR_0 = 48;\n\n// const int CHAR_A = 65;\n// const int CHAR_B = 66;\n// const int CHAR_C = 67;\n// const int CHAR_D = 68;\n// const int CHAR_E = 69;\n// const int CHAR_F = 70;\nconst int CHAR_G = 71;\n// const int CHAR_H = 72;\n// const int CHAR_I = 73;\n// const int CHAR_J = 74;\n// const int CHAR_K = 75;\n// const int CHAR_L = 76;\n// const int CHAR_M = 77;\n// const int CHAR_N = 78;\n// const int CHAR_O = 79;\n// const int CHAR_P = 80;\n// const int CHAR_Q = 81;\n// const int CHAR_R = 82;\n// const int CHAR_S = 83;\n// const int CHAR_T = 84;\n// const int CHAR_U = 85;\n// const int CHAR_V = 86;\n// const int CHAR_W = 87;\n// const int CHAR_X = 88;\n// const int CHAR_Y = 89;\n// const int CHAR_Z = 90;\n\n#if !defined(key)\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#endif\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(code) (int(store((code),0).x))\n#define keystate(code,n) ( texelFetch(iChannel3,ivec2(code,n),0) )", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3BRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[245, 245, 263, 263, 284], [285, 285, 302, 302, 321], [323, 323, 355, 452, 800], [802, 802, 824, 824, 1734], [1736, 1736, 1793, 1793, 1938]], "test": "untested"}
{"id": "fdtfRX", "name": "Fancy Circle", "author": "Zyphery", "description": "It's a fancy circle", "tags": ["hue", "rainbowcircle"], "likes": 1, "viewed": 216, "published": 3, "date": "1656962833", "time_retrieved": "2024-07-30T16:41:40.885598", "image_code": "#define PI 3.14159\n#define TWO_PI 6.28318\n#define HALF_PI 1.57079\n\nvec3 hue(float val) {\n    vec3 col;\n    float h = mod(val, 1.0);\n    float X = -abs(6.0 * mod(h, 1.0 / 3.0) - 1.0) + 1.0;\n    \n    if(h < 1.0 / 6.0)\n        col = vec3(1.0,X,0.0);\n    else if(h < 2.0 / 6.0)\n        col = vec3(X,1.0,0.0);\n    else if(h < 3.0 / 6.0)\n        col = vec3(0.0,1.0,X);\n    else if(h < 4.0 / 6.0)\n        col = vec3(0.0,X,1.0);\n    else if(h < 5.0 / 6.0)\n        col = vec3(X,0.0,1.0);\n    else\n        col = vec3(1.0,0.0,X);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord;\n    \n\n    float dist = distance(uv, iMouse.xy);\n    \n    float feather = 2.;\n    float inside = 45.;\n    float outside = 50.;\n    \n    vec3 col = vec3((\n    // inner circle\n    (1.0f - smoothstep(inside, inside - feather, dist))*\n    // outer circle\n    smoothstep(outside, outside - feather, dist)))*\n    // colour :)\n    hue(mod(iTime / 3.0f + ((atan(uv.y - iMouse.y, uv.x - iMouse.x) + PI) / TWO_PI), 1.0f));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 88, 88, 541], [543, 543, 600, 600, 1075]], "test": "untested"}
{"id": "7dtfRf", "name": "Knots and Stars", "author": "jarble", "description": "A fractal with star patterns.", "tags": ["fractal", "star", "knot"], "likes": 7, "viewed": 262, "published": 3, "date": "1656959394", "time_retrieved": "2024-07-30T16:41:41.649556", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.*8.*4.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    for(int k = 0; k < 12; k++){\n        uv += t2;\n        uv /= scale;\n        uv.x += sign(uv.x)/2.;\n        t2 = triangle_wave(uv-.5);\n        t3 = -triangle_wave(uv.yx+1.);\n        uv = t2-t3;\n        col.x = max(uv.y-uv.x,col.x/2.);\n        //col.x = abs(.5-col.x);\n        col = abs(col.yzx-vec3(col.x)*2.);\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 79, 136, 136, 797]], "test": "untested"}
{"id": "sdtBRf", "name": "004 - Windy Japan flag", "author": "PiGIon", "description": "Today I found a way to create a circle from the coordinates. It just checks the distance between the vec2 pixel from the origin. If the distance is below a range, paint it with Japan flag red. The wobbling is made affecting the uv space.", "tags": ["beginner", "sin", "circle", "cos", "learning", "japan"], "likes": 1, "viewed": 237, "published": 3, "date": "1656955373", "time_retrieved": "2024-07-30T16:41:42.402543", "image_code": "// 2022.07.04 rev 1\n// 2022.07.05 rev 2 - did improvements that FabriceNeyret2 suggested. learned simple antialias :). some refactors.\n// 2022.07.07 rev 3 - small changes in the cycle function and antialias improve\n\n#define PI 3.14159265\n#define TWOPI 6.2831853\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n    float d = fract((iTime + iTimeDelta) * perSecond);\n    \n    // step 0.5 is used to reverse the keyframe, to get a coming and going effect\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    return 2. * ( d>.5 ? 1.-d : d );\n}\n\n// returns a constant cycle instead of comming and going from cycle function\n// ______________________________________________\n// | iTime | perSecond | range     |   return   |\n// |_______|___________|___________|____________|\n// |0.1    |0.5        |10         |2.5         |\n// |3.4    |0.5        |10         |17          |\n// |_______|___________|___________|____________|\n//\n// doing a sin() with the return allows you to \"skew through the range\" seamlessly \nfloat constCycle(float perSecond, float range) {\n    return ((iTime + iTimeDelta) * perSecond) * range;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv.x += (cos(uv.y * 10.0 + (constCycle(0.3, -12.0)))/150.0) - ((cycle(0.07) * 0.1)-0.05);\n    uv.y += (sin(uv.x * 10.0 + (constCycle(0.5, -12.0)))/175.0) - ((cycle(0.03) * 0.1)-0.05);\n    \n    float antiAlias = 1.5/iResolution.y; // the larger the screen, the subtle is the antialias\n    \n    vec3 c;\n\n    vec3 japanRed = vec3(0.73, 0.0, 0.01);\n    vec3 waves = vec3(min(\n            245.0, \n            255.0 * abs(sin(uv.y * 15.0 + (constCycle(0.25, 1.0)))/5000.0) + 0.94\n        ));\n    \n    c = mix(\n        japanRed, \n        waves,\n        smoothstep(0.5 - antiAlias, 0.5 + antiAlias, length(uv))\n    );\n\n    fragColor = vec4(\n        c, \n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 380, 410, 1440, 1791], [1793, 2257, 2305, 2305, 2362], [2365, 2365, 2422, 2422, 3160]], "test": "untested"}
{"id": "sdtBzX", "name": "RayMarching - Cube", "author": "FabulousCodingFox", "description": "By https://github.com/FabulousCodingFox", "tags": ["raymarching"], "likes": 1, "viewed": 61, "published": 3, "date": "1656951600", "time_retrieved": "2024-07-30T16:41:43.200409", "image_code": "#define MAX_DISTANCE 100.\n#define SURFACE_DISTANCE .01\n\n////////////////////////////////////////////////////////////////\n\n#define OBJECT Object(vec3(0, 1, 6), 1.)\n\nstruct Object{\n    vec3 pos;\n    float side;\n};\n\nfloat dist(vec3 pos, Object obj){\n    vec3 q = abs(pos-obj.pos) - vec3(obj.side);\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat getDistance(vec3 position){\n    return min(position.y, dist(position, OBJECT));\n}\n\nstruct Ray{\n    vec3 origin, direction;\n};\n\nvec4 rayMarch(Ray ray){\n\tfloat distanceFromOrigin=0.;\n    while(true){\n    \tvec3 position = ray.origin + ray.direction * distanceFromOrigin;\n        float dist = getDistance(position);\n        distanceFromOrigin += dist;\n        if(distanceFromOrigin>MAX_DISTANCE || dist<SURFACE_DISTANCE) break;\n    }\n    return vec4(ray.origin + ray.direction * distanceFromOrigin, distanceFromOrigin);\n}\n\nvec3 getNormal(vec3 position){\n\tfloat dist = getDistance(position);\n    vec2 e = vec2(.01, 0);\n    vec3 normal = dist - vec3(\n        getDistance(position-e.xyy),\n        getDistance(position-e.yxy),\n        getDistance(position-e.yyx));\n    return normalize(normal);\n}\n\nfloat getLight(vec3 position){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 light = normalize(lightPos-position);\n    vec3 normal = getNormal(position);\n    float dif = clamp(dot(normal, light), 0., 1.);\n    vec4 dist = rayMarch(Ray(position+normal*SURFACE_DISTANCE*2., light));\n    if(dist.w<length(lightPos-position)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    Ray ray = Ray(vec3(0, 1, 0), normalize(vec3(uv.x, uv.y, 1)));\n    vec4 result = rayMarch(ray);\n    float dif = getLight(result.xyz);\n    vec3 col = vec3(dif);\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtBzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[213, 213, 246, 246, 360], [428, 428, 461, 461, 515], [561, 561, 584, 584, 951], [953, 953, 983, 983, 1222], [1224, 1224, 1254, 1254, 1623], [1625, 1625, 1681, 1681, 1969]], "test": "untested"}
{"id": "7sdfRX", "name": "RayMarching - Sphere", "author": "FabulousCodingFox", "description": "By https://github.com/FabulousCodingFox", "tags": ["raymarching"], "likes": 0, "viewed": 41, "published": 3, "date": "1656951248", "time_retrieved": "2024-07-30T16:41:44.027199", "image_code": "#define MAX_DISTANCE 100.\n#define SURFACE_DISTANCE .01\n\n////////////////////////////////////////////////////////////////\n\n#define OBJECT Object(vec3(0, 1, 6), 1.)\n\nstruct Object{\n    vec3 pos;\n    float radius;\n};\n\nfloat dist(vec3 pos, Object obj){\n    return length(pos-obj.pos)-obj.radius;\n}\n\n////////////////////////////////////////////////////////////////\n\nfloat getDistance(vec3 position){\n    return min(position.y, dist(position, OBJECT));\n}\n\nstruct Ray{\n    vec3 origin, direction;\n};\n\nvec4 rayMarch(Ray ray){\n\tfloat distanceFromOrigin=0.;\n    while(true){\n    \tvec3 position = ray.origin + ray.direction * distanceFromOrigin;\n        float dist = getDistance(position);\n        distanceFromOrigin += dist;\n        if(distanceFromOrigin>MAX_DISTANCE || dist<SURFACE_DISTANCE) break;\n    }\n    return vec4(ray.origin + ray.direction * distanceFromOrigin, distanceFromOrigin);\n}\n\nvec3 getNormal(vec3 position){\n\tfloat dist = getDistance(position);\n    vec2 e = vec2(.01, 0);\n    vec3 normal = dist - vec3(\n        getDistance(position-e.xyy),\n        getDistance(position-e.yxy),\n        getDistance(position-e.yyx));\n    return normalize(normal);\n}\n\nfloat getLight(vec3 position){\n    vec3 lightPos = vec3(0, 5, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 light = normalize(lightPos-position);\n    vec3 normal = getNormal(position);\n    float dif = clamp(dot(normal, light), 0., 1.);\n    vec4 dist = rayMarch(Ray(position+normal*SURFACE_DISTANCE*2., light));\n    if(dist.w<length(lightPos-position)) dif *= .1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    Ray ray = Ray(vec3(0, 1, 0), normalize(vec3(uv.x, uv.y, 1)));\n    vec4 result = rayMarch(ray);\n    float dif = getLight(result.xyz);\n    vec3 col = vec3(dif);\n    col = pow(col, vec3(.4545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[215, 215, 248, 248, 293], [361, 361, 394, 394, 448], [494, 494, 517, 517, 884], [886, 886, 916, 916, 1155], [1157, 1157, 1187, 1187, 1556], [1558, 1558, 1614, 1614, 1902]], "test": "untested"}
{"id": "fstBRf", "name": "Colourspace Torus", "author": "mla", "description": "Map uv coordinates to points on a torus in RGB space (with mirrored repeats in all directions).\n\nMouse changes orientation of torus.", "tags": ["torus", "colorspace", "colourspace"], "likes": 6, "viewed": 295, "published": 3, "date": "1656946193", "time_retrieved": "2024-07-30T16:41:46.042809", "image_code": "/////////////////////////////////////////////////////////////////////\n//\n// Colourspace Torus, mla, 2022\n//\n// Map uv coordinates to points on a torus in RGB space (with \n// mirrored repeats in all directions).\n//\n// Since it's a torus, colours wrap around smoothly at top and bottom,\n// and at left and right.\n//\n// Mouse changes orientation of torus.\n//\n/////////////////////////////////////////////////////////////////////\n\nvec3 map(vec2 uv) {\n  // uv in range [-1,1]\n  float lambda = PI*uv.x;\n  float phi = PI*uv.y;\n  float r = 2.0;\n  float R = 1.0;\n  vec3 p = vec3(vec2(R,0)+rotate(vec2(r,0),lambda),0);\n  p.xz = rotate(p.xz,phi);\n  return 0.2*p; // Scale\n}\n\n// Based on http://www.oscars.org/science-technology/sci-tech-projects/aces\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n    return m2*(a/b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n    vec2 uv0 = uv;\n    uv.y += 0.1618*iTime;\n    vec2 mouse = (2.0*iMouse.xy-iResolution.xy)/iResolution.xy;\n    vec3 p = normalize(vec3(1,1,1));\n    p.xy = rotate(p.xy,PI*mouse.x);\n    p.yz = rotate(p.yz,PI*mouse.y);\n    vec3 q = cross(p,vec3(0,0,1));\n    vec3 r = cross(p,q);\n    vec3 col = mat3(p,q,r)*map(uv);\n    col += 0.5*iTime*p;\n    // Mod and mirror\n    col = mod(col,2.0);\n    col = min(col,2.0-col);\n    col = smoothstep(0.0,1.0,col);\n    col *= 0.9+0.1*texture(iChannel0,uv0).x;\n    col = aces_tonemap(2.0*col);\n    col = clamp(col,0.0,1.0);\n    col = pow(col,vec3(0.4545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float PI = 3.14159;\n\n// Rotate vector p by angle t.\nvec2 rotate(vec2 p, float t) {\n  return cos(t)*p + sin(t)*vec2(-p.y,p.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstBRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 427, 446, 470, 662], [664, 740, 770, 770, 1176], [1178, 1178, 1235, 1235, 1917]], "test": "untested"}
{"id": "7d3fRf", "name": "im not sure what this is 917328", "author": "SnoopethDuckDuck", "description": "its quite dizzying tbh", "tags": ["e"], "likes": 8, "viewed": 307, "published": 3, "date": "1656936262", "time_retrieved": "2024-07-30T16:41:46.885556", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n// RayMarching code stolen from TheArtOfCode\n\n// Stolen from BlackleMori\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(80. - 70. * tanh(0.75 * iTime * iTime), 5. * thc(1., 0.81 * iTime), 5. * ths(1., iTime));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n  //  p.x += 1.;\n    p.y += 0.25 * thc(5., 1.25 * length(p) - iTime);;\n    p.x += 0.5 * cos(0.5 * p.y + iTime);\n    float y = fract(p.y) - 0.5;\n    float d = length(vec2(p.x, y)) - 0.25 + 0.25 * thc(1., 4. * abs(p.z));//sdBox(p, vec3(1.)) - 0.1;\n    \n    float y2 = fract(p.y + 0.5) - 0.5;\n    float d2 = length(vec2(p.x, y2)) - 0.25 + 0.25 * thc(1., 4. * abs(p.z) + pi);\n    \n    d = min(d, d2);\n    \n    return 0.75 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvec3 bg(vec3 rd, vec3 p) {\n    return 0.5 + 0.5 * thc(4., 0.5 *length(p) + 0.125 * pi * h21(p.xz) + rd.y - 0.5 *  iTime) * vec3(1);//abs(rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.5 + 0.75 * thc(4., 0.25 * log(length(uv)) - 0.5 * iTime));\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    \n    if(d<MAX_DIST) {        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);// * pal(length(p) *10., vec3(0,1,2)/3.);;\n        \n        float pw = 5.;\n        float fres = 1.-pow(abs(1.25 + 0.25 * cos(10. * p.y + iTime) +dot(rd, -n)), pw);\n        float fres2 = pow(abs(0.+dot(rdIn, rd)), 100.);\n        \n        vec3 fog = vec3(1.-exp(-0.3 * dIn));\n        //col *= 0.5 + 0.5 * n.y;\n        col += mix(vec3(0.25), pal(0.1 * iTime - length(p) * 0.15, vec3(0,1,2)/3.), cos(fres * 0.025) * 0.5 + 0.5);\n        col = mix(vec3(1), col, 0.5 + 0.5 * thc(2., length(p.yz) * pi / 8.));\n        col *= pal(0.1 * iTime - length(p) * 0.15, vec3(0,1,2)/3.);\n        col = mix(bg(rd, p), col, 1. / cosh(0.5 * length(p)));\n        \n    } else {\n        col = bg(rd, p);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\n// Stolen from iq, k = 0.12 is good\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) - k * h * (1. - h);\n}\n\nfloat smax(float a, float b, float k) {\n    float h = clamp(0.5 - 0.5 * (b - a) / k, 0., 1.);\n    return mix(b, a, h) + k * h * (1. - h); \n}\n    \n    \n    ", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[196, 196, 226, 226, 302], [304, 304, 342, 342, 407], [409, 409, 428, 428, 511], [513, 513, 542, 542, 623], [625, 625, 639, 639, 872], [874, 874, 897, 914, 1322], [1324, 1324, 1367, 1367, 1674], [1676, 1676, 1700, 1700, 1890], [1892, 1892, 1942, 1942, 2133], [2135, 2135, 2161, 2161, 2278], [2280, 2280, 2337, 2337, 3837]], "test": "untested"}
{"id": "NdcBzf", "name": "Dungeon Generator", "author": "detectiveLosos", "description": "I originally created this shader on my android phone using a free and amazing shader editor app.\nDecided to port it to shadertoy to share the code.\nIt is still quite messy, but hopefully one day I'll go back and clean it up.", "tags": ["procedural", "map", "generator", "dungeon", "dnd"], "likes": 45, "viewed": 713, "published": 3, "date": "1656929772", "time_retrieved": "2024-07-30T16:41:47.836015", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M_PI 3.14159265359\n\nconst float eps = 0.01;\nbool approx(float a, float b){return abs(a-b)<eps;}\nbool approx(vec2 a, vec2 b){ return approx(a.x, b.x) && approx(a.y, b.y); }\n\n#define btof(b) ((b)?1.0:0.0)\n\n#define pack(x) (x*0.5+0.5)\n#define unpack(x) (x*2.0 - 1.0)\n\n#define saturate(x) (clamp(x, 0.0, 1.0))\n\n\nfloat hash1(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n\n\n\n//==== Optimized Ashima Simplex noise2D by @makio64 https://www.shadertoy.com/view/4sdGD8 ====//\n// Original shader : https://github.com/ashima/webgl-noise/blob/master/src/noise2D.glsl\n// snoise return a value between 0 & 1\nvec4 glslmod(vec4 x, vec4 y) { return x - y * floor(x / y); }\nvec3 glslmod(vec3 x, vec3 y) { return x - y * floor(x / y); }\nvec2 glslmod(vec2 x, vec2 y) { return x - y * floor(x / y); }\nvec3 permute_optimizedSnoise2D(in vec3 x) { return glslmod(x*x*34.0 + x, vec3(289.0)); }\nfloat optimizedSnoise(in vec2 v) {\n\tvec2 i = floor((v.x + v.y)*.36602540378443 + v);\n\tvec2 x0 = (i.x + i.y)*.211324865405187 + v - i;\n\tfloat s = step(x0.x, x0.y);\n\tvec2 j = vec2(1.0 - s, s);\n\tvec2 x1 = x0 - j + .211324865405187;\n\tvec2 x3 = x0 - .577350269189626;\n\ti = glslmod(i, vec2(289.));\n\tvec3 p = permute_optimizedSnoise2D(permute_optimizedSnoise2D(i.y + vec3(0, j.y, 1)) + i.x + vec3(0, j.x, 1));\n\tvec3 m = max(.5 - vec3(dot(x0, x0), dot(x1, x1), dot(x3, x3)), 0.);\n\tvec3 x = fract(p * .024390243902439) * 2. - 1.;\n\tvec3 h = abs(x) - .5;\n\tvec3 a0 = x - floor(x + .5);\n\treturn .5 + 65. * dot(pow(m, vec3(4.0))*(-0.85373472095314*(a0*a0 + h * h) + 1.79284291400159), a0 * vec3(x0.x, x1.x, x3.x) + h * vec3(x0.y, x1.y, x3.y));\n}\n\n//==== Optimized AshimaSimplexNoise by @makio64 https://www.shadertoy.com/view/Xd3GRf ====//\n// Original : https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec4 permute_optimizedSnoise3D(in vec4 x) { return glslmod(x*x*34. + x, vec4(289.)); }\nfloat optimizedSnoise(in vec3 v) {\n\tconst vec2 C = vec2(0.16666666666, 0.33333333333);\n\tconst vec4 D = vec4(0, .5, 1, 2);\n\tvec3 i = floor(C.y*(v.x + v.y + v.z) + v);\n\tvec3 x0 = C.x*(i.x + i.y + i.z) + (v - i);\n\tvec3 g = step(x0.yzx, x0);\n\tvec3 l = (1. - g).zxy;\n\tvec3 i1 = min(g, l);\n\tvec3 i2 = max(g, l);\n\tvec3 x1 = x0 - i1 + C.x;\n\tvec3 x2 = x0 - i2 + C.y;\n\tvec3 x3 = x0 - D.yyy;\n\ti = glslmod(i, vec3(289.));\n\tvec4 p = permute_optimizedSnoise3D(permute_optimizedSnoise3D(permute_optimizedSnoise3D(\n\t\ti.z + vec4(0., i1.z, i2.z, 1.))\n\t\t+ i.y + vec4(0., i1.y, i2.y, 1.))\n\t\t+ i.x + vec4(0., i1.x, i2.x, 1.));\n\tvec3 ns = .142857142857 * D.wyz - D.xzx;\n\tvec4 j = -49. * floor(p * ns.z * ns.z) + p;\n\tvec4 x_ = floor(j * ns.z);\n\tvec4 x = x_ * ns.x + ns.yyyy;\n\tvec4 y = floor(j - 7. * x_) * ns.x + ns.yyyy;\n\tvec4 h = 1. - abs(x) - abs(y);\n\tvec4 b0 = vec4(x.xy, y.xy);\n\tvec4 b1 = vec4(x.zw, y.zw);\n\tvec4 sh = -step(h, vec4(0));\n\tvec4 a0 = b0.xzyw + (floor(b0)*2. + 1.).xzyw*sh.xxyy;\n\tvec4 a1 = b1.xzyw + (floor(b1)*2. + 1.).xzyw*sh.zzww;\n\tvec3 p0 = vec3(a0.xy, h.x);\n\tvec3 p1 = vec3(a0.zw, h.y);\n\tvec3 p2 = vec3(a1.xy, h.z);\n\tvec3 p3 = vec3(a1.zw, h.w);\n\tvec4 norm = 1.0/sqrt(vec4(dot(p0, p0), dot(p1, p1), dot(p2, p2), dot(p3, p3)));\n\tp0 *= norm.x;\n\tp1 *= norm.y;\n\tp2 *= norm.z;\n\tp3 *= norm.w;\n\tvec4 m = max(.6 - vec4(dot(x0, x0), dot(x1, x1), dot(x2, x2), dot(x3, x3)), 0.);\n\treturn .5 + 12. * dot(m * m * m, vec4(dot(p0, x0), dot(p1, x1), dot(p2, x2), dot(p3, x3)));\n}\n//", "buffer_a_code": "// Directions.\nconst ivec2 center = ivec2(0, 0);\nconst ivec2 up = ivec2(0, 1);\nconst ivec2 down = ivec2(0, -1);\nconst ivec2 right = ivec2(1, 0);\nconst ivec2 left = ivec2(-1, 0);\nconst ivec2 upRight = up + right;\nconst ivec2 upLeft = up + left;\nconst ivec2 downRight = down + right;\nconst ivec2 downLeft = down + left;\n\n// Packed versions of directions.\nconst vec2 pCenter = vec2(0.5, 0.5);\nconst vec2 pUp = vec2(0.5, 1.0);\nconst vec2 pDown = vec2(0.5, 0.0);\nconst vec2 pRight = vec2(1.0, 0.5);\nconst vec2 pLeft = vec2(0.0, 0.5);\nconst vec2 pUpRight = vec2(1.0, 1.0);\nconst vec2 pUpLeft = vec2(0.0, 1.0);\nconst vec2 pDownRight = vec2(1.0, 0.0);\nconst vec2 pDownLeft = vec2(0.0, 0.0);\n\n\n// How much the actual pixeled version of the dungeon is scaled from the base image size.\nconst float scaleDown = 12.0;\nbool isScaledDown(vec2 pos)\n{\n\treturn\n\t\t(pos.x < iResolution.x / scaleDown) &&\n\t\t(pos.y < iResolution.y / scaleDown);\n}\n\n\nbool isOnBorder(vec2 pos)\n{\n\treturn\n\t\t(pos.x < 1.0) ||\n\t\t(pos.x > iResolution.x / scaleDown - 1.5) ||\n\t\t(pos.y < 1.0) ||\n\t\t(pos.y > iResolution.y / scaleDown - 1.5);\n}\n\nbool is(vec4 cell)\n{\n\treturn cell.z > 0.1;\n}\n\n\n\nvec4 get(vec2 offset) { return texture(iChannel0, (gl_FragCoord.xy + offset) / iResolution.xy); }\nvec4 get(float x, float y){return get(vec2(x, y));}\nvec4 get(int x, int y){return get(vec2(x, y));}\nvec4 get(ivec2 offset){return get(vec2(offset));}\n\nvec4 getScaledDown(vec2 scaledDownPos)\n{\n\treturn texture(iChannel0, scaledDownPos / iResolution.xy);\n}\n\n\n\n//=================================================\n// Various initialization functions (only one is used).\nvec4 initialize(vec2 fragCoord, int seed)\n{\n\tif(hash1(fragCoord) > 0.99)\n\t{\n\t\tfloat random = hash1((fragCoord + vec2(seed)) * 3.14);\n\t\tvec2 lookupDir;\n\t\tif(random < 0.25) lookupDir = vec2(1., 0.);\n\t\telse if(random < 0.5) lookupDir = vec2(-1., 0.);\n\t\telse if(random < 0.75) lookupDir = vec2(0., 1.);\n\t\telse lookupDir = vec2(0., -1.);\n\n\t\tlookupDir = lookupDir * 0.5 + 0.5;\n\n\t\treturn vec4(lookupDir, 1., 0.);\n\t}\n\treturn get(0, 0);\n}\n\nvec4 initializeSingle(vec2 pos, int seed)\n{\n\tvec2 centerPos = iResolution.xy * 0.5;\n\tvec2 diff = pos.xy - centerPos;\n\tif(\n\t\t(-.5 < diff.x) && (diff.x < 1.) &&\n\t  (-.5 < diff.y) && (diff.y < 1.)\n\t)\n\t{\n\t\tfloat random = hash1((pos + vec2(seed)) * 3.14);\n\t\tvec2 lookupDir;\n\t\tif(random < 0.25) lookupDir = vec2(1., 0.);\n\t\telse if(random < 0.5) lookupDir = vec2(-1., 0.);\n\t\telse if(random < 0.75) lookupDir = vec2(0., 1.);\n\t\telse lookupDir = vec2(0., -1.);\n\n\t\tlookupDir = lookupDir * 0.5 + 0.5;\n\n\t\treturn vec4(lookupDir, 1., 0.);\n\t}\n\treturn get(0, 0);\n}\n\nvec4 initializeRooms(vec2 pos, float roomAmount, int seed)\n{\n\tif(hash1(pos + vec2(seed) * 139.679) > roomAmount)\n\t{\n\t\tvec2 roomDir = pCenter;\n\t\tfloat random =\n\t\t\thash1((pos + vec2(seed)) * 43.87);\n\t\tif(random < 0.2) roomDir = pUp;\n\t\telse if(random < 0.4) roomDir = pDown;\n\t\telse if(random < 0.6) roomDir = pRight;\n\t\telse if(random < 0.8) roomDir = pLeft;\n\n\t\treturn vec4(roomDir, 1.0, 0.0);\n\t}\n\treturn vec4(0.0);\n}\n\n//=================================================\nvec4 postInitialize(vec2 fragCoord)\n{\n\tvec4 prev = get(0, 0);\n\tfloat neighbourZ = max(\n\t\tmax(\n\t\t\tmax(get(-1, 0).z, get(1, 0).z),\n\t\t\tmax(get(0, -1).z, get(0, 1).z)\n\t\t),\n\t\tmax(\n\t\t\tmax(get(-1, -1).z, get(-1, 1).z),\n\t\t\tmax(get(1, -1).z, get(1, 1).z)\n\t\t)\n\t);\n\n\tif(approx(prev.z, neighbourZ)) return vec4(.0);\n\treturn prev;\n}\n\n//=================================================\n// Expands the existing empty pixels horizontally and vertically depending on the current frame.\nvec4 expand(vec2 fragCoord)\n{\n\t/*\n\tvec4 prev = get(center);\n\tif(prev.z > 0.1) return prev;\n\n\tfloat neighboursZ = max(\n\t\tmax(\n\t\t\tmax(get(up).z, get(down).z),\n\t\t\tmax(get(right).z, get(left).z)\n\t\t),\n\t\tmax(\n\t\t\tmax(get(upRight).z, get(upLeft).z),\n\t\t\tmax(get(downRight).z, get(downLeft).z)\n\t\t)\n\t);\n\n\tif(neighboursZ > 0.1)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\treturn prev;\n\t*/\n\n\tvec4 c = get(center);\n\tif(is(c)) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\tif(is(u) && (iFrame % 2 == 0))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(d) && (iFrame % 2 == 0))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(r) && (iFrame % 2 == 1))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(is(l) && (iFrame % 2 == 1))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\n\treturn c;\n}\n// Expands the existing empty pixels horizontally and vertically depending on the current frame.\n// This version tries to keep the border between rooms.\nvec4 expandBorders(vec2 pos)\n{\n\tvec4 c = get(center);\n\tif(is(c)) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\tvec4 uu = get(up*2);\n\tvec4 dd = get(down*2);\n\tvec4 rr = get(right*2);\n\tvec4 ll = get(left*2);\n\n\tif(\n\t\t(is(u) && (iFrame % 2 == 0)) && // || is(ur) || is(ul)) &&\n\t\t!(is(d) || is(dd) || is(dr) || is(dl))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(d) && (iFrame % 2 == 0)) && // || is(dr) || is(dl)) &&\n\t\t!(is(u) || is(uu) || is(ur) || is(ul))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(r) && (iFrame % 2 == 1)) && // || is(ur) || is(dr)) &&\n\t\t!(is(l) || is(ll) || is(ul) || is(dl))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\tif(\n\t\t(is(l) && (iFrame % 2 == 1)) && // || is(ul) || is(dl)) &&\n\t\t!(is(r) || is(rr) || is(ur) || is(dr))\n\t)\n\treturn vec4(pCenter, 0.5, 0.0);\n\n\t/*\n\tif((is(u) || is(uu)) && (is(d) || is(dd)))\n\t\treturn c;\n\tif((is(r) || is(rr)) && (is(l) || is(ll)))\n\t\treturn c;\n\tif(is(ur) && is(dl))\n\t\treturn c;\n\tif(is(ul) && is(dr))\n\t\treturn c;\n\tif(is(ur) && is(dr) && !is(r))\n\t\treturn c;\n\tif(is(ul) && is(dl) && !is(l))\n\t\treturn c;\n\tif(is(ur) && is(ul) && !is(u))\n\t\treturn c;\n\tif(is(dr) && is(dl) && !is(d))\n\t\treturn c;\n\n\tif(\n\t\t(is(u) || is(d) || is(l) || is(r)) ||\n\t\t(is(ur) || is(ul) || is(dr) || is(dl))\n\t)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\treturn c;\n}\n\n//=================================================\n// Make everything that is active - neutral (0.5).\nvec4 neutralize(vec2 pos)\n{\n\tvec4 prev = get(center);\n\tif(prev.z > 0.1)\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\treturn prev;\n}\n\n//=================================================\n// Clear all of the pixels on the borders of the frame.\nvec4 clearBorders(vec2 pos)\n{\n\tvec4 prev = get(center);\n\tif(isOnBorder(pos)) return vec4(0.0);\n\treturn prev;\n}\n\n//=================================================\n// Mark random pixels on the edges of the rooms to become room exits on the next generation step.\nvec4 markRoomExits(vec2 pos, float amount, int seed)\n{\n\tvec4 prev = get(center);\n\tif(prev.z < 0.1) return prev;\n\n\tif(hash1((pos + vec2(seed)) * 48.31) > amount)\n\t\treturn prev;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\n\tif(u.z < 0.1) return vec4(pDown, 1.0, 0.0);\n\tif(d.z < 0.1) return vec4(pUp, 1.0, 0.0);\n\tif(r.z < 0.1) return vec4(pLeft, 1.0, 0.0);\n\tif(l.z < 0.1) return vec4(pRight, 1.0, 0.0);\n\n\treturn prev;\n}\n\n//=================================================\n// Bores a tunnel from the active pixels in the direction specified by a pixel, turns randomly.\nvec4 tunnel(vec2 pos, float meandering)\n{\n\tif(isOnBorder(pos)) return vec4(0.0);\n\n\tvec4 prev = get(0, 0);\n\t// Make the current cell inactive\n\t// if it was active.\n\tif(prev.z > 0.9)\n\t\treturn vec4(0.5, 0.5, 0.5, 0.0);\n\t\t//return vec4(prev.xy, 0.85, 0.0);\n\n\tvec4 result = prev;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\t// Tunnel.\n\t{\n\t\tif(\n\t\t\t(u.z > 0.9) &&\n\t\t\t(dl.z + dr.z < 0.1) &&\n\t\t\tapprox(u.xy, pUp)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pUp, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(d.z > 0.9) &&\n\t\t\t(ul.z + ur.z < 0.1) &&\n\t\t\tapprox(d.xy, pDown)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pDown, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(r.z > 0.9) &&\n\t\t\t(ul.z + dl.z < 0.1) &&\n\t\t\tapprox(r.xy, pRight)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pRight, 1.0, 0.0);\n\t\t}\n\n\t\telse if(\n\t\t\t(l.z > 0.9) &&\n\t\t\t(ur.z + dr.z < 0.1) &&\n\t\t\tapprox(l.xy, pLeft)\n\t\t)\n\t\t{\n\t\t\tresult = vec4(pLeft, 1.0, 0.0);\n\t\t}\n\t}\n\n\tvec2 dir = unpack(result.xy);\n\n\t// Turn randomly.\n\tif(\n\t\t//false &&\n\t\t(result.z > 0.1) &&\n\t\t(hash1((pos + vec2(iFrame)) * 91.13) >\n\t\t\t(1.0 - meandering))\n\t)\n\t{\n\t\tfloat random =\n\t\t\thash1((pos + vec2(iFrame)) * 3.14);\n\n\t\tif(random < 0.5) dir = dir.yx;\n\t\telse             dir = -dir.yx;\n\n\t\tvec4 diagonal1 = get(-dir + dir.yx);\n\t\tvec4 diagonal2 = get(-dir - dir.yx);\n\n\t\tif(diagonal1.z + diagonal2.z < 0.1)\n\t\t{\n\t\t\tresult.xy = pack(dir);\n\t\t}\n\t}\n\n\t// Turn away from the borders and\n\t// from the intersecrions.\n\tif(\n\t\t(result.z > 0.9) &&\n\t\t(\n\t\t\tisOnBorder(pos - dir) ||\n\t\t\tisOnBorder(pos - dir*2.0) ||\n\t\t\t(get(-dir * 2.0).z > 0.1) ||\n\t\t\t(get(-dir * 2.0 + dir.yx).z > 0.1) ||\n\t\t\t(get(-dir * 2.0 - dir.yx).z > 0.1)\n\t\t)\n\t)\n\t{\n\t\tvec2 newDir = dir;\n\t\t//*\n\t\t// Randomly turn left or right relative\n\t\t//to the current direction.\n\t\tfloat random =\n\t\t\thash1((pos + vec2(iFrame)) * 89.31);\n\t\tif(random < 0.5) newDir = newDir.yx;\n\t\telse             newDir = -newDir.yx;\n\n\t\t// Check if the new direction is actually good.\n\t\tif(\n\t\t\t(get(-newDir).z > 0.1) ||\n\t\t\t(get(-newDir * 2.0).z > 0.1) ||\n\t\t\tisOnBorder(pos - newDir*2.0)\n\t\t)\n\t\t{\n\t\t\t// If it's not good, then flip it.\n\t\t\tnewDir = -newDir;\n\t\t}\n\n\t\t// Check once again if the flipped direction\n\t\t// is any good.\n\t\tif(\n\t\t\t(get(-newDir).z > 0.1) ||\n\t\t\t(get(-newDir * 2.0).z > 0.1) ||\n\t\t\tisOnBorder(pos - newDir*2.0) ||\n\t\t\t(get(-newDir + newDir.yx).z > 0.1) ||\n\t\t\t(get(-newDir - newDir.yx).z > 0.1)\n\t\t)\n\t\t{\n\t\t\t// Both left and right turn is bad.\n\t\t\t// Go back to the original direction.\n\t\t\tnewDir = dir;\n\t\t}\n\n\t\tdir = newDir;\n\n\t\tresult.xy = pack(dir);\n\t\t//*/\n\t}\n\n\t// Connect dead ends.\n\tif(\n\t\t//false &&\n\t\t(result.z < 0.1)\n\t)\n\t{\n\t\t//*\n\t\tint n1 = 0, n2 = 0;\n\t\tif(is(u)) n1++;\n\t\tif(is(d)) n1++;\n\t\tif(is(r)) n1++;\n\t\tif(is(l)) n1++;\n\t\tif(is(ur)) n2++;\n\t\tif(is(ul)) n2++;\n\t\tif(is(dr)) n2++;\n\t\tif(is(dl)) n2++;\n\t\t//*/\n\n\t\tif(\n\t\t\t/*\n\t\t\t((u.z > 0.9) && (d.z > 0.1) &&\n\t\t\t\tapprox(u.xy, pUp)) ||\n\t\t\t((d.z > 0.9) && (u.z > 0.1) &&\n\t\t\t\tapprox(d.xy, pDown)) ||\n\t\t\t((r.z > 0.9) && (l.z > 0.1) &&\n\t\t\t\tapprox(r.xy, pRight)) ||\n\t\t\t((l.z > 0.9) && (r.z > 0.1) &&\n\t\t\t\tapprox(l.xy, pLeft))\n\t\t\t//*/\n\t\t\tfalse\n\t\t\t//|| (n1 == 2) && (n2 < 2)\n\t\t\t|| ((n1 == 2) && (n2 == 0))\n\t\t\t/*\n\t\t\t|| (\n\t\t\t\tis(u) && is(d) &&\n\t\t\t\t(\n\t\t\t\t\t(!is(ur) && !is(ul)) ||\n\t\t\t\t\t(!is(dr) && !is(dl))\n\t\t\t\t)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\tis(r) && is(l) &&\n\t\t\t\t(\n\t\t\t\t\t(!is(ur) && !is(dr)) ||\n\t\t\t\t\t(!is(ul) && !is(dl))\n\t\t\t\t)\n\t\t\t)\n\t\t\t//*/\n\t\t\t//*\n\t\t\t|| (\n\t\t\t\t(u.z > 0.1) &&\n\t\t\t\t(dr.z > 0.1) &&\n\t\t\t\t(dl.z < 0.1) &&\n\t\t\t\t(r.z < 0.1) &&\n\t\t\t\t(l.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(u.z > 0.1) &&\n\t\t\t\t(dr.z < 0.1) &&\n\t\t\t\t(dl.z > 0.1) &&\n\t\t\t\t(r.z < 0.1) &&\n\t\t\t\t(l.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(l.z > 0.1) &&\n\t\t\t\t(dr.z < 0.1) &&\n\t\t\t\t(ur.z > 0.1) &&\n\t\t\t\t(u.z < 0.1) &&\n\t\t\t\t(d.z < 0.1)\n\t\t\t)\n\t\t\t|| (\n\t\t\t\t(r.z > 0.1) &&\n\t\t\t\t(dl.z < 0.1) &&\n\t\t\t\t(ul.z > 0.1) &&\n\t\t\t\t(u.z < 0.1) &&\n\t\t\t\t(d.z < 0.1)\n\t\t\t)\n\t\t\t//*/\n\t\t)\n\t\t{\n\t\t\tresult = vec4(0.5, 0.5, 0.5, 0.0);\n\t\t}\n\t}\n\n\treturn result;\n}\n\n//=================================================\n// Last cellular automata step. Clean up the result based on some rules.\nvec4 cleanUp(vec2 pos)\n{\n\tvec4 c = get(center);\n\t//return c;\n\n\t//if(c.z < 0.1) return c;\n\n\tvec4 u = get(up);\n\tvec4 d = get(down);\n\tvec4 r = get(right);\n\tvec4 l = get(left);\n\tvec4 ur = get(upRight);\n\tvec4 ul = get(upLeft);\n\tvec4 dr = get(downRight);\n\tvec4 dl = get(downLeft);\n\n\tint n1 = 0, n2 = 0;\n\tif(u.z > 0.1) n1++;\n\tif(d.z > 0.1) n1++;\n\tif(r.z > 0.1) n1++;\n\tif(l.z > 0.1) n1++;\n\tif(ur.z > 0.1) n2++;\n\tif(ul.z > 0.1) n2++;\n\tif(dr.z > 0.1) n2++;\n\tif(dl.z > 0.1) n2++;\n\n\tif(n1 == 1) return vec4(0.0);\n\t//if((n1 == 3) && (n2 == 3)) return vec4(0.0);\n\t//if((n1 == 4) && (n2 == 4)) return vec4(0.0);\n\t//if((n1 < 2) && (n2 ==3)) return vec4(0.0);\n\t//if((n1 == 2) && (n2 == 4)) return vec4(0.0);\n\tif(n1 == 0) return vec4(0.0);\n\n\t/*\n\tif(!is(c) && (n1 == 4) && (n2 == 4))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\n\t/*\n\tif(!is(u) && !is(r) && is(ur)) return vec4(0.0);\n\tif(!is(u) && !is(l) && is(ul)) return vec4(0.0);\n\tif(!is(d) && !is(r) && is(dr)) return vec4(0.0);\n\tif(!is(d) && !is(l) && is(dl)) return vec4(0.0);\n\t//*/\n\n\t/*\n\tif(!is(c) && is(u) && is(r) && !is(ur))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(u) && is(l) && !is(ul))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(d) && is(r) && !is(dr))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\tif(!is(c) && is(d) && is(l) && !is(dl))\n\t\treturn vec4(pCenter, 0.5, 0.0);\n\t//*/\n\n\treturn c;\n}\n\n//=================================================\n// This is used to add some cracks to the visual presentation of the dungeon.\nfloat getCracks(vec2 uv)\n{\n    float cracks = abs(texture(iChannel1, uv).x - 0.125) / (1.0 - 0.125);\n    return saturate(10.0*cracks);\n}\n\n\n\n//=================================================\n// This is the generation process. It happens in the bottom left corner.\nvec4 getScaledDown(vec2 pos, int frame, int seed)\n{\n    if(frame == 0)\n    {\n        return vec4(0.0);\n        //return get(center);\n    }\n\tif(frame == 1)\n\t{\n\t\t//fragColor = initializeSingle(p, seed);\n\t\t//fragColor = initialize(p, seed);\n\t\treturn initializeRooms(pos, 0.99, seed);\n\t}\n\tif(frame < 5)\n\t{\n\t\t//fragColor = get(center);\n\t\treturn tunnel(pos, 0.3);\n\t\t//fragColor = expand(p);\n\t}\n\tif(frame < 9)\n\t{\n\t\treturn expand(pos);\n\t\t//return expandBorders(pos);\n\t}\n\tif(frame == 9)\n\t{\n\t\treturn neutralize(pos);\n\t}\n\tif(frame == 10)\n\t{\n\t\treturn clearBorders(pos);\n\t}\n\tif(frame == 11)\n\t{\n\t\treturn markRoomExits(pos, 0.1, seed); //0.09\n\t}\n\tif (\n\t\t//false &&\n\t\tframe < 150\n\t)\n\t{\n\t\treturn tunnel(pos, 0.15);\n\t}\n\t//if(false)\n\t{\n\t\treturn cleanUp(pos);\n\t}\n}\n\n//=================================================\n// This is a function to upscale the tiny dungeon generated in the bottom left corner.\n// It also adds details like tiles, walls, cracks and shading.\nvec4 getRegular(vec2 pos)\n{\n\tpos = pos / scaleDown;\n\n\tvec2 originalPos = pos;\n\n\tvec2 warped = pos;\n\n\t// Uncomment this. Disabled only for testing.\n    vec2 hashNoise = unpack(hash22(vec2(ivec2(pos))));\n\twarped += 0.05 * hashNoise;\n\n\tfloat noise = unpack(optimizedSnoise(warped * 0.15));\n\tpos = warped + noise * 0.05;\n\n\tvec4 cell = getScaledDown(pos);\n\tvec4 c = cell;\n\n\tvec4 u = getScaledDown(pos + vec2(up));\n\tvec4 d = getScaledDown(pos + vec2(down));\n\tvec4 r = getScaledDown(pos + vec2(right));\n\tvec4 l = getScaledDown(pos + vec2(left));\n\tvec4 ur = getScaledDown(pos + vec2(upRight));\n\tvec4 ul = getScaledDown(pos + vec2(upLeft));\n\tvec4 dr = getScaledDown(pos + vec2(downRight));\n\tvec4 dl = getScaledDown(pos + vec2(downLeft));\n\tvec4 dd = getScaledDown(pos + vec2(down)*2.0);\n\n\tint n1 = 0, n2 = 0;\n\tif(u.z > 0.1) n1++;\n\tif(d.z > 0.1) n1++;\n\tif(r.z > 0.1) n1++;\n\tif(l.z > 0.1) n1++;\n\tif(ur.z > 0.1) n2++;\n\tif(ul.z > 0.1) n2++;\n\tif(dr.z > 0.1) n2++;\n\tif(dl.z > 0.1) n2++;\n\n\n\tfloat cracks = getCracks(originalPos * 0.003 + 0.1*hashNoise);\n\n\tvec2 grid = abs(sin(pos * M_PI));\n\tfloat gridMultiplier = min(grid.x, grid.y);\n\tgridMultiplier *= cracks;\n\tgridMultiplier =\n\t\tclamp(gridMultiplier * 5.0, 0.0, 1.0);\n\n\n\t// Wall tops.\n    float wallTopOffset = 0.5;\n    \n\tif(\n\t\t//false &&\n\t\t!is(cell) && ((n1 + n2 != 0) || !is(d))\n\t)\n\t{\n\t\tvec2 iPos = vec2(ivec2(pos));\n\n\t\tfloat mask = 0.0;\n\t\t//*\n\t\tif(is(u)) mask = max(mask, -0.25 + pos.y - iPos.y);\n\t\t//if(is(d)) mask = max(mask, 1.0 - pos.y + iPos.y);\n\t\tif(is(d)) mask = max(mask, (1.0 + wallTopOffset) - pos.y + iPos.y);\n\t\tif(is(r)) mask = max(mask, pos.x - iPos.x);\n\t\tif(is(l)) mask = max(mask, 1.0 - pos.x + iPos.x);\n\t\t//*/\n\t\t//if(is(dd)) mask = max(mask, 1.0 + (-pos.y + iPos.y));\n\t\t//*/\n\t\t//*\n\t\tif(is(ur)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, -0.25 + pos.y - iPos.y)\n\t\t);\n\t\tif(is(ul)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, -0.25 + pos.y - iPos.y)\n\t\t);\n\t\t/*\n\t\tif(is(dr)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, 1.0 - pos.y + iPos.y)\n\t\t);\n\t\tif(is(dl)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, 1.0 - pos.y + iPos.y)\n\t\t);\n\t\t//*/\n\t\tif(is(dr)) mask = max(\n\t\t\tmask,\n\t\t\tmin(pos.x - iPos.x, (1.0 + wallTopOffset) - pos.y + iPos.y)\n\t\t);\n\t\tif(is(dl)) mask = max(\n\t\t\tmask,\n\t\t\tmin(1.0 - pos.x + iPos.x, (1.0 + wallTopOffset) - pos.y + iPos.y)\n\t\t);\n\t\t//if(is(dr)) mask = max(mask, pos.x - iPos.x);\n\t\t//if(is(dl)) mask = max(mask, 1.0 - pos.x + iPos.x);\n\n\t\tmask *= mask * mask;\n\n\t\tfloat outline = 1.0 - 1.5 * mask;\n\t\toutline = clamp(3.0 * outline, 0.0, 1.0);\n\t\tmask = clamp(2.0 * mask, 0.0, 1.0);\n\n\t\tcell = vec4(mask);\n\t}\n\n\t// Side walls.\n\tif(\n\t\t//false &&\n\t\t!is(c) && is(d)\n\t)\n\t{\n\t\tfloat height =\n\t\t\t1.0 * (pos.y - float(int(pos.y)));\n\t\t//height = pow(height, 0.5);\n\t\t//height = clamp(0.0 + height, 0.0, 1.0);\n\t\t//height = 1.0 - 2.0 * abs(height - 0.5);\n\n\t\t// This one.\n\t\t//cell = min(cell, vec4(height));\n\n\t\tif(height < wallTopOffset)\n\t\t{\n\t\t\tfloat split = abs(cos(2.0 * height * M_PI));\n\t\t\tsplit = clamp(split * 2.5, 0.0, 1.0);\n\t\t\tcell = vec4(0.17 * split);\n\t\t\tif(height < (0.5 * wallTopOffset))\n\t\t\t\tpos.x += 0.25;\n\t\t}\n\n\t\t//height *= abs(sin(height * M_PI * 5.0));\n\t\t/*\n\t\tcell = mix(\n\t\t\tvec4(0.4),\n\t\t\tvec4(0.25),\n\t\t\theight\n\t\t);\n\t\tcell *= clamp(\n\t\t\t2.5 * abs(cos(height * M_PI * 2.0)),\n\t\t\t0.0, 1.0\n\t\t);\n\t\t*/\n\t}\n\n\tif(!is(c))\n\t{\n\t\tvec2 topGrid =\n\t\t\tabs(sin(2.0 * (pos - vec2(0.0, wallTopOffset)) * M_PI));\n\t\tfloat topGridMultiplier = min(topGrid.x, topGrid.y);\n\t\ttopGridMultiplier *= cracks;\n\t\ttopGridMultiplier =\n\t\t\tclamp(topGridMultiplier * 2.5, 0.0, 1.0);\n\n\t\t/*\n\t\tcell = vec4(\n\t\t\t//0.15 * cell +\n\t\t\t0.5 *\n\t\t\t(1.5 - topGridMultiplier) *\n\t\t\t(cracks) *\n\t\t\tcell\n\t\t\t//* (outline)\n\t\t);\n\t\t//*/\n\t\tcell = cell * cell * cell;\n\t\tcell = clamp(100.0 * cell, 0.0, 1.0);\n\t\tcell *= topGridMultiplier;\n\t\tcell *= 0.35;\n\t}\n\n\t// Shading.\n\tif(\n\t\t//false &&\n\t\tis(c)\n\t)\n\t{\n\t\tvec2 iPos = vec2(ivec2(pos));\n\t\tfloat mask = 1.0;\n\t\tfloat occlusion = 1.0;\n\n\t\tocclusion *= (!is(d)?\n\t\t\t\t(pos.y - iPos.y) : 1.0);\n\t\tocclusion *= (!is(u)?\n\t\t\t\t(1.0 - pos.y + iPos.y) : 1.0);\n\t\tocclusion *= (!is(l)?\n\t\t\t\t(pos.x - iPos.x) : 1.0);\n\t\tocclusion *= (!is(r)?\n\t\t\t\t(1.0 - pos.x + iPos.x) : 1.0);\n\n\t\tocclusion *= (!is(dl)?\n\t\t\tlength(vec2(\n\t\t\t\t(pos.x - iPos.x),\n\t\t\t\t(pos.y - iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(dr)?\n\t\t\tlength(vec2(\n\t\t\t\t(1.0 - pos.x + iPos.x),\n\t\t\t\t(pos.y - iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(ul)?\n\t\t\tlength(vec2(\n\t\t\t\t(pos.x - iPos.x),\n\t\t\t\t(1.0 - pos.y + iPos.y)\n\t\t\t)) : 1.0);\n\t\tocclusion *= (!is(ur)?\n\t\t\tlength(vec2(\n\t\t\t\t(1.0 - pos.x + iPos.x),\n\t\t\t\t(1.0 - pos.y + iPos.y)\n\t\t\t)) : 1.0);\n\n\t\t//occlusion = clamp(8.0 * occlusion, 0.0, 1.0);\n\t\t//occlusion *= occlusion;\n\t\tocclusion = pow(occlusion, 0.5);\n\t\tocclusion = clamp(1.5 * occlusion, 0.0, 1.0);\n\t\tmask = occlusion;\n\t\t\t//clamp(pow(occlusion, 1.0), 0.0, 1.0);\n\n\t\tcell *= mask;\n\t}\n\n\tif(is(c)) cell *= gridMultiplier;\n\treturn cell;\n\t//return cell * gridMultiplier;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Empty the texture once in the beginning.\n    if(iFrame == 0)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    // Read seed and frameId from the specified pixels in the texture.\n    ivec2 seedPixelPos = ivec2(0.0, iResolution.y / scaleDown + 1.0);\n    ivec2 frameIdPixelPos = ivec2(1.0, iResolution.y / scaleDown + 1.0);\n\n    int seed = int(texelFetch(iChannel0, seedPixelPos, 0).x * 1000.0);\n    int frameId = int(texelFetch(iChannel0, frameIdPixelPos, 0).x * 1000.0);\n\n\n    // Process the seed pixel.\n    if(ivec2(fragCoord) == seedPixelPos)\n    {\n        vec4 currentSeed = texelFetch(iChannel0, seedPixelPos, 0);\n        if(frameId == 300)\n        {\n            // Go to next seed. Reset frame counter.\n            fragColor = currentSeed + vec4(0.001, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            fragColor = currentSeed;\n        }\n        return;\n    }\n    \n    // Process the frame id pixel.\n    if(ivec2(fragCoord) == frameIdPixelPos)\n    {\n        vec4 currentFrame = texelFetch(iChannel0, frameIdPixelPos, 0);\n        if(frameId == 300)\n        {\n            // Go to next seed. Reset frame counter.\n            fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n        }\n        else\n        {\n            // Increase the frame id by 1.\n            fragColor = currentFrame + vec4(0.001, 0.0, 0.0, 0.0);\n        }\n        return;\n    }\n    \n    // If we are doing a reset, then clean everything else except the frame id pixel and the seed pixel.\n    if(frameId == 300)\n    {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n\n\tfloat mx = max(iResolution.x, iResolution.y);\n\tvec2 uv = fragCoord / mx;\n\tvec2 p = fragCoord;\n\n\tif(isScaledDown(p))\n\t{\n\t\tfragColor = getScaledDown(p, frameId, seed);\n\t}\n\telse\n\tif(\n\t\t(p.x > iResolution.x / scaleDown + 1.0) ||\n\t\t(p.y > iResolution.y / scaleDown + 1.0)\n\t)\n\t{\n\t\tfragColor = getRegular(p);\n\t}\n\telse{\n\t\tfragColor = get(center);\n\t}\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcBzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 190]], "test": "untested"}
{"id": "NstGDM", "name": "NOREN", "author": "iq", "description": "Noise Representation Networks - ie, your regular multi-layer perceptron network with Perlin noise as activation function. Original picture from [url]https://www.mentalfloss.com/article/542652/facts-about-salvador-dali[/url]", "tags": ["2d", "compression", "perceptron", "network", "siren", "ml"], "likes": 74, "viewed": 4153, "published": 3, "date": "1656925898", "time_retrieved": "2024-07-30T16:41:48.958015", "image_code": "// The MIT License\n// Copyright Â© 2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Compressing images with noise.\n//\n// I was thinking, why not use Perlin Noise as activation function\n// for a classic multi-layer perceptron network? If ReLUs and sine\n// waves work, any non linear thing must just work. Including some\n// noise (ie, a differentiable, stochastic oscillating signal, not\n// the \"noise\" of signal processing). Unlike sin waves, the search\n// space is way larger since noise isn't periodic. Also, feel free\n// to call this NOREN (Noise Representation Network).\n//\n// This is the quick experiment referred here a year ago\n// https://twitter.com/iquilezles/status/1432429955527237632\n// which I never got the time to write about.\n//\n// I trained the network with a little C program I wrote, so I am\n// confident you can beat it by a lot with a proper ML framework.\n// \n// As said, the network is a regular multi-layer perceptron, with\n// { 2, 64, 32, 16, 8, 1 } layers and a total of 2945 parameters.\n// The activation noise function is this one I developed here:\n// https://www.shadertoy.com/view/3sd3Rs\n\n// noise, https://www.shadertoy.com/view/3sd3Rs\nfloat fun( in float x )\n{\n  float i = floor(x);\n  float f = fract(x);\n  float k = fract(i*0.1731)*16.0-4.0;\n  f *=   f-1.0;\n  f *= k*f-1.0;\n  f *= sign(fract(x/2.0)-0.5);\n  return f;\n}\n\n// network\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // --- layer 0 : input ---------------\n    float v_0_0 = fragCoord.x/iResolution.x;\n    float v_0_1 = fragCoord.y/iResolution.y;\n\n    // --- layer 1 -----------------------\n    float v_1_00 = fun( 12.651764*v_0_0 +1.339055*v_0_1-23.754999);\n    float v_1_01 = fun( -0.532269*v_0_0 -8.396215*v_0_1+23.099752);\n    float v_1_02 = fun(-12.253928*v_0_0+22.502775*v_0_1-24.686695);\n    float v_1_03 = fun( 17.924093*v_0_0-18.237402*v_0_1-14.419626);\n    float v_1_04 = fun(-22.862108*v_0_0-15.147194*v_0_1-15.151608);\n    float v_1_05 = fun( -9.650509*v_0_0-14.831182*v_0_1+20.137722);\n    float v_1_06 = fun( -8.004325*v_0_0 -0.475607*v_0_1+20.921373);\n    float v_1_07 = fun(  7.464520*v_0_0 +1.960937*v_0_1+4.899765);\n    float v_1_08 = fun(-10.973597*v_0_0+18.677485*v_0_1-6.463108);\n    float v_1_09 = fun(-23.755060*v_0_0+19.067633*v_0_1-13.359839);\n    float v_1_10 = fun(  9.192753*v_0_0+20.252661*v_0_1+16.834564);\n    float v_1_11 = fun(  7.906412*v_0_0+14.221536*v_0_1+7.045158);\n    float v_1_12 = fun(-10.764951*v_0_0 +1.050687*v_0_1-12.406633);\n    float v_1_13 = fun( 14.603448*v_0_0+24.272823*v_0_1+4.524347);\n    float v_1_14 = fun(  5.894300*v_0_0 -2.107377*v_0_1-1.927901);\n    float v_1_15 = fun(  3.901146*v_0_0 +1.269753*v_0_1+23.912832);\n    float v_1_16 = fun( -7.028045*v_0_0+19.630928*v_0_1+5.540376);\n    float v_1_17 = fun( -0.534545*v_0_0+14.446243*v_0_1-17.512001);\n    float v_1_18 = fun( -2.202332*v_0_0+10.817842*v_0_1-19.685925);\n    float v_1_19 = fun( -5.548895*v_0_0 -0.556134*v_0_1+12.383915);\n    float v_1_20 = fun(  4.818054*v_0_0 +3.885520*v_0_1-18.928185);\n    float v_1_21 = fun(-19.688728*v_0_0 -6.919561*v_0_1+19.978441);\n    float v_1_22 = fun( -9.321958*v_0_0-20.376427*v_0_1+8.881976);\n    float v_1_23 = fun(-20.164150*v_0_0-13.801070*v_0_1+1.050954);\n    float v_1_24 = fun(-11.437829*v_0_0 +6.469597*v_0_1+13.477356);\n    float v_1_25 = fun( 11.655347*v_0_0 +8.145976*v_0_1+8.415142);\n    float v_1_26 = fun(-10.880453*v_0_0 +0.682798*v_0_1+17.531200);\n    float v_1_27 = fun(-13.601298*v_0_0-21.871817*v_0_1-0.502928);\n    float v_1_28 = fun(-14.981379*v_0_0+21.467344*v_0_1-3.321391);\n    float v_1_29 = fun(-20.798067*v_0_0+17.810989*v_0_1-6.143041);\n    float v_1_30 = fun( -8.127576*v_0_0-20.133320*v_0_1+3.440520);\n    float v_1_31 = fun(  0.758812*v_0_0+10.336716*v_0_1-18.378170);\n    float v_1_32 = fun( 13.717178*v_0_0 +4.189069*v_0_1-10.929428);\n    float v_1_33 = fun( 20.781424*v_0_0+13.521489*v_0_1-20.092876);\n    float v_1_34 = fun( 12.257710*v_0_0 -3.714963*v_0_1-17.730146);\n    float v_1_35 = fun(-15.930890*v_0_0-11.382194*v_0_1+18.150429);\n    float v_1_36 = fun(  7.444907*v_0_0+10.940384*v_0_1+1.030603);\n    float v_1_37 = fun( 17.040625*v_0_0+15.649309*v_0_1+5.114138);\n    float v_1_38 = fun(  9.930554*v_0_0-16.405514*v_0_1+20.695515);\n    float v_1_39 = fun(  6.665332*v_0_0+18.455132*v_0_1+12.971514);\n    float v_1_40 = fun( 23.615326*v_0_0+10.625115*v_0_1-10.179976);\n    float v_1_41 = fun(-20.110067*v_0_0 +2.001038*v_0_1+8.840239);\n    float v_1_42 = fun(-18.800917*v_0_0+23.278751*v_0_1+23.994085);\n    float v_1_43 = fun( 22.557316*v_0_0-20.167139*v_0_1-6.057110);\n    float v_1_44 = fun(-20.584620*v_0_0 -8.592924*v_0_1+9.116179);\n    float v_1_45 = fun( 23.096958*v_0_0+20.168434*v_0_1-21.596998);\n    float v_1_46 = fun( -7.976181*v_0_0+20.527336*v_0_1-18.099480);\n    float v_1_47 = fun( -5.720318*v_0_0-12.690313*v_0_1-8.031078);\n    float v_1_48 = fun( 17.160139*v_0_0 +2.665666*v_0_1-18.810461);\n    float v_1_49 = fun(-11.865465*v_0_0-16.981085*v_0_1-19.168430);\n    float v_1_50 = fun( -2.159684*v_0_0 +4.667675*v_0_1+3.735635);\n    float v_1_51 = fun( -8.529593*v_0_0 -8.495744*v_0_1+19.751242);\n    float v_1_52 = fun( 18.633884*v_0_0 +9.868877*v_0_1-1.110809);\n    float v_1_53 = fun( -7.546693*v_0_0 -0.406618*v_0_1-7.886292);\n    float v_1_54 = fun( 13.809946*v_0_0 +7.604858*v_0_1-23.396351);\n    float v_1_55 = fun(-16.146168*v_0_0 +6.536390*v_0_1-7.000743);\n    float v_1_56 = fun(-14.457527*v_0_0 -0.539393*v_0_1-3.365755);\n    float v_1_57 = fun(-19.274729*v_0_0 +2.786475*v_0_1-10.144519);\n    float v_1_58 = fun(-15.128548*v_0_0-21.821358*v_0_1+17.020514);\n    float v_1_59 = fun( 20.561825*v_0_0 -8.012662*v_0_1+3.237656);\n    float v_1_60 = fun(-22.853487*v_0_0 +0.398873*v_0_1+15.676755);\n    float v_1_61 = fun( 18.068533*v_0_0-17.750360*v_0_1-3.100729);\n    float v_1_62 = fun( 23.743105*v_0_0 -7.714730*v_0_1-15.557582);\n    float v_1_63 = fun(  6.675613*v_0_0+11.700735*v_0_1-2.029474);\n\n    // --- layer 2 -----------------------\n    float v_2_00 = fun(-0.044525*v_1_00+0.115868*v_1_01-0.035576*v_1_02+0.027339*v_1_03+0.015867*v_1_04+0.022896*v_1_05+0.039554*v_1_06-0.169480*v_1_07+0.031006*v_1_08+0.044222*v_1_09-0.004297*v_1_10+0.025188*v_1_11-0.437089*v_1_12-0.038434*v_1_13-0.082501*v_1_14-0.169753*v_1_15+0.020257*v_1_16+0.111858*v_1_17-0.051250*v_1_18+0.119436*v_1_19+0.203302*v_1_20+0.170197*v_1_21+0.068203*v_1_22-0.015849*v_1_23-0.195028*v_1_24+0.038735*v_1_25-0.087068*v_1_26+0.030674*v_1_27+0.027934*v_1_28+0.036769*v_1_29-0.029686*v_1_30-0.099598*v_1_31+0.185609*v_1_32+0.077544*v_1_33-0.001495*v_1_34-0.096777*v_1_35-0.077638*v_1_36+0.006687*v_1_37+0.025782*v_1_38+0.045049*v_1_39+0.011980*v_1_40-0.067470*v_1_41+0.005923*v_1_42-0.031544*v_1_43+0.002367*v_1_44-0.017811*v_1_45-0.044148*v_1_46-0.001016*v_1_47+0.333579*v_1_48+0.035056*v_1_49-0.033190*v_1_50-0.078993*v_1_51+0.069724*v_1_52+0.014914*v_1_53+0.067980*v_1_54+0.003039*v_1_55-0.208939*v_1_56+0.097293*v_1_57-0.000224*v_1_58+0.144430*v_1_59+0.032889*v_1_60-0.085943*v_1_61+0.029325*v_1_62-0.019159*v_1_63+0.064850);\n    float v_2_01 = fun( 0.085992*v_1_00+0.205653*v_1_01-0.053559*v_1_02-0.075332*v_1_03+0.037484*v_1_04-0.082075*v_1_05-0.000862*v_1_06+0.081010*v_1_07-0.015090*v_1_08+0.010667*v_1_09-0.025403*v_1_10-0.133320*v_1_11-0.053244*v_1_12+0.041927*v_1_13+0.498567*v_1_14+0.243247*v_1_15+0.020366*v_1_16+0.035310*v_1_17+0.003063*v_1_18-0.169640*v_1_19+0.108635*v_1_20+0.021393*v_1_21+0.104203*v_1_22+0.016613*v_1_23-0.106106*v_1_24+0.076009*v_1_25+0.084641*v_1_26-0.092887*v_1_27-0.032172*v_1_28+0.001252*v_1_29+0.004446*v_1_30+0.041510*v_1_31-0.068689*v_1_32-0.075427*v_1_33-0.053876*v_1_34-0.117501*v_1_35+0.034715*v_1_36+0.038847*v_1_37-0.086056*v_1_38-0.075281*v_1_39-0.004249*v_1_40-0.096576*v_1_41-0.023905*v_1_42+0.079087*v_1_43+0.034240*v_1_44+0.034465*v_1_45-0.031142*v_1_46+0.044658*v_1_47-0.147024*v_1_48-0.053687*v_1_49-0.135732*v_1_50-0.049481*v_1_51-0.034369*v_1_52-0.027767*v_1_53+0.066915*v_1_54-0.193987*v_1_55+0.022023*v_1_56+0.100757*v_1_57+0.022187*v_1_58-0.139774*v_1_59+0.058295*v_1_60+0.036765*v_1_61-0.082648*v_1_62-0.136839*v_1_63+0.092278);\n    float v_2_02 = fun(-0.127209*v_1_00+0.065225*v_1_01-0.056975*v_1_02+0.052557*v_1_03-0.074556*v_1_04-0.052306*v_1_05-0.324635*v_1_06-0.090682*v_1_07-0.103687*v_1_08-0.022151*v_1_09-0.041096*v_1_10-0.075392*v_1_11-0.270524*v_1_12+0.014113*v_1_13-0.070891*v_1_14-0.172151*v_1_15+0.025130*v_1_16-0.049420*v_1_17+0.053585*v_1_18-0.202775*v_1_19-0.056114*v_1_20-0.238883*v_1_21+0.129495*v_1_22+0.001273*v_1_23-0.126285*v_1_24-0.012618*v_1_25+0.173209*v_1_26-0.011349*v_1_27+0.050094*v_1_28-0.011544*v_1_29+0.083887*v_1_30+0.017274*v_1_31-0.113601*v_1_32-0.040849*v_1_33+0.097738*v_1_34-0.148567*v_1_35+0.098479*v_1_36-0.068012*v_1_37-0.026094*v_1_38-0.040769*v_1_39-0.037829*v_1_40-0.193376*v_1_41+0.044405*v_1_42-0.068566*v_1_43+0.029461*v_1_44-0.001436*v_1_45+0.000594*v_1_46+0.141620*v_1_47-0.087259*v_1_48-0.028868*v_1_49-0.016243*v_1_50+0.457991*v_1_51+0.150156*v_1_52-0.194628*v_1_53-0.022515*v_1_54+0.029254*v_1_55-0.059812*v_1_56-0.101218*v_1_57-0.030081*v_1_58-0.082407*v_1_59+0.003820*v_1_60+0.024786*v_1_61+0.075422*v_1_62+0.085187*v_1_63-0.007961);\n    float v_2_03 = fun( 0.043561*v_1_00+0.103728*v_1_01-0.014765*v_1_02-0.007922*v_1_03-0.021944*v_1_04+0.004805*v_1_05+0.203720*v_1_06-0.198465*v_1_07-0.011335*v_1_08+0.024568*v_1_09+0.014230*v_1_10+0.016075*v_1_11-0.128696*v_1_12-0.044283*v_1_13-0.039055*v_1_14+0.133844*v_1_15-0.054472*v_1_16+0.104392*v_1_17-0.105933*v_1_18-0.276674*v_1_19-0.001262*v_1_20+0.012153*v_1_21-0.000153*v_1_22+0.115850*v_1_23-0.058406*v_1_24-0.009838*v_1_25-0.271043*v_1_26-0.047843*v_1_27-0.006785*v_1_28+0.020373*v_1_29-0.002165*v_1_30+0.177880*v_1_31+0.096860*v_1_32-0.030319*v_1_33-0.048030*v_1_34+0.053012*v_1_35+0.093970*v_1_36+0.006791*v_1_37-0.127931*v_1_38-0.025170*v_1_39-0.056277*v_1_40-0.090330*v_1_41-0.063819*v_1_42-0.042224*v_1_43-0.111293*v_1_44+0.002892*v_1_45-0.057016*v_1_46+0.098001*v_1_47-0.024162*v_1_48+0.028837*v_1_49+0.065524*v_1_50+0.011087*v_1_51+0.065933*v_1_52-0.024707*v_1_53-0.229571*v_1_54-0.006999*v_1_55+0.117027*v_1_56+0.024293*v_1_57-0.026667*v_1_58-0.040759*v_1_59-0.011486*v_1_60+0.009570*v_1_61-0.044660*v_1_62-0.021106*v_1_63-0.131698);\n    float v_2_04 = fun( 0.068916*v_1_00-0.056187*v_1_01-0.083925*v_1_02-0.030404*v_1_03+0.074165*v_1_04-0.013949*v_1_05-0.114450*v_1_06+0.038914*v_1_07+0.000601*v_1_08-0.028590*v_1_09-0.036830*v_1_10+0.009743*v_1_11+0.270937*v_1_12-0.016449*v_1_13-0.066408*v_1_14+0.151630*v_1_15-0.061993*v_1_16-0.033557*v_1_17-0.014451*v_1_18-0.199938*v_1_19-0.107729*v_1_20-0.168311*v_1_21-0.072904*v_1_22-0.029236*v_1_23+0.062262*v_1_24+0.018318*v_1_25-0.056614*v_1_26-0.035537*v_1_27-0.005170*v_1_28-0.024719*v_1_29-0.071641*v_1_30+0.196137*v_1_31-0.145898*v_1_32+0.024779*v_1_33+0.181902*v_1_34+0.029270*v_1_35-0.048335*v_1_36-0.050959*v_1_37-0.007753*v_1_38-0.029827*v_1_39-0.037985*v_1_40+0.028145*v_1_41+0.066963*v_1_42+0.011681*v_1_43+0.053097*v_1_44-0.098342*v_1_45+0.081099*v_1_46-0.099549*v_1_47+0.152579*v_1_48-0.106578*v_1_49+0.011003*v_1_50+0.113793*v_1_51-0.122793*v_1_52+0.085224*v_1_53-0.079507*v_1_54-0.054002*v_1_55+0.149172*v_1_56-0.012336*v_1_57+0.012771*v_1_58-0.117302*v_1_59+0.095892*v_1_60-0.038606*v_1_61-0.021617*v_1_62+0.076835*v_1_63-0.040366);\n    float v_2_05 = fun( 0.116964*v_1_00-0.041162*v_1_01+0.014651*v_1_02-0.056107*v_1_03-0.059145*v_1_04-0.077622*v_1_05-0.268724*v_1_06-0.134324*v_1_07-0.055725*v_1_08-0.025782*v_1_09-0.010396*v_1_10-0.049224*v_1_11-0.217466*v_1_12+0.008592*v_1_13-0.058990*v_1_14+0.029188*v_1_15+0.072704*v_1_16-0.037670*v_1_17+0.005817*v_1_18+0.109588*v_1_19-0.115937*v_1_20+0.149483*v_1_21+0.048569*v_1_22-0.038552*v_1_23+0.073754*v_1_24-0.050677*v_1_25+0.035677*v_1_26-0.011170*v_1_27+0.033516*v_1_28-0.014033*v_1_29-0.000624*v_1_30-0.090845*v_1_31+0.020498*v_1_32+0.000211*v_1_33+0.070077*v_1_34-0.025147*v_1_35-0.186809*v_1_36+0.067344*v_1_37-0.035309*v_1_38-0.022144*v_1_39-0.019433*v_1_40+0.003882*v_1_41-0.029886*v_1_42-0.008913*v_1_43-0.016018*v_1_44+0.007118*v_1_45+0.026850*v_1_46-0.015412*v_1_47-0.145883*v_1_48-0.008495*v_1_49-0.215282*v_1_50-0.108235*v_1_51+0.039193*v_1_52-0.471203*v_1_53-0.030101*v_1_54-0.085238*v_1_55-0.114731*v_1_56-0.060247*v_1_57+0.056936*v_1_58-0.060115*v_1_59-0.128227*v_1_60+0.016342*v_1_61+0.036467*v_1_62-0.106037*v_1_63+0.279289);\n    float v_2_06 = fun( 0.109230*v_1_00+0.078372*v_1_01-0.018636*v_1_02-0.029131*v_1_03+0.027303*v_1_04-0.044817*v_1_05+0.129715*v_1_06+0.343596*v_1_07-0.007394*v_1_08+0.036945*v_1_09-0.028737*v_1_10+0.006490*v_1_11+0.160583*v_1_12-0.022513*v_1_13-0.220929*v_1_14+0.129579*v_1_15+0.013360*v_1_16+0.020161*v_1_17-0.058713*v_1_18-0.237086*v_1_19+0.242633*v_1_20+0.022790*v_1_21-0.057628*v_1_22-0.045872*v_1_23-0.066223*v_1_24+0.006318*v_1_25-0.147093*v_1_26-0.024223*v_1_27-0.040515*v_1_28-0.025714*v_1_29-0.011629*v_1_30+0.042925*v_1_31+0.077983*v_1_32+0.022331*v_1_33+0.103722*v_1_34-0.054089*v_1_35-0.019024*v_1_36+0.057139*v_1_37-0.111831*v_1_38+0.067253*v_1_39+0.099102*v_1_40+0.135182*v_1_41+0.010571*v_1_42-0.017970*v_1_43+0.032068*v_1_44-0.033492*v_1_45-0.028049*v_1_46-0.037449*v_1_47+0.172682*v_1_48+0.016097*v_1_49+0.049245*v_1_50-0.096760*v_1_51-0.088336*v_1_52+0.231941*v_1_53+0.066014*v_1_54-0.042505*v_1_55+0.108459*v_1_56-0.137289*v_1_57-0.020837*v_1_58+0.000274*v_1_59-0.012707*v_1_60+0.023851*v_1_61-0.001153*v_1_62-0.083715*v_1_63-0.045738);\n    float v_2_07 = fun(-0.049054*v_1_00-0.064092*v_1_01-0.009303*v_1_02+0.091048*v_1_03+0.041963*v_1_04+0.071571*v_1_05-0.116161*v_1_06-0.009199*v_1_07-0.028050*v_1_08+0.109007*v_1_09+0.035222*v_1_10+0.052942*v_1_11-0.256152*v_1_12-0.015888*v_1_13+0.032352*v_1_14+0.215416*v_1_15-0.113211*v_1_16-0.038637*v_1_17+0.160005*v_1_18+0.204943*v_1_19-0.084699*v_1_20+0.169729*v_1_21-0.070630*v_1_22-0.155203*v_1_23+0.099114*v_1_24-0.082160*v_1_25+0.348775*v_1_26+0.075367*v_1_27+0.065602*v_1_28-0.059847*v_1_29-0.070868*v_1_30+0.102799*v_1_31+0.103740*v_1_32-0.008684*v_1_33-0.038303*v_1_34+0.028744*v_1_35+0.046329*v_1_36+0.035560*v_1_37-0.026201*v_1_38-0.031817*v_1_39-0.008845*v_1_40+0.045956*v_1_41-0.004966*v_1_42-0.040434*v_1_43-0.025753*v_1_44+0.012081*v_1_45+0.141337*v_1_46+0.077079*v_1_47+0.219484*v_1_48+0.087629*v_1_49-0.016214*v_1_50+0.045452*v_1_51-0.088374*v_1_52-0.003001*v_1_53+0.021538*v_1_54+0.116217*v_1_55+0.194081*v_1_56+0.064589*v_1_57+0.008192*v_1_58+0.026659*v_1_59+0.087408*v_1_60+0.034451*v_1_61+0.088239*v_1_62+0.063672*v_1_63-0.011650);\n    float v_2_08 = fun(-0.000891*v_1_00+0.037174*v_1_01+0.035635*v_1_02+0.013455*v_1_03-0.069656*v_1_04-0.026386*v_1_05+0.154870*v_1_06-0.124133*v_1_07-0.060302*v_1_08+0.075157*v_1_09+0.064238*v_1_10+0.033930*v_1_11+0.142169*v_1_12-0.034823*v_1_13-0.141791*v_1_14+0.308062*v_1_15+0.071166*v_1_16-0.101051*v_1_17+0.148833*v_1_18-0.237508*v_1_19-0.007577*v_1_20+0.058586*v_1_21-0.008530*v_1_22+0.119090*v_1_23+0.109259*v_1_24-0.074080*v_1_25-0.173627*v_1_26-0.001551*v_1_27+0.045630*v_1_28-0.154267*v_1_29-0.071145*v_1_30+0.028686*v_1_31+0.138934*v_1_32-0.046134*v_1_33-0.205212*v_1_34-0.005224*v_1_35-0.066314*v_1_36-0.004673*v_1_37-0.046198*v_1_38+0.033970*v_1_39-0.076263*v_1_40-0.067474*v_1_41-0.053773*v_1_42-0.030688*v_1_43+0.000307*v_1_44+0.053086*v_1_45-0.038117*v_1_46+0.279037*v_1_47-0.013427*v_1_48+0.112147*v_1_49-0.138102*v_1_50+0.070978*v_1_51-0.069293*v_1_52+0.065393*v_1_53+0.126960*v_1_54+0.005318*v_1_55-0.069379*v_1_56-0.077873*v_1_57-0.064549*v_1_58-0.034743*v_1_59-0.075528*v_1_60+0.069086*v_1_61-0.125627*v_1_62+0.086342*v_1_63-0.046347);\n    float v_2_09 = fun(-0.032540*v_1_00-0.137541*v_1_01+0.101021*v_1_02+0.040863*v_1_03+0.121088*v_1_04+0.031102*v_1_05-0.040727*v_1_06+0.130902*v_1_07+0.081037*v_1_08+0.073079*v_1_09-0.065653*v_1_10-0.083753*v_1_11-0.137497*v_1_12-0.076455*v_1_13+0.177779*v_1_14-0.196471*v_1_15+0.014860*v_1_16+0.021566*v_1_17+0.151096*v_1_18-0.113111*v_1_19-0.032137*v_1_20+0.078012*v_1_21-0.091503*v_1_22-0.098476*v_1_23+0.130862*v_1_24+0.095748*v_1_25+0.018123*v_1_26+0.030106*v_1_27-0.048689*v_1_28+0.015594*v_1_29+0.072637*v_1_30-0.135748*v_1_31+0.245782*v_1_32+0.051858*v_1_33-0.113820*v_1_34+0.048778*v_1_35-0.077600*v_1_36-0.043569*v_1_37-0.009787*v_1_38-0.058587*v_1_39+0.003101*v_1_40+0.138477*v_1_41-0.030714*v_1_42+0.007233*v_1_43+0.021504*v_1_44+0.017412*v_1_45-0.043149*v_1_46+0.064261*v_1_47-0.030618*v_1_48+0.018059*v_1_49-0.092716*v_1_50-0.037081*v_1_51-0.039639*v_1_52-0.244125*v_1_53-0.137004*v_1_54-0.023565*v_1_55-0.113035*v_1_56-0.157926*v_1_57+0.042674*v_1_58-0.053496*v_1_59-0.069275*v_1_60-0.002082*v_1_61+0.141601*v_1_62+0.124829*v_1_63-0.061572);\n    float v_2_10 = fun( 0.290386*v_1_00-0.055151*v_1_01-0.012646*v_1_02-0.039341*v_1_03-0.025366*v_1_04-0.034720*v_1_05-0.057582*v_1_06-0.224825*v_1_07-0.061306*v_1_08+0.003922*v_1_09+0.033667*v_1_10-0.050187*v_1_11-0.055425*v_1_12+0.010525*v_1_13-0.107164*v_1_14+0.020638*v_1_15+0.031683*v_1_16+0.047446*v_1_17+0.103024*v_1_18-0.122056*v_1_19-0.058516*v_1_20+0.048436*v_1_21-0.000058*v_1_22+0.045718*v_1_23-0.009659*v_1_24-0.037452*v_1_25-0.117138*v_1_26-0.042320*v_1_27+0.021043*v_1_28-0.020780*v_1_29+0.010015*v_1_30-0.043874*v_1_31-0.062205*v_1_32-0.086181*v_1_33+0.120951*v_1_34-0.018674*v_1_35-0.051633*v_1_36+0.016197*v_1_37-0.064681*v_1_38-0.005301*v_1_39-0.024871*v_1_40-0.049132*v_1_41+0.020755*v_1_42-0.005837*v_1_43+0.074336*v_1_44-0.057820*v_1_45-0.060769*v_1_46+0.072127*v_1_47-0.255633*v_1_48-0.073757*v_1_49+0.159994*v_1_50+0.031299*v_1_51-0.076716*v_1_52+0.231272*v_1_53-0.039419*v_1_54+0.006703*v_1_55+0.051666*v_1_56+0.022057*v_1_57-0.074899*v_1_58-0.063821*v_1_59+0.002305*v_1_60-0.036243*v_1_61-0.016563*v_1_62+0.002557*v_1_63-0.031302);\n    float v_2_11 = fun( 0.026524*v_1_00-0.045045*v_1_01+0.002808*v_1_02-0.037124*v_1_03+0.013424*v_1_04-0.019687*v_1_05+0.103888*v_1_06-0.035798*v_1_07+0.003701*v_1_08-0.011704*v_1_09+0.004628*v_1_10-0.071057*v_1_11-0.008859*v_1_12+0.000584*v_1_13+0.190465*v_1_14+0.209680*v_1_15-0.036645*v_1_16-0.095986*v_1_17+0.071253*v_1_18+0.039880*v_1_19-0.082014*v_1_20+0.046031*v_1_21-0.017396*v_1_22-0.037866*v_1_23-0.020641*v_1_24+0.021218*v_1_25+0.121622*v_1_26+0.030982*v_1_27-0.003318*v_1_28+0.018139*v_1_29+0.053375*v_1_30+0.101832*v_1_31-0.146065*v_1_32-0.061475*v_1_33-0.038460*v_1_34+0.010538*v_1_35-0.001573*v_1_36-0.077988*v_1_37+0.151403*v_1_38+0.024668*v_1_39+0.014445*v_1_40+0.037147*v_1_41+0.048779*v_1_42+0.034143*v_1_43+0.059742*v_1_44-0.011403*v_1_45+0.084758*v_1_46+0.012009*v_1_47+0.007174*v_1_48-0.004666*v_1_49+0.059770*v_1_50+0.115192*v_1_51+0.030357*v_1_52-0.207609*v_1_53-0.027997*v_1_54+0.021363*v_1_55+0.099245*v_1_56+0.080460*v_1_57+0.065775*v_1_58+0.033129*v_1_59+0.044693*v_1_60-0.048957*v_1_61-0.077817*v_1_62+0.036288*v_1_63-0.066653);\n    float v_2_12 = fun(-0.070386*v_1_00+0.052948*v_1_01-0.042500*v_1_02+0.047282*v_1_03+0.025260*v_1_04+0.131321*v_1_05-0.257915*v_1_06+0.099309*v_1_07-0.089104*v_1_08-0.028367*v_1_09+0.079093*v_1_10-0.078358*v_1_11-0.036319*v_1_12+0.130834*v_1_13-0.359926*v_1_14+0.039374*v_1_15-0.004614*v_1_16+0.082259*v_1_17-0.123608*v_1_18-0.110275*v_1_19+0.001329*v_1_20+0.002514*v_1_21+0.023275*v_1_22+0.073062*v_1_23-0.213277*v_1_24+0.014087*v_1_25-0.067947*v_1_26+0.031123*v_1_27-0.008709*v_1_28-0.101559*v_1_29+0.054124*v_1_30-0.024036*v_1_31+0.005426*v_1_32-0.176637*v_1_33-0.239188*v_1_34-0.027527*v_1_35+0.106400*v_1_36+0.205420*v_1_37-0.013339*v_1_38+0.043838*v_1_39-0.055377*v_1_40+0.113929*v_1_41+0.052142*v_1_42-0.032742*v_1_43+0.096733*v_1_44-0.067038*v_1_45+0.024640*v_1_46+0.029677*v_1_47-0.057010*v_1_48-0.077632*v_1_49+0.255702*v_1_50-0.213174*v_1_51-0.141738*v_1_52-0.031315*v_1_53+0.150495*v_1_54+0.122954*v_1_55-0.062877*v_1_56-0.202118*v_1_57-0.026556*v_1_58+0.135034*v_1_59-0.154258*v_1_60+0.004900*v_1_61-0.093458*v_1_62+0.145635*v_1_63+0.188409);\n    float v_2_13 = fun( 0.102896*v_1_00+0.132588*v_1_01-0.026726*v_1_02+0.026576*v_1_03+0.008145*v_1_04+0.092777*v_1_05+0.001342*v_1_06-0.227200*v_1_07-0.006547*v_1_08+0.028998*v_1_09-0.009280*v_1_10-0.027162*v_1_11-0.105840*v_1_12-0.014192*v_1_13+0.097730*v_1_14-0.265727*v_1_15-0.046303*v_1_16-0.083002*v_1_17+0.094294*v_1_18+0.172596*v_1_19+0.036173*v_1_20+0.058732*v_1_21-0.035230*v_1_22-0.021967*v_1_23-0.046883*v_1_24-0.079157*v_1_25-0.070754*v_1_26-0.013511*v_1_27+0.005162*v_1_28+0.003202*v_1_29-0.054908*v_1_30-0.048946*v_1_31-0.080689*v_1_32-0.002217*v_1_33-0.053794*v_1_34-0.057295*v_1_35+0.043063*v_1_36-0.015499*v_1_37+0.041203*v_1_38-0.024652*v_1_39+0.015546*v_1_40+0.068395*v_1_41-0.072654*v_1_42-0.015718*v_1_43+0.099289*v_1_44-0.030368*v_1_45-0.017012*v_1_46-0.068940*v_1_47+0.103993*v_1_48+0.033860*v_1_49+0.018307*v_1_50-0.067980*v_1_51-0.038447*v_1_52+0.007678*v_1_53-0.049110*v_1_54+0.075390*v_1_55-0.128384*v_1_56-0.031055*v_1_57+0.093045*v_1_58+0.039915*v_1_59+0.010956*v_1_60-0.047911*v_1_61-0.071262*v_1_62-0.054446*v_1_63-0.194175);\n    float v_2_14 = fun( 0.097249*v_1_00-0.107658*v_1_01+0.047073*v_1_02-0.028581*v_1_03-0.036623*v_1_04-0.129108*v_1_05-0.070894*v_1_06-0.123021*v_1_07-0.037279*v_1_08-0.012234*v_1_09-0.078434*v_1_10-0.007059*v_1_11-0.257766*v_1_12-0.014171*v_1_13-0.133103*v_1_14-0.208169*v_1_15+0.048927*v_1_16-0.087562*v_1_17-0.089354*v_1_18-0.050608*v_1_19+0.112024*v_1_20+0.001560*v_1_21+0.019680*v_1_22-0.200185*v_1_23+0.000350*v_1_24+0.130224*v_1_25-0.044145*v_1_26+0.030221*v_1_27+0.079815*v_1_28+0.022414*v_1_29+0.062566*v_1_30-0.071945*v_1_31-0.051269*v_1_32+0.102051*v_1_33+0.024576*v_1_34-0.015681*v_1_35-0.023085*v_1_36-0.055362*v_1_37-0.056835*v_1_38+0.054811*v_1_39-0.033753*v_1_40-0.040839*v_1_41+0.061439*v_1_42+0.009153*v_1_43-0.114843*v_1_44+0.072661*v_1_45+0.009317*v_1_46+0.040278*v_1_47+0.068560*v_1_48-0.101806*v_1_49+0.003109*v_1_50-0.034983*v_1_51-0.028217*v_1_52-0.074423*v_1_53-0.147630*v_1_54-0.107716*v_1_55+0.164659*v_1_56+0.035496*v_1_57-0.003968*v_1_58+0.068453*v_1_59+0.019834*v_1_60-0.028257*v_1_61+0.030428*v_1_62+0.021704*v_1_63-0.153423);\n    float v_2_15 = fun( 0.318060*v_1_00-0.097002*v_1_01-0.017498*v_1_02-0.016142*v_1_03+0.018641*v_1_04-0.007036*v_1_05-0.134782*v_1_06+0.035184*v_1_07-0.063777*v_1_08-0.119002*v_1_09+0.143757*v_1_10-0.020829*v_1_11-0.070806*v_1_12+0.021214*v_1_13+0.067304*v_1_14-0.136263*v_1_15+0.048198*v_1_16+0.130174*v_1_17-0.162235*v_1_18-0.310550*v_1_19+0.047101*v_1_20+0.000390*v_1_21+0.036958*v_1_22+0.044357*v_1_23+0.150679*v_1_24-0.086537*v_1_25+0.061050*v_1_26+0.026752*v_1_27+0.033871*v_1_28+0.096044*v_1_29-0.062106*v_1_30-0.001273*v_1_31+0.141453*v_1_32-0.174016*v_1_33+0.089377*v_1_34+0.116798*v_1_35-0.089918*v_1_36+0.123172*v_1_37+0.128447*v_1_38-0.007015*v_1_39+0.018107*v_1_40+0.180308*v_1_41-0.085415*v_1_42-0.030752*v_1_43-0.131683*v_1_44-0.003770*v_1_45+0.015266*v_1_46+0.056423*v_1_47+0.029254*v_1_48+0.041463*v_1_49+0.106484*v_1_50+0.244691*v_1_51+0.097298*v_1_52-0.061043*v_1_53+0.070898*v_1_54-0.079493*v_1_55+0.202869*v_1_56+0.073435*v_1_57+0.037280*v_1_58-0.094291*v_1_59+0.049520*v_1_60-0.048514*v_1_61-0.161530*v_1_62+0.159415*v_1_63+0.024619);\n    float v_2_16 = fun( 0.147201*v_1_00+0.034769*v_1_01-0.031108*v_1_02-0.030289*v_1_03+0.032987*v_1_04+0.035047*v_1_05+0.156383*v_1_06+0.053084*v_1_07-0.007473*v_1_08-0.004496*v_1_09+0.123424*v_1_10-0.005311*v_1_11+0.075165*v_1_12-0.025234*v_1_13+0.048587*v_1_14-0.070836*v_1_15-0.053717*v_1_16-0.060380*v_1_17-0.077900*v_1_18+0.533767*v_1_19-0.009047*v_1_20-0.021228*v_1_21-0.032255*v_1_22-0.016347*v_1_23-0.097184*v_1_24+0.016580*v_1_25-0.030301*v_1_26-0.009585*v_1_27-0.011768*v_1_28-0.043063*v_1_29-0.058895*v_1_30-0.001107*v_1_31-0.058639*v_1_32-0.031642*v_1_33+0.264479*v_1_34+0.113643*v_1_35-0.037472*v_1_36+0.006160*v_1_37+0.027431*v_1_38+0.044727*v_1_39-0.042013*v_1_40-0.086714*v_1_41+0.011766*v_1_42-0.011616*v_1_43+0.064697*v_1_44+0.031223*v_1_45-0.003964*v_1_46+0.020819*v_1_47+0.001451*v_1_48-0.059511*v_1_49-0.064650*v_1_50-0.141412*v_1_51-0.077150*v_1_52-0.135488*v_1_53+0.054462*v_1_54-0.037431*v_1_55-0.010287*v_1_56+0.026739*v_1_57+0.019533*v_1_58-0.115860*v_1_59+0.001498*v_1_60+0.019573*v_1_61-0.128926*v_1_62-0.021824*v_1_63-0.118782);\n    float v_2_17 = fun( 0.095144*v_1_00-0.034258*v_1_01+0.015414*v_1_02+0.093834*v_1_03+0.009984*v_1_04-0.196997*v_1_05+0.078619*v_1_06-0.057782*v_1_07-0.076626*v_1_08-0.029486*v_1_09-0.055051*v_1_10-0.056482*v_1_11-0.116257*v_1_12-0.042562*v_1_13+0.095955*v_1_14+0.254019*v_1_15+0.125456*v_1_16+0.024856*v_1_17+0.072307*v_1_18+0.434768*v_1_19+0.286832*v_1_20+0.119274*v_1_21-0.059628*v_1_22-0.115188*v_1_23-0.102288*v_1_24-0.115091*v_1_25-0.024814*v_1_26-0.002879*v_1_27-0.108488*v_1_28+0.072857*v_1_29+0.023908*v_1_30-0.014248*v_1_31-0.095894*v_1_32-0.032524*v_1_33-0.130427*v_1_34+0.043149*v_1_35-0.038313*v_1_36-0.076181*v_1_37+0.150665*v_1_38+0.096981*v_1_39-0.091956*v_1_40+0.012699*v_1_41+0.046980*v_1_42+0.073128*v_1_43+0.084351*v_1_44-0.024285*v_1_45+0.057245*v_1_46+0.077333*v_1_47+0.050003*v_1_48-0.026704*v_1_49-0.053772*v_1_50+0.231248*v_1_51-0.046740*v_1_52-0.195443*v_1_53-0.178476*v_1_54-0.096862*v_1_55-0.084065*v_1_56-0.026103*v_1_57+0.131859*v_1_58-0.043820*v_1_59+0.059325*v_1_60-0.135251*v_1_61+0.075508*v_1_62+0.213230*v_1_63+0.112285);\n    float v_2_18 = fun(-0.074823*v_1_00-0.008639*v_1_01-0.037473*v_1_02+0.020968*v_1_03+0.016166*v_1_04+0.051208*v_1_05+0.030274*v_1_06+0.151686*v_1_07+0.006597*v_1_08+0.040258*v_1_09+0.039151*v_1_10+0.089726*v_1_11+0.043513*v_1_12-0.000917*v_1_13-0.247656*v_1_14+0.659646*v_1_15-0.005295*v_1_16+0.072994*v_1_17-0.044763*v_1_18+0.062800*v_1_19-0.178046*v_1_20+0.095272*v_1_21+0.044849*v_1_22+0.020821*v_1_23-0.024507*v_1_24+0.115631*v_1_25-0.040357*v_1_26+0.030084*v_1_27-0.000434*v_1_28-0.000875*v_1_29+0.041111*v_1_30+0.004606*v_1_31-0.034878*v_1_32-0.016758*v_1_33+0.043220*v_1_34-0.072036*v_1_35+0.031581*v_1_36-0.029288*v_1_37-0.023722*v_1_38+0.080657*v_1_39-0.046068*v_1_40-0.005445*v_1_41+0.032326*v_1_42-0.037803*v_1_43+0.014747*v_1_44+0.017115*v_1_45-0.014810*v_1_46-0.023985*v_1_47-0.021938*v_1_48+0.007481*v_1_49+0.020594*v_1_50+0.142448*v_1_51+0.037638*v_1_52-0.048612*v_1_53-0.057975*v_1_54+0.053047*v_1_55+0.065897*v_1_56+0.036405*v_1_57-0.065867*v_1_58+0.027132*v_1_59-0.004833*v_1_60+0.047071*v_1_61-0.031596*v_1_62+0.076818*v_1_63-0.022958);\n    float v_2_19 = fun( 0.095679*v_1_00-0.036472*v_1_01+0.052574*v_1_02+0.028556*v_1_03+0.026815*v_1_04-0.127829*v_1_05+0.060295*v_1_06+0.106021*v_1_07+0.048702*v_1_08-0.003575*v_1_09-0.029194*v_1_10+0.038937*v_1_11-0.053299*v_1_12-0.007953*v_1_13+0.170006*v_1_14+0.049977*v_1_15+0.012446*v_1_16+0.064353*v_1_17+0.131522*v_1_18-0.053832*v_1_19-0.145525*v_1_20-0.067829*v_1_21-0.078829*v_1_22+0.044281*v_1_23-0.016499*v_1_24+0.017302*v_1_25+0.125538*v_1_26+0.093448*v_1_27+0.024834*v_1_28+0.040568*v_1_29+0.153339*v_1_30+0.027570*v_1_31+0.120489*v_1_32-0.003057*v_1_33+0.020171*v_1_34-0.032555*v_1_35+0.039928*v_1_36+0.050188*v_1_37-0.114904*v_1_38+0.011750*v_1_39+0.036389*v_1_40+0.184682*v_1_41+0.022356*v_1_42+0.022414*v_1_43-0.087043*v_1_44-0.043563*v_1_45+0.039863*v_1_46-0.171541*v_1_47+0.082198*v_1_48+0.044386*v_1_49+0.113120*v_1_50+0.069231*v_1_51+0.090735*v_1_52+0.093352*v_1_53-0.083231*v_1_54-0.162849*v_1_55+0.092392*v_1_56-0.109702*v_1_57-0.013519*v_1_58+0.169150*v_1_59+0.035072*v_1_60+0.032225*v_1_61+0.013814*v_1_62-0.090252*v_1_63-0.129754);\n    float v_2_20 = fun( 0.035495*v_1_00-0.034746*v_1_01-0.057071*v_1_02+0.077991*v_1_03+0.013007*v_1_04-0.130168*v_1_05+0.199667*v_1_06-0.048282*v_1_07-0.069962*v_1_08+0.004368*v_1_09+0.005981*v_1_10+0.077606*v_1_11+0.056434*v_1_12+0.027429*v_1_13-0.280157*v_1_14-0.200260*v_1_15-0.007444*v_1_16-0.168778*v_1_17-0.161652*v_1_18-0.172109*v_1_19+0.118138*v_1_20+0.080745*v_1_21+0.125826*v_1_22+0.056150*v_1_23-0.260738*v_1_24-0.083704*v_1_25+0.077948*v_1_26-0.029848*v_1_27-0.012768*v_1_28+0.093701*v_1_29+0.019933*v_1_30+0.066294*v_1_31+0.125842*v_1_32-0.079273*v_1_33+0.283108*v_1_34+0.033387*v_1_35+0.071962*v_1_36+0.006211*v_1_37-0.005184*v_1_38-0.139697*v_1_39-0.115251*v_1_40-0.084687*v_1_41-0.003867*v_1_42-0.024396*v_1_43-0.109638*v_1_44+0.131472*v_1_45-0.040307*v_1_46-0.049689*v_1_47-0.047194*v_1_48-0.037479*v_1_49+0.018213*v_1_50+0.127044*v_1_51-0.035110*v_1_52+0.046599*v_1_53+0.099048*v_1_54+0.036148*v_1_55-0.333003*v_1_56+0.115531*v_1_57-0.027569*v_1_58-0.141175*v_1_59-0.107419*v_1_60-0.046728*v_1_61-0.084667*v_1_62-0.039256*v_1_63-0.077893);\n    float v_2_21 = fun(-0.145870*v_1_00-0.179397*v_1_01-0.001598*v_1_02+0.078662*v_1_03-0.017292*v_1_04-0.106816*v_1_05-0.082902*v_1_06+0.026821*v_1_07+0.109633*v_1_08+0.051771*v_1_09-0.066174*v_1_10-0.042033*v_1_11+0.017372*v_1_12-0.057279*v_1_13-0.487842*v_1_14+0.215429*v_1_15+0.046850*v_1_16+0.132580*v_1_17-0.032096*v_1_18+0.067209*v_1_19+0.051961*v_1_20-0.232110*v_1_21-0.026262*v_1_22-0.033424*v_1_23+0.086529*v_1_24+0.001596*v_1_25-0.041739*v_1_26+0.032346*v_1_27+0.010403*v_1_28+0.124268*v_1_29+0.038135*v_1_30-0.095907*v_1_31+0.077675*v_1_32+0.053996*v_1_33+0.106597*v_1_34+0.048009*v_1_35-0.003231*v_1_36+0.079841*v_1_37+0.020884*v_1_38+0.052181*v_1_39+0.033267*v_1_40+0.107384*v_1_41-0.064603*v_1_42+0.013943*v_1_43+0.012131*v_1_44-0.016179*v_1_45-0.070350*v_1_46-0.032281*v_1_47-0.166642*v_1_48+0.008364*v_1_49+0.177071*v_1_50-0.158398*v_1_51+0.173566*v_1_52-0.038086*v_1_53+0.028295*v_1_54-0.106559*v_1_55+0.131552*v_1_56-0.167748*v_1_57-0.044889*v_1_58+0.089807*v_1_59+0.013079*v_1_60-0.033965*v_1_61+0.058036*v_1_62+0.024121*v_1_63-0.129454);\n    float v_2_22 = fun( 0.163506*v_1_00+0.116730*v_1_01+0.017614*v_1_02+0.079399*v_1_03-0.036294*v_1_04-0.017938*v_1_05+0.055932*v_1_06+0.219972*v_1_07+0.005499*v_1_08+0.034809*v_1_09+0.021454*v_1_10-0.007493*v_1_11-0.181407*v_1_12-0.044627*v_1_13+0.174083*v_1_14+0.105369*v_1_15-0.037037*v_1_16+0.058805*v_1_17+0.131395*v_1_18+0.000066*v_1_19-0.258702*v_1_20-0.052686*v_1_21-0.002926*v_1_22-0.000698*v_1_23+0.063669*v_1_24-0.041365*v_1_25+0.031462*v_1_26+0.003424*v_1_27+0.024556*v_1_28-0.005972*v_1_29+0.058226*v_1_30-0.008921*v_1_31-0.051907*v_1_32-0.011668*v_1_33-0.048709*v_1_34-0.012438*v_1_35-0.157490*v_1_36+0.065145*v_1_37+0.024894*v_1_38+0.074607*v_1_39+0.030731*v_1_40+0.056638*v_1_41-0.024184*v_1_42-0.045461*v_1_43+0.024914*v_1_44-0.096972*v_1_45+0.013692*v_1_46+0.053290*v_1_47-0.168386*v_1_48-0.004690*v_1_49-0.117601*v_1_50-0.067415*v_1_51+0.043451*v_1_52+0.183752*v_1_53-0.118766*v_1_54+0.024181*v_1_55+0.221312*v_1_56-0.031017*v_1_57+0.031752*v_1_58+0.012803*v_1_59+0.018574*v_1_60-0.107304*v_1_61-0.036710*v_1_62-0.076097*v_1_63+0.017912);\n    float v_2_23 = fun( 0.021726*v_1_00+0.024698*v_1_01+0.051796*v_1_02-0.045750*v_1_03-0.039828*v_1_04+0.069389*v_1_05+0.038318*v_1_06-0.086662*v_1_07+0.053999*v_1_08+0.050428*v_1_09+0.016212*v_1_10+0.017871*v_1_11+0.060622*v_1_12-0.103163*v_1_13+0.156376*v_1_14-0.382265*v_1_15-0.064779*v_1_16-0.129881*v_1_17+0.179816*v_1_18-0.054466*v_1_19+0.167942*v_1_20+0.036257*v_1_21-0.052102*v_1_22+0.160203*v_1_23-0.030206*v_1_24+0.037662*v_1_25-0.227760*v_1_26+0.046208*v_1_27-0.013000*v_1_28-0.027015*v_1_29+0.021135*v_1_30+0.088139*v_1_31+0.057885*v_1_32-0.023003*v_1_33+0.063294*v_1_34-0.014417*v_1_35+0.033509*v_1_36-0.124639*v_1_37+0.030170*v_1_38-0.014527*v_1_39-0.087254*v_1_40-0.093705*v_1_41-0.059968*v_1_42-0.072205*v_1_43-0.226725*v_1_44+0.011781*v_1_45+0.033925*v_1_46+0.205980*v_1_47+0.074133*v_1_48-0.046433*v_1_49-0.147946*v_1_50+0.213612*v_1_51-0.012681*v_1_52-0.059909*v_1_53-0.091516*v_1_54+0.063973*v_1_55+0.243457*v_1_56+0.121418*v_1_57+0.050073*v_1_58+0.050494*v_1_59+0.068534*v_1_60-0.059785*v_1_61+0.033478*v_1_62-0.112038*v_1_63-0.128393);\n    float v_2_24 = fun(-0.050544*v_1_00-0.180363*v_1_01+0.061462*v_1_02-0.071600*v_1_03+0.006621*v_1_04+0.179442*v_1_05+0.021326*v_1_06+0.050782*v_1_07-0.012582*v_1_08+0.042399*v_1_09+0.030369*v_1_10-0.043486*v_1_11-0.044804*v_1_12-0.071367*v_1_13-0.045773*v_1_14-0.001165*v_1_15-0.120713*v_1_16-0.024949*v_1_17+0.195363*v_1_18-0.193877*v_1_19+0.121901*v_1_20-0.147307*v_1_21+0.146943*v_1_22-0.128370*v_1_23+0.124716*v_1_24+0.176166*v_1_25+0.193454*v_1_26-0.057714*v_1_27-0.053509*v_1_28+0.022527*v_1_29+0.064206*v_1_30-0.131882*v_1_31-0.155334*v_1_32-0.097740*v_1_33+0.007541*v_1_34+0.033374*v_1_35-0.140058*v_1_36-0.065524*v_1_37+0.060766*v_1_38+0.018226*v_1_39-0.071659*v_1_40+0.006323*v_1_41+0.058930*v_1_42-0.083008*v_1_43+0.035524*v_1_44+0.036348*v_1_45-0.005736*v_1_46+0.058605*v_1_47-0.152259*v_1_48-0.096653*v_1_49-0.070626*v_1_50-0.018521*v_1_51-0.024582*v_1_52+0.027870*v_1_53+0.105787*v_1_54-0.052791*v_1_55-0.155543*v_1_56+0.042659*v_1_57-0.056554*v_1_58+0.103733*v_1_59-0.104800*v_1_60+0.065039*v_1_61+0.096187*v_1_62+0.044322*v_1_63+0.043559);\n    float v_2_25 = fun(-0.143788*v_1_00-0.124667*v_1_01-0.126120*v_1_02+0.056341*v_1_03+0.071410*v_1_04-0.093629*v_1_05+0.162966*v_1_06-0.172463*v_1_07+0.100926*v_1_08+0.020944*v_1_09-0.004375*v_1_10+0.085489*v_1_11+0.202547*v_1_12+0.038963*v_1_13-0.014876*v_1_14+0.243997*v_1_15+0.012334*v_1_16-0.032969*v_1_17+0.031341*v_1_18+0.160123*v_1_19+0.122372*v_1_20-0.142253*v_1_21+0.044832*v_1_22-0.116035*v_1_23+0.001555*v_1_24+0.051855*v_1_25-0.068999*v_1_26-0.044933*v_1_27+0.029653*v_1_28+0.002120*v_1_29-0.003572*v_1_30-0.029879*v_1_31+0.180541*v_1_32-0.114006*v_1_33+0.064833*v_1_34-0.007295*v_1_35+0.011442*v_1_36-0.139765*v_1_37+0.024904*v_1_38-0.088994*v_1_39+0.077624*v_1_40-0.013598*v_1_41+0.013260*v_1_42+0.025051*v_1_43-0.096173*v_1_44+0.010820*v_1_45-0.032819*v_1_46-0.109230*v_1_47-0.208038*v_1_48+0.055067*v_1_49+0.130348*v_1_50-0.062290*v_1_51+0.149416*v_1_52-0.181755*v_1_53-0.042960*v_1_54-0.109323*v_1_55+0.010075*v_1_56-0.012195*v_1_57-0.027754*v_1_58+0.022066*v_1_59-0.018877*v_1_60+0.020224*v_1_61-0.060787*v_1_62-0.084639*v_1_63+0.167064);\n    float v_2_26 = fun(-0.250008*v_1_00-0.133694*v_1_01+0.049802*v_1_02+0.020565*v_1_03-0.061965*v_1_04+0.004078*v_1_05-0.247580*v_1_06-0.172765*v_1_07+0.031031*v_1_08+0.029313*v_1_09+0.075740*v_1_10+0.015441*v_1_11+0.050413*v_1_12-0.017299*v_1_13+0.469505*v_1_14-0.488017*v_1_15-0.008758*v_1_16+0.019012*v_1_17-0.028467*v_1_18+0.002662*v_1_19+0.196276*v_1_20+0.026125*v_1_21-0.071135*v_1_22+0.103115*v_1_23-0.123745*v_1_24+0.135102*v_1_25-0.000806*v_1_26+0.021510*v_1_27+0.001487*v_1_28+0.035961*v_1_29-0.065339*v_1_30-0.029646*v_1_31+0.167113*v_1_32-0.028877*v_1_33-0.091073*v_1_34-0.039901*v_1_35-0.059825*v_1_36+0.061069*v_1_37+0.038106*v_1_38+0.103084*v_1_39+0.096507*v_1_40+0.078328*v_1_41-0.016708*v_1_42-0.007555*v_1_43-0.016339*v_1_44+0.000596*v_1_45+0.021349*v_1_46-0.101175*v_1_47-0.101273*v_1_48-0.057021*v_1_49-0.015717*v_1_50+0.199943*v_1_51-0.033852*v_1_52-0.245972*v_1_53-0.030291*v_1_54+0.190247*v_1_55+0.133671*v_1_56+0.077213*v_1_57+0.056085*v_1_58+0.064699*v_1_59-0.043193*v_1_60-0.023179*v_1_61-0.171582*v_1_62+0.043448*v_1_63-0.139438);\n    float v_2_27 = fun( 0.042914*v_1_00-0.056391*v_1_01+0.042633*v_1_02+0.058883*v_1_03+0.049711*v_1_04+0.046266*v_1_05+0.397336*v_1_06-0.056700*v_1_07-0.016119*v_1_08+0.024251*v_1_09+0.059287*v_1_10-0.025932*v_1_11+0.128445*v_1_12-0.015435*v_1_13-0.061154*v_1_14+0.446170*v_1_15-0.040126*v_1_16-0.107514*v_1_17-0.075646*v_1_18+0.216301*v_1_19+0.120494*v_1_20-0.082604*v_1_21-0.018787*v_1_22+0.005329*v_1_23+0.044530*v_1_24+0.079088*v_1_25-0.025080*v_1_26-0.065861*v_1_27-0.018091*v_1_28-0.008258*v_1_29-0.088934*v_1_30-0.065546*v_1_31+0.016943*v_1_32-0.053246*v_1_33-0.093756*v_1_34+0.088500*v_1_35+0.030016*v_1_36+0.017786*v_1_37-0.040298*v_1_38-0.123512*v_1_39+0.001288*v_1_40+0.064996*v_1_41+0.004272*v_1_42-0.036213*v_1_43-0.171982*v_1_44+0.047645*v_1_45-0.053825*v_1_46-0.060183*v_1_47+0.183344*v_1_48+0.007293*v_1_49+0.087602*v_1_50-0.043304*v_1_51+0.022211*v_1_52+0.129382*v_1_53+0.006573*v_1_54+0.119095*v_1_55-0.040031*v_1_56+0.001212*v_1_57-0.011027*v_1_58+0.031518*v_1_59-0.018907*v_1_60+0.042672*v_1_61+0.042982*v_1_62+0.047723*v_1_63+0.015713);\n    float v_2_28 = fun(-0.247434*v_1_00+0.087006*v_1_01-0.001838*v_1_02+0.103970*v_1_03+0.044078*v_1_04-0.035469*v_1_05+0.096247*v_1_06-0.221772*v_1_07+0.027120*v_1_08-0.013663*v_1_09+0.041071*v_1_10-0.096205*v_1_11+0.378040*v_1_12-0.040731*v_1_13-0.146890*v_1_14+0.057755*v_1_15+0.072481*v_1_16-0.025617*v_1_17+0.116804*v_1_18-0.012006*v_1_19+0.118558*v_1_20+0.099509*v_1_21-0.054052*v_1_22-0.029560*v_1_23+0.015257*v_1_24-0.018572*v_1_25+0.006983*v_1_26-0.023485*v_1_27-0.014802*v_1_28+0.033256*v_1_29+0.026986*v_1_30-0.046895*v_1_31+0.099273*v_1_32+0.132610*v_1_33+0.089164*v_1_34-0.012252*v_1_35-0.001675*v_1_36-0.022203*v_1_37+0.022235*v_1_38-0.090554*v_1_39-0.014280*v_1_40-0.233611*v_1_41-0.031846*v_1_42-0.034070*v_1_43-0.009919*v_1_44+0.010189*v_1_45-0.050531*v_1_46+0.049227*v_1_47-0.012636*v_1_48-0.024750*v_1_49-0.019146*v_1_50+0.097287*v_1_51+0.037336*v_1_52+0.164855*v_1_53+0.035434*v_1_54+0.145338*v_1_55-0.168737*v_1_56-0.028701*v_1_57-0.042239*v_1_58+0.038589*v_1_59+0.000372*v_1_60-0.013494*v_1_61-0.128969*v_1_62+0.048280*v_1_63-0.030141);\n    float v_2_29 = fun( 0.015752*v_1_00-0.095414*v_1_01-0.025556*v_1_02-0.046414*v_1_03-0.020304*v_1_04+0.022741*v_1_05-0.044633*v_1_06-0.072512*v_1_07-0.082407*v_1_08+0.001178*v_1_09-0.056977*v_1_10+0.128317*v_1_11-0.142663*v_1_12+0.026767*v_1_13+0.118596*v_1_14+0.047216*v_1_15-0.000868*v_1_16+0.127119*v_1_17-0.008348*v_1_18-0.079873*v_1_19-0.053913*v_1_20-0.012249*v_1_21-0.018671*v_1_22-0.093717*v_1_23+0.057636*v_1_24+0.020238*v_1_25-0.045780*v_1_26-0.020037*v_1_27+0.011733*v_1_28-0.024091*v_1_29+0.059316*v_1_30+0.025354*v_1_31+0.019169*v_1_32-0.015251*v_1_33-0.029542*v_1_34-0.017117*v_1_35+0.032121*v_1_36+0.015890*v_1_37-0.149591*v_1_38+0.029245*v_1_39+0.036584*v_1_40+0.020786*v_1_41-0.008920*v_1_42+0.034699*v_1_43-0.075346*v_1_44-0.007095*v_1_45+0.047784*v_1_46-0.001412*v_1_47-0.033727*v_1_48+0.062673*v_1_49-0.020166*v_1_50-0.063980*v_1_51-0.077553*v_1_52-0.202349*v_1_53-0.144119*v_1_54-0.041573*v_1_55+0.122908*v_1_56+0.050519*v_1_57-0.128274*v_1_58-0.029806*v_1_59+0.044142*v_1_60+0.020201*v_1_61+0.099513*v_1_62-0.054130*v_1_63+0.006593);\n    float v_2_30 = fun( 0.048807*v_1_00+0.026975*v_1_01-0.019485*v_1_02+0.004008*v_1_03+0.016719*v_1_04+0.047581*v_1_05+0.502410*v_1_06+0.160158*v_1_07+0.027909*v_1_08+0.046359*v_1_09-0.079433*v_1_10-0.053918*v_1_11-0.103968*v_1_12-0.003395*v_1_13+0.014385*v_1_14-0.173457*v_1_15-0.001820*v_1_16+0.012140*v_1_17+0.003838*v_1_18-0.226680*v_1_19+0.069451*v_1_20-0.034824*v_1_21+0.000264*v_1_22-0.086546*v_1_23-0.097731*v_1_24-0.065381*v_1_25+0.054259*v_1_26+0.025402*v_1_27-0.020453*v_1_28+0.002425*v_1_29-0.001751*v_1_30-0.092841*v_1_31+0.211274*v_1_32+0.005983*v_1_33+0.042153*v_1_34-0.097111*v_1_35+0.047695*v_1_36+0.077482*v_1_37-0.024398*v_1_38+0.054729*v_1_39-0.019457*v_1_40+0.088513*v_1_41-0.018716*v_1_42+0.055683*v_1_43+0.029142*v_1_44+0.024234*v_1_45-0.006112*v_1_46-0.028955*v_1_47+0.206247*v_1_48+0.074527*v_1_49-0.240541*v_1_50-0.090128*v_1_51-0.086299*v_1_52+0.026007*v_1_53+0.041443*v_1_54-0.044002*v_1_55+0.012283*v_1_56-0.002342*v_1_57+0.074317*v_1_58+0.014854*v_1_59-0.031060*v_1_60-0.031747*v_1_61+0.078449*v_1_62-0.009373*v_1_63-0.035445);\n    float v_2_31 = fun(-0.222115*v_1_00+0.040301*v_1_01-0.016525*v_1_02+0.046240*v_1_03+0.100368*v_1_04+0.137614*v_1_05+0.160493*v_1_06-0.150416*v_1_07+0.005644*v_1_08-0.026327*v_1_09+0.079841*v_1_10+0.125470*v_1_11-0.021651*v_1_12-0.003291*v_1_13-0.111326*v_1_14-0.016486*v_1_15+0.029922*v_1_16-0.052471*v_1_17+0.058107*v_1_18+0.060459*v_1_19+0.089466*v_1_20+0.168591*v_1_21-0.091046*v_1_22+0.048474*v_1_23-0.005327*v_1_24-0.168475*v_1_25-0.629512*v_1_26+0.012670*v_1_27-0.122494*v_1_28-0.131098*v_1_29+0.002919*v_1_30-0.073231*v_1_31-0.085928*v_1_32-0.124500*v_1_33+0.056340*v_1_34-0.068095*v_1_35+0.176562*v_1_36-0.100797*v_1_37+0.044769*v_1_38-0.001113*v_1_39-0.106552*v_1_40-0.091171*v_1_41+0.042360*v_1_42+0.004133*v_1_43+0.100468*v_1_44-0.033907*v_1_45-0.091305*v_1_46-0.014356*v_1_47-0.027684*v_1_48+0.041259*v_1_49+0.025353*v_1_50-0.070525*v_1_51+0.035754*v_1_52+0.128852*v_1_53-0.080721*v_1_54+0.013834*v_1_55-0.213721*v_1_56+0.020273*v_1_57+0.054897*v_1_58+0.019326*v_1_59+0.085586*v_1_60+0.039246*v_1_61-0.043885*v_1_62-0.065694*v_1_63+0.200177);\n\n    // --- layer 3 -----------------------\n    float v_3_00 = fun(-0.072429*v_2_00-0.052117*v_2_01-0.023910*v_2_02+0.203479*v_2_03-0.132919*v_2_04-0.349307*v_2_05+0.089661*v_2_06-0.078603*v_2_07+0.196552*v_2_08-0.067238*v_2_09+0.169480*v_2_10+0.155241*v_2_11-0.198106*v_2_12-0.085792*v_2_13-0.238174*v_2_14-0.163969*v_2_15-0.071988*v_2_16+0.027705*v_2_17-0.020056*v_2_18+0.246110*v_2_19+0.084463*v_2_20-0.094323*v_2_21-0.105242*v_2_22+0.044057*v_2_23+0.207527*v_2_24+0.282902*v_2_25+0.114393*v_2_26+0.173069*v_2_27+0.069312*v_2_28-0.001658*v_2_29+0.183876*v_2_30+0.038688*v_2_31-0.067231);\n    float v_3_01 = fun( 0.279215*v_2_00+0.280494*v_2_01+0.321873*v_2_02-0.145595*v_2_03-0.034021*v_2_04+0.195307*v_2_05-0.234471*v_2_06+0.135093*v_2_07+0.035883*v_2_08+0.081551*v_2_09-0.219987*v_2_10+0.054182*v_2_11-0.238160*v_2_12+0.011234*v_2_13-0.085822*v_2_14-0.259100*v_2_15+0.366847*v_2_16+0.132563*v_2_17-0.228914*v_2_18+0.130180*v_2_19+0.149006*v_2_20+0.023534*v_2_21-0.103975*v_2_22-0.081088*v_2_23-0.025780*v_2_24-0.200678*v_2_25+0.378662*v_2_26-0.204158*v_2_27-0.024252*v_2_28+0.413405*v_2_29-0.157246*v_2_30-0.044508*v_2_31+0.158127);\n    float v_3_02 = fun( 0.160732*v_2_00+0.256011*v_2_01-0.110751*v_2_02-0.125313*v_2_03-0.065373*v_2_04-0.110848*v_2_05-0.114430*v_2_06-0.082431*v_2_07-0.068293*v_2_08+0.050474*v_2_09-0.211380*v_2_10+0.008279*v_2_11+0.208713*v_2_12-0.032765*v_2_13+0.189141*v_2_14-0.086992*v_2_15+0.124879*v_2_16+0.033473*v_2_17-0.208384*v_2_18+0.037765*v_2_19+0.119528*v_2_20+0.101169*v_2_21+0.222705*v_2_22+0.245765*v_2_23-0.176616*v_2_24+0.017667*v_2_25+0.078378*v_2_26+0.284788*v_2_27-0.028020*v_2_28+0.033615*v_2_29+0.062638*v_2_30+0.094317*v_2_31+0.102371);\n    float v_3_03 = fun( 0.141703*v_2_00+0.018339*v_2_01-0.049143*v_2_02+0.017668*v_2_03-0.153063*v_2_04+0.058508*v_2_05+0.111957*v_2_06+0.082174*v_2_07-0.212974*v_2_08+0.009967*v_2_09+0.041689*v_2_10-0.231775*v_2_11-0.145673*v_2_12-0.269081*v_2_13-0.201231*v_2_14-0.146360*v_2_15+0.069768*v_2_16+0.174144*v_2_17+0.102493*v_2_18-0.158220*v_2_19-0.023848*v_2_20-0.044683*v_2_21+0.194084*v_2_22+0.012289*v_2_23-0.108902*v_2_24+0.157053*v_2_25-0.101255*v_2_26-0.138732*v_2_27-0.064813*v_2_28-0.168581*v_2_29-0.179403*v_2_30-0.098669*v_2_31+0.060956);\n    float v_3_04 = fun( 0.055462*v_2_00+0.012236*v_2_01+0.137857*v_2_02-0.007873*v_2_03-0.255538*v_2_04-0.004729*v_2_05-0.009306*v_2_06+0.177762*v_2_07+0.167626*v_2_08+0.179370*v_2_09+0.156887*v_2_10-0.026025*v_2_11+0.195465*v_2_12-0.169990*v_2_13-0.110219*v_2_14+0.171137*v_2_15+0.041942*v_2_16+0.056661*v_2_17-0.047715*v_2_18-0.097023*v_2_19-0.076487*v_2_20+0.102538*v_2_21+0.070541*v_2_22+0.289628*v_2_23-0.054302*v_2_24+0.262871*v_2_25-0.115504*v_2_26-0.038528*v_2_27-0.005957*v_2_28+0.024039*v_2_29+0.116935*v_2_30-0.136978*v_2_31+0.290137);\n    float v_3_05 = fun( 0.094135*v_2_00+0.151499*v_2_01+0.142469*v_2_02+0.473716*v_2_03-0.003120*v_2_04-0.096686*v_2_05-0.211224*v_2_06+0.289545*v_2_07-0.017378*v_2_08-0.219641*v_2_09-0.105904*v_2_10+0.159131*v_2_11-0.232989*v_2_12+0.093633*v_2_13+0.203833*v_2_14-0.182458*v_2_15-0.181173*v_2_16-0.151925*v_2_17-0.137024*v_2_18-0.030933*v_2_19-0.269800*v_2_20-0.005893*v_2_21+0.204376*v_2_22-0.451209*v_2_23+0.172122*v_2_24-0.080869*v_2_25+0.097873*v_2_26-0.113800*v_2_27+0.222237*v_2_28-0.011652*v_2_29-0.006933*v_2_30+0.135856*v_2_31+0.229496);\n    float v_3_06 = fun( 0.114590*v_2_00-0.050509*v_2_01-0.177848*v_2_02-0.075297*v_2_03+0.166118*v_2_04-0.151201*v_2_05+0.083566*v_2_06+0.325173*v_2_07-0.109660*v_2_08-0.026054*v_2_09+0.067388*v_2_10-0.113322*v_2_11-0.028444*v_2_12-0.227439*v_2_13+0.138387*v_2_14-0.042116*v_2_15-0.142887*v_2_16-0.253878*v_2_17-0.019159*v_2_18+0.154164*v_2_19+0.186702*v_2_20-0.031668*v_2_21+0.023003*v_2_22+0.012250*v_2_23+0.089520*v_2_24+0.060231*v_2_25+0.000937*v_2_26-0.298728*v_2_27+0.267446*v_2_28-0.292538*v_2_29+0.064285*v_2_30-0.072182*v_2_31+0.172897);\n    float v_3_07 = fun(-0.110691*v_2_00-0.261372*v_2_01+0.078001*v_2_02+0.213953*v_2_03+0.090914*v_2_04-0.291401*v_2_05+0.085209*v_2_06+0.217021*v_2_07-0.114512*v_2_08+0.133875*v_2_09+0.270512*v_2_10-0.064528*v_2_11+0.065763*v_2_12+0.108031*v_2_13+0.130548*v_2_14-0.132751*v_2_15-0.248279*v_2_16-0.075339*v_2_17+0.176982*v_2_18-0.039952*v_2_19+0.095405*v_2_20+0.213864*v_2_21+0.074618*v_2_22+0.016896*v_2_23+0.095186*v_2_24-0.004186*v_2_25+0.011728*v_2_26+0.149403*v_2_27-0.101422*v_2_28-0.006989*v_2_29+0.119510*v_2_30+0.138768*v_2_31+0.083989);\n    float v_3_08 = fun( 0.114491*v_2_00+0.168758*v_2_01+0.264733*v_2_02+0.025732*v_2_03-0.138357*v_2_04-0.636609*v_2_05-0.179637*v_2_06+0.069689*v_2_07-0.169867*v_2_08+0.055848*v_2_09-0.149956*v_2_10-0.215913*v_2_11-0.005772*v_2_12-0.077164*v_2_13+0.061990*v_2_14+0.018299*v_2_15+0.284049*v_2_16+0.163867*v_2_17-0.339084*v_2_18-0.009155*v_2_19-0.205331*v_2_20-0.233561*v_2_21-0.065324*v_2_22-0.098747*v_2_23+0.010475*v_2_24+0.031747*v_2_25+0.313526*v_2_26-0.017686*v_2_27+0.036675*v_2_28+0.168762*v_2_29-0.062879*v_2_30+0.074452*v_2_31+0.253199);\n    float v_3_09 = fun(-0.056692*v_2_00-0.238749*v_2_01+0.076381*v_2_02+0.114606*v_2_03+0.089212*v_2_04-0.080897*v_2_05+0.270516*v_2_06+0.059891*v_2_07-0.002170*v_2_08+0.231490*v_2_09-0.242035*v_2_10+0.191429*v_2_11+0.006937*v_2_12-0.056038*v_2_13-0.204798*v_2_14-0.008964*v_2_15+0.037935*v_2_16-0.290974*v_2_17-0.159624*v_2_18+0.059585*v_2_19+0.199148*v_2_20+0.186739*v_2_21-0.170407*v_2_22+0.027352*v_2_23+0.150852*v_2_24+0.148215*v_2_25+0.054201*v_2_26-0.518585*v_2_27+0.289968*v_2_28+0.037875*v_2_29-0.052819*v_2_30+0.033675*v_2_31+0.029864);\n    float v_3_10 = fun( 0.326542*v_2_00+0.040399*v_2_01+0.201698*v_2_02+0.290997*v_2_03+0.199064*v_2_04+0.006128*v_2_05-0.124135*v_2_06+0.057628*v_2_07+0.124545*v_2_08+0.109343*v_2_09+0.048072*v_2_10+0.330426*v_2_11-0.036181*v_2_12-0.260121*v_2_13+0.071318*v_2_14-0.135288*v_2_15-0.117472*v_2_16-0.148146*v_2_17-0.688773*v_2_18+0.072893*v_2_19+0.024796*v_2_20-0.076462*v_2_21+0.109759*v_2_22-0.280305*v_2_23-0.023174*v_2_24-0.242890*v_2_25+0.171241*v_2_26+0.099887*v_2_27+0.202405*v_2_28-0.218115*v_2_29+0.035058*v_2_30+0.411294*v_2_31-0.131805);\n    float v_3_11 = fun( 0.205495*v_2_00+0.131622*v_2_01-0.200618*v_2_02-0.126344*v_2_03+0.137103*v_2_04-0.203709*v_2_05-0.179754*v_2_06+0.008463*v_2_07+0.047206*v_2_08-0.174325*v_2_09-0.310894*v_2_10-0.374026*v_2_11-0.065052*v_2_12-0.041360*v_2_13-0.227356*v_2_14-0.049431*v_2_15+0.047929*v_2_16+0.244925*v_2_17+0.321526*v_2_18+0.089854*v_2_19+0.043593*v_2_20-0.040902*v_2_21+0.375603*v_2_22-0.023301*v_2_23+0.229255*v_2_24+0.077241*v_2_25-0.023149*v_2_26-0.170729*v_2_27-0.068468*v_2_28+0.249025*v_2_29-0.085374*v_2_30+0.125159*v_2_31-0.172228);\n    float v_3_12 = fun( 0.039226*v_2_00+0.034918*v_2_01-0.048377*v_2_02+0.090690*v_2_03+0.176874*v_2_04-0.118805*v_2_05-0.010681*v_2_06+0.153826*v_2_07+0.055955*v_2_08+0.009882*v_2_09-0.223976*v_2_10+0.085491*v_2_11+0.059156*v_2_12-0.046569*v_2_13-0.222009*v_2_14-0.012478*v_2_15-0.205995*v_2_16+0.202204*v_2_17+0.137789*v_2_18-0.111004*v_2_19+0.149519*v_2_20+0.034712*v_2_21+0.272577*v_2_22+0.014841*v_2_23+0.075070*v_2_24-0.403323*v_2_25+0.075140*v_2_26+0.270352*v_2_27-0.155054*v_2_28+0.096580*v_2_29+0.104740*v_2_30-0.007412*v_2_31+0.047696);\n    float v_3_13 = fun(-0.048225*v_2_00+0.058702*v_2_01-0.105006*v_2_02+0.131665*v_2_03+0.088907*v_2_04-0.147617*v_2_05+0.070276*v_2_06+0.078152*v_2_07-0.106617*v_2_08-0.140748*v_2_09-0.127722*v_2_10-0.011950*v_2_11+0.134040*v_2_12-0.071629*v_2_13-0.051022*v_2_14-0.250510*v_2_15-0.142103*v_2_16-0.135902*v_2_17-0.063278*v_2_18-0.172445*v_2_19+0.307059*v_2_20+0.034731*v_2_21-0.102078*v_2_22-0.148489*v_2_23-0.024020*v_2_24-0.366180*v_2_25+0.174037*v_2_26+0.118328*v_2_27+0.186542*v_2_28+0.103307*v_2_29+0.023335*v_2_30-0.088635*v_2_31+0.359868);\n    float v_3_14 = fun(-0.159407*v_2_00+0.048035*v_2_01-0.235352*v_2_02+0.196105*v_2_03+0.049172*v_2_04-0.048163*v_2_05-0.132879*v_2_06+0.151793*v_2_07-0.208038*v_2_08-0.155564*v_2_09+0.130196*v_2_10+0.216088*v_2_11-0.024750*v_2_12-0.364631*v_2_13-0.075135*v_2_14-0.087908*v_2_15-0.212368*v_2_16-0.005580*v_2_17+0.004953*v_2_18-0.284964*v_2_19-0.136990*v_2_20+0.082654*v_2_21+0.089684*v_2_22+0.014834*v_2_23-0.064100*v_2_24-0.106852*v_2_25-0.023190*v_2_26+0.021252*v_2_27+0.373946*v_2_28-0.054027*v_2_29+0.656903*v_2_30+0.147754*v_2_31+0.308907);\n    float v_3_15 = fun( 0.225937*v_2_00-0.224250*v_2_01-0.242018*v_2_02+0.105097*v_2_03-0.082519*v_2_04-0.138594*v_2_05-0.153288*v_2_06-0.109048*v_2_07-0.059405*v_2_08-0.047025*v_2_09+0.048504*v_2_10+0.030623*v_2_11-0.001060*v_2_12+0.071544*v_2_13-0.135603*v_2_14-0.178962*v_2_15-0.104012*v_2_16-0.041296*v_2_17+0.105765*v_2_18+0.040479*v_2_19-0.013607*v_2_20-0.092112*v_2_21-0.032040*v_2_22+0.042604*v_2_23-0.173923*v_2_24-0.014723*v_2_25-0.206968*v_2_26-0.095554*v_2_27-0.015923*v_2_28-0.145868*v_2_29-0.284663*v_2_30-0.215003*v_2_31+0.205751);\n\n    // --- layer 4 -----------------------\n    float v_4_0 = fun(-0.074770*v_3_00+0.153457*v_3_01-0.081600*v_3_02+0.806365*v_3_03+0.319611*v_3_04-0.421145*v_3_05+0.262921*v_3_06+0.414504*v_3_07+0.182466*v_3_08-0.204948*v_3_09-0.278227*v_3_10-0.267526*v_3_11-0.482732*v_3_12+0.016222*v_3_13-0.163100*v_3_14-0.230546*v_3_15+0.239487);\n    float v_4_1 = fun(-0.177743*v_3_00+0.225562*v_3_01-0.453886*v_3_02+0.049631*v_3_03-0.075604*v_3_04+0.043647*v_3_05-0.399492*v_3_06+0.247270*v_3_07+0.142535*v_3_08+0.207551*v_3_09-0.285785*v_3_10+0.103653*v_3_11+0.173852*v_3_12-0.448810*v_3_13+0.348173*v_3_14-0.034657*v_3_15+0.146180);\n    float v_4_2 = fun( 0.007303*v_3_00-0.020625*v_3_01+0.083740*v_3_02+0.352550*v_3_03+0.240649*v_3_04-0.228324*v_3_05+0.194696*v_3_06-0.296093*v_3_07-0.187802*v_3_08-0.277522*v_3_09+0.138169*v_3_10+0.089463*v_3_11-0.271476*v_3_12+0.172629*v_3_13-0.294718*v_3_14-0.250925*v_3_15+0.358876);\n    float v_4_3 = fun(-0.265278*v_3_00-0.038249*v_3_01+0.333545*v_3_02-0.297062*v_3_03-0.615192*v_3_04-0.249223*v_3_05+0.212743*v_3_06-0.604752*v_3_07-0.367048*v_3_08-0.042192*v_3_09+0.173391*v_3_10+0.114303*v_3_11+0.426310*v_3_12-0.139203*v_3_13-0.123320*v_3_14+0.058854*v_3_15+0.155411);\n    float v_4_4 = fun( 0.240330*v_3_00-0.381828*v_3_01+0.046630*v_3_02-0.166178*v_3_03-0.399996*v_3_04-0.082567*v_3_05+0.133546*v_3_06-0.302975*v_3_07+0.572987*v_3_08+0.104452*v_3_09-0.106836*v_3_10-0.224661*v_3_11+0.276150*v_3_12+0.192883*v_3_13-0.242290*v_3_14+0.385779*v_3_15+0.468982);\n    float v_4_5 = fun( 0.110387*v_3_00+0.526222*v_3_01+0.281856*v_3_02-0.270505*v_3_03-0.084157*v_3_04-0.022643*v_3_05+0.262157*v_3_06+0.263482*v_3_07+0.012487*v_3_08-0.286433*v_3_09+0.246836*v_3_10+0.379451*v_3_11-0.071842*v_3_12-0.334393*v_3_13+0.305813*v_3_14-0.101473*v_3_15-0.389199);\n    float v_4_6 = fun(-0.254180*v_3_00+0.230147*v_3_01+0.149039*v_3_02+0.492671*v_3_03+0.093311*v_3_04-0.255843*v_3_05-0.106917*v_3_06-0.123294*v_3_07+0.267801*v_3_08+0.014941*v_3_09-0.434856*v_3_10-0.066969*v_3_11-0.263687*v_3_12-0.005927*v_3_13+0.241499*v_3_14+0.033405*v_3_15+0.188735);\n    float v_4_7 = fun(-0.151883*v_3_00-0.453696*v_3_01-0.408301*v_3_02+0.007573*v_3_03-0.007660*v_3_04-0.544588*v_3_05-0.594500*v_3_06-0.579255*v_3_07-0.301253*v_3_08+0.662012*v_3_09-0.429279*v_3_10-0.396704*v_3_11-0.088744*v_3_12-0.262998*v_3_13-0.595673*v_3_14-0.016370*v_3_15+0.526708);\n\n    // --- layer 5 : output --------------\n    float v_5_0 = 0.5 + ( 0.274124*v_4_0+0.153013*v_4_1 -1.233798*v_4_2+0.299297*v_4_3+0.879313*v_4_4-0.199257*v_4_5-0.248584*v_4_6+0.411614*v_4_7-0.153534);\n    fragColor = vec4(v_5_0, v_5_0, v_5_0, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstGDM.jpg", "access": "api", "license": "mit", "functions": [[2114, 2162, 2187, 2187, 2346], [2348, 2359, 2414, 2457, 52260]], "test": "untested"}
{"id": "sd3fzX", "name": "003 - Trying to create a circle", "author": "PiGIon", "description": "Today I tried to create a circle, fixed the UV aspect ratio and a bug in the cycle function.\n\nI studied a bit about convert Paremetric to Rectangular functions and tried to implement it, by trying to transform (cos(t), sin(t)) into a Rectangular function.", "tags": ["beginner", "sin", "circle", "cos", "learning"], "likes": 1, "viewed": 222, "published": 3, "date": "1656899122", "time_retrieved": "2024-07-30T16:41:49.734938", "image_code": "// 2022.07.03 rev 1\n\n#define PI 3.14159265\n#define TWOPI 6.2831853\n\n// https://www.wolframalpha.com/input?i=f%28x%29%3D0.5%2B%28cos%28%28%28x%2B0.5%2F1%29*20*1%29%2F%28PI%29%29%2F2.%29\nfloat cycle(float perSecond) {\n    // doing this multiplication, we make the animation % grow by perSecond factor\n    // iTime is the current time + timeDelta for precision\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |1          |0.1    |\n    // |0.2    |1          |0.2    |\n    // |0.45   |1          |0.45   |\n    // |0.5    |1          |0.5    |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |2          |0.2    |\n    // |0.2    |2          |0.4    |\n    // |0.45   |2          |0.9    |\n    // |0.5    |2          |0      |\n    // |_______|___________|_______|\n    // _____________________________\n    // | iTime | perSecond |   d   |\n    // |_______|___________|_______|\n    // |0.1    |0.5        |0.05   |\n    // |0.2    |0.5        |0.1    |\n    // |0.45   |0.5        |0.225  |\n    // |0.5    |0.5        |0.25   |\n    // |_______|___________|_______|\n\n\n    float x = (iTime + iTimeDelta) * perSecond;\n    float d = x - floor(x);\n    \n    if (d > 0.5) {\n        d = (1. - d); // reverse the keyframe, go back to start\n    }\n    \n    // since the cut point is 0.5, we need to get original place (e.g. 1 again) if d is exactly to 0.5\n    // this means that it cycles from 0...1...0 every second\n    d *= 2.;\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2. - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float r,g,b = 0.0;\n\n    // if the coord is inside a circle function...\n    if (step(pow(cos(uv.x*TWOPI), 2.) + pow(sin(uv.y*TWOPI), 2.), 2.*cycle(0.3)) == 1.) {\n        r = 0.;\n        g = 0.64;\n        b = 0.81;\n    } else if (step(cos(uv.x) + sin(uv.y), 2.*cycle(0.1)) == 1.) {\n        r = 0.14;\n        g = 0.63;\n        b = 0.55;\n    } else {\n        r = 0.;\n        g = 0.30;\n        b = 0.39;\n    }\n\n    fragColor = vec4(\n        r,\n        g, \n        b, \n        1\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3fzX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 185, 215, 1245, 1615], [1618, 1618, 1675, 1675, 2267]], "test": "untested"}
{"id": "sscfRX", "name": "Fork Triangle Voronoi Boarders", "author": "arlomcwalter", "description": "Cell interior distances for triangle voronoi", "tags": ["2d", "voronoi", "triangle"], "likes": 5, "viewed": 274, "published": 3, "date": "1656888411", "time_retrieved": "2024-07-30T16:41:50.551754", "image_code": "const float PI = 3.14159265359;\nconst float s3 = sin(PI / 3.);\nconst float speed = 12.;\n\nvec3 sdTriEdges(vec2 p) {\n    return vec3(\n        dot(p, vec2(0,-1)),\n        dot(p, vec2(s3, .5)),\n        dot(p, vec2(-s3, .5))\n    );\n}\n\nfloat sdTri(vec2 p) {\n    vec3 t = sdTriEdges(p);\n    return max(t.x, max(t.y, t.z));\n}\n\n// Adapted from Fizzer (found through Shane in the comments of https://www.shadertoy.com/view/Wl3fD2)\n// Picks the dominant axis and its sign:\n// vec3(1, 2, -3) -> vec3(0, 0, -1)\nvec3 primaryAxis(vec3 p) {\n    vec3 a = abs(p);\n//  return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p); // fails to pick a compoent when two have equal length, eg vec3(0,-2,2)\n    return (1.-step(a.xyz, a.yzx))*step(a.zxy, a.xyz)*sign(p);\n}\n\n// This is the interesting bit\n// Signed distance and gradient to border\nvec3 sdgBorder(vec2 pt1, vec2 pt2) {\n    \n    vec3 tbRel = sdTriEdges(pt2 - pt1);    \n    vec3 axis = primaryAxis(tbRel);\n    \n    vec2 gA = vec2(0,-1);\n    vec2 gB = vec2(s3, .5);\n    vec2 gC = vec2(-s3, .5);\n    \n    vec2 norA = gC * axis.x + gA * axis.y + gB * axis.z;\n    vec2 norB = gB * -axis.x + gC * -axis.y + gA * -axis.z;\n    \n    vec2 dir = gA * axis.x + gB * axis.y + gC * axis.z;\n    vec2 corner = dir * dot(dir, pt1 - pt2) * 2./3.;\n    \n    mat2 r90 = mat2(0,-1,1,0);\n    \n    bool isEdge = axis.x + axis.y + axis.z < 0.;\n    \n    if (isEdge) {\n        corner = pt2 + corner;\n        vec2 ca = corner + min(0., dot(corner, -norA)) * norA;\n        vec2 cb = corner + max(0., dot(corner, -norB)) * norB;\n        float side = step(dot(corner, dir * r90), 0.);\n        corner = mix(cb, ca, side);\n    } else {\n        corner = pt1 - corner;\n        vec2 ca = corner + max(0., dot(corner, -norA)) * norA;\n        vec2 cb = corner + min(0., dot(corner, -norB)) * norB;\n        float side = step(dot(corner, dir * r90), 0.);\n        corner = mix(ca, cb, side);\n    }\n    \n    vec2 nor = normalize(corner);\n\n    float d = length(corner);\n\n    return vec3(abs(d), nor);\n}\n\n\n// From here on is almost exactly like iq's voronoi https://shadertoy.com/view/ldl3W8\n\n#define ANIMATE\n\nvec2 hash2( vec2 p ) {\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat time;\n\nvec3 voronoi( in vec2 x, out vec2 nor )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n\tvec2 closestCell, closestPoint;\n\n    const int reach = 2;\n\n    float closestDist = 8.0;\n    for( int j = -reach; j <= reach; j++ )\n    for( int i = -reach; i <= reach; i++ )\n    {\n        vec2 cell = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + cell );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n        #endif\t\n        vec2 point = cell + o - f;\n        float dist = sdTri(point);\n\n        if( dist < closestDist )\n        {\n            closestDist = dist;\n            closestPoint = point;\n            closestCell = cell;\n        }\n    }\n\n\n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    closestDist = 8.0;\n    for( int j = -reach-1; j <= reach+1; j++ )\n    for( int i = -reach-1; i <= reach+1; i++ )\n    {\n        vec2 cell = closestCell + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + cell );\n\t\t#ifdef ANIMATE\n        o = 0.5 + 0.5*sin( time * PI * 2. + 6.2831*o );\n        #endif\t\n        vec2 point = cell + o - f;\n\n        float dist = sdTri(closestPoint - point);\n\n        if( dist > 0.00001 ) {\n            vec3 sdg = sdgBorder(closestPoint, point);\n            if (sdg.x < closestDist) {\n                closestDist = sdg.x;\n                nor = sdg.yz;\n            }\n        }\n    }\n\n    return vec3( closestDist, closestPoint );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xx;\n    \n    time = fract(iTime / speed);\n\n    p *= 8.;\n\n    vec2 nor;\n    vec3 c = voronoi(p, nor);\n\n    float aa = length(fwidth(p)) * .5;\n\n\t// isolines\n    float n = 15.;\n    vec3 col = smoothstep(.25 - aa * n, .25 + aa * n, abs(fract(c.x * n + .25) - .5)) * vec3(1);\n    // normals\n    nor = mix(nor, vec2(0), smoothstep(2./n - aa, 2./n + aa, c.x));\n    col = mix(col, normalize(vec3(nor, 1)) * .5 + .5, .9);\n    // borders\t\n    col = mix( vec3(0.5,1.0,0.5) * 0., col, smoothstep( 0.01 - aa, 0.01 + aa, c.x));\n    // feature points\n\t// float dd = length( c.yz );\n\t// col *= .2 + .8 * smoothstep( 0.00, 0.12, dd);\n    // col = mix(col, vec3(1), smoothstep( 0.035 + aa, 0.035 - aa, dd));\n\n\tfragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscfRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 114, 114, 228], [230, 230, 251, 251, 317], [319, 498, 524, 524, 740], [742, 815, 851, 851, 1991], [2098, 2098, 2120, 2120, 2210], [2225, 2225, 2266, 2266, 3786], [3788, 3788, 3845, 3845, 4601]], "test": "untested"}
{"id": "Nscfzf", "name": "Own World", "author": "Dave_Hoskins", "description": "An experiment in raymarching using a cube map to store an SDF.\n", "tags": ["3d", "raymarching", "planet"], "likes": 37, "viewed": 678, "published": 3, "date": "1656882809", "time_retrieved": "2024-07-30T16:41:51.600949", "image_code": "// Own World. \n\n// Shadertoy version of my NFT in WebGL 1.0 using p5 java-script.\n// License Creative Commons Attribution-NonCommercial-ShareAlike 1.0 Unported License.\n// By David Hoskins, 2022. AKA Flandish - https://twitter.com/Flandish_Art\n\n\n#define FAR 10.\n\n#define planetSizeSQR .6*.6\nconst vec3 seaColour = vec3(0,.0,.05);\nvec3 landColour = vec3(.4,.1,.1);\nconst vec2 planetRotate = vec2(.15, -.195);\nconst vec3 sunRay = normalize(vec3(-9.,8.0, 9.0));\nconst vec3 backlightRay = normalize(vec3(6.,-1.0, -4.0));\nmat3 rotMat;\n\n//----------------------------------------------------------------------------------------\nmat2 rot2D(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\n\n//----------------------------------------------------------------------------------------------------------\nfloat sphere( in vec3 ro, const in vec3 rd, const in float s )\n{\n\tfloat b = dot( ro, rd );\n\tfloat c = dot( ro, ro ) - s;\n\tfloat h = b * b - c;\n\tif(h < 0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat map(vec3 p)\n{\n    p = rotMat * p;\n    float t = texture(iChannel1, p).x + SEA_LEVEL;\n    return length(p) - t;\n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 mapNormal(vec3 p)\n{\n    p = rotMat * p;\n    return  (texture(iChannel1, p).yzw*2.0) - 1.0;\n    \n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat rayMarch(const in vec3 ro, const in vec3 rd, in float d)\n{\n    //d -= hash12(ro.yz)*.5;\n    for (int i = 0; i < 80 && d < FAR; i++)\n    {\n        vec3 p = ro+rd*d;\n        float m = map(p);\n        if (abs(m) < eps) break;\n        d += m*.37;\n    }\n \n    return d;\n}\n\n//----------------------------------------------------------------------------------------------------------\nfloat shadow(const in vec3 ro, const in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.;\n    for(int i = 0; i < 35; i++ )\n    {\n\t\tfloat h = map(ro + rd*t);\n\n\n        res = min( res, 6.*h/t );\n        if (res < .1) break;\n        t += h*.35;\n    }\n\n    return clamp( res, 0.1, 1.0 );\n}\n//----------------------------------------------------------------------------------------------------------\nvec3 getNormal(const in vec3 p, const in float ep)\n{\n\n    vec2 e = vec2(-1, 1)*ep;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) ); \n}\n\n//----------------------------------------------------------------------------------------------------------\nvec3 background(const in vec2 st)\n{\n  float s = .1/dot(st, st);\n  s = s*s*8.;\n  vec3 col = vec3(s*.7, s*.85, s);\n \n  // Dither over several bands for super smooth gradient...\n  vec3 m = col * 64.0;\n  vec3 h = hash32(st*40.0+2000.0);\n  col = (m + h) / 64.0;\n  return clamp(col, 0.0, 1.0);\n}\n\nvoid changeColours(int i)\n{\n    float rand = float((iFrame>>10))*23.+41.;\n    landColour = hash31(rand*43.+47.)*vec3(.3, .3, .1) + vec3(.2, .1, .1);\n}\n\n\n\n//----------------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = (2.0*(fragCoord+.5)-iResolution.xy) / iResolution.y;\n    const vec3 camPos = vec3(0,0,6);\n    vec3 rayDir = normalize( vec3(st*.08, -1.));\n    vec3 col;\n    \n    // Amimate...\n    rotMat = rotateMat3(iTime * planetRotate.x,  iTime * planetRotate.y);\n    \n\n    changeColours(iFrame);\n\n\n    // Firstly project the ray to the bounding sphere,\n    // which means I don't have to march from the camera.\n    float inter = sphere(camPos, rayDir, planetSizeSQR);\n    if (inter > 0.0)\n    {\n        // Raymarch from shell point to discover planet below...\n        float dist = rayMarch(camPos, rayDir, inter);\n        if (dist < FAR)\n        {\n            vec3 p = camPos + rayDir * dist;\n            vec3 up = normalize(p);\n            float dep = length(p);\n            vec3 norm =  inverse(rotMat) * mapNormal(p);\n        \n            // Compare stored normal to the acquired normal.\n            //if ((iFrame & 64) == 0) norm = getNormal(p, eps);\n\n\n            float refLight = max(dot( reflect(rayDir, norm), sunRay), 0.0);\n            float sh = shadow(p+norm*.0005, sunRay);\n          \n            \n            // Under water merge flatness...\n            float sea = smoothstep(SEA_LEVEL+0.02,  SEA_LEVEL+.006, dep);\n            //if (dep < SEA_LEVEL+4.) sea = 1.0;\n            norm = mix(norm, up, sea);\n            \n            vec3 mat = landColour;\n            // Grassy flats...\n            float slope = max(dot(up, norm), 0.0);\n            slope = pow(slope, 20.);\n            if (sea == 0.) mat = mix(mat, vec3(0.,.25,0), slope);\n            \n            // Snow colour...\n            float snow = smoothstep(SNOW_LEVEL-.06,  SNOW_LEVEL, dep);\n            mat =  mix(mat, vec3(.9), snow);\n\n            mat =  mix(mat, seaColour, sea);\n            // Sunlight...\n            float bri = sh*max(dot(norm, sunRay),0.0);\n            // Specular\n            col = mat * bri+.05;\n            col += vec3(1.,.8, .7)*pow(refLight, 10.0)*.4*sh;\n            // Blue side light\n            col += max(dot(norm, backlightRay),0.0)*vec3(.0, .1, .2);\n        }else\n        {\n            col = background(st);\n        }\n    }else\n    {\n        col = background(st);\n    }\n    //col = clamp(col*1.4, 0.0, 1.0);\n    col =  (col*col*(3.0-2.0*col));\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define SEA_LEVEL .34\n#define SNOW_LEVEL .51\n\n#define eps .0005\n\n// Swap m1 and m2 declaration around to break Angle!\nmat3 rotateMat3(float x, float y)\n{\n    mat3 m2 = mat3(cos(y),-sin(y), 0,\n                   sin(y), cos(y), 0,\n                   0, 0, 1);\n    mat3 m1 = mat3(cos(x),0,sin(x),\n                   0, 1, 0,\n                   -sin(x),0, cos(x));\n    return m2*m1;\n}\n\n\nmat2 rotMat2d(float x)\n{\n    return mat2(cos(x), sin(x), -sin(x), cos(x));\n}\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 mod289(vec3 x)\n{\n        return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x)\n{\n   return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n    return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade(vec3 t)\n{\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n   \nfloat pnoise(vec3 P)\n{\n   vec3 Pi0 = floor(P);\n    vec3 Pi1 = Pi0 + vec3(1.0);\n    Pi0 = mod289(Pi0);\n    Pi1 = mod289(Pi1);\n    vec3 Pf0 = fract(P); \n    vec3 Pf1 = Pf0 - vec3(1.0);\n    vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n    vec4 iy = vec4(Pi0.yy, Pi1.yy);\n    vec4 iz0 = Pi0.zzzz;\n    vec4 iz1 = Pi1.zzzz;\n\n    vec4 ixy = permute(permute(ix) + iy);\n    vec4 ixy0 = permute(ixy + iz0);\n    vec4 ixy1 = permute(ixy + iz1);\n\n    vec4 gx0 = ixy0 * (1.0 / 7.0);\n    vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n    gx0 = fract(gx0);\n    vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n    vec4 sz0 = step(gz0, vec4(0.0));\n    gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n    gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n    vec4 gx1 = ixy1 * (1.0 / 7.0);\n    vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n    gx1 = fract(gx1);\n    vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n    vec4 sz1 = step(gz1, vec4(0.0));\n    gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n    gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n    vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n    vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n    vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n    vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n    vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n    vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n    vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n    vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n    vec4 norm0 = taylorInvSqrt(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n    g000 *= norm0.x;\n    g010 *= norm0.y;\n    g100 *= norm0.z;\n    g110 *= norm0.w;\n    vec4 norm1 = taylorInvSqrt(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n    g001 *= norm1.x;\n    g011 *= norm1.y;\n    g101 *= norm1.z;\n    g111 *= norm1.w;\n\n    float n000 = dot(g000, Pf0);\n    float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n    float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n    float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n    float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n    float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n    float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n    float n111 = dot(g111, Pf1);\n\n    vec3 fade_xyz = fade(Pf0);\n    vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n    vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n    float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n    return 1.99 * n_xyz;\n} \n", "cube_a_code": "// Own World - make the planets in this tab\n// License Creative Commons Attribution-NonCommercial-ShareAlike 1.0 Unported License.\n// By David Hoskins, 2022.\n\n// The planet is stored in the environment map.\n// Which means you can't have any holes in it\n// unless you play around with four different values xyzw as spans.\n// But that would not be fast enough for me so I only store one height, in x.\n// yzw stores the normal.\n\n//----------------------------------------------------------------------------------------\n\nmat3 rotMat;\nfloat rand;\nvec2 details;\nfloat frequency;\nfloat adder;\n\n//---------------------------------------------------------------------------------------- \nfloat height( in vec3 q)\n{\n\n    vec3 p = (q+adder)*frequency;\n\n    float d = 0.0, a = .3;\n    for (int i = 0; i < 12; i++)\n    {\n        float n = 1.0-abs(pnoise(p));\n        n = pow(n, 1.5);\n        n += pnoise(p*1.35)*a*.3;\n\n        d += a * n;\n        a *= 0.43;\n        p = rotMat * p;\n    }\n    float r = clamp(d - SEA_LEVEL, 0.0, 1.0);\n    if (r < .002) r = r + d*.02;\n\n    return r;\n}\n\n//----------------------------------------------------------------------------------------\nfloat map(in vec3 p)\n{\n    float f = height(p);\n    return length(p)-f;\n}\n\n\n\n// The normal looks different from calculating it on the fly, but\n// I think it's more precise to use the actual SDF to grab the normals, instead of the cubemap,\n// because of the pixel density change across the cubemapped pixels giving uneven results?\n \nvec3 getNormal(in vec3 p, in float ep)\n{\n\n    vec2 e = vec2(-1, 1)*ep;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) ); \n \n}\n\n//----------------------------------------------------------------------------------------\nvoid mainCubemap( out vec4 C, in vec2 Coor, in vec3 rayOri, in vec3 rayDir )\n{\n   // Occasionally re-render the cubemap,\n   // Note, I have to do 2 frames because I think ALL the buffer objects are double.\n\n    int i = iFrame;\n    int doit = i & 1023;\n    if(doit > 1) discard;\n  \n    float rand = float((i>>2)&1023) +99.;\n    details = hash21(rand+13.0);\n\n    \n    frequency = .5 + hash11(rand*99.)*.4;\n    adder = hash11(rand*19.+5.)*1400.;\n\n\n    rotMat = rotateMat3(-1.11, 1.31) * 2.0;\n   \n    float f = height(rayDir);\n    f = clamp(f, 0.0, 1.0);\n    \n    \n    vec3 norm =  getNormal(rayDir, eps*.5);\n\n    norm = clamp(norm, -1.0, 1.0);\n    \n    C = vec4(f, (norm + 1.0)*.5);\n}\n\n//----------------------------------------------------------------------------------------", "cube_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nscfzf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[531, 622, 643, 643, 695], [1004, 1113, 1132, 1132, 1231], [1233, 1342, 1366, 1366, 1444], [2938, 2938, 2965, 2965, 3088], [3092, 3201, 3258, 3258, 5549]], "test": "untested"}
{"id": "fscfRf", "name": "voronoimix", "author": "Del", "description": "extruded, voronoi, smoothrot - left mouse - raw", "tags": ["voronimix"], "likes": 12, "viewed": 308, "published": 3, "date": "1656879583", "time_retrieved": "2024-07-30T16:41:52.496554", "image_code": "// playing voronoi extrude + smoothrot\n\n#define PI 3.14159265\n#define TAU 6.283185\n\n\nfloat opExtrusion( in vec3 p, float dd, in float h )\n{\n    float d = dd;\n    vec2 w = vec2( d, abs(p.y) - h );\n    return min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n\nmat2 rotate(float a)\n{\n    float s=sin(a),c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// IQ's polynomial-based smooth minimum function.\n//float smin( float a, float b, float k ){\n//\n////    float h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n//    return mix(b, a, h) - k*h*(1. - h);\n//}\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n\nvec2 hash2( vec2 p )\n{\n    // procedural white noise\t\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Voronoi (IQ) - slightly modified to return get the ID etc.\nvec4 VoronoiGrid( in vec2 x, out vec2 id, float _smooth )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n\n    // first pass: regular voronoi\n\tvec2 mg, mr;\n\n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );//anim\n\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    // second pass: distance to borders\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n\t\tvec2 o = hash2( n + g );\n        //o = 0.5 + 0.5*sin( iTime + 6.2831*o );//anim\n\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        if (_smooth>0.0)\n            md = smin( md, dot( 0.5*(mr+r), normalize(r-mr) ), _smooth );\n        else\n            md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ));\n        \n    }\n    \n    id = (n+mg)+vec2(0.5); // ID is n+mg\n    md = max(md,0.0);\n    return vec4(md, length(mr), mr);\n}\n\n\n\n\nvec2 smoothRot(vec2 p,float s,float m,float c,float d){\n  s*=0.5;\n  float k=length(p);\n  float x=asin(sin(atan(p.x,p.y)*s)*(1.0-m))*k;\n  float ds=k*s;\n  float y=mix(ds,2.0*ds-sqrt(x*x+ds*ds),c);\n  return vec2(x/s,y/s-d);\n}\n\n\nfloat map( in vec3 pos )\n{\n    //pos.zx *= rotate(iTime*0.5);\n    //pos.xy *= rotate(iTime*0.9);\n    //pos.zy *= rotate(iTime*0.4);\n    vec3 pp = pos;\n    float d = 100000.0;\n    \n    \n    float bd = sdBox(pp,vec3(4.0,0.5,4.0));\n    //if (bd>d) return d;\n    \n    if (iMouse.z<0.5)\n        pp.xz = smoothRot(pp.xz, 10.0, 0.3, 0.5, 0.0);\n    float scale =1.0+(sin(iTime*0.325)*0.7);//32.0\n    vec2 id = vec2(0.0);\n    vec2 uv = pp.xz;\n    //uv += iTime*0.01; // scroll\n    vec4 h = VoronoiGrid(uv*scale,id,0.1);\n    uv = id/scale;\n    float height = 0.2;\n    float dd = h.x/scale;\n    //d = min(d,h.y/scale);\n\n    dd = opExtrusion(pos,dd,height);\n    dd = dd-0.05;\n    dd = smin(dd,pos.y+0.2,0.1);\n\n    dd = max(dd,bd);\n\n    d = min(d,dd);\n    \n    return d-0.05;\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#define AA 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*iTime;\n\tvec3 ro = vec3( 6.*cos(an), 4.0+sin(iTime*0.9), 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 50.0;\n        float t = 0.0;\n        for( int i=0; i<128; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.7,0.6,0.4)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.8,0.7,0.5)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscfRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 139, 139, 252], [255, 255, 277, 277, 335], [337, 337, 368, 368, 459], [461, 877, 916, 916, 992], [994, 994, 1016, 1047, 1137], [1139, 1201, 1260, 1260, 2351], [2356, 2356, 2411, 2411, 2578], [2581, 2581, 2607, 2712, 3345], [3347, 3393, 3425, 3425, 3663]], "test": "untested"}
{"id": "fdtfRB", "name": "wythoff + caspar-klug", "author": "remaindeer", "description": "- wythoff + caspar-klug\n- simplifying code from the democapsid shader via wythoff construction, etc...\n- need to calculate dual patterns... (done)\n", "tags": ["tetrahedron", "pattern", "tiling", "icosahedron", "octahedron", "polyhedron", "wythoff", "casparklug"], "likes": 6, "viewed": 305, "published": 3, "date": "1656877109", "time_retrieved": "2024-07-30T16:41:53.526799", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    // vec3 col = vec3(0);\n    // col = sdTriangle(uv, q1, q2, q3) > 0.0 ? col : texture(iChannel0, iv.xy).xyz;\n   \n    // https://en.wikipedia.org/wiki/Camera_matrix\n    // https://www.cs.cmu.edu/~16385/s17/Slides/11.1_Camera_matrix.pdf\n    mat3 K = mat3(2.5);          // calibration\n    vec3 C = vec3(0);            // translation\n    mat3 Q = rotmat3(            // rotation\n        vec3(\n            radians(mod(iTime, 360.0) * 10.0),\n            radians(mod(iTime, 360.0) * 15.0),\n            radians(mod(iTime, 360.0) * 20.0)\n        )\n    );\n    mat4x3 IC = mat4x3(mat3(1));\n    IC[3] = -C;\n    mat4x3 P = (K * Q) * IC;     // projection\n\n    vec3 col = vec3(0);\n\n    int n = 0;   // n-th color\n    vec3[20] c;  // color value\n    float[20] z; // color depth\n    int nf = 20; // number of faces\n    int shape = int(mod(round((iTime + 3.0 / 2.0) / 6.0), 3.0));\n    switch (shape) {\n        case TET:\n            nf = 4;\n            break;\n        case OCT:\n            nf = 8;\n            break;\n        case ICO:\n            nf = 20;\n            break;\n    }\n    for (int i = 0; i < nf; i++)\n    {\n        // map face\n        vec3 q1, q2, q3;\n        switch (shape) {\n            case TET:\n                q1 = P * TET_V[int(TET_F[i].x)]; \n                q2 = P * TET_V[int(TET_F[i].y)]; \n                q3 = P * TET_V[int(TET_F[i].z)];\n                break;\n            case OCT:\n                q1 = P * OCT_V[int(OCT_F[i].x)]; \n                q2 = P * OCT_V[int(OCT_F[i].y)]; \n                q3 = P * OCT_V[int(OCT_F[i].z)];\n                break;\n            case ICO:\n                q1 = P * ICO_V[int(ICO_F[i].x)]; \n                q2 = P * ICO_V[int(ICO_F[i].y)]; \n                q3 = P * ICO_V[int(ICO_F[i].z)];\n                break;\n        }\n        if (sdTriangle(uv, q1.xy, q2.xy, q3.xy) <= 0.0)\n        {\n            mat3 A = mat3(\n                q1.x, q1.y, 1,\n                q2.x, q2.y, 1,\n                q3.x, q3.y, 1\n            );\n            // face centroid depth\n            z[n] = ((q1 + q2 + q3) / 3.0).z;\n            // https://stackoverflow.com/a/55550712\n            // map lattice texture to face\n            float s = (iResolution.y / iResolution.x) * 2.0 / sqrt(3.0);\n            mat3 X = mat3(0, 0, 1, s / 2.0, 1, 1, s, 0, 1);\n            vec3 iv = X * inverse(A) * vec3(uv.x, uv.y, 1);\n            c[n] = mix(texture(iChannel0, iv.xy).xyz, vec3(0), -z[n]);\n            n += 1;\n        }\n    }\n\n    // painter's algorithm\n    int i = 1;\n    while (i < n) {\n        float x = z[i];\n        vec3 X = c[i];\n        int j = i - 1;\n        while (j >= 0 && z[j] > x) {\n            z[j+1] = z[j];\n            c[j+1] = c[j];\n            j = j - 1;\n        }\n        z[j+1] = x;\n        c[j+1] = X;\n        i = i + 1;\n    }\n    for (int i = 0; i < n; i++) col = mix(col, c[i], 0.5);\n   \n   \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// math\n#define phi (1.0 + sqrt(5.0)) / 2.0\n\n// polyhedra\n//// constants\n#define TET 0\n#define OCT 1\n#define ICO 2\n//// tetrahedron\n////// radius\n#define TET_R 0.25\n////// vertexes\n#define TET_V vec4[] (               \\\n    vec4(+TET_R, +TET_R, +TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1), \\\n    vec4(-TET_R, +TET_R, -TET_R, 1), \\\n    vec4(-TET_R, -TET_R, +TET_R, 1), \\\n    vec4(+TET_R, -TET_R, -TET_R, 1)  \\\n)                                    \\\n////// faces\n#define TET_F vec3[] ( \\\n    vec3(0, 1, 2),     \\\n    vec3(1, 4, 2),     \\\n    vec3(0, 2, 4),     \\\n    vec3(0, 4, 1)      \\\n)                      \\\n//// octahedron\n////// radius\n#define OCT_RADIUS 0.85\n#define OCT_A      1.0 / (2.0 * sqrt(2.0)) * OCT_RADIUS\n#define OCT_B      0.5 * OCT_RADIUS\n////// vertexes\n#define OCT_V vec4[] (          \\\n    vec4(-OCT_A, 0, +OCT_A, 1), \\\n    vec4(-OCT_A, 0, -OCT_A, 1), \\\n    vec4(0, +OCT_B, 0, 1),      \\\n    vec4(+OCT_A, 0, -OCT_A, 1), \\\n    vec4(+OCT_A, 0, +OCT_A, 1), \\\n    vec4(0, -OCT_B, 0, 1)       \\\n)                               \\\n////// faces\n#define OCT_F vec3[] ( \\\n    vec3(0, 1, 2),     \\\n    vec3(1, 3, 2),     \\\n    vec3(3, 4, 2),     \\\n    vec3(4, 0, 2),     \\\n    vec3(3, 1, 5),     \\\n    vec3(1, 0, 5),     \\\n    vec3(4, 3, 5),     \\\n    vec3(0, 4, 5)      \\\n)                      \\\n//// icosahedron\n////// radius\n#define ICO_RADIUS 0.85\n#define ICO_A      0.5 * ICO_RADIUS\n#define ICO_B      1.0 / (2.0 * phi) * ICO_RADIUS\n////// vertexes\n#define ICO_V vec4[] (          \\\n    vec4(0, +ICO_B, -ICO_A, 1), \\\n    vec4(+ICO_B, +ICO_A, 0, 1), \\\n    vec4(-ICO_B, +ICO_A, 0, 1), \\\n    vec4(0, +ICO_B, +ICO_A, 1), \\\n    vec4(0, -ICO_B, +ICO_A, 1), \\\n    vec4(-ICO_A, 0, +ICO_B, 1), \\\n    vec4(0, -ICO_B, -ICO_A, 1), \\\n    vec4(+ICO_A, 0, -ICO_B, 1), \\\n    vec4(+ICO_A, 0, +ICO_B, 1), \\\n    vec4(-ICO_A, 0, -ICO_B, 1), \\\n    vec4(+ICO_B, -ICO_A, 0, 1), \\\n    vec4(-ICO_B, -ICO_A, 0, 1)  \\\n)                               \\\n////// faces\n#define ICO_F vec3[] ( \\\n    vec3( 0,  1,  2),  \\\n    vec3( 3,  2,  1),  \\\n    vec3( 3,  4,  5),  \\\n    vec3( 3,  8,  4),  \\\n    vec3( 0,  6,  7),  \\\n    vec3( 0,  9,  6),  \\\n    vec3( 4, 10, 11),  \\\n    vec3( 6, 11, 10),  \\\n    vec3( 2,  5,  9),  \\\n    vec3(11,  9,  5),  \\\n    vec3( 1,  7,  8),  \\\n    vec3(10,  8,  7),  \\\n    vec3( 3,  5,  2),  \\\n    vec3( 3,  1,  8),  \\\n    vec3( 0,  2,  9),  \\\n    vec3( 0,  7,  1),  \\\n    vec3( 6,  9, 11),  \\\n    vec3( 6, 10,  7),  \\\n    vec3( 4, 11,  5),  \\\n    vec3( 4,  8, 10)   \\\n)                      \\\n\nconst float cos30 = cos(radians(30.0));\n\nvec2 v1 = vec2(0, 0);\nvec2 v2 = vec2(0, cos30);\nvec2 v3 = vec2(0.5, cos30);\n\n// http://paulbourke.net/geometry/pointlineplane/\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\nmat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nmat3 rotmat3(vec3 angle) {\n    float sintht = sin(angle.x), sinpsi = sin(angle.y), sinphi = sin(angle.z);\n    float costht = cos(angle.x), cospsi = cos(angle.y), cosphi = cos(angle.z);\n    return mat3(\n        costht * cospsi,\n        sintht * cospsi,\n        -sinpsi,\n        costht * sinpsi * sinphi - sintht * cosphi,\n        sintht * sinpsi * sinphi + costht * cosphi,\n        cospsi * sinphi,\n        costht * sinpsi * cosphi + sintht * sinphi,\n        sintht * sinpsi * cosphi - costht * sinphi,\n        cospsi * cosphi\n    );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opUnion( float d1, float d2 )\n{ \n    return min(d1,d2); \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\n// r is the half-side\nfloat sdEquilateralTriangle(  in vec2 p, in float r )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - r;\n    p.y = p.y + r/k;\n    if( p.x+k*p.y>0.0 ) p=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0*r, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), v3, vec2(1, 0), v2);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, v3) / dot(v3, v3) * v3;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSchwartz632Snub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    // snub point\n    vec2 g = snub632();\n    // rotate\n    vec2 G = rotmat2(radians(180.0)) * (g - v2) + v2;\n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdSegment(p, g, G) - t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdSegment(rotmat2(radians(-60.0)) * p, g, G) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(-60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+120.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+180.0)) * (G - g) + g) - t);\n    return d;\n}\n\nfloat sdSchwartz632DualSnub(vec2 p, float t) {\n    // p the uv\n    // t the thickness\n    // snub point\n    vec2 g = snub632();\n    // take advantage of symmetry\n    float a = atan(p.y, p.x) - (atan(g.y, g.x) - radians(60.0));\n    float M = floor(mod(degrees(a), 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // central point\n    float d = sdCircle(p, t);\n    float R3 = sqrt(3.0) / 2.0 * length(g);\n    float r3 = sqrt(3.0) / 6.0 * length(g); \n    vec2 n0 = normalize(rotmat2(radians(+30.0)) * g);\n    vec2 n1 = (R3 + r3) * n0;\n    vec2 n2 = n1 + rotmat2(radians(-60.0)) * (2.0 * r3 * n0);\n    vec2 n3 = n1 + rotmat2(radians(+60.0)) * (2.0 * r3 * n0);\n    d = opUnion(d, sdSegment(p, v1, n1) - t);\n    d = opUnion(d, sdSegment(p, n1, n2) - t);\n    d = opUnion(d, sdSegment(p, n1, n3) - t);\n    d = opUnion(d, sdSegment(p, n2, n1 + n2 + -n3) - t);\n    d = opUnion(d, sdSegment(p, n3, n1 + n3 + -n2) - t);\n    return d;\n}\n\nfloat sdSchwartz632(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    // snub case\n    if (m == 8.0) {\n        return sdSchwartz632Snub(p, t);\n    }\n    // snub case\n    else if (m == 9.0) {\n        return sdSchwartz632DualSnub(p, t);\n    }\n    p = abs(p);\n    if (p.y < 2.0 * cos30 * p.x) {\n        p = rotmat2(radians(-60.0)) * p;\n        p = abs(p);\n    }\n    float d = sdCircle(p, t); \n    // d = opUnion(d, opOnion(sdTriangle(p, v1, v2, v3), t*0.25)); \n    d = opUnion(d, sdCircle(p - g, t));\n    d = bool(mod(m, 2.0)) ? opUnion(d, sdSegment(p, g, vec2(0, g.y)) - t) : d;\n    vec2 v = v3 - v1;\n    d = bool(mod(floor(m / 2.0), 2.0)) ? opUnion(d, sdSegment(p, g, dot(g, v) / dot(v, v) * v) - t) : d;\n    d = bool(mod(floor(m / 4.0), 2.0)) ? opUnion(d, sdSegment(p, g, vec2(g.x, v2.y)) - t) : d;\n    d = bool(mod(w, 2.0)) ? opUnion(d, sdSegment(p, v1, v2) - t) : d;\n    d = bool(mod(floor(w / 2.0), 2.0)) ? opUnion(d, sdSegment(p, v1, v3) - t) : d;\n    d = bool(mod(floor(w / 4.0), 2.0)) ? opUnion(d, sdSegment(p, v2, v3) - t) : d;\n    return d;\n}\n\nfloat sdSchwartz632Plane(vec2 p, vec2 g, float m, float w, float t) {\n    // p the uv\n    // g the generator point\n    // m the mirror toggle\n    // w the wall toggle\n    // t the thickness\n    vec2 v = vec2(3.0, 2.0 * cos30);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSchwartz632(p1, g, m, w, t),\n        sdSchwartz632(p2, g, m, w, t)\n    );\n}\n", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    // Caspar-Klug\n    float r = cos30;\n    float R = r / cos30;\n    float h = mod(round((iTime + 3.0 / 2.0) / 2.0), 3.0) + 1.0;\n    float k = mod(round((iTime + 6.0 + 3.0 / 2.0) / 3.0), 3.0);\n    vec2 i = vec2(1.5 * R, 1.0 * r);\n    vec2 j = vec2(0.0 * R, 2.0 * r);\n    mat2 b = mat2(i, j);\n    vec2 t1 = vec2(0);\n    vec2 t2 = b * vec2(h, k);\n    vec2 t3 = rotmat2(radians(-60.0)) * t2;\n    \n    // Wythoff\n    float a1 = 0.5 + sin(0.25 * iTime) / 2.0;\n    float a2 = 0.5 + cos(2.00 * iTime) / 2.0;\n    // pick point within fundamental triangle\n    // https://mathworld.wolfram.com/TrianglePointPicking.html\n    // http://extremelearning.com.au/evenly-distributing-points-in-a-triangle/\n    vec2 g = (((a1 + a2) < 1.0) ? (a1 * v3 + a2 * v2) : ((1.0 - a1) * v3 + (1.0 - a2) * v2));\n    float mirrors = mod(round((iTime - 2.0 / 2.0) / 2.0), 10.0);\n    float walls = 0.0;\n    \n    // style\n    float t = 0.075;\n\n    // transform\n    // facet altitude\n    float a = sqrt(3.0) / 2.0 * distance(t1, t2);\n\tvec2 p = fragCoord / iResolution.y;\n    p *= a;\n    p = rotmat2(-atan(t2.y, t2.x)) * p;\n\n    // distance\n    vec2 v = vec2(3.0 * R, 2.0 * r);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    float d = opUnion(\n        sdSchwartz632(p1, g, mirrors, walls, t),\n        sdSchwartz632(p2, g, mirrors, walls, t)\n    );\n    // d = opUnion(d, opOnion(sdTriangle(p, t1, t2, t3), t));\n    \n    vec3 col = vec3(1);\n    col = (d > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    col *= t - exp(-1.0 * abs(d));\n    col *= t + cos(150.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, t, abs(d)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Ns3fRf", "name": "From Fractal to Deep Well", "author": "turboplay", "description": "Some modifications of the original factal to create an abyss.", "tags": ["fractal"], "likes": 3, "viewed": 251, "published": 3, "date": "1656876151", "time_retrieved": "2024-07-30T16:41:54.325663", "image_code": "#define R(p,a,t) mix(a*dot(p,a),p,cos(t))+sin(t)*cross(p,a)\n#define H(h) (cos((h)*6.3+vec3(0,23,21))*.5+.5)\n\nvoid mainImage(out vec4 O, vec2 C)\n{\n    vec3 r=iResolution,c=vec3(0),\n    d=normalize(vec3(C-.5*r.xy,r.y));\n    float i=0.,s,e,g=0.,t=iTime;\n\tfor(;i++<90.;){\n        vec4 p=vec4(R(g*d,normalize(H(t*.7)),g*.1),.2 );\n        p.z+=t*.4;\n        p=sin(sin(p));\n        s=1.;\n        for(int i=0;i++<6;p=p*e-vec4(1,.3,.5,1.7))\n            p=abs(p),\n            p=p.x<p.y?p.zwxy:p.zwyx,\n            s*=e=2.7/min(dot(p,p/2.),2.);\n        g+=e=abs(p.w)/s+1e-4;\n\t    c+=mix(vec3(0.9),H(log(s)*.9),.4)*.04/exp(i*i*e);\n\t}\n\tc*=c*c;\n    O=vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 145, 145, 648]], "test": "untested"}
{"id": "Nd3fRf", "name": "Fire with Heat Haze", "author": "HughPH", "description": "Combined https://www.shadertoy.com/view/XsXSWS (fire) with https://www.shadertoy.com/view/MsScRt (height to normal) then refracted to give the impression of heat haze", "tags": ["procedural", "2d", "refraction"], "likes": 2, "viewed": 315, "published": 3, "date": "1656870820", "time_retrieved": "2024-07-30T16:41:55.090618", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 normal = (texture(iChannel0, uv).rg-.5)*vec2(1.,-1.)/15.;\n    vec4 fire = texture(iChannel2, uv);\n    vec4 distorted = texture(iChannel1, uv+normal);\n    fragColor = fire + distorted;\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////\n// Fire Flame shader\n\n// procedural noise from IQ\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise( uv ); uv = m*uv;\n\tf += 0.2500*noise( uv ); uv = m*uv;\n\tf += 0.1250*noise( uv ); uv = m*uv;\n\tf += 0.0625*noise( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\n// no defines, standard redish flames\n//#define BLUE_FLAME\n//#define GREEN_FLAME\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 q = uv;\n\tq.x += 1.;\n\tq.y *= 1.;\n\tfloat strength = floor(q.x+1.);\n\tfloat T3 = max(3.,1.25*strength)*iTime/2.;\n\tq.x = mod(q.x,1.)-0.5;\n\tq.y -= 0.25;\n\tfloat n = fbm(strength*q - vec2(0,T3));\n\tfloat c = 1. - 16. * pow( max( 0., length(q*vec2(1.8+q.y*1.5,.75) ) - n * max( 0., q.y+.25 ) ),1.2 );\n\tfloat c1 = n * c;\n\tc1=clamp(c1,0.,1.);\n\n    vec3 col = vec3(1.5*c1, 1.5*c1*c1*c1, c1*c1*c1*c1*c1*c1);\n\n#ifdef BLUE_FLAME\n\tcol = col.zyx;\n#endif\n#ifdef GREEN_FLAME\n\tcol = 0.85*col.yxz;\n#endif\n\n\tfloat a = c * (1.-pow(uv.y,3.));\n\tfragColor = vec4( mix(vec3(0.),col,a), c1*c1);\n}", "buffer_a_inputs": [], "buffer_b_code": "float getHeight(vec2 uv) {\n  return texture(iChannel0, uv).a;\n}\n\nvec4 bumpFromDepth(vec2 uv, vec2 resolution, float scale) {\n  vec2 step = 1. / resolution;\n    \n  float height = getHeight(uv);\n    \n  vec2 dxy = height - vec2(\n      getHeight(uv + vec2(step.x, 0.)), \n      getHeight(uv + vec2(0., step.y))\n  );\n    \n  return vec4(normalize(vec3(dxy * scale / step, 1.)), height);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  vec2 uv = fragCoord.xy / iResolution.xy;\n  fragColor = vec4(bumpFromDepth(uv, iResolution.xy, .1).rgb * .5 + .5, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3fRf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 290]], "test": "untested"}
{"id": "sdtBz2", "name": "practice on volumetric cloud", "author": "jcyuan", "description": "practice on volumetric cloud rendering", "tags": ["noise", "cloud", "perlin", "volumetric", "worley"], "likes": 0, "viewed": 88, "published": 3, "date": "1656853447", "time_retrieved": "2024-07-30T16:41:56.053045", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = vec3(texelFetch(iChannel0, ivec2(fragCoord), 0));\n    col *= smoothstep(.0, .2, uv.y);\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI 3.141592653589793\n#define sat(v) clamp(v, 0., 1.)\n\n// 0 - 1\n#define GLOBAL_PROB .22\n// 0 - x\n#define GLOBAL_DENSITY .1\n// 0 - 1\n#define GLOBAL_ANVIL_AMOUNT .0\n\n// -----------------------------------------\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1. / float(0xffffffffU))\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn -1. + 2. * (vec3(q) * UIF);\n}\n\nfloat worleyNoise(in vec3 p, in float f, in bool t)\n{\n    vec3 id = floor(p);\n    vec3 fr = fract(p);\n    \n    float dist = 10000.;\n    for(float x = -1.; x <= 1.; x++)\n    {\n        for(float y = -1.; y <= 1.; y++)\n        {\n            for(float z = -1.; z <= 1.; z++)\n            {\n                vec3 c = vec3(x, y, z);\n                vec3 r = id + c;\n                r = t ? hash33(mod(r, f)) : hash33(r);\n                r = (r * .4 + .3) + c;\n                vec3 sd = fr - r;\n                dist = min(dist, dot(sd, sd));\n            }\n        }\n    }\n    \n    return 1.0 - dist;\n}\n\nfloat worleys(in vec3 p, in float freq, in bool repeat)\n{\n    return max(0., dot(\n        vec3(\n            worleyNoise(p * freq, freq, repeat),\n            worleyNoise(p * freq * 2., freq * 2., repeat),\n            worleyNoise(p * freq * 4., freq * 4., repeat)\n        ),\n        vec3(.625, .25, .125)\n    ) * 1.1 - .1);\n}\n\n/*\nfloat perlinNoise(in vec3 p, in float freq)\n{\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\t\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\n    return mix( mix( mix( dot( hash33(mod(i + vec3(0.0,0.0,0.0), freq)) * 2. - 1., f - vec3(0.0,0.0,0.0) ), \n                          dot( hash33(mod(i + vec3(1.0,0.0,0.0), freq)) * 2. - 1., f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash33(mod(i + vec3(0.0,1.0,0.0), freq)) * 2. - 1., f - vec3(0.0,1.0,0.0) ), \n                          dot( hash33(mod(i + vec3(1.0,1.0,0.0), freq)) * 2. - 1., f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash33(mod(i + vec3(0.0,0.0,1.0), freq)) * 2. - 1., f - vec3(0.0,0.0,1.0) ), \n                          dot( hash33(mod(i + vec3(1.0,0.0,1.0), freq)) * 2. - 1., f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash33(mod(i + vec3(0.0,1.0,1.0), freq)) * 2. - 1., f - vec3(0.0,1.0,1.0) ), \n                          dot( hash33(mod(i + vec3(1.0,1.0,1.0), freq)) * 2. - 1., f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n*/\n\nfloat perlinNoise(in vec3 x, in float freq)\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    \n    f = f * f * (3. - 2. * f);\n\t\n    return mix(mix(mix(hash13(mod(i + vec3(0, 0, 0), freq)),  \n                       hash13(mod(i + vec3(1, 0, 0), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 0), freq)),  \n                       hash13(mod(i + vec3(1, 1, 0), freq)), f.x), f.y),\n               mix(mix(hash13(mod(i + vec3(0, 0, 1), freq)),  \n                       hash13(mod(i + vec3(1, 0, 1), freq)), f.x),\n                   mix(hash13(mod(i + vec3(0, 1, 1), freq)),  \n                       hash13(mod(i + vec3(1, 1, 1), freq)), f.x), f.y), f.z);\n}\n\nfloat perlins(in vec3 p, in float freq, in int oct)\n{\n    const float G = exp2(-.85);\n    float amp = 1.;\n    float noise = 0.;\n    for (int i = 0; i < oct; ++i)\n    {\n        noise += amp * perlinNoise(p * freq, freq);\n        freq *= 2.;\n        amp *= G;\n    }\n    return noise;\n}\n\nfloat remap(float x, float a, float b, float c, float d)\n{\n    return (((x - a) / (b - a)) * (d - c)) + c;\n}\n\nvec3 calcShape(in vec4 data, in float h)\n{\n    float prob = max(data.x, sat(GLOBAL_PROB - .5) * data.y * 2.);\n    float height = sat(data.z + .12);\n    \n    float sbottom = sat(remap(h, .0, .07, .0, 1.));\n    float stop = sat(remap(h, height * 0.2, height, 1., .1));\n    float shape = sbottom * stop;\n    shape = pow(shape, sat(remap(h, .65, .95, 1., (1. - GLOBAL_ANVIL_AMOUNT * GLOBAL_PROB))));\n\n    float dbottom = h * sat(remap(h, .0, .15, .0, 1.));\n    float dtop = sat(remap(h, .9, 1., 1., .2));\n    float density = GLOBAL_DENSITY * dbottom * dtop * data.w * 2.;\n    density = density\n               * mix(1., sat(remap(pow(h, .5), .4, .95, 1., .2)), GLOBAL_ANVIL_AMOUNT)\n               * sat(remap(h, .9, 1., 1., 0.));\n    \n    return vec3(prob, shape, density);\n}\n\nstruct Ray {\n    vec3 orig;\n    vec3 dir;\n};\n\n// with sphere, or maybe other shapes\nfloat intersects(Ray ray, float r)\n{\n \tfloat b = 2. * dot(ray.orig, ray.dir);\n    float c = dot(ray.orig, ray.orig) - r * r;\n    float d = sqrt(b * b - 4. * c);\n    return (-b + d) * .5;\n}\n", "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        vec3 p = vec3(uv, .5);\n\n        float w1 = worleys(p, 4., true);\n        float w2 = worleys(p, 8., true);\n        float w3 = worleys(p, 16., true);\n        float pf = abs((perlins(vec3(uv, .2), 4., 15) * .5) * 2. - 1.); // billowy\n        float w0 = remap(pf, 0., 1., w1, 1.);\n        \n        w1 = dot(vec3(w1, w2, w3), vec3(.625, .25, .125)) - 1.;\n\n        fragColor = vec4(w0, w1, 0, 0);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame > 0)\n    {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    }\n    else\n    {\n        vec2 uv = fragCoord / iResolution.xy;\n        \n        vec4 col = texture(iChannel1, uv);\n        float r = sat(pow(1. - col.g + col.b, 1.));\n        float g = perlins(vec3(uv, .4), 4., 7) * 2. - 1.;\n        // g = sat(1. - pow(g * 2., 1000.));\n        const float b = 1.;\n        const float a = .5;\n\n        fragColor = vec4(r, g, b, a);\n    }\n}", "buffer_b_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define D_STEPS 40\n\n#define MOVE_DIR vec3(-.4, .1, 1.)\n#define MOVE_SPEED 700.\n\n#define RANGE_R 6371000.\n#define RANGE_T 10000.\n#define RANGE_B 2100.\n#define RNG(l) (l - RANGE_R - RANGE_B) / (RANGE_T - RANGE_B)\n\n#define SUN_COLOR vec3(1.2, 1., .6)\n#define AMBIENT_TOP vec3(0.5, 0.8, 1.2)\n#define AMBIENT_BOTTOM vec3(0.15, 0.45, 1.1)\n\n// random pos on unit sphere\nconst vec3 ConeSamplingKernel[6u] = vec3[] \n(\n\tvec3( .38051305,  .92453449, -.02111345),\n\tvec3(-.50625799, -.03590792, -.86163418),\n\tvec3(-.32509218, -.94557439,  .01428793),\n\tvec3( .09026238, -.27376545,  .95755165),\n\tvec3( .28128598,  .42443639, -.86065785),\n\tvec3(-.16852403,  .14748697,  .97460106)\n);\n\nfloat cloudShape(in vec4 data, in vec3 p, in float h, in bool detail)\n{\n    vec4 noise = textureLod(iChannel0, (p.xz - (MOVE_DIR.xz * iTime * MOVE_SPEED)) * (1. / RANGE_R) * 200., 0.);\n    vec3 c = calcShape(data, h);  // prob, shape, density\n\n    float prob = 1. - GLOBAL_PROB * c.x;\n    float shape = remap(noise.r, noise.g, 1., 0., 1.) * c.y;\n    float covered = sat(remap(shape, prob, 1., 0., 1.));\n    \n    if (detail && covered > 0. && covered < .3)\n    {\n        p -= MOVE_DIR * 3. * iTime * MOVE_SPEED;\n        float d = dot(vec3(worleys(p, .0018, false),\n                   worleys(p, .0036, false),\n                   worleys(p, .0072, false)),\n                   vec3(.625, .25, .125));\n        float m = .35 * exp(-GLOBAL_PROB * .75) * mix(d, 1. - d, sat(h * 5.));\n        \n        return sat(remap(covered, m, 1., 0., 1.)) * c.z;\n    }\n    \n    return covered * c.z;\n}\n\nfloat henyeyGreenstein(float sunDot, float g)\n{\n\tfloat g2 = g * g;\n\treturn (.25 / PI) * ((1. - g2) / pow(1. + g2 - 2. * g * sunDot, 1.5));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 data = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    vec2 mouse = (2. * iMouse.xy - iResolution.xy) / iResolution.y;\n    \n    vec3 eye = vec3(0);\n    vec3 target = vec3(0, .3, -1);\n    const vec3 UP = vec3(0, 1, 0);\n    vec3 lookDir = normalize(target - eye);\n    vec3 r = normalize(cross(lookDir, UP));\n    vec3 t = cross(r, lookDir);\n    vec2 camUv = ((2. * fragCoord - iResolution.xy) / iResolution.y) * (75. / 360.) * PI;\n    vec3 dir = normalize(mat3(r, t, -lookDir) * vec3(camUv, -2.));\n    \n    Ray ray = Ray(eye, dir);\n    \n    Ray sun = Ray(vec3(-.2, .3, .6), vec3(0.));\n    sun.dir = normalize(vec3(sun.orig.xz, -1.));\n\n    ray.orig.y = RANGE_R;\n    float rs = intersects(ray, RANGE_R + RANGE_B);\n    float re = intersects(ray, RANGE_R + RANGE_T);\n    float st = (re - rs) / float(D_STEPS);\n    float jitter = st * texelFetch(iChannel2, (ivec2(fragCoord) + iFrame * ivec2(113, 127)) & 1023, 0).r;\n    float curDist = rs + jitter;\n    \n    float VdotL = max(0., dot(ray.dir, sun.dir));\n    float hgPhase = mix(henyeyGreenstein(VdotL, .4), henyeyGreenstein(VdotL, -.1), .5);\n    \n    const vec3 skyColor = vec3(.4);  // todo: atmosphere scattering\n    \n    float sunHeight = smoothstep(.01, .1, sun.orig.z + .025);\n    \n    hgPhase = max(hgPhase, 1.6 * henyeyGreenstein(sqrt(VdotL),\n\t\t\t\t\t\t\tsat(.8 - sunHeight)));\n                            \n    hgPhase = mix(pow(VdotL, .25), hgPhase, sunHeight);\n    \n    float sunScatterHeight = smoothstep(.15, .4, sun.orig.z);\n    \n    vec4 scatter = vec4(vec3(0.), 1.);  // in\n    for (int i = 0; i < D_STEPS; i++)\n    {\n        vec3 p = ray.orig + ray.dir * curDist;\n        float hr = RNG(length(p));\n        float density = cloudShape(data, p, hr, true);\n        if (density > 0.)\n        {\n            const float lst = 11.;\n            vec3 sDir = sun.dir * lst;\n            vec3 sDist = sDir * .5;  // todo: twist this\n            float coneR = length(sDir);\n            float density2 = 0.;\n            for(int j = 0; j < 6; j++)\n            {\n                vec3 cp = p + sDist + float(j) * coneR * ConeSamplingKernel[j];\n                if (hr > .99 || density2 > .99) break;\n                density2 += cloudShape(data, cp, hr, false) * lst;\n                sDist += sDir;\n            }\n            float precipitation = mix(3.6,\n\t\t\t\t1.8, sunScatterHeight);\n                \n            float shadow = 32. * exp(-density2 * precipitation) * (1. - exp(-density2 * 2.));\n            \n            // integrate along the current step segment: https://www.shadertoy.com/view/XlBSRz\n            \n            vec3 ambient = mix(AMBIENT_BOTTOM, AMBIENT_TOP, \n                                  \thr);\n\t\t\t\t\t\n                    // cloud illumination\n                    vec3 lum = (ambient * sat(pow(sun.orig.z + .04, 1.4))\n\t\t\t\t\t\t+ skyColor * .125 + (sunHeight * skyColor + vec3(.0075, .015, .03))\n\t\t\t\t\t\t* SUN_COLOR * hgPhase\n\t\t\t\t\t\t* shadow) * density;\n\n\n            /*\n            vec3 lum = (\n                mix(AMBIENT_BOTTOM, AMBIENT_TOP, hr)\n                + (skyColor + vec3(.0075, .015, .03)) * SUN_COLOR * hgPhase * shadow\n            ) * density;*/\n            \n            float transmittance = exp(-density * st);\n            vec3 integrate = (lum - lum * transmittance) * (1. / density);\n            \n            scatter.rgb += scatter.a * integrate;\n            scatter.a *= transmittance;\n        }\n        \n        if (scatter.a < .01)\n            break;\n            \n        curDist += st;\n    }\n    \n    float hzMix = 1. - exp(-smoothstep(.08, 0., ray.dir.y) * 2.);\n    scatter = mix(scatter, vec4(0.), hzMix);\n    \n    fragColor = scatter;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "const ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1, -1), ivec2(-1, 1),\n\tivec2(1, -1), ivec2(1, 1),\n\tivec2(1, 0), ivec2(0, -1),\n\tivec2(0, 1), ivec2(-1, 0)\n);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 currentBuffer = textureLod(iChannel0, uv, 0.);\n    vec4 historyBuffer = textureLod(iChannel1, uv, 0.);\n\n    vec4 colorAvg = currentBuffer;\n    vec4 colorVar = currentBuffer * currentBuffer;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec4 neighborTexel = texelFetch(iChannel0, ivec2(fragCoord.xy) + offsets[i], 0);\n        colorAvg += neighborTexel;\n        colorVar += neighborTexel * neighborTexel;\n    }\n    colorAvg /= 9.;\n    colorVar /= 9.;\n    \n    float gColorBoxSigma = .75;\n\tvec4 sigma = sqrt(max(vec4(0.), colorVar - colorAvg * colorAvg));\n\tvec4 colorMin = colorAvg - gColorBoxSigma * sigma;\n\tvec4 colorMax = colorAvg + gColorBoxSigma * sigma;\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n\n\tfragColor = mix(currentBuffer, historyBuffer, .95);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtBz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 234]], "test": "untested"}
{"id": "7s3Bz2", "name": "Flowing Water", "author": "fenix", "description": "*drag with mouse* *space to reset* Added boundary handling and water-on-window effect inspired stylistically by Heartfelt by BigWIngs  ", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 44, "viewed": 1021, "published": 3, "date": "1656828284", "time_retrieved": "2024-07-30T16:41:57.000512", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles into a density texture\n//  Buffer D blurs the density\n//\n// ---------------------------------------------------------------------------------------\n\nvec2 getGradFromHeightMap( vec2 point )\n{\n\tvec2 tinyChangeX = vec2( 0.002, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.002 );\n    \n   \tfloat upTinyChangeInX0   = texture(iChannel0, point + tinyChangeX).x; \n   \tfloat upTinyChangeInX1   = texture(iChannel0, point + tinyChangeX + tinyChangeX).x; \n    float downTinyChangeInX0 = texture(iChannel0, point - tinyChangeX).x; \n    float downTinyChangeInX1 = texture(iChannel0, point - tinyChangeX - tinyChangeX).x; \n    \n    float tinyChangeInX = upTinyChangeInX0 + upTinyChangeInX1 - downTinyChangeInX0 - downTinyChangeInX1;\n    \n    \n    float upTinyChangeInY0   = texture(iChannel0, point + tinyChangeY).x; \n    float upTinyChangeInY1   = texture(iChannel0, point + tinyChangeY + tinyChangeY).x; \n    float downTinyChangeInY0 = texture(iChannel0, point - tinyChangeY).x; \n    float downTinyChangeInY1 = texture(iChannel0, point - tinyChangeY - tinyChangeY).x; \n    \n    float tinyChangeInY = upTinyChangeInY0 + upTinyChangeInY1 - downTinyChangeInY0 - downTinyChangeInY1;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normal * 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n    vec2 p = fragCoord/iResolution.xy;\n    float density = textureLod(iChannel0, p, 1.0).x;\n    if (p.x > 0.15 && ((p.y > 0.725 && p.y < 0.775) || (p.y > 0.225 && p.y < 0.275))\n        || p.x < 0.85 && (p.y > 0.475 && p.y < 0.525))\n    {\n        fragColor = texture(iChannel2, p);\n    }\n    else\n    {\n        vec4 background = textureLod(iChannel1, p, 5.0);\n        vec2 grad = getGradFromHeightMap(p);\n        if (p.y < 0.25) grad.y -= p.y - 0.25; // Hack to make bottom layer more visible\n        vec4 water = texture(iChannel1, p + grad * 0.7) * vec4(0.8, 0.9, 1.0, 0.0); // Refract :)\n        fragColor = mix(background, water, smoothstep(0.5, 1.0, density)); // Blur water edges\n    }\n    //fragColor = texture(iChannel0, p);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 6000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.03;\nconst float PARTICLE_REPEL_SIZE = 0.010;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return length2(closestDelta);\n}\n\nconst vec4 SCENE_LINES[13] = vec4[]( vec4(-1.0, -1.0, 1.0, -1.0),\n    vec4(-1.0, 1.0, 1.0, 1.0),\n    vec4(-1.0, -1.0, -1.0, 1.0),\n    vec4(1.0, -1.0, 1.0, 1.0),\n    vec4(-0.7, 0.55, 1.0, 0.55),\n    vec4(-0.7, 0.45, 1.0, 0.45),\n    vec4(-0.7, 0.55, -0.7, 0.45),\n    vec4(0.7, 0.05, -1.0, 0.05),\n    vec4(0.7, -0.05, -1.0, -0.05),\n    vec4(0.7, 0.05, 0.7, -0.05),\n    vec4(-0.7, -0.55, 1.0, -0.55),\n    vec4(-0.7, -0.45, 1.0, -0.45),\n    vec4(-0.7, -0.55, -0.7, -0.45));\n    \nconst int NUM_SCENE_LINES = 13;\n\nbool intersectPlane(vec2 p0, vec2 p1, vec2 p2, vec2 p3, in float minT, out float t, out vec2 n)\n{ \n    vec2 CmP = p2 - p0;\n    vec2 r = p1 - p0;\n    vec2 s = p3 - p2;\n\n    float CmPxr = cross2(CmP, r);\n    float CmPxs = cross2(CmP, s);\n    float rxs = cross2(r, s);\n\n    if (CmPxr == 0.0)\n    {\n        // Lines are collinear, and so intersect if they have any overlap\n        return false;\n        //return ((C.X - A.X < 0f) != (C.X - B.X < 0f))\n          //  || ((C.Y - A.Y < 0f) != (C.Y - B.Y < 0f));\n    }\n\n    if (rxs == 0.0)\n        return false; // Lines are parallel.\n\n    float rxsr = 1.0 / rxs;\n    t = CmPxs * rxsr;\n    float u = CmPxr * rxsr;\n\n    if (t >= 0.0 && t <= minT && u >= 0.0 && u <= 1.0)\n    {\n        n = normalize(vec2(-s.y, s.x));\n        \n        if (rxs < 0.0) n = -n;\n        \n        return true;\n    }\n    \n    return false;\n} \n\nbool intersectScene(float animate, vec2 from, vec2 to, out float t, out vec2 n)\n{\n    float intersectT;\n    vec2 intersectNormal;\n\n    float minT = 1.0;\n    bool hit = false;\n    for (int index = 0; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        if(intersectPlane(from, to, sceneFrom, sceneTo, minT, intersectT, intersectNormal))\n        {\n            t = minT = intersectT;\n            n = intersectNormal;\n            hit = true;\n        }\n    }\n\n    return hit;\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n#if 1\n    minDist = min(minDist, (point.x + 1.0 - MOVING_WALL_MAG - MOVING_WALL_MAG*sin(time / MOVING_WALL_TIME)) * resolution.x / resolution.y);\n    minDist = min(minDist, (1.0 - point.x) * resolution.x / resolution.y);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n#else\n    for (int index = 0; index < NUM_SCENE_LINES; ++index)\n    {\n        vec2 sceneFrom = SCENE_LINES[index].xy;\n        vec2 sceneTo = SCENE_LINES[index].zw;\n        \n        vec2 closest;\n        float dist = linePointDist2(sceneFrom, sceneTo, point, resolution, closest);\n        \n        if (dist < minDist)\n        {\n            minDist = dist;\n        }\n    }\n#endif\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define FLUID 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n    float density;\n    float pressure;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLUID), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.uv = particleData5.xy;\n    particle.density = particleData5.z;\n    particle.pressure = particleData5.w;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case FLUID:\n        return vec4(p.uv, p.density, p.pressure);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.00012);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.0001;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL || dataType == FLUID)\n    {\n        if (iFrame == 0 || keyDown(32))\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles)) * 5.0;\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            float k = float(id % 4);\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * vec2(1.8, -0.2) - vec2(0.9, -0.8 + 0.5 * k);\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            else\n            {\n                // auto disturb\n                //disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, 0.2);\n                //disturbDelta = 80.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.1 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n                float density;\n                int id;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    \n                    // Don't affect particles on the other side of a wall\n                    vec2 normal;\n                    float t;\n                    if (intersectScene(iTime, data.pos, otherPosVel.xy, t, normal)) continue;\n                    \n                    vec4 otherFluid = fxGetParticleData(cid, FLUID);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    particles[numSolverParticles].density = otherFluid.z;\n                    particles[numSolverParticles].id = cid;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            particles[numSolverParticles].id = id;\n            ++numSolverParticles;\n\n            // Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos / dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist / PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    // Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    // Integrate vel\n                    particles[i].vel -= particles[i].vel * 0.000004 - GRAVITY / float(NUM_ITERATIONS);\n                    \n                    // Integrate pos\n                    particles[i].pos += particles[i].vel / float(NUM_ITERATIONS);\n                }\n            }\n            \n            // Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n            \n            // Record misc solver results\n            data.pressure = pressure;\n            data.density = totalDensity;\n                   \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            const int NUM_SCENE_ITERATIONS = 4;\n            for (int i = 0; i < NUM_SCENE_ITERATIONS; ++i)\n            {\n                float t;\n                vec2 normal;\n                vec2 newPos = data.pos + data.vel;\n                if (intersectScene(iTime, data.pos, newPos, t, normal))\n                {    \n                    vec2 intersection = data.pos + t * data.vel;\n                    vec2 reflected = intersection + (1.0 - t) * reflect(data.vel, normal);\n                    data.vel = reflect(data.vel, normal);\n                }\n            }\n\n            // Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n            data.vel -= data.vel * 0.9 * smoothstep(50.0, 100.0, data.density);\n\n            // Clamping\n            float maxSpeed = 30.0 / (iResolution.x + iResolution.y); // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n            \n            if (data.pos.x > 0.7 && data.pos.y < -0.99)\n            {\n                data.pos.y += 1.98;\n            }\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n\n        //random sorts\n        for (int i = 0; i < 4; ++i)\n        {\n            int searchId = int(float(iResolution.x*iResolution.y)*hash13(vec3(iFrame, id, i)));\n            sort0(bestIds, bestDists, id, searchId, dataType, data.pos);\n        }\n        \n        //see if the rendering buffer found anything better\n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);\n        }\n        \n        fragColor = vec4(bestIds);\n        return;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = fxGetClosest(ivec2(fragCoord));\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(distance(fxGetParticleData(new[0], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[1], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[2], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[3], POS_VEL).xy, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(maxParticles));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec3 renderLine(in vec2 from, in vec2 to, in vec3 color, in float size, in vec2 fragCoord)\n{\n    vec2 closest;\n    float dist = linePointDist2(from, to, fragCoord, iResolution, closest);\n    return color * max(0.0, (size - sqrt(dist)) / (size));\n}\n\nvec3 renderParticle(in fxParticle p, in vec2 fragCoord)\n{   \n    //if (p.density < 50.0) return;\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    //fragColor.xyz += 1000.2 * p.pressure * particleColor(p.uv) * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n    vec3 color = vec3(1.0, 1.0, 1.0);//vec3(150.0*p.pressure, 10000.0*dot(p.vel, p.vel), 0.000012*p.density*p.density*p.density);\n    vec3 fragColor = renderLine(p.pos, p.pos - p.vel, color, PARTICLE_SIZE, fragCoord);\n    \n    // Render neighbor lines\n    #if 0\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                //float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor += renderLine(p.pos, p.pos + 0.5 * (otherPos - p.pos), color, PARTICLE_SIZE * 0.3, fragCoord);//color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) / (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n    \n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord){\n    \n    fragColor = vec4(0.0);\n    \n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n#if 0\n    for (int line = 0; line < NUM_SCENE_LINES; ++line)\n    {\n        fragColor.xyz += renderLine(SCENE_LINES[line].xy, SCENE_LINES[line].zw, vec3(1.0, 0.0, 0.0), PARTICLE_SIZE, p);\n    }\n#endif\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        fragColor.xyz += renderParticle(particle, p);\n    }\n    \n    //fragColor.xyz = vec3(distanceFromWalls(p, iResolution, iTime));\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// gaussian blur from FabriceNeyret2's smart gaussian blur: https://www.shadertoy.com/view/WtKfD3\n\nint           N = 11; // 7                              // target sampling rate\nfloat         w = .1,                                   // filter width\n              z;                                        // LOD MIPmap level to use for integration \n#define init  w = .02; \\\n              z = ceil(max(0.,log2(w*R.y/float(N))));   // N/w = res/2^z\n#define R     iResolution.xy\n\n\nfloat convol2D(vec2 U) {                                                     \n    float  O = 0.0;  \n    float r = float(N-1)/2., g, t=0.;                                       \n    for( int k=0; k<N*N; k++ ) {                                            \n        vec2 P = vec2(k%N,k/N) / r - 1.;                                    \n        t += g = exp(-2.*dot(P,P) );                                        \n        O += g * textureLod(iChannel0, (U+w*P) *R.y/R, z ).x;                 \n    }                                                                       \n    return O/t;                                                             \n}      \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    init \n    vec2 U = u / R.y;  \n    O = texture(iChannel0, u / iResolution.xy);\n    O.x = convol2D(U); return;\n  //  O = convol1D(U,vec2(1,0));\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3Bz2.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[645, 645, 686, 686, 1786], [1788, 1788, 1840, 1840, 2574]], "test": "untested"}
{"id": "7ddBRj", "name": "False perspective spiral", "author": "El_Sargo", "description": "Perspective trick", "tags": ["2d"], "likes": 3, "viewed": 291, "published": 3, "date": "1656825404", "time_retrieved": "2024-07-30T16:41:57.881157", "image_code": "#define i iResolution\nvoid mainImage(out vec4 j,in vec2 k){vec2 u=k/i.xy;vec2 n=(u-.5)*vec2(1,i.y/\ni.x);float l=length(n),t=atan(n.x,n.y)/(26.)*20.,f=mod(pow(l+.8,-5.)*40.+iTime\n*10.+t,5.)*.2;j=vec4((f+smoothstep(.2,0.,f))*texture(iChannel0,vec2(t,pow(f,-l*\n.2))).rgb*smoothstep(.0,.6,l),1);}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 59, 59, 292]], "test": "untested"}
{"id": "sddBRj", "name": "Metal branch mosaic 4", "author": "jarble", "description": "Another ornate mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 2, "viewed": 227, "published": 3, "date": "1656824325", "time_retrieved": "2024-07-30T16:41:58.735873", "image_code": "vec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(c, -s, s, c)*v;\n}\n\nvec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\n\n\nint length_mod(vec2 uv,int num){\n    num += int(uv.x*float(num));\n    return (int(length(uv*float(num))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 4.*2.*1.5;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    float p1 = 1.;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    for(int k = 0; k < length_mod(uv,21); k++){\n\n        uv += t2;\n        uv /= -scale*p1*sign(uv.x);\n        t2 = p1*triangle_wave(uv-.5);\n        t3 = -p1*triangle_wave(uv.yx);\n        uv = t2-t3;\n        p1 *= -1.;\n        col.x = max(uv.y-uv.x,col.x*sqrt(2.))/sqrt(2.);\n        col = abs(col.yzx-vec3(col.x/sqrt(2.)))*2.;\n        \n        \n        //col.x = max(uv.y-uv.x-col.x,col.x)/(2.-uv.y);\n        //col.x = abs(.5-col.x);\n        //col = abs(col.yzx-vec3(col.x)*(2.-uv.x));\n    }\n    fragColor = vec4(col*2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 99], [101, 101, 128, 128, 178], [293, 293, 350, 350, 1203]], "test": "untested"}
{"id": "Nddfzj", "name": "spiral stairs slice", "author": "pyBlob", "description": "Use cylinder coordinates (b*2pi=angle, U.y=height) to show slices of [url=https://www.shadertoy.com/view/NscBzj]spiral stairs[/url] by [url=https://www.shadertoy.com/user/FabriceNeyret2]FabriceNeyret2[/url].", "tags": ["short"], "likes": 2, "viewed": 211, "published": 3, "date": "1656804323", "time_retrieved": "2024-07-30T16:41:59.559669", "image_code": "#define rot(a) mat2(cos(a+vec4(0,11,-11,0)))\n#define q(v) max(v.x, v.y)\n#define ri(r) (round(i=r)-i)\n#define iTime (iTime+iMouse.y/R.y*5.)\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float a // screen angle\n        , i, b, j\n        ;\n    vec3  R = iResolution\n        ;\n    U -= R.xy/2.;\n    vec2  V = U\n        ;\n    V.y *= 3.;\n    for (\n        O = vec4(a=j=0.) ;\n        V.x=U.x\n            / sin(a*6.28) // scale for orthographic projection\n        , j<250.\n        ; ++j, a+=.001 * sign(U.x)) // slices from 0Â° to +-90Â°\n    //; // only show widest slice\n    //if (V=U,a=atan(V.y, V.x)/6.28+.2*iTime, V = vec2(length(V), (j/250.-iTime/10.)*R.y), true) // horizontal slice\n        if ( // screw tunnel\n            b=a-.2*iTime, // world angle // <- can't move into first reference, because compiler might strip this assignment\n            V.x > // radius of section\n            .3*R.y * ( // base radius\n                ri(\n                    V.y/R.y*1. +\n                    b\n                )\n                + 1.\n            )\n            / q(abs(rot(b*6.28)[0])) // square, comment for cylinder\n            // ^ only nearly square. With show ramp, the central part is a perfect square/circle.\n            // For a circle, can you make it the spiral go tangential at the ends?\n           )\n        if ( // steps\n            .3 > // room height\n            abs(ri(\n                i\n                - b // removes ramp\n                + round(b*12.)/12. // adds stairs\n            ))\n            //, true // show ramp\n           )\n            O = mix(max(O, j/250.), vec4(1,.5,0,1), floor((j+1.)/250.));\n\n    // 200px squares\n    //O = vec4(length(U) * q(abs(rot(atan(U.y,U.x))[0])) < 200.);\n    //O = vec4(length(U) < 200. / q(abs(rot(atan(U.y,U.x))[0])));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nddfzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 176, 176, 1767]], "test": "untested"}
{"id": "fddfRj", "name": "2nd attempt multiscale truchet", "author": "mrange", "description": "License CC0: 2nd attempt multiscale truchet\nEveryone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\nBeen tinkering a bit more with multiscale truchet inspired by Shane's\n", "tags": ["2d", "truchet"], "likes": 20, "viewed": 374, "published": 3, "date": "1656794833", "time_retrieved": "2024-07-30T16:42:00.594901", "image_code": "// License CC0: 2nd attempt multiscale truchet\n// Everyone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\n// Been tinkering a bit more with multiscale truchet inspired by Shane's.\n// Made a height field and applied lighting to it. Kind of neat\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n#define DOT2(x)     dot(x,x)\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(vec3 t) {\n  return mix(1.055*pow(t, vec3(1./2.4)) - 0.055, 12.92*t, step(t, vec3(0.0031308)));\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat df0(vec2 p) {\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.125;\n  return d;\n}\n\nfloat df1(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+200.0);\n  float h1 = fract(8667.0*h0);\n\n  if (h1 < 0.5) {\n    return -(df0(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125*1.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125*1.5;\n  d = min(d, d2);\n  return d;\n}\n\nfloat df2(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+300.0);\n  float h1 = fract(8667.0*h0);\n\n  if (h1 < 0.5) {\n    return -(df1(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.666) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125;\n  d = min(d, d2);\n  d = abs(d)-0.0125*2.5;\n  return d;\n}\n\nfloat df(vec2 p) {\n  return df2(p);\n}\n\nfloat hf(vec2 p) {\n  float aa = 0.0275;\n  float d = df(p);\n  return -0.033*smoothstep(aa, -aa, -d);\n}\n\nfloat g_h3 = 0.0;\n\nfloat height(vec2 p) {\n  p *= 0.3333;\n  float h = hf(p);\n  p *= 3.0;\n  h += 0.5*hf(p);\n  p *= 3.0;\n  float h3 = hf(p);\n  h += 0.25*h3;\n  g_h3 = h3;\n  return h;\n}\n\nvec3 normal(vec2 p) {\n  vec2 e = vec2(4.0/RESOLUTION.y, 0);\n  \n  vec3 n;\n  n.x = height(p + e.xy) - height(p - e.xy);\n  n.y = 2.0*e.x;\n  n.z = height(p + e.yx) - height(p - e.yx);\n  \n  return normalize(n);\n}\n\nvec3 effect(vec2 p) {\n  const float s = 1.0;\n  \n  const float amp = 10.0;\n  vec2 off = amp*sin(vec2(1.0, sqrt(0.5))*TIME*TAU/(30.0*amp));\n  const vec3 lp1 = vec3(1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n  const vec3 lp2 = vec3(-1.0, 1.25, 1.0)*vec3(s, 1.0, s);\n\n  vec2 p0 = p;\n  p0 += off;\n  float h = height(p0);\n  float h3= g_h3;\n  vec3  n = normal(p0);\n\n  vec3 ro = vec3(0.0, -10.0, 0.0);\n  vec3 pp = vec3(p.x, 0.0, p.y);\n\n  vec3 po = vec3(p.x, h, p.y);\n  vec3 rd = normalize(ro - po);\n\n  vec3 ld1 = normalize(lp1 - po);\n  vec3 ld2 = normalize(lp2 - po);\n  \n  float diff1 = max(dot(n, ld1), 0.0);\n  float diff2 = max(dot(n, ld2), 0.0);\n\n  vec3  rn    = n;\n  vec3  ref   = reflect(rd, rn);\n  float ref1  = max(dot(ref, ld1), 0.0);\n  float ref2  = max(dot(ref, ld2), 0.0);\n  float fre   = 1.0+dot(n,rd);\n  float mh3  = smoothstep(-0.033, -0.015, h3);\n  vec3 mat   = HSV2RGB(vec3(0.66, 0.55, mix(0.75, 0.05, mh3)));\n  const vec3 lcol1 = HSV2RGB(vec3(0.60, 0.66, 6.0));\n  const vec3 lcol2 = HSV2RGB(vec3(0.05, 0.66, 2.0));\n  vec3 col = vec3(0.);\n  float dm = tanh_approx(-h*10.0+0.05);\n  float dist1 = DOT2(lp1 - po);\n  float dist2 = DOT2(lp2 - po);\n  col += (lcol1*mat)*(diff1*diff1/dist1);\n  col += (lcol2*mat)*(diff2*diff2/dist2);\n  col *= dm;\n  float rm = mix(0.125, 0.5, fre);\n  float spread = mix(80.0, 40.0, mh3);\n  col += (rm/dist1)*(pow(ref1, spread)*lcol1);\n  col += (rm/dist2)*(pow(ref2, spread)*lcol2);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddfRj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[490, 590, 609, 609, 696], [698, 805, 831, 831, 1015], [1169, 1169, 1191, 1191, 1337], [1632, 1692, 1713, 1713, 1783], [1785, 1785, 1813, 1833, 1909], [1911, 1911, 1942, 1942, 1968], [1970, 1970, 1989, 1989, 2246], [2248, 2248, 2267, 2267, 2697], [2699, 2699, 2718, 2718, 3167], [3169, 3169, 3187, 3187, 3206], [3208, 3208, 3226, 3226, 3309], [3330, 3330, 3352, 3352, 3491], [3493, 3493, 3514, 3514, 3700], [3702, 3702, 3723, 3723, 5123], [5125, 5125, 5180, 5180, 5416]], "test": "untested"}
{"id": "NscBzj", "name": "spiral stairs", "author": "FabriceNeyret2", "description": "WIP.\nwhy is 1.5 step  wall color instead of grey ?", "tags": ["raymarching", "short", "reproduction"], "likes": 19, "viewed": 420, "published": 3, "date": "1656791020", "time_retrieved": "2024-07-30T16:42:01.418699", "image_code": "\n// smooth fract. cf https://www.shadertoy.com/view/tsyXzV\n#  define sfloor(x) ( floor(x-pix/2.) + max( 0., 1.-fract(-(x)+pix/2.) / pix ) ) \n#  define sfract(x) ( x - sfloor(x) )\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n                                  \nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.,s, A, v, pix=.04; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -4.*R.y) - R),          // ray direction\n          p = 60./R, q,a,                                 // marching point along ray \n          M = iMouse.z > 0. ? .1*(iMouse.xyz/R -.5): vec3(10)/1e3*cos(iTime+vec3(0,11,0)); // auto demo\n//D.yz *= rot(-1.57-M.y*50.); D.xy *= rot(M.x*80.);       // debug view\n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01)          // march scene\n        q = p,\n        q.yz *= rot(-6.*M.y),                             // rotations\n        q.xz *= rot(-6.*M.x),\n        q.z -= 5.*iTime,\n        a = abs(q),\n        A = fract( atan(q.y,q.x)/6.28 - 1./8. ),          // steps fan\n        s = 10. - 3.*sfract(q.z/32.+ A) - max(a.x,a.y),        // stair walls\n        v = abs( fract(q.z/32.)*32. + sfloor(32.*A) -32.) -2., // steps surface\n        t = max(min(t, s ), -v), // s = max(s,max(a.x,a.y)-12.)\n     // t = min(9.,max( max(v,q.z+30.), abs(length(q.xy)-10.) -5.)), // test\n        \n        p += .5*t*D;                                      // step forward = dist to obj          \n   \n   if (t==s) O *= 2.*texture(iChannel0, a.x>a.y ? q.yz*.1 : q.xz*.1 ); // coloring\n}  // WIP: at wrong corner step s<0. !\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscBzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[303, 303, 339, 339, 1538]], "test": "untested"}
{"id": "NddBRj", "name": "uint pseudorandom numbers", "author": "Bloodwyn", "description": "found it here https://www.reedbeta.com/blog/quick-and-easy-gpu-random-numbers-in-d3d11/", "tags": ["randomnumbers"], "likes": 0, "viewed": 230, "published": 3, "date": "1656789286", "time_retrieved": "2024-07-30T16:42:02.331259", "image_code": "uint hash(uint seed){\n    seed = (seed ^ 61u) ^ (seed >> 16u);\n    seed *= 9u;\n    seed = seed ^ (seed >> 4u);\n    seed *= 0x27d4eb2du;\n    seed = seed ^ (seed >> 15u);\n    return seed;\n}\nuint combineSeed(uint a, uint b){\n\treturn hash(a) ^ hash(b);\n}\nfloat rand(inout uint seed){\n\tseed = hash(seed);\n\treturn float(seed) * (1.0 / float(~0u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uint seed = combineSeed(combineSeed(uint(iTime*1000.), uint(fragCoord.x)), uint(fragCoord.y));\n\n    // Output to screen\n    fragColor = vec4(rand(seed), rand(seed), rand(seed), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 187], [188, 188, 221, 221, 250], [251, 251, 279, 279, 343], [345, 345, 402, 402, 591]], "test": "untested"}
{"id": "fdtBRj", "name": "Cube Grabber", "author": "5t0n3r1pp3r", "description": "Built from two shaders https://www.shadertoy.com/view/sdcfDn & https://www.shadertoy.com/view/ssVcDz", "tags": ["cuby"], "likes": 1, "viewed": 447, "published": 3, "date": "1656784267", "time_retrieved": "2024-07-30T16:42:03.189963", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec3 img = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n   \tfragColor = vec4(img, 1.);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // The grid size\n    float gridWidth = 5.;\n    float gridHeight = 10.;\n    \n    // Basically the speed of the movement\n    float timeModifier = 1.;\n    // Fixed time delta to change the phase of movement of alternate y boundaries\n    float timeDelta = radians(90.);\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 channelColor = texture(iChannel0,uv);\n       \n    // Fill each cell\n    \n    float mody1 = mod(fragCoord.y+gridHeight*sin(iTime*timeModifier),gridHeight);\n    float mody2 = mod(fragCoord.y+gridHeight/2.-gridHeight*sin(iTime*timeModifier+timeDelta),gridHeight);\n    \n    float newx = fragCoord.x-mod(fragCoord.x,gridWidth);\n    float newy1 = fragCoord.y-mody1;\n    float newy2 = fragCoord.y-mody2;\n    \n    if(mod(fragCoord.x,gridWidth*2.) <= gridWidth)\n    {\n        vec2 rounduv = vec2(newx,newy1)/iResolution.xy;\n        channelColor = texture(iChannel0,rounduv);\n    }\n    else\n    {\n        vec2 rounduv = vec2(newx,newy2)/iResolution.xy;\n        channelColor = texture(iChannel0,rounduv);\n    }\n    \n    // Fill boundary\n    \n    //X boundary (Vertical lines)\n    if(mod(fragCoord.x,gridWidth)<=1.) channelColor = vec4(0,0,0,1);\n    \n    //Every alternate Y boundary is at a different height offset by gridHeight/2\n    if(mody1<=1. && mod(fragCoord.x,gridWidth*2.) <= gridWidth) channelColor = vec4(0,0,0,1);\n    if(mody2<=1. && mod(fragCoord.x,gridWidth*2.) >= gridWidth) channelColor = vec4(0,0,0,1);\n    \n    fragColor = channelColor;\n    \n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float rgbToGray(vec3 rgb) {\n\tconst vec3 W = vec3(0.2125, 0.7154, 0.0721);\n    return dot(rgb, W);\n}\n\nconst int KEY_SPACE  = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // mirror reverse the camera input\n    vec2 pos = fragCoord/iResolution.xy;\n    pos = vec2(1.0 - pos.x, pos.y);\n    \n    // KALEIDOSCOPE MODE\n    float upDown = texelFetch(iChannel2, ivec2(KEY_UP,0), 0).x;\n    if (upDown > 0.) {\n        pos *= 2.;\n        pos -= 1.;\n        pos = abs(pos);\n    }\n    \n    vec3 cam = texture(iChannel0,pos).xyz;\n    \n    vec2 offsetPos = fragCoord/iResolution.xy;\n\n    // ZOOM MODE\n    float rightDown = texelFetch(iChannel2, ivec2(KEY_RIGHT,0), 0).x;\n    if (rightDown > 0.) {\n        vec2 center = vec2(0.5, 0.5);\n        vec2 v2 = (fragCoord/iResolution.xy) - center;\n        v2 *= 0.995;\n        offsetPos = v2 + center;\n    }\n\n    vec3 image = texture(iChannel1,offsetPos).xyz;\n    \n    float camBrightness = rgbToGray(cam);\n    float imageBrightness = rgbToGray(image);\n        \n    if (camBrightness > imageBrightness) {\n\t    fragColor = vec4(cam, 1.);\n    } else {\n\t    fragColor = vec4(image * 0.999, 1.); // fade out    \n    }\n    \n    // PAUSE MODE\n     float downDown = texelFetch(iChannel2, ivec2(KEY_DOWN,0), 0).x;\n    if (downDown > 0.) {\n        fragColor = vec4(image, 1.);\n    }\n    \n    // CLEAR\n    float SpaceDown = texelFetch(iChannel2, ivec2(KEY_SPACE,1), 0).x;\n    if (SpaceDown > 0.) {\n        fragColor = vec4(0., 0., 0., 1.);\n    }\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nvec3 hueShift(vec3 color, float hue)\n{\n    const vec3 k = vec3(0.57735, 0.57735, 0.57735);\n    float cosAngle = cos(hue);\n    return vec3(color * cosAngle + cross(k, color) * sin(hue) + k * dot(k, color) * (1.0 - cosAngle));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 filtered = texture(iChannel0,fragCoord/iResolution.xy).xyz;\n    \n    // hue shift\n    vec3 shifted = filtered;\n    float leftDown = texelFetch(iChannel1, ivec2(KEY_LEFT,0), 0).x;\n    if (leftDown > 0.) {\n        shifted = hueShift(filtered, 0.1);\n    }\n   \n    // Slow fade\n    //fragColor = vec4(shifted * 0.999, 1.);\n    fragColor = vec4(shifted, 1.);\n    \n    // Click to clear\n    vec4 m = iMouse / iResolution.xxxx;\n    if(m.z>0.0 ) {\n        fragColor = vec4(0.,0.,0.,1.);\n    }\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtBRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 158]], "test": "untested"}
{"id": "sscfRj", "name": "Fake Voronoi 3D Param Visualizer", "author": "gehtsiegarnixan", "description": "Emulating a Voronoi pattern in under a tweet. While being readable and letting you pick the parameters with the mouse", "tags": ["voronoi", "mouse", "fast", "fake", "cellular"], "likes": 4, "viewed": 287, "published": 3, "date": "1656769206", "time_retrieved": "2024-07-30T16:42:04.126460", "image_code": "// The MIT License\n// Copyright Â© 2022 Gehtsiegarnixan\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n/*\nThis is a variant of Shane's Cellular Tiling \n(https://www.shadertoy.com/view/4scXz2, https://www.shadertoy.com/view/MdKXDD).\nHis versions are pretty extensively commented so give it a read. The main \nfeature of the celluar tiling is it looks very similar to Voronoi noise, \nbut it is much faster, because it does not use hash. It essentiall rotates \na number of sphere grids around to create the illusion of randomness.\n\nIf you want to see if this is faster than a texture lookup see here \n(https://www.shadertoy.com/view/sd3fDM).\n\nI changed a number of things to make it simpler and easier to understand. \nYou can also select a number of parameters with the mouse.\n- GridRes controls the size of the first grid sample\n- Level controls the number of grids added 3-4 looks pretty good.\n- Degree is controlled by the y-axis of the mouse. It selects the degree of \n    rotation around the x and z axis of each grid is offset to each other. You \n    should avoid multiple of 45 degrees and a few degrees around it.\n- Scale selects the size difference for each grid layer. Note that values \ngreater than about +-10% will make the edges rounded.\n\nI have made a number of comments to make it clear what is happening and why. \nThis probably only for myself, when I forgot how to do this in a year. \n*/\n\n// Text on Screen from Piperoman https://www.shadertoy.com/view/XllSWl\nfloat DigitBin(const in int x) {\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces) {\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    if ((vStringCharCoords.y < 0.0) || (vStringCharCoords.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCharCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) \n    {\n\t\tif(fDigitIndex > fBiggestIndex) \n        {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} \n        else \n        {\t\t\n\t\t\tif(fDigitIndex == -1.0) \n            {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} \n            else \n            {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue / (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCharCoords.x) * 4.0) + (floor(vStringCharCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// makes afmhot colormap with poly6 from me (https://www.shadertoy.com/view/Nd3fR2)\nvec3 afmhot(float t) {\n    const vec3 c0 = vec3(-0.020390,0.009557,0.018508);\n    const vec3 c1 = vec3(3.108226,-0.106297,-1.105891);\n    const vec3 c2 = vec3(-14.539061,-2.943057,14.548595);\n    const vec3 c3 = vec3(71.394557,22.644423,-71.418400);\n    const vec3 c4 = vec3(-152.022488,-31.024563,152.048692);\n    const vec3 c5 = vec3(139.593599,12.411251,-139.604042);\n    const vec3 c6 = vec3(-46.532952,-0.000874,46.532928);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// creates a sphere grid of the squared distance to the center\nfloat sphereGrid(vec3 uv) {\n    vec3 squaregrid = fract(uv) - .5; //rectangular grid with center in the middle\n    float spheregrid = dot(squaregrid, squaregrid); //squared distance form scenter\n    return spheregrid;\n}\n\n#define pi              3.1415926536\n// makes a tiling cell pattern\nfloat cellTiling3D(vec3 uvw, float degree, float scale, int level) {\n    float c = sphereGrid(uvw); // first grid\n    \n    // choose a deg/scale and calculate it here desmos.com/calculator/refsu6mvlj\n    float rad = (pi* degree)/180.; //degree to radians   \n    // This is rotation matrix X * Z, because symtery no 3. rot needed\n    mat3 m = mat3(cos(rad), -cos(rad)*sin(rad), pow(sin(rad),2.),\n                 sin(rad), pow(cos(rad),2.), -cos(rad)*sin(rad),\n                 0., sin(rad), cos(rad));\n    m *= scale;\n    \n    //If you want two indepented seperate rotations for X,Z use this\n    /*mat3 mZ = mat3(cos(rad), -sin(rad), 0.,\n                  sin(rad), cos(rad), 0.,\n                  0., 0., 1.); // rotation matric Z Axis\n    mat3 mX = mat3(1., 0., 0.,\n                   0., cos(rad), -sin(rad),\n                   0., sin(rad), cos(rad)); // rotation matric X Axis                                      \n    mat3 m = mX * mZ * scale; //scale and rotate. */\n    \n    // precalculate the m*m for perfromance\n    for (int i = 0; i < level-1; i++){    \n        uvw *= m; //each iteration gets rotated and scaled one addional time\n        c = min(c, sphereGrid(uvw)); // blending the voronoi with \n    }\n    \n    return sqrt(c); //sqrt for center distance, 1.5 for 0-1 range\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float gridRes = 6.0; //Hex Grid Size\n    int level = 4; //number of point grids, should be above 1. \n    \n    // mouse controls\n    float scale = 1.07; //default values for preview\n    float degree = 33.; // default values for preview\n    if(iMouse.x > 0.0)\t{\n        vec4 mouse = iMouse / iResolution.y;\n        scale = .17 * mouse.x +.85;  // value range .85-1.15\n        degree = mouse.y  * 90.; // it's a square gird going going larger than 90 is pointless\n    }\n        \n    //UV needs to be offset by a large vector from the 0,0, and avoiding 120/90/60 ... deg\n    vec2 offset = vec2(379., 769.); // two arbitrary large prime numbers\n    vec2 uv = vec2(fragCoord/iResolution.y - offset)*gridRes; // uv scaled and offset\n    vec3 uvw = vec3(uv, iTime * 0.5);\n            \n    float vor = cellTiling3D(uvw, degree, scale, level); // generating cell Tilling    \n    \n    vec3 vColour = afmhot(vor); // applying cosmetic colormap\n    \n    // Text portion\n    float fDigits = 1.0;\n\tfloat fDecimalPlaces = 3.0;\t\n    vec2 vFontSize = vec2(8.0, 15.0); // Multiples of 4x5 work best\n    \n    if(iMouse.x > 0.0)\t{\n        // Plot Mouse Pos Point\n\t    float fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\t    vColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n        \n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-62.0, 6.0);\n\t\tfloat fValue2 = scale;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit2 = PrintValue(fragCoord, vPixelCoord2, vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = degree;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue(fragCoord, vPixelCoord3, vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n    \n    fragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscfRj.jpg", "access": "api", "license": "mit", "functions": [[3875, 3959, 3981, 3981, 4444], [4446, 4509, 4536, 4536, 4728], [4767, 4798, 4866, 4866, 6085], [6087, 6087, 6144, 6144, 8067]], "test": "untested"}
{"id": "sscBRj", "name": "1st attempt multiscale truchet", "author": "mrange", "description": "License CC0: First attempt multiscale tiling\nEveryone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\nI was trying to understand what was going and my brain hurt.", "tags": ["2d", "truchet"], "likes": 16, "viewed": 285, "published": 3, "date": "1656765996", "time_retrieved": "2024-07-30T16:42:04.984166", "image_code": "// License CC0: 1st attempt multiscale truchet\n// Everyone loves truchet tiles. Shane did an amazing one: https://www.shadertoy.com/view/4t3BW4\n// I was trying to understand what was going and my brain hurt.\n// Anyway after some tinkering I think I got the gist of it. The idea is brilliant!\n// Compared to Shane's this looks awful but I have a low barrier to what I chose to share :)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// Classic truchet pattern\nfloat df0(vec2 p) {\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d) - 0.125;\n  return d;\n}\n\n// Multiscale truchet\nfloat df1(vec2 p) {\n  vec2 op = p;\n  p -= 0.5;\n  vec2 n = round(p);\n  p -= n;\n  float h0 = hash(n+100.0);\n  float h1 = fract(8667.0*h0);\n\n  // Recurse to df0 for 50% of the tiles\n  if (h1 < 0.5) {\n    // Invert the distance to make inside into outside\n    return -(df0(2.0*op))*0.5;\n  }\n\n  if (h0 > 0.5) {\n    p = vec2(p.y, -p.x);;\n  }\n\n  // Classic truchet with an added circle\n  // so that the outside areas matches up with the nested truchet \n  float d0 = circle(p-0.5, 0.5);\n  float d1 = circle(p+0.5, 0.5);\n  p = abs(p);\n  float d2 = circle(p-0.5, 0.125*1.5);\n  float d = d0;\n  d = min(d, d1);\n  d = abs(d)-0.125*1.5;\n  d = min(d, d2);\n  return d;\n}\n\nfloat df(vec2 p) {\n  return df1(p);\n}\n\nvec3 effect(vec2 p) {\n  float aa = 2.0/RESOLUTION.y;\n  const float amp = 10.0;\n  p += amp*sin(vec2(1.0, sqrt(0.5))*TIME*TAU/(10.0*amp));\n  const float sz = 0.25;\n  float d = df(p/sz)*sz;\n  vec3 col = vec3(0.01);\n  col = mix(col, vec3(0.5), smoothstep(aa, -aa, d));\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);  \n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sscBRj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[506, 566, 587, 587, 657], [659, 659, 690, 690, 716], [718, 745, 764, 764, 1021], [1023, 1045, 1064, 1064, 1699], [1701, 1701, 1719, 1719, 1738], [1740, 1740, 1761, 1761, 2020], [2022, 2022, 2074, 2074, 2249]], "test": "untested"}
{"id": "Nd3fR2", "name": "matplotlib Color Maps", "author": "gehtsiegarnixan", "description": "I wanted more colormaps from matplotlib, so I made a python script to translate every Colormap ([url]https://pastebin.com/mf5GfGCc[/url]).", "tags": ["colormap", "polynomial", "uniform", "viridis", "magma", "python", "inferno", "matplotlib", "perceptually", "fitcolormap", "cmap", "plt"], "likes": 21, "viewed": 736, "published": 3, "date": "1656762159", "time_retrieved": "2024-07-30T16:42:06.003440", "image_code": "/* \nGrayscale is boring. Feel free to use these for your projects. \n\nI wanted more colormaps to choose from. I already had a cmap \ntranslator into textures, graphs, and csv laying around.\nI added a simple scipy fitter to translate any cmap into poly6 \nfunctions too. It doesn't work for all colormaps, but all the \npretty ones work great. \n\nIf you want to add a colormap thats not here you can use my\npython code to make it yourself (https://pastebin.com/mf5GfGCc)\n\nIf you wonder how all the other colormaps look, see an \nincomplete list the matplotlib documentation \n(https://matplotlib.org/stable/tutorials/colors/colormaps.html)\nor my graphs with everything (https://imgur.com/a/xfZlxlp).\n\nIf you want to imporve the default mpl color maps use gamma \nadjustment suggested by xrx to remove color bleeding:\nfragColor.xyz = pow(fragColor.xyz,vec3(.455));\nGamma Color Adjustment is showcased here: \nhttps://www.shadertoy.com/view/WdXGzl\n*/\n\n// makes afmhot colormap with polynimal 6\nvec3 afmhot(float t) {\n    const vec3 c0 = vec3(-0.020390,0.009557,0.018508);\n    const vec3 c1 = vec3(3.108226,-0.106297,-1.105891);\n    const vec3 c2 = vec3(-14.539061,-2.943057,14.548595);\n    const vec3 c3 = vec3(71.394557,22.644423,-71.418400);\n    const vec3 c4 = vec3(-152.022488,-31.024563,152.048692);\n    const vec3 c5 = vec3(139.593599,12.411251,-139.604042);\n    const vec3 c6 = vec3(-46.532952,-0.000874,46.532928);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes Blues_r colormap with polynimal 6\nvec3 Blues_r(float t) {\n    const vec3 c0 = vec3(0.042660,0.186181,0.409512);\n    const vec3 c1 = vec3(-0.703712,1.094974,2.049478);\n    const vec3 c2 = vec3(7.995725,-0.686110,-4.998203);\n    const vec3 c3 = vec3(-24.421963,2.680736,7.532937);\n    const vec3 c4 = vec3(47.519089,-4.615112,-5.126531);\n    const vec3 c5 = vec3(-46.038418,2.606781,0.685560);\n    const vec3 c6 = vec3(16.586546,-0.279280,0.447047);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes bone colormap with polynimal 6\nvec3 bone(float t) {\n    const vec3 c0 = vec3(-0.005007,-0.003054,0.004092);\n    const vec3 c1 = vec3(1.098251,0.964561,0.971829);\n    const vec3 c2 = vec3(-2.688698,-0.537516,2.444353);\n    const vec3 c3 = vec3(12.667310,-0.657473,-8.158684);\n    const vec3 c4 = vec3(-27.183124,8.398806,10.182004);\n    const vec3 c5 = vec3(26.505377,-12.576925,-5.329155);\n    const vec3 c6 = vec3(-9.395265,5.416416,0.883918);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes BuPu_r colormap with polynimal 6\nvec3 BuPu_r(float t) {\n    const vec3 c0 = vec3(0.290975,0.010073,0.283355);\n    const vec3 c1 = vec3(2.284922,-0.278000,1.989093);\n    const vec3 c2 = vec3(-6.399278,8.646163,-3.757712);\n    const vec3 c3 = vec3(2.681161,-20.491129,4.065305);\n    const vec3 c4 = vec3(12.990405,24.836197,0.365773);\n    const vec3 c5 = vec3(-16.216830,-16.111779,-4.006291);\n    const vec3 c6 = vec3(5.331023,4.380922,2.057249);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes cividis colormap with polynimal 6\nvec3 cividis(float t) {\n    const vec3 c0 = vec3(-0.008598,0.136152,0.291357);\n    const vec3 c1 = vec3(-0.415049,0.639599,3.028812);\n    const vec3 c2 = vec3(15.655097,0.392899,-22.640943);\n    const vec3 c3 = vec3(-59.689584,-1.424169,75.666364);\n    const vec3 c4 = vec3(103.509006,2.627500,-122.512551);\n    const vec3 c5 = vec3(-84.086992,-2.156916,94.888003);\n    const vec3 c6 = vec3(26.055600,0.691800,-28.537831);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes CMRmap colormap with polynimal 6\nvec3 CMRmap(float t) {\n    const vec3 c0 = vec3(-0.046981,0.001239,0.005501);\n    const vec3 c1 = vec3(4.080583,1.192717,3.049337);\n    const vec3 c2 = vec3(-38.877409,1.524425,20.200215);\n    const vec3 c3 = vec3(189.038452,-32.746447,-140.774611);\n    const vec3 c4 = vec3(-382.197327,95.587531,270.024592);\n    const vec3 c5 = vec3(339.891791,-100.379096,-212.471161);\n    const vec3 c6 = vec3(-110.928480,35.828481,60.985694);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes coolwarm colormap with polynimal 6\nvec3 coolwarm(float t) {\n    const vec3 c0 = vec3(0.227376,0.286898,0.752999);\n    const vec3 c1 = vec3(1.204846,2.314886,1.563499);\n    const vec3 c2 = vec3(0.102341,-7.369214,-1.860252);\n    const vec3 c3 = vec3(2.218624,32.578457,-1.643751);\n    const vec3 c4 = vec3(-5.076863,-75.374676,-3.704589);\n    const vec3 c5 = vec3(1.336276,73.453060,9.595678);\n    const vec3 c6 = vec3(0.694723,-25.863102,-4.558659);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes cubehelix colormap with polynimal 6\nvec3 cubehelix(float t) {\n    const vec3 c0 = vec3(-0.079465,0.040608,-0.009636);\n    const vec3 c1 = vec3(6.121943,-1.666276,1.342651);\n    const vec3 c2 = vec3(-61.373834,27.620334,19.280747);\n    const vec3 c3 = vec3(240.127160,-93.314549,-154.494465);\n    const vec3 c4 = vec3(-404.129586,133.012936,388.857101);\n    const vec3 c5 = vec3(306.008802,-81.526778,-397.337219);\n    const vec3 c6 = vec3(-85.633074,16.800478,143.433300);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes gist_earth colormap with polynimal 6\nvec3 gist_earth(float t) {\n    const vec3 c0 = vec3(-0.005626,-0.032771,0.229230);\n    const vec3 c1 = vec3(0.628905,1.462908,4.617318);\n    const vec3 c2 = vec3(3.960921,9.740478,-25.721645);\n    const vec3 c3 = vec3(-32.735710,-53.470618,60.568598);\n    const vec3 c4 = vec3(91.584783,109.398709,-74.866221);\n    const vec3 c5 = vec3(-101.138314,-103.815111,48.418061);\n    const vec3 c6 = vec3(38.745198,37.752237,-12.232828);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes hsv colormap with polynimal 6\nvec3 hsv(float t) {\n    const vec3 c0 = vec3(0.834511,-0.153764,-0.139860);\n    const vec3 c1 = vec3(8.297883,13.629371,7.673034);\n    const vec3 c2 = vec3(-80.602944,-80.577977,-90.865764);\n    const vec3 c3 = vec3(245.028545,291.294154,390.181844);\n    const vec3 c4 = vec3(-376.406597,-575.667879,-714.180803);\n    const vec3 c5 = vec3(306.639709,538.472148,596.580595);\n    const vec3 c6 = vec3(-102.934273,-187.108098,-189.286489);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes inferno colormap with polynimal 6\nvec3 inferno(float t) {\n    const vec3 c0 = vec3(0.000129,0.001094,-0.041044);\n    const vec3 c1 = vec3(0.083266,0.574933,4.155398);\n    const vec3 c2 = vec3(11.783686,-4.013093,-16.439814);\n    const vec3 c3 = vec3(-42.246539,17.689298,45.210269);\n    const vec3 c4 = vec3(78.087062,-33.838649,-83.264061);\n    const vec3 c5 = vec3(-72.108852,32.950143,74.479447);\n    const vec3 c6 = vec3(25.378501,-12.368929,-23.407604);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes jet colormap with polynimal 6\nvec3 jet(float t) {\n    const vec3 c0 = vec3(-0.071839,0.105300,0.510959);\n    const vec3 c1 = vec3(3.434264,-5.856282,5.020179);\n    const vec3 c2 = vec3(-35.088272,62.590515,-12.661725);\n    const vec3 c3 = vec3(125.621078,-187.192678,8.399805);\n    const vec3 c4 = vec3(-179.495111,277.458688,-26.089763);\n    const vec3 c5 = vec3(113.825719,-218.486063,52.463600);\n    const vec3 c6 = vec3(-27.714880,71.427477,-27.714893);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes jet colormap with polynimal 6\nvec3 magma(float t) {\n    const vec3 c0 = vec3(-0.002292,-0.001348,-0.011890);\n    const vec3 c1 = vec3(0.234451,0.702427,2.497211);\n    const vec3 c2 = vec3(8.459706,-3.649448,0.385699);\n    const vec3 c3 = vec3(-28.029205,14.441378,-13.820938);\n    const vec3 c4 = vec3(52.814176,-28.301374,13.021646);\n    const vec3 c5 = vec3(-51.349945,29.406659,4.305315);\n    const vec3 c6 = vec3(18.877608,-11.626687,-5.627010);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes ocean colormap with polynimal 6\nvec3 ocean(float t) {\n    const vec3 c0 = vec3(0.005727,0.451550,-0.000941);\n    const vec3 c1 = vec3(-0.112625,1.079697,1.001170);\n    const vec3 c2 = vec3(-0.930272,-28.415474,0.004744);\n    const vec3 c3 = vec3(15.125713,109.226840,-0.011841);\n    const vec3 c4 = vec3(-54.993643,-168.660130,0.012964);\n    const vec3 c5 = vec3(74.155713,119.622305,-0.005110);\n    const vec3 c6 = vec3(-32.297651,-32.297650,-0.000046);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes PuBu_r colormap with polynimal 6\nvec3 PuBu_r(float t) {\n    const vec3 c0 = vec3(-0.006363,0.212872,0.336555);\n    const vec3 c1 = vec3(1.081919,1.510170,1.985891);\n    const vec3 c2 = vec3(-14.783872,-6.062404,-2.068039);\n    const vec3 c3 = vec3(71.020484,24.455925,-4.350981);\n    const vec3 c4 = vec3(-127.620020,-46.977973,14.599012);\n    const vec3 c5 = vec3(101.930678,41.789097,-14.293631);\n    const vec3 c6 = vec3(-30.634205,-13.967854,4.778537);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes rainbow colormap with polynimal 6\nvec3 rainbow(float t) {\n    const vec3 c0 = vec3(0.503560,-0.002932,1.000009);\n    const vec3 c1 = vec3(-1.294985,3.144463,0.001872);\n    const vec3 c2 = vec3(-16.971202,0.031355,-1.232219);\n    const vec3 c3 = vec3(97.134102,-5.180126,-0.029721);\n    const vec3 c4 = vec3(-172.585487,-0.338714,0.316782);\n    const vec3 c5 = vec3(131.971426,3.514534,-0.061568);\n    const vec3 c6 = vec3(-37.784412,-1.171512,0.003376);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes PuRd_r colormap with polynimal 6\nvec3 PuRd_r(float t) {\n    const vec3 c0 = vec3(0.425808,-0.016400,0.108687);\n    const vec3 c1 = vec3(0.317304,0.729767,2.091430);\n    const vec3 c2 = vec3(13.496685,-7.880910,-14.132707);\n    const vec3 c3 = vec3(-48.433187,38.030685,64.370712);\n    const vec3 c4 = vec3(60.867293,-65.403385,-126.336402);\n    const vec3 c5 = vec3(-28.305816,50.079623,111.580346);\n    const vec3 c6 = vec3(2.578842,-14.582396,-36.726260);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes RdYlBu_r colormap with polynimal 6\nvec3 RdYlBu_r(float t) {\n    const vec3 c0 = vec3(0.207621,0.196195,0.618832);\n    const vec3 c1 = vec3(-0.088125,3.196170,-0.353302);\n    const vec3 c2 = vec3(8.261232,-8.366855,14.368787);\n    const vec3 c3 = vec3(-2.922476,33.244294,-43.419173);\n    const vec3 c4 = vec3(-34.085327,-74.476041,37.159352);\n    const vec3 c5 = vec3(50.429790,67.145621,-1.750169);\n    const vec3 c6 = vec3(-21.188828,-20.935464,-6.501427);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes Spectral_r colormap with polynimal 6\nvec3 Spectral_r(float t) {\n    const vec3 c0 = vec3(0.426208,0.275203,0.563277);\n    const vec3 c1 = vec3(-5.321958,3.761848,5.477444);\n    const vec3 c2 = vec3(42.422339,-15.057685,-57.232349);\n    const vec3 c3 = vec3(-100.917716,57.029463,232.590601);\n    const vec3 c4 = vec3(106.422535,-116.177338,-437.123306);\n    const vec3 c5 = vec3(-48.460514,103.570154,378.807920);\n    const vec3 c6 = vec3(6.016269,-33.393152,-122.850806);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes twilight colormap with polynimal 6\nvec3 twilight(float t) {\n    const vec3 c0 = vec3(0.996106,0.851653,0.940566);\n    const vec3 c1 = vec3(-6.529620,-0.183448,-3.940750);\n    const vec3 c2 = vec3(40.899579,-7.894242,38.569228);\n    const vec3 c3 = vec3(-155.212979,4.404793,-167.925730);\n    const vec3 c4 = vec3(296.687222,24.084913,315.087856);\n    const vec3 c5 = vec3(-261.270519,-29.995422,-266.972991);\n    const vec3 c6 = vec3(85.335349,9.602600,85.227117);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes twilight_shifted colormap with polynimal 6\nvec3 twilight_shifted(float t) {\n    const vec3 c0 = vec3(0.120488,0.047735,0.106111);\n    const vec3 c1 = vec3(5.175161,0.597944,7.333840);\n    const vec3 c2 = vec3(-47.426009,-0.862094,-49.143485);\n    const vec3 c3 = vec3(197.225325,47.538667,194.773468);\n    const vec3 c4 = vec3(-361.218441,-146.888121,-389.642741);\n    const vec3 c5 = vec3(298.941929,151.947507,359.860766);\n    const vec3 c6 = vec3(-92.697067,-52.312119,-123.143476);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes viridis colormap with polynimal 6\nvec3 viridis(float t) {\n    const vec3 c0 = vec3(0.274344,0.004462,0.331359);\n    const vec3 c1 = vec3(0.108915,1.397291,1.388110);\n    const vec3 c2 = vec3(-0.319631,0.243490,0.156419);\n    const vec3 c3 = vec3(-4.629188,-5.882803,-19.646115);\n    const vec3 c4 = vec3(6.181719,14.388598,57.442181);\n    const vec3 c5 = vec3(4.876952,-13.955112,-66.125783);\n    const vec3 c6 = vec3(-5.513165,4.709245,26.582180);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes YlGnGn_r colormap with polynimal 6\nvec3 YlGnGn_r(float t) {\n    const vec3 c0 = vec3(0.006153,0.269865,0.154795);\n    const vec3 c1 = vec3(-0.563452,1.218061,0.825586);\n    const vec3 c2 = vec3(7.296193,-2.560031,-5.402727);\n    const vec3 c3 = vec3(-19.990101,12.478140,25.051507);\n    const vec3 c4 = vec3(37.139815,-26.377692,-45.607642);\n    const vec3 c5 = vec3(-35.072408,24.166247,36.357837);\n    const vec3 c6 = vec3(12.187661,-8.203542,-10.475316);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes YlGnBu_r colormap with polynimal 6\nvec3 YlGnBu_r(float t) {\n    const vec3 c0 = vec3(0.016999,0.127718,0.329492);\n    const vec3 c1 = vec3(1.571728,0.025897,2.853610);\n    const vec3 c2 = vec3(-4.414197,5.924816,-11.635781);\n    const vec3 c3 = vec3(-12.438137,-8.086194,34.584365);\n    const vec3 c4 = vec3(67.131044,-2.929808,-58.635788);\n    const vec3 c5 = vec3(-82.372983,11.898509,47.184502);\n    const vec3 c6 = vec3(31.515446,-5.975157,-13.820580);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\n// makes YlGnBu_r colormap with polynimal 6\nvec3 YlGnRd_r(float t) {\n    const vec3 c0 = vec3(0.501291,0.002062,0.146180);\n    const vec3 c1 = vec3(1.930635,-0.014549,0.382222);\n    const vec3 c2 = vec3(0.252402,-2.449429,-6.385366);\n    const vec3 c3 = vec3(-10.884918,30.497903,29.134150);\n    const vec3 c4 = vec3(18.654329,-67.528678,-54.909286);\n    const vec3 c5 = vec3(-12.193478,59.311181,49.311295);\n    const vec3 c6 = vec3(2.736321,-18.828760,-16.894758);\n    return c0+t*(c1+t*(c2+t*(c3+t*(c4+t*(c5+t*c6)))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float cmapCount = 25.;\n    float x = floor(uv.x*cmapCount);    \n    fragColor = vec4(0, 0, 0, 1);\n    \n    if (x == 0.) {\n        fragColor.xyz = afmhot(uv.y);\n    } else if (x == 1.) {\n        fragColor.xyz = Blues_r(uv.y);\n    } else if (x == 2.) {\n        fragColor.xyz = bone(uv.y);\n    } else if (x == 3.) {\n        fragColor.xyz = BuPu_r(uv.y);\n    } else if (x == 4.) {\n        fragColor.xyz = cividis(uv.y);\n    } else if (x == 5.) {\n        fragColor.xyz = CMRmap(uv.y);\n    } else if (x == 6.) {\n        fragColor.xyz = coolwarm(uv.y);\n    } else if (x == 7.) {\n        fragColor.xyz = cubehelix(uv.y);\n    } else if (x == 8.) {\n        fragColor.xyz = gist_earth(uv.y);\n    } else if (x == 9.) {\n        fragColor.xyz = hsv(uv.y);\n    } else if (x == 10.) {\n        fragColor.xyz = inferno(uv.y);\n    } else if (x == 11.) {\n        fragColor.xyz = jet(uv.y);\n    } else if (x == 12.) {\n        fragColor.xyz = magma(uv.y);\n    } else if (x == 13.) {\n        fragColor.xyz = ocean(uv.y);\n    } else if (x == 14.) {\n        fragColor.xyz = PuBu_r(uv.y);\n    } else if (x == 15.) {\n        fragColor.xyz = rainbow(uv.y);\n    } else if (x == 16.) {\n        fragColor.xyz = PuRd_r(uv.y);\n    } else if (x == 17.) {\n        fragColor.xyz = RdYlBu_r(uv.y);\n    } else if (x == 18.) {\n        fragColor.xyz = Spectral_r(uv.y);\n    } else if (x == 19.) {\n        fragColor.xyz = twilight(uv.y);\n    } else if (x == 20.) {\n        fragColor.xyz = twilight_shifted(uv.y);\n    } else if (x == 21.) {\n        fragColor.xyz = viridis(uv.y);\n    } else if (x == 22.) {\n        fragColor.xyz = YlGnGn_r(uv.y);\n    } else if (x == 23.) {\n        fragColor.xyz = YlGnBu_r(uv.y);\n    } else if (x == 24.) {\n        fragColor.xyz = YlGnRd_r(uv.y);\n    }   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3fR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[940, 982, 1004, 1004, 1467], [1469, 1512, 1535, 1535, 1982], [1984, 2024, 2044, 2044, 2494], [2496, 2538, 2560, 2560, 3007], [3009, 3052, 3075, 3075, 3531], [3533, 3575, 3597, 3597, 4062], [4064, 4108, 4132, 4132, 4579], [4581, 4626, 4651, 4651, 5119], [5121, 5167, 5193, 5193, 5653], [5655, 5694, 5713, 5713, 6187], [6189, 6232, 6255, 6255, 6713], [6715, 6754, 6773, 6773, 7238], [7240, 7279, 7300, 7300, 7755], [7757, 7798, 7819, 7819, 8277], [8279, 8321, 8343, 8343, 8801], [8803, 8846, 8869, 8869, 9322], [9324, 9366, 9388, 9388, 9847], [9849, 9893, 9917, 9917, 10373], [10375, 10421, 10447, 10447, 10913], [10915, 10959, 10983, 10983, 11445], [11447, 11499, 11531, 11531, 11998], [12000, 12043, 12066, 12066, 12514], [12516, 12560, 12584, 12584, 13039], [13041, 13085, 13109, 13109, 13563], [13565, 13609, 13633, 13633, 14088], [14090, 14090, 14147, 14147, 15943]], "test": "untested"}
{"id": "NdcBR2", "name": "Abstract dragon scales", "author": "mrange", "description": "License CC0: Abstract dragon scales\nContinued tinkering with the \"bubblesort\"\nI suppose next step is to compute the normal of the scales \nand apply some nice metallic lighting to make it look like \n\"real\" dragon scales\n", "tags": ["2d", "bubblesort"], "likes": 24, "viewed": 367, "published": 3, "date": "1656758667", "time_retrieved": "2024-07-30T16:42:06.759419", "image_code": "// License CC0: Abstract dragon scales\n// Continued tinkering with the \"bubblesort\"\n// I suppose next step is to compute the normal of the scales \n// and apply some nice metallic lighting to make it look like \n// \"real\" dragon scales\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\n//  Macro version of above to enable compile-time constants\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nvec2 mod2_1(inout vec2 p) {\n  p += 0.5;\n  vec2 n = floor(p);\n  p = fract(p)-0.5;\n  return n;\n}\n\nvec3 alphaBlend(vec3 back, vec4 front) {\n  // Based on: https://en.wikipedia.org/wiki/Alpha_compositing\n  return mix(back, front.xyz, front.w);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat egg(vec2 p, float ra, float rb) {\n  const float k = sqrt(3.0);\n  p.x = abs(p.x);\n  float r = ra - rb;\n  return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n          (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                            length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\n\nfloat cellhf(vec2 n) {\n  float h = texture(iChannel0, 0.005*n+0.5).x;\n  h = sqrt(abs(h));\n  return h;\n}\n\nfloat celldf(vec2 p, vec2 n) {\n  float hh = cellhf(n);\n  vec2 hxx = vec2(cellhf(n-vec2(1.0, 0.0))-hh, cellhf(n-vec2(0.0, 1.0))-hh);\n  float hl = length(hxx);\n  hxx /= hl;\n  vec2 hyy = vec2(hxx.y, -hxx.x);\n  const float off = 0.25;\n  if (hl > 1E-6) p *= mat2(hxx, hyy);\n  float r = (sqrt(0.5)+off);\n  float d = egg(p.yx, r*0.9, 0.25*r);\n  return d;\n}\n\nvec3 effect(vec2 p) {\n  const float sz = 0.25;\n  const float amp = 10.0;\n  const float th = -TAU*sz*20.0;\n  p += amp*cos(vec2(1.0, sqrt(0.5))*TAU*(TIME)/(amp*30.0));\n  vec2 op = p;\n  p /= sz;  \n  float aa = 2.0/(sz*RESOLUTION.y);\n  vec2 n = mod2_1(p);\n\n  const int c = 1;\n  const int l = (2*c+1)*(2*c+1);\n  vec2 results[l];\n  int j = 0;\n  for (int x = -c; x <= c; ++x) {\n    for (int y = -c; y <= c; ++y) {\n      vec2 off = vec2(float(x), float(y));\n      vec2 pp = p - off;\n      vec2 nn = n + off;\n      \n      float d = celldf(pp, nn);\n      float h = cellhf(nn);\n      \n      results[j] = vec2(d, h);\n      ++j;\n    }\n  }\n\n  // Bubblesort in 2022?\n  for (int o = 1; o < l; ++o) {\n    vec2 r = results[o];\n    for (int i = o; i > 0; --i) {\n      vec2 l = results[i-1];\n      if (l.y > r.y) {\n        results[i - 1] = r;\n        results[i] = l;\n      } else {\n        r = l;\n      }\n    }\n  }\n\n  vec3 col = vec3(0.0);\n  for (int i = 0; i < l; ++i) {\n    vec2 r = results[i];\n    float d = r.x;\n    float h = r.y;\n    vec4 bcol0 = vec4(hsv2rgb(vec3(fract(0.05*length(op)), mix(0.125, 1.0, h), mix(0.25, 1.0, h))), 1.0);\n    vec4 bcol1 = vec4(vec3(bcol0*bcol0*0.25), 0.5);\n    vec4 bcol = mix(bcol0, bcol1, smoothstep(-th*aa, th*aa, sin(th*d)));\n    float t = smoothstep(aa, -aa, d);\n    vec4 ccol = bcol;\n    ccol.w *= t;\n    col *= mix(1.0, 0.25, exp(-10.0*max(d, 0.0)));\n    col = alphaBlend(col, ccol);\n  }\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n    \n  col = clamp(col, 0.0, 1.0);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = sqrt(col);\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcBR2.jpg", "access": "api", "license": "cc0-1.0", "functions": [[506, 506, 528, 528, 674], [969, 969, 996, 996, 1063], [1065, 1065, 1105, 1168, 1210], [1212, 1330, 1369, 1369, 1630], [1632, 1632, 1654, 1654, 1735], [1737, 1737, 1767, 1767, 2086], [2088, 2088, 2109, 2109, 3515], [3517, 3517, 3572, 3572, 3817]], "test": "untested"}
{"id": "7ddfRB", "name": "Self supporting SPH", "author": "fenix", "description": "*drag with mouse* *space to reset* Fixed neighborhood bugs. Increased convergence by solving the neighborhood, obviating the need for the expensive density transport via blur. It's amazing that GPUs have so much power they can throw this much data away.", "tags": ["2d", "voronoi", "simulation", "particles", "flow", "liquid", "sph"], "likes": 15, "viewed": 408, "published": 3, "date": "1656746882", "time_retrieved": "2024-07-30T16:42:07.761739", "image_code": "// ---------------------------------------------------------------------------------------\n//\tCreated by fenix in 2022\n//\tLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n//  Multipass particle physics simulation, attempting to approximate smoothed particle\n//  hydrodynamics. \n// \n//  Buffer A computes the particle positions and neighbors\n//  Buffer B does a traditional voronoi search to help out building neighborhoods\n//  Buffer C renders the particles into a density texture\n//  Buffer D blurs the density\n//\n// ---------------------------------------------------------------------------------------\n\n// Render particle SDF\n\nconst float PARTICLE_SDF_SIZE = 0.04;\n\nvoid renderParticle(in fxParticle p, in vec2 fragCoord, inout vec4 fragColor)\n{   \n    //if (p.density < 50.0) return;\n    vec2 closest;\n    float dist = linePointDist2(p.pos, p.pos - p.vel, fragCoord, iResolution, closest);\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n\n    fragColor.w += max(0.0, PARTICLE_SDF_SIZE - sqrt(dist)) / PARTICLE_SDF_SIZE;\n    //fragColor.xyz += 1000.2 * p.pressure * particleColor(p.uv) * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n    vec3 color = vec3(200.0*p.pressure, 30000.0*dot(p.vel, p.vel), 0.000012*p.density*p.density*p.density);\n    fragColor.xyz += color * max(0.0, PARTICLE_SIZE - sqrt(dist)) / PARTICLE_SIZE;\n    \n    // Render neighbor lines\n    #if 1\n    for(int i = 0; i < 4; i++){\n        ivec4 neighbors = p.neighbors[i];\n        for (int j = 0; j < 4; ++j)\n        {\n            int cid = neighbors[j];\n            if(cid==-1 || cid >= maxParticles || cid == 0) continue;\n\n            vec2 otherPos = fxGetParticleData(cid, POS_VEL).xy;\n\n            if (length(otherPos - p.pos) < 0.1)\n            {\n                float distToLin = linePointDist2(p.pos, p.pos + 0.5 * (otherPos - p.pos), fragCoord, iResolution, closest);\n                fragColor.xyz += color * max(0.0, PARTICLE_SIZE * 0.3 - sqrt(distToLin)) / (PARTICLE_SIZE);\n            }\n        }\n    }\n    #endif\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    \n    fragColor = vec4(0.0);\n  \tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.xy;\n\n    //get the id's of the 4 particles that (should be) closest.\n    //the 4 ids are stored in .x, .y, .z, .w\n    ivec4 ids = fxGetClosest(ivec2(fragCoord));\n    \n    //draw the particles\n    for(int i = 0; i < 4; i++){\n        //get the particles position\n        int id = ids[i];\n        fxParticle particle = fxGetParticle(id);\n\n        renderParticle(particle, p, fragColor);\n    }\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//amount of particles\nconst int MAX_PARTICLES = 3000; \nconst int PARTICLE_INIT_X = 10;\nconst float PARTICLE_SIZE = 0.03;\nconst float PARTICLE_REPEL_SIZE = 0.015;\nconst float MOVING_WALL_MAG = 0.0;\nconst float MOVING_WALL_TIME = 3.0;\n\n//hashing noise by IQ\nfloat hash( int k ) {\n    uint n = uint(k);\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return uintBitsToFloat( (n>>9U) | 0x3f800000U ) - 1.0;\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 world2screenInternal(in vec2 p, in vec2 resolution)\n{\n    return (p + 1.0) * 0.5 * resolution;\n}\n\n#define world2screen(X) world2screenInternal(X, iResolution.xy)\n\nvec2 screen2worldInternal(in vec2 p, in vec2 resolution)\n{\n    return (p / resolution) * 2.0 - 1.0;\n}\n\n#define screen2world(X) screen2worldInternal(X, iResolution.xy)\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\nfloat linePointDist2(in vec2 newPos, in vec2 oldPos, in vec2 fragCoord, in vec3 resolution, out vec2 closest)\n{\n    vec2 pDelta = (fragCoord - oldPos);\n    vec2 delta = newPos - oldPos;\n    float deltaLen2 = dot(delta, delta);\n\n    // Find the closest point on the line segment from old to new\n    closest;\n    if (deltaLen2 > 0.0000001)\n    {\n        float deltaInvSqrt = inversesqrt(deltaLen2);\n        vec2 deltaNorm = delta * deltaInvSqrt;\n        closest = oldPos + deltaNorm * max(0.0, min(1.0 / deltaInvSqrt, dot(deltaNorm, pDelta)));\n    }\n    else\n    {\n        closest = oldPos;\n    }\n\n    // Distance to closest point on line segment\n    vec2 closestDelta = closest - fragCoord;\n    closestDelta *= resolution.xy / resolution.y;\n    return dot(closestDelta, closestDelta);\n}\n\nfloat distanceFromWalls(vec2 point, vec3 resolution, float time)\n{\n    float minDist = 1e30;\n    minDist = min(minDist, (point.x + 1.0 - MOVING_WALL_MAG - MOVING_WALL_MAG*sin(time / MOVING_WALL_TIME)) * resolution.x / resolution.y);\n    minDist = min(minDist, (1.0 - point.x) * resolution.x / resolution.y);\n    minDist = min(minDist, point.y + 1.0);\n    minDist = min(minDist, 1.0 - point.y);\n    return minDist;\n}\n\nvec2 getNormalFromWalls( vec2 point, vec3 resolution, float time )\n{\n\tvec2 tinyChangeX = vec2( 0.001, 0.0 );\n    vec2 tinyChangeY = vec2( 0.0 , 0.001 );\n    \n   \tfloat upTinyChangeInX   = distanceFromWalls( point + tinyChangeX, resolution, time ); \n    float downTinyChangeInX = distanceFromWalls( point - tinyChangeX, resolution, time ); \n    \n    float tinyChangeInX = upTinyChangeInX - downTinyChangeInX;\n    \n    \n    float upTinyChangeInY   = distanceFromWalls( point + tinyChangeY, resolution, time ); \n    float downTinyChangeInY = distanceFromWalls( point - tinyChangeY, resolution, time ); \n    \n    float tinyChangeInY = upTinyChangeInY - downTinyChangeInY;\n    \n    \n\tvec2 normal = vec2(\n         \t\t\ttinyChangeInX,\n        \t\t\ttinyChangeInY\n    \t \t\t  );\n    \n\treturn normalize(normal);\n}\n\n//returns the ids of the four closest particles from the input\nivec4 fxGetClosestInternal(sampler2D sampler, ivec2 xy)\n{\n    return ivec4(texelFetch(sampler, xy, 0));\n}\n\n#define fxGetClosest(X) fxGetClosestInternal(iChannel1, X)\n\n#define UL_NEIGHBORS 0\n#define UR_NEIGHBORS 1\n#define LL_NEIGHBORS 2\n#define LR_NEIGHBORS 3\n#define POS_VEL 4\n#define FLUID 5\n#define NUM_PARTICLE_DATA_TYPES 6\n\n//returns the location of the particle within the particle buffer corresponding with the input id \nivec2 fxLocFromIDInternal(int width, int id, int dataType)\n{\n    int index = id * NUM_PARTICLE_DATA_TYPES + dataType;\n    return ivec2( index % width, index / width);\n}\n\n#define fxLocFromID(X, Y) fxLocFromIDInternal(int(iResolution.x), X, Y)\n\nstruct fxParticle\n{\n    vec2 pos;\n    vec2 vel;\n    \n    ivec4 neighbors[4];\n    vec2 uv;\n    float density;\n    float pressure;\n};\n\n//get the particle corresponding to the input id\nfxParticle fxGetParticleInternal(sampler2D sampler, int resolutionWidth, int id)\n{\n    vec4 particleData0 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UL_NEIGHBORS), 0);\n    vec4 particleData1 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, UR_NEIGHBORS), 0);\n    vec4 particleData2 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LL_NEIGHBORS), 0);\n    vec4 particleData3 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, LR_NEIGHBORS), 0);\n    vec4 particleData4 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n    vec4 particleData5 = texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, FLUID), 0);\n\n    fxParticle particle;\n    particle.neighbors[0] = ivec4(particleData0);\n    particle.neighbors[1] = ivec4(particleData1);\n    particle.neighbors[2] = ivec4(particleData2);\n    particle.neighbors[3] = ivec4(particleData3);\n    particle.pos = particleData4.xy;\n    particle.vel = particleData4.zw;\n    particle.uv = particleData5.xy;\n    particle.density = particleData5.z;\n    particle.pressure = particleData5.w;\n    \n    return particle;\n}\n\n\nvec4 fxSaveParticle(fxParticle p, int dataType)\n{    \n    switch(dataType)\n    {\n    case UL_NEIGHBORS:\n        return vec4(p.neighbors[0]);\n    case UR_NEIGHBORS:\n        return vec4(p.neighbors[1]);\n    case LL_NEIGHBORS:\n        return vec4(p.neighbors[2]);\n    case LR_NEIGHBORS:\n        return vec4(p.neighbors[3]);\n    case POS_VEL:  \n        return vec4(p.pos, p.vel);\n    case FLUID:\n        return vec4(p.uv, p.density, p.pressure);\n    }\n}\n\n#define fxGetParticle(X) fxGetParticleInternal(iChannel0, int(iResolution.x), X)\n\nvec4 fxGetParticleDataInternal(sampler2D sampler, int resolutionWidth, int id, int dataType)\n{\n    return texelFetch(sampler, fxLocFromIDInternal(resolutionWidth, id, POS_VEL), 0);\n}\n\n#define fxGetParticleData(X, Y) fxGetParticleDataInternal(iChannel0, int(iResolution.x), X, Y)\n\nconst float PI = 3.141592653589793;\n\nfloat SPHKernel (float x)\n{\n    if (x < 1.0)\n        return 4.0 * cos(x*PI) + cos((x + x) * PI) + 3.0;\n    else\n        return 0.0;\n}\n\nfloat SPHgradKernel (float x)\n{\n    if (x < 4.0)\n    {\n        float xx = x*x;\n        float xxx = xx*x;\n        float xxxx = xxx*x;\n        return 0.000 + 3.333 * x + -3.167 * xx + 0.917 * xxx + -0.083 * xxxx;\n    }\n    else\n        return 0.0;\n}\n\nfloat length2(vec2 v)\n{\n    return dot(v, v);\n}\n\n#define keyClick(ascii)   ( texelFetch(iChannel3,ivec2(ascii,1),0).x > 0.)\n#define keyDown(ascii)    ( texelFetch(iChannel3,ivec2(ascii,0),0).x > 0.)\n\nvoid insertion_sort(inout ivec4 i, inout vec4 d, int i_, float d_){\t\n    if(any(equal(ivec4(i_),i))) return;\n    if     (d_ < d[0])             \n        i = ivec4(i_,i.xyz),    d = vec4(d_,d.xyz);\n    else if(d_ < d[1])             \n        i = ivec4(i.x,i_,i.yz), d = vec4(d.x,d_,d.yz);\n    else if(d_ < d[2])            \n        i = ivec4(i.xy,i_,i.z), d = vec4(d.xy,d_,d.z);\n    else if(d_ < d[3])           \n        i = ivec4(i.xyz,i_),    d = vec4(d.xyz,d_);\n}\n", "buffer_a_code": "// Particle Buffer\n// in this buffer every pixel represents a particle\n// the particles positions is stored in .xy\n//           its velocity  is stored in .zw\n// Only the first PARTICLES amount of pixels are actually used.\n\nconst vec2 GRAVITY = vec2(0.0000, -0.00002);\nconst float DAMPING = 1.0;\nconst float PARTICLE_REPEL = 0.0001;\nconst float WALL_REPEL = 0.0;\nconst float IDEAL_DENSITY = 106.0;\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int id, int searchId, int dataType, in vec2 myPos);\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n    ivec2 iFragCoord = ivec2(fragCoord);\n    \n    //we only simulate PARTICLES amount of particles\n    int maxParticles = min(int(iResolution.x * iResolution.y) / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n    int index = iFragCoord.x + iFragCoord.y*int(iResolution.x);\n    int id = index / NUM_PARTICLE_DATA_TYPES;\n    int dataType = index - id * NUM_PARTICLE_DATA_TYPES;\n    if(id>=maxParticles) return;\n    \n    fxParticle data = fxGetParticle(id);\n    \n    if (dataType == POS_VEL || dataType == FLUID)\n    {\n        if (iFrame == 0 || keyDown(32))\n        {\n            //pick a \"random\" starting position\n            float particlesPerRow = sqrt(float(maxParticles));\n            float i = float(id % int(particlesPerRow));\n            float j = float(id / int(particlesPerRow)) + float(id & 1) * 0.5;\n            \n            data.pos = vec2(i / particlesPerRow, j / particlesPerRow) * 1.8 - 0.9;\n            data.vel = vec2(0);\n            data.uv = vec2(data.pos.x * 0.5 + 0.5, data.pos.y * 0.5 + 0.5);\n        }\n        else\n        {\n            vec2 force = vec2(0);\n            \n            // Debug forces\n            vec2 disturbPos = vec2(0.0, 0.0);\n            vec2 disturbDelta = vec2(0.0, 0.0);\n            if (iMouse.z > 0.0 && iMouse.w < 0.0)\n            {\n                disturbPos = ((2.0 * iMouse.xy / iResolution.xy) - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n                disturbDelta = (iMouse.xy - vec2(iMouse.z, -iMouse.w));\n                disturbDelta = clamp(disturbDelta, -100.0, 100.0);\n            }\n            else\n            {\n                // auto disturb\n                disturbPos = vec2(sin(iTime * 0.5), sin(iTime * 1.0))* vec2(1.2, 0.2) + vec2(0.0, 0.2);\n                disturbDelta = 80.0 * vec2(cos(iTime * 0.5), cos(iTime * 1.0));\n            }\n            \n            const float MOUSE_FIELD_SIZE = 0.3;\n            float MOUSE_FIELD_STRENGTH = 0.1 / sqrt(iFrameRate);\n            float dist = distance(data.pos * iResolution.xy / iResolution.y, disturbPos);\n            if (dist < MOUSE_FIELD_SIZE)\n            {\n                force += (MOUSE_FIELD_SIZE - dist) * MOUSE_FIELD_STRENGTH * disturbDelta / iResolution.xy;\n            }\n\n            struct solverParticle\n            {\n                vec2 pos;\n                vec2 vel;\n                float density;\n                int id;\n            };\n            \n            solverParticle particles[17];\n            int numSolverParticles = 0;\n            float totalDensity = SPHKernel(0.0);\n            vec2 densityGrad = vec2(0);\n            \n            // Compute neighborhood density and density gradient, and init solver particles\n            for(int i = 0; i < 4; i++){\n                ivec4 neighbors = data.neighbors[i];\n                for (int j = 0; j < 4; ++j)\n                {\n                    int cid = neighbors[j];\n                    if(cid==id || cid==-1 || cid == 0 || cid >= maxParticles) continue;\n                    \n                    vec4 otherPosVel = fxGetParticleData(cid, POS_VEL);\n                    vec4 otherFluid = fxGetParticleData(cid, FLUID);\n                    \n                    vec2 deltaPos = otherPosVel.xy - data.pos;\n                    float dist = length(deltaPos) + 0.0001;\n                    float nbDensity = SPHKernel(dist);\n                    totalDensity += nbDensity;\n                    densityGrad += nbDensity * deltaPos / dist;\n\n                    particles[numSolverParticles].pos = otherPosVel.xy;\n                    particles[numSolverParticles].vel = otherPosVel.zw;\n                    particles[numSolverParticles].density = otherFluid.z;\n                    particles[numSolverParticles].id = cid;\n                    ++numSolverParticles;\n                }\n            }       \n\n            particles[numSolverParticles].pos = data.pos;\n            particles[numSolverParticles].vel = data.vel;\n            particles[numSolverParticles].id = id;\n            ++numSolverParticles;\n\n            // Solve local neighborhood\n            float pressure = 0.0;\n            const int NUM_ITERATIONS = 20;\n            for(int iterations = 0; iterations < NUM_ITERATIONS; ++iterations)\n            {\n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    float impulse;\n                    for (int j = 0; j < numSolverParticles; ++j)\n                    {\n                        if (i != j)\n                        {\n                            vec2 deltaPos = particles[i].pos - particles[j].pos;\n                            float dist = length(deltaPos) + 0.001;\n                            vec2 dir = deltaPos / dist; \n\n                            impulse = (PARTICLE_REPEL * SPHgradKernel(dist / PARTICLE_REPEL_SIZE));\n                                                        \n                            particles[i].vel += impulse * dir;\n                            particles[j].vel -= impulse * dir;\n                        }\n                    }\n                    \n                    // Last particle is the one we're working on\n                    pressure += impulse;\n                }\n                \n                for (int i = 0; i < numSolverParticles; ++i)\n                {\n                    // Integrate vel\n                    particles[i].vel -= particles[i].vel * 0.000004 - GRAVITY / float(NUM_ITERATIONS);\n                    \n                    // Integrate pos\n                    particles[i].pos += particles[i].vel / float(NUM_ITERATIONS);\n                }\n            }\n            \n            // Combine solver results into force\n            force += particles[numSolverParticles - 1].vel - data.vel;\n            \n            // Record misc solver results\n            data.pressure = pressure;\n            data.density = totalDensity;\n                   \n            // Apply force\n            data.vel = data.vel + force;\n            \n            // Boundary\n            float distToScene = distanceFromWalls(data.pos, iResolution, iTime);\n            float distToSceneOld = distanceFromWalls(data.pos, iResolution, iTime - iTimeDelta);\n            vec2 distNormal = getNormalFromWalls(data.pos, iResolution, iTime);\n\n            if (distToScene < PARTICLE_REPEL_SIZE)\n            {\n                data.pos -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                data.vel -= 1.0 * distNormal * (distToScene - PARTICLE_REPEL_SIZE);\n                float velToClip = dot(data.vel, distNormal);\n                if (velToClip > 0.0)\n                {\n                    data.vel -= distNormal * (distToSceneOld - distToScene);                    \n                }\n            }\n            \n            // Damping\n            data.vel -= data.vel * length2(data.vel) * 200.0;\n            data.vel -= data.vel * 0.9 * smoothstep(50.0, 100.0, data.density);\n\n            // Clamping\n            float maxSpeed = 30.0 / (iResolution.x + iResolution.y); // Dictated by voronoi update speed\n            float velLength2 = length2(data.vel);\n            if (velLength2 > maxSpeed * maxSpeed)\n            {\n                data.vel *= inversesqrt(velLength2) * maxSpeed;\n            }\n\n            // Integrate position\n            data.pos = data.pos + data.vel;\n            data.pos = clamp(data.pos, -1.0, 1.0);\n        }\n    }\n    else\n    {\n        // Nearest particle sort inspired by michael0884's Super SPH: https://www.shadertoy.com/view/tdXBRf\n        //sort neighbors and neighbor neighbors\n        vec4 nb0 = fxGetParticleData(id, dataType);\n        ivec4 closest = fxGetClosest(ivec2(world2screen(data.pos)));\n        ivec4 bestIds = ivec4(nb0);\n        vec4 bestDists = vec4(length2(fxGetParticleData(bestIds[0], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[1], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[2], POS_VEL).xy - data.pos),\n            length2(fxGetParticleData(bestIds[3], POS_VEL).xy - data.pos));\n        \n        for (int i = 0; i < 4; ++i)\n        {\n            sort0(bestIds, bestDists, id, int(nb0[i]), dataType, data.pos);  //sort this\n            sort0(bestIds, bestDists, id, int(closest[i]), dataType, data.pos);  //sort this\n        }\n        \n        if(dataType==UL_NEIGHBORS ) data.neighbors[0] = bestIds;\n        else if(dataType==UR_NEIGHBORS ) data.neighbors[1] = bestIds;\n        else if(dataType==LL_NEIGHBORS ) data.neighbors[2] = bestIds;\n        else                             data.neighbors[3] = bestIds;\n    }\n    \n    fragColor = fxSaveParticle(data, dataType);\n}\n\nbool iscoincidence(in ivec4 bestIds, int currentId, int id)\n{\n    return id <= 0 ||\n      \tid == currentId ||\n        any(equal(bestIds,ivec4(id)));\n}\n\nvoid sort0(inout ivec4 bestIds, inout vec4 bestDists, int currentId, int searchId, int dataType, in vec2 myPos)\n{\n    if(iscoincidence(bestIds, currentId, searchId)) return; //particle already sorted\n    \n    vec2 nbX = fxGetParticleData(searchId, POS_VEL).xy; \n\n    vec2 dx = nbX - myPos;\n    int dir = int(2.*(atan(dx.y, dx.x)+PI)/PI); \n\n    if(dir != dataType) return; //not in this sector\n    \n    float t = length2(dx);\n    \n    if (t > PARTICLE_REPEL_SIZE * 20.0) return;\n   \n    insertion_sort(bestIds, bestDists, searchId, t);\n}\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Gijs's Basic : Voronoi Tracking: https://www.shadertoy.com/view/WltSz7\n\n// Voronoi Buffer\n// every pixel stores the 4 closest particles to it\n// every frame this data is shared between neighbours\n\nfloat distance2Particle(int id, vec2 fragCoord){\n    if(id==-1) return 1e20;\n    vec2 delta = fxGetParticleData(id, POS_VEL).xy-fragCoord;\n    return dot(delta, delta);\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord ){\n   \tivec2 iFragCoord = ivec2(fragCoord);\n\n    //in this vector the four new closest particles' ids will be stored\n    ivec4 new = fxGetClosest(ivec2(fragCoord));\n    //in this vector the distance to these particles will be stored \n    vec4 dis = vec4(distance(fxGetParticleData(new[0], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[1], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[2], POS_VEL).xy, screen2world(fragCoord)),\n        distance(fxGetParticleData(new[3], POS_VEL).xy, screen2world(fragCoord)));\n    \n    for(int x=-2; x<=2; x++){\n        for(int y=-2; y<=2; y++){\n            ivec4 old   = fxGetClosest( iFragCoord + ivec2( x, y) );      \n\n            for(int j=0; j<4; j++){\n                int id = old[j];\n                float dis2 = distance2Particle(id, screen2world(fragCoord));\n                insertion_sort( new, dis, id, dis2 );\n            }\n        }\n    }\n    \n    int searchIterations = 1;\n    if (iFrame < 5)\n    {\n        searchIterations = 10;\n    }\n    for(int k = 0; k < searchIterations; k++){\n        //random hash. We should make sure that two pixels in the same frame never make the same hash!\n        float h = hash(\n            iFragCoord.x + \n            iFragCoord.y*int(iResolution.x) + \n            iFrame*int(iResolution.x*iResolution.y) +\n            k\n        );\n        int maxParticles = min(iFragCoord.x * iFragCoord.y / NUM_PARTICLE_DATA_TYPES, MAX_PARTICLES);\n        //pick random id of particle\n        int p = int(h*float(maxParticles));\n        insertion_sort(new, dis, p, distance2Particle(p, screen2world(fragCoord)));\n    }\n    \n    fragColor = vec4(new); \n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddfRB.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[708, 708, 787, 826, 2103], [2105, 2105, 2158, 2158, 2637]], "test": "untested"}
{"id": "sstBRS", "name": "Normal Map Practice", "author": "Xorberax", "description": "Just practicing normal mapping.\n\nReplace iChannel1 with a normal map (Chrome extensions enable this).\niChannel0 = diffuse.", "tags": ["normalmap"], "likes": 1, "viewed": 294, "published": 3, "date": "1656716622", "time_retrieved": "2024-07-30T16:42:08.580550", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 diffuse = texture(iChannel0, uv);\n    vec3 normal = vec3(texture(iChannel1, uv));\n    vec3 lightDirection = vec3(cos(iTime), sin(iTime), 1.0);\n    fragColor = diffuse * dot(normal, lightDirection);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 308]], "test": "untested"}
{"id": "fddBRS", "name": "Apple Hex Icons", "author": "pyBlob", "description": "Mouseable.\nInspired by [url=https://www.shadertoy.com/view/7sdfDN]Apple Watch UI Effect[/url].\nReference 50-55s: [url=https://youtu.be/eHjBH9UBLnI?t=50]How to manage your apps[/url]", "tags": ["circle", "ui", "apple", "watch", "reproduction"], "likes": 16, "viewed": 391, "published": 3, "date": "1656695575", "time_retrieved": "2024-07-30T16:42:09.332540", "image_code": "const int mode_grid    = 0;\nconst int mode_masonry = 1;\nconst int mode_hex     = 2;\nconst int mode = 2;\nconst bool show_screen = false;\nconst bool radius_field = true;\n\nfloat sdRect(vec2 O);\nfloat sdRectWithHole(vec2 O);\nfloat sdBar(vec2 O);\nfloat sdSnake(vec2 O);\nfloat sdScreen(vec2 O);\nvec2 normalScreen(vec2 O);\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    float spacing = iResolution.x / 10.;\n    float spacing_y = spacing;\n    if (mode == mode_hex)\n        // some scaling is possible, as long as circles don't touch the discontinuity of round\n        spacing_y *= sqrt(3.)/2.;\n    \n    vec2 shift;\n    shift.x = sin(iTime) * spacing;\n    shift.y = cos(iTime) * spacing;\n    if (iMouse.z > 0.)\n        shift = -iMouse.xy;\n    \n    float row = round((O.y + shift.y) / spacing_y);\n    if (mode == mode_masonry || mode == mode_hex)\n        shift.x += spacing * row / 2.;\n    \n    float column = round((O.x + shift.x) / spacing);\n    \n    vec2 center;\n    center.x = column * spacing - shift.x;\n    center.y = row * spacing_y - shift.y;\n\n    float full = 0.4 * spacing;\n    if (radius_field)\n        full *= mix(1.05, 0.8, pow(distance(O, iResolution.xy/2.)/(iResolution.x/2.), 2.));\n    \n    // shrink circles until they are fully on the screen\n    float dist = (sdScreen(center) + full) / 2.;\n    vec2 normal = normalScreen(center);\n    float radius = full;\n    if (dist > 0.)\n        center -= dist * normal,\n        radius -= dist;\n    \n    C = vec4(0);\n    if (show_screen)\n    {\n        C = vec4(.1 + .1 * normalScreen(O), 0, 1);\n        C = blend(C, vec3(1), sdScreen(O));\n    }\n    vec2 tex = .5 + clamp((O - center) / radius, -.5, .5);\n    vec3 c = mix(vec3(1), vec3(0), texture(iChannel0, (vec2(row, column) + tex) / 16.).r);\n    C = blend(C, c, radius - distance(O, center));\n    C = sqrt(C);\n}\n\n/*\nConstraints:\n- Exact Sdf\n- Surface Curvature < Icon Curvature\n- Minimum Separation > 2x (3x?) Icon Radius\n- Minimum Thickness > 1x Icon Radius\n\nApart from that, anything should work. What about a snake shaped watch?\n*/\nfloat sdScreen(vec2 O)\n{\n    //return max(sdSnake(O), sdSnake(O - vec2(0, iResolution.y)));\n    //return sdBar(O);\n    return sdRectWithHole(O);\n    return sdRect(O);\n}\n\nvec2 normalScreen(vec2 O)\n{\n    vec2 eps = vec2(1, 0);\n    return normalize(vec2(\n        sdScreen(O + eps.xy) - sdScreen(O - eps.xy),\n        sdScreen(O + eps.yx) - sdScreen(O - eps.yx)\n    ));\n}\n\nfloat sdRect(vec2 O)\n{\n    float r = iResolution.x / 10.;\n    return sdBox(O - iResolution.xy/2., vec2(iResolution.xy / 2.) - r - 4.) - r;\n}\n\nfloat sdRectWithHole(vec2 O)\n{\n    return max(sdRect(O), .08*iResolution.x - distance(O, iResolution.xy/2.));\n}\n\nfloat sdBar(vec2 O)\n{\n    float r = iResolution.x / 10.;\n    float a = 1.5 * cos(iTime);\n    return .4 * r - abs(dot(vec2(sin(a), cos(a)), (O - iResolution.xy / 2.)));\n}\n\nfloat sdSnake(vec2 O)\n{\n    float thickness = iResolution.x / 20.;\n    float spacing = iResolution.x / 2.;\n    float r = iResolution.x / 4.;\n\n    float h = sqrt(r*r - spacing*spacing/16.);\n    float sa = asin(spacing/4. / r);\n    float id0 = round(O.x / spacing);\n    float id1 = round(O.x / spacing + .5) - .5;\n    float sd;\n    sd = sdfArc(sa, r, O.yx-vec2(-h,id0*spacing));\n    sd = min(sd, sdfArc(sa, r, -O.yx+vec2(h,id1*spacing)));\n    return thickness - abs(sd);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sdBox(in vec2 p, in vec2 b)\n{\n    // https://iquilezles.org/articles/distfunctions2d/\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec4 blend(vec4 C, vec3 c, float r)\n{\n    return mix(C, vec4(c, 1), clamp(r, 0., 1.));\n}\n\nfloat sdfArc(float ea, float r, vec2 uv)\n{\n    // ArmandB: simple sdf arc https://www.shadertoy.com/view/sdSfWG\n    float sa = -ea;\n    const float tau = 2.*radians(180.);\n    //find coterminal angles\n    sa = mod(mod(sa,tau) + tau, tau);\n    ea = mod(mod(ea,tau) + tau, tau);\n    float a = mod(mod(atan(uv.y,uv.x),tau) + tau, tau);\n    //https://stackoverflow.com/questions/12234574/calculating-if-an-angle-is-between-two-angles\n    if ((sa <= a && a <= ea && sa < ea) || ((sa <= a || a <= ea) && sa >= ea)){\n        return abs(r - length(uv));\n    }\n    //get closest endpoint\n    vec2 p1 = vec2(cos(sa), sin(sa))*r;\n    vec2 p2 = vec2(cos(ea), sin(ea))*r;\n    return min(distance(p1, uv), distance(p2, uv));\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddBRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[317, 317, 356, 356, 1807], [1809, 2031, 2055, 2145, 2199], [2201, 2201, 2228, 2228, 2397], [2399, 2399, 2421, 2421, 2539], [2541, 2541, 2571, 2571, 2652], [2654, 2654, 2675, 2675, 2823], [2825, 2825, 2848, 2848, 3295]], "test": "untested"}
{"id": "sdKyWG", "name": "kaleidoscope variations 2", "author": "hnh", "description": "Fork of [url]https://www.shadertoy.com/view/7dyyWm[\\url].\nThe three possible variations of the 3-mirror kaleidoscope - see code comments. \nBrightness is attenuated by the number of reflections. \nUse mouse to manually scroll the texture.", "tags": ["reflection", "interactive", "folding", "kaleidoscope", "tiling", "symmetry"], "likes": 17, "viewed": 467, "published": 3, "date": "1656691738", "time_retrieved": "2024-07-30T16:42:10.087521", "image_code": "\n// The three possible variations of the 3-mirror kaleidoscope [1,2].\n// The image is composed by reflections of a base triangle, tiling the plane.\n// Here, I adopted the folding scheme [3,4] for the Euclidean plane whereas\n// in general it also works for the spherical and hyperbolic case. \n// A similar example with good comments is also found in [5]. \n// You may also try using the webcam in iChannel0\n// (don't forget setting Filter->mipmap and Wrap->repeat).\n// Note: lines marked by '//o' are comment-switchable (optional).\n// '//p' indicates parameters for manual tuning.\n// Shadertoy plugin: use Alt + R/L arrows to switch modes\n//\n// See also https://www.shadertoy.com/view/ssyyRG for a visualization of the folding scheme.\n//\n// [1] https://en.wikipedia.org/wiki/Kaleidoscope#Different_versions_suggested_by_Brewster\n// [2] https://en.wikipedia.org/wiki/Triangle_group\n// [3] mla, Wythoffian Tiling Generator, https://shadertoy.com/view/wlGSWc\n// [4] knighty, Tilings, https://www.shadertoy.com/view/4sf3zX\n// [5] TotallyReal, Euclidean triangle groups, https://www.shadertoy.com/view/7lV3Wy\n// [6] Artleet, The most compact hueshift, https://www.shadertoy.com/view/3tjGWm\n// [7] https://de.wikipedia.org/wiki/Datei:Kaleidoscope-abc.jpg\n\n#define C .03  // emphasize parent tile\n#define H 1.  // hold between transitions\n\n#define PI 3.14159265\n#define R iResolution\n\n// The angles are defined by divisors of PI in each row (1st row: classical kaleidoscope, [1]).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(\n    3,3,3,\n    2,4,4,\n    2,3,6);\n\nvec3 hs(vec3 c, float s) {  // hue shift [6]\n    vec3 m = vec3(cos(s), s=sin(s)*.5774, -s);\n    return c*mat3(m+=(1.-m.x)/3., m.zxy, m.yzx);\n}\n\n// Iterative folding/reflection adopted from [3,4] and streamlined for the Euclidean case.\n// The fold count (nf) can be useful, e.g. to attenuate reflections as in a real kaleidoscope [7].\nvec4 fold(vec2 p, float sc, vec3 ang, out int nf) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(1, 0, C,\n                 -c.x, s.x, 0,\n                 -c.z, -(c.y+c.x*c.z)/s.x, 1);  // normals\n    sc *= s.z;  // set longest edge to unit length\n    vec3 u, q = vec3(p,sc);\n    nf = 0;  // fold counter\n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n        }\n        if(i >= nf) break;  // base triangle is reached\n    }\n    return vec4(q.xy, u.yz);  // q.xy: cartesian coords, u.xyz: trilinear coords, note that u.x = q.x\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    const float sc = 5.;  //p scale\n    float t = iTime*.2;  //p global speed\n        \n    int m = 2, mm = m;  //p reflection mode (0,1,2)\n    m = int(t)%3, mm = int(t+1.)%3;  //o cycle modes\n    //m = int(U.x*3./R.x); mm = m;  //o simultaneous view    \n        \n    U = sc*(U*2. - R.xy)/R.y;\n        \n    int nf;    \n    float f = smoothstep(0.,1.,mod(t,1.)*(H+1.)-H);  // blending\n    O = fold(U, 1., mix(PI/D[m],PI/D[mm],f), nf);\n    U = O.xy;\n    vec3 u = O.xzw;\n        \n    if(iMouse.z>0.) U -= (iMouse.xy*2.-R.xy)/R.y;\n    else U -= t*.5; //o auto-scroll\n    //U += vec2(nf)*.01;  //o reflection shift\n    O = texture(iChannel0,U);\n    O.rgb = hs((O.bgr-.25)*2., PI*(1.-.5*mix(float(m),float(mm),f)));  //o color modes\n    //O = vec4(1);  //o monochrome background\n    \n    O *= exp(-float(nf)/sc*.4)*1.5;  //o attenuate reflections\n    //O *= .6 + .4*float(nf%2);  //o 'checkerboard'\n    //O *= .9 + .15*(dFdx(U.x)-.3*dFdy(U.x))/sc*R.y;  //o relief (cheap)\n    O *= smoothstep(-1.,1.,(min(u.x,min(u.y,u.z))-.01)*R.y/(sc*2.));  //o edges\n    \n    O.a= 1.;  // who knows...\n}\n\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdKyWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1586, 1586, 1612, 1630, 1728], [1730, 1920, 1971, 1971, 2572], [2575, 2575, 2611, 2611, 3693]], "test": "untested"}
{"id": "ssyyRG", "name": "kaleidoscope reflections", "author": "hnh", "description": "Fork of [url]https://www.shadertoy.com/view/7dyyWm[\\url] demonstrating the symmetry axes and path of iterated reflections of a point. Go to base version for further info.\nUse your mouse to move the starting point.", "tags": ["reflection", "interactive", "folding", "kaleidoscope", "tiling", "symmetry"], "likes": 3, "viewed": 263, "published": 3, "date": "1656691723", "time_retrieved": "2024-07-30T16:42:10.910322", "image_code": "\n// Fork of 'kaleidoscope variations', https://www.shadertoy.com/view/7dyyWm \n// to visualize the fold() algorithm. A point in the plane is repeatedly reflected \n// about the symmetry axes until reaching the base triangle at the center.\n// Drawing info is directly obtained from fold() which certainly is not the most efficient way.\n// Pause shader to keep zoom fixed. More info at the base version mentioned above.\n// Note: lines marked by '//o' are comment-switchable (optional).\n\n// visual mode - 1: gray level = num. reflections, 2: RGB = trilinear coordinates\n#define M 1\n\n#define PI 3.14159265\n#define R iResolution\n#define SM(x) smoothstep(1.,0.,(x)*R.y/(sc*2.))  // antialiasing\n\n// The angles are defined by divisors of PI in each row (reflection mode).\n// In the Euclidean plane their inverses must sum to one.\nconst mat3 D = mat3(\n    3,3,3,\n    2,4,4,\n    2,3,6);\n\nfloat seg(vec2 p, vec2 a, vec2 b){  // line segment SDF - by iq\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa - ba*h);\n}\n\n// slightly modified version to draw reflection info of a point given in V\nvec4 fold(vec2 p, float sc, vec3 ang, vec2 V) {\n    vec3 c = cos(ang), s = sin(ang);\n    mat3 N = mat3(  // normals\n        1, 0, 0,\n        -c.x, s.x, 0,\n        -c.z, -(c.y+c.x*c.z)/s.x, 1);\n\n    sc *= s.z;  // set longest edge to unit length\n    vec3 q = vec3(p,sc), qq;\n    vec4 u, v = vec4(9e9);\n    int nf = 0;  // fold counter\n    \n    for(int i=0; i<9999; i++) {\n        for(int j=0; j<3; j++) {\n            qq = q;\n            u[j] = dot(q, N[j]);\n            if(u[j] < 0.) {q -= 2.*u[j]*N[j]*vec3(1,1,0); nf++;}\n\t\t\t\n\t\t\tif(V.x<9e9) {  // return drawing SDFs instead of trilinear coordinates\n                if(i==0) v.x = min(v.x, \n                    abs  //o symmetry axes (otherwise: base triangle)\n                    (dot(vec3(V, sc), N[j])));\n                v.y = min(v.y, length(qq.xy - V));  // reflected point\n                float s = seg(V,q.xy,qq.xy);  // reflection path\n                if(s < v.z+.001){ v.z = s; v.w = float(nf); }\n            }\n        }\n        if(i>=nf) break;  // base triangle is reached\n    }\n    v.w /= float(nf);\n    return V.x<9e9 ? v : u;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime*.1;\n    \n    int m = 0;  //p reflection mode (0,1,2)\n    m = int(t)%3;  //o cycle modes\n            \n    float sc = 10., a = 2., b = R.y*.075;  //p scale, bounce interval\n    sc = sqrt(b*a)*pow(b/a, .5*cos(2.*PI*t));  //o bouncing zoom\n    \n\tU = sc*(U*2.-R.xy)/R.y;\n\n    vec2 p = iMouse.z<=0. ? vec2(-.7,-.8)*sc : sc*(iMouse.xy*2.-R.xy)/R.y;\n        \n    vec4 u = fold(U, 1., PI/D[m], vec2(9e9));\n    vec4 v = fold(p, 1., PI/D[m], U);\n\n#if M==1\n    O = vec4(0);  // monochrome background\n    mat4 c = mat4( // line colors\n        0,0,.5,1,\n        0,.6,.3,1,\n        vec4(1.-v.w*.9),  // darken with number of reflections\n        1,1,0,1);\n#else\n    O = u;\n    mat4 c; c += 1.-c;  // white lines, except...\n    c[0] -= 1.;\n#endif\n    \n    O = mix(O,c[0],SM(min(u.x,min(u.y,u.z))-.01));  //o grid\n    O = mix(O,c[1],SM(abs(v.x)-.01));  //o symmetry axes/base triangle\n    O = mix(O,c[2],SM(v.z-.015));  //o reflection path\n    O = mix(O,c[3],SM(v.y-.05));  //o reflected point\n    \n    O.a= 1.;  // who knows...\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssyyRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[877, 877, 911, 940, 1051], [1053, 1128, 1175, 1175, 2219], [2222, 2222, 2258, 2258, 3291]], "test": "untested"}
{"id": "7dcfRB", "name": "Backbuffer example", "author": "ninofiliu", "description": "I didn't find anywhere a satisfying previous frame (aka backbuffer) hello world so I wrote that!", "tags": ["example", "helloworld", "demo", "frame", "backbuffer", "previousframe"], "likes": 15, "viewed": 501, "published": 3, "date": "1656686913", "time_retrieved": "2024-07-30T16:42:11.665302", "image_code": "// This just paints whatever is in BufferA\nvoid mainImage(out vec4 color, in vec2 coord) {\n    vec2 uv = coord / iResolution.xy;\n    color = texture(iChannel0, uv);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This shader can read and write to iChannel0 that is set to BufferA\n// That allows to draw something, and to read it on the next frame\nvoid mainImage(out vec4 color, in vec2 coord) {\n\n    // On the previous frame, read 4 pixels around the pixels to be painted,\n    // then average and dim them, creating a disappearing blur effect\n    vec2 uv = coord / iResolution.xy;\n    float diff = 0.005;\n    float dim = 0.999;\n    color = dim * (\n        texture(iChannel0, vec2(uv.x-diff, uv.y-diff))+\n        texture(iChannel0, vec2(uv.x-diff, uv.y+diff))+\n        texture(iChannel0, vec2(uv.x+diff, uv.y-diff))+\n        texture(iChannel0, vec2(uv.x+diff, uv.y+diff))\n    )/4.;\n    \n    // Draws a circle around a rotating point\n    if (distance(uv, 0.5 + 0.2*vec2(cos(iTime), sin(iTime))) < 0.01) {\n        color.rgb += 1.;\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcfRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 43, 90, 90, 170]], "test": "untested"}
{"id": "sd3fRB", "name": "GLSLÂ Windows bug #64", "author": "FabriceNeyret2", "description": "Doesn't compile on Windows:\nerror X3500 : array reference cannot be used as an l-value; not natively addressable.\nUnknown error: retrying with skip validation.\n", "tags": ["glsl", "bug"], "likes": 1, "viewed": 228, "published": 3, "date": "1656682639", "time_retrieved": "2024-07-30T16:42:12.418289", "image_code": "// found here: https://www.shadertoy.com/view/Ns3BD7\n\nstruct foo\n{\n    vec4 bar[4];\n};\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    foo baz;   \n    baz.bar[int(fragCoord.x) % 4] = fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3fRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 145, 145, 210]], "test": "untested"}
{"id": "fd3BRB", "name": "Metal branch mosaic 3", "author": "jarble", "description": "Another ornate mosaic pattern.", "tags": ["fractal", "mosaic"], "likes": 3, "viewed": 212, "published": 3, "date": "1656652977", "time_retrieved": "2024-07-30T16:42:13.211169", "image_code": "vec2 triangle_wave(vec2 a){\n    return abs(fract((a+vec2(1.,0.5))*1.5)-.5);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    vec3 col = vec3(0.);\n    float t1 = 8.;\n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    float time1 = iTime/64./2.;\n    uv += vec2(time1/2.0,time1/3.0)/t1/4.0+(vec2(cos(time1),sin(time1)))*8./t1;\n    float scale = 1.5;\n    vec2 t2 = vec2(0.);\n    vec2 t3 = vec2(0.);\n    for(int k = 0; k < 9; k++){\n        float p1 = sign(uv.x);\n        //float random_num = hash12(floor(uv));\n        uv += t2;\n        uv /= scale;\n        //uv.x += sign(uv.x)/2.;\n        //uv.y += sign(uv.y)/2.;\n        //scale -= col.x/4.*random_num;\n        t2 = -p1*triangle_wave(uv-.5);\n        t3 = p1*triangle_wave(uv.yx);\n        \n        uv = t2-t3;\n        col.x = max(uv.y-uv.x*p1-col.x*(2.+uv.x),col.x)/sqrt(2.);\n        col = abs(col.yzx-vec3(1.-col.x));\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3BRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 77], [79, 189, 211, 211, 328], [330, 330, 387, 387, 1199]], "test": "untested"}
{"id": "NdcBzS", "name": "snub hexagonal tiling", "author": "remaindeer", "description": "- was trying to figure out \"| 6 3 2\" -> https://en.wikipedia.org/wiki/Wythoff_symbol\n- my geogebra for snub point -> https://www.geogebra.org/calculator/zdb5wjp9\n- small glitch (fixed by mla)\n- fizzer's demo helped -> https://www.shadertoy.com/view/3tyXWw", "tags": ["sdf", "tiling", "hexagonal", "schwarz", "wythoff", "snub"], "likes": 6, "viewed": 286, "published": 3, "date": "1656641833", "time_retrieved": "2024-07-30T16:42:13.965153", "image_code": "vec2 snub632() {\n    // fermat point\n    vec2 pf = intersection(vec2(-0.75, cos30 / 2.0), v3, vec2(1, 0), v2);\n    // reflect over side (y-axis)\n    vec2 q1 = vec2(-1.0 * pf.x, pf.y);\n    // vec2 q2 = vec2(pf.x, pf.y + 2.0 * (cos30 - pf.y));\n    // project to hypotenuse then double to obtain reflection\n    vec2 q3 = dot(pf, v3) / dot(v3, v3) * v3;\n    q3 = pf + 2.0 * (q3 - pf);\n    // snub point is at half the hypotenuse of the new right triangle (Thales's theorem)\n    return q1 + ((q3 - q1) / 2.0);\n}\n\nfloat sdSnubSchwartz632(vec2 p, float t)\n{\n    // take advantage of symmetry\n    float a = atan(p.y, p.x);\n    float M = floor(mod(degrees(a) - 30.0, 360.0) / 60.0) * 60.0;\n    p = rotmat2(radians(M)) * p;\n    // centralpoint\n    float d = sdCircle(p, t);\n    // snub point\n    vec2 g = snub632();\n    // rotate\n    vec2 G = rotmat2(radians(180.0)) * (g - v2) + v2;\n    d = opUnion(d, sdSegment(p, g, G) - t);\n    // fix by https://www.shadertoy.com/user/mla\n    d = opUnion(d, sdSegment(rotmat2(radians(-60.0)) * p, g, G) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(-60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+60.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+120.0)) * (G - g) + g) - t);\n    d = opUnion(d, sdSegment(p, g, rotmat2(radians(+180.0)) * (G - g) + g) - t);\n    return d;\n}\n\nfloat sdSnubSchwarz632Plane(vec2 p, float t) {\n    float r = cos30;\n    float R = r / cos30;\n    vec2 v = vec2(3.0 * R, 2.0 * r);\n    vec2 p1 = opRep(p, v);\n    vec2 p2 = opRep(p + v / 2.0, v);\n    return opUnion(\n        sdSnubSchwartz632(p1, t),\n        sdSnubSchwartz632(p2, t)\n    );\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec2 m = (2.0 * iMouse.xy - iResolution.xy) / iResolution.y;\n    p *= 2.0;\n    m *= 2.0;\n    p += iTime / 2.0;\n    m += iTime / 2.0;\n\n    float t = 0.075;\n\n    // distance\n    float d = sdSnubSchwarz632Plane(p, t);\n    \n    vec3 col = vec3(0.5);\n    col = (d > 0.0) ? col : 0.5 + 0.5 * cos(iTime + p.xyx + vec3(0, 2, 4));\n    col *= t - exp(-1.0 * abs(d));\n    col *= t + cos(150.0 * d);\n    col = mix(col, vec3(0.5), 1.0 - smoothstep(0.0, t, abs(d)));\n    \n    if (iMouse.z > 0.001)\n    {\n        d = sdSnubSchwarz632Plane(m, t);\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, abs(length(p - m) -abs(d)) - 0.005));\n        col = mix(col, vec3(1.0, 1.0, 0.0), 1.0 - smoothstep(0.0, 0.005, length(p - m) - 0.015));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "mat2 rotmat2(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat opUnion( float d1, float d2 )\n{ \n    return min(d1,d2); \n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nvec2 opRep( in vec2 p, in vec2 c )\n{\n    return mod(p + 0.5 * c, c) - 0.5 * c;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nconst float cos30 = cos(radians(30.0));\n\nvec2 v1 = vec2(0, 0);\nvec2 v2 = vec2(0, cos30);\nvec2 v3 = vec2(0.5, cos30);\n\n// http://paulbourke.net/geometry/pointlineplane/\nvec2 intersection(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    float d = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);\n    float ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / d;\n    // float ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / d;\n    return p1 + ua * (p2 - p1);\n}\n\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcBzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 16, 36, 506], [508, 508, 550, 584, 1374], [1376, 1376, 1422, 1422, 1666], [1668, 1668, 1723, 1723, 2593]], "test": "untested"}
