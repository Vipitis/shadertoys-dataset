{"id": "7styWS", "name": "pastel columns", "author": "jorge2017a2", "description": "pastel columns", "tags": ["pastelcolumns"], "likes": 12, "viewed": 282, "published": 3, "date": "1654008239", "time_retrieved": "2024-07-30T16:46:08.171462", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 200.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec2 opRep2D( in vec2 p, in vec2 c )\n\t{ vec2 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3 opRep3D( in vec3 p, in vec3 c )\n\t{ vec3 q = mod(p+0.5*c,c)-0.5*c; return  q ;}\nvec3  opRep(vec3 p, vec3 r)\n   { return mod(p,r)-0.5*r; }\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 columnaBase(vec3 p)\n{\n    vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float d1= sdCylinderXZ(p-vec3(0.0,6.0,0.0), vec2(2.0,10.0) );\n    float d2= sdCylinderXZ(p-vec3(0.0,-3.5,0.0), vec2(4.0,0.5) );\n    float d3= sdCylinderXZ(p-vec3(0.0,-2.5,0.0), vec2(3.0,0.5) );\n    float d4= sdCylinderXZ(p-vec3(0.0,-1.5,0.0), vec2(2.5,0.5) );\n    res =opU2(res, vec2(d1,100.0));\n    res =opU2(res, vec2(d2,1.0));\n    res =opU2(res, vec2(d3,8.0));\n    res =opU2(res, vec2(d4,9.0));\n    return res;\n}\n    \n    \nvec2 pastel(vec3 p)\n{   vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    float d1= sdCylinderXZ(p-vec3(0.0,15.5,0.0), vec2(10.0,0.5) );\n    float d2= sdCylinderXZ(p-vec3(0.0,16.5,0.0), vec2(15.0,0.5) );\n    float d3= sdCylinderXZ(p-vec3(0.0,17.5,0.0), vec2(18.0,0.5) );\n    \n    float d4= sdCylinderXZ(p-vec3(0.0,21.5,0.0), vec2(5.0,11.0) );\n    \n    res =opU2(res, vec2(d1,1.0));\n    res =opU2(res, vec2(d2,8.0));\n    res =opU2(res, vec2(d3,9.0));\n    res =opU2(res, vec2(d4,11.0));\n    return res;\n}\n\nvec2 cuatrocolumnas(vec3 p)\n{\n    vec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n    vec2 p1= pastel(p);\n    vec2 p2= pastel(vec3(p.x,-p.y,p.z)-vec3(0.0,-12.5,0.0));\n    res =opU2(res, p1);\n    res =opU2(res, p2);\n    p=p0;\n    \n    p.x=abs(p.x)-10.0;\n    p.z=abs(p.z)-10.0;\n    vec2 cb1= columnaBase(p);\n    res =opU2(res, cb1);\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y+0.5;  //piso inf\n    p.z= opRep1D(p.z, 50.0 );\n    float d1= sdBox( p-vec3(0.0,-2.0,0.0), vec3(20.0,1.0,20.0) );\n    float d2= sdBox( p-vec3(0.0,-3.0,0.0), vec3(21.0,1.0,25.0) );\n    res =opU2(res, vec2(d1,8.0));\n    res =opU2(res, vec2(d2,1.0));\n    p.y=p.y-5.0;\n    vec2 cc1= cuatrocolumnas(p);\n    res =opU2(res, cc1);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    //diff = pow(diff, 0.75) * 4.0;   //antes\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n     \n\n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    float t0=iTime;\n    t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(50.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(20.0,25.0+5.*sin(t0),-25.0+t);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(20.0));\n   rd= rotate_y(rd, radians(-45.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Shane...\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(.7)\n);\n\nvec3 getColor(int i)\n{  if (i>-1 )  return Arrcolores[i];}\n", "sound_code": "\nstruct Note {\n    // in Hz, see \"common\" tab\n    float frequency;\n    // offset - time in seconds when to start playing note\n    float offset;\n    // duration of a note (1/4, 1/8, ...), see \"common\" tab\n    float duration;\n};\n\n\n\n\n\n//version D \n////Octava #1\n//--fin--\n////Octava #2\n const float A0 =27.5;  //1\n const float A_0 =29.14;  //2\n const float B0 =30.87;  //3\n//--fin--\n////Octava #3\n const float C1 =32.7;  //4\n const float C_1 =34.65;  //5\n const float D1 =36.71;  //6\n const float D_1 =38.89;  //7\n const float E1 =41.2;  //8\n const float F1 =43.65;  //9\n const float F_1 =46.25;  //10\n const float G1 =49.0;  //11\n const float G_1 =51.91;  //12\n const float A1 =55.;  //13\n const float A_1 =58.27;  //14\n const float B1 =61.74;  //15\n//--fin--\n////Octava #4\n const float C2 =65.41;  //16\n const float C_2 =69.3;  //17\n const float D2 =73.42;  //18\n const float D_2 =77.78;  //19\n const float E2 =82.41;  //20\n const float F2 =87.31;  //21\n const float F_2 =92.5;  //22\n const float G2 =98.;  //23\n const float G_2 =103.83;  //24\n const float A2 =110.;  //25\n const float A_2 =116.54;  //26\n const float B2 =123.47;  //27\n//--fin--\n////Octava #5\n const float C3 =130.81;  //28\n const float C_3 =138.59;  //29\n const float D3 =146.83;  //30\n const float D_3 =155.56;  //31\n const float E3 =164.81;  //32\n const float F3 =174.61;  //33\n const float F_3 =185.;  //34\n const float G3 =196.;  //35\n const float G_3 =207.65;  //36\n const float A3 =220.;  //37\n const float A_3 =233.08;  //38\n const float B3 =246.94;  //39\n//--fin--\n////Octava #6\n const float C4 =261.63;  //40\n const float C_4 =277.18;  //41\n const float D4 =293.66;  //42\n const float D_4 =311.13;  //43\n const float E4 =329.63;  //44\n const float F4 =349.23;  //45\n const float F_4 =369.99;  //46\n const float G4 =392.;  //47\n const float G_4 =415.3;  //48\n const float A4 =440.;  //49\n const float A_4 =466.16;  //50\n const float B4 =493.88;  //51\n//--fin--\n////Octava #7\n const float C5 =523.25;  //52\n const float C_5 =554.37;  //53\n const float D5 =587.33;  //54\n const float D_5 =622.25;  //55\n const float E5 =659.26;  //56\n const float F5 =698.46;  //57\n const float F_5 =739.99;  //58\n const float G5 =783.99;  //59\n const float G_5 =830.61;  //60\n const float A5 =880.;  //61\n const float A_5 =932.33;  //62\n const float B5 =987.77;  //63\n//--fin--\n////Octava #8\n const float C6 =1046.5;  //64\n const float C_6 =1108.73;  //65\n const float D6 =1174.66;  //66\n const float D_6 =1244.51;  //67\n const float E6 =1318.51;  //68\n const float F6 =1396.91;  //69\n const float F_6 =1479.98;  //70\n const float G6 =1567.98;  //71\n const float G_6 =1661.22;  //72\n const float A6 =1760.;  //73\n const float A_6 =1864.66;  //74\n const float B6 =1975.53;  //75\n//--fin--\n////Octava #9\n const float C7 =2093.;  //76\n const float C_7 =2217.46;  //77\n const float D7 =2349.32;  //78\n const float D_7 =2489.02;  //79\n const float E7 =2637.02;  //80\n const float F7 =2793.83;  //81\n const float F_7 =2959.96;  //82\n const float G7 =3135.96;  //83\n const float G_7 =3322.44;  //84\n const float A7 =3520.;  //85\n const float A_7 =3729.31;  //86\n const float B7 =3951.07;  //87\n//--fin--\n////Octava #10\n const float C8 =4186.01;  //88\n const float C_8 =4434.92;  //89\n const float D8 =4698.64;  //90\n const float D_8 =4978.03;  //91\n const float E8 =5274.04;  //92\n const float F8 =5587.65;  //93\n const float F_8 =5919.91;  //94\n const float G8 =6271.93;  //95\n const float G_8 =6644.88;  //96\n const float A8 =7040.;  //97\n const float A_8 =7458.62;  //98\n const float B8 =7902.13;  //99\n//--fin--\n\n\n\nconst Note[] notes = Note[] (\nNote(C3,0.00000,0.25),\nNote(A3,0.25000,0.5),\nNote(A3,0.75000,0.25),\nNote(C3,1.00000,0.125),\nNote(D3,1.12500,0.125),\nNote(G3,1.25000,0.5),\nNote(G3,1.75000,0.25),\nNote(A3,2.00000,0.25),\nNote(B3,2.25000,0.25),\nNote(F4,2.50000,0.25),\nNote(F4,2.75000,0.25),\nNote(E4,3.00000,0.125),\nNote(C4,3.12500,0.125),\nNote(D4,3.25000,0.25),\nNote(C_4,3.50000,0.125),\nNote(B4,3.62500,0.125),\nNote(A3,3.75000,0.25),\nNote(C4,4.00000,0.25),\nNote(D4,4.25000,0.0625),\nNote(D4,4.31250,0.0625),\nNote(D4,4.37500,0.0625),\nNote(G4,4.43750,0.0625),\nNote(F4,4.50000,0.0625),\nNote(E4,4.56250,0.0625),\nNote(E4,4.56250,0.0625),\nNote(F4,4.62500,0.0625),\nNote(D4,4.68750,0.0625),\nNote(C4,4.75000,0.5),\nNote(F3,5.25000,0.25),\nNote(G3,5.50000,0.125),\nNote(A3,5.62500,0.125),\nNote(D4,5.75000,0.125),\nNote(C4,5.87500,0.125),\nNote(C4,6.00000,0.25),\nNote(B4,6.25000,0.125),\nNote(A3,6.37500,0.125),\nNote(E3,6.50000,0.125),\nNote(F3,6.50000,0.25),\nNote(F3,6.75000,0.5),\nNote(C4,7.25000,0.25),\nNote(A3,7.50000,0.5),\nNote(A3,8.00000,0.25),\nNote(C4,8.25000,0.125),\nNote(D4,8.37500,0.125)\n\n\n);\n\nfloat Weight( float x )\n{  if( x < 0.0 )x = - x;\n\tif( x < 1.0 )return (1.0 - 2.0*x*x + x*x*x) ;\n\tif( x < 2.0 )return (4.0 - 8.*x + 5.*x*x - x*x*x) ;\nreturn 0.0 ;\n}\n\n\nfloat saw(float t, float note, float octave)\n{   return fract(t*note*exp2(octave-1.))-0.5; }\n\n\nvec2 noteFreq(Note note, float time) \n{\n    float octava=3.0;\n    float n1=saw(time,note.frequency, octava)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    float t=time;\n    n1=Weight(n1)*n1;    \n    return vec2(n1);\n}\n\nvec2 mainSound( in int samp,float time) \n{   vec2 result;\n    float ftime= mod(time*0.5, 9.0);\n    \n    for (int i = 0; i < notes.length(); i++) {\n        Note note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        { result += noteFreq(note, ftime);  }\n    }\n    return result*0.135;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7styWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 494, 494, 578], [579, 579, 618, 618, 713], [714, 714, 753, 753, 848], [849, 849, 888, 888, 983], [985, 985, 1021, 1021, 1066], [1067, 1067, 1106, 1106, 1150], [1151, 1151, 1190, 1190, 1234], [1235, 1235, 1267, 1267, 1292], [1293, 1358, 1392, 1392, 1488], [1489, 1489, 1523, 1523, 1614], [1615, 1615, 1649, 1649, 1740], [1742, 1742, 1768, 1768, 2234], [2245, 2245, 2266, 2266, 2743], [2745, 2745, 2774, 2774, 3087], [3090, 3090, 3115, 3115, 3521], [3523, 3523, 3547, 3547, 3709], [3711, 3711, 3759, 3759, 4038], [4041, 4041, 4085, 4085, 4406], [4408, 4408, 4445, 4445, 4702], [4704, 4704, 4794, 4794, 5800], [5802, 5802, 5851, 5851, 5929], [5933, 5933, 5965, 5965, 6255], [6258, 6258, 6328, 6328, 6508], [6510, 6510, 6537, 6537, 6626], [6628, 6628, 6686, 6686, 6734], [6736, 6736, 6759, 6759, 6871], [6873, 6873, 6904, 6904, 7524], [7526, 7526, 7583, 7583, 8120]], "test": "untested"}
{"id": "7d3yWS", "name": "pseudo-vectorization of video2", "author": "FabriceNeyret2", "description": "Purpose is to display an image \"as if\" vectorized at low resolution.\nvariant of https://shadertoy.com/view/fddyRs\nusing marching triangles https://www.shadertoy.com/view/fdccDB", "tags": ["short", "marchingsquare", "marchingcube", "vectorization"], "likes": 10, "viewed": 316, "published": 3, "date": "1654003300", "time_retrieved": "2024-07-30T16:46:08.921458", "image_code": "// variant of https://shadertoy.com/view/fddyRs\n// using marching triangles https://www.shadertoy.com/view/fdccDB\n\n#define T(U)  textureLod(iChannel0, U*R.y/R , float(lod)-2. ).r // or lod=0 for fun\n#define G(uv) ( ( (floor(U) + uv) *mat2(1,.5,0,.86) ) *Z/1024. )\n#define S(v) smoothstep( -.8,.8,(v)/fwidth(v) )           // antialiasing draw\n\nfloat vector(vec2 U, int lod, float thresh)\n{\n    float Z = exp2(float(lod));                           // scaling\n    vec2  v, R = iResolution.xy;\n    float O = 0.;                                         // --- marching triangle -------\n    U *= mat2(1,-1./1.73, 0,2./1.73) *1024./Z/R.y;        // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y);                         // hexagonal coordinates\n\tg = fract(g);                                         // diamond coords\n    bool side = length(g)>1.;                             // tri: which diamond half\n \n    vec3 V = side ? vec3( T(G(vec2(1))), T(G(vec2(0,1))), T(G(vec2(1,0))) ) // samples at corder\n                  : vec3( T(G(vec2(0))), T(G(vec2(1,0))), T(G(vec2(0,1))) );\n    if (side) g = 1.-g;                                   // barycentric coordinates\n    O = S( (1.-g.x-g.y)*V.x + g.x*V.y + g.y*V.z - thresh );\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{   int lod = 5;\n    O = vec4( vector(U,lod,.3) + vector(U,lod,.5) + vector(U,lod,.7) ) / 3.;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3yWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 344, 389, 389, 1235], [1237, 1237, 1275, 1275, 1369]], "test": "untested"}
{"id": "fdccDB", "name": "marching triangles on texture", "author": "FabriceNeyret2", "description": "mouse.x shows the full res texture.\nPurpose is to display an image \"as if\" vectorized at low resolution.\nTriangle variant of  https://www.shadertoy.com/view/NddyRl", "tags": ["short", "marchingcubes", "marchingsquares", "vectorization"], "likes": 9, "viewed": 355, "published": 3, "date": "1654002020", "time_retrieved": "2024-07-30T16:46:09.679431", "image_code": "int      lod = 6;\nfloat thresh = .4;\n\n// relying on hexagonal tiling tuto https://www.shadertoy.com/view/4dKXR3\n\n//#define s    textureSize(iChannel0,0)\n#define S(v)  smoothstep( -.8,.8,(v)/fwidth(v) )          // antialiasing draw\n#define T(U)  textureLod(iChannel0, U , float(lod)-1. ).r // or lod=0 for fun\n#define G(uv) ( ( (floor(U) + uv) *mat2(1,.5,0,.86) ) *Z/1024. )\n\nvoid mainImage( out vec4 O, vec2 U )\n{ \n    float Z = exp2(float(lod)),                           // scaling\n          t = floor(30.*iTime),                           // animation\n          h = iResolution.y;\n    U *= h/512.; U += t; \n    if ( iMouse.x*h/512. > U.x-t ) {                      // mouse.x show ref\n        O = vec4( texture(iChannel0, U/h).r > thresh, T(U/h)  > thresh , 0,1);\n        return;\n    }\n          \n    U *= mat2(1,-1./1.73, 0,2./1.73) *1024./Z/h;          // conversion to\n    vec3 g = vec3(U, 1.-U.x-U.y);                         // hexagonal coordinates\n\tg = fract(g);                                         // diamond coords\n    bool side = length(g)>1.;                             // tri: which diamond half\n \n    vec3 V = side ? vec3( T(G(vec2(1))), T(G(vec2(0,1))), T(G(vec2(1,0))) ) // samples at corder\n                  : vec3( T(G(vec2(0))), T(G(vec2(1,0))), T(G(vec2(0,1))) );\n    if (side) g = 1.-g;                                   // barycentric coordinates\n    O = vec4( S( (1.-g.x-g.y)*V.x + g.x*V.y + g.y*V.z - thresh ) );\n    if (step(thresh,V)==vec3(0)) O += .3;                 // empty cell ( for test )\n    \n    O = mix( vec4(.5), O, S(min(g.x,min(g.y,g.z)) ));     // grid\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdccDB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[376, 376, 414, 414, 1603]], "test": "untested"}
{"id": "NscyDS", "name": "Fork Universe_G c_design_w 484", "author": "c_design_work", "description": "A shader created as a test while working on\n   https://www.shadertoy.com/view/XlcSDr\nIf someone find it usefull ...", "tags": ["klm"], "likes": 3, "viewed": 256, "published": 3, "date": "1653987249", "time_retrieved": "2024-07-30T16:46:10.427431", "image_code": "// Created by sebastien durand - 08/2016\n//-------------------------------------------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \n// Sliders from IcePrimitives by Bers (https://www.shadertoy.com/view/MscXzn)\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n//-------------------------------------------------------------------------------------\n\n\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n#define pi 3.14159265\n\n#define DENSE_DUST\n#define DITHERING\n#define BACKGROUND\n\nconst float time = 10.;\n\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x<b.x ? a  : b;\n} \n\nfloat hash( const in vec3 p ) {\n\tfloat h = dot(p,vec3(127.1,311.7,758.5453123));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n// [iq] https://www.shadertoy.com/view/4sfGzS\nfloat pn(in vec3 x) {\n    vec3 p = floor(x), f = fract(x);\n\tf = f*f*(3.-f-f);\n\tvec2 uv = (p.xy+vec2(37.,17.)*p.z) + f.xy,\n\t     rg = texture( iChannel0, (uv+.5)/256., -100.).yx;\n\treturn -1.+2.4*mix(rg.x, rg.y, f.z);\n}\n\nbool cylinder(vec3 ro, vec3 rd, float r, float h, out float tn, out float tf) {\n\tfloat a = dot(rd.xy, rd.xy), b = dot(ro.xy, rd.xy),\n\t\t  d = b*b - a*(dot(ro.xy, ro.xy) - r*r);    \n\tif(d < 0.) \n        return false;\n\td = sqrt(d);\n\ttn = (-b - d)/a; tf = (-b + d)/a;\n\t// order roots\n\ta = min(tf, tn); tf = max(tf, tn); tn = a;\n\ta = ro.z + tn * rd.z;\n    b = ro.z + tf * rd.z;\n\t// top, bottom\n\tvec2 zcap = h*vec2(.5, -.5), cap = (zcap - ro.z) / rd.z;\n    tn = a < zcap.y ? cap.y : a > zcap.x ? cap.x : tn;\n\ttf = b < zcap.y ? cap.y : b > zcap.x ? cap.x : tf;\n    return tf > 0. && tf > tn;\n}\n\n\nfloat fpn(vec3 p) { \n    return pn(p*.06125)*.5 + pn(p*.125)*.25 + pn(p*.25)*.125;// + pn(p*.5)*.625;\n}\n\n\nfloat rand(vec2 co) {\n\treturn fract(sin(dot(co*.123,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 spiralArm(in vec3 p, in float thickness, in float blurAmout, in float blurStyle) {\n    float dephase = 2., loop = 4.;\n    float a = atan(p.x,p.z),  // angle     \n\t\t  r = length(p.xz), lr = log(r), // distance to center\n    \t  th = (.1-.25*r), // thickness according to distance\n    \t  d = fract(.5*(a-lr*loop)/pi); //apply rotation and scaling.\n    d = (.5/dephase - abs(d-.5))*2.*pi*r;\n  \td *= (1.-lr)/thickness;  // space fct of distance\n    // Perturb distance fiel1\n    float radialBlur = blurAmout*mix(fpn(8.*vec3(r*43.,40.*d,24.*p.y)),fpn(p*400.0), blurStyle);\n    return vec2(sqrt(d*d+10.*p.y*p.y/thickness)-th*r*.2-radialBlur);\n}\n\nfloat map(vec3 p, vec4 id) {\n   \treturn spiralArm(p.xzy*.2, 10.*(.5+.5*id.x), .2+.3*id.y, id.z).x;\n}\n\n\n//--------------------------------------------------------------\n\n\n// assign color to the media\nvec3 computeColor( float density, float radius ) {\n\t// color based on density alone, gives impression of occlusion within the media\n\tvec3 result = mix(vec3(.25,.22,.2), vec3(.1,.0375,.025), density );\n\t// color added for disk\n\treturn result * mix(  vec3(4.8,6.,6.), vec3(.96,1.06,1.), min( (radius+.5)/2.0, 1.15 ) );\n}\n\n\n// +----------------------------------------+\n// |                 Galaxy                 |\n// +----------------------------------------+\n\n\nvec4 renderGalaxy(in vec3 ro, in vec3 rd, in vec4 id, in float time) {\n        \n\t// ld, td: local, total density \n\t// w: weighting factor\n\tfloat ld=0., td=0., w=0.;\n\n\t// t: length of the ray\n\t// d: distance function\n\tfloat d=1., t=0.;\n    \n    const float h = .1;\n  #ifdef DITHERING\n\tvec2 seed = rd.xy + fract(iTime);    \n   \t// randomizing the length \n    // rd *= (1. + fract(sin(dot(vec3(7, 157, 113), rd.zyx))*43758.5453)*0.1-0.03); \n  #endif \n    \n\tvec4 sum = vec4(0);\n    float min_dist=0., max_dist=100.;\n\n    if(cylinder(ro, rd, 3.,3., min_dist, max_dist)) {\n        \t\n        t = max(min_dist,t); //*step(t,min_dist);\n\n        // raymarch loop\n        for (int i=0; i<60; i++)  {\n\n            vec3 pos = ro + t*rd;\n            float fld = 0.;\n\n            // Loop break conditions.\n            if(td>(1.-1./80.) ||  sum.a > .99 || t>max_dist) break;\n\n            // evaluate distance function\n            d = map(3.5*pos, id);\n            // kind of countour drawing\n            d = abs(d)+.05 ;\n\n            // direction to center\n            vec3 stardir = normalize(vec3(0.0)-pos);\n\n            // change this string to control density \n            d = max(d,.005);\n\n            if (d<.1) {\n                // compute local density \n                ld = .1 - d;\n\n              #ifdef DENSE_DUST          \n                fld = clamp((ld - map(pos*3.5+0.2*stardir, id))/0.4, 0.0, 1.0 );\n                ld += fld;\n              #endif\n\n                // compute weighting factor \n                w = (1. - td) * ld;\n\n                // accumulate density\n                td += w + 1./200.;\n\n                float radiusFromCenter = length(pos);\n                vec4 col = vec4( computeColor(td,radiusFromCenter), td );\n\n                // uniform scale density\n                col.a *= 0.2;\n                // colour by alpha\n                col.rgb *= col.a/0.8;\n                // alpha blend in contribution\n                sum = sum + col*(1.0 - sum.a);  \n            }\n\n            td += 1./70.;\n\n            // point light calculations\n            vec3 ldst = pos*.25,\n                 ldst2 = pos*.05;\n            ldst2.z*=2.5;\n            float lDist = max(length(ldst),.0001), //max(length(ldst), 0.001);\n                  lDist2 = max(length(ldst2),.0001);\n            // star in center\n            vec3 lightColor = (1.-smoothstep(3.,4.5,lDist*lDist))*\n                mix(.07*vec3(1.,.5,.25)/(lDist),\n                    .008*vec3(1.,1.7,2.)/(lDist2), \n                    smoothstep(.2,.7,lDist));\n\n            // star in center\n            //lightColor=vec3(1.0,0.5,0.25);\n            sum.rgb += lightColor/(lDist*20.); //add a bloom around the light\n\n            // using the light distance to perform some falloff\n          //  float atten = 1./(1. + lDist*0.125 + lDist*lDist*0.4);\n            // accumulating the color\n          //  sum += w*atten*fld;\n\n            // enforce minimum stepsize\n            d = max(d, .04); \n\n          #ifdef DITHERING\n            // add in noise to reduce banding and create fuzz\n            d = abs(d)*(1.+.28*rand(seed*vec2(i)));\n          #endif \n\n            t +=  max(d * .3, .02);\n        }\n\n   \t\tsum = clamp( sum, 0., 1. );\n      \tsum.xyz = sum.xyz*sum.xyz*(3.-2.*sum.xyz);\n    }\n    \n    return sum;\n}\n\n// ---------------------------------------------------\n// Bers : https://www.shadertoy.com/view/MscXzn\nvec4 processSliders(in vec2 uv, out vec4 sliderVal) {\n    sliderVal = texture(iChannel1,vec2(0));\n    return length(uv.xy)>1. ? \n            texture(iChannel1,uv.xy/iResolution.xy) :  \n            vec4(0);\n}\n\n// ---------------------------------------------------\n// Based on \"Dusty nebula 4\" by Duke (https://www.shadertoy.com/view/MsVXWW) \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord ) {\n    vec4 sliderVal;\n    vec4 cSlider = processSliders(fragCoord, sliderVal);\n\n   // camera\t   \n    float a = sliderVal.w*pi;\n    vec3 ro = 8.*vec3(0, cos(a), sin(a)),\n         ta = vec3(0);\n\tro.xy = R(ro.xy, iTime);\n    // camera tx\n    vec3 cw = normalize( ta-ro ),\n     \t cu = normalize( cross(cw,vec3(0., 0., 1.)) ),\n     \t cv = normalize( cross(cu,cw) );\n    vec2 q = (fragCoord.xy)/iResolution.xy,\n     \t p = -1.+2.*q;\n    p.x *= iResolution.x/iResolution.y;\n    \n    vec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    vec4 sum = vec4(0);\n    \n    vec4 cGalaxy = renderGalaxy(ro,rd, sliderVal, iTime);\n  \n    cGalaxy += (1.-cGalaxy.a)*sum;\n\n     //Apply slider overlay\n    fragColor = vec4(mix(cGalaxy.xyz, cSlider.rgb, cSlider.a), 1.);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscyDS.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[618, 618, 645, 645, 676], [804, 850, 871, 871, 1067], [1069, 1069, 1148, 1148, 1655], [1658, 1658, 1677, 1677, 1761], [1764, 1764, 1785, 1785, 1855], [1857, 1857, 1944, 1944, 2499], [2501, 2501, 2529, 2529, 2601], [2671, 2700, 2750, 2831, 3018], [3161, 3161, 3231, 3298, 6434], [6436, 6539, 6592, 6592, 6746], [6748, 6881, 6937, 6937, 7689]], "test": "untested"}
{"id": "sdtcRs", "name": "Apple Mac Pro Universe", "author": "copperbotte", "description": "This is a raymarcher for Apple's mac pro grill.\n\nClick and drag with the mouse!", "tags": ["raymarcher", "apple", "mac"], "likes": 7, "viewed": 320, "published": 3, "date": "1653986893", "time_retrieved": "2024-07-30T16:46:11.176428", "image_code": "\nfloat sdf_sphere(vec3 wPos, vec3 sPos, float sSize)\n{\n    float sdf = length(wPos - sPos) - sSize;\n    \n    //if(sdf < 0.0) normal = -normalize(wPos - sPos);\n    //else normal = normalize(wPos - sPos);\n    \n    return sdf;\n}\n\n// Thanks iQ!! https://iquilezles.org/articles/distfunctions/\nfloat sdf_cube(vec3 wPos, vec3 cPos, vec3 cSize)\n{\n    vec3 diff = abs(wPos - cPos) - cSize;\n    \n    // Outer is the vector from the current point to each side of the cube, offset by its size.\n    // If multiple offset are larger than 0, the distance is given by length instead of one side only.\n    vec3 outer = max(diff, 0.0);\n    \n    // Inner is the minimum distance to any side, which is guaranteed to be a straight line distance.\n    float inner = min(max(max(diff.x, diff.y), diff.z), 0.0);\n    \n    // The side closest to the cube has a length of 1.\n    //vec3 invec = diff / inner; \n    \n    float sdf = length(outer) + min(max(max(diff.x, diff.y), diff.z), 0.0);\n    //if(0.0 <= sdf) normal = normalize(wPos - outer - cSize);\n    //else normal = \n    return sdf;\n    \n    \n    //return length(outer) + min(max(max(diff.x, diff.y), diff.z), 0.0);\n}\n\n// Global SDF\nfloat Sdf(in vec3 wPos)\n{   \n    const float s3 = sqrt(3.0);\n    float sRad = s3/4.0;\n\n    //float s = sdf_sphere(wPos, vec3(0.0, 1.0 - sRad, 0.0), sRad);\n    float csize = (2.0/3.0)*sRad;\n    float c = sdf_cube(wPos, vec3(0.0, -csize, 0.0), vec3(1000.0, csize, 1000.0));\n\n    //float sdf = min(s, c);\n    //float sdf = max(-s, c);\n    \n    float sdf = c;\n    \n////////////////////////////////////////////////////////////////////////////////\n    \n    // https://saccade.com/blog/2019/06/how-to-make-apples-mac-pro-holes/\n    //     The Mac pro's grill is made of a grid of spheres cut into a flat\n    // surface.  The spheres centers are on the surface, spaced equilaterally.\n    // Their radii is selected such that the top of each sphere touches the\n    // bottom of the sphere the next row up.  The surface has another set of\n    // spheres cut underneath, offset such that the spheres align with the\n    // centroid of the triangular grid.  The thickness of plate is 2/3 r, so the\n    // spheres intersect with regular triangular holes.\n    // \n////////////////////////////////////////////////////////////////////////////////\n    //     For an equilateral grid with spheres spaced every unit, we can \n    // represent this as a coordinate system with a shear:\n    // \n    //     Each sphere repeats along the x axis every unit, offset by a half unit \n    // for each y. It also repeats along the y axis, offset by 1/3 the y height \n    // for each z. This can be encoded by a matrix:\n    //\n    // [x]   [1  1/2    0] [i]\n    // [y] = [0 s3/2 s3/6]*[j]\n    // [z]   [0    0 s3/6] [k]\n    // where s3 is sqrt(3).\n    // \n    //     To find the closest sphere to a point on the grid, coordinates are \n    // first transformed into this coordinate system via its inverse:\n    // \n    // [i]   [s3 -1  1]      [x]\n    // [j] = [ 0  2 -2]*s3/3*[y]\n    // [k]   [ 0  0  6]      [z]\n    //\n    // Then, the coordinates are rounded, then transformed back.\n    \n    //     Using the full 3x3 matrix seems to introduce errors, going to fall back\n    // to manually computing z.\n    \n    \n    /*\n    mat3x3 smat = mat3x3(1,    0.5,      0,\n                         0, s3/2.0, s3/6.0,\n                         0,      0, s3/3.0);\n    mat3x3 ismat = mat3x3(s3, -1,  1,\n                           0,  2, -2,\n                           0,  0,  6)*s3/3.0;\n    /*/\n    mat3x3 smat = mat3x3(1,    0.5,      0,\n                         0, s3/2.0,      0,\n                         0,      0, s3/6.0);\n    mat3x3 ismat = mat3x3(s3, -1,  0,\n                           0,  2,  0,\n                           0,  0,  6)*s3/3.0;\n    //*/                    \n                          \n    for(int i=0; i<2; ++i)\n    {\n        for(int j=0; j<2; ++j)\n        {\n            vec3 drift = vec3(float(i), float(j), 0);\n            \n            vec3 coords = (drift + round(wPos.xzy * ismat)) * smat;\n            float s = sdf_sphere(wPos, vec3(coords.x, 0, coords.y), sRad); \n            sdf = max(sdf, -s);\n            \n            vec3 offset = vec3(0, sqrt(3.0)/3.0, 0);\n            drift = vec3(float(i), float(j), 1);\n            coords = (drift + round((wPos.xzy + offset) * ismat)) * smat - offset;\n            s = sdf_sphere(wPos, vec3(coords.x, -sRad, coords.y), sRad); \n            sdf = max(sdf, -s);\n        }\n    }\n    \n    return sdf;\n}\n\n\n// SDF Raymarch\nvec3 raymarch(in vec3 rPos, in vec3 rDir)\n{\n    vec3 sPos = rPos;\n    \n    float dir = sign(Sdf(sPos));\n    \n    for(int i=0; i<100; ++i)\n    {\n        float sdf = Sdf(sPos);\n        sPos += rDir * dir * sdf;\n        if(abs(sdf) < 1e-4)\n            return sPos;\n    }\n    \n    return sPos;\n}\n\n\n// Color each world position by firing a ray off\nvec3 color_wpos(in vec3 wPos, in vec3 rDir)\n{\n    // Find the sdf's local gradient\n    const float epsilon = 1e-5;\n    \n    // thx iq!! https://iquilezles.org/articles/normalsSDF/\n    const vec2 k = vec2(1,-1);\n    vec3 normal = normalize(\n        k.xyy*Sdf( wPos + k.xyy*epsilon ) + \n        k.yyx*Sdf( wPos + k.yyx*epsilon ) + \n        k.yxy*Sdf( wPos + k.yxy*epsilon ) + \n        k.xxx*Sdf( wPos + k.xxx*epsilon ) );\n    \n    // Light with PBR Phong\n    float theta = iTime;\n    vec3 lDir = normalize(vec3(sin(theta),2,cos(theta)));\n    float diffuse = max(0.0, dot(lDir, normal));\n    \n    vec3 refl = reflect(rDir, normal);\n    float power = 10.0;\n    float specular = pow(max(0.0, dot(refl, lDir)), power);\n    \n    float reflectivity = 0.2;\n    float L = mix(diffuse, specular*(power + 2.0)/2.0, reflectivity); // /3.141592;\n    \n    // Check if the raymarch yeets off very far\n    vec3 endPos = raymarch(wPos + lDir*100.0, -lDir);\n    if(length(endPos - wPos) < 1e-2)\n        return vec3(L + 0.1);\n    else\n        return vec3(0.1);\n}\n\n// Generate a ray to march\nvoid generate_ray(in vec2 xy, out vec3 rPos, out vec3 rDir)\n{\n    rPos = vec3(0,0,20);\n    //rPos = vec3(0,0,2);\n    \n    vec3 dir = vec3(xy, -1);\n    rDir = normalize(dir);\n    \n    float theta = iTime / 10.0;\n    float phi = 3.141592/4.0;\n    \n    if(0.5 < iMouse.z)\n    {\n        theta = ((iMouse.x / iResolution.x)*2.0 - 1.0)*3.141592;\n        phi += ((iMouse.y / iResolution.y)*2.0 - 1.0)*3.141592 * iResolution.y/iResolution.x;\n    }\n    float ct = cos(theta);\n    float st = sin(theta);\n    float cp = cos(phi);\n    float sp = sin(phi);\n\n    mat3x3 pitch = mat3x3(1.0, 0.0, 0.0,\n                          0.0,  cp, -sp,\n                          0.0,  sp,  cp);\n\n    mat3x3 yaw = mat3x3( ct, 0.0, -st,\n                        0.0, 1.0, 0.0,\n                         st, 0.0,  ct);\n\n    mat3x3 view = yaw * pitch;\n    rPos = view * rPos;\n    rDir = view * rDir;\n    \n}\n\n// Seperate sample function for integration\nvec3 sample_image( in vec2 uv )\n{\n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 rPos, rDir;\n    generate_ray(xy, rPos, rDir);\n    vec3 sPos = raymarch(rPos, rDir);\n    \n    if(abs(Sdf(sPos)) < 0.01)\n        col = color_wpos(sPos, rDir);\n    \n    // Output to screen\n    return col;\n}\n\n// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n \n    const int samples = 4;\n    const float s_f = float(samples);\n \n    for(int i=0; i<samples; ++i)\n    {\n        vec2 rng = vec2(rnd(), rnd()) - 0.5;\n        //vec2 rng = vec2(0);\n    \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = (fragCoord+rng)/iResolution.xy;\n        vec3 C = sample_image(uv);\n        C = pow(C, vec3(2.2));\n        col += C;\n    \n    }\n    \n    col /= s_f;\n    \n    // adjust for srgb color space\n    // rough approx\n    col = pow(col, vec3(1.0/2.2));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtcRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 54, 54, 225], [227, 289, 339, 339, 1147], [1149, 1163, 1188, 1188, 4485], [4488, 4504, 4547, 4547, 4795], [4798, 4847, 4892, 4929, 5889], [5891, 5918, 5979, 5979, 6792], [6794, 6838, 6871, 6931, 7249], [7251, 7343, 7356, 7356, 7399], [7401, 7401, 7458, 7458, 8023]], "test": "untested"}
{"id": "sdtyzl", "name": "2d outline", "author": "jorge2017a2", "description": "2d outline", "tags": ["2doutline"], "likes": 35, "viewed": 843, "published": 3, "date": "1653960759", "time_retrieved": "2024-07-30T16:46:12.000225", "image_code": "//por jorge2017a2\n\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(6.0*antialiasing(0.5),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}    \n\nfloat intersectSDF(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat unionSDF(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat differenceSDF(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\nfloat sdTunnel( in vec2 p, in vec2 wh )\n{\n    p.x = abs(p.x); p.y = -p.y;\n    vec2 q = p - wh;\n\n    float d1 = dot2(vec2(max(q.x,0.0),q.y));\n    q.x = (p.y>0.0) ? q.x : length(p)-wh.x;\n    float d2 = dot2(vec2(q.x,max(q.y,0.0)));\n    float d = sqrt( min(d1,d2) );\n    \n    return (max(q.x,q.y)<0.0) ? -d : d;\n}\n\nvec3 CirculoBorde1(vec2 p, vec2 pos,  vec3 colOut, vec3 colIn)\n{\n    float d3= sdCircle(p-pos, 0.5 );\n    float d4= sdCircle(p-pos, 0.3 );\n    vec3 col= DrawFigBorde(vec3(0.0), colOut, d3 );\n    col= DrawFigBorde(vec3(1.0), col, d4 );\n    return col;\n}\n\n\nvec3 bloque1(vec2 p, vec3 colOut, vec3 colIn )\n{   float r=0.5;\n    float anchb=0.2,altob=0.2;\n    float ancha=3.0,altoa=3.0;\n    float d1= sdBox(p, vec2(ancha+anchb,altoa+altob) )-r;\n    float d2= sdBox(p, vec2(ancha,altoa) )-r;\n    vec3 col= DrawFigBorde(vec3(0.0), colOut, d1 );\n    col *= 1.0 - 0.5*exp(-5.0*abs(d1)); //iq\n    col= DrawFigBorde(colIn, col, d2 );\n    col *= 1.0 - 0.5*exp(-5.0*abs(d2)); //iq\n    \n    p.x=abs(p.x)-2.3;\n    p.y=abs(p.y)-2.3;\n    col= CirculoBorde1(p, vec2(0.0,0.0), col,vec3(1.0));\n    return col;\n }\n\n\nvec3 bloque2(vec2 p, vec3 colOut, vec3 colIn )\n{   float r=0.5;\n    float anchb=0.2,altob=0.2;\n    float ancha=3.0,altoa=5.0;\n    float d1= sdBox(p, vec2(ancha+anchb,altoa+altob) )-r;\n    float d2= sdBox(p, vec2(ancha,altoa) )-r;\n    vec3 col= DrawFigBorde(vec3(0.0), colOut, d1 );\n    col *= 1.0 - 0.5*exp(-5.0*abs(d1));\n    col= DrawFigBorde(colIn, col, d2 );\n    col *= 1.0 - 0.5*exp(-5.0*abs(d2));\n    \n    p.x=abs(p.x)-2.3;\n    p.y=abs(p.y)-2.3;\n    col= CirculoBorde1(p, vec2(0.0,1.8), col,colIn);\n    return col;\n }\n\n\nvec3 bloquePiso(vec2 p, vec3 colOut)\n{   vec3 col1= vec3(173,104,47)/255.;\n    float alto=1.3;\n    float d1= sdBox(p, vec2(25.0,alto));\n    float d2= sdBox(p, vec2(25.0-0.5,alto-0.3));\n    \n    vec3 col= DrawFigBorde(vec3(0.0), colOut,d1 );\n    col= DrawFigBorde(col1, col,d2 );\n    col *= 1.0 - 0.5*exp(-8.0*abs(d2));\n    return col;\n}\n\nfloat bloqueZigzagDist(vec2 p)\n{   p.x=p.y*0.5+0.5*sin(p.y)+mod(p.x,1.0)*6.0;\n    float d1=p.x;\n    float d2=p.x-2.;\n    d1= differenceSDF(d2, d1);\n    return d1;\n}\n\n\nvec3 bloquePisoLineas(vec2 p, vec3 colOut)\n{   vec3 col1= vec3(173,104,47)/255.;\n    float d1= sdBox(p, vec2(25.0,5.0));\n    float d2= sdBox(p, vec2(25.0-0.5,5.0-0.2));\n    float d3= bloqueZigzagDist(p-vec2(0.0,4.0));\n    d3=  intersectSDF(d1, d3);\n    vec3 col= DrawFigBorde(vec3(0.0), colOut,d1 );\n    col= DrawFigBorde(col1, col,d2 );\n    col *= 1.0 - 0.5*exp(-8.0*abs(d2));\n    col= DrawFigBorde(vec3(0.0), col,d3 );\n    return col;\n}\n\n\nvec3 bloqueZigzag(vec2 p, vec3 colOut)\n{  vec3 col1= vec3(173,104,47)/255.;\n    p.x=p.y*0.5+mod(p.x,1.0)*5.0;\n    float d1=p.x;\n    float d2=p.x-0.9;\n    d1= differenceSDF(d2, d1);\n    vec3 col= DrawFigBorde(vec3(0.0), colOut,d1 );\n    return col;\n}\n\nvec3 distTunelcol(vec2 p, vec2 med, vec3 colOut)\n{\n    vec2 meddif=vec2(0.2,0.2);\n    float d1a= sdTunnel(p, med );\n    float d1b= sdTunnel(p, med-meddif );\n    vec3 col= DrawFigBorde(vec3(0.0), colOut,d1a );\n    col= DrawFigBorde(vec3(0.0,0.8,0.0), col,d1b );\n    return col;\n}\n\nvec3 OjosDist(vec2 p,vec3 colOut)\n{\n    p.x=abs(p.x)-0.8;\n    float d1= sdCircle( p, 0.25 );\n    vec3 col= DrawFigBorde(vec3(0.0), colOut,d1 );\n    return col;\n}\n\nvec3 planta(vec2 p, vec3 colOut)\n{\n    colOut= distTunelcol(p-vec2(3.0,3.0), vec2(2.0,6.0),colOut );\n    colOut= OjosDist(p-vec2(3.0,3.2),colOut);\n    colOut= distTunelcol(p, vec2(2.0,3.0), colOut );\n    colOut= OjosDist(p-vec2(0.0,0.2),colOut);\n    colOut= distTunelcol(p-vec2(3.0,-1.0), vec2(2.0,2.0),colOut );\n    colOut= distTunelcol(p-vec2(6.0,1.0), vec2(2.0,4.0), colOut );\n    colOut= distTunelcol(p-vec2(8.0,0.0), vec2(2.0,3.0), colOut );\n    colOut= OjosDist(p-vec2(8.0,0.0),colOut);\n    colOut= distTunelcol(p-vec2(5.0,-2.0), vec2(2.0,1.0),colOut );\n    colOut= OjosDist(p-vec2(5.0,-2.0),colOut);\n    vec3 col=colOut;\n    return col;\n}\n\n\nvec3 Nube(vec2 p, vec3 colOut)\n{\n    vec2 p0=p;\n    p.x=abs(p.x)-1.8;\n    float d1= sdCircle( p, 1.25 );\n    float d2= sdCircle( p0-vec2(0.0,1.0), 1.5 );\n    float d3= sdBox(p0, vec2(0.5,0.1));\n    \n    vec3 col= DrawFigSolo(vec3(1.0), colOut,d1 );\n    \n    \n    col *= 1.0 - 0.5*exp(-5.0*abs(d1));\n    \n    \n    col= DrawFigSolo(vec3(1.0), col,d2 );\n    col *= 1.0 - 0.5*exp(-5.0*abs(d2));\n    col=OjosDist(p0-vec2(-0.2,1.2),col);\n    \n    col= DrawFigSolo(vec3(0.0), col,d3);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = -1.0 + 2.0 * fragCoord.xy/iResolution.xy;\n\tuv.x *= iResolution.x/iResolution.y;\n    uv-=vec2(0.0,-0.1);\n    float esc=14.0;\n    vec2 uv0=uv;\n    uv*=esc;\n    vec3 col =vec3(105,156,248)/255.0-uv0.y*0.25;\n    \n    vec3 col1;\n    col=bloquePisoLineas(uv-vec2(0.0,-11.0),col);\n    col1=vec3(88.,200.,246.)/255.0;\n    col= bloque2(uv-vec2(4.5,2.0), col,col1 );\n    col1=vec3(245.0,144.,72.0)/255.;\n    col= bloque1(uv, col,col1 );\n    col=bloquePiso(uv-vec2(0.0,-5.0), col);\n    col= planta(uv-vec2(-15.0,-0.7), col);\n    float posx=5.0*sin(iTime);\n    col= Nube(uv-vec2(-9.0+posx,7.0), col);\n    col= Nube(uv-vec2(5.0-posx,9.0), col);\n    \n    col=pow(col,  vec3(0.554545));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "sound_code": "\nstruct Note {\n    // in Hz, see \"common\" tab\n    float frequency;\n    // offset - time in seconds when to start playing note\n    float offset;\n    // duration of a note (1/4, 1/8, ...), see \"common\" tab\n    float duration;\n};\n\n\n\n\n\n//version D \n////Octava #1\n//--fin--\n////Octava #2\n const float A0 =27.5;  //1\n const float A_0 =29.14;  //2\n const float B0 =30.87;  //3\n//--fin--\n////Octava #3\n const float C1 =32.7;  //4\n const float C_1 =34.65;  //5\n const float D1 =36.71;  //6\n const float D_1 =38.89;  //7\n const float E1 =41.2;  //8\n const float F1 =43.65;  //9\n const float F_1 =46.25;  //10\n const float G1 =49.0;  //11\n const float G_1 =51.91;  //12\n const float A1 =55.;  //13\n const float A_1 =58.27;  //14\n const float B1 =61.74;  //15\n//--fin--\n////Octava #4\n const float C2 =65.41;  //16\n const float C_2 =69.3;  //17\n const float D2 =73.42;  //18\n const float D_2 =77.78;  //19\n const float E2 =82.41;  //20\n const float F2 =87.31;  //21\n const float F_2 =92.5;  //22\n const float G2 =98.;  //23\n const float G_2 =103.83;  //24\n const float A2 =110.;  //25\n const float A_2 =116.54;  //26\n const float B2 =123.47;  //27\n//--fin--\n////Octava #5\n const float C3 =130.81;  //28\n const float C_3 =138.59;  //29\n const float D3 =146.83;  //30\n const float D_3 =155.56;  //31\n const float E3 =164.81;  //32\n const float F3 =174.61;  //33\n const float F_3 =185.;  //34\n const float G3 =196.;  //35\n const float G_3 =207.65;  //36\n const float A3 =220.;  //37\n const float A_3 =233.08;  //38\n const float B3 =246.94;  //39\n//--fin--\n////Octava #6\n const float C4 =261.63;  //40\n const float C_4 =277.18;  //41\n const float D4 =293.66;  //42\n const float D_4 =311.13;  //43\n const float E4 =329.63;  //44\n const float F4 =349.23;  //45\n const float F_4 =369.99;  //46\n const float G4 =392.;  //47\n const float G_4 =415.3;  //48\n const float A4 =440.;  //49\n const float A_4 =466.16;  //50\n const float B4 =493.88;  //51\n//--fin--\n////Octava #7\n const float C5 =523.25;  //52\n const float C_5 =554.37;  //53\n const float D5 =587.33;  //54\n const float D_5 =622.25;  //55\n const float E5 =659.26;  //56\n const float F5 =698.46;  //57\n const float F_5 =739.99;  //58\n const float G5 =783.99;  //59\n const float G_5 =830.61;  //60\n const float A5 =880.;  //61\n const float A_5 =932.33;  //62\n const float B5 =987.77;  //63\n//--fin--\n////Octava #8\n const float C6 =1046.5;  //64\n const float C_6 =1108.73;  //65\n const float D6 =1174.66;  //66\n const float D_6 =1244.51;  //67\n const float E6 =1318.51;  //68\n const float F6 =1396.91;  //69\n const float F_6 =1479.98;  //70\n const float G6 =1567.98;  //71\n const float G_6 =1661.22;  //72\n const float A6 =1760.;  //73\n const float A_6 =1864.66;  //74\n const float B6 =1975.53;  //75\n//--fin--\n////Octava #9\n const float C7 =2093.;  //76\n const float C_7 =2217.46;  //77\n const float D7 =2349.32;  //78\n const float D_7 =2489.02;  //79\n const float E7 =2637.02;  //80\n const float F7 =2793.83;  //81\n const float F_7 =2959.96;  //82\n const float G7 =3135.96;  //83\n const float G_7 =3322.44;  //84\n const float A7 =3520.;  //85\n const float A_7 =3729.31;  //86\n const float B7 =3951.07;  //87\n//--fin--\n////Octava #10\n const float C8 =4186.01;  //88\n const float C_8 =4434.92;  //89\n const float D8 =4698.64;  //90\n const float D_8 =4978.03;  //91\n const float E8 =5274.04;  //92\n const float F8 =5587.65;  //93\n const float F_8 =5919.91;  //94\n const float G8 =6271.93;  //95\n const float G_8 =6644.88;  //96\n const float A8 =7040.;  //97\n const float A_8 =7458.62;  //98\n const float B8 =7902.13;  //99\n//--fin--\n\n\n\nconst Note[] notes = Note[] (\n\nNote(G3,0.00000,0.25),\nNote(G3,0.25000,0.25),\nNote(G3,0.50000,0.25),\nNote(C3,0.75000,0.5),\nNote(G3,1.25000,0.5),\nNote(F3,1.75000,0.125),\nNote(E3,1.87500,0.125),\nNote(D3,2.00000,0.125),\nNote(C4,2.12500,0.5),\nNote(G3,2.62500,0.25),\nNote(F3,2.87500,0.125),\nNote(E3,3.00000,0.125),\nNote(D3,3.12500,0.125),\nNote(C4,3.25000,0.5),\nNote(G3,3.75000,0.25),\nNote(F3,4.00000,0.125),\nNote(E3,4.12500,0.125),\nNote(F3,4.25000,0.125),\nNote(D3,4.37500,0.5),\nNote(G3,4.87500,0.125),\nNote(G3,5.00000,0.125),\nNote(G3,5.12500,0.125),\nNote(C3,5.25000,0.5),\nNote(G3,5.75000,0.5),\nNote(F3,6.25000,0.125),\nNote(E3,6.37500,0.125),\nNote(D3,6.50000,0.125),\nNote(C4,6.62500,0.5),\nNote(G3,7.12500,0.25),\nNote(F3,7.37500,0.125),\nNote(E3,7.50000,0.125),\nNote(D3,7.62500,0.125),\nNote(C4,7.75000,0.5),\nNote(G3,8.25000,0.25)\n\n\n\n);\n\nfloat Weight( float x )\n{  if( x < 0.0 )x = - x;\n\tif( x < 1.0 )return (1.0 - 2.0*x*x + x*x*x) ;\n\tif( x < 2.0 )return (4.0 - 8.*x + 5.*x*x - x*x*x) ;\nreturn 0.0 ;\n}\n\n\nfloat saw(float t, float note, float octave)\n{   return fract(t*note*exp2(octave-1.))-0.5; }\n\n\nvec2 noteFreq(Note note, float time) \n{\n    float octava=3.0;\n    float n1=saw(time,note.frequency, octava)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    float t=time;\n    n1=Weight(n1)*n1;    \n    return vec2(n1);\n}\n\n\n\nvec2 mainSound( in int samp,float time) \n{   vec2 result;\n    //float tt=sin(time*0.25);\n    float ftime= mod(time*0.5, 10.0);\n    \n    for (int i = 0; i < notes.length(); i++) {\n        Note note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        { result += noteFreq(note, ftime);  }\n    }\n    return result*0.135;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 337, 337, 382], [388, 388, 435, 435, 462], [463, 463, 506, 506, 533], [534, 534, 582, 582, 610], [614, 614, 676, 676, 806], [808, 808, 870, 870, 935], [938, 938, 975, 975, 1049], [1051, 1051, 1086, 1086, 1109], [1111, 1111, 1136, 1136, 1155], [1156, 1156, 1181, 1181, 1200], [1201, 1201, 1237, 1237, 1265], [1268, 1268, 1309, 1309, 1578], [1580, 1580, 1644, 1644, 1832], [1835, 1835, 1883, 1883, 2371], [2374, 2374, 2422, 2422, 2896], [2899, 2899, 2937, 2937, 3235], [3237, 3237, 3269, 3269, 3401], [3404, 3404, 3448, 3448, 3842], [3845, 3845, 3885, 3885, 4094], [4096, 4096, 4146, 4146, 4374], [4376, 4376, 4411, 4411, 4537], [4539, 4539, 4573, 4573, 5184], [5187, 5187, 5219, 5219, 5687], [5689, 5689, 5746, 5746, 6465]], "test": "untested"}
{"id": "sd3cW4", "name": "Glass Walls", "author": "byt3_m3chanic", "description": "Glass / Refractive surface - moving textured wall behind glass.\n", "tags": ["raymarching", "refraction", "glass"], "likes": 28, "viewed": 537, "published": 3, "date": "1653957068", "time_retrieved": "2024-07-30T16:46:12.806070", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Beveled Glass 5/23/22 @byt3_m3chanic\n    \n    Just some glass with a refractive surface - animated textured wall behind.\n    AA makes it pretty - but can be slow on lower end machines.\n    \n    big thank you to, and a little bit of help from:\n    @blackle, @tdhooper, @iq, @Drakyen\n    \n*/\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI2     6.28318530718\n#define PI      3.14159265359\n\n// AA Setting - comment out to disable\n#define AA 2\n\nfloat time;\nmat2 rot(float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*43758.5453); }\n\n//@iq https://iquilezles.org/articles/palettes\nvec3 hue(float t){ return .45+.4*cos( PI2*t*vec3(.95,.97,.88)*vec3(0.110,0.584,0.949) ); }\n\n\nfloat box( vec3 p, vec3 b ){\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat box( vec2 p, vec2 b){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n//global\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat radius = 1.25;\n     \nconst vec2 scaler =vec2(6.);\nfloat pattern(vec3 pt){\n    vec3 hp = pt;\n    vec2 uv   = hp.xy;\n\n    vec2 grid = fract(uv.xy*scaler)-.5;\n    vec2 id   = floor(uv.xy*scaler);\n    float hs = hash21(id);\n\n    if(hs>.5) grid.x*=-1.;\n    float chk = mod(id.y + id.x,2.) * 2. - 1.;\n\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n\n    float circle = length(gx)-.5;\n    circle=abs(circle)-.075;\n\n    if(hs>.82){\n     circle = abs(length(gx.x)-.5)-.075;\n     circle = min(circle,abs(length(gx.y)-.5)-.075);\n    }\n    \n    float px = 45.5/R.x;\n    circle=abs(abs(circle)-.08)-.01;\n    circle=smoothstep(-px,.175-px,circle);\n\n    float h = mix(.0, .1,circle);\n    return clamp(h*.1,.0,.1);\n}\n\nmat2 spin;\n\nvec2 map(vec3 p){\n    vec2 res = vec2(1e5,0.);\n    p.xy*=spin;\n    \n    vec3 q = p-vec3(.2*sin(T*.1),.2*cos(T*.0981),1);\n    vec3 r = p+vec3(0,0,7);\n\n    float hmp = pattern(q);\n    q.z+=.085*sin(T*.45+q.x*3.7);\n\n    float glass = abs(q.z)-hmp;\n\n    if(glass<res.x) {\n        res = vec2(glass,2.);\n        hit=q;\n    }    \n\n    float background = box(r,vec3(12.,8.,.1));\n    if(background<res.x) {\n        res = vec2(background,3.);\n        hit=r;\n    }    \n\n    return res;\n}\n\n//Tetrahedron technique\n//https://iquilezles.org/articles/normalsSDF\nvec3 normal(vec3 p, float t, float mindist) {\n    float e = mindist*t;\n    vec2 h = vec2(1.0,-1.0)*0.5773;\n    return normalize( h.xyy*map( p + h.xyy*e ).x + \n\t\t\t\t\t  h.yyx*map( p + h.yyx*e ).x + \n\t\t\t\t\t  h.yxy*map( p + h.yxy*e ).x + \n\t\t\t\t\t  h.xxx*map( p + h.xxx*e ).x );\n}\n\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n) {\n    n = normal(p,d,1.);\n    vec3 lpos = vec3(.1,9,7);\n    vec3 l = normalize(lpos-p);\n\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 h = vec3(.0005);\n    \n    if(m==3.) {\n        vec2 uv = hitPoint.xy*.075;\n        uv.x+=T*.05;\n        \n        float scale = 10.;\n        vec2 id = floor(uv*scale);\n        uv = fract(uv*scale)-.5;\n\n        float hs = hash21(id);\n        vec3 hue = 0.5 + 0.5*cos(hs+vec3(0,1,2)-id.xyx*.2);\n         \n        if(hs>.55) {\n            scale*=.75;\n            id   = floor(uv*2.);\n            uv = fract(uv*2.)-.5;\n            hue *= 0.5 + 0.5*cos(id.x+vec3(0,1,2)+id.y);\n        }\n    \n        h =vec3(0);\n\n        float px = 1.5*scale/R.x;\n        float d = box(uv,vec2((fract(hs*3.1)>.9)?.3:.325))-(.015*scale);\n        if(fract(hs*3.1)>.9) d=abs(d)-.05;\n        d = smoothstep(px,-px,d);\n\n        h = mix (h,hue,d);\n    }\n    \n    \n    return h*pow(h, vec3(1.25))*2.5;\n}\n\nvec3 renderAll( vec2 uv){    \n\n    vec3 C=vec3(.0);\n    vec3 ro = vec3(0,0,1.45),\n         rd = normalize(vec3(uv,-1));\n\n    float x = M.xy == vec2(0) ? .0 : -(M.y/R.y * .05 - .025) * PI;\n    float y = M.xy == vec2(0) ? .0 :  (M.x/R.x * .05 - .025) * PI;\n\n    mat2 rx = rot(x), ry = rot(y);\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.;\n    float iv= 1.;\n    float bnc = 5.;\n    float alpha = 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    for(int i=0;i<110;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n=vec3(0);\n        float fresnel=0.;\n        float d = i<32?ray.x*.85:ray.x;\n        float m = ray.y;\n        p += rd * d *k;\n        \n        if (d*d < 1e-7) {\n            bnc--;\n            hitPoint=hit;\n\n            alpha*=d;\n            \n            C+=shade(p,rd,d,m,n)*atten;\n            if(m==3.)break;\n            atten *= .7;\n            p += rd*.001;\n            k = sign(map(p).x);\n            \n            vec3 rf=refract(rd,n,iv > 0. ? 1./1.2 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.001;\n   \n            if(bnc<1.) break;\n        }  \n        if(distance(p,rd)>100.) { break; }\n       \n    }\n\n   return clamp(C,vec3(0),vec3(1));\n}\n\nfloat vmul(vec2 v) {return v.x * v.y;}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    \n    float mTime = iTime;\n    time = mTime;    \n    spin = rot(.5*sin(T*.2));\n    vec2 o = vec2(0);\n\n    // AA and motion blur from iq https://www.shadertoy.com/view/3lsSzf\n    // set AA above renderFull\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderAll(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3cW4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[577, 577, 596, 596, 641], [642, 642, 664, 664, 723], [725, 772, 790, 790, 862], [865, 865, 893, 893, 984], [986, 986, 1013, 1013, 1093], [1195, 1195, 1218, 1218, 1908], [1922, 1922, 1939, 1939, 2398], [2400, 2469, 2514, 2514, 2740], [2742, 2742, 2803, 2803, 3712], [3714, 3714, 3739, 3739, 5097], [5099, 5099, 5119, 5119, 5137]], "test": "untested"}
{"id": "Nsdczf", "name": "Pride 2022", "author": "byt3_m3chanic", "description": "Some simple SDF extrusions to make some custom letters.  (mouseable)", "tags": ["refraction", "typography", "pride2022"], "likes": 18, "viewed": 446, "published": 3, "date": "1653956242", "time_retrieved": "2024-07-30T16:46:13.733591", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n     PRIDE 2022 | 6/01/22  @byt3_m3chainc\n\n    Some simple SDF extrusions to make some custom letters.\n    \n    made with a big thank you and a little bit of \n    help from: @blackle, @tdhooper, @iq, @Drakyen\n*/\n\n\n#define R \t\tiResolution\n#define T \t\tiTime\n#define M \t\tiMouse\n\n#define PI          \t3.14159265358\n#define PI2         \t6.28318530718\n\n#define MAX_DIST    40.\n\n// AA Setting - comment/uncomment to disable/endable AA from render\n#define AA 2\n\nfloat mtime=0.,time=0.;\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(21.23,41.232)))*43758.5453); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\nfloat vmax(vec3 p){ return max(max(p.x,p.y),p.z); }\nfloat box(vec3 p, vec3 b){\n\tvec3 d = abs(p) - b;\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box(vec3 p, vec3 b, in vec4 r ){   r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\tvec3 d = abs(p) - b+vec3(r.x,0,0);\n\treturn length(max(d,vec3(0))) + vmax(min(d,vec3(0)));\n}\nfloat box( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box( in vec2 p, in vec2 b, in vec4 r ){\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0)) - r.x;\n}\n// letter shapes\nfloat getP(vec2 uv){\n    float letp = box(uv-vec2(-.04,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letp=abs(letp)-.05;\n    letp=min(box(uv+vec2(.19, .0),vec2(.05,.3)),letp);\n    return letp;\n}\nmat2 rtR,ry,rx;\nfloat getR(vec2 uv){\n    float letr = box(uv-vec2(0,.1),vec2(.15),vec4(.15,.15,.00,0));\n    letr=abs(letr)-.05;\n    letr=min(box(uv+vec2(.15,.0),vec2(.05,.3)),letr);\n    vec2 uu = uv+vec2(-.1, .175);\n    uu.xy*=rtR;\n    letr=min(box(uu,vec2(.05,.175)),letr);\n    letr=max(letr, -box(uv+vec2(-.1, .35),vec2(.4,.05)) ); \n    return letr;\n}\nfloat getI(vec2 uv){\n    float leti = box(uv,vec2(.05,.3));\n    return leti;\n}\nfloat getD(vec2 uv){\n    float letd = box(uv,vec2(.125,.25),vec4(.125,.125,.00,0));\n    letd=abs(letd)-.05;\n    letd=min(box(uv+vec2(.125, .0),vec2(.05,.3)),letd);\n    return letd;\n}\nfloat getE(vec2 uv){\n    uv.y=abs(uv.y);\n    float lete = box(uv-vec2(.0, .0),vec2(.05,.3));\n    lete = min(box(uv-vec2(.1, .0),vec2(.10,.05)),lete);\n    lete = min(box(uv-vec2(.1, .25),vec2(.15,.05)),lete);\n    return lete;\n}\n//@iq sdf extrude\nfloat opx(in float sdf, in float pz, in float h){\n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n}\n\n//global vars\nvec3 hit=vec3(0), hitPoint=vec3(0);\n\nvec2 map(vec3 p) {\n\tvec2 res = vec2(100.,-1.);\n    p.x+=.02;\n    vec3 q = p;\n\n    p.zy*=rx;\n    p.xz*=ry;\n    \n    float tn = 0.;\n    float lp = getP(p.xy+vec2(.75,0));\n    tn = lp;\n    float tp = opx(lp,p.z,.1);\n\n    float lr = getR(p.xy+vec2(.30,0));\n    tn=min(lr,tn);\n    float tr = opx(lr,p.z,.1);\n\n    float li = getI(p.xy-vec2(.05,0));\n    tn=min(li,tn);\n    float ti = opx(li,p.z,.1);\n\n    float ld = getD(p.xy-vec2(.40,0));\n    tn=min(ld,tn);\n    float td = opx(ld,p.z,.1);\n\n    float le = getE(p.xy-vec2(.72,0));\n    tn=min(le,tn);\n    float te = opx(le,p.z,.1);\n\n    tn = abs(tn)-.02;\n    float tx = opx(tn,p.z,.075);\n    \n    float pr = min(tp,tr);\n    float id = min(ti,td);\n    float pride = min(te,id);\n    pride=min(pr,pride);\n    \n    if(pride<res.x){\n        res = vec2(pride,1.);\n        hit=p;\n    }\n    if(tx<res.x){\n        res = vec2(tx,3.);\n        hit=p;\n    }\n    float flr =q.z+2.5;\n    if(flr<res.x) {\n        res = vec2(flr,2.);\n    \thit=q;\n    }  \n\n    return res;\n}\n\nvec3 normal(vec3 p, float t, float mindist){\n    t*=mindist;\n    float d = map(p).x;\n    vec2 e = vec2(t,0);\n    \n    vec3 n = d-vec3(\n        map(p-e.xyy).x,\n        map(p-e.yxy).x,\n        map(p-e.yyx).x\n    );\n    return normalize(n);\n}\n\n//@iq of hsv2rgb\nvec3 hsv2rgb( in vec3 c ) {\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat scale = 3.5;\nvec3 shade(vec3 p, vec3 rd, float d, float m, inout vec3 n){\n    n = normal(p,d,1.);\n  \n    vec3 lpos = vec3(2,9,7);\n    vec3 l = normalize(lpos-p);\n    float diff = clamp(dot(n,l),0.,1.);\n    vec3 h=vec3(0.05);\n    \n    if(m==2.) {\n        vec2 uv =hitPoint.xy;\n        uv-=T*vec2(.05,.2);\n\n        vec2 id = floor(uv*scale);\n        uv = fract(uv*scale)-.5;\n\n        float hs = hash21(id+floor(T*8.));\n        vec3 hue = 0.5 + 0.5*cos(hs+vec3(0,1,2)-id.xyx*.2);\n        float px = 1.5*scale/R.x;\n\n        float d = box(uv,vec2(.3))-.125;\n        d = smoothstep(px,-px,d);\n\n        h = mix (vec3(.01),hue,d);\n    }\n    \n    if(m==3.) h = hsv2rgb(vec3(p.x*.5,1.,.5));\n    \n    return diff*h;\n}\n\nvec3 renderFull(vec2 uv)\n{\n    //precal\n    rtR=rot(0.38397243543);\n      \n    vec3 C=vec3(.0);\n    vec3 ro = vec3(0,0,1.45),\n         rd = normalize(vec3(uv,-1));\n         \n    // mouse //\n    float x = M.xy==vec2(0) ? .18 : -(M.y/R.y*1.-.5)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*1.-.5)*PI;\n    \n    rx =rot(x); ry =rot(y);\n    mat2 mx =rot(.1*sin(T*.2)); mat2 my =rot(.075*cos(-T*.15));\n    \n    ro.zy*=mx;rd.zy*=mx;\n    ro.xz*=my;rd.xz*=my;\n    \n    vec3  p = ro + rd * .1;\n    float atten = 1.;\n    float k = 1.;\n    float iv= 1.;\n    \n    // loop inspired/adapted from @blackle's \n    // marcher https://www.shadertoy.com/view/flsGDH\n    // a lot of these settings are tweaked for this scene \n    for(int i=0;i<120;i++)\n    {\n        vec2 ray = map(p);\n        vec3 n = vec3(0);\n        float d = i<32? ray.x*.7:ray.x*.9;\n        float m = ray.y;\n        p += rd*d*k;\n        \n        //set current hit point\n        hitPoint=hit;\n        \n        if (d*d < 1e-8) {\n            C+=shade(p,rd,d,ray.y,n)*atten;\n            if(m==2.) break;\n            \n            atten *= .65;\n            p += rd*.01;\n            k = sign(map(p).x);\n\n            //@Drakyen - refraction math\n            vec3 rf=refract(rd,n,iv > 0. ? 1./1.1 : 1.1);\n            iv *= -1.;\n            if(length(rf) == 0.) rf = reflect(rd,n);\n            rd=rf;\n            p+=-n*.01;\n\n        }\n\n        if(distance(p,rd)>50.) { break; }\n    }\n\n    return clamp(C,vec3(0),vec3(1)); \n}\n\n// Thank you @tdhooper for AA/Motion Blur help \nfloat vmul(vec2 v) {return v.x * v.y;}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) { \n\n    vec3 col = vec3(.00); \n    float mTime = iTime;\n    time = mTime;    \n    \n    vec2 o = vec2(0);\n\n    // AA and motion blur from @iq https://www.shadertoy.com/view/3lsSzf\n    #ifdef AA\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n    \t// pixel coordinates\n    \to = vec2(float(m),float(n)) / float(AA) - 0.5;\n    \t// time coordinate (motion blurred, shutter=0.5)\n    \tfloat d = 0.5*vmul(sin(mod(fragCoord.xy * vec2(147,131), vec2(PI * 2.))));\n    \ttime = mTime - 0.1*(1.0/24.0)*(float(m*AA+n)+d)/float(AA*AA-1);\n    #endif\n\t\t\n        //time = mod(time, 1.);\n    \tvec2 p = (-iResolution.xy + 2. * (fragCoord + o)) / iResolution.x;\n    \tcol += renderFull(p);\n        \n    #ifdef AA\n    }\n    col /= float(AA*AA);\n    #endif\n\n    col = pow( col, vec3(0.4545) );\n    fragColor = vec4(col, 0);\n}", "image_inputs": [{"id": 29092, "src": "https://soundcloud.com/whothefuckisdrewg/aretha-frankin-cc-music-factory-pride-a-deeper-love-drewg-2018-remix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsdczf.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[583, 583, 605, 605, 664], [665, 665, 683, 683, 727], [729, 729, 748, 748, 780], [781, 781, 807, 807, 886], [887, 887, 925, 925, 1083], [1084, 1084, 1118, 1118, 1198], [1199, 1199, 1244, 1244, 1401], [1402, 1419, 1439, 1439, 1607], [1624, 1624, 1644, 1644, 1961], [1962, 1962, 1982, 1982, 2040], [2041, 2041, 2061, 2061, 2223], [2224, 2224, 2244, 2244, 2450], [2451, 2469, 2518, 2518, 2614], [2667, 2667, 2685, 2685, 3663], [3665, 3665, 3709, 3709, 3904], [3906, 3923, 3950, 3950, 4076], [4097, 4097, 4157, 4157, 4790], [4792, 4792, 4818, 4831, 6261], [6263, 6311, 6331, 6331, 6349]], "test": "untested"}
{"id": "sd3czs", "name": "Pixel Staff Generator 2", "author": "SnoopethDuckDuck", "description": "The first one doesn't load for some reason - click reset or wait 4 seconds\n\nHere's a messier but maybe nicer looking version:\nhttps://www.shadertoy.com/view/7scczf", "tags": ["feedback", "cellularautomata"], "likes": 15, "viewed": 637, "published": 3, "date": "1653943198", "time_retrieved": "2024-07-30T16:46:14.574343", "image_code": "#define pi 3.14159\n\nvec3 pal(float t, vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\n// Notes:\n// This is a bit ad hoc, will do colors properly later\n\n// Detailing = gold bits where col.r == 1. in buffer A\n// Interior = brown bits where col.r == 0. in buffer A\n// Outline = outline\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Zoom + coords + flipped coords etc.\n    float zm = 0.225; \n    vec2 res = 0.5 * floor( iResolution.xy);    \n    vec2 f = fragCoord;\n    vec2 f2 = vec2(abs(f.x - res.x) + res.x, f.y);\n    \n    vec4 col = texelFetch( iChannel0, ivec2(zm * f2 + (1.-zm) * res), 0);\n\n    \n    // Hide green\n    col.g *= col.r;\n    \n    // Only show blue above threshold\n    col.b *= step(thb, col.b);\n\n    // Is col == 0? Used for background\n    float s = step(col.r + col.g + col.b, 0.);\n         \n    // Set outline color (gets changed)\n    if (col.a == 1.)\n        col.rgb = vec3(0.1);\n    \n    // Darken left interior + detailing\n    if (f.x < res.x && col.a == 0. && col.rgb != vec3(1))\n        col *= 0.625;\n    \n    // Remove blues on the detailing\n    if (col.r > 0.)\n        col.b = 0.;\n    // Replace interior with another color\n    else if (col.rgb != vec3(1))\n        col.rgb = 0.44 * vec3(1,1,0.5) * col.bbb;\n    \n    // Add a red-ish color to detailing + outline\n    col.rgb += 1.5 * col.r * pal(0.45, 0.5 * vec3(0,1,2)/3.);\n    \n    // Lighten interior + outline\n    col.rgb += (1.-col.r) * vec3(0.15,0.075,0.15);\n    \n    // White background \n    col.rgb = mix(col.rgb, vec3(0.98), s * (1.-col.a));\n    \n    // Lighten right outline\n    if (f.x > res.x && col.a == 1.)\n        col.rgb /= 0.625;\n\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Dimensions of staff (change me)\n#define w 16.\n#define h 36.\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    col = vec4(0);\n\n    ivec2 px = ivec2(f);\n    int fr = int(2. * max(w, h));\n    int maxFr = fr + 240;\n    int frame = iFrame % maxFr;\n    \n    // \"random\" value from texture, used for green \"texture\"\n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel1, g, 0).r;\n    \n    vec2 res = floor(0.5 * iResolution.xy);\n    \n    // Centre abs coords, used for checking dimensions etc.\n    vec2 v = abs(f - res - 0.5);\n    \n    if (frame == 0) {   \n        col.a = 0.;\n        \n        // Pole for reds to traverse from\n        if (v.x < 1. && v.y <= h)\n            col.r = 1.;\n        \n        // Pixel for greens to expand from\n        if (v.x < 1. && v.y < 1.)\n            col.g = 1.;\n            \n        return;\n    }\n           \n    // Center cell\n    col = cell(px);\n    \n    // Neighbour cells\n    vec4 b = cell(px - ivec2(0,1));\n    vec4 t = cell(px + ivec2(0,1));\n    vec4 l = cell(px - ivec2(1,0));\n    vec4 r = cell(px + ivec2(1,0));   \n    vec4 bl = cell(px + ivec2(-1,-1));\n    vec4 br = cell(px + ivec2(1, -1));\n    vec4 tl = cell(px + ivec2(-1, 1));\n    vec4 tr = cell(px + ivec2(1,  1));   \n    \n    vec4 sum = b + t + l + r + bl + br + tl + tr;\n    vec4 dif = abs(b-t) * abs(l-r);\n\n    // Traversal threshold [0,1], lower value -> more pixels\n    float th = 0.5;\n    \n    if (frame < fr) {\n        // Clamp to bounds\n        if (v.x > w || v.y > h)\n            col.g = 0.;\n        // Expand greens\n        else if (col.g == 0. && rand >= th && abs(sum.g-1.) <= 0.5)\n            col.g = (rand - th) / (1.-th);\n        // I don't think this does much\n        else if (abs(dif.g - sum.g) < 0.5) \n            col.g = 0.;\n            \n        // Traverse greens with red\n        if (sum.r > 0. && col.g > 0.55)\n            col.r = 1.;\n    }\n    else {  \n        if (frame == fr) {\n            // Can do this here, or in Image\n            col.g *= col.r;\n             \n            // Outline the blues in alpha channel\n            // Alpha pushes back against the blues when blues expand\n            if (step(thb, col.b) == 0. && step(thb, t.b) + step(thb, r.b) + step(thb, l.b) + step(thb, b.b) > 0.)\n                col.a = 1.;\n            else\n                col.a = 0.;\n        }\n        else if (frame == fr + 100) {\n            // Shift everything to remove red bar + make thinner\n            col = r; //mix(col, r, 0.75);\n            \n            // Guarantee a pole so it doesn't disconnect\n            if (v.x < 1. && v.y < h && col.b < th)\n                col.b = 1.;\n            \n            // Remove isolated reds (not perfect)\n            if (col.r == 1. && col.g == 0.) // or col.r = 0.;\n                col.g = 1.;\n        }\n        else if (frame == fr + 100 + 1) { \n            // Make an outline for col.a:\n            // col.a = 0. everywhere\n            // col.a = 1. where col.b < threshold and blue neighbours > thr\n            col.a = 0.;\n            \n            float s = step(thb, t.b) + step(thb, b.b) + step(thb, l.b) + step(thb, r.b);\n            if (col.b < thb && s > 0.)\n                col.a = 1.;\n        }      \n    }  \n    \n    \n    // Expand outwards from reds so blue channel can provide outline\n    \n    // Original idea was: \n    // -> expand blues from reds\n    // -> set some alpha values to 1 at fr + N \n    // -> alphas expand inwards from that \"outline\"\n    // -> remove alphas from blues, \"pressure\" from alpha and blue expansions\n    //    makes blue > thb where the staff outline will be\n    \n    // Currently: \n    // alpha \"outline\" happens at fr, still pushes inwards and mostly works\n    // idk\n    \n    if (frame < fr + 100) {\n        if (sum.r > 0.)\n            col.b = sum.r / 8.;\n        else\n           col.b = 0. * sum.b / 8.;    \n               \n        if (col.a < 1. && col.r < 1.)\n            col.a = sum.a / 8.;\n                \n        col.b -= col.a;   \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Blue threshold. Used for expanding away from shape and choosing a \"distance\"\n// to draw a boundary at <- allegedly\n#define thb 0.08\n\n// Buffer A:\n// Greens expand into a texture\n// Reds traverse that texture to provide detailing (yellow parts)\n// Blues expand away from the reds to provide a mask sort of thing\n// Alphas provide an outline based on the blue mask\n\n// Image:\n// Recolors stuff from buffer A\n\n\n\n\n// Todo:\n// Use more colors\n// Maybe split fragCoord into a grid, draw many at the same time\n// Remove spiky outlines\n// Shade from bottom to top\n// Lighten bits which touch the outline from below\n// Remove dark inner colors which touch the outline\n// Cut a bit out for a handle?\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3czs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 102], [302, 302, 359, 359, 1751]], "test": "untested"}
{"id": "fddyRs", "name": "pseudo-vectorization of video", "author": "FabriceNeyret2", "description": "Purpose is to display an image \"as if\" vectorized at low resolution.\nvariant of https://shadertoy.com/view/NddyRl", "tags": ["short", "marchingsquare", "marchingcube", "vectorization"], "likes": 20, "viewed": 416, "published": 3, "date": "1653939426", "time_retrieved": "2024-07-30T16:46:15.447009", "image_code": "// variant of https://shadertoy.com/view/NddyRl\n\n#define s    textureSize(iChannel0,0)\n#define T(U) texelFetch(iChannel0, ivec2(U), lod).r  // texture access\n#define S(v) smoothstep( -.8,.8,(v)/fwidth(v) )      // antialiasing draw\n\nfloat vector(vec2 u, int lod, float thresh)\n{\n    float Z = exp2(float(lod));                      // scaling\n    vec2  R = iResolution.xy, v,\n          U = u/Z;\n    float O = 0.;                                    // --- marching cube -------\n    vec4 c = vec4( T(U)          , T(U+vec2(1,0)),   // value at corners\n                   T(U+vec2(0,1)), T(U+vec2(1,1)) ), \n         b = step(thresh,c);                         // is > threshold ?\n    int  n = int(b.x+b.y+b.z+b.w);                   // number of yes\n    U = fract(U);                                    // tile local coordinates\n    if      (n==0) O += 0.;                          // empty\n    else if (n==4) O += 1.;                          // full\n    else if (n==1 || n==3 || n==2 && b.x==b.w ) {    // corner + checker case \n        if (n==3) b = 1.-b;  \n        if(b.x>0.) O += S( (1.-U.x-U.y)*c.x +   U.x   *c.y +   U.y   *c.z - thresh );\n        if(b.y>0.) O += S( (  U.x -U.y)*c.y + (1.-U.x)*c.x +   U.y   *c.w - thresh );\n        if(b.z>0.) O += S( (-U.x+ U.y )*c.z +   U.x   *c.w + (1.-U.y)*c.x - thresh );\n        if(b.w>0.) O += S( (U.x+U.y-1.)*c.w + (1.-U.x)*c.z + (1.-U.y)*c.y - thresh );\n    } else { // n==2                                      // (checker treated above)\n        if      (b.x==b.y) v = (thresh-c.xy)/(c.zw-c.xy), // horizontal\n                           O += S( U.y - mix(v.x,v.y,U.x) );\n        else if (b.x==b.z) v = (thresh-c.xz)/(c.yw-c.xz), // vertical\n                           O += S( U.x - mix(v.x,v.y,U.y) );\n        if (b.x>0.) O = 1.-O;\n    }\n    return O;\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{   U *= 360./iResolution.y;\n    O = vec4( vector(U,4,.3) + vector(U,4,.5) + vector(U,4,.7) ) / 3.;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddyRs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 233, 278, 278, 1802], [1804, 1804, 1842, 1842, 1942]], "test": "untested"}
{"id": "NddyRl", "name": "marching squares on texture", "author": "FabriceNeyret2", "description": "mouse.x shows the full res texture.\nPurpose is to display an image \"as if\" vectorized at low resolution.", "tags": ["short", "marchingcubes", "marchingsquares", "vectorization"], "likes": 16, "viewed": 521, "published": 3, "date": "1653938425", "time_retrieved": "2024-07-30T16:46:16.271804", "image_code": "int      lod = 5;\nfloat thresh = .4;\n\n#define s    textureSize(iChannel0,0)\n#define T(U) texelFetch(iChannel0, ivec2(U) %(s>>lod), lod).r // texture access\n#define S(v) smoothstep( -.8,.8,(v)/fwidth(v) )      // antialiasing draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{   //u*=2.;\n    float Z = exp2(float(lod)),                      // scaling\n          t = floor(30.*iTime);                      // animation\n    u += t;\n    vec2  R = iResolution.xy, v,\n          U = u/Z,\n          V = mod(u-.5,Z);\n    if (V.x*V.y==0.) { O = vec4(.5); return; }       // grid\n\n    if ( iMouse.x > u.x-t ) {                        // mouse.x show ref\n        O = vec4( texelFetch(iChannel0,ivec2(u+Z/2.) %s,0).r > thresh ,\n                  T(U+.5) > thresh , 0,1);\n        return;\n    }\n    O-=O;                                            // --- marching cube -------\n    vec4 c = vec4( T(U)          , T(U+vec2(1,0)),   // value at corners\n                   T(U+vec2(0,1)), T(U+vec2(1,1)) ), \n         b = step(thresh,c);                         // is > threshold ?\n    int  n = int(b.x+b.y+b.z+b.w);                   // number of yes\n    U = fract(U);                                    // tile local coordinates\n    if      (n==0) O += .3;                          // empty ( for test )\n    else if (n==4) O += 1.;                          // full\n    else if (n==1 || n==3 || n==2 && b.x==b.w ) {    // corner + checker case \n        if (n==3) b = 1.-b;  \n        if(b.x>0.) O += S( (1.-U.x-U.y)*c.x +   U.x   *c.y +   U.y   *c.z - thresh );\n        if(b.y>0.) O += S( (  U.x -U.y)*c.y + (1.-U.x)*c.x +   U.y   *c.w - thresh );\n        if(b.z>0.) O += S( (-U.x+ U.y )*c.z +   U.x   *c.w + (1.-U.y)*c.x - thresh );\n        if(b.w>0.) O += S( (U.x+U.y-1.)*c.w + (1.-U.x)*c.z + (1.-U.y)*c.y - thresh );\n    } else { // n==2                                      // (checker treated above)\n        if      (b.x==b.y) v = (thresh-c.xy)/(c.zw-c.xy), // horizontal\n                           O += S( U.y - mix(v.x,v.y,U.x) );\n        else if (b.x==b.z) v = (thresh-c.xz)/(c.yw-c.xz), // vertical\n                           O += S( U.x - mix(v.x,v.y,U.y) );\n        if (b.x>0.) O = 1.-O;\n    }\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 231, 269, 280, 2180]], "test": "untested"}
{"id": "Nddyzl", "name": "PerfTest dot(a,a) VS length(a)", "author": "gehtsiegarnixan", "description": "A quick performance test designed to tank your FPS to see which operation is faster.\nDot is faster than length. \nHere is a reddit thread on the matter ([url]https://www.reddit.com/r/computergraphics/comments/v15agr[/url])", "tags": ["test", "performance", "speed"], "likes": 1, "viewed": 161, "published": 3, "date": "1653935637", "time_retrieved": "2024-07-30T16:46:17.019804", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // center screen coords  \n    vec2 uv = (fragCoord.xy- (0.5*iResolution.xy))/iResolution.y;\n    \n    vec2 subject = uv * 8. *  (sin(iTime * 0.5)+2.); //some arbitrary motion\n    \n    // if you get around 144 fps use a higher repeat value\n    int repeat = 1; //10 000 is enough for RTX2070\n    float test;\n    for(int i=0; i<repeat; i++)\n    {\n        vec2 a = subject + float(i); //permutation each iteration\n        \n        // use which ever you wish to test\n        float x = dot(a,a); //95fps\n        //float x = length(a); //60fps\n        \n        test += x; // each iteration adds to final image\n    }\n        \n    // Output to screen\n    fragColor = vec4(fract(test));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nddyzl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 86, 738]], "test": "untested"}
{"id": "fdtyRl", "name": "BLOSSOMS TO BLOOM Animation", "author": "NEAR_DREAM_UNITY", "description": "WORK IN PROGRESS -- An simple animation to accompany a music track I made.", "tags": ["sunset", "animation"], "likes": 2, "viewed": 230, "published": 3, "date": "1653925532", "time_retrieved": "2024-07-30T16:46:17.843601", "image_code": "/* Logo:\n\n                NEAR DREAM UNITY\n\n          fascination and joy, with you\n*/\n\n\n#define  AASS           3.//was 5\n#define  NOISE_FADE     0.25\n#define  PULSE          cos(iTime * 0.5)\n#define  NDULOGO_FADE   (0.02 * (1. - PULSE))\n#define  NDULOGO_ZOOM   (0.7 - 0.2 * PULSE)\n#define  SCENE_ZOOM     (0.9 + 0.1 * PULSE)\n\n#define  SSET_UPWARD    0.3\n#define  SSET_HEIGHT    0.1\n#define  SSET_C_SKY     (vec3(0.38, 0.30, 0.48) * 0.8)\n#define  SSET_C_CYAN    vec3(0., 0.7, 0.7)\n#define  SSET_CYAN_R    1.8\n#define  SSET_CYAN_Q    1.6\n#define  SSET_C_RED     vec3(2., -0.35, -0.5)\n#define  SSET_RED_R     0.85\n#define  SSET_RED_Q     1.8\n#define  SSET_C_GOLD    vec3(0., 0.35, 0.1)\n#define  SSET_GOLD_R    0.45\n#define  SSET_GOLD_Q    1.2\n#define  SSET_C_SUN     1.5\n#define  SSET_SUN_R     0.15\n#define  SSET_SUN_Q     2.8\n#define  SSET_YDARK     0.15\n\n#define  SSET_C_GROUND  vec3(0.2, 0.3, 0.2)\n\n#define  SSET_C_BDNG    vec3(0.8, 0.6, 0.4)\n#define  SSET_C_WINDOW  vec3(0., 0.8, 0.6)\n\n\n\nvec4  Building  (vec2 p, vec2 corner1, vec2 corner2, ivec2 windows) {\n    vec2 bp = (p - corner1) / (corner2 - corner1);\n    if (bp.x >= 0. && bp.y >= 0. && bp.x <= 1. && bp.y <= 1.) {\n        ivec2 wslots = windows * 2 + ivec2(1, 2);\n        ivec2 wloc = ivec2(floor(bp * vec2(wslots)));\n        vec3 c = ((wloc.x & 1) == 1 && (wloc.y & 1) == 0 && wloc.y != 0) ? SSET_C_WINDOW : SSET_C_BDNG;\n        return vec4(c, 1.);\n    } else return vec4(0.);\n}\n\n\nvec3  Sky  (vec2 sun_p) {\n    float d = length(sun_p);\n    // Add on radial gradients from the outside in:\n    vec3 c = SSET_C_SKY;  // Ambient sky colour.\n    #define ADDRADGRAD(C, R, Q) \\\n        c += C * pow(1. - min(1., d * (1. / R)), Q)\n    ADDRADGRAD(SSET_C_CYAN,  SSET_CYAN_R,  SSET_CYAN_Q);\n    ADDRADGRAD(SSET_C_RED,   SSET_RED_R,   SSET_RED_Q);\n    ADDRADGRAD(SSET_C_GOLD,  SSET_GOLD_R,  SSET_GOLD_Q);\n    ADDRADGRAD(SSET_C_SUN,   SSET_SUN_R,   SSET_SUN_Q);\n    c -= sun_p.y * SSET_YDARK;\n    return c;\n}\n\n\nvec3  Ground  (vec2 sun_p) {\n    return SSET_C_GROUND\n        + 0.1\n        - pow(-sun_p.y, 1.5) * 0.4\n        - dot(sun_p, sun_p) * 0.05;\n}\n\n\nvec3  SunsetScene  (vec2 p) {\n    p.y += SSET_UPWARD;  // Shift view upwards.\n    vec2 sun_p = p - vec2(0., SSET_HEIGHT);\n    vec3 c = (p.y > 0.) ? Sky(sun_p) : Ground(sun_p);\n    \n    #define BUILD(N, X1, X2, Y1, Y2, WX, WY) \\\n        vec4 bN_c = Building(p, vec2(X1, Y1), vec2(X2, Y2), ivec2(WX, WY)); \\\n        if (bN_c.w != 0.) c = bN_c.xyz\n    //BUILD(1, -1.2, -0.4, -0.1, 0.2, 3, 3);\n    \n    return c;\n}\n\n\nbool  OneSquare  (vec2 moved, float size) {\n    float hlt = 17. / 32.;\n    return (\n        moved.x >= -hlt           &&\n        moved.y >= -hlt           &&\n        moved.x <= size + hlt     &&\n        moved.y <= size + hlt     && (\n            moved.x < hlt         ||\n            moved.y < hlt         ||\n            moved.x > size - hlt  ||\n            moved.y > size - hlt  ));\n}\n\n\nbool  NDULogo  (vec2 p) {\n    vec2 zoom = p * 17.;\n    vec2 tilt = vec2(zoom.x * 15. - zoom.y * 8., zoom.y * 17.) / 15.;\n    return (\n        OneSquare(tilt - vec2(0.,    -8.),   8.)  ||\n        OneSquare(tilt - vec2(-4.,   -12.),  4.)  ||\n        OneSquare(tilt - vec2(8.,    0.),    4.)  ||\n        OneSquare(tilt - vec2(8.,    -12.),  4.)  ||\n        OneSquare(tilt - vec2(0.,    8.),    4.)  ||\n        OneSquare(tilt - vec2(-12.,  -4.),   4.)  ||\n        OneSquare(tilt - vec2(-12.,  8.),    4.)  ||\n        OneSquare(tilt - vec2(-8.,   0.),    8.)  );\n}\n\n\nvec3  Composition  (vec2 p) {\n    vec3 c = vec3(0.);\n    c += SunsetScene(p * SCENE_ZOOM);\n    c += NDULogo(p * NDULOGO_ZOOM) ? NDULOGO_FADE : 0.;\n    return c;\n}\n\n\nvoid  mainImage  (out vec4 fragColor, vec2 fragCoord) {\n\n    #define AASS_RECIP (1. / AASS)\n    #define AASS_SQ (AASS * AASS)\n    vec3 accum = vec3(0.);\n    float resmin = min(iResolution.x, iResolution.y);\n    for (float aax = 0.5; aax < AASS; ++aax)\n    for (float aay = 0.5; aay < AASS; ++aay) {\n        vec2 aacoord = fragCoord + vec2(aax, aay) * AASS_RECIP - 0.5;\n        accum += Composition((aacoord * 2. - iResolution.xy) / resmin);\n    }\n    accum /= AASS_SQ;\n\n    float noise_p =\n        9.87654321 * fragCoord.x +\n        8.79546213 * fragCoord.y +\n        7913.84625 * fract(iTime * 0.123456789);\n    float noise_q =\n        6.93582471 * fragCoord.x +\n        5.26841397 * fragCoord.y +\n        4175.28639 * fract(iTime * 0.321654987);\n    float noise_v = fract(sin(noise_p) * 1024.) - fract(sin(noise_q) * 1024.);\n    vec3 noise_c = sin(noise_v * vec3(123456., 456789., 789123.));\n    accum += noise_c * NOISE_FADE;\n\n    fragColor = vec4(accum, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[992, 992, 1061, 1061, 1442], [1445, 1445, 1470, 1470, 1959], [1962, 1962, 1990, 1990, 2102], [2105, 2105, 2134, 2134, 2515], [2518, 2518, 2561, 2561, 2902], [2905, 2905, 2930, 2930, 3464], [3467, 3467, 3496, 3496, 3629], [3632, 3632, 3687, 3687, 4596]], "test": "untested"}
{"id": "ssdXzB", "name": "Mercury_LPA", "author": "LabutinPavel", "description": "Mercury", "tags": ["visuals"], "likes": 0, "viewed": 168, "published": 3, "date": "1653918607", "time_retrieved": "2024-07-30T16:46:18.683356", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (true) {\n        vec2 uv = fragCoord / iResolution.xy;\n        uv.x = min(uv.x, 1. - uv.x);\n        uv.y = min(uv.y, 1. - uv.y);\n\n\n        float m = 0.0015;\n        float k = 20.0;\n        float e = 0.5;\n\n        float s = 0.;\n        for (int i=0;i<30;i++) {\n            vec4 sxy = texelFetch(iChannel0, ivec2(i, 0), 0);\n            float d = pow(distance(uv, sxy.xy) * m, e) * k;\n            s += smoothstep(0.3, 0.001, d);\n        }\n\n        // s = s * s * s;\n        \n        fragColor = vec4(\n            smoothstep(0., 1.0, s * 10.),\n            smoothstep(0., 1.0, s),\n            smoothstep(0., 1.0, s * .2),\n            //smoothstep(1.0, 2.0, s), \n            //smoothstep(0.1, 0.2, s), \n            // smoothstep(1.1, 3.0, s), \n            // smoothstep(1.3, 0.7, s), \n            1.);\n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord / 16.), 0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.y > 10.) \n        return;\n    float t = iTime * .005 + 111.1111;\n    vec2 uv = fragCoord / iResolution.xy;\n    ivec2 xy = ivec2(fragCoord);\n    float a =      sin(0.3 + t * 3. * fragCoord.x + t * uv.x * 1000.0) \n            + 2. * cos(t * 5. * fragCoord.x + t * uv.x * 0.7);\n    float b = 2. * sin(1.7 + t * 7. * fragCoord.x + 0.3 + t * uv.x * 0.1) \n                 + cos(t * 9. * fragCoord.x + 0.7 + t * uv.x * 0.7);\n    // fragColor = vec4((a  + 3.) / 6., (b + 3.0) / 6., 0., 0.);\n    fragColor = vec4((a  + 3.) / 8., (b + 3.0) / 8., 0., 0.);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdXzB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 951]], "test": "untested"}
{"id": "fdcyzs", "name": "Fork super simp Arrangemon 611", "author": "Arrangemonk", "description": "really fucken simple liquid warp like in quake or whatever , i forked that and played around with it and now its jiggly and disgusting", "tags": ["liquid"], "likes": 4, "viewed": 393, "published": 3, "date": "1653905678", "time_retrieved": "2024-07-30T16:46:19.771448", "image_code": "// set up constants, effects ripple behaviour\nfloat violence = 0.02;\nfloat levelOfExtreme = 5.0;\n\n// function warp x or y coordinate based on time and sin that shit\nfloat warp( float a , float timescale)\n{\n    return sin( (timescale * iTime + a) * levelOfExtreme ) * violence;\n}\n\n// main thing\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xx);\n  \n    //uv = uv * 3.;\n    \n    uv += 19.2 * vec2(warp(uv.y *.0122,0.012),warp(uv.x * .0122,0.012));\n    \n    uv -= vec2(warp(uv.y,1.),warp(uv.x,1.));\n    \n    uv +=0.2333* vec2(warp(uv.y *2.05,1.433),warp(uv.x *2.05,1.433));\n    uv +=0.12666* vec2(warp(uv.y *4.01222,2.355),warp(uv.x *4.01222,2.355));\n    \n    vec2 t =  uv + 0.01 * texture(iChannel0, uv + iTime*.02).xy; \n    \n\tfragColor = texture(iChannel1, t);\n}", "image_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyzs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 165, 205, 205, 278], [280, 294, 351, 351, 815]], "test": "untested"}
{"id": "fs3yRl", "name": "Cymatics Simulation", "author": "wyatt", "description": "sand simulated on a wave equation. takes a really long time to converge to what you might see on real steel plate with sand. (use low resolution and speed up 16x)", "tags": ["wave", "cymatics"], "likes": 21, "viewed": 938, "published": 3, "date": "1653885470", "time_retrieved": "2024-07-30T16:46:20.520444", "image_code": "\nMain\n    \n    vec4 b = B(U);\n    vec4 a = A(b.xy);\n    Q = vec4(1)*exp(-2.*length(U-a.xy));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n\n#define pi 3.14159265359\n\nfloat building(vec2 U) {\n    \n    if (length(U-vec2(.8,.5)*R)<.15*R.x) return 1.;\n    \n    if (length(U-vec2(.2,.5)*R)<.15*R.x) return 1.;\n    \n    return 0.;\n\n}", "buffer_a_code": "Main\n    \n    Q = A(U);\n    vec4 d = D(U);\n    vec4 c = C(Q.xy);\n    vec2 f = vec2(0,0);\n    \n    for (float x = -1.; x <= 1.; x ++) \n    for (float y = -1.; y <= 1.; y ++)\n    if (x!=0.||y!=0.) {\n        vec4 c = C(Q.xy+vec2(x,y));\n        f -= .1*c.y*vec2(x,y)/(x*x+y*y);\n    }\n    Q.zw += f-.1*Q.zw;\n    Q.xy += .5*f+Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (Q.y<1.) Q.y=1., Q.w *= -1.;\n    if (Q.x<1.) Q.x=1., Q.z *= -1.;\n    if (R.y-Q.y<1.) Q.y=R.y-1., Q.w *= -1.;\n    if (R.x-Q.x<1.) Q.x=R.x-1., Q.z *= -1.;\n\n    //if (M.z>0.) Q.zw -= 1e-3*(M.xy-Q.xy)/(1.+length((M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U,0,0);\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void XY (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.xy).xy)<length(U-A(Q.xy).xy)) Q.xy = q.xy;\n}\nvoid ZW (vec2 U, inout vec4 Q, vec4 q) {\n    if (length(U-A(q.zw).xy)<length(U-A(Q.zw).xy)) Q.zw = q.zw;\n}\nMain\n    Q = B(U);\n    for (int x=-1;x<=1;x++)\n    for (int y=-1;y<=1;y++) {\n        XY(U,Q,B(U+vec2(x,y)));\n    }\n    \n    if (I%12==0) \n        Q.zw = U;\n    else\n    {\n        float k = exp2(float(11-(I%12)));\n        ZW(U,Q,B(U+vec2(0,k)));\n        ZW(U,Q,B(U+vec2(k,0)));\n        ZW(U,Q,B(U-vec2(0,k)));\n        ZW(U,Q,B(U-vec2(k,0)));\n    }\n    XY(U,Q,Q.zwxy);\n    \n    if (I<1) Q = vec4(U,U);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n\n    vec4 n = C(U+vec2(0,1));\n    vec4 e = C(U+vec2(1,0));\n    vec4 s = C(U-vec2(0,1));\n    vec4 w = C(U-vec2(1,0));\n    vec4 m = 0.25*(n+e+s+w);\n    Q = C(U);\n    Q.x += m.y-Q.y;\n    Q.y += Q.x;\n    if (length(U-.5*R)<1.)\n        Q.y = \n            sin(19.*float(iFrame)/R.y)+\n            sin(19.*float(iFrame)/R.y);\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main\n\n    vec4 n = C(U+vec2(0,1));\n    vec4 e = C(U+vec2(1,0));\n    vec4 s = C(U-vec2(0,1));\n    vec4 w = C(U-vec2(1,0));\n    vec4 m = 0.25*(n+e+s+w);\n    Q = C(U);\n    Q.x += m.y-Q.y;\n    Q.y += Q.x;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3yRl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Nsdyzf", "name": "Some pbr", "author": "kaylent", "description": "Fixed version of pbr implementation (old: https://www.shadertoy.com/view/7djBDh)\nFixes: extra shadowing was removed, ao was replaced by ao+so, shadow algorithm was changed.\nGGX brdf + point light + env probe + ao + so + bent normals + volume selfshadowing", "tags": ["pbr"], "likes": 13, "viewed": 525, "published": 3, "date": "1653850831", "time_retrieved": "2024-07-30T16:46:21.532738", "image_code": "//minus: texture is convoluted for diff part from -Pi/2 to Pi/2. It`s better to use horizon.\n\n#define PI 3.1415926535897932384626433832795\n#define heightCoef 5.\nconst float lightSourceRadius = 0.05*heightCoef;\n\nconst float convKernel[] = float[]\n(\n    0.00291502, 0.0130642, 0.0215393, 0.0130642, 0.00291502, \n    0.0130642, 0.0585498, 0.0965324, 0.0585498, 0.0130642, \n    0.0215393, 0.0965324, 0.159155, 0.0965324, 0.0215393, \n    0.0130642, 0.0585498, 0.0965324, 0.0585498, 0.0130642, \n    0.00291502, 0.0130642, 0.0215393, 0.0130642, 0.00291502 \n);\n\nconst vec3 albedo = vec3(0.7,0.7,0.8);\nconst float metallic = 0.7;\nconst float roughness = 0.1;\nconst float lightStrength = 3.*heightCoef*heightCoef;\n\nvec3 lightPosition = vec3(0.,0.,0.);\n\n\nvec3 Lo_Env(const vec3 N, const vec3 V, const vec3 H, const vec2 texCoord);\nvec3 Lo_DL(const vec3 N, const vec3 V, const vec3 L, const vec3 H);\nfloat getSelfShadows(const vec2 fragCoord);\nvec3 bentNormal(const vec2 texCoords, const vec3 normal);\nvec3 orientToVector(const vec3 toVector, const vec3 vector);\nvec3 convolultedEnvMap(const vec3 normal);\nfloat specularAOExperiment(vec2 texCoord, vec3 L, vec3 V);\nvec3 animateLightPoint();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float xzFragCoordToWorld = heightCoef/iResolution.y;\n    lightPosition = vec3(iMouse.x*xzFragCoordToWorld, heightCoef, iMouse.y*xzFragCoordToWorld);\n    if (iMouse.x == 0.)\n    {\n        lightPosition = animateLightPoint();\n    }\n    vec3 cameraPosition = vec3(0.5*iResolution.x*xzFragCoordToWorld, heightCoef, 0.5*iResolution.y*xzFragCoordToWorld);   \n    vec2 uv = fragCoord/iResolution.y*2.;\n    vec3 pixelPosition = vec3(fragCoord.x*xzFragCoordToWorld,  (texture(iChannel0, uv).x - 1.)*heightCoef, fragCoord.y*xzFragCoordToWorld);\n    vec3 L = normalize(lightPosition - pixelPosition );\n    vec3 V = normalize(cameraPosition - pixelPosition );\n    float shadowMultiplier = getSelfShadows(fragCoord);\n    \n    /////////////////////////////////////////////////\n    ////calculate normal/////////////////////////////\n    /////////////////////////////////////////////////\n    vec3 vector1;\n    vec3 vector2;\n    float deltaHeight;\n    float stepUv = 1./512.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x, uv.y+stepUv)).x - texture(iChannel0, vec2(uv.x, uv.y-stepUv)) ).x * heightCoef;\n    vector1.x = 0.;\n    vector1.y = deltaHeight;\n    vector1.z = 1.;\n    \n    deltaHeight = ( texture(iChannel0, vec2(uv.x+stepUv, uv.y)).x - texture(iChannel0, vec2(uv.x-stepUv, uv.y)) ).x * heightCoef;\n    vector2.x = 1.;\n    vector2.y = deltaHeight;\n    vector2.z = 0.;\n    \n    vec3 N = normalize(cross(vector1, vector2));\n    \n    //////////////////////////////////////////////\n    ////PBR///////////////////////////////////////\n    //////////////////////////////////////////////\n    vec4 lightColor = vec4(1., 1., 1., 1.)*lightStrength;\n    float gamma = 2.2f;\n    \n    vec3 H = normalize(L + V);\n    \n    float lightDistance = distance(lightPosition, pixelPosition);\n    float attenuation = 1./pow(lightDistance-lightSourceRadius, 2.);\n    vec3 radiance = lightColor.xyz*attenuation;\n    \n    float NdotL = max(dot(N, L), 0.);\n    vec3 Lo = Lo_Env(N, V, H, uv); //bent to diff\n    Lo+=Lo_DL(N, V, L, H)*radiance*NdotL*shadowMultiplier;\n    \n    fragColor = vec4(Lo , 1.);\n    \n    fragColor.xyz = pow(fragColor.xyz, vec3(1./gamma));\n    \n    if (distance(lightPosition.xz/xzFragCoordToWorld, fragCoord.xy) < 3.)\n        fragColor = vec4(1., 0.,0.,1.); \n}\n\n    \n//////////////////////////////////////////////\n////IBL///////////////////////////////////////\n//////////////////////////////////////////////\n\nvec3 fresnelSchlick_IBL(float cosTheta, vec3 F0){\n    return F0 + (max(vec3(1. - roughness), F0) - F0) * pow(1. - cosTheta, 5.);\n}\n\nfloat DistributionGGX_IBL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.);\n    float a2 = pow(a, 2.);\n    float NdotH = max(dot(N, H), 0.);\n    float NdotH2 = pow(NdotH, 2.);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.) + 1.);\n    denom = PI * pow(denom, 2.);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_IBL(float NdotV, float roughness){\n    float r = (roughness);\n    float k = sqrt((r*r)*2.);\n    \n    float nom   = NdotV;\n    float denom = NdotV * (1. - k) + k;\n    \n    return nom / denom;\n}\n\nfloat GeometrySmith_IBL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.);\n    float NdotL = max(dot(N, L), 0.);\n    float ggx2 = GeometrySchlickGGX_IBL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_IBL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\n\nfloat RadicalInverse_VdC(uint bits)\n{\n    bits = (bits << 16u) | (bits >> 16u);\n    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n    return float(bits) * 2.3283064365386963e-10;\n}\n\nvec2 Hammersley(uint i, uint N)\n{\n    return vec2(float(i)/float(N), RadicalInverse_VdC(i));\n}\n\nvec3 ImportanceSampleGGX_IBL(vec2 Xi, vec3 N)\n{\n    float a = roughness*roughness;\n\t\n    float phi = 2. * PI * Xi.x;\n    float sinTheta = a*sqrt(Xi.y)/sqrt(1.-Xi.y);\n    float cosTheta = sqrt(1. - sinTheta*sinTheta);\n\t\t\n    vec3 H;\n    H.x = cos(phi) * sinTheta;\n    H.y = cosTheta;\n    H.z = sin(phi) * sinTheta;\n    \n    return normalize(orientToVector(N, H));\n}  \n\nvec3 getFilteredEnvironmentMap(vec3 N, vec3 V)\n{\n    const uint SAMPLE_COUNT = 32u;\n    float totalWeight = 0.;\n    vec3 prefilteredColor = vec3(0.);\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N);\n        vec3 L  = normalize(2. * dot(V, H) * H - V);\n        \n        float NdotL = max(dot(N, L), 0.);\n        if(NdotL > 0.)\n        {\n            prefilteredColor += texture(iChannel1, L).rgb * NdotL;\n            totalWeight      += NdotL;\n        }\n    }\n    prefilteredColor = prefilteredColor / totalWeight;\n    \n    return prefilteredColor;\n}\n\nvec2 IntegrateBRDF(float NdotV)\n{\n    vec3 V;\n    V.x = sqrt(1. - NdotV*NdotV);\n    V.y = NdotV;\n    V.z = 0.;\n    \n    float A = 0.;\n    float B = 0.;\n    \n    vec3 N = vec3(0., 1., 0.);\n    \n    const uint SAMPLE_COUNT = 32u;\n    for(uint i = 0u; i < SAMPLE_COUNT; ++i)\n    {\n        vec2 Xi = Hammersley(i, SAMPLE_COUNT);\n        vec3 H  = ImportanceSampleGGX_IBL(Xi, N);\n        vec3 L  = normalize(2. * dot(V, H) * H - V);\n        \n        float NdotL = max(L.y, 0.);\n        float NdotH = max(H.y, 0.);\n        float VdotH = max(dot(V, H), 0.);\n        \n        if(NdotL > 0.)\n        {\n            float G = GeometrySmith_IBL(N, V, L, roughness);\n            float G_Vis = (G * VdotH) / (NdotH * NdotV);\n            float Fc = pow(1. - VdotH, 5.);\n            \n            A += (1. - Fc) * G_Vis;\n            B += Fc * G_Vis;\n        }\n    }\n    A /= float(SAMPLE_COUNT);\n    B /= float(SAMPLE_COUNT);\n    return vec2(A, B);\n}\n\nvec3 Lo_Env(const vec3 N, const vec3 V, const vec3 H, const vec2 texCoord){\n    vec3 F0 = vec3(0.04, 0.04, 0.04);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_IBL(max(dot(N, V), 0.), F0);\n    vec2 envBRDF = IntegrateBRDF(dot(N, V));\n    vec3 prefilteredColor = getFilteredEnvironmentMap(N, V);\n    vec3 specular = prefilteredColor * (F0 * envBRDF.x + envBRDF.y);\n    \n    vec3 kD = vec3(1.) - F;\n    kD *= 1.0f - metallic;\n    vec3 bentN = bentNormal(texCoord, N);\n    vec3 irradiance = convolultedEnvMap(bentN);\n    vec3 ambient = kD * irradiance * albedo;\n    \n    vec3 fr = length(bentN)*ambient/PI + clamp(pow(dot(V, H)+length(bentN), 2.) - 1. + length(bentN), 0.,1.)*specular;\n    return fr;\n}\n\nvec3 fresnelSchlick_DL(float cosTheta, vec3 F0){\n    return F0 + (1. - F0) * pow(1. - cosTheta, 5.);\n}\n\nfloat DistributionGGX_DL(vec3 N, vec3 H, float roughness){\n    float a = pow(roughness, 2.);\n    float a2 = pow(a, 2.);\n    float NdotH = max(dot(N, H), 0.);\n    float NdotH2 = pow(NdotH, 2.);\n    \n    float num = a2;\n    float denom = (NdotH2 * (a2 - 1.) + 1.);\n    denom = PI * pow(denom, 2.);\n    \n    return num / denom;\n}\n\nfloat GeometrySchlickGGX_DL(float NdotV, float roughness){\n    float r = (roughness);\n    float k = pow((r+1.), 2.)/8.;\n    \n    float num = NdotV;\n    float denom = NdotV * (1. - k) + k;\n    \n    return num / denom;\n}\n\nfloat GeometrySmith_DL(vec3 N, vec3 V, vec3 L, float roughness){\n    float NdotV = max(dot(N, V), 0.);\n    float NdotL = max(dot(N, L), 0.);\n    float ggx2 = GeometrySchlickGGX_DL(NdotV, roughness);\n    float ggx1 = GeometrySchlickGGX_DL(NdotL, roughness);\n    \n    return ggx1 * ggx2;\n}\n\nvec3 Lo_DL(const vec3 N, const vec3 V, const vec3 L, const vec3 H)\n{\n    vec3 F0 = vec3(0.04, 0.04, 0.04);\n    F0 = mix(F0, albedo, metallic);\n    vec3 F = fresnelSchlick_DL(max(dot(H, V), 0.0f), F0);\n    float NDF = DistributionGGX_DL(N, H, roughness);\n    float G = GeometrySmith_DL(N, V, L, roughness);\n    \n    vec3 numerator = NDF*F*G;\n    float denominator = 4. * max(dot(N, V), 0.) * max (dot(N, L), 0.) + 0.001;\n    vec3 specular = numerator / denominator;\n    \n    vec3 kS = F;\n    vec3 kD = vec3(1.) - kS;\n    kD *= 1. - metallic;\n    \n    vec3 fr = kD*albedo/PI + specular;\n    \n    return fr;\n}\n\nvec3 orientToVector(const vec3 toVector, const vec3 vector)\n{\n    vec3 up        = abs(toVector.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    vec3 tangent   = normalize(cross(up, toVector));\n    vec3 bitangent = cross(toVector, tangent);\n\t\n    return tangent * vector.x + bitangent * vector.z + toVector * vector.y;\n}\n\nfloat getSelfShadows(const vec2 fragCoord) //minus - depends on screen size\n{\n    float accum = 0.;\n    for (int x = -2; x < 3; ++x)\n    {\n        for (int y = -2; y < 3; ++y)\n        {\n            vec2 uv = vec2(fragCoord.x + float(x), fragCoord.y + float(y))/iResolution.xy;\n            accum += texture(iChannel2, uv).x*convKernel[x+2 + (y+2)*5]; // 5x5 conv kernel\n        }\n    }\n    return accum;\n}\n\nvec3 bentNormal(const vec2 texCoords, const vec3 N)\n{\n    const uint numRotateSteps = 16u;\n    const uint numRaySteps = 8u;\n    const float maxTexCoordDistance = 0.05;\n    const float rotateStep = 2.*PI/float(numRotateSteps);\n    \n    float fragmentHeight = (texture(iChannel0, texCoords).x - 1.)*heightCoef;\n    \n    vec3 bentNormal = vec3(0.);\n    for (uint theta = 0u; theta<numRotateSteps/4u; ++theta)\n    {\n        for(uint phi = 0u; phi<numRotateSteps; ++phi)\n        {\n            vec3 pRandVecDir;\n            pRandVecDir.y = cos(rotateStep*float(theta));            \n            float xzFactor = sin(rotateStep*float(theta));\n            pRandVecDir.x = cos(rotateStep*float(phi))*xzFactor;\n            pRandVecDir.z = sin(rotateStep*float(phi))*xzFactor;\n            pRandVecDir = orientToVector(N, pRandVecDir);\n            \n            vec3 stepRay = pRandVecDir/float(numRaySteps)*maxTexCoordDistance/xzFactor;\n            vec3 ray = stepRay;\n            \n            bool isOccluded = false;\n            uint step = 1u;\n            for (; step < numRaySteps+1u; ++step)\n            {\n                if ((texture(iChannel0, texCoords+ray.xz).x - 1.)*heightCoef > fragmentHeight + stepRay.y)\n                {\n                    break;\n                }\n                ray += stepRay;\n            }\n           \n            bentNormal+=((float(step)/float(numRaySteps)))*pRandVecDir*pRandVecDir*sin(rotateStep*float(theta))*cos(rotateStep*float(theta))*PI/(float(numRotateSteps/4u*numRotateSteps));\n        }\n    }\n    return bentNormal;\n}\n\nvec3 convolultedEnvMap(const vec3 N)\n{\n    const uint numRotateSteps = 20u;\n    const float rotateStep = 2.*PI/float(numRotateSteps);\n    vec3 convColor = vec3(0.);\n    \n    for (uint theta = 0u; theta<numRotateSteps/4u; ++theta)\n    {\n        for(uint phi = 0u; phi<numRotateSteps; ++phi)\n        {\n            vec3 pRandVecDir;\n            pRandVecDir.y = cos(rotateStep*float(theta));\n            float xzFactor = sin(rotateStep*float(theta));\n            pRandVecDir.x = cos(rotateStep*float(phi))*xzFactor;\n            pRandVecDir.z = sin(rotateStep*float(phi))*xzFactor;\n            pRandVecDir = orientToVector(N, pRandVecDir);\n            \n            convColor += texture(iChannel1, pRandVecDir).xyz*sin(rotateStep*float(theta))*cos(rotateStep*float(theta))*PI*PI/(float(numRotateSteps/4u*numRotateSteps)); \n        }\n    }\n    return convColor;\n}\n\nvec3 animateLightPoint()\n{\n    vec3 pointPos1 = vec3(0.);\n    pointPos1.y = heightCoef;\n    float modulo = mod(iTime, 2.*PI);\n    pointPos1.x = ((cos(modulo + PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n    pointPos1.z = ((sin(modulo + PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n\n    vec3 pointPos2 = vec3(0.);\n    pointPos2.y = heightCoef;\n    modulo = mod(iTime, 2.*PI);\n    pointPos2.x = ((cos(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1 + iResolution.x/iResolution.y - 1.)*heightCoef;\n    pointPos2.z = ((sin(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1)*heightCoef;\n    \n    vec3 pointPos = vec3(0.);\n    pointPos = mix(pointPos1, pointPos2, (cos(mod(iTime, 2.*PI) + PI/2.)+1.)/2.);\n    \n    return pointPos;\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926535897932384626433832795\n#define lightSourceRadius 0.05\n#define heightCoef 5.\n\nconst vec3 lightApprx[16] = vec3[]\n(\n    vec3(0.551047, 0.766867, 0.329033), vec3(0.40481, 0.903168, -0.142888), \n    vec3(0.544277, 0.804168, 0.238905), vec3(-0.900311, 0.0365544, -0.43371), \n    vec3(0.526163, 0.0951804, -0.84504), vec3(0.928479, 0.362623, 0.0802011), \n    vec3(-0.371819, 0.287964, -0.882512), vec3(0.079554, 0.54282, 0.836073), \n    vec3(-0.320073, 0.842607, -0.433089), vec3(-0.958668, 0.261276, -0.112653), \n    vec3(-0.670151, 0.674361, -0.310056), vec3(0.309392, 0.420734, -0.852795), \n    vec3(-0.955604, 0.0966579, 0.27835), vec3(0.684154, 0.286764, 0.670597), \n    vec3(0.60757, 0.772842, 0.183232), vec3(0.393977, 0.563268, 0.726299)\n);\n\nconst float lightApprxNoise[4] = float[](1.804289383, 0.846930886, 0.424238335, 3.044897763);\n\nvec3 orientToVector(vec3 toVector, vec3 vector)\n{\n    vec3 up        = abs(toVector.y) < 0.999 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);\n    vec3 tangent   = normalize(cross(up, toVector));\n    vec3 bitangent = cross(toVector, tangent);\n\t\n    return tangent * vector.x + bitangent * vector.z + toVector * vector.y;\n}\n\nvec3 rotateAlongY(const float angle, const vec3 vector)\n{\n    mat3 rotM;\n    float cosa = cos(angle);\n    float sina = sin(angle);\n    rotM[0] = vec3(cosa, 0., -sina);\n\n    rotM[1] = vec3(0., 1., 0.);\n\n    rotM[2] = vec3(sina, 0., cosa);\n                    \n    return rotM*vector;\n}\n\nfloat isShadowed(const vec2 pixelPos, vec3 toLight)\n{ \n    toLight.y += heightCoef - texture(iChannel0, pixelPos).x*heightCoef;\n    float alignFactor = dot(vec3(0.,1.,0.), normalize(toLight));\n    const float minNumSteps = 32.;\n    const float maxNumSteps = 64.;\n    uint numSteps = uint(mix(maxNumSteps, minNumSteps, abs(alignFactor)));\n    vec3 stepRay = toLight/float(numSteps)*((heightCoef - heightCoef*texture(iChannel0, pixelPos).x)/toLight.y); //no sense to check it over 0\n    \n    vec3 ray = stepRay;\n    ray.y -= heightCoef - texture(iChannel0, pixelPos).x*heightCoef;\n    for (uint i = 0u; i < numSteps; ++i)\n    {\n        float currHeight = heightCoef*texture(iChannel0, pixelPos+ray.xz).x - heightCoef;\n        if (currHeight > ray.y)\n            return 1.;\n        ray += stepRay;\n    }    \n    \n    return 0.;\n}\n\nfloat getSelfShadow(const vec2 texCoord, const vec3 lightPos, const vec3 pixelPosition, const vec2 fragCoord)\n{\n    float shadowMultiplier = 1.;\n    for (uint i = 0u; i < 16u; ++i)\n    {       \n        vec3 noisedLightApprx = rotateAlongY(lightApprxNoise[int(fragCoord.x)%2 + 2*int(fragCoord.y)%2],  lightApprx[i]);\n        vec3 lightPoint = orientToVector(normalize(vec3(-1.,0.,0.)), noisedLightApprx*lightSourceRadius);\n        shadowMultiplier -= isShadowed(texCoord, lightPos + lightPoint - pixelPosition)/16.;        \n    }\n    \n    return shadowMultiplier;\n}\n\nvec3 lightPosition = vec3(0.,0.,0.);\n\nvec3 animateLightPoint();\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPosition = vec3(iMouse.x/iResolution.y, 1.0f, iMouse.y/iResolution.y);\n    if (iMouse.x == 0.)\n    {\n        lightPosition = animateLightPoint();\n    }\n    vec2 uv = fragCoord/iResolution.y*2.;   \n    vec3 pixelPosition = vec3(fragCoord.x/iResolution.y, 0., fragCoord.y/iResolution.y);\n    float shadowMultiplier = getSelfShadow(uv, lightPosition, pixelPosition, fragCoord);\n    fragColor = vec4(shadowMultiplier, 0., 0., 0.);\n}\n\nvec3 animateLightPoint()\n{\n    float xzFragCoordToWorld = heightCoef/iResolution.y;\n    vec3 pointPos1 = vec3(0.);\n    pointPos1.y = 1.;\n    float modulo = mod(iTime, 2.*PI);\n    pointPos1.x = ((cos(modulo + PI/2.) + 1.)/2.*0.8 + 0.1);\n    pointPos1.z = ((sin(modulo + PI/2.) + 1.)/2.*0.8 + 0.1);\n\n    vec3 pointPos2 = vec3(0.);\n    pointPos2.y = 1.;\n    modulo = mod(iTime, 2.*PI);\n    pointPos2.x = ((cos(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1 + iResolution.x/iResolution.y - 1.);\n    pointPos2.z = ((sin(-modulo - PI/2.) + 1.)/2.*0.8 + 0.1);\n    \n    vec3 pointPos = vec3(0.);\n    pointPos = mix(pointPos1, pointPos2, (cos(mod(iTime, 2.*PI) + PI/2.)+1.)/2.);\n    \n    return pointPos;\n}", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsdyzf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1180, 1180, 1237, 1237, 3496], [3645, 3645, 3694, 3694, 3775], [3777, 3777, 3836, 3836, 4104], [4106, 4106, 4165, 4165, 4323], [4325, 4325, 4390, 4390, 4615], [4618, 4618, 4655, 4655, 5036], [5038, 5038, 5071, 5071, 5132], [5134, 5134, 5181, 5181, 5498], [5502, 5502, 5550, 5550, 6148], [6150, 6150, 6183, 6183, 7083], [7085, 7085, 7160, 7160, 7802], [7804, 7804, 7852, 7852, 7906], [7908, 7908, 7966, 7966, 8234], [8236, 8236, 8294, 8294, 8454], [8456, 8456, 8520, 8520, 8743], [8745, 8745, 8813, 8813, 9351], [9353, 9353, 9414, 9414, 9684], [9686, 9686, 9763, 9763, 10090]], "test": "untested"}
{"id": "Nl3GWN", "name": "Dark room", "author": "z0rg", "description": "Room", "tags": ["dark", "room"], "likes": 11, "viewed": 351, "published": 3, "date": "1653837661", "time_retrieved": "2024-07-30T16:46:22.462253", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(0.,f*factor);\n        if (nuv.y > 0. && nuv.y < 1.)\n            col += texture(iChannel0, uv+vec2(0.,f*factor)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+GLOW_OPACITY*pow(col, vec3(GLOW_POW));\n    //rgb += 2.*vec3(0.,.25,.3)*sat(sin(uv.y*355.-iTime*200.)-.5);\n\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nfloat seed;\nfloat rand()\n{\n    seed++;\n    return hash11(seed);\n}\n\nmat2 r2d(float a) { float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n    vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n    vec3 u = normalize(cross(rd, r));\n    return normalize(rd+r*uv.x+u*uv.y);\n}\nfloat _sqr(vec2 p, vec2 s)\n{\n    vec2 l = abs(p)-s;\n    return max(l.x, l.y);\n}\nvec2 _min(vec2 a, vec2 b)\n{\n    if (a.x < b.x)\n        return a;\n    return b;\n}\n\nvec2 map(vec3 p)\n{\n    vec2 acc = vec2(10000.,-1.);\n    \n    //acc = _min(acc, vec2(length(p-vec3(sin(iTime*2.)-.5,cos(iTime*1.7)+cos(iTime*.5)*.5,cos(iTime*3.)+8.))-.5, 2.));\n    \n    acc = _min(acc, vec2(-(abs(p.y)-2.8), 0.));\n    vec3 pwall = p;\n    //pwall.xy*=r2d(.5);\n    float sidewall = -(abs(p.y+p.x)-3.8);\n    \n    sidewall = max(sidewall, -(abs(p.z-3.5)-1.));\n    acc = _min(acc, vec2(sidewall, 0.)); // Sidewalls\n    acc = _min(acc, vec2(-(abs(p.z)-12.), 1.));\n    \n    return acc;\n}\n\nvec3 getNorm(vec3 p, float d)\n{\n    vec2 e = vec2(0.01,0.);\n    return normalize(vec3(d)-\n        vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n    vec3 p = ro;\n    for (int i = 0; i < steps; ++i)\n    {\n        vec2 res = map(p);\n        if (res.x < 0.01)\n            return vec3(res.x, distance(p, ro), res.y);\n        p+= rd*res.x;\n    }\n    return vec3(-1.);\n}\n\nvec3 getMat(vec3 rd, vec3 res, vec3 p, vec3 n)\n{\n    vec3 col = vec3(0.);\n    \n    col = n*.5+.5;\n    if (res.z == 0.)\n    {\n        if (abs(dot(n,vec3(0.,0.,1.))) < 0.01)\n        {\n            col = vec3(0.051,0.404,0.408)*.2*pow(texture(iChannel0, p.xz*.1).x, .1)*vec3(.5); // ambient\n        }\n        else\n            col = vec3(0.);\n    }\n    if (res.z == 1.)\n    {\n        vec2 uvwall = p.xy;\n        float rep = 3.;\n        float idwin = floor((uvwall.x+rep*.5)/rep);\n        uvwall.y = abs(uvwall.y);\n        uvwall.y -= 1.8;\n        uvwall.x = mod(uvwall.x+rep*.5,rep)-rep*.5;\n        float sqr = _sqr(uvwall, vec2(1.4, .78));\n        float wincolfactor = sat(sin(idwin*1.+3.*iTime*sign(p.y))*.5+.5);\n        //wincolfactor += pow(FFT(.1),2.);\n        wincolfactor *= (mod(iTime, .2)/.2)*FFT(.1);\n        vec3 rgbwin = mix(vec3(1.), vec3(1.,0.1,0.4), wincolfactor);\n        col = mix(vec3(0.), rgbwin*pow(FFT(.9),.5), 1.-sat(sqr*40.));\n    }\n    if (res.z == 2.)\n    {\n        col = vec3(0.165,0.996,0.678)*10.*FFT(.4);\n    }\n    \n    return col;\n}\nfloat getKeyPress(int keycode)\n{\n    return texelFetch( iChannel1, ivec2(keycode,1),0 ).x;\n}\nfloat getKeyState(int keycode)\n{\n    return texelFetch( iChannel1, ivec2(keycode,0),0 ).x;\n}\nfloat getWallSpec(vec3 p)\n{\n    return pow(texture(iChannel0, p.xz*.1).x, .1);\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-2.+sin(iTime*.2),1.+sin(iTime*.25),-8.);\n    vec3 ta = vec3(-2.+sin(iTime*.2),0.+sin(iTime*.3),0.);\n    vec3 rd = normalize(ta-ro);\n    rd = getCam(rd, uv);\n    \n    vec3 res = trace(ro, rd, 128);\n    if (res.y > 0.)\n    {\n        vec3 p = ro+rd*res.y;\n        vec3 n = getNorm(p, res.x);\n        col = getMat(rd, res, p, n);\n        \n        if (res.z == 0.)\n        {\n            if (abs(dot(n,vec3(0.,0.,1.))) < 0.01)\n            {\n                float spec = pow(texture(iChannel0, p.xz*.1).x, 1.)*.2;\n                vec3 refl = normalize(reflect(rd, n)+spec*2.*(vec3(rand(), rand(), rand())-.5));\n                vec3 resrefl = trace(p+n*0.01, refl, 128);\n                if (resrefl.y > 0.)\n                {\n                    vec3 prefl = p+refl*resrefl.y;\n                    vec3 nrefl = getNorm(prefl, resrefl.x);\n                    col += getMat(refl, resrefl, prefl, nrefl);\n                }\n            }\n        }\n        \n    }\n    if (getKeyState(KEY_LEFT) > .1)\n    col *= sat(sin(iTime*80.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.xx;\n    seed=texture(iChannel0,uv).x;\n    seed+=fract(iTime);\n    vec3 col = rdr(uv);\n    \n    col = mix(col, texture(iChannel2, fragCoord/iResolution.xy).xyz, .7);\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30380, "src": "https://soundcloud.com/recharge/recharge-operate-psyclotron?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    const int steps = GLOW_SAMPLES;\n    vec3 col = vec3(0.);\n    \n    for (int i = 0; i< steps; ++i)\n    {\n        float f = float(i)/float(steps);\n        f = (f -.5)*2.;\n        float factor = GLOW_DISTANCE;\n        vec2 nuv = uv+vec2(f*factor, 0.);\n        if (nuv.x > 0. && nuv.x < 1.)\n          col += texture(iChannel0, uv+vec2(f*factor,0.)).xyz/float(steps);\n    }\n    \n    vec3 rgb = texture(iChannel1, uv).xyz+2.*pow(col, vec3(GLOW_POW));\n    fragColor = vec4(col,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define GLOW_SAMPLES 40\n#define GLOW_DISTANCE 0.05\n#define GLOW_POW 1.\n#define GLOW_OPACITY 1.5\n\nconst int KEY_LEFT  = 37;\n\n#define sat(a) clamp(a, 0., 1.)\n#define FFT(a) (texture(iChannel3, vec2(a, 0.)).x*.5+.5)\nfloat hash11(float p)\n{\n// Stolen from https://www.shadertoy.com/view/ss3SD8\n    return (fract(sin((p)*114.514)*1919.810));\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl3GWN.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[397, 397, 454, 454, 1055]], "test": "untested"}
{"id": "fdtyRX", "name": "2 - Loop from periodic function", "author": "kampta", "description": "Following https://bleuje.github.io/tutorial2/", "tags": ["periodic", "basics"], "likes": 3, "viewed": 225, "published": 3, "date": "1653834216", "time_retrieved": "2024-07-30T16:46:23.303005", "image_code": "#define PI 3.14159265359\n\nconst float m = 35.;\n\nbool inCircle(vec2 ctr, float r, vec2 p)\n{\n    vec2 vec = ctr - p;\n    return length(vec) < r;\n}\n\nvec3 colCircle(vec2 ctr, float r, vec2 p)\n{\n    // Time varying pixel color\n    vec3 pNorm = p.xyx / iResolution.xyx;\n    vec3 col = inCircle(ctr, r, p) ? vec3(0.) : 0.5+ 0.5*cos(iTime+pNorm+vec3(0,2,4));\n    return col;\n}\n\n\nfloat map(float value, float min1, float max1, float min2, float max2)\n{\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nfloat periodicFunction(float p)\n{\n  return map(sin(2.*PI*p),-1.,1.,2.,5.);\n}\n\nfloat offset(vec2 p)\n{\n  vec2 ctr = 0.5*iResolution.xy;\n  vec2 vec = ctr - p;\n  return 0.01*length(vec);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{    \n    // find closest circle center\n    vec2 ctr = vec2(\n        round(map(fragCoord.x, 0., iResolution.x-1., 0., m-1.)), \n        round(map(fragCoord.y, 0., iResolution.y-1., 0., m-1.))\n    );\n    ctr.x = map(ctr.x, 0., m-1., 0., iResolution.x-1.);\n    ctr.y = map(ctr.y, 0., m-1., 0., iResolution.y-1.);\n    \n    // calculate radius\n    float r_pt = periodicFunction(iTime-offset(ctr));\n\n    // Output to screen\n    fragColor = vec4(colCircle(ctr, r_pt, fragCoord.xy), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 90, 90, 144], [146, 146, 189, 221, 368], [371, 371, 443, 443, 509], [511, 511, 544, 544, 587], [589, 589, 611, 611, 695], [697, 697, 753, 791, 1233]], "test": "untested"}
{"id": "Nsdyzj", "name": "1 - Point doing a circular loop", "author": "kampta", "description": "Point doing a circular loop", "tags": ["basics"], "likes": 0, "viewed": 177, "published": 3, "date": "1653827147", "time_retrieved": "2024-07-30T16:46:24.073944", "image_code": "bool inCircle(vec2 ctr, float r, vec2 uv) {\n    vec2 vec = ctr - uv;\n    return length(vec*iResolution.xy) < r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // center and radius of circle\n    vec2 ctr = 0.5*iResolution.xy;\n    float r_circ = 100.;\n    \n    ctr = (ctr + r_circ*vec2(cos(2.*3.14*iTime), sin(2.*3.14*iTime)))/iResolution.xy;\n    \n    // radius of point\n    float r_pt = 20.;\n\n    // Time varying pixel color\n    vec3 col = inCircle(ctr, r_pt, uv) ? vec3(0.) : 0.5+ 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    // position of pixel\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsdyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 113], [115, 115, 172, 222, 711]], "test": "untested"}
{"id": "7dcyRX", "name": " intertwined torii", "author": "FabriceNeyret2", "description": "( still some glitches in the solver )\nmouse controls camera\nreference: https://www.facebook.com/gianni.sarcone/videos/506922401137887/\n( oops, wireframe don't perfectly fit at end)\n( relies on Shane's quadric solver https://www.shadertoy.com/view/XsGyDh )", "tags": ["raytracing", "torus", "short", "reproduction"], "likes": 21, "viewed": 560, "published": 3, "date": "1653816531", "time_retrieved": "2024-07-30T16:46:24.908712", "image_code": "// relies on Shane's quadric solver https://www.shadertoy.com/view/XsGyDh\n// ( see Common )\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation   \n\nfloat draw( vec3 p, vec3 A, vec2 r) { // ---- pattern upon the torus   \n    vec3 Ay = normalize(cross(vec3(1,0,0),A)), Ax = cross(A,Ay); // torus frame\n    vec2 U;\n    U.y = atan( dot(p,A) ,  ( dot(p,p) - dot(r,r) ) * .5/r.x );\n     // or   asin ( \"/r2 ) or  acos( \"/r2 )  * sign\n    p -= dot(p,A) *A; \n    U.x  = atan(dot(p,Ax), dot(p,Ay) );\n    U = sin( vec2(20,10)*U );\n    U = max(1.- abs(U)/fwidth(U), 0.);\n    return max(U.x,U.y);\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          P = 60./R,                                      // camera position \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(25,10,0)/1e2*cos(.5*iTime+vec3(0,11,0)); // auto thumbnail\n    \n    P.yz *= rot(-6.*M.y),                                 // rotations\n    P.xz *= rot(-6.*M.x);\n    D.yz *= rot(-6.*M.y),                           \n    D.xz *= rot(-6.*M.x);\n    float r0 = 2.5 + 1.5*sin(iTime);                      // [1,4]\n    vec3 C[] = vec3[]( vec3(10.-r0, 0, 0), -vec3(10.-r0, 0, 0), vec3(0,0,0) ),\n         A[] = vec3[]( vec3(0,.7,.7), vec3(0,.7,-.7), vec3(0,1,0) );\n    vec2 r[] = vec2[]( vec2(10,r0),vec2(10,r0),vec2(10,10.-2.*r0) );\n    O-=O; vec4 dist;      \n    float d = 1e4, l;                                     // opaque draw\n    l = closest( torus (P,D,C[0],A[0],r[0], dist), dist); \n    if ( l < d )  d = l, O = vec4(.6-draw(P+d*D-C[0],A[0],r[0]));\n    l = closest( torus (P,D,C[1],A[1],r[1], dist), dist); \n    if ( l < d )  d = l, O = vec4(.6-draw(P+d*D-C[1],A[1],r[1]));\n               \n                                                          // wireframe draw\n    bvec4 hit = torus (P,D,vec3(0),A[2],r[2], dist);\n    if (hit.x && dist.x < d ) O = mix(O, vec4(1 ), draw(P+dist.x*D,A[2],r[2]) );\n    if (hit.y && dist.y < d ) O = mix(O, vec4(.3), draw(P+dist.y*D,A[2],r[2]) );\n    if (hit.z && dist.z < d ) O = mix(O, vec4(1 ), draw(P+dist.z*D,A[2],r[2]) );\n    if (hit.w && dist.w < d ) O = mix(O, vec4(.3), draw(P+dist.w*D,A[2],r[2]) );\n\n     \n    O = sqrt(O);                                          // to sRGB\n}\n", "image_inputs": [], "common_code": "//switch  Shane / IQ\n   #define torus(p,d,c,n,r,S) ShaneTorus(p,d,c,n,r, S) // best of 3 in wyatt bench\n// #define torus(p,d,c,n,r,S)    IqTorus(p,d,c,n,r, S) // not better, but shorter !\n\n// naive P4 solver is too instable in float: https://www.shadertoy.com/view/fsdyzj\n//  better solutions:\n// from Shane https://www.shadertoy.com/view/XsGyDh\n// and wyatt bench https://www.shadertoy.com/view/XddfW7\n// WIP: adapt mla more robust version: https://www.shadertoy.com/view/Nd3cRs\n\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n    float p = coeffs.y / 2.;\n    float D = p*p - coeffs.x;\n    if (D <= 0.) return 0;\n    else {\n        roots = vec2(-1, 1)*sqrt(D) - p;\n        return 2;\n    }\n}\nint solve_cubic(vec3 coeffs, inout vec3 r){\n    float a = coeffs[2];\n    float b = coeffs[1];\n    float c = coeffs[0];\n    float p = b - a*a/3.;\n    float q = a * (2.*a*a - 9.*b)/27. + c;\n    float p3 = p*p*p;\n    float d = q*q + 4.*p3/27.;\n    float offset = -a/3.;\n    if(d >= 0.0) { \n        vec2 uv = (vec2(1, -1)*sqrt(d) - q)/2.;\n        uv = uv = sign(uv)*pow(abs(uv), vec2(1./3.));\n        r[0] = offset + uv.x + uv.y;\t\n        float f = ((r[0] + a)*r[0] + b)*r[0] + c;\n        float f1 = (3.*r[0] + 2. * a)*r[0] + b;\n        r[0] -= f/f1;\n        return 1;\n    }\n    float u = sqrt(-p/3.);\n    float v = acos(-sqrt(-27./p3)*q/2.)/3.;\n    float m = cos(v), n = sin(v)*1.732050808;\n    float f,f1;\n    r[0] = offset + u * (m + m);\n    f = ((r[0] + a)*r[0] + b)*r[0] + c;\n    f1 = (3.*r[0] + 2. * a)*r[0] + b;\n    r[0] -= f / f1;\n    r[1] = offset - u * (n + m);\n    f = ((r[1] + a)*r[1] + b) * r[1] + c;\n    f1=(3.*r[1] + 2. * a)*r[1] + b;\n    r[1] -= f / f1;\n    r[2] = offset + u * (n - m);\n    f = ((r[2] + a)*r[2] + b)*r[2] + c;\n    f1 = (3.*r[2] + 2. * a)*r[2] + b;\n    r[2] -= f / f1;\n    return 3;\n}\nbvec4 solve_quartic(vec4 coeffs, inout vec4 s){\n    bvec4 broots;\n    float a = coeffs[0];\n    float b = coeffs[1];\n    float c = coeffs[2];\n    float d = coeffs[3];\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n    int num;\n    vec3 cubic_coeffs;\n    cubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n    cubic_coeffs[1] = - r;\n    cubic_coeffs[2] = - 1.0/2. * p;\n    solve_cubic(cubic_coeffs, s.xyz);\n    float z = s[0];\n    float u = z * z - r;\n    float v = 2. * z - p;\n    if(u > 0.) u = sqrt(abs(u));\n    else return bvec4(false);\n    if(v > 0.) v = sqrt(abs(v));\n    else return bvec4(false);\n    vec2 quad_coeffs;\n    quad_coeffs[0] = z - u;\n    quad_coeffs[1] = q < 0. ? -v : v;\n    num = solve_quadric(quad_coeffs, s.xy);\n    if (num == 0) broots.xy = bvec2(false);\n    if (num == 2) broots.xy = bvec2(true);\n    quad_coeffs[0] = z + u;\n    quad_coeffs[1] = q < 0. ? v : -v;\n    vec2 tmp = vec2(1e8);\n    int old_num = num;\n    num = solve_quadric(quad_coeffs, s.zw);\n    if (num == 0) broots.zw = bvec2(false);\n    if (num == 2) broots.zw = bvec2(true);\n    s -= a/4.;\n    return broots;\n}\n\n\nfloat absmin(float a, float b) {\n\treturn b>0. ? min(a,b) : a;\n}\n/* float intersect (vec4 coes) {\n    vec4 roots;\n    bvec4 br = solve_quartic(coes, roots);\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}*/\nfloat closest (bvec4 br, vec4 roots) {  // $Fab\n\tfloat i = 1e4;\n    if (br.x) i = absmin(i,roots.x);\n    if (br.y) i = absmin(i,roots.y);\n    if (br.z) i = absmin(i,roots.z);\n    if (br.w) i = absmin(i,roots.w);\n    return i;\n}\n\nbvec4 ShaneTorus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r, inout vec4 S) {\n\tfloat dn = dot(d,n);\n    float wn = dot(p-c,n);\n    vec3 s = p-c-wn*n;\n    vec3 q = d - dn*n;\n    float qq = dot(q,q);\n    float sq = dot(s,q);\n    float ss = dot(s,s);\n    float A = (dn*dn+qq)*0.5/r.x;\n    float B = (wn*dn+sq)/r.x;\n    float C = (r.x*r.x-r.y*r.y+wn*wn+ss)*0.5/r.x;\n    vec4 coes = vec4(2.*A*B,B*B+2.*A*C-qq,2.*C*B-2.*sq,C*C-ss)/(A*A);\n    return solve_quartic(coes, S);  // $Fab\n\n}\n\n// --- IQ version  https://iquilezles.org/articles/intersectors/\n\nbvec4 torIntersect( in vec3 ro, in vec3 rd, in vec2 tor, inout vec4 S )\n{\n    float po = 1.0;\n    float Ra2 = tor.x*tor.x;\n    float ra2 = tor.y*tor.y;\n    float m = dot(ro,ro);\n    float n = dot(ro,rd);\n    float k = (m + Ra2 - ra2)/2.0;\n    float k3 = n;\n    float k2 = n*n - Ra2*dot(rd.xy,rd.xy) + k;\n    float k1 = n*k - Ra2*dot(rd.xy,ro.xy);\n    float k0 = k*k - Ra2*dot(ro.xy,ro.xy);\n    \n    if( abs(k3*(k3*k3-k2)+k1) < 0.01 )\n    {\n        po = -1.0;\n        float tmp=k1; k1=k3; k3=tmp;\n        k0 = 1.0/k0;\n        k1 = k1*k0;\n        k2 = k2*k0;\n        k3 = k3*k0;\n    }\n    \n    float c2 = k2*2.0 - 3.0*k3*k3;\n    float c1 = k3*(k3*k3-k2)+k1;\n    float c0 = k3*(k3*(c2+2.0*k2)-8.0*k1)+4.0*k0;\n    c2 /= 3.0;\n    c1 *= 2.0;\n    c0 /= 3.0;\n    float Q = c2*c2 + c0;\n    float R = c2*c2*c2 - 3.0*c2*c0 + c1*c1;\n    float h = R*R - Q*Q*Q;\n    \n    if( h>=0.0 )  \n    {\n        h = sqrt(h);\n        float v = sign(R+h)*pow(abs(R+h),1.0/3.0); // cube root\n        float u = sign(R-h)*pow(abs(R-h),1.0/3.0); // cube root\n        vec2 s = vec2( (v+u)+4.0*c2, (v-u)*sqrt(3.0));\n        float y = sqrt(0.5*(length(s)+s.x));\n        float x = 0.5*s.y/y;\n        float r = 2.0*c1/(x*x+y*y);\n        float t1 =  x - r - k3; t1 = (po<0.0)?2.0/t1:t1;\n        float t2 = -x - r - k3; t2 = (po<0.0)?2.0/t2:t2;\n        float t = 1e20;\n        S = vec4(t1,t2,0,0).yxzw;                      // $Fab\n        return  bvec4(t1>0.,t2>0.,false,false).yxzw;\n/*\n        if( t1>0.0 ) t=t1;\n        if( t2>0.0 ) t=min(t,t2);\n         return t;\n*/\n    }\n    \n    float sQ = sqrt(Q);\n    float w = sQ*cos( acos(-R/(sQ*Q)) / 3.0 );\n    float d2 = -(w+c2); if( d2<0.0 ) return bvec4(false); // -1.0;\n    float d1 = sqrt(d2);\n    float h1 = sqrt(w - 2.0*c2 + c1/d1);\n    float h2 = sqrt(w - 2.0*c2 - c1/d1);\n    float t1 = -d1 - h1 - k3; t1 = (po<0.0)?2.0/t1:t1;\n    float t2 = -d1 + h1 - k3; t2 = (po<0.0)?2.0/t2:t2;\n    float t3 =  d1 - h2 - k3; t3 = (po<0.0)?2.0/t3:t3;\n    float t4 =  d1 + h2 - k3; t4 = (po<0.0)?2.0/t4:t4;\n    float t = 1e20;\n    \n    S = vec4(t1,t2,t3,t4).wzyx;                         // $Fab\n    return  bvec4(t1>0.,t2>0.,t3>0.,t4>0.).wzyx;\n/*    \n    if( t1>0.0 ) t=t1;\n    if( t2>0.0 ) t=min(t,t2);\n    if( t3>0.0 ) t=min(t,t3);\n    if( t4>0.0 ) t=min(t,t4);\n    return t;\n*/\n}\n\n#define rot3(P,A,a) ( mix( A*dot(P,A), P, cos(a) ) + sin(a)*cross(P,A) )\n\nbvec4 IqTorus (vec3 p, vec3 d, vec3 c, vec3 n, vec2 r, inout vec4 S ) {\n    p -= c; \n    float a = -acos(n.z); // rotation turning n into vec3(0,0,1)\n    if (abs(a)>1e-3) {\n        vec3  A = normalize(cross(n,vec3(0,0,1)));\n        p = rot3(p,A,a);\n        d = normalize(rot3(d,A,a));\n    }\n    return torIntersect( p, d, r, S );\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcyRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[167, 167, 204, 238, 605]], "test": "untested"}
{"id": "fscczX", "name": "fluffballs", "author": "celyk", "description": "a", "tags": ["fluffy"], "likes": 113, "viewed": 4285, "published": 3, "date": "1653804604", "time_retrieved": "2024-07-30T16:46:26.080579", "image_code": "#define R iResolution.xy\n\nconst float PI = 3.1415926;\nmat2 rot(float c){float s=sin(c);return mat2(c=cos(c),s,-s,c);}\n\n#define normal(FUNC,P,E)\\\n(\\\n    vec3(\\\n        FUNC(P+vec3(E,0,0))-FUNC(P-vec3(E,0,0)),\\\n        FUNC(P+vec3(0,E,0))-FUNC(P-vec3(0,E,0)),\\\n        FUNC(P+vec3(0,0,E))-FUNC(P-vec3(0,0,E))\\\n     )/(E*2.)\\\n)\n\nfloat map(vec3 p){\n    float d = 1e9;\n    \n    p -= (texture(iChannel0,p).xyz-.5)*.1;\n    \n    d = min(d,length(fract(p)-.5)+1.);\n    \n    p.xy = (p.xy+p.yx*vec2(-1,1))/sqrt(2.);\n    \n    p.xz = (p.xz+p.zx*vec2(-1,1))/sqrt(2.);\n    p*=.4;\n    p-=iTime*.3;\n    d = min(d,(length(fract(p)-.5))/.4);\n        \n    //d = min(d,(sdBox(fract(p-.5)-.5,vec3(.4,.5,.6))+.7)/.4);\n    \n    return d;\n}\n\nfloat trace(vec3 ro,vec3 rd){\n    vec3 p = ro;\n    float t = 0.;\n    float h = -.4;\n    for(int i=0;i<40;i++){\n        t += (map(p)+t*h)/(1.-h);\n        p = ro+rd*t;\n    }\n    return t;\n}\n\nvoid mainImage(out vec4 O,vec2 U){\n    vec2 uv = (2.*U-R)/R.y*.8;\n    vec2 m = (2.*iMouse.xy-R)/R.y*2.;\n\n    vec3 ro = vec3(sin(iTime*.2)*4.,sin(.1*iTime*1.23)*4.,-0)+iTime;\n    vec3 rd = normalize(vec3(uv,1));\n    \n    if(iMouse.z>0.){\n        rd.yz*=rot(-m.y);\n        rd.xz*=rot(-m.x);\n    }\n    \n    rd.yz*=rot(iTime*.37);\n    rd.xy*=rot(iTime*.4);\n     \n    \n    O.xyz = (rd*.5+.5)*2.;\n    \n    float t = trace(ro,rd);\n    \n    vec3 p = ro+rd*t;\n    vec3 n = normal(map,p,.15);\n    \n    O.xyz += vec3(1,2,3)*max(dot(n,normalize(vec3(0,1,0)))*.5+.5,0.)*.2;//n*.5+.5;\n    O.xyz += vec3(4,2,1)*max(dot(n,normalize(vec3(3,1,0))),0.);//n*.5+.5;\n\n\n    O.xyz += vec3(.1,.2,.3)*exp(t*.4);\n    O.xyz *= .6;O.xyz-=.4;\n    \n    O.xyz = 1. - exp(-O.xyz);\n    O.xyz = pow(O.xyz,vec3(1./2.2));\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscczX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 72, 72, 117], [326, 326, 344, 344, 715], [717, 717, 746, 746, 904], [906, 906, 940, 940, 1692]], "test": "untested"}
{"id": "NdccRX", "name": "The Panorama Projection(stars)", "author": "blackholes", "description": "A method of azimuthal orthomorphic projection.", "tags": ["texture", "sphere", "star", "projection", "stars", "ball", "orb", "photo", "image", "panorama", "bent", "move", "picture", "globe", "azimuthal", "method", "methods", "orthomorphic"], "likes": 6, "viewed": 365, "published": 3, "date": "1653797056", "time_retrieved": "2024-07-30T16:46:26.846530", "image_code": "// View settings\n\n    float CAMERA_HEIGHT = 400000000000.0; // meters\n    float sightdistance = 0.03;//meters\n\nconst int INTEGRATION_STEPS = 0;\n\n// Constants\n\nconst float PI = 3.141592653589793;\nconst float time_speed=3000.0;\n// in seconds\nconst float INF = 1e10;//1.0 / 0.0;\nconst float rotation_of_earth=86164.09;\nconst float revolution_of_earth=31558152.96;\nfloat time(){return time_speed*iTime/rotation_of_earth-0.015;}\nfloat day_time(){return time()-time_speed*iTime/revolution_of_earth;}\nfloat brightness(){return 1.0+9.5*(1.0-smoothstep(-1.0/18.0,0.0,day_time()-floor(day_time()))+smoothstep(0.5,0.5+1.0/18.0,day_time()-floor(day_time()))-smoothstep(1.0-1.0/18.0,1.0,day_time()-floor(day_time())));}\nconst float beta =PI/2.0;\nconst vec2 EMPTY_INTERVAL = vec2(INF, -INF); // interval [a,b] represented as vec2(a, b)\n\nconst float EARTH_RADIUS = 6372000.0; // meters\nconst float ATMOSPHERE_HEIGHT = 100000.0; // meters\n vec3 camera_position(){return vec3(0.0, 0.0, EARTH_RADIUS + CAMERA_HEIGHT);}\nconst vec3 SUN_EMISSION = vec3(1.0);\nconst vec3 SUN_COLOR = vec3(1,1.06,1.034);\nconst vec3 EARTH_COLOR = vec3(0.10,0.19,0.29);\n\n// Scattering & absorption settings (try to set some to zero to see how important each of them is)\n\nconst vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1) * 6.8e-7;\nconst vec3 RAYLEIGH_EXTINSION = RAYLEIGH_SCATTERING;\n\nconst vec3 MIE_ABSOPTION = vec3(4.4) * 9.5e-6;\nconst vec3 MIE_SCATTERING = vec3(2.1) * 1e-5/1.5;\nconst vec3 MIE_EXTINSION = MIE_ABSOPTION + MIE_SCATTERING;\n\nconst vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, 0.085) * 0.405e-6;\nconst vec3 OZONE_EXTINSION = OZONE_ABSORPTION;\n\nfloat rayleigh_density(float height)\n{\n    return exp(- height / 7994.0);\n}\n\nfloat mie_density(float height)\n{\n    return exp(- height / 1200.0);\n}\n\nfloat ozone_density(float height)\n{\n    return max(0.0, 1.0 - abs(height - 25000.0) / 15000.0);\n}\n\nfloat rayleigh_phase(float c)\n{\n    return (1.0 + c * c) * (3.0 / 16.0 / PI);\n}\n\nfloat mie_phase(float c)\n{\n    float g = 0.76;\n    return (3.0 / 8.0 / PI) * (1.0 - g * g) * (1.0 + c * c) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * c, 1.5);\n}\n\n// Math helpers\n\nvec2 interval_intersection(vec2 i1, vec2 i2)\n{\n    return vec2(max(i1.x, i2.x), min(i1.y, i2.y));\n}\n\nbool empty(vec2 i)\n{\n    return i.x > i.y;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    float D = b * b - 4.0 * a * c;\n    if (D < 0.0)\n        return vec2(INF, INF);\n    D = sqrt(D);\n        \n    float x1, x2;\n    if (b >= 0.0)\n    {\n        x1 = (- b - D) / 2.0 / a;\n        x2 = 2.0 * c / (- b - D);\n    }\n    else\n    {\n        x1 = 2.0 * c / (- b + D);\n        x2 = (- b + D) / 2.0 / a;\n    }\n    \n    if (x1 < x2)\n        return vec2(x1, x2);\n    return vec2(x2, x1);\n}\n\n// Raycast\nmat3 spinxyz(int axis,float angle,mat3 XYZ)\n{\n    vec3 X,Y,Z;\n\n\tif(axis==1)\n\t{\n\t   X = XYZ[0];\n       Y = XYZ[1];\n       Z = XYZ[2];\n\t}\n\tif(axis==2)\n\t{\n\t   X = XYZ[1];\n       Y = XYZ[2];\n       Z = XYZ[0];\n\t}\t\n    if(axis==3)\n\t{\n       X = XYZ[2];\n       Y = XYZ[0];\n       Z = XYZ[1];\n\t}\n\tZ = Z * cos(angle) + Y * sin(angle);\n    Y = cross(Z, X);\n\tif(axis==1)\n\treturn mat3(X,Y,Z);\n\tif(axis==2)\n\treturn mat3(Z,X,Y);\n\tif(axis==3)\n\treturn mat3(Y,Z,X);\n}\nvec3 transformxyz(vec3 xyz,mat3 XYZ)\n{\n    float nx=XYZ[0].x*xyz.x+XYZ[0].y*xyz.y+XYZ[0].z*xyz.z;\n\tfloat ny=XYZ[1].x*xyz.x+XYZ[1].y*xyz.y+XYZ[1].z*xyz.z;\n\tfloat nz=XYZ[2].x*xyz.x+XYZ[2].y*xyz.y+XYZ[2].z*xyz.z;\n\treturn vec3(nx,ny,nz);\n}\nvec2 sphere_raycast(vec3 ray_origin, vec3 ray_direction, float radius)\n{\n//    |o + td| = r\n//    o^2 + 2t do + t^2 d^2 = r^2\n    float a = 1.0;\n    float b = dot(ray_direction, ray_origin) * 2.0;\n    float c = dot(ray_origin, ray_origin) - radius * radius;\n        \n    vec2 t = solve_quadratic(a, b, c);        \n    if (t == vec2(INF, INF))\n        return EMPTY_INTERVAL;\n    return interval_intersection(t, vec2(0.0, INF));\n}\n\nvec2 atmosphere_raycast(vec3 ray_origin, vec3 ray_direction)\n{\n    vec2 i = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 ip = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    if (!empty(ip))\n        i = interval_intersection(i, vec2(-INF, ip.x));\n    return i;\n}\n\n// Main raymarching\n\nvec3 transmittance(vec3 origin, vec3 direction, float tmax, int steps)\n{\n    vec3 log_result = vec3(0.0);\n    float dt = tmax / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt;\n        vec3 p = origin + t * direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        log_result += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        log_result += MIE_EXTINSION * mie_density(h) * dt;\n        log_result += OZONE_EXTINSION * ozone_density(h) * dt;\n    }\n    return exp(- log_result);\n}\n\nvec3 sky_color(vec3 ray_origin, vec3 ray_direction, vec3 sun_direction, int steps)\n{\n    vec3 background = vec3(0.0);\n    vec3 stars= vec3(0);\n\tvec3 sun = vec3(0);\n    vec2 interval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 uv;\n    vec2 pinterval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n\tmat3 n0=spinxyz(1,PI/2.0-beta,mat3(1,0,0,0,1,0,0,0,1));\n\tmat3 n=spinxyz(3,2.0*PI*time(),n0);\n\tmat3 n1=spinxyz(3,2.0*PI*day_time(),n0);\n\tvec3 skyn=transformxyz(ray_direction,n);\n\tvec3 sunn=transformxyz(ray_direction,n1);\n    \t\t\t\t float ay2 = asin(skyn.z);\n     float ax2=asin(skyn.x / cos(asin(skyn.z)));\n\t\t\t if (skyn.y < 0.0) ax2 = 3.0 * PI / 2.0 + ax2;\n\t\t\t else ax2 = PI / 2.0 - ax2;\n\t\t\t uv.x=1.0-ax2/PI/2.0;\n\t\t\t uv.y=1.0-(ay2+PI/2.0)/PI;\n stars = texture( iChannel0, uv ).xyz;\n if(stars.b>0.8)stars=exp(2.15*(stars.r+stars.g+stars.b))*stars/2.8;\n if(sunn.x>0.9999891)sun = vec3(1);\n else sun=sun;\n    if (!empty(pinterval))\n    {\n        vec3 n = normalize(ray_origin + ray_direction * pinterval.x);\n\t\t\t\tvec3 earthcolor=transformxyz(n,n0);\n    float ay = asin(earthcolor.z);\n     float ax=asin(earthcolor.x / cos(asin(earthcolor.z)));\n\t\t\t if (earthcolor.y < 0.0) ax = 3.0 * PI / 2.0 + ax;\n\t\t\t else ax = PI / 2.0 - ax;\n\t\t\t uv.x=ax/PI/2.0;\n\t\t\t uv.y=0.5-ay/PI;\n\tvec3 col4 = texture( iChannel1, uv ).xyz;\n        background = 0.017* max(0.0, dot(n, sun_direction))*col4;\n\t\tstars=sun=vec3(0);\n        interval = interval_intersection(interval, vec2(-INF, pinterval.x));\n    }\n    \n    \n    vec3 result = vec3(0.0);\n\n    vec3 tcoeff = vec3(0.0);\n    \n    float dt = (interval.y - interval.x) / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt + interval.x;\n        vec3 p = ray_origin + t * ray_direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        // Instead of calling transmittance(p, -ray_direction, t, steps) to\n        // compute how much scattered light actually reachs the camera (as opposed\n        // to being absorbed or scattered again), we make use of the raymarching\n        // and compute transmittance on the go. The actuall transmittance factor\n        // is exp(-tcoeff) * dt\n        \n        tcoeff += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        tcoeff += MIE_EXTINSION * mie_density(h) * dt;\n        tcoeff += OZONE_EXTINSION * ozone_density(h) * dt;\n        \n        vec2 it = sphere_raycast(p, sun_direction, EARTH_RADIUS);\n        \n        vec3 emitter = vec3(0.0);\n        if (!empty(it))\n            emitter = EARTH_COLOR;\n        else\n        {\n            it = sphere_raycast(p, sun_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n        \n            if (!empty(it))\n                emitter = SUN_EMISSION* rayleigh_density(h);\n        }\n            \n        vec3 incoming = transmittance(p + it.x * sun_direction, sun_direction, it.y - it.x, steps) * SUN_EMISSION;\n        \n        float c = dot(-sun_direction, -ray_direction);\n        \n        vec3 scatter = vec3(0.0);\n        scatter += RAYLEIGH_SCATTERING * rayleigh_phase(c)*rayleigh_density(h)*1.0;\n        scatter += MIE_SCATTERING * mie_phase(c)*mie_density(h)*0.25;\n        \n        result += incoming * scatter * exp(-tcoeff) * dt;\n    }\n\n    result += (background+0.00002*stars+sun) * exp(-tcoeff);\n\n    return result;\n}\n\nvec3 tone_map(vec3 color)\n{\n    return pow(color / (vec3(1.0) + color), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec3 sun_direction = vec3(sin(2.0*PI*day_time()+PI/2.0), cos(2.0*PI*day_time()+PI/2.0)*cos(PI/2.0-beta), -cos(2.0*PI*day_time()+PI/2.0)*sin(PI/2.0-beta));\n   vec2 uv = fragCoord/iResolution.y;\n    float x1 =uv.x-0.5*iResolution.x/iResolution.y;\n    float y1 =0.5-uv.y;\n    float screenR = sqrt(x1 * x1 + y1 * y1);\n    float eyeay = PI / 2.0 - screenR*0.15/ sightdistance;\n    float eyeax=asin(y1 / screenR);\n     if (x1 > 0.0) eyeax = PI/2.0+eyeax;\n\t\t\t else eyeax = 3.0*PI/2.0- eyeax;       \n    vec2 m = vec2(2.0*iMouse.x / iResolution.y,-2.0*iMouse.y / iResolution.y)+vec2(0,0.5);    \n    m *= PI;   \n\t\n    vec3 view_direction;\n    //Rotation of spatial cartesian coordinates\n\t\tmat3 n=spinxyz(2,-m.y,spinxyz(3,-m.x,mat3(1.0, 0.0, 0.0,0.0, 1.0, 0.0,0.0, 0.0, 1.0)));\n    //Space cartesian coordinates to spherical coordinates\n    view_direction =\n        n[0] * cos(eyeax) * cos(eyeay) +\n        n[1] * sin(eyeax) * cos(eyeay) +\n        n[2] * sin(eyeay);\n    vec3 color = sky_color(camera_position(), view_direction, sun_direction, INTEGRATION_STEPS);       \n    fragColor = vec4(5.0*tone_map(color)*24.0, 1.0);\n\tif(eyeay>PI / 2.0||eyeay<-PI / 2.0)fragColor = vec4(0,0,0,1);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdccRX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[361, 361, 374, 374, 423], [424, 424, 441, 441, 493], [494, 494, 513, 513, 706], [861, 924, 947, 947, 1000], [1625, 1625, 1663, 1663, 1700], [1702, 1702, 1735, 1735, 1772], [1774, 1774, 1809, 1809, 1871], [1873, 1873, 1904, 1904, 1952], [1954, 1954, 1980, 1980, 2117], [2136, 2136, 2182, 2182, 2235], [2237, 2237, 2257, 2257, 2281], [2283, 2283, 2332, 2332, 2724], [2726, 2737, 2782, 2782, 3188], [3189, 3189, 3227, 3227, 3424], [3425, 3425, 3497, 3550, 3853], [3855, 3855, 3917, 3917, 4170], [8078, 8078, 8105, 8105, 8169], [8171, 8171, 8226, 8226, 9413]], "test": "untested"}
{"id": "7sdcRj", "name": "Mandelbrot Refract Applet", "author": "PhDFractal", "description": "A Shadertoy version of the Mandelbrot Refract Applet ijuru.com/refract by Rowan Seymour founded in 2006 and discontinued in 2014. Wanted to bring it back, but only using single precision. \nCompare Absolute Julia Set vs. Julia Set of two locations/zooms.", "tags": ["fractal", "mandelbrot", "comparison"], "likes": 3, "viewed": 297, "published": 3, "date": "1653770435", "time_retrieved": "2024-07-30T16:46:27.604504", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Mandelbrot Refract Applet\n//\n// Comparison of Absolute Julia Set vs. Julia Set with powers 2,3,4,5.\n//\n// Based on Mandelbrot Refract: ijuru.com/refract\n//\n// PLEASE BRING BACK REFRACT\n// PLEASE BRING BACK REFRACT\n// PLEASE BRING BACK REFRACT\n// PLEASE BRING BACK REFRACT\n// PLEASE BRING BACK REFRACT\n//\n// Created by PhDFractal, 11/26/2021\n//\n// Drag mouse on the screen to change the Julia seed.\n//\n// Powers can be toggled by pressing right \"\".\n//\n// Press 'z' to zoom into an interesting location and 'z' to again to go back.\n//\n// Interesting locations are:\n//   z^2: (0.2598,0.00168).\n//   z^3: (0.00016,1.09026).\n//   z^4: (-1.1745,0).\n//   z^5: (0.881004,0.582670).\n//\n// All colored FX rainbow. Calculated at 100 iterations per second.\n//\n// WARNING: don't run too long. Higher iterations uses GPU very quickly.\n// \n////////////////////////////////////////////////////////////////////////////////\n// Created by Fractal Math\n// https://www.youtube.com/channel/UCY-W4FvxaNRoZ8N5b-KzSZg\n// I share this piece (art and code) here in Shadertoy and through its Public API,\n// only for educational purposes. You cannot use, sell, share or host this piece\n// or modifications of it as part of your own commercial or non-commercial product\n// website or project. You cannot use, sell, share or host this piece or modifications\n// of it as part of your own commercial or non-commercial product, website or project.\n// You can share a link to it or an unmodified screenshot of it provided you attribute\n// \"by Fractal Math @Fractal MathPro\". \n\nvec2 two(vec2 x){ return vec2(x.x*x.x-x.y*x.y,2.*x.x*x.y); } //z^2\nvec2 three(vec2 x){ return vec2(x.x*x.x*x.x-3.*x.x*x.y*x.y,3.*x.x*x.x*x.y-x.y*x.y*x.y); } //z^3\nvec2 four(vec2 x){ return vec2(x.x*x.x*x.x*x.x-6.*x.x*x.x*x.y*x.y+x.y*x.y*x.y*x.y,\n                4.*x.x*x.x*x.x*x.y-4.*x.x*x.y*x.y*x.y); } //z^4\nvec2 five(vec2 x){ return vec2(x.x*x.x*x.x*x.x*x.x-10.*x.x*x.x*x.x*x.y*x.y+5.*x.x*x.y*x.y*x.y*x.y,\n                5.*x.x*x.x*x.x*x.x*x.y-10.*x.x*x.x*x.y*x.y*x.y+x.y*x.y*x.y*x.y*x.y); } //z^5\nvec4 rainbow(float i,float density){                                    //FX rainbow palette\n    vec4 black=vec4(0.,0.,0.,1.); vec4 red=vec4(1.,0.,0.,1.); vec4 yellow=vec4(1.,1.,0.,1.);\n    vec4 green=vec4(0.,1.,0.,1.); vec4 cyan=vec4(0.,0.698,1.,1.); vec4 blue=vec4(0.,0.,1.,1.);\n    float r=(i*density+5.)-100.*floor((i*density+5.)/100.); float R=0.;\n    if(r<16.){ R=r/16.; return mix(black,red,R); }\n    else if(r>=16. && r<31.){ R=(r-16.)/15.; return mix(red,yellow,R); }\n    else if(r>=31. && r<45.){ R=(r-31.)/14.; return mix(yellow,green,R); }\n    else if(r>=45. && r<62.){ R=(r-45.)/17.; return mix(green,cyan,R); }\n    else if(r>=62. && r<78.){ R=(r-62.)/16.; return mix(cyan,blue,R); }\n    else{ R=(r-78.)/22.; return mix(blue,black,R); }\n}\nbool keypress(int code){ return texelFetch(iChannel0,ivec2(code,2),0).x != 0.0; }\nvec4 store(int i,int j) { return texelFetch(iChannel1,ivec2(i,j),0); }\nint keycount(int key) { return int(store(0,key).x); } //from Wythoffian Tiling Generator @mla: shadertoy.com/view/wlGSWc\nvec2 seed = vec2(-0.75,0.); //Seed initialized to San Marco Absolute.\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n    bool zoom=keypress(90);                       //Press key 'z' for original\n    int mode=keycount(39)%4;                      //Press key '' to switch power\n    vec2 z0=vec2(0.,0.); vec2 pix=fragCoord/iResolution.x-.5*vec2(1,iResolution.y/iResolution.x);\n    vec2 z=vec2(0.,0.);  vec2 pixa=4.*pix+vec2(1.,0); vec2 pixj=4.*pix-vec2(1.,0);\n    vec4 color=vec4(0.,0.,0.,1.); //initialization of Juliation pixels, and color to black\n    if((iMouse.x==0.)&&(iMouse.y==0.)){ pixa=two(pixa)+seed; //Default is San Marco Absolute of seed c=(-0.75,0).\n        if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+pixa; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+seed; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n    }\n    else{\n    if(!zoom){ seed=.005*(iMouse.xy-.5*iResolution.xy);\n        if(mode==0){ pixa=two(pixa)+seed;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+pixa; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+seed; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==1){ pixa=three(pixa)+seed;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=three(z0)+pixa; if(dot(z,z)>2.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=three(z0)+seed; if(dot(z,z)>2.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==2){ pixa=four(pixa)+seed;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=four(z0)+pixa; if(dot(z,z)>1.59){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=four(z0)+seed; if(dot(z,z)>1.59){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==3){ pixa=five(pixa)+seed;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=five(z0)+pixa; if(dot(z,z)>1.42){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=five(z0)+seed; if(dot(z,z)>1.42){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        } }\n     else{\n        if(mode==0){ seed=vec2(0.2598,0.00168)+1e-6*(iMouse.xy-.5*iResolution.xy); pixa=two(pixa/64.)+seed; pixj=pixj/5.;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+pixa; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=two(z0)+seed; if(dot(z,z)>4.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==1){ seed=vec2(0.00016,1.09026)+1e-7*(iMouse.xy-.5*iResolution.xy); pixa=three(pixa/20.)+seed; pixj=pixj/4.;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=three(z0)+pixa; if(dot(z,z)>2.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=three(z0)+seed; if(dot(z,z)>2.){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==2){ seed=vec2(-1.1745,0)+2e-6*(iMouse.xy-.5*iResolution.xy); pixa=four(pixa/4.)+seed; pixj=pixj/4.;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=four(z0)+pixa; if(dot(z,z)>1.59){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=four(z0)+seed; if(dot(z,z)>1.59){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        }\n        else if(mode==3){ seed=vec2(0.881004,0.58267)+5e-7*(iMouse.xy-.5*iResolution.xy); pixa=five(pixa/6.78)+seed; pixj=pixj/4.;\n            if(pix.x<0.){ for(int i=0;i<int(iTime/.01);i++){ z=five(z0)+pixa; if(dot(z,z)>1.42){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n            else{ z0=pixj; for(int i=0;i<int(iTime/.01);i++){ z=five(z0)+seed; if(dot(z,z)>1.42){ color=rainbow(float(i),3.2); break;} else{ z0=z; } } }\n        } } }\n    fragColor=color;\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) (texelFetch(iChannel0,ivec2(k,n),0))\nvoid mainImage(out vec4 t,vec2 uv){\n#if __VERSION__ < 300\n    t = vec4(0);\n#else    \n    int i=int(uv.x); int j=int(uv.y);\n    if(iFrame==0) { t=vec4(0); }\n    else{ t=texelFetch(iChannel1,ivec2(i,j),0); } //Get current state\n    if(i==0){ float w1 = keystate(j,2).x;\n        if (w1!=t.w) { t.w=w1; t.x++; } }\n#endif           \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdcRj.jpg", "access": "api", "license": "proprietary-license", "functions": [[1632, 1632, 1649, 1649, 1692], [1693, 1699, 1718, 1718, 1788], [1789, 1795, 1813, 1813, 1935], [1936, 1942, 1960, 1960, 2127], [2128, 2134, 2170, 2226, 2885], [2886, 2886, 2910, 2910, 2967], [2968, 2968, 2993, 2993, 3038], [3039, 3039, 3062, 3062, 3092], [3231, 3231, 3285, 3285, 7433]], "test": "untested"}
{"id": "sstcRj", "name": "Pixel Staff Generator", "author": "SnoopethDuckDuck", "description": "Will probably upgrade this at some point", "tags": ["feedback", "cellularautomata"], "likes": 11, "viewed": 287, "published": 3, "date": "1653768425", "time_retrieved": "2024-07-30T16:46:28.455229", "image_code": "#define pi 3.14159\n\nvec3 pal(float t, vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 0.225; \n    vec2 res = 0.5 * floor( iResolution.xy);    \n    vec2 f = fragCoord;//mod(floor(32. * iTime) + fragCoord, res);\n    f.x = abs(f.x - res.x) + res.x;\n    \n    vec3 col = texelFetch( iChannel0, ivec2(zm * f + (1.-zm) * res), 0).rgb;\n\n    col.g *= col.r;\n    //if (col.b > 0.) \n    //    col.rg += col.b * 0.45;\n\n    if (col.g + col.r > 0.)\n        col.b = 0.;\n    else\n        col = 0.4 * vec3(1,1,0.5) * col.bbb;\n    \n    col += 1.5 * col.r * pal(0.5, 0.5 * vec3(0,1,2)/3.);\n    col += (1.-col.r) * vec3(0.15,0.075,0.15);\n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\n#define w 10.\n#define h 32.\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n    int fr = int(2. * max(w, h));\n    int maxFr = 3 * fr;\n    int frame = iFrame % maxFr;\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n    \n    vec2 res = floor(0.5 * iResolution.xy);\n    vec2 v = abs(f - res - 0.5);\n    \n    if (frame == 0 || key_down(KEY_RESET)) {      \n        if (v.x < 1. && v.y <= h)\n            col.r = 1.;\n        \n        if (v.x < 1. && v.y < 1.)\n            col.g = 1.;\n        return;\n    }\n           \n    // Center cell\n    col.rgb = cell(px);\n    \n    // Neighbour cells\n    vec3 b = cell(px - ivec2(0,1));\n    vec3 t = cell(px + ivec2(0,1));\n    vec3 l = cell(px - ivec2(1,0));\n    vec3 r = cell(px + ivec2(1,0));   \n    vec3 bl = cell(px + ivec2(-1,-1));\n    vec3 br = cell(px + ivec2(1, -1));\n    vec3 tl = cell(px + ivec2(-1, 1));\n    vec3 tr = cell(px + ivec2(1,  1));   \n    \n    vec3 sum = b + t + l + r;\n    vec3 diag = bl + br + tl + tr;\n    vec3 dif = abs(b-t) * abs(l-r);\n    \n    sum += diag;\n    \n    //e = clamp(e - 0.001, 0., 1.);    \n    //rand = step(0.9, rand);\n    \n    // > 0 and < 1\n    float th = 0.5; // 0.9\n    \n    // between 0 and 7 ish\n    float s = 3.;\n    \n    //e = clamp(e - 0.0001, 0., 1.);\n\n    if ( frame < fr) {\n        if (v.x > w || v.y > h)\n            col.g = 0.;\n        else if (col.g == 0. && rand >= th && abs(sum.g-1.) <= 0.5)\n            col.g = (rand - th) / (1.-th);\n        else if (abs(dif.g - sum.g) < 0.5)\n            col.g = 0.;\n            \n        if (sum.r + diag.r > 0. && col.g > 0.55)\n            col.r = min(2. * col.g, 1.);   \n    }\n    else {\n        if (frame == fr && v.x < 1. && v.y <= h) {\n            col.r = mix(col.r, (sum.r + diag.r) / 8., 0.25);\n        }\n    \n        if (frame == maxFr - 40)\n            col.r = 0.;\n    \n        if (sum.r + diag.r > 0.)\n            col.b = (sum.r + diag.r) / 8.;\n        else\n            col.b = 0.65 * (sum.b + diag.b) / 8.;\n     \n    }  \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstcRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 102], [104, 104, 161, 161, 806]], "test": "untested"}
{"id": "7dtcRj", "name": "Neonwave Sunset", "author": "mrange", "description": "License CC0: Neon Sunset\nCode is hackish but I thought it looked good enough to share\nThe music from GTA III - RISE FM, the best radio channel in GTA III IMHO", "tags": ["raytracerneon"], "likes": 68, "viewed": 2141, "published": 3, "date": "1653767670", "time_retrieved": "2024-07-30T16:46:29.291992", "image_code": "// License CC0: Neon Sunset\n//  Code is hackish but I thought it looked good enough to share\n//  The music from GTA III - RISE FM, the best radio channel in GTA III IMHO\n#define LAYERS            5.0\n#define PI                3.141592654\n#define TAU               (2.0*PI)\n#define TIME              iTime\n#define TTIME             (TAU*TIME)\n#define RESOLUTION        iResolution\n#define ROT(a)            mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nfloat sRGB(float t) { return mix(1.055*pow(t, 1./2.4) - 0.055, 12.92*t, step(t, 0.0031308)); }\n// License: Unknown, author: nmz (twitter: @stormoid), found: https://www.shadertoy.com/view/NdfyRM\nvec3 sRGB(in vec3 c) { return vec3 (sRGB(c.x), sRGB(c.y), sRGB(c.z)); }\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6f;\n  float a = 2.51f;\n  float b = 0.03f;\n  float c = 2.43f;\n  float d = 0.59f;\n  float e = 0.14f;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0f, 1.0f);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\n\n// License: Unknown, author: Unknown, found: don't remember\nvec2 hash2(vec2 p) {\n  p = vec2(dot (p, vec2 (127.1, 311.7)), dot (p, vec2 (269.5, 183.3)));\n  return fract(sin(p)*43758.5453123);\n}\n\n// License: CC BY-NC-SA 3.0, author: Stephane Cuillerdier - Aiekick/2015 (twitter:@aiekick), found: https://www.shadertoy.com/view/Mt3GW2\nvec3 blackbody(float Temp) {\n  vec3 col = vec3(255.);\n  col.x = 56100000. * pow(Temp,(-3. / 2.)) + 148.;\n  col.y = 100.04 * log(Temp) - 623.6;\n  if (Temp > 6500.) col.y = 35200000. * pow(Temp,(-3. / 2.)) + 184.;\n  col.z = 194.18 * log(Temp) - 1448.6;\n  col = clamp(col, 0., 255.)/255.;\n  if (Temp < 1000.) col *= Temp/1000.;\n  return col;\n}\n\n// License: WTFPL, author: sam hocevar, found: https://stackoverflow.com/a/17897228/418488\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\nvec3 hsv2rgb(vec3 c) {\n  vec3 p = abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www);\n  return c.z * mix(hsv2rgb_K.xxx, clamp(p - hsv2rgb_K.xxx, 0.0, 1.0), c.y);\n}\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat tanh_approx(float x) {\n//  return tanh(x);\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/smin\nfloat pmin(float a, float b, float k) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\n// License: MIT OR CC-BY-NC-4.0, author: mercury, found: https://mercury.sexy/hg_sdf/\nvec2 mod2(inout vec2 p, vec2 size) {\n  vec2 c = floor((p + size*0.5)/size);\n  p = mod(p + size*0.5,size) - size*0.5;\n  return c;\n}\n\n// License: MIT, author: Inigo Quilez, found: https://iquilezles.org/articles/intersectors\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n  return -(dot(ro,p.xyz)+p.w)/dot(rd,p.xyz);\n}\n\nvec3 toSpherical(vec3 p) {\n  float r   = length(p);\n  float t   = acos(p.z/r);\n  float ph  = atan(p.y, p.x);\n  return vec3(r, t, ph);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  float d0 = circle(sp, 0.5);\n  float d = d0;\n  return d;\n}\n\nfloat segmentx(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = length(p);\n  return p.x > 0.0 ? d0 : d1;\n}\n\nfloat segmentx(vec2 p, float l) {\n  float hl = 0.5*l;\n  p.x = abs(p.x);\n  float d0 = abs(p.y);\n  float d1 = length(p-vec2(hl, 0.0));\n  return p.x > hl ? d1 : d0;\n}\n\nfloat synth(vec2 p, float aa, out float h, out float db) {\n  const float z = 75.0;\n  p.y -= -70.0;\n  const float st = 0.04;\n  p.x = abs(p.x);\n  p.x -= 20.0-3.5;\n  p.x += st*20.0;\n  p /= z;\n  float n = mod1(p.x, st);\n  float dib = 1E6;\n  const int around = 0;\n  for (int i = -around; i <=around ;++i) {\n    float fft = texture(iChannel0, vec2((n+float(i))*st, 0.25)).x; \n    fft *= fft;\n    if (i == 0) h = fft;\n    float dibb = segmentx((p-vec2(st*float(i), 0.0)).yx, fft+0.05)-st*0.4;\n    dib = min(dib, dibb);\n  }\n  \n  float d = dib;\n  db = abs(p.y)*z;\n  return smoothstep(aa, -aa, d*z);\n}\n\nvec3 road(vec3 ro, vec3 rd, vec3 nrd, float glare, vec4 pl, out float pt) {\n  const float szoom   = 0.5;\n  const float bsz     = 25.0;\n  const float sm      = 1.0;\n  float off = abs(pl.w);\n  float t = rayPlane(ro, rd, pl);\n  pt = t;\n\n  vec3 p  = ro+rd*t;\n  vec3 np = ro+nrd*t;\n\n  vec2 pp   = p.xz;\n  vec2 npp  = np.xz;\n  vec2 opp  = pp;\n\n  float aa  = length(npp-pp)*sqrt(0.5);\n  pp.y += -60.0*TIME;\n\n  vec3 gcol = vec3(0.0);\n\n  float dr = abs(pp.x)-off;\n  vec2 cp = pp;\n  mod1(cp.y, 6.0*off);\n  vec2 sp = pp;\n  sp.x = abs(sp.x);\n  mod1(sp.y, off);\n  float dcl = segmentx(cp.yx, 1.5*off);\n  float dsl = segmentx((sp-vec2(0.95*off, 0.0)).yx, off*0.5);\n\n  vec2 mp = pp;\n  mod2(mp, vec2(off*0.5));\n    \n  vec2 dp = abs(mp);\n  float d = dp.x;\n  d = pmin(d, dp.y, sm);\n  d = max(d, -dr);\n  d = min(d, dcl); \n  d = min(d, dsl); \n  vec2 s2 = sin(TIME+2.0*p.xz/off);\n  float m = mix(0.75, 0.9, tanh_approx(s2.x+s2.y));\n  m *= m;\n  m *= m;\n  m *= m;\n  vec3 hsv = vec3(0.4+mix(0.5, 0.0, m), tanh_approx(0.15*mix(30.0, 10.0, m)*d), 1.0);\n  float fo = exp(-0.04*max(abs(t)-off*2., 0.0));\n  vec3 bcol = hsv2rgb(hsv);\n  gcol += 2.0*bcol*exp(-0.1*mix(30.0, 10.0, m)*d)*fo;\n\n  float sh;\n  float sdb;\n  float sd =synth(opp, aa,sh, sdb)*smoothstep(aa, -aa, -dr);\n  sh = tanh_approx(sh);\n  sdb *= 0.075;\n  sdb *= sdb;\n  sdb += 0.05;\n  vec3 scol = sd*(sdb)*pow(tanh(vec3(0.1)+bcol), mix(vec3(1.0), vec3(1.5, 0.5, 0.5), smoothstep(0.4, 0.5, sh)));\n  gcol += scol;\n\n\n  gcol = t > 0.0 ? gcol : vec3(0.0);\n  return gcol+scol;\n}\n\nvec3 stars(vec2 sp, float hh) {\n  vec3 col = vec3(0.0);\n  \n  const float m = LAYERS;\n  hh = tanh_approx(20.0*hh);\n\n  for (float i = 0.0; i < m; ++i) {\n    vec2 pp = sp+0.5*i;\n    float s = i/(m-1.0);\n    vec2 dim  = vec2(mix(0.05, 0.003, s)*PI);\n    vec2 np = mod2(pp, dim);\n    vec2 h = hash2(np+127.0+i);\n    vec2 o = -1.0+2.0*h;\n    float y = sin(sp.x);\n    pp += o*dim*0.5;\n    pp.y *= y;\n    float l = length(pp);\n  \n    float h1 = fract(h.x*1667.0);\n    float h2 = fract(h.x*1887.0);\n    float h3 = fract(h.x*2997.0);\n\n    vec3 scol = mix(8.0*h2, 0.25*h2*h2, s)*blackbody(mix(3000.0, 22000.0, h1*h1));\n\n    vec3 ccol = col + exp(-(mix(6000.0, 2000.0, hh)/mix(2.0, 0.25, s))*max(l-0.001, 0.0))*scol;\n    ccol *= mix(0.125, 1.0, smoothstep(1.0, 0.99, sin(0.25*TIME+TAU*h.y)));\n    col = h3 < y ? ccol : col;\n  }\n  \n  return col;\n}\n\nvec3 meteorite(vec2 sp) {\n  const float period = 3.0;\n  float mtime = mod(TIME, period);\n  float ntime = floor(TIME/period);\n  float h0 = hash(ntime+123.4);\n  float h1 = fract(1667.0*h0);\n  float h2 = fract(9967.0*h0);\n  vec2 mp = sp;\n  mp.x += -1.0;\n  mp.y += -0.5*h1;\n  mp.y += PI*0.5;\n  mp *= ROT(PI+mix(-PI/4.0, PI/4.0, h0));\n  float m = mtime/period;\n  mp.x += mix(-1.0, 2.0, m);\n  \n  float d0 = length(mp);\n  float d1 = segmentx(mp);\n  \n  vec3 col = vec3(0.0);\n  \n  col += 0.5*exp(-4.0*max(d0, 0.0))*exp(-1000.0*max(d1, 0.0));\n  col *= 2.0*HSV2RGB(vec3(0.8, 0.5, 1.0));\n  float fl = smoothstep(-0.5, 0.5, sin(12.0*TTIME));\n  col += mix(1.0, 0.5, fl)*exp(-mix(100.0, 150.0, fl)*max(d0, 0.0));\n  \n  col = h2 > 0.8 ? col: vec3(0.0);\n  return col;\n}\n\nvec3 skyGrid(vec2 sp) {\n  const float m = 1.0;\n\n  const vec2 dim = vec2(1.0/12.0*PI);\n  float y = sin(sp.x);\n  vec2 pp = sp;\n  vec2 np = mod2(pp, dim*vec2(1.0/floor(1.0/y), 1.0));\n\n  vec3 col = vec3(0.0);\n\n  float d = min(abs(pp.x), abs(pp.y*y));\n  \n  float aa = 2.0/RESOLUTION.y;\n  \n  col += 0.25*vec3(0.5, 0.5, 1.0)*exp(-2000.0*max(d-0.00025, 0.0));\n  \n  return col;\n}\n\n\nvec3 sunset(vec2 sp, vec2 nsp) {\n  const float szoom   = 0.5;\n  float aa = length(nsp-sp)*sqrt(0.5);\n  sp -= vec2(vec2(0.5, -0.5)*PI);\n  sp /= szoom;\n  sp = sp.yx;\n  sp.y += 0.22;\n  sp.y = -sp.y;\n  float ds = sun(sp)*szoom;\n  \n  vec3 bscol = hsv2rgb(vec3(fract(0.7-0.25*(sp.y)), 1.0, 1.0));\n  vec3 gscol = 0.75*sqrt(bscol)*exp(-50.0*max(ds, 0.0));\n  vec3 scol = mix(gscol, bscol, smoothstep(aa, -aa, ds));\n  return scol;\n}\n\nvec3 glow(vec3 ro, vec3 rd, vec2 sp, vec3 lp) {\n  float ld = max(dot(normalize(lp-ro), rd),0.0);\n  float y = -0.5+sp.x/PI;\n  y = max(abs(y)-0.02, 0.0)+0.1*smoothstep(0.5, PI, abs(sp.y));\n  float ci = pow(ld, 10.0)*2.0*exp(-25.0*y);\n  float h = 0.65;\n  vec3 col = hsv2rgb(vec3(h, 0.75, 0.35*exp(-15.0*y)))+HSV2RGB(vec3(0.8, 0.75, 0.5))*ci;\n  return col;\n}\n\n\n\nvec3 neonSky(vec3 ro, vec3 rd, vec3 nrd, out float gl) {\n  const vec3 lp       = 500.0*vec3(0.0, 0.25, -1.0);\n  const vec3 skyCol   = HSV2RGB(vec3(0.8, 0.75, 0.05));\n\n\n  float glare = pow(abs(dot(rd, normalize(lp))), 20.0);\n  \n  vec2 sp   = toSpherical(rd.xzy).yz;\n  vec2 nsp  = toSpherical(nrd.xzy).yz;\n  vec3 grd  = rd;\n  grd.xy *= ROT(0.025*TIME);\n  vec2 spp = toSpherical(grd).yz;\n\n  float gm = 1.0/abs(rd.y)*mix(0.005, 2.0, glare);\n  vec3 col = skyCol*gm;\n  float ig = 1.0-glare;\n  col += glow(ro, rd, sp, lp);\n  if (rd.y > 0.0) {\n    col += sunset(sp, nsp);\n    col += stars(sp, 0.0)*ig;\n    col += skyGrid(spp)*ig;\n    col += meteorite(sp)*ig;\n  }\n  gl = glare;\n  return col;\n}\n\nvec3 color(vec3 ro, vec3 rd, vec3 nrd) {\n  const float off1  = -20.0;\n  const vec4 pl1    = vec4(normalize(vec3(0.0, 1.0, 0.15)), -off1);\n  float glare;\n  vec3 col = neonSky(ro, rd, nrd, glare);\n  if (rd.y < 0.0) {\n    float t;\n    col += road(ro, rd, nrd, glare, pl1, t);\n  }\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy; \n  vec2 p = -1.0 + 2.0*q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  float aa = 2.0/RESOLUTION.y;\n  vec3 ro = vec3(0.0, 0.0, 10.0);\n  vec3 la = vec3(0.0, 2.0, 0.0);\n  vec3 up = vec3(0.0, 1.0, 0.0);\n\n  vec3 ww = normalize(la - ro);\n  vec3 uu = normalize(cross(up, ww ));\n  vec3 vv = normalize(cross(ww,uu));\n  const float fov = tan(TAU/6.0);\n  vec2 np = p + vec2(aa); \n  vec3 rd = normalize(-p.x*uu + p.y*vv + fov*ww);\n  vec3 nrd = normalize(-np.x*uu + np.y*vv + fov*ww);\n\n\n  vec3 col = vec3(0.1);\n  col = color(ro, rd, nrd);\n//  col += synth(p, np);\n  col *= smoothstep(0.0, 4.0, TIME);\n  col = aces_approx(col);\n  col = sRGB(col); \n\n\n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [{"id": 29046, "src": "https://soundcloud.com/furtheram-9/grand-theft-auto-iii-gta-3-1", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dtcRj.jpg", "access": "api", "license": "cc0-1.0", "functions": [[445, 545, 566, 566, 639], [640, 740, 762, 762, 811], [813, 920, 946, 946, 1130], [1132, 1192, 1214, 1214, 1262], [1265, 1325, 1345, 1345, 1457], [1459, 1597, 1625, 1625, 1937], [2091, 2091, 2113, 2113, 2259], [2403, 2463, 2491, 2511, 2587], [2589, 2589, 2620, 2620, 2646], [2648, 2731, 2770, 2770, 2863], [2865, 2951, 2990, 2990, 3115], [3117, 3203, 3239, 3239, 3333], [3335, 3426, 3468, 3468, 3515], [3517, 3517, 3543, 3543, 3652], [3654, 3654, 3673, 3673, 3775], [3777, 3777, 3801, 3801, 3880], [3882, 3882, 3915, 3915, 4045], [4047, 4047, 4105, 4105, 4638], [4640, 4640, 4715, 4715, 6143], [6145, 6145, 6176, 6176, 6979], [6981, 6981, 7006, 7006, 7732], [7734, 7734, 7757, 7757, 8104], [8107, 8107, 8139, 8139, 8529], [8531, 8531, 8578, 8578, 8885], [8889, 8889, 8945, 8945, 9573], [9575, 9575, 9615, 9615, 9867], [9869, 9869, 9924, 9924, 10622]], "test": "untested"}
{"id": "sddyRj", "name": "ship v3", "author": "jorge2017a2", "description": "sound, happybirthday, shipv3, \nship v3", "tags": ["sound", "happybirthday", "shipv3"], "likes": 6, "viewed": 235, "published": 3, "date": "1653767377", "time_retrieved": "2024-07-30T16:46:30.231480", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 basicaNave(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n     p.x=abs(p.x)-5.0;\n    float d1=sdBox( p, vec3(2.0,2.0,10.0) );\n    float d2a= sdCylinderXY(p-vec3(0.0,0.0,-10.0), vec2(1.5,5.0) );\n    float d2b= sdCylinderXY(p-vec3(0.0,0.0,-15.0), vec2(0.5,3.0) );\n    float d4= sdCylinderXY(p-vec3(0.0,0.0,10.0), vec2(1.5,5.0) );\n    float d5=sdBox( p-vec3(2.0,0.0,25.0), vec3(4.0,4.0,10.0) );\n    float d6=sdBox( p-vec3(1.0,0.0,25.0), vec3(0.5,10.0,3.0) );\n    float d7=sdBox( p-vec3(4.0,0.0,25.0), vec3(0.5,12.0,3.0) );\n    \n    p=p0;\n    float d3=sdBox( p-vec3(0.0,-1.0,5.0), vec3(12.0,0.5,5.0) );\n    float d8a= sdCylinderYZ(p-vec3(0.0,0.0,20.0), vec2(2.0,20.0));\n    float d8b= sdCylinderYZ(p-vec3(-17.0,0.0,20.0), vec2(8.0,0.5));\n    float d8c= sdCylinderYZ(p-vec3( 17.0,0.0,20.0), vec2(8.0,0.5));\n    \n    res =opU2(res, vec2(d1,1.0));\n    res =opU2(res, vec2(d2a,2.0));\n    res =opU2(res, vec2(d2b,5.0));\n    res =opU2(res, vec2(d3,2.0));\n    res =opU2(res, vec2(d4,2.0));\n    res =opU2(res, vec2(d5,1.0));\n    res =opU2(res, vec2(d6,2.0));\n    res =opU2(res, vec2(d7,2.0));\n    \n    res =opU2(res, vec2(d8a,4.0));\n    res =opU2(res, vec2(d8b,2.0));\n    res =opU2(res, vec2(d8c,2.0));\n    \n    return res;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);\n    float t=iTime;\n    if(15.*sin(t)>0.0)\n        p= rotate_z(p, iTime);\n    \n    vec3 p0=p;\n\n\tp.y=p.y-5.0;\n   \n   float pos1=10.0*cos(t);\n   //p.x=abs(p.x)-30.0;\n   p.z= opRep1D(p.z+t*30.0, 100.0); \n   vec2 b1= basicaNave(p);\n   res =opU2(res, b1);\n    \n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\t\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   return vec3(0.0);}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }\n\n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,500.0);\n \tlight_pos1= vec3(-10.0, 60.0, -25.); light_color1=vec3( 0.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,0.0,1.0 ); \n   //vec3 ro=vec3(0.0,7.0,-25.0);\n   \n   float py=20.0*sin(t*2.0);\n   vec3 ro=vec3(0.0,20.0+py,25.0);\n   \n   \n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   //rd= rotate_y(rd, -10.0);\n   rd= rotate_x(rd, -50.0);\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n//shane\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0),   //12\nvec3(0.5,0,0.5),  //13\nvec3(0,0.5,0.5),  //14\nvec3(0,0,0.5),    //15\nvec3(1.0, 0.8, 0.737),  //16\nvec3(0.8, 0.8, 0.8),  //17\nvec3(0.5, 0.5, 0.8),  //18\nvec3(1, 0.5, 0),      //19\nvec3(1.0, 1.0, 1.0),  //20\nvec3(0.968,0.6588,  0.721),//21\nvec3(0, 1, 1), //22 \nvec3(0.333, 0.803, 0.988),//23\nvec3(0.425, 0.56, 0.9)*vec3( 0.3, 0.2, 1.0 ),//24 \nvec3(0.8,0.8,0.8)*vec3( 0.3, 0.2, 1.0 ),//25  \nvec3(1.0,0.01,0.01)*vec3( 0.3, 0.2, 1.0 ),//26\nvec3(0.1, 0.5, 1.0),//27   \nvec3(0.0, 0.6, 0.0),//28 \nvec3(0.1,0.1,0.7), //29\nvec3(0.99, 0.2, 0.1), //30\nvec3(.395, .95, 1.), //31\nvec3(0.425, 0.56, 0.9), //32\nvec3(0.7333, 0.1412, 0.1412), //33\nvec3(0.1843, 0.3333, 0.1843), //34\n vec3(0.6549, 0.6549, 0.9922), //35\n vec3(0.8549, 0.8549, 0.8549)  //36\n);\n\nvec3 getColor(int i)\n{   //if (i==-2 ) {return mObj.color; }       \n    if (i>-1 )  return Arrcolores[i];\n}\n", "sound_code": "\nstruct Note {\n    // in Hz, see \"common\" tab\n    float frequency;\n    // offset - time in seconds when to start playing note\n    float offset;\n    // duration of a note (1/4, 1/8, ...), see \"common\" tab\n    float duration;\n};\n\n//version D JF\n////Octava #1\n//--fin--\n////Octava #2\n const float A0 =27.5;  //1\n const float A_0 =29.14;  //2\n const float B0 =30.87;  //3\n//--fin--\n////Octava #3\n const float C1 =32.7;  //4\n const float C_1 =34.65;  //5\n const float D1 =36.71;  //6\n const float D_1 =38.89;  //7\n const float E1 =41.2;  //8\n const float F1 =43.65;  //9\n const float F_1 =46.25;  //10\n const float G1 =49.0;  //11\n const float G_1 =51.91;  //12\n const float A1 =55.;  //13\n const float A_1 =58.27;  //14\n const float B1 =61.74;  //15\n//--fin--\n////Octava #4\n const float C2 =65.41;  //16\n const float C_2 =69.3;  //17\n const float D2 =73.42;  //18\n const float D_2 =77.78;  //19\n const float E2 =82.41;  //20\n const float F2 =87.31;  //21\n const float F_2 =92.5;  //22\n const float G2 =98.;  //23\n const float G_2 =103.83;  //24\n const float A2 =110.;  //25\n const float A_2 =116.54;  //26\n const float B2 =123.47;  //27\n//--fin--\n////Octava #5\n const float C3 =130.81;  //28\n const float C_3 =138.59;  //29\n const float D3 =146.83;  //30\n const float D_3 =155.56;  //31\n const float E3 =164.81;  //32\n const float F3 =174.61;  //33\n const float F_3 =185.;  //34\n const float G3 =196.;  //35\n const float G_3 =207.65;  //36\n const float A3 =220.;  //37\n const float A_3 =233.08;  //38\n const float B3 =246.94;  //39\n//--fin--\n////Octava #6\n const float C4 =261.63;  //40\n const float C_4 =277.18;  //41\n const float D4 =293.66;  //42\n const float D_4 =311.13;  //43\n const float E4 =329.63;  //44\n const float F4 =349.23;  //45\n const float F_4 =369.99;  //46\n const float G4 =392.;  //47\n const float G_4 =415.3;  //48\n const float A4 =440.;  //49\n const float A_4 =466.16;  //50\n const float B4 =493.88;  //51\n//--fin--\n////Octava #7\n const float C5 =523.25;  //52\n const float C_5 =554.37;  //53\n const float D5 =587.33;  //54\n const float D_5 =622.25;  //55\n const float E5 =659.26;  //56\n const float F5 =698.46;  //57\n const float F_5 =739.99;  //58\n const float G5 =783.99;  //59\n const float G_5 =830.61;  //60\n const float A5 =880.;  //61\n const float A_5 =932.33;  //62\n const float B5 =987.77;  //63\n//--fin--\n////Octava #8\n const float C6 =1046.5;  //64\n const float C_6 =1108.73;  //65\n const float D6 =1174.66;  //66\n const float D_6 =1244.51;  //67\n const float E6 =1318.51;  //68\n const float F6 =1396.91;  //69\n const float F_6 =1479.98;  //70\n const float G6 =1567.98;  //71\n const float G_6 =1661.22;  //72\n const float A6 =1760.;  //73\n const float A_6 =1864.66;  //74\n const float B6 =1975.53;  //75\n//--fin--\n////Octava #9\n const float C7 =2093.;  //76\n const float C_7 =2217.46;  //77\n const float D7 =2349.32;  //78\n const float D_7 =2489.02;  //79\n const float E7 =2637.02;  //80\n const float F7 =2793.83;  //81\n const float F_7 =2959.96;  //82\n const float G7 =3135.96;  //83\n const float G_7 =3322.44;  //84\n const float A7 =3520.;  //85\n const float A_7 =3729.31;  //86\n const float B7 =3951.07;  //87\n//--fin--\n////Octava #10\n const float C8 =4186.01;  //88\n const float C_8 =4434.92;  //89\n const float D8 =4698.64;  //90\n const float D_8 =4978.03;  //91\n const float E8 =5274.04;  //92\n const float F8 =5587.65;  //93\n const float F_8 =5919.91;  //94\n const float G8 =6271.93;  //95\n const float G_8 =6644.88;  //96\n const float A8 =7040.;  //97\n const float A_8 =7458.62;  //98\n const float B8 =7902.13;  //99\n//--fin--\n\n\n\n\nconst Note[] notes = Note[] (\n\nNote(C3,0.00000,0.125),\nNote(C3,0.12500,0.125),\nNote(D3,0.25000,0.25),\nNote(C3,0.50000,0.25),\nNote(F3,0.75000,0.25),\nNote(E3,1.00000,0.25),\nNote(C3,1.25000,0.125),\nNote(C3,1.37500,0.125),\nNote(D3,1.50000,0.25),\nNote(C3,1.75000,0.25),\nNote(G3,2.00000,0.25),\nNote(F3,2.25000,0.5),\nNote(C3,2.75000,0.125),\nNote(C3,2.87500,0.125),\nNote(C4,3.00000,0.25),\nNote(A3,3.25000,0.25),\nNote(F3,3.50000,0.25),\nNote(E3,3.75000,0.25),\nNote(D3,4.00000,0.25),\nNote(B4,4.25000,0.125),\nNote(B4,4.37500,0.125),\nNote(A3,4.50000,0.25),\nNote(F3,4.75000,0.25),\nNote(G3,5.00000,0.25),\nNote(F3,5.25000,0.5),\nNote(C3,5.75000,0.125),\nNote(C3,5.87500,0.125),\nNote(D3,6.00000,0.25),\nNote(C3,6.25000,0.25),\nNote(F3,6.50000,0.25),\nNote(E3,6.75000,0.5),\nNote(C3,7.25000,0.125),\nNote(C3,7.37500,0.125),\nNote(D3,7.50000,0.25),\nNote(C3,7.75000,0.25),\nNote(G3,8.00000,0.25)\n\n\n\n);\n\nfloat Weight( float x )\n{  if( x < 0.0 )x = - x;\n\tif( x < 1.0 )return (1.0 - 2.0*x*x + x*x*x) ;\n\tif( x < 2.0 )return (4.0 - 8.*x + 5.*x*x - x*x*x) ;\nreturn 0.0 ;\n}\n\n\nfloat saw(float t, float note, float octave)\n{   return fract(t*note*exp2(octave-1.))-0.5; }\n\n\nvec2 noteFreq(Note note, float time) \n{\n    float octava=3.0;\n    float n1=saw(time,note.frequency, octava)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    float t=time;\n    n1=Weight(n1)*n1;    \n    return vec2(n1);\n}\n\nvec2 mainSound( in int samp,float time) \n{   vec2 result;\n    //float tt=sin(time*0.25);\n    float ftime= mod(time*0.5, 9.0);\n    \n    for (int i = 0; i < notes.length(); i++) {\n        Note note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        { result += noteFreq(note, ftime);  }\n    }\n    return result*0.135;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddyRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[421, 421, 453, 453, 537], [538, 538, 577, 577, 672], [673, 673, 712, 712, 807], [808, 808, 847, 847, 942], [944, 988, 1032, 1032, 1059], [1060, 1060, 1100, 1100, 1127], [1128, 1128, 1173, 1173, 1201], [1202, 1240, 1276, 1276, 1321], [1322, 1387, 1421, 1421, 1517], [1518, 1518, 1552, 1552, 1643], [1644, 1644, 1678, 1678, 1769], [1770, 1770, 1804, 1804, 1895], [1897, 1897, 1922, 1922, 3120], [3122, 3122, 3147, 3147, 3455], [3457, 3457, 3481, 3481, 3643], [3645, 3645, 3693, 3693, 3972], [3975, 3975, 4019, 4019, 4340], [4342, 4342, 4379, 4379, 4636], [4638, 4638, 4728, 4728, 5688], [5690, 5690, 5739, 5739, 5819], [5823, 5823, 5855, 5855, 5876], [5879, 5879, 5949, 5949, 6123], [6125, 6125, 6152, 6152, 6241], [6243, 6243, 6301, 6301, 6349], [6351, 6351, 6374, 6374, 6486], [6488, 6488, 6519, 6519, 7139], [7141, 7141, 7198, 7198, 7769]], "test": "untested"}
{"id": "fsdyzj", "name": "ray-tracing torus (where's bug?)", "author": "FabriceNeyret2", "description": "WIP.\ntrying to directly ray-trace a torus by solving the P4 polynomial.  (blue)\nred / green where solutions l_1,2 / l_3,4 are defined.   why the dots, why the arc bug ?\nmouse controls camera", "tags": ["raytracing", "short"], "likes": 13, "viewed": 419, "published": 3, "date": "1653766261", "time_retrieved": "2024-07-30T16:46:30.990452", "image_code": "float r1 = 10., r2 = 5.;                 // large & small torus radii\nconst vec3 A = normalize(vec3(0,0,1)),   // torus axis\n          Ay = normalize(cross(vec3(1,0,0),A)), Ax = cross(A,Ay); // torus frame\n\n//#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation   \n  #define rot(a)       mat2(cos(a), -sin(a), sin(a), cos(a) )   \n\n#if 0\n     #define draw(p) 1.\n#else\nvec4 draw( vec3 p) { // p += l*D;       // ---- pattern upon the torus\n     //v = asin( (oa + l*da)/r2 );\n     //v = acos( ( dot(p,p) - (r1*r1 + r2*r2) ) * .5/r1/r2 );     \n     float v = atan( dot(p,A),  ( dot(p,p) - (r1*r1 + r2*r2) ) * .5/r1 );\n\n     p -= dot(p,A) *A; \n     float u = atan(dot(p,Ax), dot(p,Ay) );\n     vec2 U = vec2( sin(2.*r1*u), sin(2.*r2*v) );\n  // return vec4( clamp(.5-.5*U/fwidth(U),0.,1.) , 0, 1);\n     U = clamp(.5-.5*abs(U)/fwidth(U),0.,1.);\n     return vec4( vec2( max(U.x,U.y) ), 1,1);\n}\n#endif\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          P = 60./R,                                      // camera position \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(25,10,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    \n    P.yz *= rot(-6.*M.y),                                 // rotations\n    P.xz *= rot(-6.*M.x);\n    D.yz *= rot(-6.*M.y),                           \n    D.xz *= rot(-6.*M.x);\n    // P = O + lD ,   P.A = r.sinv ,   |P-(P.A)A| = R+r.cosv \n    //  P-rsinv = (R+r.cosv)  P = r+R+2rR.cosv \n    //  r.cosv = ( P-r-R ) / 2R\n    //  r = (P.A) + ( \" ) = degree4 polynomial in l\n    // solution: https://en.wikipedia.org/wiki/Quartic_function#Solution\n    \n    float da = dot(D,A), oa = dot(P,A),\n          a0 = .5/r1,         //  ( P-r-R ) / 2R = P2[l]\n          b0 =  dot(P,D)/r1,\n          c0 = ( dot(P,P) - r1*r1 - r2*r2 ) *.5/r1,\n    // --- (P.A)[l] --- ((P-r-R)/2R)[l]  ----\n          a =              a0*a0,                       // l\n          b =              2.*a0*b0,                    // l\n          c =  da*da    +  b0*b0 + 2.*a0*c0,            // l\n          d = 2.*oa*da  +  2.*b0*c0,                    // l\n          e = oa*oa     +  c0*c0              - r2*r2,  // l\n\n          d0 = c*c - 3.*b*d + 12.*a*e,\n          d1 = 2.*c*c*c - 9.*b*c*d +27.*b*b*e +27.*a*d*d -72.*a*c*e,\n          p = ( 8.*a*c - 3.*b*b ) / ( 8.*a*a ),\n          q = ( b*b*b - 4.*a*b*c + 8.*a*a*d )  / ( 8.*a*a*a ),\n          dd  = d1*d1-4.*d0*d0*d0,\n          Q   = pow( ( d1 + sqrt(dd) )/2., 1./3. ), \n          phi = acos(d1*.5/sqrt(d0*d0*d0)),\n          S = dd > 0. \n                ? .5* sqrt( -2./3.*p+ (Q+d0/Q)/(3.*a) )\n                : .5* sqrt( -2./3.*p+ 2./(3.*a)*sqrt(d0)*cos(phi/3.) ),\n          d2 = .5*sqrt(-4.*S*S - 2.*p +q/S),\n          l0 = -b/(4.*a),\n          l,u,v;\n#if 0     \n     O = vec4(d1*d1-4.*d0*d0*d0<0., \n              d1 + sqrt(d1*d1-4.*d0*d0*d0) <0.,\n              0,0); return;\n#endif\n     O-=O;\n     l = l0 -S -d2;  if (!isnan(l)) O += draw(P+l*D) *vec4( 1,0,.1,0);\n     l = l0 -S +d2;  if (!isnan(l)) O += draw(P+l*D) *vec4(.3,0,.1,0);\n     d2 = .5*sqrt(-4.*S*S - 2.*p -q/S);\n     l = l0 +S -d2;  if (!isnan(l)) O += draw(P+l*D) *vec4(0, 1,.1,0);\n     l = l0 +S +d2;  if (!isnan(l)) O += draw(P+l*D) *vec4(0,.3,.1,0);\n     \n     O = sqrt(O);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdyzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[910, 910, 946, 946, 3372]], "test": "untested"}
{"id": "Nddczj", "name": "Backfisch point cloud", "author": "Ossitech", "description": "Point cloud reacting to music", "tags": ["sound", "points"], "likes": 1, "viewed": 240, "published": 3, "date": "1653754956", "time_retrieved": "2024-07-30T16:46:31.892040", "image_code": "#define POINT_DISTANCE 75\n#define POINT_SIZE 20\n\nint points(vec2 pos, vec2 d)\n{\n    vec2 uv = (pos + d) / iResolution.xy;\n    uv *= 3.0;\n    \n    if(int(pos.x + d.x) % POINT_DISTANCE < POINT_SIZE && int(pos.y + d.y) % POINT_DISTANCE < POINT_SIZE)\n    {\n\nreturn 1;\n}\n\n\n    \n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    int mask = 0;\n    \n    mask += points(fragCoord, vec2(iTime * 300.0, 0.0));\n    //mask += points(fragCoord, vec2(iTime * 120.0, 30.0));\n    \n    if (mask > 0)\n    {\n        fragColor = texture(iChannel0, uv);\n    }\n    else\n    {\n        fragColor = vec4(0.0);\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nddczj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 79, 79, 288], [290, 290, 347, 347, 667]], "test": "untested"}
{"id": "fstyzj", "name": "Monster Skeleton Preset 43.7", "author": "aiekick", "description": "Monster Skeleton Preset 43.7 with iron man coloring :)", "tags": ["kifs"], "likes": 21, "viewed": 395, "published": 3, "date": "1653752830", "time_retrieved": "2024-07-30T16:46:32.658990", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2022 (twitter:@aiekick)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// the shading used for these kifs, are so simple\n\n// its just the ambient occlusion used as a ratio in a linear interpolation between two colors\n\n// in my experiments, its was just 2 matcaps\n// like in this video https://twitter.com/aiekick/status/1524851894761537550\n\n// for shadertoy, i just tried to recreate a similar shading as my matcaps\n\n// with iron man colors\n\n// can be cool if shadertoy can add some matcaps (as samples)\n\n//#define CAN_TUNE_SHAPE_WITH_MOUSE\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n\tfragColor = vec4(0,0,0,1);\n    \n    // one time sdf transform \n    vec2 shape_mouse = vec2(0.468359,0.95317);\n#ifdef CAN_TUNE_SHAPE_WITH_MOUSE\n    if (iMouse.z > 0.0)\n    {\n        shape_mouse = iMouse.xy/iResolution.xy;\n    }\n#endif\n\tvec2 rm = k2Pi * shape_mouse;\n\tscene_mtx = rotX(rm.x) * rotY(rm.x) * rotZ(rm.x) * rotX(rm.y);\n\t\t\n    // ray origin, ray direction\n    vec2 mr = iMouse.xy / iResolution.xy;\n\tfloat ca = iTime * 0.4;\n\tfloat cd = 30.0;\n    \n#ifndef CAN_TUNE_SHAPE_WITH_MOUSE\n    if (iMouse.y > 0.0)\n    {\n        cd = 15.0 + iMouse.y / iResolution.y * 30.0;\n    }\n#endif\n\tvec3 ro = vec3(cos(ca) * cd, sin(ca) * 15.0, sin(ca) * cd);\n\tvec3 lp = ro + vec3(0.0, 10.0, 0.0);\n\tvec3 rd = camera(fragCoord, iResolution.xy, ro, vec3(0), vec3(0.5));\n\n\tfloat md = 0.0;\n\tif (march(ro, rd, 300.0, 100, 0.8, md))\n\t{\n\t\tvec3 p = ro + rd * md;\n\t\tvec3 n = getNormal(p, 0.001);\n        \n        // ambiant occluison factor\n\t\tfloat ao = getAmbiantOcclusion(p, n, 6.98795);\n\t\tfloat ratio = clamp((1.0-ao) * 3.07229, 0.0, 1.0);\n        \n        // light dir\n        vec3 ld = normalize(lp-p);\n\t\t\n        // linera interpolation fo two colors by the ao ratio\n        vec3 col = mix(vec3(0.4,0,0), vec3(0.46,0.42,0.21), vec3(ratio));\n\t\t\n        // just a simple shading for reproduce the matcaps i was using\n        // based on a cubemap here\n        vec3 refl = refract(rd, -n, 0.4);\n\t\tfloat diff = clamp( dot( n, ld ), 0.0, 1.0 );\n\t\tfloat fre = pow( clamp( 1. + dot(n,rd),0.0,1.0), 4. );\n\t\tfloat spe = pow(clamp( dot( refl, ld ), 0.0, 1.0 ),32.);\n\t\tfloat amb = 0.23; \t\n\t\tvec3 cube = texture(iChannel0, refl, 2.0).rgb;\n\t\tfloat sha = getShadow(p, ld, 0.0, 50.0, 10.0);\n\t\t\n        // lighting\n\t\tcol *= (1.0 + sha) * 0.5;\n        col += 0.25 * diff * sha;\n        col += 0.2 * ao;\n        col += 0.15 * fre;\n        col += 0.5 * cube;\n        col += 0.25 * spe;\n        \n        // gamma\n        fragColor.rgb = pow(col, vec3(5.0));\n    }\n\t\t\n    // aces (filmic) tonemap, with custom coefs\n\tfragColor.rgb = acesFilm(fragColor.rgb, 2.4, 0.1, 2.4, 0.29, 0.2);\n}\n", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float kPi = radians(180.);\nconst float k2Pi = radians(360.);\n\nmat3 scene_mtx;\n\nmat3 rotZ(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3(c, s, 0., -s, c, 0., 0., 0., 1.);\n}\n\nmat3 rotX(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3(1., 0., 0., 0.,\tc, \ts, 0., -s, c);\n}\n\nmat3 rotY(float t)\n{\n    float s = sin(t);\n    float c = cos(t);\n    return mat3 (c, 0., -s, 0., 1., 0, s, 0, c);\n}\n\nfloat map(vec3 p)\n{\n\tfloat scaleAccum = 1.;\n    for(int i = 0; i < 18; ++i)\n    {\n\t\tp.yz = sqrt(p.yz*p.yz+0.16406);\n\t\tp *= 1.21;\n\t\tscaleAccum *= 1.21;\n        p -= vec3(2.43307,5.28488,0.9685);\n        p = scene_mtx * p;\n\t}\n\t\n\treturn length(p) / scaleAccum - 0.15;\n}\n\nvec3 getNormal(vec3 p, float prec)\n{\n\tvec3 e = vec3(prec, 0, 0);\n\treturn normalize(vec3(\n\t\tmap(p+e)-map(p-e),\n\t\tmap(p+e.yxz)-map(p-e.yxz),\n\t\tmap(p+e.zyx)-map(p-e.zyx)));\n}\n\nfloat getAmbiantOcclusion(vec3 p, vec3 n, float k)\n{\t\t\t\t\n    float o = 0.0, d = 0.0;\n    for(float diff = 0.0, c = 0.0; diff < 6.0; diff+=0.1, ++c)\n    {\n        d = map(p + n * diff);\n        o += (diff - d) * pow(2., float(-c));\n    }\n    return min(1., 1. - k * o);\n}\n\nfloat getShadow(vec3 ro, vec3 rd, float minD, float maxD, float k)\n{\n    float res = 1.0;\n    float d = minD;\n\tfloat s = 0.;\n    for(int i = 0; i < 50; ++i)\n    {\n        s = map(ro + rd * d);\n        if( abs(s) < d*d*1e-5 ) return 0.0;\n        res = min( res, k * s / d );\n\t\td += s;\n        if(d >= maxD) break;\n    }\n    return res;\n}\n\nbool march(vec3 ro, vec3 rd, float far, int iters, float prec, out float md)\n{\n\tmd = 0.0;\n\tfloat d = 0.0, s = 1.0;\n\tvec3 p = ro;\n\tfor (int i=0;i<iters;i++)\n\t{\n\t\tif (abs(s)<0.001) break;\n\t\tif (d > far) return false;\n\t\ts = map(p);\n\t\td += s * prec;\n\t\tp = ro+rd*d;\n\t}\n\tmd = d;\n\treturn true;\n}\n\nvec3 camera(vec2 g, vec2 s, vec3 ro, vec3 tgt, vec3 fov)\n{\n\tvec2 uv = (g * 2.0 - s)/s.y * fov.xy; \n\tvec3 z = normalize(tgt-ro);\n\tvec3 x = normalize(cross(vec3(0,1,0),z));\n\tvec3 y = cross(z, x);\n\treturn normalize(uv.x*x+uv.y*y+z*fov.z);\n}\n\nvec3 acesFilm(const vec3 x, float a, float b, float c, float d, float e) \n{\n    return clamp((x * (a * x + b)) / (x * (c * x + d ) + e), 0.0, 1.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstyzj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[628, 628, 684, 684, 2733]], "test": "untested"}
{"id": "Nsccz2", "name": "HellProject 3", "author": "hellhand", "description": "Have it blown your mind?! :D", "tags": ["hell"], "likes": 0, "viewed": 268, "published": 3, "date": "1653704521", "time_retrieved": "2024-07-30T16:46:33.513704", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Canvas\n    vec2 uv = fragCoord/iResolution.xy;\n    float floatCanVasX = float(iResolution.x);\n    float floatCanVasY = float(iResolution.y);\n    \n    //Initial background (the rest) \n    fragColor = vec4(0., 0., 0., 1.);\n\n    //Circle\n    float radius = -170.;\n    float thickness = 10.*pow(sin(mod(float(iTime), 10.)), 2.) + 1.;\n\n    //This pixel\n    float floatThisX = float(fragCoord.x);\n    float floatThisY = float(fragCoord.y);\n\n    //Different random phases and sin^2 for [0; 1]\n    float time1 = pow(sin(float(iTime)), 2.);\n    float time2 = pow(sin(float(iTime) + 1.), 2.);\n    float time3 = pow(sin(float(iTime) + 2.), 2.);\n    \n    for (float i = 0.; i <= max(iResolution.x, iResolution.y); i+=20.){\n        if ((pow(floatThisX-floatCanVasX/2., 2.) + pow(floatThisY-floatCanVasY/2., 2.) \n            <= pow(((radius + i) + 200. * sin(float(iTime))) + thickness/2., 2.)) \n        && (pow(floatThisX-floatCanVasX/2., 2.) + pow(floatThisY-floatCanVasY/2., 2.) \n            >= pow(((radius + i) + 200. * sin(float(iTime))) - thickness/2., 2.))){\n            fragColor = vec4(time1, time2, time3, 1.0);\n        }\n    }\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nsccz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 70, 1195]], "test": "untested"}
{"id": "Nd3cz2", "name": "Enhanced Voronoi Cracks", "author": "kg", "description": "Was browsing around to see what approaches there were for cracked/shattered glass and really liked this one, so I messed with ways to improve the look a bit. Could still be much better. Use the mouse to move the center point.", "tags": ["voronoi", "glass"], "likes": 21, "viewed": 637, "published": 3, "date": "1653701130", "time_retrieved": "2024-07-30T16:46:34.274670", "image_code": "// Based on original code by by inigo quilez - iq/2013 https://www.shadertoy.com/view/ldl3W8\n// Then modified by hadyn lander (https://www.shadertoy.com/view/ll3SD2)\n// https://iquilezles.org/articles/voronoilines\n\n#define PHASE_POWER 2.0\n\nvec2 hash2( vec2 p )\n{\n    // texture based white noise\n    return texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n    \n    // procedural white noise   \n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec4 voronoi( in vec2 x )\n{\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 o;\n    //----------------------------------\n    // first pass: regular voronoi\n    //----------------------------------\n    vec2 mg, mr;\n    float oldDist;\n    \n    float md = 8.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2(float(i),float(j));\n        o = hash2( n + g );\n        vec2 r = g + o - f;\n        float d = dot(r,r);\n\n        if( d<md )\n        {\n            md = d;\n            mr = r;\n            mg = g;\n        }\n    }\n    \n    oldDist = md;\n    \n    //----------------------------------\n    // second pass: distance to borders\n    //----------------------------------\n    md = 8.0;\n    for( int j=-2; j<=2; j++ )\n    for( int i=-2; i<=2; i++ )\n    {\n        vec2 g = mg + vec2(float(i),float(j));\n        o = hash2( n + g );\n        vec2 r = g + o - f;\n\n        if( dot(mr-r,mr-r)>0.00001 )\n        md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n    }\n\n    return vec4( md, mr, oldDist );\n}\n\nvoid eval (vec2 xy, float timeStep, out vec4 c, out float cellPhase, out float edgePhase, out float phase) {\n    vec2 p = (xy/iResolution.xx);\n    p *= 16.0; // higher values zoom out further - don't go too high or the sine waves will become quite obvious...\n    vec2 unscaledPos = xy/iResolution.xy;\n    // c = (min distance, ???, ???)\n    c = voronoi( p );\n    c.x = 1.0-pow(1.0-c.x, 2.0);\n    \n    \n    float dist = length((iMouse.xy - xy) / iResolution.xy),\n        distanceScale = 0.75,\n        waveScale = 0.025,\n        // lower values will make the band of unbroken surface larger\n        bandSizeFactor = 2.0,\n        bandSizeFactor2 = 2.0,\n        // higher value = more prominent sine wave ripple\n        sineStrength = 3.0,\n        // higher value = higher sine wave frequency and weirder output\n        sineRate = 1.0,\n        // raising this value expands the wave so it covers more of the screen\n        modulus = 1.25;\n    \n    timeStep -= (dist * distanceScale);\n\n    // decreases 1->0 as cell falls away from the surface\n    float s1 = sineStrength*sin(((p.y + c.z)*0.8 + (p.x + c.y)*0.4) * sineRate);\n    cellPhase = p.x + c.y + s1;\n    cellPhase *= waveScale;\n    cellPhase = clamp(abs(mod(cellPhase -timeStep, modulus) / modulus -0.5) * bandSizeFactor, 0.0, 1.0);\n    cellPhase = pow(clamp(cellPhase*bandSizeFactor2-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    // fades smoothly 1->0 as breaking wave travels across it\n    float s2 = sineStrength*sin((p.y*0.8 + p.x*0.4) * sineRate);\n    edgePhase = p.x + s2;\n    edgePhase *= waveScale;\n    edgePhase = clamp(abs(mod(edgePhase -timeStep, modulus) / modulus -0.5) * bandSizeFactor, 0.0, 1.0);\n    edgePhase = pow(clamp(edgePhase*bandSizeFactor2-0.5, 0.0, 1.0), PHASE_POWER);\n    \n    phase = mix(edgePhase, cellPhase, smoothstep(0.0,0.2, edgePhase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float edgeSizeDivisor = 0.25, edgeAmplification = 2.2,\n        edgeSuppressionPower = 2.0;\n    // float timeStep = clamp(iTime / 2.5, 0.0, 1.525) + 2.1;\n    float timeStep = iTime / 3.0;\n    \n    float cellPhase, edgePhase, phase;\n    vec4 c;\n    eval(fragCoord.xy, timeStep, c, cellPhase, edgePhase, phase);\n\n    vec3 col, fill, bg;\n    float \n        // as the pieces first start to fall we darken the edges to create the illusion\n        //  of a shadow and distinguish them from the surface\n        edgeDarkness = (1.0 - clamp((c.x - cellPhase) / edgeSizeDivisor, 0.0, 1.0)) * cellPhase * edgeAmplification,\n        // as the piece falls away we want to stop darkening the edges\n        edgeSuppression = pow(1.0 - clamp(cellPhase, 0.0, 1.0), edgeSuppressionPower),\n        // and then we darken the entire pieces instead\n        darkness = max(edgeDarkness * edgeSuppression, cellPhase);\n\n    bg = vec3(0.0,0.33,0.5);\n    fill = mix(vec3(1, 1, 1), vec3(0, 0, 0), clamp(darkness, 0.0, 1.0));    \n    col = mix(bg, fill, smoothstep( phase-0.025, phase, c.x ) );\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3cz2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[240, 240, 262, 295, 488], [490, 490, 517, 517, 1531], [1533, 1533, 1641, 1641, 3350], [3352, 3352, 3409, 3409, 4516]], "test": "untested"}
{"id": "fd3yR2", "name": "bruh shader 2", "author": "vow", "description": "yep", "tags": ["epicswag"], "likes": 10, "viewed": 285, "published": 3, "date": "1653687869", "time_retrieved": "2024-07-30T16:46:35.071539", "image_code": "float time;\n\nfloat noise(vec2 p)\n{\n  return sin(p.x*10.) * sin(p.y*(3. + sin(time/11.))) + .2; \n}\n\nmat2 rotate(float angle)\n{\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nfloat fbm(vec2 p)\n{\n  p *= 1.1;\n  float f = 0.;\n  float amp = .5;\n  for( int i = 0; i < 3; i++) {\n    mat2 modify = rotate(time/50. * float(i*i));\n    f += amp*noise(p);\n    p = modify * p;\n    p *= 2.;\n    amp /= 2.2;\n  }\n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  q = vec2( fbm(p + vec2(1.)), fbm(rotate(.1*time)*p + vec2(1.)));\n  r = vec2( fbm(rotate(.1)*q + vec2(0.)), fbm(q + vec2(0.)));\n  return fbm(p + 1.*r);\n\n}\n\nfloat sampleFont(vec2 p, float num) {\n    float glyph[2];\n    if (num < 1.)      { glyph[0] = 0.91333008; glyph[1] = 0.89746094; }\n    else if (num < 2.) { glyph[0] = 0.27368164; glyph[1] = 0.06933594; }\n    else if (num < 3.) { glyph[0] = 1.87768555; glyph[1] = 1.26513672; }\n    else if (num < 4.) { glyph[0] = 1.87719727; glyph[1] = 1.03027344; }\n    else if (num < 5.) { glyph[0] = 1.09643555; glyph[1] = 1.51611328; }\n    else if (num < 6.) { glyph[0] = 1.97045898; glyph[1] = 1.03027344; }\n    else if (num < 7.) { glyph[0] = 0.97045898; glyph[1] = 1.27246094; }\n    else if (num < 8.) { glyph[0] = 1.93945312; glyph[1] = 1.03222656; }\n    else if (num < 9.) { glyph[0] = 0.90893555; glyph[1] = 1.27246094; }\n    else               { glyph[0] = 0.90893555; glyph[1] = 1.52246094; }\n    \n    float pos = floor(p.x + p.y * 5.);\n    if (pos < 13.) {\n        return step(1., mod(pow(2., pos) * glyph[0], 2.));\n    } else {\n        return step(1., mod(pow(2., pos-13.) * glyph[1], 2.));\n    }\n}\n\nfloat digit(vec2 p){\n    p -= vec2(0.5, 0.5);\n    p *= (1.+0.15*pow(length(p),0.6));\n    p += vec2(0.5, 0.5);\n    \n    p.x += sin(iTime/7.)/5.;\n    p.y += sin(iTime/13.)/5.;\n        \n    vec2 grid = vec2(3.,1.) * 15.;\n    vec2 s = floor(p * grid) / grid;\n    p = p * grid;\n    vec2 q;\n    vec2 r;\n    float intensity = pattern(s/10., q, r)*1.3 - 0.03 ;\n    p = fract(p);\n    p *= vec2(1.2, 1.2);\n    float x = fract(p.x * 5.);\n    float y = fract((1. - p.y) * 5.);\n    vec2 fpos = vec2(floor(p.x * 5.), floor((1. - p.y) * 5.));\n    float isOn = sampleFont(fpos, floor(intensity*10.));\n    return p.x <= 1. && p.y <= 1. ? isOn * (0.2 + y*4./5.) * (0.75 + x/4.) : 0.;\n}\n\nfloat hash(float x){\n    return fract(sin(x*234.1)* 324.19 + sin(sin(x*3214.09) * 34.132 * x) + x * 234.12);\n}\n\nfloat onOff(float a, float b, float c)\n{\n\treturn step(c, sin(iTime + a*cos(iTime*b)));\n}\n\nfloat displace(vec2 look)\n{\n    float y = (look.y-mod(iTime/4.,1.));\n    float window = 1./(1.+50.*y*y);\n\treturn sin(look.y*20. + iTime)/80.*onOff(4.,2.,.8)*(1.+cos(iTime*60.))*window;\n}\n\nvec3 getColor(vec2 p){\n    \n    float bar = mod(p.y + time*20., 1.) < 0.2 ?  1.4  : 1.;\n    p.x += displace(p);\n    float middle = digit(p);\n    float off = 0.002;\n    float sum = 0.;\n    for (float i = -1.; i < 2.; i+=1.){\n        for (float j = -1.; j < 2.; j+=1.){\n            sum += digit(p+vec2(off*i, off*j));\n        }\n    }\n    return vec3(0.9)*middle + sum/10.*vec3(0.,1.,0.) * bar;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime / 3.;\n    vec2 p = fragCoord / iResolution.xy;\n    float off = 0.0001;\n    vec3 col = getColor(p);\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3yR2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 34, 34, 97], [99, 99, 125, 125, 191], [194, 194, 213, 213, 430], [432, 432, 479, 479, 635], [637, 637, 674, 674, 1632], [1634, 1634, 1654, 1654, 2301], [2303, 2303, 2323, 2323, 2413], [2415, 2415, 2455, 2455, 2503], [2505, 2505, 2532, 2532, 2691], [2693, 2693, 2715, 2715, 3086], [3088, 3088, 3145, 3145, 3292]], "test": "untested"}
{"id": "NsccRj", "name": "Integration over a single step", "author": "Mytino", "description": "Integration over a single step", "tags": ["integration"], "likes": 0, "viewed": 24, "published": 3, "date": "1653684785", "time_retrieved": "2024-07-30T16:46:35.827518", "image_code": "// From forked shader:\n// Subpixels antialiased arrow fields\n// Nicolas P. Rougier (http://www.loria.fr/~rougier)\n// Released under BSD license.\n//\n// Inspired by by \"2D vector field visualization\" by Morgan McGuire\n// (https://www.shadertoy.com/view/4s23DG)\n\n// ARROW VISUALS BEGIN\n#define ROWS 16.0\n#define COLS 16.0\nvec4 filled(float distance, float linewidth, float antialias, vec4 fill) {\n    vec4 frag_color;\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n\n    // Within linestroke\n    if( border_distance < 0.0 )\n        frag_color = fill;\n    // Within shape\n    else if( signed_distance < 0.0 )\n        frag_color = fill;\n    else\n        // Outside shape\n        if( border_distance > (linewidth/2.0 + antialias) )\n            frag_color = vec4(0.0);\n        else // Line stroke exterior border\n            frag_color = vec4(fill.rgb*alpha, 1.0);\n\n    return frag_color;\n}\nfloat segment_distance(vec2 p, vec2 p1, vec2 p2) {\n    vec2 center = (p1 + p2) * 0.5;\n    float len = length(p2 - p1);\n    vec2 dir = (p2 - p1) / len;\n    vec2 rel_p = p - center;\n    float dist1 = abs(dot(rel_p, vec2(dir.y, -dir.x)));\n    float dist2 = abs(dot(rel_p, dir)) - 0.5*len;\n    return max(dist1, dist2);\n}\nvec4 circle_from_2_points(vec2 p1, vec2 p2, float radius)\n{\n    float q = length(p2-p1);\n    vec2 m = (p1+p2)/2.0;\n    vec2 d = vec2( sqrt(radius*radius - (q*q/4.0)) * (p1.y-p2.y)/q,\n                   sqrt(radius*radius - (q*q/4.0)) * (p2.x-p1.x)/q);\n    return  vec4(m+d, m-d);\n}\nfloat arrow_curved(vec2 texcoord,\n                   float body, float head,\n                   float linewidth, float antialias)\n{\n    float w = linewidth/2.0 + antialias;\n    vec2 start = -vec2(body/2.0, 0.0);\n    vec2 end   = +vec2(body/2.0, 0.0);\n    float height = 0.5;\n\n    vec2 p1 = end - head*vec2(+1.0,+height);\n    vec2 p2 = end - head*vec2(+1.0,-height);\n    vec2 p3 = end;\n\n    // Head : 3 circles\n    vec2 c1  = circle_from_2_points(p1, p3, 1.25*body).zw;\n    float d1 = length(texcoord - c1) - 1.25*body;\n    vec2 c2  = circle_from_2_points(p2, p3, 1.25*body).xy;\n    float d2 = length(texcoord - c2) - 1.25*body;\n    vec2 c3  = circle_from_2_points(p1, p2, max(body-head, 1.0*body)).xy;\n    float d3 = length(texcoord - c3) - max(body-head, 1.0*body);\n\n    // Body : 1 segment\n    float d4 = segment_distance(texcoord, start, end - vec2(linewidth,0.0));\n\n    // Outside (because of circles)\n    if( texcoord.y > +(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.y < -(2.0*head + antialias) )\n         return 1000.0;\n    if( texcoord.x < -(body/2.0 + antialias) )\n         return 1000.0;\n    if( texcoord.x > c1.x ) //(body + antialias) )\n         return 1000.0;\n\n    return min( d4, -min(d3,min(d1,d2)));\n}\n// ARROW VISUALS END\n\n// Velocity field function\nvec2 getVelocity(vec2 pos, vec2 res) {\n    pos = 6.0 * (pos / res - 0.5) * vec2(res.x / res.y, 1.0);\n    pos /= length(pos);\n    return vec2(-pos.y, pos.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const float M_PI = 3.14159265358979323846;\n    const float SQRT_2 = 1.4142135623730951;\n    const float linewidth = 2.0;\n    const float antialias =  1.0;\n\n    vec2 res = iResolution.xy;\n    float body = min(iResolution.x/COLS, iResolution.y/ROWS) / SQRT_2;\n    vec2 texcoord = fragCoord.xy;\n    vec2 size   = iResolution.xy / vec2(COLS,ROWS);\n    vec2 center = (floor(texcoord/size) + vec2(0.5,0.5)) * size;\n    texcoord -= center;\n\n    vec2 vR = getVelocity(center, res);\n    vR.y *= -1.0;\n    texcoord = vec2(vR.x*texcoord.x - vR.y*texcoord.y,\n                    vR.y*texcoord.x + vR.x*texcoord.y);\n    float d = arrow_curved(texcoord, body, 0.25*body, linewidth, antialias);\n\n    fragColor = filled(d, linewidth, antialias, vec4(1,1,1,1));\n    fragColor.rgb *= 0.35;\n    \n    //// NEW STUFF:\n    \n    float dt = 50.0;\n    float flip = float(iMouse.z <= 0.5) * 2.0 - 1.0;\n    dt *= mod(iTime, 10.0) * flip;\n    vec2 delta = iResolution.xy * vec2(-0.1, 0.25);\n    vec2 forwardPos = vec2(iResolution.xy * 0.5 + delta);\n    vec2 pos = forwardPos;\n    \n    vec2 s1 = pos;\n    vec2 v1 = getVelocity(s1, res);\n    vec2 s2 = pos + 0.5 * v1 * dt;\n    vec2 v2 = getVelocity(s2, res);\n    vec2 s3 = pos + 0.5 * v2 * dt;\n    vec2 v3 = getVelocity(s3, res);\n    vec2 s4 = pos + v3 * dt;\n    vec2 v4 = getVelocity(s4, res);\n    \n    vec2 posEuler = pos + v1 * dt;\n    vec2 posMidpoint = pos + v2 * dt;\n    vec2 posRk4 = pos + ((v1 + 2.0 * v2 + 2.0 * v3 + v4) / 6.0) * dt;\n    \n    float dist = length(res*0.5 - fragCoord.xy);\n    fragColor = mix(fragColor, vec4(1, 1, 0, 1.0)*0.4, float(dist > length(delta) - 0.5 && dist < length(delta) + 0.5));\n    \n    if (iMouse.z > 0.5) {\n        \n        pos = fragCoord.xy;\n        \n        s1 = pos;\n        v1 = getVelocity(s1, res);\n        s2 = pos + 0.5 * v1 * dt;\n        v2 = getVelocity(s2, res);\n        s3 = pos + 0.5 * v2 * dt;\n        v3 = getVelocity(s3, res);\n        s4 = pos + v3 * dt;\n        v4 = getVelocity(s4, res);\n        \n        posEuler = pos + v1 * dt;\n        posMidpoint = pos + v2 * dt;\n        posRk4 = pos + ((v1 + 2.0 * v2 + 2.0 * v3 + v4) / 6.0) * dt;\n    \n        // Visualize flow map VFX\n        if (iMouse.x/res.x > 0.75) {\n            fragColor.r += texture(iChannel0, posEuler.xy / res).r * 0.5;\n            fragColor.gb += texture(iChannel0, posRk4.xy / res).gg * 1.0;\n        } else if (iMouse.x/res.x > 0.5) {\n            fragColor.rgb += texture(iChannel0, posRk4.xy / res).rgb * 0.5;\n        } else if (iMouse.x/res.x > 0.25) {\n            fragColor.rgb += texture(iChannel0, posMidpoint.xy / res).rgb * 0.5;\n        } else {\n            fragColor.rgb += texture(iChannel0, posEuler.xy / res).rgb * 0.5;\n        }\n        \n        // Show how the start positions appear to move when this backward approach is used.\n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(posEuler - forwardPos) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(posMidpoint - forwardPos) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(posRk4 - forwardPos) < 7.0));\n        \n    } else {\n    \n        fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(posEuler - fragCoord.xy) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(posMidpoint - fragCoord.xy) < 7.0));\n        fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(posRk4 - fragCoord.xy) < 7.0));\n\n        if (iMouse.x > res.x / 3.0) {\n            fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(length(s1 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(length(s2 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 0.0, 0.6, 1.0), float(length(s3 - fragCoord.xy) < 3.0));\n            fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(length(s4 - fragCoord.xy) < 3.0));\n\n            if (iMouse.x > res.x / 3.0 * 2.0) {\n                fragColor = mix(fragColor, vec4(1.0, 0.0, 0.0, 1.0), float(abs(length(s1 + v1*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 1.0, 0.0, 1.0), float(abs(length(s2 + v2*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 0.0, 0.6, 1.0), float(abs(length(s3 + v3*dt - fragCoord.xy) - 6.0) < 2.0));\n                fragColor = mix(fragColor, vec4(0.0, 0.3, 1.0, 1.0), float(abs(length(s4 + v4*dt - fragCoord.xy) - 6.0) < 2.0));\n            }\n\n        }\n    }\n    \n    //fragColor = vec4(fragCoord.xy / iResolution.xy, 0.0, 1.0);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsccRj.jpg", "access": "api", "license": "bsd-new", "functions": [[319, 319, 393, 393, 1044], [1045, 1045, 1095, 1095, 1362], [1363, 1363, 1422, 1422, 1644], [1645, 1645, 1776, 1776, 2883], [2906, 2933, 2971, 2971, 3091], [3093, 3093, 3150, 3150, 7749]], "test": "untested"}
{"id": "7dBBRG", "name": "reaction diffusion + lighting", "author": "ml", "description": "basic reaction diffusion. Move the mouse to change the lighting direction.", "tags": ["lighting", "reactiondiffusion"], "likes": 5, "viewed": 241, "published": 3, "date": "1653684772", "time_retrieved": "2024-07-30T16:46:36.586489", "image_code": "vec3 lightColor = vec3(1.);\n\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos(TAU*(c*t+d) );\n}\n\nvec3 palette1(float t){\n    return palette(t, vec3(0.8, 0.5, 0.4), vec3(0.2, 0.4, 0.2), vec3(2.0, 1.0, 1.0), vec3(0.00, 0.25, 0.25));\n}\n\nvec3 palette2(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(1.0, 1.0, 1.0), vec3(0.00, 0.33, 0.67));\n}\n\nvec3 palette3(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.50, 0.20, 0.25));\n}\n\nvec3 palette4(float t){\n    return palette(t, vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5), vec3(2.0, 1.0, 0.0), vec3(0.6627, 0.9411, 0.8196));\n}\n\nvec3 palette5(float t){\n     return vec3(1., pow(cos(t*TAU*1.), 2.)*0.8+0.2, pow(cos(t*TAU*0.5), 2.));\n}\n\nvec3 palette6(float t){\n    return vec3(smoothstep(0.55, 0.45, t)*0.8 +0.06);\n}\n\nvec3 getColour(float depth, vec2 uv){\n    \n    return palette6(depth);\n}\n\nfloat getDepth(vec2 uv){\n    vec4 values = texture(iChannel0, uv);\n    float a = values.x;\n    float b = values.y;\n    float depth = a-b;\n    return depth;\n}\n\n//https://www.shadertoy.com/view/XlGBW3\nvec3 getNormal(vec2 uv) {\n    vec3 p = vec3(uv, 0.);\n    vec2 e = vec2(1./iResolution.y, 0);//vec2(.0001, 0);\n    float d = getDepth(uv+e.xy);\n\n    vec3 normal = d - vec3(\n        getDepth(uv-e.xy),\n        getDepth(uv-e.yx),\n        -1.\n    );\n    \n    return normalize(normal);\n}\n\nvec3 getLightDir(vec2 uv){\n    vec3 lightPos = vec3(iMouse.xy/iResolution.xy*1., 0.2);\n\n    vec3 fragPos = vec3(uv, 0.);\n    vec3 lightDir = vec3(lightPos.xy-vec2(0.5, 0.5), 0.5); \n    //vec3 lightDir = lightPos - fragPos;\n    lightDir = normalize(lightDir);\n    return lightDir;\n}\n\n//https://learnopengl.com/Lighting/Basic-Lighting\nvec3 getAmbient(vec2 uv){\n    float ambientStrength = 0.1;\n    vec3 ambient = ambientStrength * lightColor;\n    return ambient;\n}\n\nvec3 getDiffuse(vec2 uv){\n    \n    float diff = dot(getNormal(uv), getLightDir(uv)); \n    //diff = max(diff, 0.);\n    vec3 diffuse = diff * lightColor;\n    return diffuse;\n}\n\nvec3 getSpecular(vec2 uv){\n\n    float specularStrength = 10.;\n\n    //vec3 viewPos = vec3(uv, 1.);\n    //vec3 fragPos = vec3(uv, 0.);\n    //vec3 viewDir = normalize(viewPos - FragPos);\n    vec3 viewDir = vec3(0., 0., 1.);\n    \n    vec3 reflectDir = reflect(-getLightDir(uv), getNormal(uv));  \n    \n    float spec = pow(max(dot(viewDir, reflectDir), 0.0), 256.);\n    \n    vec3 specular = specularStrength * spec * lightColor; \n    \n    return specular;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*0.4;\n    //uv.x *= iResolution.x/iResolution.y;\n   \n\n    float depth = getDepth(uv);\n    \n    vec3 normal = getNormal(uv);\n    \n    vec3 cool = normal*depth*0.8+depth*0.7;\n    vec3 c = vec3(length(cool));\n    \n \n    vec3 lightness = getDiffuse(uv) + getAmbient(uv)+ getSpecular(uv);\n    vec3 colour = getColour(depth,uv);\n    // Output to screen\n    fragColor = vec4(vec3(colour*lightness), 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define D_A 1.\n#define D_B 0.5\n#define F 0.055\n#define K 0.062\n#define T_STEP 0.5\n\n\n\n\nconst float weights[9] = float[9](\n    .05,0.2,.05,\n    0.2, -1., 0.2,\n    .05,0.2,.05\n);\n\nvec4 laplacian(vec2 fragCoord){\n\n    vec4 weightedLevels = vec4(0.);\n    for(int i = 0; i < 9; i++){\n        int dx = i%3-1;\n        int dy = i/3-1;\n        vec2 uv = (fragCoord + vec2(dx, dy))/iResolution.xy;\n\n        weightedLevels += weights[i] * texture(iChannel0, uv);\n\n\n    }\n    \n    return weightedLevels;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    vec4 levels = texture(iChannel0, uv);\n    \n    float a = levels.x;\n    float b = levels.y;\n   \n    vec4 weightedLevels = laplacian(fragCoord);\n    \n    //https://www.karlsims.com/rd.html\n    \n    float aChange = (D_A * weightedLevels.x - a * b * b + F * (1.-a))*T_STEP; \n    \n    float bChange = (D_B * weightedLevels.y + a * b * b - (F+K) *b)*T_STEP; \n    \n    float newA = a + aChange;\n    float newB = b + bChange;\n    \n    if(iFrame < 10){\n        newA = 0.5+hash12(uv*100.)*0.8;\n        newB = step(0.5, hash12(floor(uv*50.) + vec2(10., 16.23)));\n    };\n    \n    fragColor = vec4(newA, newB,1.0,1.0);\n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define TAU 6.28318530718\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dBBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 102, 102, 140], [142, 142, 165, 165, 277], [279, 279, 302, 302, 414], [416, 416, 439, 439, 551], [553, 553, 576, 576, 694], [696, 696, 719, 719, 800], [802, 802, 825, 825, 881], [883, 883, 920, 920, 955], [957, 957, 981, 981, 1114], [1116, 1156, 1181, 1181, 1437], [1439, 1439, 1465, 1465, 1720], [1722, 1772, 1797, 1797, 1901], [1903, 1903, 1928, 1928, 2076], [2078, 2078, 2104, 2104, 2530], [2532, 2532, 2589, 2639, 3076]], "test": "untested"}
{"id": "fd3cRj", "name": "shamana", "author": "vow", "description": "fo shamana", "tags": ["display"], "likes": 2, "viewed": 191, "published": 3, "date": "1653680587", "time_retrieved": "2024-07-30T16:46:37.611747", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//\tsdSegment from iq -- https://www.shadertoy.com/view/Xlf3zl \nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b ) {\n\tvec2 pa = p - a, ba = b - a;\n\treturn length( pa - ba * clamp( dot( pa, ba ) / dot( ba, ba ), 0.0, 1.0 ) );\n}\n\nfloat segment_dist( vec2 p, vec4 s ) {\n\treturn sdSegment( p, s.xy, s.zw );\n}\n\nfloat abc[26];\n\nvoid init_abc() {\n\tabc[0]\t= .949951171875;\t\tabc[1]\t= .863037109375;\t\tabc[2]\t= .80859375;\t\t\tabc[3]\t= .800537109375;\n\tabc[4]\t= .93359375;\t\t\tabc[5]\t= .88671875;\t\t\tabc[6]\t= .871337890625;\t\tabc[7]\t= .199951171875;\n\tabc[8]\t= .7998046875;\t\t\tabc[9]\t= .051513671875;\t\tabc[10] = .1367950439453125;\tabc[11] = .05859375;\n\tabc[12] = .01263427734375;\t\tabc[13] = .0125885009765625;\tabc[14] = .809326171875;\t\tabc[15] = .94970703125;\n\tabc[16] = .8093414306640625;\tabc[17] = .9497222900390625;\tabc[18] = .992431640625;\t\tabc[19] = .7529296875;\n\tabc[20] = .059326171875;\t\tabc[21] = .011810302734375;\t\tabc[22] = .0124969482421875;\tabc[23] = .0002288818359375;\n\tabc[24] = .19677734375;\t\t\tabc[25] = .796966552734375;\n}\n\nfloat get_abc( float i ) {\n\treturn\ti < 16. ?\t( i < 8. ?\t( i < 4. ?\t( i < 2. ?\t( i <  1. ? abc[ 18] : abc[ 7] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i <  3. ? abc[ 0] : abc[ 12] ) ) :\n\t\t\t\t\t\t\t\t\t\t\t\t( i < 6. ?\t( i <  5. ? abc[ 0] : abc[ 13] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i <  7. ? abc[ 0] : abc[ 0] ) ) ) :\n\t\t\t\t\t\t\t\t\t( i < 12. ?\t( i < 10. ?\t( i <  9. ? abc[ 18] : abc[ 7] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i < 11. ? abc[ 0] : abc[ 12] ) ) :\n\t\t\t\t\t\t\t\t\t\t\t\t( i < 14. ?\t( i < 13. ? abc[ 0] : abc[ 13] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i < 15. ? abc[ 0] : abc[ 0]  ) ) ) ) :\n\t\t\t\t\t\t( i < 24. ?\t( i < 20. ?\t( i < 18. ?\t( i < 17. ? abc[18] : abc[ 7] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i < 19. ? abc[ 0] : abc[12] ) ) :\n\t\t\t\t\t\t\t\t\t\t\t\t( i < 22. ?\t( i < 21. ? abc[ 0] : abc[13] ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i < 23. ? abc[ 0] : abc[ 0] ) ) ) :\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t( i < 25. ? abc[ 0] : abc[ 0] ) );\n}\n\nvec4 sgmt[16];\nvec2 sk = vec2( 2. );\t//\tvec2( 2.5, 2.25 ) for stone age\n\nvoid init_segments( vec4 r ) {\n\tvec2 a=r.xy, c=r.zy, b=(a+c)/2., g=r.xw, d=(a+g)/sk.x, i=r.zw, e=(a+i)/sk.y, f=(c+i)/2., h=(g+i)/2.;\n\tsgmt[ 0]=vec4(a,b); sgmt[ 1]=vec4(b,c); sgmt[ 2]=vec4(d,e); sgmt[ 3]=vec4(e,f);\n\tsgmt[ 4]=vec4(g,h); sgmt[ 5]=vec4(h,i); sgmt[ 6]=vec4(a,d); sgmt[ 7]=vec4(d,g);\n\tsgmt[ 8]=vec4(b,e); sgmt[ 9]=vec4(e,h); sgmt[10]=vec4(c,f); sgmt[11]=vec4(f,i);\n\tsgmt[12]=vec4(a,e); sgmt[13]=vec4(c,e); sgmt[14]=vec4(e,g); sgmt[15]=vec4(e,i);\n}\n\nvoid init_segments( vec2 r ) {\n\tinit_segments( vec4( 0., r.y, r.x, 0. ) );\n}\n\nvec3 segment_display( vec2 p, float a, float line_width, vec3 color ) {\n\tfloat d = iResolution.x, s = .5, pixel_size = 1., c = mod( iTime * 3. / 26., 3. );\n\tfor ( int i = 0 ; i < 16 ; i++ ) {\n\t\tif ( a >= s ) {\n\t\t\td = min( d, segment_dist( p, sgmt[i] ) );\n\t\t\ta -= s;\n\t\t}\n\t\ts *= .5;\n\t}\n    if ( c <= 1. ) {\n        return mix( vec3( 0. ), color, 1. - ( d - line_width ) * 2. / ( line_width * pixel_size  ) );\n    } else if ( c <= 2. ) {\n        return mix( vec3( 0. ), color, 1. - ( d - line_width ) * 2. / ( line_width * pixel_size  ) )\n        \t+ color * 1e3 / ( d * d );\n    } else {\n    \treturn color * 2e1 * line_width * line_width / ( d * d );\n    }\n}\n\nvec3 my_main( vec2 p ) {\n    vec2 gr = vec2( 2., 1. + sqrt( 5. ) );\t//\tgolden ratio\n    float m = .1 * iResolution.y;\n\n\tinit_abc();\n\tinit_segments( floor( m * gr ) );\n\treturn segment_display( floor( p + m - iResolution.xy / 2. ), \n                        \tget_abc( mod( iTime * 3., 26. ) ), \n                            floor( m  / 1e1 ),\n                          \tvec3( 1., fract( p / 3. ) * vec2( .35, .55 ) ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor.rgb = my_main( floor( fragCoord.xy ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3cRj.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[127, 190, 242, 242, 352], [354, 354, 392, 392, 430], [448, 448, 465, 465, 1143], [1145, 1145, 1171, 1171, 1945], [2020, 2020, 2050, 2050, 2478], [2480, 2480, 2510, 2510, 2556], [2558, 2558, 2629, 2629, 3213], [3215, 3215, 3239, 3239, 3632], [3634, 3634, 3691, 3691, 3744]], "test": "untested"}
{"id": "fs3yRj", "name": "Pixel Plotter 2", "author": "SnoopethDuckDuck", "description": "A bit messy and overcomplicated,  I think will be very useful for pixel art detailing + outlines", "tags": ["feedback", "cellularautomata"], "likes": 3, "viewed": 255, "published": 3, "date": "1653679276", "time_retrieved": "2024-07-30T16:46:38.397646", "image_code": "#define pi 3.14159\n\nvec3 pal(float t, vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 0.225; \n    vec2 res = floor(iResolution.xy);    \n   \n    vec2 f = fragCoord;//mod(fragCoord, res);\n    \n    vec3 col = texelFetch( iChannel0, ivec2(zm * f + 0.5 * (1.-zm) * res), 0).rgb;\n    vec2 f2 = vec2(res.x-f.x, f.y);\n    vec3 col2 = texelFetch( iChannel0, ivec2(zm * f2 + 0.5 * (1.-zm) * res), 0).rgb;\n    \n    col = max(col, col2);\n\n    if (col.b == 1. && col.g == 0.)\n        col = vec3(0,0,1);\n    else if (col.g == 1.)\n        col = vec3(1);\n   // col.b = 0.;\n   // if (col.b == 1.)\n    //    col = vec3(0.25);\n    \n    col = 1. - col;\n    vec3 pcol = pal(1.25 + 0.75 * uv.y, 0.5 * vec3(2,1,3)/3.);\n    col = mix(col, pcol, 0.25);\n    \n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nvec4 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 );\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nfloat gs(ivec2 px) {\n    float b = cell(px - ivec2(0,1)).g;\n    float t = cell(px + ivec2(0,1)).g;\n    float l = cell(px - ivec2(1,0)).g;\n    float r = cell(px + ivec2(1,0)).g;   \n    float bl = cell(px + ivec2(-1,-1)).g;\n    float br = cell(px + ivec2(1, -1)).g;\n    float tl = cell(px + ivec2(-1, 1)).g;\n    float tr = cell(px + ivec2(1,  1)).g; \n    return b + t + l + r + bl + br + tl + tr;\n}\n\n//get rand\nfloat gr(vec2 f) {\n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    return texelFetch(iChannel2, g, 0).r;\n}\n\n//check rand (others)\nbool cr(vec2 f) {\n    float v = gr(f+vec2(1,1)) + \n              gr(f+vec2(0,1)) + \n              gr(f+vec2(-1,1)) + \n              gr(f+vec2(-1,0)) + \n              gr(f+vec2(-1,-1)) + \n              gr(f+vec2(0,-1)) + \n              gr(f+vec2(1,-1)) + \n              gr(f+vec2(1,0)) + \n              gr(f+vec2(2,0)) + \n              gr(f+vec2(-2,0)) + \n              gr(f+vec2(0,2)) + \n              gr(f+vec2(0,-2));\n    return v <= 5.;\n}\n\n#define w 40.\n#define h 40.\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    col = vec4(0);\n\n    ivec2 px = ivec2(f);\n    int frame = iFrame % 240;\n    \n    ivec2 g = ivec2(f - vec2(cos(0.1 * iTime),sin(iTime)) * 512.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n    \n    if (frame == 0 || key_down(KEY_RESET)) {      \n        return;\n    }\n           \n    // Center cell\n    col = cell(px);\n    \n    // Neighbour cells\n    float b = cell(px - ivec2(0,1)).g;\n    float t = cell(px + ivec2(0,1)).g;\n    float l = cell(px - ivec2(1,0)).g;\n    float r = cell(px + ivec2(1,0)).g;   \n    float bl = cell(px + ivec2(-1,-1)).g;\n    float br = cell(px + ivec2(1, -1)).g;\n    float tl = cell(px + ivec2(-1, 1)).g;\n    float tr = cell(px + ivec2(1,  1)).g;   \n    \n    float bb = cell(px - ivec2(0,2)).g;\n    float tt = cell(px + ivec2(0,2)).g;\n    float ll = cell(px - ivec2(2,0)).g;\n    float rr = cell(px + ivec2(2,0)).g;   \n    \n    float ttl = cell(px + ivec2(-1, 2)).g;\n    float ttr = cell(px + ivec2(1,  2)).g;\n    float bbl = cell(px + ivec2(-1,-2)).g;\n    float bbr = cell(px + ivec2(1, -2)).g;       \n    float tll = cell(px + ivec2(-2, 1)).g;\n    float trr = cell(px + ivec2(2,  1)).g;\n    float bll = cell(px + ivec2(-2,-1)).g;\n    float brr = cell(px + ivec2(2, -1)).g;\n    \n    float ttll = cell(px + ivec2(-2, 2)).g;\n    float ttrr = cell(px + ivec2(2,  2)).g;\n    float bbll = cell(px + ivec2(-2,-2)).g;\n    float bbrr = cell(px + ivec2(2, -2)).g;\n    \n    float sum = b + t + l + r;\n    float diag = bl + br + tl + tr;\n    float dif = abs(b-t) * abs(l-r);\n \n    float th = 0.9;\n    \n    vec2 res = floor(0.5 * iResolution.xy);\n    \n   \n    g = ivec2(f - vec2(cos(0.5 * iTime),sin(0.1 * iTime)) * 512.) & 1023;\n    float rand2 = texelFetch(iChannel2, g, 0).r;\n    bool rnd = 0.9 < rand2;\n    \n    bool dt = f.y <= res.y + h || rnd;\n    bool db = f.y >= res.y - h || rnd;\n    bool dr = f.x <= res.x + w || rnd;\n   \n    //f.x < res.x + w && f.y < res.y + h && \n    if (frame < 180) {\n    if (sum + diag == 1. && rand >= th && f.x > res.x) {\n        if ((db&&     t ==1. && gs(px + ivec2(0,  1)) == 1. && (ttl==1. || tt==1.   || ttr==1.)) ||\n            (dt&&     b ==1. && gs(px - ivec2(0,  1)) == 1. && (bbl==1. || bb==1.   || bbr==1.)) ||\n            (dr&&     l ==1. && gs(px - ivec2(1,  0)) == 1. && (bll==1. || ll==1.   || tll==1.)) ||\n            (         r ==1. && gs(px + ivec2(1,  0)) == 1. && (brr==1. || rr==1.   || trr==1.)) ||\n            (db&&dr&& tl==1. && gs(px + ivec2(-1, 1)) == 1. && (tll==1. || ttll==1. || ttl==1.)) ||\n            (db&&     tr==1. && gs(px + ivec2(1,  1)) == 1. && (trr==1. || ttrr==1. || ttr==1.)) ||\n            (dt&&dr&& bl==1. && gs(px + ivec2(-1,-1)) == 1. && (bll==1. || bbll==1. || bbl==1.)) ||\n            (dt&&     br==1. && gs(px + ivec2(1, -1)) == 1. && (brr==1. || bbrr==1. || bbr==1.)) ) {\n            col.g = 1.;\n        } \n        //else if (f.x < res.x + w && f.y >= res.y + h && \n    }\n    if (dif == 1.)// && sum + diag == 1.)\n        col.g = 0.;\n    }\n    if (frame == 180) {\n        if (col.g == 0. && sum == 2. || sum == 1.)\n            col.b = 1.;\n    }\n        \n    vec2 v2 = abs(f - vec2(5,0)-res-0.5);\n    if (v2.x < 2. && v2.y < 1.)\n        col.g = 1.;   \n    \n    vec2 v = abs(f -res-0.5);\n    if (v.x < w && v.y < h)\n        col.r = 1.;\n       \n   //rr col = vec4(step(0.99, rand)) * 10.;\n}\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3yRj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 102], [104, 104, 161, 161, 921]], "test": "untested"}
{"id": "7ddcW7", "name": "Visceral Infection", "author": "tqs", "description": "Itchy throat? :D\nBased on shane's Desert Canyon https://www.shadertoy.com/view/Xs33Df", "tags": ["raymarching", "tunnel", "organic", "bio", "pebbles"], "likes": 32, "viewed": 639, "published": 3, "date": "1653668772", "time_retrieved": "2024-07-30T16:46:39.182547", "image_code": "/*\n    Based on:\n\tDesert Canyon by shane\n\thttps://www.shadertoy.com/view/Xs33Df\n    \n    I removed shane's comments to avoid passing them as my own. (I have no idea what I'm doing). \n    Please refer to shane's shader for extensive comments.\n*/\n\n\n#define FAR 125.\n\n#define RM_STEPS 128\n\nconst float freqA = .15/3.75;\nconst float freqB = .25/2.75;\nconst float ampA = 20.;\nconst float ampB = 2.;\n\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\nfloat getGrey(vec3 p){ return dot(p, vec3(0.299, 0.587, 0.114)); }\n\nfloat sminP(float a, float b , float s){\n    \n    float h = clamp(.5 + .5*(b - a)/s, 0., 1.);\n    return mix(b, a, h) - h*(1.0-h)*s;\n}\n\nfloat smaxP(float a, float b, float s){\n    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\nvec2 path(in float z){ \n\n    return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB) + 5.*(sin(z*0.025)  - 5.)); \n}\n\nfloat map(in vec3 p){\n    \n    float tx = (-textureLod(iChannel0, p.xz/22. + p.xy/80., 0.).x-0.4) * 0.95;\n    \n    vec3 q = sin(p.zyx*.2 - (0.5+tx)*0.5 + iTime*0.13)*sminP(5.0, pow((0.5-tx)*5.5, 0.22), 3.);\n    \n    float h = q.x*q.y*q.z;\n  \n    p.xy -= path(p.z);\n    \n    float tnl = 2.0 - length(p.xy*vec2(.33, .66))*0.5 + h * 0.4 + (1. - tx)*.25;\n    \n    return tnl - tx*.5 + tnl*0.3; \n}\n\nfloat getprot(in vec3 p){\n    \n    float tx = (-textureLod(iChannel0, p.xz/22. + p.xy/80., 0.).x-0.4) * 0.95;\n    \n    vec3 q = sin(p.zyx*.2 - (0.5+tx)*0.5 + iTime*0.13)*sminP(5.0, pow((0.5-tx)*5.5, 0.22), 3.);\n    \n    return q.x*q.y*q.z;// + (1. - tx)*.25- tx*.5; \n}\n\n// Log-Bisection Tracing\n// https://www.shadertoy.com/view/4sSXzD\n//\n// Log-Bisection Tracing by nimitz (twitter: @stormoid)\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Contact: nmz@Stormoid.com\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd){\n\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro);\n    float sgn = sign(d);\n\n    for (int i=0; i<RM_STEPS; i++){\n\n        if (sign(d) != sgn || d < 0.001 || t > FAR) break;\n \n        told = t;\n           \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \n        d = map(rd*t + ro);\n    }\n    \n    if (sign(d) != sgn){\n\n        dn = sign(map(rd*told + ro));\n        \n        vec2 iv = vec2(told, t); \n\n        for (int ii=0; ii<8; ii++){ \n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro);\n            if (abs(d) < 0.001)break;\n\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid; \n    }\n    \n    return min(t, FAR);\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max(n*n, .001);\n    n /= (n.x + n.y + n.z );  \n    \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\nvec3 doBumpMap( sampler2D tex, in vec3 p, in vec3 nor, float bumpfactor){\n   \n    const float eps = .001;\n    vec3 grad = vec3( getGrey(tex3D(tex, vec3(p.x - eps, p.y, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y - eps, p.z), nor)),\n                      getGrey(tex3D(tex, vec3(p.x, p.y, p.z - eps), nor)));\n    \n    grad = (grad - getGrey(tex3D(tex, p, nor)))/eps; \n            \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize(nor + grad*bumpfactor);\n}\n\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n\n    for(float i=1.; i< nbIte+.5; i++){\n    \n        l = (i + hash(i))*.5/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l))/(1. + l);\n    }\n\t\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n\nfloat curve(in vec3 p){\n\n    const float eps = .05, amp = 4., ampInit = .5;\n\n    vec2 e = vec2(-1, 1)*eps; \n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return clamp((t1 + t2 + t3 + t4 - 4.*map(p))*amp + ampInit, 0., 1.);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n\tvec2 u = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\tvec3 lookAt = vec3(0, 0, 18.+iTime*1.9);\n\tvec3 ro = lookAt + vec3(0, .0, -.25);\n\n\tlookAt.xy += path(lookAt.z);\n\tro.xy += path(ro.z);\n\n    float FOV = 3.14159/1.5; \n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n    vec3 up = cross(forward, right);\n\n    vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n    \n\trd.xy = rot2( path(lookAt.z).x/64. )*rd.xy;\n    \n    vec3 lp = vec3(FAR*.5, FAR, FAR) + vec3(0, 0, ro.z);\n\n\tfloat t = logBisectTrace(ro, rd);\n    \n    vec3 fog = vec3(1, .9, .7);\n    //vec3 fog = vec3(1, .3, .3);\n\n    vec3 col = fog;\n    \n    if (t < FAR){\n    \n        vec3 sp = ro+t*rd;\n        vec3 sn = normal(sp);\n\n        vec3 ld = lp-sp;\n        ld /= max(length(ld), 0.001); \n    \n        const float tSize1 = 1./6.;\n\n        sn = doBumpMap(iChannel1, sp*tSize1, sn, .007/(1. + t/FAR));\n        \n        float shd = 0.9;\n        float curv = curve(sp)*.7 +.1;\n        float ao = calculateAO(sp, sn, 10.);\n        \n        float dif = max( dot( ld, sn ), 0.); \n        float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.)*2.0; \n        float fre = clamp(1.0 + dot(rd, sn), 0., 1.);\n\n\t\tfloat Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 1.5);\n\t\tfloat fre2 = mix(.2, 1., Schlick);\n       \n        float amb = fre*fre2 + .76*ao;\n        \n        col = clamp(mix(vec3(.5, .4, .3), vec3(.25, .45, .125),(sp.y+1.)*.15), vec3(.25, .45, .125), vec3(1));\n        \n        curv = smoothstep(0., .7, curv);\n        col *= vec3(curv*0.9, curv*.45, curv*.25)*1.0;\n        \n        float prot = smoothstep(-0.0, -3.0, getprot(sp));\n        \n        col = mix(col, vec3(0.9, 0.6, 0.4), prot);\n        \n        col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col; \n        \n    }\n    \n    col = mix(col, fog, sqrt(smoothstep(FAR - 85., FAR, t)));\n    \n    col = pow(max(col, 0.), vec3(.85));\n\n    u = fragCoord/iResolution.xy;\n    col *= pow(16.*u.x*u.y*(1. - u.x)*(1. - u.y) , .0625);\n\n\tfragColor = vec4(clamp(col, 0., 1.), 1);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[395, 395, 417, 417, 485], [487, 487, 507, 507, 542], [543, 543, 562, 562, 621], [623, 623, 645, 645, 689], [691, 691, 731, 731, 825], [827, 827, 866, 866, 961], [963, 963, 985, 985, 1075], [1077, 1077, 1098, 1098, 1469], [1471, 1471, 1496, 1496, 1739], [1983, 1983, 2028, 2028, 2753], [2755, 2755, 2779, 2779, 2938], [2940, 2940, 2990, 2990, 3144], [3146, 3146, 3219, 3219, 3661], [3663, 3663, 3721, 3721, 3958], [3960, 3960, 3983, 3983, 4256], [4259, 4259, 4313, 4313, 6392]], "test": "untested"}
{"id": "7s3cWM", "name": "SynthCity", "author": "rcargou", "description": "Credit to IQ for his raymarching primitives shader\nThis shader is trying to reproduce this image https://www.youtube.com/watch?v=k3WkJq478To\n", "tags": ["synth"], "likes": 13, "viewed": 453, "published": 3, "date": "1653659810", "time_retrieved": "2024-07-30T16:46:40.121038", "image_code": "//Credit to IQ for his raymarching primitives shader\n// This shader is trying to reproduce this image https://www.youtube.com/watch?v=k3WkJq478To\n\n#define AA 2   // make this 2 or 3 for antialiasing\n\n\n#define floor_mat 1.0f\n#define sky_mat 2.0f\n#define building_mat 3.0f\n#define big_building_mat 4.0f\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nfloat stripes(float y) {\n\n    float b = clamp(0.0f, 1.0f, 1.0 - y * 2.0f); \n    //b = 1.0f - b;\n    float h = y + 0.3f;\n    float s = smoothstep(0.3, 0.21, abs(sin(-iTime * 1.5f + h*h * 30.0f)));\n    return s*b;\n}\n\nvec2 hash( vec2 p )\n{\n    //p = mod(p, 4.0); // tile\n    p = vec2(dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)));\n    return fract(sin(p)*18.5453);\n}\n\n// return distance, and cell id\nvec2 voronoi( in vec2 x )\n{\n    vec2 n = floor( x );\n    vec2 f = fract( x );\n\n\tvec3 m = vec3( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2  g = vec2( float(i), float(j) );\n        vec2  o = hash( n + g );\n      //vec2  r = g - f + o;\n\t    vec2  r = g - f + (0.5+0.5*sin(6.2831*o));\n\t\tfloat d = dot( r, r );\n        if( d<m.x )\n            m = vec3( d, o );\n    }\n\n    return vec2( sqrt(m.x), m.y+m.z );\n}\nfloat oscillate() {\n    return sin(iTime * 1.0f);\n}\n\nfloat mapBigBuildings(vec3 p) {\n    float scale = 1.0f/3.0f;\n    float id = floor(p.x / scale);\n    float scale_fact = clamp(abs(id / 50.0f), 0.5, 44.5f);\n    p.x = mod(p.x, scale) - scale/2.0f;\n    \n    float h = hash(vec2(id)).x;\n    p.y += 0.6f;\n    p.y /= 13.0f / scale_fact;//\n    p.x /= 7.0f;\n    p.z += 5.0f;\n    \n    p.z /= 10.0f;\n    p.y += h / 5.0f;\n    float b1 = sdBox(p + vec3(0.1f, 0.0f, 0.0f), vec3(0.05f, 0.1f, 0.02f));\n    float b2 = sdBox(p + vec3(0.0f, 0.0f, 0.0f), vec3(0.05f, 0.2f, 0.05f));\n    float b3 = sdBox(p + vec3(-0.05f, 0.0f, -0.1f), vec3(0.05f, 0.1f, 0.05f));\n    return min(b1, min(b2, b3));\n}\n\nfloat mapBuildings(vec3 p) {\n\n    float scale = 1.0f/3.0f;\n    float x = p.x;\n    float z = p.z;\n    p.x += iTime * 0.4f ;\n     \n    float angle = iTime / 10000.0f;\n    \n    \n    //p.x = cos(angle) * p.x - sin(angle) * p.z;\n    //p.z = sin(angle)* x + cos(angle) * z;\n        \n    vec3 id = floor(p/scale);\n    if (-id.z + 1.0f > 8.0f)\n    return 10000.0f;\n    float h = hash(id.xz).x;\n    p.xz = mod(p.xz, scale) - scale/2.0f;\n  p.x -= 0.05f;\n p.y += 0.6f;\n    if (h < 0.1f)\n    p.y *= 0.6f;\n    p.x += h/10.0f;\n     p *= 1.2f;\n    float b1 = sdBox(p + vec3(0.1f, 0.0f, 0.0f), vec3(0.05f, 0.1f, 0.02f));\n    float b2 = sdBox(p + vec3(0.0f, 0.0f, 0.0f), vec3(0.05f, 0.2f, 0.05f));\n    float b3 = sdBox(p + vec3(-0.05f, 0.0f, -0.1f), vec3(0.05f, 0.1f, 0.05f));\n    if (h > 0.3)\n    b2 = 10000.0f;\n    \n    return min(b1, min(b2, b3));\n}\n\nvec2 map2( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float dFloor = pos.y + 0.75;// + cos(pos.x / 35.0f);\n \n    res = opU(res, vec2(dFloor, floor_mat) );\n        float dSky = pos.z + 6.5;\n    res = opU(res, vec2(dSky, sky_mat) );\n    return res;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float dFloor = pos.y + 0.75;// + cos(pos.x / 35.0f);\n \n    \n    float dSky = pos.z + 6.5;\n    res = opU(res, vec2(dSky, sky_mat) );\n    res = opU(res, vec2(mapBuildings(pos), building_mat) );\n    res = opU(res, vec2(mapBigBuildings(pos), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 4.5f, 1.0f) + vec3(0.0f, 0.0f, -1.0f)), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 6.5f, 1.0f) + vec3(-3.0f, 0.0f, -1.0f)), big_building_mat));\n    //res = opU(res, vec2(mapBigBuildings(pos * vec3(1.0f, 2.0f, 1.0f) + vec3(3.0f, 0.0f, -1.0f)), big_building_mat));\n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.00005*t;\n\t    vec2 res = map( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x * 0.6f;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\nvec2 castRay2( in vec3 ro, in vec3 rd )\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n       \n    float t = tmin;\n    float m = -1.0;\n    for( int i=0; i<256; i++ )\n    {\n\t    float precis = 0.00005*t;\n\t    vec2 res = map2( ro+rd*t );\n        if( res.x<precis || t>tmax ) break;\n        t += res.x * 0.6f;\n\t    m = res.y;\n    }\n\n    if( t>tmax ) m=-1.0;\n    return vec2( t, m );\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvec3 shade_floor(vec3 pos) {\n    vec3 col = vec3(0.0025f, 0.0005, 0.002);\n    pos.x+= iTime * 0.4;\n    float scale = 3.0f;\n    vec2 fuv=fract(scale * pos.xz);\n    \n    fuv = abs(abs(fuv) - 0.5);\n    \n    col += vec3(0.6f, 0.01f, 0.6f) * 85.5f * smoothstep(0.47, 0.5, smax(fuv.x, fuv.y, 15.0f));\n    \n    //col += col * 200.0f * smoothstep(.0f, 1.5, min(fuv.x, fuv.y));\n   // col += vec3(.3f) * smoothstep(0.1, 0.35, abs(fuv.x)*abs(fuv.y) );\n   \n     float f= 1.0f / length(pos/15.0f - vec3(0.0f, 0.0f, -0.1f * 20.0f + 1.0f));\n    f = clamp(0.0f, 1.0f, pow(f,2.9f));\n    f = smoothstep(0.2f, 0.9f, f) * 0.7;\n   // col += mix(vec3(250.0f / 255.0f, 0.0f / 255.0f, 124.0f/255.0f), vec3(0.0f), 1.0f-f);\n    return col;\n}\n\n\nfloat window(vec2 uv, vec3 p) {\n\n    float s = 1.0f;\n    vec3 id = floor(p);\n    vec2 fuv = abs(fract(uv * s) - vec2(0.5f));\n    vec2 fid = uv  - fract(uv);\n    float size = 0.20f;\n    float f = smoothstep(size, size - 0.1f, max(fuv.x, fuv.y));\n    vec2 h = hash(fid + id.zx);\n    f *= step(h.x, 0.6f);\n    return f;\n}\n\nvec3 shade_window(vec3 pos, vec3 nor, float r) {\n    \n    if (abs(nor.y) > 0.001f)\n        return vec3(.0f);\n    vec2 uv = vec2(pos.x * nor.z + pos.z * nor.x + pos.y * 0.0f, \n    pos.y * nor.z + pos.y * nor.x + pos.z * nor.y );\n    float window_factor = window(uv * 40.0f, pos);\n    vec3 c_window = vec3(0.4f, 0.4f, 0.4f) * 5.0f;\n    float d = 9.0f;\n    window_factor *= smoothstep(d, d - 10.0f, r);\n//    return vec3(r/100.0f);\n    return c_window * window_factor;\n}\n\nvec3 shade_buildings(vec3 pos, float t) {\n    float f= 1.0f / length(pos/15.0f - vec3(0.0f, 0.0f, -0.1f * 20.0f + 1.0f));\n    f = clamp(0.0f, 1.0f, pow(f,2.9f));\n    f = smoothstep(0.2f, 0.9f, f) * 0.7;\n    vec3 nor = calcNormal(pos);\n    vec3 col = mix(vec3(250.0f / 255.0f, 0.0f / 255.0f, 124.0f/255.0f), vec3(0.0f), 1.0f-f);\n      pos.x += 0.4 * iTime;\n   \n    vec3 c_window = shade_window(pos, nor, t);\n    return c_window + col;\n}\n\nvec3 shade_sky(vec2 uv) {\nvec3 col;\n   \n        vec3 col_top = vec3(0.001f, 0.0f, 0.02f);\n        vec3 col_bot = vec3(0.1, 0.02, 0.24);\n        vec3 col_light = vec3(420.0f / 255.0f, 0.0f / 255.0f, 104.0f/255.0f);\n        \n \n        col = mix(col_bot, col_top, min(1.0f, 0.3 + uv.y * 1.3f) );\n        float i = length(1.3f * (uv-vec2(0.0f, -0.3f))*vec2(0.2f, 2.0f));\n         //i = .8f / length(uv.y - 1.0f);\n//        i = clamp(0.0f, 1.0f, i);\n  //      col = col_sun * (1.0f - i) + col;\n        vec3 col_sun = vec3(1.0f, 0.3f, 0.2f) * 1.0f;\n       // col_sun = pow(col_sun, vec3(1.3f + 0.6f * oscillate()) );\n        float j = length(4.0f * (uv - vec2(0.0f, -0.2f)) * vec2(0.6, .6f));\n        float sun_value= smoothstep( 1.5, 1.4f, j);\n        sun_value *= smoothstep(0.9f, 1.0f, 1.0f-stripes(uv.y*2.0f));\n        col = mix(col, col_sun, sun_value*1.5f );\n        col = mix(col_light*0.7f, col, clamp(0.0f, 1.0f, i/1.4f));\n        //uv.x += iTime * 0.05f;\n        float star = texture(iChannel0, texture(iChannel1, uv).xz).r;\n            uv.xy += texture(iChannel1, uv*200.0f).xy/10.0f;\n    uv.x+= iTime * 0.01f;\n        vec2 closest_star = voronoi(uv*100.0f);\n        star = (2.5f * pow(texture(iChannel1, uv*1.0f).x, 3.0f)) / length(closest_star);\n        star = pow(star, 1.0f);\n        float star_treshold = 3.9f;\n        star = mix(star, 0.0f, smoothstep(1.5, 1.4, j));\n        col = mix(col, vec3(0.4f), smoothstep(star_treshold - 0.01, star_treshold, star));\n     return col;\n}\n\nvec3 shade(vec2 res, vec3 pos, vec2 uv) {\n    vec3 col;\n    \n    if (res.y == floor_mat) {\n        col = vec3(0.2f);\n        col = shade_floor(pos);\n    } else if (res.y == sky_mat) {\n        col = shade_sky(uv);\n    } else if (res.y == building_mat) {\n        col = shade_buildings(pos, res.x);\n    } else if (res.y == big_building_mat) {\n        vec3 nor =calcNormal(pos);\n          vec3 col_light = vec3(420.0f / 255.0f, 0.0f / 255.0f, 104.0f/255.0f);\n        \n \n        col = col_light*0.2f + 0.3f*shade_window(pos/10.0f, nor, 0.0f);\n        col *= smoothstep(0.9, -0.3, uv.y*4.0f + 0.6f);\n//        col = calcNormal(pos);\n    }\n\n    return col;\n}\n\nvec3 render( in vec3 ro, in vec3 rd, vec2 uv )\n{ \n    vec3 col = vec3(.0f);\n    vec2 res = castRay(ro,rd);\n    \n    vec2 res2 = castRay2(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if (res.y != sky_mat && !(res.y == big_building_mat && res2.y == floor_mat)) {\n        vec3 pos = ro + rd * t;\n        col = shade(res, pos, uv);\n        if (res.y == building_mat) {\n            col = mix(col, shade(res2, ro + rd * res2.x, uv), 0.01);\n        }\n    } else  {\n        vec3 pos = ro + rd * res2.x;\n        col = shade(res2, pos, uv);\n    }\n   \treturn vec3(col);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0.0f);//iMouse.xy/iResolution.xy;\n\tfloat time = 15.0 + iTime;\n\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        p.y += sin(p.x - 1.57)/-13.0f;\n\t\t// camera (ro = ray origin)\t\n        vec3 ro = vec3( 0.0f, 0.5f, 10.0f);\n        vec3 ta = vec3( 0.0f, 2.05, 1.0 );\n        // camera-to-world transformation\n        mat3 ca = setCamera( ro, ta, 0.0 );\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p.xy,0.8) );\n  \n        // render\t\n        vec3 col = render( ro, rd, p );\n        col += vec3(0.1f, 0.0f, 0.07f) / 2.0f;\n\n\t\t// gamma\n        col = pow( col, vec3(0.6545 + 0.2f * oscillate()) );\n        tot += col;\n        \n        \n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n\n    fragColor = vec4( tot, 1.0 );\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k*a)+exp(k*b))/k;\n}\n\nfloat smin(float a, float b, float k)\n{\n    return -(log(exp(k*-a)+exp(k*-b))/k);\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3cWM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[472, 472, 496, 496, 685], [687, 687, 708, 739, 854], [856, 888, 915, 915, 1336], [1337, 1337, 1356, 1356, 1388], [1390, 1390, 1421, 1421, 2015], [2017, 2017, 2045, 2045, 2852], [2854, 2854, 2880, 2880, 3114], [3116, 3116, 3141, 3141, 3882], [3911, 3911, 3951, 3951, 4291], [4293, 4293, 4334, 4334, 4675], [4677, 4722, 4800, 4823, 5164], [5166, 5212, 5244, 5244, 5454], [5456, 5456, 5498, 5498, 5814], [5817, 5817, 5869, 5869, 6046], [6048, 6048, 6076, 6076, 6763], [6766, 6766, 6797, 6797, 7084], [7086, 7086, 7134, 7134, 7553], [7555, 7555, 7596, 7596, 7990], [7992, 7992, 8017, 8017, 9479], [9481, 9481, 9522, 9522, 10132], [10134, 10134, 10182, 10182, 10700]], "test": "untested"}
{"id": "NsdczS", "name": "Growing tree", "author": "lasoy", "description": "Growing Tree~", "tags": ["tree", "physics", "verlet"], "likes": 9, "viewed": 349, "published": 3, "date": "1653657923", "time_retrieved": "2024-07-30T16:46:40.892975", "image_code": "#define P_COLOR 1.0\n#define DC_COLOR 2.0\n#define AC_COLOR 3.0\n#define BOUNDS_COLOR 4.0\n\nvec2 getInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));\n    info.xy = info.xy * 2. - 1.;\n    \n    return info.xy;\n}\n\nvec2 opU( vec2 d1, float d2, float material )\n{\n    return (d1.x<d2) ? d1 : vec2(d2, material);\n}\n\nvec2 map(vec2 p){\n    vec2 d = vec2(99999.9, 0);\n    for(int i = 0;i < P_COUNT;i ++) {\n       d = opU(d, sdCircle(p - getInfo(i), R), P_COLOR);\n    }\n\n    for(int i = 0;i < DC_COUNT;i ++) {\n      int a = int(dc[i][0]);\n      int b = int(dc[i][1]);\n      d = opU(d, sdSegment(p, getInfo(a).xy,  getInfo(b).xy), AC_COLOR);\n    }\n    \n    d = opU(d, sdSegment(p, vec2(-1, -1), vec2(-1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(-1, 1), vec2(1, 1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, 1), vec2(1, -1)), BOUNDS_COLOR);\n    d = opU(d, sdSegment(p, vec2(1, -1), vec2(1, 1)), BOUNDS_COLOR);\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    float w = length(fwidth(uv)) * 5.0;\n    \n    vec2 d = map(uv);\n    float c = smoothstep(0.0, w, abs(d.x));\n    vec3 col = vec3(1.0-c);\n    if (d.y == P_COLOR) {\n      col *= vec3(.3, .9, .6);\n    } else if (d.y == DC_COLOR) {\n      col *= vec3(.3, .6, .9);\n    } else if (d.y == AC_COLOR) {\n      col *= vec3(.6, .9, .3);\n    } else if (d.y == BOUNDS_COLOR) {\n      col *= vec3(.5, .5, .5);\n    }\n\n    col = mix(col, vec3(1, 1, .95), c/4.0);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define PI 3.141592653589793\n#define R .04\n#define STEP 0.1\nfloat friction = 0.9;\n\nstruct AC {\n    int a;\n    int b;\n    int c;\n    float angle;\n    float stiffness;\n};\n\n#define P_COUNT 17\nconst vec2 pos[P_COUNT] = vec2[P_COUNT](\n    vec2(0.5,0.05000000074505806),\n    vec2(0.5,0.050999999046325684),\n    vec2(0.5,0.20000000298023224),\n    vec2(0.42500001192092896,0.32990381121635437),\n    vec2(0.33839747309684753,0.37990379333496094),\n    vec2(0.2883974611759186,0.37990379333496094),\n    vec2(0.31339746713638306,0.42320504784584045),\n    vec2(0.42500001192092896,0.4299038052558899),\n    vec2(0.4000000059604645,0.4732050895690918),\n    vec2(0.45000001788139343,0.4732050895690918),\n    vec2(0.574999988079071,0.32990381121635437),\n    vec2(0.574999988079071,0.4299038052558899),\n    vec2(0.550000011920929,0.4732050895690918),\n    vec2(0.5999999642372131,0.4732050895690918),\n    vec2(0.6616025567054749,0.37990379333496094),\n    vec2(0.6866025328636169,0.42320504784584045),\n    vec2(0.7116025686264038,0.37990379333496094)\n);\n\n#define DC_COUNT 16\nconst vec4 dc[DC_COUNT] = vec4[DC_COUNT](\n    vec4(3,2,0.14999999202035977,0.1),\n    vec4(4,3,0.099999989713187,0.1),\n    vec4(5,4,0.050000011920928955,0.1),\n    vec4(6,4,0.04999998940239111,0.1),\n    vec4(7,3,0.09999999403953552,0.1),\n    vec4(8,7,0.05000001521195773,0.1),\n    vec4(9,7,0.05000001521195773,0.1),\n    vec4(10,2,0.14999999202035977,0.1),\n    vec4(11,10,0.09999999403953552,0.1),\n    vec4(12,11,0.050000000310804184,0.1),\n    vec4(13,11,0.050000000310804184,0.1),\n    vec4(14,10,0.10000001552275858,0.1),\n    vec4(15,14,0.049999974501229866,0.1),\n    vec4(16,14,0.050000011920928955,0.1),\n    vec4(0,1,0.000999998301267624,0.9),\n    vec4(1,2,0.14900000393390656,0.9)\n);\n\n#define AC_COUNT 15\nconst AC ac[AC_COUNT] = AC[AC_COUNT](\n    AC(1,2,3,-2.617993939045201,0.5),\n    AC(2,3,4,-2.6179936698521753,0.5),\n    AC(3,4,5,-2.617994025077107,0.5),\n    AC(6,4,3,-2.617993990927634,0.5),\n    AC(7,3,2,-2.617993939045201,0.5),\n    AC(3,7,8,-2.6179939159930097,0.5),\n    AC(9,7,3,-2.6179939159930097,0.5),\n    AC(10,2,1,-2.617993939045201,0.5),\n    AC(2,10,11,-2.617993939045201,0.5),\n    AC(10,11,12,-2.6179944321843833,0.5),\n    AC(13,11,10,-2.6179944321843833,0.5),\n    AC(14,10,2,-2.617993520840624,0.5),\n    AC(10,14,15,-2.617993325724532,0.5),\n    AC(16,14,10,-2.6179941740886576,0.5),\n    AC(2,1,0,-3.141592653589793,0.8)\n);\n\n#define PC_COUNT 2\nconst vec3 pc[PC_COUNT] = vec3[PC_COUNT](\n    vec3(0,0.5,0.05000000074505806),\n    vec3(1,0.5,0.050999999046325684)\n);\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n", "buffer_a_code": "vec4 getPInfo(int index) {\n    vec4 info = texture(iChannel0, vec2((float(index)+.5)/iResolution.x, 0));    \n    return info;\n}\n\nvoid bounds(inout vec4 info) {\n    float min = R/2.0;\n    float max = 1.0 - R/2.0;\n\n    if (info.x < min) {\n        info.x = min;\n    } else if (info.x > max) {\n        info.x = max;\n    }\n\n    if (info.y < min) {\n        info.y = min;\n    } else if (info.y > max) {\n        info.y = max;\n    }\n}\n\nvoid relaxDC(int index, inout vec4 color) {\n  for(int i = 0;i < DC_COUNT;i ++) {\n    vec4 info = dc[i];\n    int a = int(info[0]);\n    int b = int(info[1]);\n    float dist = info[2];\n    float stiffness = info[3];\n\n    if (a == index || b == index) {\n      vec2 d;\n      if(a == index) {\n        d = color.xy - getPInfo(b).xy;\n      } else {\n        d = getPInfo(a).xy - color.xy;\n      }\n      d = getPInfo(a).xy - getPInfo(b).xy;\n      float m = dot(d, d);\n      d *=((dist*dist - m)/m)*stiffness*0.5;\n      if (a == index) {\n        color.xy += d;\n      } else if(b == index) {\n        color.xy -= d;\n      }\n    }\n  }\n}\n\nvoid relaxPC(int index, inout vec4 color) {\n  for(int i = 0;i < PC_COUNT;i ++) {\n    vec3 info = pc[i];\n    if (int(info.x) == index) {\n      color.xy = info.yz;\n    }\n  }\n}\n\nvoid rotate(inout vec2 pos, vec2 origin, float angle) {\n  vec2 offset = pos - origin;\n  float c = cos(angle);\n  float s = sin(angle);\n  pos.x = origin.x + offset.x * c - offset.y * s;\n  pos.y = origin.y + offset.x * s + offset.y * c;\n}\n\nvoid relaxAC(int index, inout vec4 color) {\n  for(int i = 0;i < AC_COUNT;i ++) {\n    AC info = ac[i];\n    if (info.a == index || info.b == index || info.c == index) {\n      vec2 aPos;\n      vec2 bPos;\n      vec2 cPos;\n      if (info.a == index) {\n        aPos = color.xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = getPInfo(info.c).xy;\n      } else if (info.b == index) {\n        aPos = getPInfo(info.a).xy;\n        bPos = color.xy;\n        cPos = getPInfo(info.c).xy;\n      } else {\n        aPos = getPInfo(info.a).xy;\n        bPos = getPInfo(info.b).xy;\n        cPos = color.xy;\n      }\n      vec2 l = aPos-bPos;\n      vec2 r = cPos-bPos;\n\n      float diff = atan(l.x * r.y - l.y * r.x, dot(l,r)) - info.angle;\n      \n      if (diff <= -PI)\n        diff += 2.0 * PI;\n      else if (diff >= PI)\n        diff -= 2.0 * PI;\n\n      diff *= STEP * info.stiffness;\n      rotate(aPos, bPos, diff);\n      rotate(cPos, bPos, -diff);\n      rotate(bPos, aPos, diff);\n      rotate(bPos, cPos, -diff);\n      if (info.a == index) {\n        color.xy = aPos;\n      } else if(info.b == index) {\n        color.xy = bPos;\n      } else if(info.c == index) {\n        color.xy = cPos;\n      }   \n    }\n  }\n}\n\nvoid relaxMouse(int index, inout vec4 color) {\n  if (iMouse.z > 0.) {\n    vec2 target = getPInfo(index).xy;\n    vec2 mouse = iMouse.xy/iResolution.xy;\n    mouse.x = (mouse.x - 0.5)*iResolution.x/iResolution.y + 0.5;\n    float l = dot(mouse - target, mouse - target);\n\n    if (l < R*R) {\n      color.xy = mouse;\n    }\n  }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord;\n    int col = int(uv.x);\n    int row = int(uv.y);\n    \n    col/=1;\n \n    if (col >= P_COUNT || row > 0) {\n        return;\n    }\n\n    vec4 color = getPInfo(col);\n    \n    if (iFrame == 0) {\n        color.xy = pos[col];\n        color.zw = color.xy;\n    } else {\n        vec2 v = color.xy - color.zw;\n        v *= friction;\n        vec2 g = vec2((sin(iTime*1.))*0.01, sign(cos(iTime*1.5))*0.01);\n        v += g*0.05;\n        \n        color.zw = color.xy;\n        color.xy += v;\n        \n        relaxAC(col, color);\n        relaxDC(col, color);\n        relaxMouse(col, color);\n        relaxPC(col, color);\n        bounds(color);\n    }\n    fragColor = color;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdczS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 300, 300, 350], [352, 352, 369, 369, 978], [980, 980, 1037, 1037, 1586]], "test": "untested"}
{"id": "3t3BWB", "name": "Toni Boxfield", "author": "Kali", "description": "to expose the API consider it unlisted...", "tags": ["spedsaflkj"], "likes": 7, "viewed": 411, "published": 3, "date": "1653609312", "time_retrieved": "2024-07-30T16:46:41.684857", "image_code": "vec3 c;\nfloat s;\n\nmat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nfloat de(vec3 p)\n{\n    p.xy *= rot(iTime * .5 + p.z * .02);\n    p.x += iTime * 25.;\n    p.z += iTime * 50.;\n    float sc = 1.2;\n    float der = 1.;\n    float id = floor(p.x / 30.);\n    p = mod(p, 30.) - 15.;\n    p.xy *= rot(iTime * 3.);\n    p.yz *= rot(iTime * 1.5);\n    vec3 cc = abs(p) - vec3(8.*s, 6., .5);\n    float d = length(max(vec3(0.), cc));\n    vec3 cr = vec3(0., .5, 1.);\n    cr.xz *= rot(id * 2.);\n    cr = abs(cr);\n    c = max(0., 2. - d) * length(sin(p * 4.)) * cr;\n    return d * .5;\n}\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d, td = 0.;\n    vec3 p, col = vec3(0.);\n    for (int i = 0; i < 120; i++)\n    {\n        p = from + td * dir;\n        d = de(p);\n        td += max(.05, abs(d));\n        col += c * exp(-.007 * td);\n    }\n    if (mod(iTime,20.)>10.) return abs(.5-col * .02);\n    else return col*.02;\n}\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s=getSound();\n     vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 dir = normalize(vec3(uv, 1.));\n    dir.yz *= rot(floor(iTime * .2) * 3.1416 / 3.);\n    vec3 from = vec3(0.,0.,-10.);\n    vec3 col = march(from, dir);\n   texto(col, vec2(-.35,-.4));\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 35.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ _ _ _ K A L I _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t3BWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 37, 37, 103], [106, 106, 124, 124, 606], [608, 608, 641, 641, 934], [936, 936, 955, 955, 1128], [1130, 1130, 1171, 1171, 1324], [1326, 1326, 1383, 1383, 1689]], "test": "untested"}
{"id": "ttVyW3", "name": "Toni Tunnel", "author": "Kali", "description": "to expose the api for a show (unlisted api feature missing)", "tags": ["asdflkj"], "likes": 22, "viewed": 1328, "published": 3, "date": "1653606338", "time_retrieved": "2024-07-30T16:46:42.540569", "image_code": "float s;\n\nmat2 rot(float a)\n{\n    float s = sin(a), c = cos(a);\n    return mat2(c, s, -s, c);\n}\n\n\nvec3 path(float z)\n{\n    vec3 p = vec3(sin(z) * .5, cos(z * .5), z);\n    p.x+=p.y*p.x*2.;\n    return p;\n}\n\nvec3 fractal(vec3 p)\n{\n    float z = p.z * .1;\n    p.z = abs(.5 - fract(z));\n    float m = 100.;\n    for (int i = 0; i < 10; i++)\n    {\n        p.xy *= rot(z);\n        p = abs(p * (1.5+sin(z*3.)*.2)) - 2.;\n        m = min(m, abs(p.y) + .5 * abs(.5 - fract(p.x * .25 + iTime + float(i) * .1)));\n    }\n    m = exp(-8. * m) * 2.;\n    return vec3(p.xz * 2., m) * m + .5;\n}\n\nfloat g=0.;\nvec3 lpos;\n\nfloat de(vec3 p)\n{\n    float d=length(p-lpos)-s*.2;\n    p.xy -= path(p.z).xy;\n    g+=.003/(.1+d*5.);\n    return min(d,-length(p.xy) + .3);\n}\n\nvec3 march(vec3 from, vec3 dir)\n{\n    float d, td = 0.;\n    vec3 p, col = vec3(0);\n    for (int i = 0; i < 80; i++)\n    {\n        p = from + dir * td;\n        d = de(p);\n        if (d < .001) break;\n        td += d;\n    }\n    if (d < .1) \n    {\n        p -= .001 * dir;\n        col = fractal(p) * exp(-1. * td * td) * smoothstep(.3, 1., td);\n    }\n    return (col+g)*(.3+s*4.);\n}\n\nmat3 lookat(vec3 dir, vec3 up) {\n    dir = normalize(dir);\n    vec3 rt = normalize(cross(dir, normalize(up)));\n    return mat3(rt, cross(rt, dir), dir);\n}\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     s=getSound();\n     vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    float t = iTime;\n    vec3 from = path(t);\n    lpos = path(t+1.);\n    vec3 fw = normalize(path(t + .5) - from);\n    vec3 dir = normalize(vec3(uv, 1));\n    dir = lookat(fw, vec3(0, 1, 0)) * dir;\n    vec3 col = march(from, dir);\n    texto(col, vec2(-0.35,-0.4));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 35.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ _ _ _ K A L I _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttVyW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 10, 29, 29, 95], [98, 98, 118, 118, 203], [205, 205, 227, 227, 573], [599, 599, 617, 617, 739], [741, 741, 774, 774, 1120], [1122, 1122, 1154, 1154, 1276], [1278, 1278, 1297, 1297, 1470], [1472, 1472, 1513, 1513, 1666], [1669, 1669, 1726, 1726, 2108]], "test": "untested"}
{"id": "7scyzS", "name": "Mixed Skethcy Stippling", "author": "starea", "description": "Mixed Skethcy Stippling", "tags": ["rapsai"], "likes": 1, "viewed": 201, "published": 3, "date": "1653604232", "time_retrieved": "2024-07-30T16:46:43.294553", "image_code": "/** \n * Forked from my https://www.shadertoy.com/view/ldSyzV shader \n **/\nconst float PI = 3.1415926536;\nconst float PI2 = PI * 2.0; \nconst int mSize = 9;\nconst int kSize = (mSize-1)/2;\nconst float sigma = 3.0;\nfloat kernel[mSize];\n\n// Gaussian PDF\nfloat normpdf(in float x, in float sigma) \n{\n\treturn 0.39894 * exp(-0.5 * x * x / (sigma * sigma)) / sigma;\n}\n\n// \nvec3 colorDodge(in vec3 src, in vec3 dst)\n{\n    return step(0.0, dst) * mix(min(vec3(1.0), dst/ (1.0 - src)), vec3(1.0), step(1.0, src)); \n}\n\nfloat greyScale(in vec3 col) \n{\n    return dot(col, vec3(0.3, 0.59, 0.11));\n    //return dot(col, vec3(0.2126, 0.7152, 0.0722)); //sRGB\n}\n\nvec2 random(vec2 p){\n\tp = fract(p * (vec2(314.159, 314.265)));\n    p += dot(p, p.yx + 17.17);\n    return fract((p.xx + p.yx) * p.xy);\n}\n\nvec2 random2(vec2 p)\n{\n    return texture(iChannel1, p / vec2(1024.0)).xy;\n    //blue1 = texture(iChannel1, p / vec2(1024.0));\n    //blue2 = texture(iChannel1, (p+vec2(137.0, 189.0)) / vec2(1024.0));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec3 col = texture(iChannel0, q).rgb;\n   \n    vec2 r = random(q);\n    r.x *= PI2;\n    vec2 cr = vec2(sin(r.x),cos(r.x))*sqrt(r.y);\n    \n    vec3 blurred = texture(iChannel0, q + cr * (vec2(mSize) / iResolution.xy) ).rgb;\n    \n    vec3 inv = vec3(1.0) - blurred; \n    // color dodge\n    vec3 lighten = colorDodge(col, inv);\n    // grey scale\n    vec3 res = vec3(greyScale(lighten));\n    \n    // more contrast\n    res = vec3(pow(res.x, 3.0)); \n    //res = clamp(res * 0.7 + 0.3 * res * res * 1.2, 0.0, 1.0);\n    \n    // edge effect\n    if (iMouse.z > 0.5) res *= 0.25 + 0.75 * pow( 16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.15 );\n    \n    if ( texture(iChannel2, q).r > 0.5) {\n      fragColor = vec4(col, 1.0); \n    } else {\n      fragColor = vec4(res, 1.0); \n\n    }\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7scyzS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 249, 293, 293, 358], [360, 364, 407, 407, 504], [506, 506, 537, 537, 643], [645, 645, 665, 665, 780], [782, 782, 804, 804, 987], [989, 989, 1046, 1046, 1864]], "test": "untested"}
{"id": "7s3yRS", "name": "2D Transform from Line+Midpoint", "author": "pyBlob", "description": "Calculates the transform between a camera and a line segment with midpoint, such that the rays through the 3 image points intersect 3 points of that segment.\n\nMouse: manually move image points / directions.", "tags": ["geometry", "transform", "projective"], "likes": 2, "viewed": 190, "published": 3, "date": "1653602303", "time_retrieved": "2024-07-30T16:46:44.192153", "image_code": "// The interesting bits:\n//   void Common::recover_transform(inout State z);\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    C = image(O, iResolution, iMouse, iFrame, iTime, iChannel0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct View\n{\n    float f;\n    vec2 uv;\n    vec2 mouse;\n    vec2 click;\n    bool down;\n    bool clicked;\n};\n\nvoid init(inout View v, vec2 O, vec3 R, vec4 mouse)\n{\n    v.f = R.x / 10.;\n    vec2 o = vec2(0, R.y) / 2.;\n    v.uv = (O - o) / v.f;\n    v.mouse = (abs(mouse.xy) - o) / v.f;\n    v.click = (abs(mouse.zw) - o) / v.f;\n    v.down = mouse.z > 0.;\n    v.clicked = mouse.w > 0.;\n}\n\nconst int N = 3;\nstruct State\n{\n    float screen[N];\n\n    int selected_point;\n    \n    mat2x3 T;\n};\n\nvoid recover_transform(inout State z)\n{\n    float i, j, k, i0, i1, j0, j1, k0, k1, c, s, r;\n\n    i = z.screen[0];\n    j = z.screen[1];\n    k = z.screen[2];\n\n    i0 = k - j;\n    i1 = i * i0;\n\n    j0 = -2. * (i - k);\n    j1 = j * j0;\n\n    k0 =  2. * (i - j);\n    k1 = k * k0;\n\n    c = k0 - j0;\n    s = k1 - j1;\n    r = length(vec2(c, s));\n    r *= i0 < 0. ? -1. : 1.;\n    \n    z.T = mat2x3(\n        i0, c, -s,\n        i1, s,  c\n    ) / r;\n}\n\nvoid load(inout State z, sampler2D A)\n{\n    vec4 t;\n    t = texelFetch(A, ivec2(0, 0), 0);\n    z.selected_point = int(t.y);\n\n    for (int i=0 ; i<N ; ++i)\n    {\n        t = texelFetch(A, ivec2(1, i), 0);\n        z.screen[i] = t.x;\n    }\n    \n    recover_transform(z);\n}\n\nvec4 save(State z, ivec2 O)\n{\n    vec4 t = vec4(0);\n    if (O == ivec2(0, 0))\n    {\n        t.y = float(z.selected_point);\n    }\n    \n    for (int i=0 ; i<N ; ++i)\n        if (O == ivec2(1, i))\n            t.x = z.screen[i];\n    \n    return t;\n}\n\nvoid demo(inout State z, vec4 M, int iFrame, float iTime)\n{\n    if (iFrame == 0)\n    {\n        z.screen[0] = -0.05;\n        z.screen[1] = 0.3;\n        z.screen[2] = -0.2;\n    }\n    if (M == vec4(0))\n    {\n        float t = (iTime - 17.6) / 5.;\n        float x = cos(t * 1.3481) * 2. + cos(t * 5.1439) + 4.;\n        float y = sin(t * 3.2419);\n        float a = t * 3. + cos(t) * 5.;\n        float c = cos(a) / 2.;\n        float s = sin(a) / 2.;\n        z.screen[0] = y / x;\n        z.screen[1] = (y - s) / (x - c);\n        z.screen[2] = (y + s) / (x + c);\n    }\n}\n\nfloat ray(vec2 x, vec2 t)\n{\n    return abs(dot(x, normalize(t).yx * vec2(-1, 1)));\n}\n\nfloat ray(vec2 x, State z, int i)\n{\n    return ray(x, vec2(1, z.screen[i]));\n}\n\nvec4 bufferA(vec2 O, vec3 R, vec4 M, int iFrame, float iTime, sampler2D A)\n{\n    View v; init(v, O, R, M);\n    State z; load(z, A); demo(z, M, iFrame, iTime);\n    if (!v.down)\n        z.selected_point = -1;\n    if (v.clicked)\n    {\n        int closest = 0;\n        for (int i=1 ; i<N ; ++i)\n            if (ray(v.mouse, z, i) < ray(v.mouse, z, closest))\n                closest = i;\n        float r = ray(v.mouse, z, closest);\n        z.selected_point = r < 20. / v.f ? closest : -1;\n    }\n    for (int i=0 ; i<N ; ++i)\n        if (v.down && z.selected_point >= 0 && i==z.selected_point)\n            z.screen[i] = v.mouse.y / v.mouse.x;\n    return save(z, ivec2(O));\n}\n\nvoid blend(inout vec4 C, vec3 c, float r)\n{\n    C = mix(C, vec4(c, 1), clamp(r, 0., 1.));\n}\n\nvoid blend(inout vec4 C, vec4 c)\n{\n    blend(C, c.xyz, c.w);\n}\n\nvoid circle(inout vec4 C, View v, vec3 c, vec2 center, float r)\n{\n    float l = r - length(v.uv - center) * v.f;\n    blend(C, vec3(1), l + 1.);\n    blend(C, c, l);\n}\n\nView transform(View v, mat2x3 T)\n{\n    mat3x3 M = inverse(mat3x3(1, 0, 0, T[0], T[1]));\n    T = mat2x3(M[1], M[2]);\n    v.uv = vec3(1, v.uv) * T;\n    v.mouse = vec3(1, v.mouse) * T;\n    return v;\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(0),\n    vec3(1, 0.3, 0),\n    vec3(0,   0, 1),\n    vec3(1,   0, 0)\n);\n\nvoid object(inout vec4 C, View v, float iTime)\n{\n    vec2 x = vec2(abs(v.uv.x), v.uv.y);\n    float y = sin(v.uv.x*6.28) * sin(iTime * 5.) * 0.05;\n    float l = 2. - length(x - vec2(min(.5, x.x), y)) * v.f;\n    vec3 c;\n    c = mix(colors[0], v.uv.x < 0. ? colors[1] : colors[2], abs(v.uv.x * 2.));\n    blend(C, c, l);\n\n    circle(C, v, colors[1], vec2(-0.5, 0), 3.);\n    circle(C, v, colors[0], vec2( 0.0, 0), 3.);\n    circle(C, v, colors[2], vec2( 0.5, 0), 3.);\n}\n\nvec4 image(vec2 O, vec3 R, vec4 M, int iFrame, float iTime, sampler2D A)\n{\n    View v; init(v, O, R, M);\n    State z; load(z, A);\n    vec4 C = vec4(1, 1, 1, 0);\n    \n    // object\n    object(C, transform(v, z.T), iTime);\n\n    // image plane\n    blend(C, vec3(0), 1. - abs(v.uv.x - 1.) * v.f);\n\n    for (int i=0 ; i<N ; ++i)\n    {\n        float r = 3., l = 1.;\n        if (z.selected_point == i)\n        {\n            r = 5.;\n            l = 1.5;\n        }\n        vec2 image_point = vec2(1, z.screen[i]);\n        \n        // ray\n        blend(C, colors[i], l - ray(v.uv, image_point) * v.f);\n        \n        // image point\n        circle(C, v, colors[i], image_point, r);\n    }\n    C = sqrt(C);\n    return C;\n}\n", "buffer_a_code": "void mainImage(out vec4 C, vec2 O)\n{\n    C = bufferA(O, iResolution, iMouse, iFrame, iTime, iChannel0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3yRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 114, 114, 181]], "test": "untested"}
{"id": "7d3cRS", "name": "[Fork] Countdown Clock", "author": "izutionix", "description": "a 24-hour clock counting down\nForked from [url=https://www.shadertoy.com/view/Xsy3zG]Digital clock optimized by Andre[/url]\nidea from: [url]https://www.reddit.com/r/Lightbulb/comments/sgwvd0/if_24hour_clocks_started_at_2359_and_counted_down/[/url]", "tags": ["time", "clock", "digital", "countdown", "reverse"], "likes": 3, "viewed": 366, "published": 3, "date": "1653600424", "time_retrieved": "2024-07-30T16:46:44.954116", "image_code": "// original shader: https://www.shadertoy.com/view/Xsy3zG\n\nfloat segment(vec2 uv)\n{\n    uv = abs(uv);\n\treturn (1.0-smoothstep(0.07,0.10,uv.x))\n         * (1.0-smoothstep(0.46,0.49,uv.y+uv.x))\n         * (1.25 - length(uv*vec2(3.8,1.3)));\n}\n\nfloat sevenSegment(vec2 uv,int num)\n{\n\tfloat seg= 0.0;\n    \n    if (num>=2 && num!=7 || num==-2)\n        seg = max(seg,segment(uv.yx));\n        \n    if (num==0 || \n            (uv.y<0.?((num==2)==(uv.x<0.) || num==6 || num==8):\n            (uv.x>0.?(num!=5 && num!=6):(num>=4 && num!=7) )))\n        seg = max(seg,segment(abs(uv)-0.5)); \n\t\n    if (num>=0 && num!=1 && num!=4 && (num!=7 || uv.y>0.))\n        seg = max(seg,segment(vec2(abs(uv.y)-1.0,uv.x)));\n    \n\treturn seg;\n}\n\nfloat showNum(vec2 uv,float nr, bool zeroTrim)\n{\n    if (uv.x>-3.0 && uv.x<0.0)\n    {\n        float digit = floor(-uv.x / 1.5);\n\t\tnr /= pow(10.,digit);\n        nr = mod(floor(nr+0.000001),10.0);\n        if (nr==0.0 && zeroTrim && digit!=0.0)\n            return 0.;\n\t\treturn sevenSegment(uv+vec2( 0.75 + digit*1.5,0.0),int(nr));\n    }\n\treturn 0.;\n}\n\nfloat dots(vec2 uv)\n{\n\tuv.y = abs(uv.y)-0.5;\n\tfloat l = length(uv);\n\treturn (1.0-smoothstep(0.11,0.13,l)) * (1.0-l*2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-0.5*iResolution.xy) / iResolution.x;\n    \n    uv *= 11.0;\n    uv.x -= 5.+uv.y*.07;\n\n    if (uv.x<-10.0 || uv.x>0.0 || abs(uv.y)>1.2) {\n        fragColor = vec4(0.);\n    \treturn;\n    }\n    \n    float p = floor(abs(uv.x/3.5));\n    uv.x = mod(uv.x,3.5)-3.5;\n    \n\tfloat seg = 0.0;\n    if (uv.x>-3.)\n\t    seg = showNum(uv,mod((86400.-iDate.w)/pow(60.0,p),60.0),p==2.0);\n    else\n    {\n        uv.x += 3.25;\n\t\tseg = dots(uv);\n    }\n\t\n    fragColor = vec4(seg,0.,0.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3cRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 83, 83, 239], [241, 241, 278, 278, 716], [718, 718, 766, 766, 1065], [1067, 1067, 1088, 1088, 1189], [1191, 1191, 1248, 1248, 1740]], "test": "untested"}
{"id": "fd3cRB", "name": "Nice Pattern Automata", "author": "SnoopethDuckDuck", "description": "Could be useful for texturing pixel art, or something else :)\n\nPlay around with th and s, you can get other patterns really easily\n\nUsed to generate shapes:\nhttps://www.shadertoy.com/view/7s3cRS", "tags": ["feedback", "cellularautomata"], "likes": 4, "viewed": 301, "published": 3, "date": "1653592438", "time_retrieved": "2024-07-30T16:46:45.733033", "image_code": "#define pi 3.14159\n\nvec3 pal(float t, vec3 d) {\n    return 0.5 + 0.5 * cos(2. * pi * (0.5 * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float zm = 0.14; \n    vec2 res = floor(iResolution.xy);    \n    vec2 f = mod(floor(32. * iTime) + fragCoord, res);\n    \n    vec3 col = texelFetch( iChannel0, ivec2(zm * f + 0.5 * (1.-zm) * res), 0).rgb;\n    col.b = col.g;\n    col = pal(0.75 + 0.35 * col.g + 0.5 * uv.y, 0.5 * vec3(2,1,3)/3.);\n    \n    fragColor.rgb = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n\nfloat cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).g;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n    int frame = iFrame % 1200;\n    \n    ivec2 g = ivec2(f + vec2(100.,151.) * iTime * 60.) & 1023;\n    float rand = texelFetch(iChannel2, g, 0).r;\n    \n    if (frame == 0 || key_down(KEY_RESET)) {      \n        return;\n    }\n           \n    // Center cell\n    float e = cell(px);\n    \n    // Neighbour cells\n    float b = cell(px - ivec2(0,1));\n    float t = cell(px + ivec2(0,1));\n    float l = cell(px - ivec2(1,0));\n    float r = cell(px + ivec2(1,0));   \n    float bl = cell(px + ivec2(-1,-1));\n    float br = cell(px + ivec2(1, -1));\n    float tl = cell(px + ivec2(-1, 1));\n    float tr = cell(px + ivec2(1,  1));   \n    \n    float sum = b + t + l + r;\n    float diag = bl + br + tl + tr;\n    float dif = abs(b-t) * abs(l-r);\n    \n    sum += diag;\n    \n    //e = clamp(e - 0.001, 0., 1.);    \n    //rand = step(0.9, rand);\n    \n    // > 0 and < 1\n    float th = 0.5; // 0.9\n    \n    // between 0 and 7 ish\n    float s = 3.5;\n    \n    if (e <= 0. && rand >= th && sum <= s)\n        e = (rand - th) / (1.-th);\n    else if (sum >= s || dif >= 0.75) // dif makes corners rounder (maybe)\n        e = 0.;\n        \n    col.g = e;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3cRB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 47, 47, 102], [104, 104, 161, 161, 561]], "test": "untested"}
{"id": "sstcW7", "name": "Mirror into the cosmos", "author": "Roninkoi", "description": "I was playing around with mirror effects using raymarching, so I decided to make the main mirror of the James Webb Space Telescope! I imagine this is how the mirrors move :)", "tags": ["raymarching", "hexagon", "mirror", "telescope", "webb", "jwst"], "likes": 5, "viewed": 331, "published": 3, "date": "1653581252", "time_retrieved": "2024-07-30T16:46:46.509956", "image_code": "#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.05\n#define STEP 0.5\n\n#define MAXRAYS 4\n#define FAR 5.\n\n#define minx4(a, b) ((a.x) < (b.x) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n\nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n\nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n\nfloat torus(vec3 r, vec3 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat box(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\t\n    return length(max(p, 0.));\n}\n\nvec4 boxn(vec3 r, mat3 rot, vec3 a)\n{\n\tfloat h = 0.001;\n\tfloat z = box(r*rot, a);\n\tfloat z1 = box((r+vec3(h, 0., 0.))*rot, a);\n\tfloat z2 = box((r+vec3(0., h, 0.))*rot, a);\n\tfloat z3 = box((r+vec3(0., 0., h))*rot, a);\n\tvec3 n = normalize(vec3(z1 - z, z2 - z, z3 - z));\n\t\n    return vec4(z, n);\n}\n\nfloat hexp(vec3 r, vec3 a)\n{\n    vec3 p = (abs(r) - a);\n\tp.x = clamp(abs(r.x)+(p.y-a.x)*0.57735, 0., 5.*a.x);\n\t\n    return length(max(p, 0.));\n}\n\nvec4 hexpn(vec3 r, mat3 rot, vec3 a)\n{\n\tfloat h = 0.001;\n\tfloat z = hexp(r*rot, a);\n\tfloat z1 = hexp((r+vec3(h, 0., 0.))*rot, a);\n\tfloat z2 = hexp((r+vec3(0., h, 0.))*rot, a);\n\tfloat z3 = hexp((r+vec3(0., 0., h))*rot, a);\n\tvec3 n = normalize(vec3(z1 - z, z2 - z, z3 - z));\n\t\n    return vec4(z, n);\n}\n\nfloat star(vec2 r, float a)\n{\n\tr = mod(r, vec2(2.*3.141, 3.141));\n\treturn length(r-a)-a;\n}\n\nvec4 webb(vec3 r, float roty) {\n\tfloat sqrt3 = 1.73205;\n\t\n\tr = rotY(roty) * r;\n\tmat3 rot = mat3(1.);\n\t\n    float m = sin(t) + 1.;\n    \n    // 04\n    rot = rotX(-0.1*m);\n\tvec4 h1 = hexpn(r+vec3(0., 2., 0.), rot, vec3(0.9, 0.9, 0.3));\n    \n    rot = rotX(0.1*m);\n\th1 = minx4(hexpn(r+vec3(0., -2., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    // 15\n    \n    rot = rotX(0.05*m)*rotY(0.1*m);\n\th1 = minx4(hexpn(r+vec3(-sqrt3, -1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    rot = rotX(-0.05*m)*rotY(-0.1*m);\n\th1 = minx4(hexpn(r+vec3(sqrt3, 1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    // 36\n    \n    rot = rotX(0.05*m)*rotY(-0.1*m);\n\th1 = minx4(hexpn(r+vec3(sqrt3, -1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n    \n    rot = rotX(-0.05*m)*rotY(0.1*m);\n\th1 = minx4(hexpn(r+vec3(-sqrt3, 1., 0.), rot, vec3(0.9, 0.9, 0.3)), h1);\n\t\n    float lz = 10.+sin(t)*10.;\n    \n    // 06\n    rot = rotX(-0.2*m);\n\tvec4 h2 = hexpn(r+vec3(0., 4., 0.2), rot, vec3(0.9, 0.9, 0.3));\n    \n    rot = rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(0., -4., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 39\n    \n    rot = rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, 0., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n     \n    rot = rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, 0., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 28\n    \n    rot = rotX(-0.1*m)*rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, 2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotX(0.1*m)*rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, -2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 410\n    \n    rot = rotX(-0.1*m)*rotY(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-2.*sqrt3, 2., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotX(0.1*m)*rotY(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(2.*sqrt3, -2., 0.3), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 17\n    rot = rotY(-0.1*m)*rotX(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(sqrt3, 3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotY(0.1*m)*rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(-sqrt3, -3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    // 511\n       \n    rot = rotY(-0.1*m)*rotX(0.2*m);\n\th2 = minx4(hexpn(r+vec3(sqrt3, -3., 0.3), rot, vec3(0.9, 0.9, 0.3)), h2);\n    \n    rot = rotY(0.1*m)*rotX(-0.2*m);\n\th2 = minx4(hexpn(r+vec3(-sqrt3, 3., 0.2), rot, vec3(0.9, 0.9, 0.3)), h2);\n\t\n\tvec4 h = minx4(h1, h2);\n\t\n\th.yzw = rotY(-roty) * h.yzw;\n\t\n\treturn h;\n}\n\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n\nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\nvec3 r;\nvec3 rd;\nfloat rs;\nint rnum;\n\nvec4 map()\n{\n\tvec4 d = webb(r + vec3(0., 0., -6.), sin(0.2*t)*0.5);\n    \n    vec3 pn = vec3(0., 0., 1.);\n    float p = plane(r, vec3(0., 0., -2.), pn);\n\t\n    if (p < EPSILON && rnum < MAXRAYS) {\n\t\tr -= rd * rs * STEP;\n\t\trd = normalize(rd-2.*dot(rd, -pn)*(-pn));\n\t\t++rnum;\n\t}\n    if (d.x < EPSILON && rnum < MAXRAYS) {\n\t\tr -= rd * d.x * STEP;\n\t\trd = normalize(rd-2.*dot(rd, d.yzw)*d.yzw);\n        rd = rd * 0.5 + d.yzw * 0.5;\n\t\t++rnum;\n\t}\n    \n    rs = min(d.x, p);\n\t\n\treturn vec4(d.x, vec3(1., 0.65, 0.) * 1.4);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    mat3 cam = rotY(-PI) * rotX(0.3);\n\n    vec3 ro = vec3(0., 2.5, 0.0);\n    rd = cam * normalize(vec3(uv * 2., -1.));\n    r = ro;\n\n    vec3 bcol = vec3(0.05 + sin(-uv.y) * 0.7, 0., 0.2)*0.3;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n\t\n\trnum = 0;\n    rs = 1.;\n\n    float sh = 1.;\n    float glow = 0.;\n    \n    for (int i = 0; i < MAXIT; ++i) {\n        vec4 d = map();\n        float z = length(r - ro);\n\n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, d.yzw,\n                shade(normalize(r), rd));\n\t\t\n            col.rgb = fog(z * 0.1, col.rgb, bcol);\n        }\n        else {\n            glow += exp(-d.x * 2.);\n        }\n        \n        if (z > 2.*FAR)\n            break;\n\n        rs *= 0.8 - 0.2 * hash(uv+vec2(t*uv.x, t*uv.y));\n        r += rd * rs * STEP;\n\n        sh = (float(i) / float(MAXIT));\n\t}\n\tif (length(r) > FAR) {\n\t\tfloat theta = acos(rd.y);\n\t\tfloat phi = atan(rd.z, rd.x);\n\t\tvec3 sky = vec3(0.05 + sin(-rd.y-0.4) * 0.7, 0., 0.2)*0.3;\n\t\t\n\t\tfloat sr1 = hash(vec2(round(2138.*theta)/2138., round(1140.*phi)/1140.));\n\t\tfloat sr2 = hash(vec2(round(1139.*theta)/1139., round(3142.*phi)/3142.));\n\t\tsky += 2. * vec3(1., 1., 0.5) * min(1., max(0., -(100.+(sin(51.*t*sr1)+cos(49.*t*sr2))*50.)*star(vec2(sr1, sr2), 0.02)));\n\n        col.rgb = mix(col.rgb, sky, 0.9);\n\t}\n\n    if (sh < 0.5)\n        col.rgb *= clamp(exp(-sh * 2. + 0.1), 0., 1.);\n    \n    col.rgb = mix(col.rgb, vec3(1.0, 0.5, 0.0), glow * 0.01);\n\n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sstcW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 210, 230, 230, 332], [334, 334, 354, 354, 458], [460, 460, 480, 480, 582], [584, 584, 604, 604, 676], [688, 688, 719, 719, 747], [749, 749, 778, 778, 852], [854, 854, 891, 891, 919], [921, 921, 948, 948, 1010], [1012, 1012, 1049, 1049, 1306], [1308, 1308, 1336, 1336, 1452], [1454, 1454, 1492, 1492, 1753], [1755, 1755, 1784, 1784, 1845], [1847, 1847, 1878, 1878, 4211], [4214, 4214, 4244, 4244, 4299], [4301, 4301, 4343, 4343, 4383], [4433, 4433, 4445, 4445, 4946]], "test": "untested"}
{"id": "fscyRS", "name": "PolySuperFractal", "author": "jpupper", "description": "This is a clasic shader from my library, \n\nPress click and use the mouse to control the fractal. \n\nIt uses feedback to create the fractal", "tags": ["shader", "feedback"], "likes": 5, "viewed": 211, "published": 3, "date": "1653579015", "time_retrieved": "2024-07-30T16:46:47.683819", "image_code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = gl_FragCoord.xy/resolution.xy;\n  \n   /* vec4 prev = texture(iChannel0,uv);\n     prev*= 1.- texture(iChannel1,uv);\n     */\n     \n   vec3 fl = texture(iChannel0,uv).rgb;\n   \n   vec2 puv = uv;\n   \n   puv+=length(fl)*.08;\n   puv.y = 1.-puv.y;\n   vec3 textoloco = texture(iChannel1,puv).rgb;\n     \n        // textoloco = vec3(textoloco.r);\n         //  textoloco=mix(textoloco,fl,textoloco);\n        //textoloco=mix(textoloco,fl,textoloco)*2.1;\n   \n   vec3 fin = fl;\n        fin+=textoloco;\n   fragColor = vec4(fin,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 fractalLoco(){\n    vec2 uv = gl_FragCoord.xy/resolution.xy;\n    \n    uv = fract(uv);\n    //float n = snoise(vec2(uv.x*STnoise,uv.y*STnoise-time*5))*0.5+0.5;\n    \n    vec2 coords = uv;\n    \n    coords -= vec2(0.5);\n    coords = rotate2d(STspeed) * coords;\n    coords += vec2(0.5);\n    \n    vec4 spec2 = vec4(1.0);\n    coords = fract(coords*1.05); \n    vec4 prev = texture(iChannel0,coords);\n    \n\n    int cant = 3;\n    vec3 dib = vec3(0.);\n    \n    vec2 mov = vec2(0.);\n    \n    if(mouse.z > 0.){\n        mov.x = mouse.x/resolution.x;\n        mov.y = mouse.y/resolution.y;\n    }else{\n    \n    \n        mov.x = sin(time)*.4+.5+cos(time*2.)*.2;\n        mov.y = cos(time)*.4+.5+sin(time*2.)*.2;\n    }\n    float e =  poly(\n       uv,\n       mov\n       ,0.08*sin(uv.x*100.+sin(uv.y*30.+time*2.))\n            ,0.08,\n            3\n            ,0.) ;\n    dib+=e;\n       /*  e +=     \n       vec4(poly(\n       uv,\n       vec2(mouse.x,1.-mouse.y)\n       ,0.08*sin(uv.x*100.+sin(uv.y*30.+time*2.))\n            ,0.08,\n            3\n            ,0.));*/\n\n\n        dib.g *= noise(uv,PI/2.)*sin(uv.x*30.);\n        dib.b *= noise(uv,PI);\n        dib.r *= noise(uv,PI/17.)*3.;\n    \n    vec2 p = vec2(0.5) -uv;\n    float r = length(p);\n    //dib = vec3(e);\n    \n    vec3 fin = dib*4.+prev.rgb*0.9;\n    return fin ;\n}\nvec3 generarTextoLoco(){\n     vec3 fractalloco = fractalLoco();\n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ F U N K Y _ B E A T _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=fractalLoco();\n         //col+=fractalLoco();\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n\n// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 generarTextoLoco(){\n   \n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n    \n    \n    uv-=vec2(0.5);\n    uv*=scale(vec2(1.0));\n    uv+=vec2(0.5);\n    \n\tuv *= 40.0 ;\n\t\n    uv -= vec2(-8., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\t//uv.x+=4. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ J P U P P E R _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=generarTextoLoco();\n       //  col+=texto;\n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscyRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[171, 171, 192, 192, 239], [240, 240, 261, 261, 308], [309, 309, 331, 331, 366], [367, 367, 428, 469, 739], [743, 743, 771, 771, 880], [881, 881, 909, 909, 995], [996, 996, 1020, 1020, 1083], [1086, 1086, 1123, 1123, 1715], [1716, 1716, 1738, 1791, 3486], [4145, 4145, 4192, 4192, 4308], [4310, 4310, 4354, 4354, 4464], [4466, 4466, 4525, 4525, 4601], [4603, 4612, 4653, 4653, 4684], [4686, 4686, 4724, 4724, 4761], [4763, 4763, 4816, 4816, 4886], [4889, 4889, 4931, 4931, 4959], [4961, 4961, 5018, 5018, 5092], [5096, 5096, 5143, 5143, 5207], [5209, 5209, 5253, 5253, 5363], [5365, 5365, 5424, 5424, 5500], [5501, 5501, 5549, 5549, 5605], [5607, 5607, 5652, 5652, 5765], [5767, 5767, 5827, 5827, 5904], [5906, 5906, 5950, 5950, 5977], [5979, 5979, 6020, 6020, 6121], [6123, 6123, 6179, 6179, 6252], [6255, 6255, 6300, 6300, 6327], [6329, 6329, 6389, 6389, 6466], [6469, 6469, 6513, 6513, 6550], [6552, 6552, 6611, 6611, 6687], [6689, 6689, 6734, 6734, 6761], [6763, 6763, 6805, 6805, 6909], [6911, 6911, 6968, 6968, 7042], [7043, 7043, 7091, 7140, 7175], [7177, 7177, 7222, 7270, 7317], [7319, 7319, 7379, 7379, 7456], [7457, 7457, 7506, 7550, 7581], [7583, 7583, 7629, 7672, 7709], [7711, 7711, 7772, 7772, 7850], [7851, 7851, 7900, 7900, 7996], [7998, 7998, 8044, 8044, 8160], [8162, 8162, 8223, 8223, 8301], [8302, 8302, 8345, 8345, 8367], [8369, 8369, 8427, 8427, 8502], [8505, 8505, 8548, 8548, 8595], [8597, 8597, 8655, 8655, 8730], [8732, 8732, 8773, 8773, 8790], [8792, 8792, 8848, 8848, 8921], [8923, 8923, 8968, 8968, 9038], [9040, 9040, 9082, 9082, 9186], [9188, 9188, 9245, 9245, 9319], [9320, 9320, 9362, 9362, 9415], [9417, 9417, 9474, 9474, 9548], [9549, 9549, 9595, 9595, 9685], [9687, 9687, 9730, 9730, 9837], [9839, 9839, 9897, 9897, 9972], [9974, 9974, 10019, 10019, 10080], [10082, 10082, 10124, 10124, 10228], [10230, 10230, 10287, 10287, 10361], [10365, 10365, 10409, 10409, 10449], [10451, 10451, 10492, 10492, 10593], [10595, 10595, 10651, 10651, 10724], [10725, 10725, 10772, 10772, 10807], [10809, 10809, 10853, 10853, 10900], [10902, 10902, 10961, 10961, 11038], [11039, 11039, 11087, 11087, 11183], [11185, 11185, 11230, 11230, 11343], [11345, 11345, 11405, 11405, 11482], [11483, 11483, 11527, 11527, 11563], [11565, 11565, 11624, 11624, 11700], [11701, 11701, 11740, 11740, 11776], [11778, 11778, 11832, 11832, 11903], [11905, 11905, 11950, 11950, 12003], [12005, 12005, 12047, 12047, 12151], [12153, 12153, 12210, 12210, 12284], [12287, 12287, 12337, 12337, 13968], [13969, 13969, 14033, 14033, 15864], [15867, 15867, 15924, 15924, 16457]], "test": "untested"}
{"id": "Ns3yRS", "name": "Palos de boliche", "author": "jpupper", "description": "You are on a DISCO BAR. You have drink way to much, taken some pills, the music is very loud , your head is spinning and spinning non stop.", "tags": ["raymarching", "disco", "lights", "bar"], "likes": 6, "viewed": 346, "published": 3, "date": "1653578314", "time_retrieved": "2024-07-30T16:46:48.775898", "image_code": "// VARIABLES GLOBALES\nfloat det = .001; // umbral para detectar choque \nvec3 lightpos1, lightpos2,lightpos3; // posicion de las luces\nfloat light1, light2,light3; // distancia a las luces\nvec3 light1color = vec3(2.,0.,0.); // color luz 1\nvec3 light2color = vec3(0.,2.,2.); // color luz 2\nvec3 light3color = vec3(0.,0.2,.0); // color luz 2\n\n#define pi 3.14159265359\n#define time iTime\n#define resolution iResolution\n// matriz de rotacin\nmat2 rot(float a) \n{\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n// distancia a un octaedro\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\nvec3 rgb2hsb( in vec3 c ){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz),\n                 vec4(c.gb, K.xy),\n                 step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r),\n                 vec4(c.r, p.yzx),\n                 step(p.x, c.r));\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)),\n                d / (q.x + e),\n                q.x);\n}\n\n//  Function from Iigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),\n                             6.0)-3.0)-1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n// funcin de distancia (distance estimation)\nfloat de(vec3 p) \n{\n    light1 = length(p - lightpos1) - .1; // distancia a las luces, que estn definidas como esferas de radio .1\n    light2 = length(p - lightpos2) - .1; // \n    \n    vec3 p2 = p; \n    \n    \n    p.yz *= rot(pi/4.+sin(time*.3)*1.); // rotaciones\n    p.xz *= rot(time * .1);\n    p.xy *= rot(time * .1+cos(time*.025)*2.);\n    //p.x = sin(p.x+time*2.);\n    //p- = sin(p.y+time*2.);\n    \n    \n    \n    float oct = max(sdOctahedron(p, 5.), -length(p)+0.3); // distancia a octaedro restando una esfera\n    \n    float ms = floor(4.0)+1.;\n    float id2 = floor(p.x/ms);\n\n    \n    p.y+=time;\n    p.x = mod(p.x, ms) - ms/2.;\n    p.z = mod(p.z, ms) - ms/2.;\n \n    p.y = mod(p.y, ms) - ms/2.;\n    \n   // p.x = sin(p.x*1.0+time);\n    \n\n    oct = sdTorus(p,vec2(1.+sin(p.z*1.+time*1.+sin(id2*30.+time)*10.)*.3,0.1));   \n    \n    \n     float idx2 = sin(id2*2.);\n    \n    \n     float s =  exp(-.2 * sin(distance(p, lightpos1)*2.+time)*.4);\n     oct = sdSphere(p,0.8);\n     oct = sdRoundBox(p,vec3(0.1,.1,sin(id2*10.)*4.+2000000000000.1),0.01);\n    \n    \n    \n    float d = min(oct, min(light1, light2)*10.); // obtencin de distancia mnima (combinar objetos)\n    \n    \n    p2.z+=30.5;\n    float d2 = max(d,1.-sdSphere(p2,10.9));\n          //d2 = min(d,sdSphere(p2,4.9));\n    \n    return d2*0.53;\n}\n\n\n// funcin normal (vector perpendicular a la superficie)\nvec3 normal(vec3 p) \n{\n    vec2 d = vec2(0., det);\n    return normalize(vec3(de(p+d.yxx), de(p+d.xyx), de(p+d.xxy)) - de(p));\n}\n\n\n// funcin shade (p = punto en el que golpe el rayo, dir = direccin del rayo)\nvec3 shade(vec3 p, vec3 dir)\n{   \n    \n    \n    \n    float l1 = length(p.xyz);\n    \n    light1color = vec3(1.0,sin(l1*10.+time*.1),1.0);\n\n    light2color = vec3(0.3,0.0,sin(l1*10.)*.5+.5);\n\n    vec3 c1 = vec3(1.0,0.7,0.0);\n    \n    vec3 c2 = vec3(1.0,0.0,0.8);\n    \n    \n    l1  = exp(-.5 * distance(p, lightpos1));\n    l1 = sin(l1*10.+time+sin(p.x));\n    //l1 = smoothstep(0.9,0.9,l1);\n    light1color = mix(c1,c2,l1);\n    \n    //light1color = hsb2rgb(vec3(l1,1.0,1.0));\n    \n    if (light1 < det) return light1color; // si golpe a una luz, devolver el color de la misma\n    if (light2 < det) return light2color; // sin aplicar obviamente el clculo de su propia iluminacin\n    \n    vec3 lightdir1 = normalize(lightpos1 - p); // obtencin de la direccin hacia donde estn las luces\n    vec3 lightdir2 = normalize(lightpos2 - p); // desde el punto p\n    vec3 lightdir3 = normalize(lightpos3 - p); // desde el punto p\n     \n    \n    float fade1 = exp(-.2 * distance(p, lightpos1)); // atenuacin de la luz basada en la distancia entre p\n    float fade2 = exp(-.2 * distance(p, lightpos2)); // y la posicin de las mismas\n    \n    vec3 n = normal(p); // obtencin de la normal\n    \n    \n    vec3 amb = mix(c1,c2,0.5)*.03; // luz ambiental\n    vec3 dif1 = max(0., dot(lightdir1, n)) * light1color * fade1 * .7; // luces difusas, se aplica el color de la luz\n    vec3 dif2 = max(0., dot(lightdir2, n)) * light2color * fade2 * .7; // y la atenuacin segn la distancia\n     vec3 ref1 = reflect(lightdir1, n); // vector reflejo entre la direccin de la luz y\n    vec3 ref2 = reflect(lightdir2, n); // el normal de la superficie\n    \n    vec3 spe1 = pow(max(0., dot(ref1, dir)),10.) * light1color * fade1; // calculo de luz especular, tambin \n    vec3 spe2 = pow(max(0., dot(ref2, dir)),10.) * light2color * fade2; // teniendo en cuenta la atenuacin por distancia\n    \n    return amb + dif1 + spe1 +dif2+spe2 ; // color final combinando las luces\n}\n\n// funcin de raymarching\nvec3 march(vec3 from, vec3 dir) \n{\n    float maxdist = 50.;\n    float totdist = 0.;\n    float steps = 100.;\n    float d;\n    vec3 p;\n    vec3 col = vec3(0.);\n    float glow1 = 0., glow2 = 0.,glow3 = 0.; // variables para la obtencin del brillo \"glow\" alrededor de las luces\n    float glowgeneral = 0.; // variable para la obtencin de glow general con \"step count\"\n    for (float i=0.; i<steps; i++)\n    {\n        p = from + totdist * dir;\n        d = de(p);\n        if (d < det || totdist > maxdist) break;\n        totdist += d;\n        glow1 = max(glow1, 1. - light1); // capturamos cuando el rayo pasa cerca de las luces, obteniendo un valor\n        glow2 = max(glow2, 1. - light2); // entre 0 y 1 segn la distancia a la que pas\n      \n        glowgeneral++; // step counting para obtener brillo glow general\n    }\n    \n    if (d < det) \n    {\n        col = shade(p, dir);\n    }\n    \n    col+=smoothstep(.99,.99,sin(shade(p,dir)*100.+10.+pi/2.));\n    \n    if(length(col) > .9){\n        //col = vec3(0.0);\n    }\n    \n    col += pow(glow1, 5.) * light1color; // sumamos el brillo glow de las luces, elevando a un exponente\n   \n   // col += pow(glow2, 5.) * light2color; // para definir el tamao del glow    \n //   col += glowgeneral * glowgeneral * .00001; // lo mismo para el glow general que se puede apreciar en el objeto\n    // este glow genera \"banding\", sobre todo si no est exponenciado\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  \n    vec2 uv = (gl_FragCoord.xy - resolution.xy / 2.) / resolution.y;\n    vec2 puv  = fragCoord.xy / iResolution.xy; ;\n    vec3 from = vec3(0., 0., -25.);\n    vec3 dir = normalize(vec3(uv, 1.5));\n    lightpos1 = vec3(sin(time) * 2., sin(time * 1.), sin(time*1.)*5.); // definimos la posicin de las luces\n    lightpos2 = -lightpos1.yxz; // copia las coordenadas de la luz 1 rotando los ejes\n   \n    vec3 col = march(from, dir);\n    \n    \n    puv.x-=0.35;\n    \n    puv.y+=0.48;\n    puv.y = 1.-puv.y;\n    vec3 textoloco = texture(iChannel0,puv).rgb;\n    textoloco = vec3((textoloco.r+textoloco.g+textoloco.b)/3.);\n    textoloco*=col;\n    \n    \n    col += textoloco*3.*abs(fract(time*.1)*2.-1.);\n    \n    //col = blendMode(16,col,textoloco,1.0);\n    fragColor = vec4(col, 1.);\n    \n    \n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 generarTextoLoco(){\n   \n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n    \n    \n\tuv *= 40.0 ;\n\t\n    uv -= vec2(-8., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\t//uv.x+=4. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ J P U P P E R _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=generarTextoLoco();\n       //  col+=texto;\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [], "common_code": "float STfeed = 0.971;\nfloat STspeed = 0.81;\n\n#define time iTime\n#define resolution iResolution\n#define mouse iMouse\n#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n\nvec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }\nvec3 permute(vec3 x) { return mod289(((x*34.0)+1.0)*x); }\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    \n    // Remap the space to -1. to 1.\n    \n    vec2 st = p - uv ;\n    \n    \n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    float r = TWO_PI/float(N);\n    \n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,dif,d);\n      \n    return e;\n}\n\n\n\nfloat random (in vec2 _st) {\n    return fract(sin(dot(_st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.56222123);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\n\n\nfloat noise (in vec2 st,float fase) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    float fase2 = fase;\n    // Four corners in 2D of a tile\n    float a = sin(random(i)*fase2);\n    float b =  sin(random(i + vec2(1.0, 0.0))*fase2);\n    float c =  sin(random(i + vec2(0.0, 1.0))*fase2);\n    float d =  sin(random(i + vec2(1.0, 1.0))*fase2);\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\nfloat snoise(vec2 v) {\n\n    // Precompute values for skewed triangular grid\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0):vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod289(i);\n    vec3 p = permute(\n            permute( i.y + vec3(0.0, i1.y, 1.0))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n    vec3 m = max(0.5 - vec3(\n                        dot(x0,x0),\n                        dot(x1,x1),\n                        dot(x2,x2)\n                        ), 0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n\n    // Normalise gradients implicitly by scaling m\n    // Approximation of: m *= inversesqrt(a0*a0 + h*h);\n    m *= 1.79284291400159 - 0.85373472095314 * (a0*a0+h*h);\n\n    // Compute final noise value at P\n    vec3 g = vec3(1);\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * vec2(x1.x,x2.x) + h.yz * vec2(x1.y,x2.y) ;\n    return 20.0 * dot(m, g);\n}\n\n/*************************************************/\n\n// TODAS LAS FUNCIONES DE BLENDING SACADAS DE  https://github.com/jamieowen/glsl-blend\n\n\n///SOFT LIGHT\n#define ADD 1 \n#define\tAVERAGE 2\n#define\tCOLOR_BURN 3\n#define\tCOLOR_DODGE 4\n#define\tDARKEN 5\n#define\tDIFFERENCE 6\n#define\tEXCLUSION 7\n#define\tGLOW 8\n#define\tHARD_LIGHT 9\n#define\tHARD_MIX 10\n#define\tLIGHTEN 11\n#define\tLINEAR_BURN 12\n#define\tLINEAR_DODGE 13\n#define\tLINEAR_LIGHT 14\n#define\tMULTIPLY 15\n#define\tNEGATION 16\n#define\tNORMAL 17\n#define\tOVERLAY 18\n#define\tPHOENIX 19\n#define\tPIN_LIGHT 20\n#define\tREFLECT 21\n#define\tSCREEN 22\n#define\tSOFT_LIGHT 23\n#define\tSUBTRACT 24\n#define\tVIVID_LIGHT 25\n\n\nfloat blendSoftLight(float base, float blend) {\n\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend) {\n\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\n}\n\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n//ADD : \nfloat blendAdd(float base, float blend) {\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendAdd(vec3 base, vec3 blend) {\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendAdd(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAdd(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendAverage(vec3 base, vec3 blend) {\n\treturn (base+blend)/2.0;\n}\n\nvec3 blendAverage(vec3 base, vec3 blend, float opacity) {\n\treturn (blendAverage(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendColorBurn(float base, float blend) {\n\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend) {\n\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\n}\n\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendColorDodge(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend) {\n\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\n}\n\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendDarken(float base, float blend) {\n\treturn min(blend,base);\n}\n\nvec3 blendDarken(vec3 base, vec3 blend) {\n\treturn vec3(blendDarken(base.r,blend.r),blendDarken(base.g,blend.g),blendDarken(base.b,blend.b));\n}\n\nvec3 blendDarken(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDarken(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendDifference(vec3 base, vec3 blend) {\n\treturn abs(base-blend);\n}\n\nvec3 blendDifference(vec3 base, vec3 blend, float opacity) {\n\treturn (blendDifference(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendExclusion(vec3 base, vec3 blend) {\n\treturn base+blend-2.0*base*blend;\n}\n\nvec3 blendExclusion(vec3 base, vec3 blend, float opacity) {\n\treturn (blendExclusion(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendLighten(float base, float blend) {\n\treturn max(blend,base);\n}\n\nvec3 blendLighten(vec3 base, vec3 blend) {\n\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\n}\n\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearBurn(float base, float blend) {\n\t// Note : Same implementation as BlendSubtractf\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendSubtract\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearDodge(float base, float blend) {\n\t// Note : Same implementation as BlendAddf\n\treturn min(base+blend,1.0);\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\n\t// Note : Same implementation as BlendAdd\n\treturn min(base+blend,vec3(1.0));\n}\n\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendLinearLight(float base, float blend) {\n\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend) {\n\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\n}\n\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendMultiply(vec3 base, vec3 blend) {\n\treturn base*blend;\n}\n\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\n\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendNegation(vec3 base, vec3 blend) {\n\treturn vec3(1.0)-abs(vec3(1.0)-base-blend);\n}\n\nvec3 blendNegation(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNegation(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nvec3 blendNormal(vec3 base, vec3 blend) {\n\treturn blend;\n}\n\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\n\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendOverlay(float base, float blend) {\n\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend) {\n\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\n}\n\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\n\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendPhoenix(vec3 base, vec3 blend) {\n\treturn min(base,blend)-max(base,blend)+vec3(1.0);\n}\n\nvec3 blendPhoenix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPhoenix(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendPinLight(float base, float blend) {\n\treturn (blend<0.5)?blendDarken(base,(2.0*blend)):blendLighten(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend) {\n\treturn vec3(blendPinLight(base.r,blend.r),blendPinLight(base.g,blend.g),blendPinLight(base.b,blend.b));\n}\n\nvec3 blendPinLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendPinLight(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendReflect(float base, float blend) {\n\treturn (blend==1.0)?blend:min(base*base/(1.0-blend),1.0);\n}\n\nvec3 blendReflect(vec3 base, vec3 blend) {\n\treturn vec3(blendReflect(base.r,blend.r),blendReflect(base.g,blend.g),blendReflect(base.b,blend.b));\n}\n\nvec3 blendReflect(vec3 base, vec3 blend, float opacity) {\n\treturn (blendReflect(base, blend) * opacity + base * (1.0 - opacity));\n}\n  \nfloat blendScreen(float base, float blend) {\n\treturn 1.0-((1.0-base)*(1.0-blend));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend) {\n\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\n}\n\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\n\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\n}\nfloat blendSubstract(float base, float blend) {\n\treturn max(base+blend-1.0,0.0);\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend) {\n\treturn max(base+blend-vec3(1.0),vec3(0.0));\n}\n\nvec3 blendSubstract(vec3 base, vec3 blend, float opacity) {\n\treturn (blendSubstract(base, blend) * opacity + blend * (1.0 - opacity));\n}\nfloat blendVividLight(float base, float blend) {\n\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend) {\n\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\n}\n\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendHardLight(vec3 base, vec3 blend) {\n\treturn blendOverlay(blend,base);\n}\n\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\n}\nvec3 blendGlow(vec3 base, vec3 blend) {\n\treturn blendReflect(blend,base);\n}\n\nvec3 blendGlow(vec3 base, vec3 blend, float opacity) {\n\treturn (blendGlow(base, blend) * opacity + base * (1.0 - opacity));\n}\n\nfloat blendHardMix(float base, float blend) {\n\treturn (blendVividLight(base,blend)<0.5)?0.0:1.0;\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend) {\n\treturn vec3(blendHardMix(base.r,blend.r),blendHardMix(base.g,blend.g),blendHardMix(base.b,blend.b));\n}\n\nvec3 blendHardMix(vec3 base, vec3 blend, float opacity) {\n\treturn (blendHardMix(base, blend) * opacity + base * (1.0 - opacity));\n}\n\n\nvec3 blendMode( int mode, vec3 base, vec3 blend ){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend );\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend );\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend );\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend );\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend );\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend );\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend );\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend );\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend );\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend );\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend );\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend );\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend );\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend );\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend );\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend );\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend );\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend );\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend );\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend );\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend );\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend );\n\t}\n\treturn vec3(0.0);\n}\nvec3 blendMode( int mode, vec3 base, vec3 blend ,float opacity){\n\tif( mode == 1 ){\n\t\treturn blendAdd( base, blend ,opacity);\n\t}else\n\tif( mode == 2 ){\n\t\treturn blendAverage( base, blend ,opacity);\n\t}else\n\tif( mode == 3 ){\n\t\treturn blendColorBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 4 ){\n\t\treturn blendColorDodge( base, blend ,opacity);\n\t}else\n\tif( mode == 5 ){\n\t\treturn blendDarken( base, blend ,opacity);\n\t}else\n\tif( mode == 6 ){\n\t\treturn blendDifference( base, blend ,opacity);\n\t}else\n\tif( mode == 7 ){\n\t\treturn blendExclusion( base, blend,opacity );\n\t}else\n\tif( mode == 8 ){\n\t\treturn blendGlow( base, blend ,opacity);\n\t}else\n\tif( mode == 9 ){\n\t\treturn blendHardLight( base, blend ,opacity);\n\t}else\n\tif( mode == 10 ){\n\t\treturn blendHardMix( base, blend,opacity );\n\t}else\n\tif( mode == 11 ){\n\t\treturn blendLighten( base, blend ,opacity);\n\t}else\n\tif( mode == 12 ){\n\t\treturn blendLinearBurn( base, blend ,opacity);\n\t}else\n\tif( mode == 13 ){\n\t\treturn blendLinearDodge( base, blend,opacity );\n\t}else\n\tif( mode == 14 ){\n\t\treturn blendLinearLight( base, blend ,opacity);\n\t}else\n\tif( mode == 15 ){\n\t\treturn blendMultiply( base, blend ,opacity);\n\t}else\n\tif( mode == 16 ){\n\t\treturn blendNegation( base, blend ,opacity);\n\t}else\n\tif( mode == 17 ){\n\t\treturn blendNormal( base, blend ,opacity);\n\t}else\n\tif( mode == 18 ){\n\t\treturn blendOverlay( base, blend ,opacity);\n\t}else\n\tif( mode == 19 ){\n\t\treturn blendPhoenix( base, blend ,opacity);\n\t}else\n\tif( mode == 20 ){\n\t\treturn blendPinLight( base, blend ,opacity);\n\t}else\n\tif( mode == 21 ){\n\t\treturn blendReflect( base, blend ,opacity);\n\t}else\n\tif( mode == 22 ){\n\t\treturn blendScreen( base, blend ,opacity);\n\t}else\n\tif( mode == 23 ){\n\t\treturn blendSoftLight( base, blend ,opacity);\n\t}else\n\tif( mode == 24 ){\n\t\treturn blendSubstract( base, blend ,opacity);\n\t}else\n\tif( mode == 25 ){\n\t\treturn blendVividLight( base, blend ,opacity);\n\t}\n\treturn vec3(0.0);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3yRS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 438, 458, 458, 517], [519, 546, 584, 584, 637], [639, 639, 672, 672, 737], [739, 739, 774, 774, 798], [799, 799, 844, 844, 935], [936, 936, 962, 962, 1392], [1394, 1468, 1494, 1494, 1726], [1727, 1774, 1793, 1793, 3077], [3080, 3138, 3160, 3160, 3265], [3268, 3351, 3381, 3381, 5311], [5313, 5340, 5374, 5374, 6763], [6765, 6765, 6822, 6822, 7611]], "test": "untested"}
{"id": "ssccW7", "name": "Pixel Clusters 78231", "author": "SnoopethDuckDuck", "description": "Very messy code, just a few ideas", "tags": ["feedback", "cellularautomata"], "likes": 8, "viewed": 212, "published": 3, "date": "1653577851", "time_retrieved": "2024-07-30T16:46:49.761263", "image_code": "vec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5*cos( 6.28318*(0.5*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float zm = 0.2;\n    \n    vec2 res = floor(iResolution.xy);\n    \n    vec2 f = fragCoord;vec2(abs(fragCoord.x - 0.5 * res.x) + 0.5 * res.x, fragCoord.y);\n    vec2 f2 = vec2(res.x-f.x, f.y);\n\n    vec4 col = texelFetch( iChannel0, ivec2(zm * f + 0.5 * (1.-zm) * res), 0);\n  //  vec3 col2 = texelFetch( iChannel0, ivec2(zm * f2 - vec2(1,0) + 0.5 * (1.-zm) * res), 0).rgb;\n    \n   // if (col.r >= 1.)\n     //   col *= 0.;\n    if (col.b == 1.)\n        col.rgb = vec3(0.1);\n    else if (col.rgb == vec3(0,1,0))\n        col.rgb = vec3(1);\n    else if (col.rgb == vec3(1,0,0))\n        col.rgb = vec3(0.999);\n    else\n        col.rgb = vec3(0);//pal(h21(f), 0.5 * vec3(0,1,2)/3.);\n        \n    float o = (5. / 8.) * floor(iTime/3.)+ floor(8. * uv.y)/8.;\n    if (col.rgb == vec3(0))\n        col.rgb = pal(o, 1. * vec3(0,1,2)/3.);\n    else if (col.rgb == vec3(1))\n        col.rgb = pal(o - 0., uv.x * vec3(0,1,2)/3.);\n      \n    fragColor.rgb = col.rgb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define pi 3.14159\n\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    f -= p;\n    vec2 dir = .5 * (q - p),\n         v = step(abs(f - round(dir/dir.yx * f.yx)), vec2(0)),\n         a = step(abs(f - dir), abs(dir));  \n    return max(v.x, v.y) * a.x * a.y ;           \n}\n\nfloat getShape(vec2 f) {\n    f -= 0.5;\n    vec2 p = vec2(0);\n    float s = 0.;\n    float t = 0.01 * floor(iTime);\n    float a = 0.;\n\n    float n = 100.;\n    for (float i = 0.; i < n; i++) {\n        float j = i + t;\n        float h = h21(vec2(j , 103. + j));\n        float h2 = h21(vec2(j-10.,3. * j));\n      \n       // float m = 0.;mod(i, 2.);\n        a += 0.25 * pi * (2. * floor(h) - 1.);// * (0.25 * floor((2. + m) * h)-m);\n               \n        vec2 q = p + ceil(h2 * 4.) * vec2(cos(a), sin(a));\n        q = round(q);\n        \n        s = max(s, pxLine(f, p, q));\n        s = max(s, pxLine(vec2(-f.x-1., f.y), p, q));\n\n        p = q;\n    }     \n    return s;\n}\n\nfloat getShape2(vec2 f) {\n    \n    float t = 0.01 * floor(iTime);\n    float s = 0.;//step(d, 4.);\n    \n    for (float i = 2.; i < 15.; i++) {\n        vec2 g = f + 400. * vec2(h21(f), h21(vec2(-f.y,f.x+1.)));\n        vec2 fpos = mod(g, 2. * i) - i;\n        vec2 ipos = g - fpos;\n        s += step(length(fpos), i) * step(h21(ipos + 0.01 * floor(iTime)),0.025);\n    }\n    \n    \n    /*\n    float n = 100.;\n    for (float i = 0.; i < n; i++) {\n        float j = i + 0.01 * floor(iTime);\n        float h = h21(vec2(j+41.,1.3*j));\n        float h2 = h21(vec2(1.4 * j, j - 43.5));\n        s = max(s, step(length(f+ (15. - 30. * vec2(h,h2))), 2.));\n    }\n    */\n    return s;\n}\n\nvec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\n// because im lazy\nfloat alpha(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).a;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n\n    col.rgb = cell(px);\n    col.a = alpha(px);\n    \n    vec3 b = cell(px - ivec2(0,1));\n    vec3 t = cell(px + ivec2(0,1));\n    vec3 l = cell(px - ivec2(1,0));\n    vec3 r = cell(px + ivec2(1,0));\n    \n    vec3 bl = cell(px + ivec2(-1,-1));\n    vec3 tl = cell(px + ivec2(-1,1));\n    vec3 br = cell(px + ivec2(1,-1));\n    vec3 tr = cell(px + ivec2(1,1));\n        \n    float sum = b.r + t.r + l.r + r.r;\n    float sumb = b.b+t.b+l.b+r.b;\n    vec3 col2 = vec3(0);\n    \n    if (frame == 0 || key_down(KEY_RESET)) {\n        vec2 res = floor(0.5 * iResolution.xy);\n\n        col.b = 0.;\n        col.rg = vec2(1) * clamp(getShape2(f-res), 0., 1.);\n        col.a = 0.;\n        \n        //if (length(f-res) < 25. && length(f-res) > 24.)\n         //   col.r = 1.;\n\n        if (f.x < 1. || f.y < 1.)\n            col.g = 0.;\n        else\n            col.g = 1.;\n       // if (f.x < res.x && f.x > res.x - 1. && f.y < res.y && f.y > res.y - 1.)\n         //   col.g = 2.;\n        \n        return;\n    } \n    else if (frame == 1) {\n        if (col.r == 1. && sum == 0.)\n            col.r = 0.;\n    }\n    else if (frame <= 5) {\n        if (sum >= 2.)\n            col.r = 1.;\n    } \n    else if (frame <= 6) {\n        if (sum <= 2.)\n            col.r = 0.;\n    }\n    else if (frame <= 10) {\n        if (sum <= 1.)\n            col.r = 0.;\n    }\n    else if (frame <= 11) {\n        if (col.r == 0. && sum > 0.) {\n            col.b = 1.;//vec3(0,0,1);\n        }\n    }\n    else if (frame <= 12) {\n        if (col.b == 1. && sumb == 3.) {\n            col.b = 0.;\n            col.rg = vec2(1);\n        }            \n    }\n    else if (frame <= 13) {\n        if (col.b == 1. && sumb <= 1. && sum >= 3.) {\n            col.b = 0.;\n            col.rg = vec2(1);\n        }\n    }\n    else if (frame <= 14) {\n        if (col.rg == vec2(1) && sum == 3. && sumb == 0.)\n            col.b = 1.;\n    }\n    else if (frame <= 15) {\n        if (col.rg == vec2(1) && sumb > 0.)\n            col.g = 0.;\n    }\n    //*/\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_b_inputs": [], "common_code": "#define frame iFrame % 180\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssccW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 82], [84, 84, 141, 141, 1154]], "test": "untested"}
{"id": "NstyW7", "name": "Kagisoo", "author": "kagiso34", "description": "Paying with sound spectrum, iq's cosine palette and polar coordinates.", "tags": ["2d", "sound", "polar"], "likes": 1, "viewed": 228, "published": 3, "date": "1653542744", "time_retrieved": "2024-07-30T16:46:50.581071", "image_code": "\n// \"SoundSpector\"\n// by Julien Vergnaud @duvengar-2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define CEL 64.                  // How many buckets to divide spectrum into\n\n// the original accurate spectrum was taken from \n// https://www.shadertoy.com/view/lt2fRz by 834144373\n\n#define barSize 1.0 / CEL        // Constant to avoid division in main loop\n#define sampleSize 0.2           // How accurately to sample spectrum\n\n// iq's cosine palette function\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\n\n// logo distance function written specially for the occasion :)\nfloat rect(vec2 uv,vec2 p, float w, float h, float blur){\n    \n    uv += p;\n    float rv = S(w, w + blur, length(uv.x));\n    float rh = S(h, h + blur, length(uv.y));\n    return SAT( rv + rh);\n}\n\nfloat logo(vec2 uv, float blur){    \n    uv += vec2(.001,.008);\n    uv.y *= 1.15;\n\n    float as = blur;\n    // first make 4 circles\n    float s1 = S(.011 - as, .011, length(uv - vec2(-.035,.0)));\n    float s2 = S(.019 - as, .019, length(uv - vec2(-.015,.01)));\n    float s3 = S(.023 - as, .023, length(uv - vec2(.01,.02)));\n    float s4 = S(.0142 - as, .0142, length(uv - vec2(.035,.0022)));\n    // then a rectangle\n    float r1 = rect(uv, vec2(.0,-.0012), .032, .0101, as);\n    // make vertical lines stripes for part off the screen\n          uv = uv.x > -.0072 ? uv : fract(uv * 220.);\n    float lines = S(.7, .7 + as,length(uv.x + .25));\n    // merge circles together\n    float shape =  SAT(s1 * s2 * s3 * s4 * r1); \n    // and finally substract the line from the shape\n    shape = 1. - max(shape, lines);\n    \n    return SAT(shape);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 U ) {\n  \t\n \n   \t// DOMAIN\n    vec2 uv = (U -.5 * R)/R.x;\n    vec2 uv2  = 1. - 2. * U / R;                       // additionnal domain for post processing effect       \n    vec2 st = uv;   \t\t\t\t\t               // store original domain before distortion\n    uv *= M(TWO_PI / 8. * cos(length(st)) * 20.);      // rotate and twist domain \n    vec2 pol = vec2(atan(uv.x, uv.y), length(uv));     // polar coordinates\n    float alfa = pol.x / TWO_PI + .5;                  // full polar domain from -PI to PI\n    \n    uv = vec2(alfa , pol.y);                           // convert domain to polar coordinates\n   \t\n    \n    // SPECTRUM\n    float barStart = floor(uv.x * CEL) / CEL;          // spectrum buckets id's\n    float amp = .0;  \n    amp -= texture(iChannel0,vec2(400.,0.),0.).x;      // store global sound amplitude\n    \n    float intensity = .0;                              // loop get all buckets intensity\n    \n    for(float i = 0.0; i < barSize; i += barSize * sampleSize)\n    {      \n        intensity += .9 * texture(iChannel0, vec2(barStart + i, 0.)).r;  \n    }\n    \n\tintensity *= sampleSize;                           // accurate intensity\n\tintensity  = clamp(intensity + .1, 0.29, 1.);       // apply floor on lower intensities   \n    float height  = S(.0,.005, intensity - uv.y * 3.);   // height of the bucket\n  \t\n     \n    // SHADING                                         // I'm using iq's cosine color palette for coloring\n    vec3 pal = palette(intensity -.2,\n                            vec3(.5, .5, .0),\n                            vec3(.5,.5,.35),\n                            vec3(.9,.5,.3),\n                            vec3(vec2(intensity * length(uv) + uv.y), 1.)); \t\t\n    \n    vec4 spectrum =  vec4(SAT(pal) * height, 1.);               // final colored spectrum\n    float lines  = S(.2, .4, .85*length(fract(uv.x * CEL)-.5)); // lines gap to be substrated from the spectrum\n    float center = 1.- S(.09, .091, length(st));\t            // circle to be substrated from the spectrum\n    float c0     = 1.- S(.082, .083, length(st));               // highlight circle of the logo bakground\n    vec4 bg = vec4(.1,.15,.3, 1.);\t\t\t\t\t            // base color bakground\n    vec3 pat  = texture(iChannel1, U / R).xyz;                  // get image texture from buffer A\n    \n    bg      += -amp/3.+.1 * vec4(max(pat,center), 1.);                 // connect bg luminosity to global amplitude\n    bg      += .23 * S(.03,.0,length(st));                             // hightlight middle of screen\n    float lns = S(.5,.51,length(fract(pol.y*250.)));                   // radial lines pattern applied on bg\n\tbg -= length(pol.y*.1) * lns;                       \n    bg += .05 * length( (st.y + .08)* 30.) * c0;                       // apply highlight on logo circle bg\n    vec4 col = min(vec4(spectrum),vec4(spectrum) - (lines + center)) ; //substract middle of the spectrum\n    col = mix( SAT(bg), SAT(3. * col), .5);\n    \n    \n    // POSTPROD\n    col += .1 * hash2(T + st * vec2(1462.439, 297.185));               // animated grain (hash2 function in common tab)\n    col *= 1.1 * vec4(.9 - S(.0, 2.2, length(uv2*uv2)));               // vigneting\n    col = pow(col, vec4(1.3));                                         // gamma\n    \n    \n    // LOGO\n    col = 1.1 * col + logo(st * (.9+amp*.4), .003 ) * 4. ;\t                // add soundcloud logo\n \tcol += (.075*amp)* logo((st- vec2(.0,-.009)) * (.75 + amp *.1), .004) * 2. ;   // add soundcloud logo shadows\n    \n     \n    fragColor = col ;\n    \n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 13474, "src": "https://soundcloud.com/vicariousbliss/may68-the-prisoner-vicarious-bliss-halfweg-80s-extended-vocal-rework", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define T iTime\n#define R iResolution.xy\n#define LOWRES 320.\n#define SAT(a) clamp(a, .0,1.)\n#define S(a, b, c) smoothstep(a, b, c)\n#define M(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n#define PI acos(-1.)\n#define TWO_PI (PI * 2.)\n\n\n/////////////////////////////////////////////\n// hash2 taken from Dave Hoskins \n// https://www.shadertoy.com/view/4djSRW\n/////////////////////////////////////////////\n\nfloat hash2(vec2 p)\n{  \n\tvec3 p3  = fract(vec3(p.xyx) * .2831);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n/////////////////////////////////////////////\n// hash and noise function by Inigo Quilez\n/////////////////////////////////////////////\n\nfloat hash( float n ) { \n\treturn fract(sin(n)*75728.5453123); \n}\n\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0;\n    return mix(mix( hash(n + 0.0), hash(n + 1.0), f.x), mix(hash(n + 57.0), hash(n + 58.0), f.x), f.y);\n}\n\n\n", "buffer_a_code": "// copacabana pattern + noise distortion + rot\n// https://www.shadertoy.com/view/MsXBzB\n\nvoid mainImage( out vec4 C, vec2 U )\n{  \n    U = (U -.5 * R)/R.x;\n    U *= M(T * .1);    \n    U += .4 * length(U-.5) * noise(U * 4.);\n    U *= 70.;   \n    U.y -= cos(U.x) + iDate.w ; \n    C = vec4(smoothstep(0.5,\n                        1.,\n                        mix(cos(U.x) * sin(U.y),\n                        0.3,\n                        cos(U.y) * .5) * 8.));\n        \n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstyW7.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[561, 593, 665, 665, 708], [712, 776, 833, 833, 969], [971, 971, 1003, 1003, 1809], [1811, 1811, 1860, 1880, 5363]], "test": "untested"}
{"id": "fsdcDM", "name": "TL // DANCE PARTICLES ", "author": "fpiaggio", "description": "TL // DANCE PARTICLES ", "tags": ["tldanceparticles"], "likes": 5, "viewed": 422, "published": 3, "date": "1653541653", "time_retrieved": "2024-07-30T16:46:51.433791", "image_code": "#define TWO_PI 3.283185\n#define NUMBALLS 60.0\nfloat hash( vec2 p )\n{\n    return fract( sin( dot(p, vec2( 15.79, 81.93  ) ) * 45678.9123 ) );\n}\n\nfloat d = -TWO_PI;\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    //uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/25.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    vec3 c = vec3(0);\n    float a1 = floor(mod(iTime*0.08, 10.)) + 1.;\n    float a2 = floor(mod(iTime*0.08, 10.)) + 2.;\n    // As sera si quiero uno random cada vez que cambia\n    // float a2 = rand(vec2(floor(mod(iTime / 5., 10.)))) * 10.;\n    \n    \n\tfor(float i = 1.0; i < NUMBALLS; i++) {\n\t\tfloat t = TWO_PI * i/NUMBALLS + sin(iTime*0.2)*5.;\n\t\tfloat x = cos(a1 * t + d);\n\t\tfloat y = sin(a2 * t + d);\n\t\tvec2 q = .4 * vec2(x, y);\n\t\tc += 0.004/distance(uv, q) * vec3(0.5 * abs(x), 0, abs(y));\n\t}\n    texto(c, vec2(-0.42,0.42));\n    fragColor = vec4(vec3(c), 1.0)*(getSound()*1.+0.5);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n    uv *= 2.5;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ F P I A G G I O _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdcDM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 68, 68, 142], [163, 163, 204, 204, 359], [360, 360, 379, 379, 552], [553, 553, 610, 610, 1262]], "test": "untested"}
{"id": "NscyDN", "name": "Atom Supernova", "author": "fpiaggio", "description": "Atom Supernova", "tags": ["noise", "fbm", "lights"], "likes": 10, "viewed": 493, "published": 3, "date": "1653536697", "time_retrieved": "2024-07-30T16:46:52.196751", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime;\n    float rotTime = sin(time);\n    \n    vec3 color1 = vec3(0.8, 0.5, 0.3);\n    vec3 color2 = vec3(rotTime, 0.2, 0.3);\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n\n    vec3 destColor = vec3(2.0 * rotTime, .0, 0.5);\n    float f = 10.15;\n    float maxIt = 18.0;\n    vec3 shape = vec3(0.);\n    for(float i = 0.0; i < maxIt; i++){\n        float s = sin((time / 111.0) + i * cos(iTime*0.02+i)*0.05+0.05);\n        float c = cos((time / 411.0) + i * (sin(time*0.02+i)*0.05+0.05));\n        c += sin(iTime);\n        f = (.01) / abs(length(uv / vec2(c, s)) - 0.4);\n        f += exp(-400.*distance(uv, vec2(c,s)*0.5))*2.;\n        // Mas Particulas\n        f += exp(-200.*distance(uv, vec2(c,s)*-0.5))*2.;\n        // Circulito\n        f += (.008) / abs(length(uv/2. / vec2(c/4. + sin(time*.6), s/4.)))*0.4;\n        float idx = float(i)/ float(maxIt);\n        idx = fract(idx*2.);\n        vec3 colorX = mix(color1, color2,idx);\n        shape += f * colorX;\n        \n        // todo: sacar el sin\n        uv *= r2d(sin(iTime*0.2) + cos(i*50.*f+iTime)*f);\n    }\n    \n    // vec3 shape = vec3(destColor * f);\n    // Activar modo falopa fuerte\n    // shape = sin(shape*10.+time);\n    fragColor = vec4(shape,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 104], [105, 105, 162, 162, 1407]], "test": "untested"}
{"id": "7sccW7", "name": "TL // Light saber fight", "author": "fpiaggio", "description": "TL // Light saber fight", "tags": ["noise", "fbm", "lights"], "likes": 6, "viewed": 604, "published": 3, "date": "1653532272", "time_retrieved": "2024-07-30T16:46:53.163168", "image_code": "#define HorizontalAmplitude\t\t10.010\n#define VerticleAmplitude\t\t0.010\n#define HorizontalSpeed\t\t\t0.10\n#define VerticleSpeed\t\t\t10.50\n#define ParticleMinSize\t\t\t1.76\n#define ParticleMaxSize\t\t\t10.61\n#define ParticleBreathingSpeed\t\t0.30\n#define ParticleColorChangeSpeed\t0.70\n#define ParticleCount\t\t\t2.0\n#define ParticleColor1\t\t\tvec3(.0, 2.0, 2.0)\n#define ParticleColor2\t\t\tvec3(5.0, 1.0, 1.0)\n#define iTime iTime+getSound()*.2\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n    }\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nfloat hash( float x )\n{\n    return fract( sin( x ) * 43758.5453 );\n}\n\nfloat noise( vec2 uv )\n{\n    vec3 x = vec3( uv.xy, 90.0 );\n    \n    vec3 p = floor( x );\n    vec3 f = fract( x );\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n    float offset = 57.0;\n    \n    float n = dot( p, vec3(1.0, offset, offset*2.0) );\n    \n    return mix(\tmix(\tmix( hash( n + 0.0 ), \t\thash( n + 1.0 ), f.x ),\n        \t\t\t\tmix( hash( n + offset), \thash( n + offset+1.0), f.x ), f.y ),\n\t\t\t\tmix(\tmix( hash( n + offset*2.0), hash( n + offset*2.0+1.0), f.x),\n                    \tmix( hash( n + offset*3.0), hash( n + offset*3.0+1.0), f.x), f.y), f.z);\n}\n\nfloat snoise( vec2 uv )\n{\n    return noise( uv ) * 2.0 - 1.0;\n}\n\n\nfloat perlinNoise( vec2 uv )\n{   \n    float n = \t\tnoise( uv * 1.0 ) \t* 128.0 +\n        \t\tnoise( uv * 2.0 ) \t* 64.0 +\n        \t\tnoise( uv * 4.0 ) \t* 32.0 +\n        \t\tnoise( uv * 8.0 ) \t* 16.0 +\n        \t\tnoise( uv * 16.0 ) \t* 8.0 +\n        \t\tnoise( uv * 32.0 ) \t* 4.0 +\n        \t\tnoise( uv * 64.0 ) \t* 2.0 +\n        \t\tnoise( uv * 128.0 ) * 1.0;\n    \n    float noiseVal = n / ( 1.0 + 2.0 + 4.0 + 8.0 + 16.0 + 32.0 + 64.0 + 128.0 );\n    noiseVal = abs(noiseVal * 2.0 - 1.0);\n\t\n    return \tnoiseVal;\n}\n\nfloat fBm( vec2 uv, float lacunarity, float gain )\n{\n    float sum = 0.0;\n    float amp = 7.0;\n    \n    for( int i = 0; i < 10; ++i )\n    {\n        sum += ( perlinNoise( uv ) ) * amp;\n        amp *= gain;\n        uv *= lacunarity;\n    }\n    \n    return sum;\n}\n\nvec3 particles( vec2 pos )\n{\n\t\n\tvec3 c = vec3( 0, 0, 0 );\n\t\n\tfloat noiseFactor = fBm( pos, 0.01, 0.1);\n\t\n\tfor( float i = 1.0; i < ParticleCount+1.0; ++i )\n\t{\n\t\tfloat cs = cos( iTime * HorizontalSpeed * (i/ParticleCount) + noiseFactor ) * HorizontalAmplitude;\n\t\tfloat ss = sin( iTime * VerticleSpeed   * (i/ParticleCount) + noiseFactor ) * VerticleAmplitude;\n\t\tvec2 origin = vec2( cs , ss );\n\t\t\n\t\tfloat t = sin( iTime * ParticleBreathingSpeed * i ) * 0.5 + 0.5;\n\t\tfloat particleSize = mix( ParticleMinSize, ParticleMaxSize, t );\n\t\tfloat d = clamp( sin( length( pos - origin )  + particleSize ), 0.0, particleSize);\n\t\t\n\t\tfloat t2 = sin( iTime * ParticleColorChangeSpeed * i ) * 0.5 + 0.5;\n\t\tvec3 color = mix( ParticleColor1, ParticleColor2, t2 );\n\t\tc += color * pow( d, 5.0 );\n\t}\n\t\n\treturn c;\n}\n\nfloat line( vec2 a, vec2 b, vec2 p )\n{\n\tvec2 aTob = b - a;\n\tvec2 aTop = p - a;\n\t\n\tfloat t = dot( aTop, aTob ) / dot( aTob, aTob) * fBm(a, 0., 0.);\n\t\n\tt = clamp( t, 0.0, 1.0);\n\t\n\tfloat d = length( p - (a + aTob * t)  );\n\td = 1.0 / d;\n\t\n\treturn clamp( d, 0.0, 1.0 );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    float scale = 200.0;\n    float v = 70.0 + sin(iTime) * 30.;\n    uv *= r2d(iTime*0.25);\n    float freqA = mix( 0.4, 1.2, sin(iTime + 30.0) * 0.5 + 0.5 );\n\tfloat freqB = mix( 0.4, 1.2, sin(iTime + 20.0) * 0.5 + 0.5 );\n\tfloat freqC = mix( 0.4, 1.2, sin(iTime + 10.0) * 0.5 + 0.5 );\n    vec3 finalColor = vec3( 0.0 );\n    finalColor = (particles( sin( abs(uv* (sin(iTime*0.2)+0.6)*5.) ) ) * length(uv)) * 0.20;\n    uv *= r2d(sin(-iTime*2.25));\n    float t = line( vec2(-v, -v), vec2(0.0, v), uv * scale );\n    uv *= r2d(cos(-iTime*1.25));\n    finalColor += vec3( 8.0 * t, 2.0 * t, 4.0 * t) * freqA;\n\tt = line( vec2(0.0, v), vec2(v, -v), uv * scale );\n    uv *= r2d(-iTime*.45);\n\tfinalColor += vec3( 2.0 * t, 2.0 * t, 4.0 * t) * freqB;\n\tt = line( vec2(-v, -v), vec2(v, -v), uv * scale );\n    uv *= r2d(sin(iTime*100.15));\n    finalColor += vec3( 2.0 * t, 6.0 * t, 4.0 * t) * freqB;\n\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sccW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[420, 420, 439, 439, 653], [654, 654, 673, 673, 758], [759, 759, 782, 782, 827], [829, 829, 853, 853, 1378], [1380, 1380, 1405, 1405, 1443], [1446, 1446, 1476, 1476, 1943], [1945, 1945, 1997, 1997, 2204], [2206, 2206, 2234, 2234, 2998], [3000, 3000, 3038, 3038, 3266], [3267, 3267, 3324, 3324, 4308]], "test": "untested"}
{"id": "sl2BWV", "name": "moveing point", "author": "lanx06", "description": "point,move", "tags": ["move", "poinr"], "likes": 3, "viewed": 166, "published": 3, "date": "1653531482", "time_retrieved": "2024-07-30T16:46:54.363957", "image_code": "\n\n\nfloat circle(in vec2 _st, in float _radius){\n    \n    vec2 l = _st-.5;\n    float pix = 10./iResolution.y;\n    return smoothstep(_radius+pix,\n                      _radius-pix,\n                      length(l)*1.5);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 st = fragCoord/iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float u_time=iTime;\n    vec2 nst =st* 10.0;      // \n    float movex=step(1.,mod(u_time,2.))*mod(u_time,1.);\n    float movey=step(1.,mod(u_time+1.,2.))*mod(u_time+1.,1.);\n    vec2 xbar=step(vec2(.1),mod(st,0.2));\n    nst.y+=movex*xbar.x;\n    nst.x+=movey*xbar.y;\n\n    nst = fract(nst); // Wrap around 1.0\n    \n    \n    float tem=distance(st,vec2(sin(st.x)));\n    //color = vec3(nst.x,nst.y,0);\n    color = vec3(circle(nst,0.5));\n    \n   \n\n    fragColor = vec4(color,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2BWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 47, 47, 218], [219, 219, 276, 276, 827]], "test": "untested"}
{"id": "7s3yW7", "name": "CRT Shader Test", "author": "SarahIsWeird", "description": "Emulates the appearance of an old-school CRT TV/monitor.", "tags": ["crt"], "likes": 1, "viewed": 378, "published": 3, "date": "1653526415", "time_retrieved": "2024-07-30T16:46:55.402181", "image_code": "// How much to brighten the image to compensate for the brightness loss due to removing 3/4ths of the image brightness.\n#define BRIGHTNESS_CORRECTION (1.333333)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 colorIn = texture(iChannel0, uv).xyz;\n    \n    int rgbIndex = int(fragCoord.x) % 3;\n    vec3 mask = vec3(rgbIndex == 0, rgbIndex == 1, rgbIndex == 2);\n    \n    vec3 colorOut = colorIn * mask * BRIGHTNESS_CORRECTION;\n\n    fragColor = vec4(colorOut, 1.0);\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s3yW7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 219, 219, 524]], "test": "untested"}
{"id": "fsccDN", "name": "TL // ATOMS NOISE CIRCLE", "author": "fpiaggio", "description": "TL // ATOMS NOISE CIRCLE", "tags": ["tlatomsnoisecircle"], "likes": 7, "viewed": 365, "published": 3, "date": "1653511634", "time_retrieved": "2024-07-30T16:46:56.462347", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\n\nfloat hash( vec2 p )\n{\n    return fract( sin( dot(p, vec2( 15.79, 81.93  ) ) * 45678.9123 ) );\n}\n\nfloat valueNoise( vec2 p )\n{\n\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    f = f*f*(3.0 - 2.0*f);\n    \n\n    float bottomOfGrid =    mix( hash( i + vec2( 0.0, 0.0 ) ), hash( i + vec2( 1.0, 0.0 ) ), f.x );\n\n    float topOfGrid =       mix( hash( i + vec2( 0.0, 1.0 ) ), hash( i + vec2( 1.0, 1.0 ) ), f.x );\n\n\n    float t = mix( bottomOfGrid, topOfGrid, f.y );\n    \n    return t;\n}\n\nfloat fbm( vec2 uv )\n{\n    float sum = 0.00;\n    float amp = 0.7;\n    \n    for( int i = 0; i < 4; ++i )\n    {\n        sum += valueNoise( uv ) * amp;\n        uv += uv * 1.2;\n        amp *= 0.4;\n    }\n    \n    return sum;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float rotTime = sin(iTime);\n    \n    vec3 color1 = vec3(0.8, 0.2, 0.);\n    vec3 color2 = vec3(.0, 0.2, 0.8);\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n\n    vec3 destColor = vec3(2.0 * rotTime, .0, 0.5);\n    float f = 10.15;\n    float maxIt = 18.0;\n    vec3 shape = vec3(0.);\n    for(float i = 0.0; i < maxIt; i++){\n        float s = sin((iTime / 111.0) + i * cos(iTime*0.02+i)*0.05+0.05);\n        float c = cos((iTime / 411.0) + i * (sin(iTime*0.02+i)*0.05+0.05));\n        c += sin(iTime);\n        f = (.005) / abs(length(uv / vec2(c, s)) - 0.4+fbm( uv*2.  ));\n        f += exp(-400.*distance(uv, vec2(c,s)*0.5))*2.;\n        // Mas Particulas\n        f += exp(-200.*distance(uv, vec2(c,s+fbm(uv))*-0.5))*2.;\n        // Circulito\n        f += (.008+fbm( uv*0.01)) / abs(length(uv/2. / vec2(c/4. + sin(iTime*4.), s/4.)));\n        f += fbm( uv * 20.5 )*0.05;\n        float idx = float(i)/ float(maxIt);\n        idx = fract(idx*2.);\n        vec3 colorX = mix(color1, color2,idx);\n        shape += f * colorX;\n        \n        //uv += fbm( uv * 20.5 )*0.02;\n        uv *= r2d(iTime*0.1 + cos(i*50.));\n        \n    }\n    \n    // vec3 shape = vec3(destColor * f);\n    // Activar modo falopa fuerte\n    // shape = sin(shape*10.+time);\n    fragColor = vec4(shape,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsccDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 104], [107, 107, 129, 129, 203], [205, 205, 233, 233, 597], [599, 599, 621, 621, 820], [821, 821, 878, 878, 2170]], "test": "untested"}
{"id": "fs3yDM", "name": "Squircle - gradient 2D", "author": "iq", "description": "Signed distance and gradient to a Squrcle. Faster than central differences or automatic differentiation/dual numbers most probably. NOTE - this is a brute-force and resolution dependent SDF. This is NOT a great way to blend between a circle and a square.", "tags": ["2d", "distancefield", "sdf", "gradient", "distance", "segment"], "likes": 22, "viewed": 886, "published": 3, "date": "1653502592", "time_retrieved": "2024-07-30T16:46:57.458683", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Correct SDF and gradient to a Squircle. NOTE - this is a brite force\n// way to do this, it has tesselation artifacts and is slow. But it is exact\n// (in the limit). Not also this is NOT a great way go blend between a circle\n// and a square btw; for that you can use https://www.shadertoy.com/view/7sdXz2\n\n\n// .x = f(p)\n// .y = f(p)/x\n// .z = f(p)/y\n// .yz = f(p) with f(p) = 1\nvec3 sdSquircle(vec2 p, float n)\n{\n    // symmetries\n    vec2 k = sign(p); p = abs(p);\n    bool m = p.y>p.x; if( m ) p=p.yx;\n   \n    const int num = 16; // tesselate into 8x16=128 segments, more denselly at the corners\n    float s = 1.0;\n    float d = 1e20;\n    vec2 oq = vec2(1.0,0.0);\n    vec2  g = vec2(0.0,0.0);\n    for( int i=1; i<=num; i++ )\n    {\n        float h = (6.283185/8.0)*float(i)/float(num);\n        vec2  q = pow(vec2(cos(h),sin(h)),vec2(2.0/n));\n        vec2  pa = p-oq;\n        vec2  ba = q-oq;\n        vec2  z = pa - ba*clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n        float d2 = dot(z,z);\n        if( d2<d )\n        {\n            d = d2;\n            s = pa.x*ba.y - pa.y*ba.x;\n            g = z;\n        }\n        oq = q;\n    }\n    \n    // undo symmetries\n    if( m ) g=g.yx; g*=k; \n    \n    d = sign(s)*sqrt(d);\n    return vec3( d, g/d );\n}\n\nfloat incorrect_sdSquircle(vec2 p, float n)\n{\n    return pow(pow(abs(p.x),n) + pow(abs(p.y),n),1.0/n) - 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n     // animation\n    float n = 3.0 + 2.5*sin(6.283185*iTime/3.0);\n\n    // distance\n    vec3 dg =  sdSquircle(p, n);\n    float d = dg.x;\n    vec2 g = dg.yz;\n    \n    // central differenes based gradient, for comparison\n    //g = vec2( dFdx(d), dFdy(d) )/(2.0*1.4/iResolution.y);\n\n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.4,0.7,0.85);\n    col *= 1.0 + vec3(0.5*g,0.0);\n    col *= 1.0 - 0.5*exp(-8.0*abs(d));\n    col *= 0.9 + 0.1*cos(90.0*d);\n    col = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdSquircle(m,n).x;\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.010, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.010, length(p-m)-0.015));\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3yDM.jpg", "access": "api", "license": "mit", "functions": [[1454, 1549, 1583, 1601, 2412], [2414, 2414, 2459, 2459, 2524], [2526, 2526, 2583, 2619, 3613]], "test": "ok"}
{"id": "fddyDN", "name": "illusion: length perception 2", "author": "FabriceNeyret2", "description": "click to check lengths\nreference: https://www.youtube.com/watch?v=Wt7rR0MCYsg&t=142s\n", "tags": ["illusion", "perception", "short", "reproduction"], "likes": 16, "viewed": 351, "published": 3, "date": "1653488579", "time_retrieved": "2024-07-30T16:46:58.284475", "image_code": "// variant of https://shadertoy.com/view/ssccDN\n\n#define R    iResolution.xy\n#define S(v) smoothstep(6./R.y, 0., v)               // AA draw\n\nfloat L(vec2 p, vec2 a,vec2 b) {                     // line drawing\n    p -= a, b -= a;\n    return S( length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ) );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 2.* ( U+U - R ) / R.y;\n    float l = length(U), a = atan(U.y,U.x);\n    U = l * sin( abs(fract(a*10./6.28+.5)-.5)/10.*6.28 +vec2(0,1.57) ); // symmetries\n    float d = .75,\n          x = U.x, v = cos(x+2.*iTime)/5.,\n          y = U.y;\n          \n    O = vec4(1);\n    O -= L(U, vec2(0,0),vec2(0,1.5) )                // color bars\n         * ( y > d ? vec4(.4,1,1,0) : vec4(1,1,.4,0) )\n      +  L(U, vec2(0, 1.5),vec2(.07,1.5-v) )         // top half-arrow\n      +  L(U, vec2(0, d),vec2(.07, v+d) );           // mid\n      \n    if (iMouse.z>0.)                                 // if click\n        O = mix(O,vec4(0,1,0,0), S(min(abs(l-1.5), abs(l-d)) )); // green lines\n\n    O = sqrt(O);                                     // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddyDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 174, 210, 303], [305, 305, 343, 343, 1085]], "test": "untested"}
{"id": "sdtyW4", "name": "Color Idea A 3", "author": "SnoopethDuckDuck", "description": "testing things", "tags": ["e"], "likes": 2, "viewed": 183, "published": 3, "date": "1653487230", "time_retrieved": "2024-07-30T16:46:59.151157", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.y;\n   \n    vec3 col = texture(iChannel0, uv).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos(6.28318*(0.5*t+d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float th = 0.99;\n    //if (col.x >=th && col.y >=th && col.z >= th)\n    //    col = vec3(0);\n   \n    vec2 f = uv.y * 0.2 + 0.05 * vec2(cos(0.1 * iTime), sin(0.1 *iTime));\n    vec3 c = texture(iChannel1, f).rgb;\n    //c = mix(c, texture(iChannel1, f).rgb, 0.5);\n\n    float d = length(uv - c.xy+0.);\n    float k = c.z * 0.25;\n    float s = exp(-20. * d);//smoothstep(-k, k, - d + 0.01 * c.z);\n    \n    vec3 col2 = s * pal(iTime, 1. * vec3(0,1,2)/3.);\n    \n    col *= 0.995;\n    col += 1. * (1.-col) * col2;// = mix(col, col2, 0.0);\n   // vec3 col = vec3(s);\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdtyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 207]], "test": "untested"}
{"id": "fsdcz7", "name": "Random Grid Subdivision", "author": "Shane", "description": "Performing CSG operations on variable frequency, randomly rotated, offset grids to produce a fractal-like polygonal pattern mildly reminiscent of randomly subdivided Voronoi cells.", "tags": ["2d", "fractal", "fbm", "csg", "hexagon", "square", "cell", "subdivision"], "likes": 60, "viewed": 1120, "published": 3, "date": "1653485561", "time_retrieved": "2024-07-30T16:47:00.115579", "image_code": "/*\n\n    Random Grid Subdivision\n    -----------------------\n    \n    Performing CSG operations on variable frequency, randomly rotated, \n    offset grids to produce a fractal-like polygonal pattern mildly \n    reminiscent of randomly subdivided Voronoi cells... As you can see, \n    I'm really struggling to describe this. :D It's kind of a mixture of \n    fBm, CSG and subdivision. Either way, verbose description aside, these \n    things are easy to code.\n    \n    I came across Ruojake's cool \"Grids all the way down\" example the other \n    day. There are a few examples relating to it on Shadertoy, and each \n    involve randomly subdividing or partitioning cells in some way to form \n    a fractal-like pattern. I've used similar methods a few times on \n    Shadertoy.\n    \n    Anyway, this is just one of infinite variations possible. The process \n    is pretty simple: Render a grid, then in each cell, render a randomly \n    offset, rotated grid at a higher frequency (Make the cells smaller). \n    After that, repeat the step as many times as you want, and that's it.\n    \n    Which variation on the aforementioned you choose is up to you. Ruojake \n    chose the commonly occurring square grid, so just to be different, I've \n    adapted some old code to produce a hexagonally based one. The result is \n    interesting, but I prefer the more common square grid that most use. By \n    the way, I've provided that option below for anyone who'd like to see \n    that.\n    \n    Aesthetically, I kept things simple -- Just some basic coloring and \n    highlighting with a line overlay. I was tempted to make an extruded \n    version -- I know of at least one method that would work, but I didn't \n    have time to waste on this diversion in the first place, so I might \n    leave it at that... Actually, a globally illuminated wall refected \n    version would look nice... :)\n    \n    \n    \n    Other Examples:\n    \n    // Clean code and a nice result.\n    Grids all the way down - ruojake\n    https://www.shadertoy.com/view/fdccR8\n    \n    // A simpler line partitioned version.\n    Sloped Line Partitioning - Shane\n    https://www.shadertoy.com/view/fstcD7\n    \n*/\n\n// Using a hexagon grid based pattern, instead of a square one.\n#define HEXAGON\n\n// Random cell subdivsion: Commenting this out would mean compulsory cell \n// subdivision. Whether you leave this in or not depends on the look you're after.\n#define RANDOM_SUBDIVISION\n\n// Thick outer cell borders for a more cartoonish look.\n//#define THICK_BORDER\n        \n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\nfloat sBoxS(in vec2 p, in vec2 b, in float rf){\n  \n  vec2 d = abs(p) - b + rf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - rf;\n    \n}\n\n// Flat top or pointed top hexagon.\n#define FLAT_TOP_HEXAGON\n//\n// Helper vector. If you're doing anything that involves regular triangles or hexagons, the\n// 30-60-90 triangle will be involved in some way, which has sides of 1, sqrt(3) and 2.\n#ifdef FLAT_TOP_HEXAGON\nvec2 s = vec2(1.7320508, 1);\n#else\nvec2 s = vec2(1, 1.7320508);\n#endif\n\n\n// The 2D hexagonal isosuface function: If you were to render a horizontal line and one that\n// slopes at 60 degrees, mirror, then combine them, you'd arrive at the following. As an aside,\n// the function is a bound -- as opposed to a Euclidean distance representation, but either\n// way, the result is hexagonal boundary lines.\nfloat hex(in vec2 p){\n    \n    p = abs(p);\n    \n    #ifdef FLAT_TOP_HEXAGON\n    // Below is equivalent to:\n    //return max(p.x*.866025 + p.y*.5, p.y); \n\n    return max(dot(p, vec2(1.7320508, 1)*.5), p.y); // Hexagon.\n    #else\n    // Below is equivalent to:\n    //return max(p.x*.5 + p.y*.866025, p.x); \n\n    return max(dot(p, vec2(1, 1.7320508)*.5), p.x); // Hexagon.\n    #endif\n    \n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec4 getHex(vec2 p){\n    \n    // The hexagon centers: Two sets of repeat hexagons are required to fill in the space, and\n    // the two sets are stored in a \"vec4\" in order to group some calculations together. The hexagon\n    // center we'll eventually use will depend upon which is closest to the current point. Since \n    // the central hexagon point is unique, it doubles as the unique hexagon ID.\n    #ifdef FLAT_TOP_HEXAGON\n    vec4 hC = floor(vec4(p/s, p/s - vec2(1.7320508/3., .5))) + .5;\n    #else\n    vec4 hC = floor(vec4(p/s, p/s - vec2(.5, 1.7320508/3.))) + .5;\n    #endif    \n   \n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p - hC.xy*s, p - (hC.zw + .5)*s);\n    //vec4 h = p.xyxy - vec4(hC.xy + .5, hC.zw)*s.xyxy;\n    \n    \n    // Nearest hexagon center (with respect to p) to the current point. In other words, when\n    // \"h.xy\" is zero, we're at the center. We're also returning the corresponding hexagon ID --\n    // in the form of the hexagonal central point. By the way, the unique ID (the .zw bit), \n    // needs to be multiplied by \"s\" to give the correct quantized position back. \n    // For example: float ns = noise2D(hID*s);\n    //\n    // On a side note, I sometimes compare hex distances, but I noticed that Iomateron compared\n    // the squared Euclidian version, which seems neater, so I've adopted that. \n    return dot(h.xy, h.xy)<dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n\n}\n\n// A second offset distance field value. Used for hilighting.\nfloat dHi;\n\nvec3 distField(vec2 p){\n\n    // Set the distance (and highlight distance) to a minimum.\n    float d = -1e5;\n    dHi = -1e5;\n    \n    // Overal unique cell ID.\n    vec2 gIP = vec2(0);\n    \n    // Inititalize the scale to one.\n    float sc = 1.;\n    \n    // Directional light.\n    vec2 ld = normalize(vec2(1, 1.5));\n    \n    // Rotate and translate the coordinates and light.\n    p *= rot2(iTime/8.);\n    p -= iTime/16.;\n    ld *= rot2(iTime/8.);\n     \n   \n    // Six subdivided grid partitions.\n    for(int i = 0; i<6; i++){\n    \n        \n        // Get the hexagon (or square) grid information\n        // (local coordinates and cell ID) for this iteration.\n        #ifdef HEXAGON\n        vec4 p4 = getHex(p);\n        p = p4.xy;\n        vec2 ip = p4.zw;\n        d = max(d, hex(p) - .5/sc); // Hexagon distance.\n        dHi = max(dHi, (hex(p + ld*.001) - .5/sc)); // Highlight distance.\n        #else\n        vec2 ip = floor(p*sc) + .5;\n        p -= ip/sc;\n        d = max(d, sBoxS(p, vec2(.5/sc), 0.)); // Square distance.\n        dHi = max(dHi, sBoxS(p + ld*.001, vec2(.5/sc), 0.)); // Highlight distance.\n        #endif\n  \n        \n  \n        // Rescale the grid for the next iteration.\n        #ifdef HEXAGON\n        sc *= 1.4;\n        s /= 1.4;\n        #else\n        sc *= 1.5;\n        #endif\n        \n        // Update the overall cell ID.\n        gIP += ip/sc;    \n        \n        // Optional random rotation -- It looks more interesting, but\n        // it's not mandatory.\n        p *= rot2((hash21(gIP + .05) - .5)*6.2831);\n        ld *= rot2((hash21(gIP + .05) - .5)*6.2831);\n       \n        // Random translation.\n        p -= vec2(hash21(gIP + .13), hash21(gIP + .04))/sc*.75;\n        \n        #ifdef RANDOM_SUBDIVISION\n        // Random cell subdivsion. Commenting this out would mean compulsory\n        // cell subdivision. Whether you leave this in or not depends on what\n        // look you're after.\n        if(i>2 && hash21(gIP + .22)<.2) break;\n        #endif\n        \n        /*\n        // Internal moving rotation -- Interesting, but a bit much.\n        float dir = hash21(gIP + .07)<.5? -1. : 1.;\n        p *= rot2(dir*iTime/sc/8.);\n        ld *= rot2(dir*iTime/sc/8.);\n        */ \n        \n        // Extra temporal translation. Also not mandatory.\n        p -= iTime/32.;\n         \n        \n        \n    \n    }\n   \n    // Return the cell distance and unique ID.\n    return vec3(d, gIP);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Aspect corret coordinates.\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\n    // Scale and smoothing factor.\n    const float sc = 1.;\n    float sf = sc/iResolution.y;\n    \n    \n    // Scaling and translation.\n    vec2 p = sc*uv;\n    \n    // Scene object -- Returns distance and ID.\n    vec3 d = distField(p); \n    \n    // Rendering onto the canvas.\n    \n    // ID based cell coloring.\n    float rnd = hash21(d.yz + .1);\n    float taper = rnd<.35? .7 : 1.;\n    vec3 oCol = .5 + .45*cos(6.2831*hash21(d.yz + .2)/5. + vec3(0, 1, 2)/taper);\n    if(rnd>=.35) oCol = mix(oCol.zyx, vec3(1)*dot(oCol, vec3(.299, .587, .114)), .75)/4.;\n    //else oCol = oCol.zyx;\n    \n    // Directional derivative bump map calculation for some highlighting.\n    float b = max(dHi - d.x, 0.)/.001;\n  \n    oCol = oCol*(.25 + b*.75)*1.35;\n   \n     \n    // Diagonal line pattern.\n    //\n    // Resolution independent line number -- Not PPI independent though.\n    float lns = 120.*iResolution.y/450.;\n    vec2 rp = rot2(-3.14159/3.)*p;\n    float pat = abs(fract((rp.x)*lns) - .5)*2. - .05;\n    pat = smoothstep(0., sf*lns*2., pat); \n    \n    float ew = .005*450./iResolution.y; // Resolution independent edge width.\n    \n    // Scene color.\n    vec3 col = oCol*(pat*1. + .5);\n    \n    // Cell border.\n    #ifdef THICK_BORDER\n    const float bw = .0025; // Border width.\n    #else\n    const float bw = .001; // Border width.\n    #endif\n    // Border distance.\n    float dBord = abs(d.x + bw) - bw; \n    \n    // Application... There are definitely better ways, but I was pushed for time.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*8., dBord - ew))*.25); // Inner gradient.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, dBord - ew - .005))*.8); // Inner edge.\n    col = mix(col, mix(oCol, vec3(1), .125), 1. - smoothstep(0., sf, dBord - ew)); // Colored edge.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, dBord)); // Outer edge.\n    \n\n    // Vertical color gradient of sorts.\n    float grad = clamp(uv.y + .65, 0., 1.);\n    col = mix(col.yxz, col.zyx, grad*grad);\n    \n    // Red to blue colors.\n    //col = col.yxz;\n    \n    // Rough gamma correction and screen presentation.\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2528, 2561, 2583, 2583, 2641], [2644, 2672, 2693, 2693, 2756], [2759, 2759, 2806, 2806, 2903], [3246, 3575, 3596, 3596, 3962], [3964, 4656, 4676, 5056, 6119], [6195, 6195, 6218, 6282, 8606], [8608, 8608, 8664, 8699, 10908]], "test": "untested"}
{"id": "fsdyW4", "name": "Entropy Escape Decay", "author": "xenn", "description": "kinda interesting", "tags": ["mouse", "background", "shadertoy", "feedback", "integration", "library", "web", "webdevelopment", "webdev", "javascript"], "likes": 11, "viewed": 366, "published": 3, "date": "1653467641", "time_retrieved": "2024-07-30T16:47:01.386182", "image_code": "\n// Fork of a fork of a fork of a fork of a fork of a fork of a fork of a fork of a total mind fuhk\n\n//Chromatic aberration, film grain and tone mapping\n\nfloat NoiseSeed;\n\nfloat randomFloat(){\n  NoiseSeed = sin(NoiseSeed) * 84522.13219145687;\n  return fract(NoiseSeed);\n}\n\nvec3 ACESFilm(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    if(fragCoord.y / iResolution.y < Margins || fragCoord.y / iResolution.y > 1.0-Margins){\n        fragColor = vec4(ACESFilm(vec3(0)), 1.0);\n        return;\n    }\n    \n    NoiseSeed = float(iFrame)* .003186154 + fragCoord.y * 17.2986546543 + fragCoord.x;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy;\n    \n    vec2 d = (uv-vec2(.5)) * .0075;\n    vec3 color = vec3(texture(iChannel0, uv - 0.0 * d).r,\n                      texture(iChannel0, uv - 1.0 * d).g,\n                      texture(iChannel0, uv - 2.0 * d).b);\n                                  \n    vec3 col = vec3(texture(iChannel1, uv - 0.0 * d).r,\n                      texture(iChannel1, uv - 1.0 * d).g,\n                      texture(iChannel1, uv - 2.0 * d).b);\n                      \n        vec3 col2 = vec3(texture(iChannel2, uv - 0.0 * d).r,\n                      texture(iChannel2, uv - 1.0 * d).g,\n                      texture(iChannel2, uv - 2.0 * d).b);\n                      \n                      vec3 col3 = vec3(texture(iChannel3, uv - 0.0 * d).r,\n                      texture(iChannel3, uv - 1.0 * d).g,\n                      texture(iChannel3, uv - 2.0 * d).b);\n                      col3 = clamp(col3, 0., 1.);\n                      \n     //                 col = min(col,col2);\n                      color = min(col2,color);\n               //       col2 = mix(col,color,0.5);\n               //      col2 = min(color,col2);\n                      \n                       \n      color += mix(col,col2,col3)*.5;\n    float noise = .9 + randomFloat()*.15;\n  \tfragColor = vec4(ACESFilm(((color * 0.5)+ (mix(col,color,col2)))*noise), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = .005;\nconst float iFeedbackFadeRate         = .999;\nconst float iFeedbackColorShiftZoom   = .01;\nconst float iFeedbackColorShiftImpact = 0.005;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .05;\nconst float iBlobEdgeSmoothing        = .001;\nconst float iBlob1Radius              = .45;\nconst float iBlob1PowFactor           = 50.;\nconst float iBlob1ColorPulseSpeed     = .033;\nconst float iBlob2Radius              = .33;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     =- .1234;\nconst float iBlob2ColorPulseShift     = 0.0250;\nconst float iColorShiftOfRadius       = 0.0275;\nconst float iFeedbackMouseShiftFactor = -.0;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n     vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n      prevColor = clamp(prevColor, 0., .5);\n       prevColor2 = clamp(prevColor2, 0., .050);\n     \n  //   prevColor -= prevColor / 64.;\n//     prevColor -= (prevColor2 * .0050);\n //    prevColor2 += prevColor2 * .050;\n    //prevColor += mix(prevColor,prevColor2,0.5);\n    prevColor += -prevColor2/(-1024.);\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define iFeedbackColorShiftZoom 0.2\n//#define iFeedbackColorShiftImpact 0.001\n//#define iBlob1ColorPulseSpeed 0.03456\n//#define iBlob2ColorPulseSpeed 0.02345\n#define Margins .0\n#define iTime iTime /3.0\n\n#define PI 3.14159265359\n\nvec2 getFontSymbolSampleUV(int x, int y, vec2 uv) {\n\treturn uv * vec2(1./16.) + vec2(float(x) / 16., float(y) / 16.);\n}\n\nfloat getHeight(vec2 uv, sampler2D bumpMap, float maxHeight) {\n    return texture(bumpMap, uv).r*maxHeight;\n}\n\nvec3 getSlope(vec2 uv, float height, vec2 axis, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    float h1 = getHeight(uv+texelSize*axis, bumpMap, maxHeight);\n    float h2 = getHeight(uv-texelSize*axis, bumpMap, maxHeight);\n    return vec3(1,((height-h2) + (h1-height)) / 2.,0);\n}\n\nvec3 bump2Normal(vec2 uv, sampler2D bumpMap, float maxHeight, vec2 texelSize) {\n    \n    float height = getHeight(uv, bumpMap, maxHeight);\n        \n    vec3 slopeX = getSlope(uv, height, vec2(1., 0.), bumpMap, maxHeight, texelSize).zyx;\n    vec3 slopeY = getSlope(uv, height, vec2(0., 1.), bumpMap, maxHeight, texelSize).xyz;\n    return cross(slopeX, slopeY).zyx;\n}\n\nvec3 normal2rgb(vec3 normal) {\n    return normalize(normal.rbg * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5));\n}\n\nfloat radius = 20.;\nfloat intensity = 5.;\nfloat fade = .99;\n\nfloat pi = 3.14159265359;\n\nfloat blurRadius = 3.;\n\nfloat sinWave(float v, float m){return (sin(v*m*pi*2.)+1.)/2.;}\n\n//from https://github.com/hughsk/glsl-hsv2rgb\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 xy2hue(vec2 v){\n    float h = (atan(v.y, v.x)/(pi) + 1.)/2.;\n    float b = length(v);\n    return vec4(hsv2rgb(vec3(h, 1., b)), 1.);\n}\n\n\n\n\n\n\n\n/*\n * Conway Ticket\n * \n * Copyright (C) 2021  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n \nivec2 boardSize = ivec2(125),\n    ci = ivec2(1,0);\nvec2 blockSize,\n    xij;\nvec3 c = vec3(1,0,-1);\nfloat stepTimeDelta = .05,\n//    pi = 3.14159,\n    fsaa = 144.,\n    bpm = 90.,\n    spb = 60./90.,\n    scale,\n    nbeats,\n    stepTime;\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins.\n// See https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(p.xyx * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat lfnoise(float y)\n{\n    vec2 t = y*c.xx;\n    vec2 i = floor(t);\n    t = smoothstep(c.yy, c.xx, fract(t));\n    vec2 v1 = vec2(hash12(i), hash12(i+c.xy)),\n    v2 = vec2(hash12(i+c.yx), hash12(i+c.xx));\n    v1 = c.zz+2.*mix(v1, v2, t.y);\n    return mix(v1.x, v1.y, t.x);\n}\n\nfloat m(vec2 x)\n{\n    return max(x.x,x.y);\n}\n\nfloat d210(vec2 x)\n{\n    return min(max(max(max(max(min(max(max(m(abs(vec2(abs(abs(x.x)-.25)-.25, x.y))-vec2(.2)), -m(abs(vec2(x.x+.5, abs(abs(x.y)-.05)-.05))-vec2(.12,.02))), -m(abs(vec2(abs(x.x+.5)-.1, x.y-.05*sign(x.x+.5)))-vec2(.02,.07))), m(abs(vec2(x.x+.5,x.y+.1))-vec2(.08,.04))), -m(abs(vec2(x.x, x.y-.04))-vec2(.02, .08))), -m(abs(vec2(x.x, x.y+.1))-vec2(.02))), -m(abs(vec2(x.x-.5, x.y))-vec2(.08,.12))), -m(abs(vec2(x.x-.5, x.y-.05))-vec2(.12, .07))), m(abs(vec2(x.x-.5, x.y))-vec2(.02, .08)));\n}\n\nfloat dbox3(vec3 x, vec3 b)\n{\n  b = abs(x) - b;\n  return length(max(b,0.))\n         + min(max(b.x,max(b.y,b.z)),0.);\n}\n\nfloat setStateF(ivec2 index, ivec2 where, float oldState, float newState)\n{\n    return all(equal(index, where)) ? newState : oldState;\n}\n\n// Distance to star\nfloat dstar(vec2 x, float N, vec2 R)\n{\n    float d = pi/N,\n        p0 = acos(x.x/length(x)),\n        p = mod(p0, d);\n    vec2 a = mix(R,R.yx,mod(round((p-p0)/d),2.)),\n    \tp1 = a.x*c.xy,\n        ff = a.y*vec2(cos(d),sin(d))-p1;\n    return dot(length(x)*vec2(cos(p),sin(p))-p1,ff.yx*c.zx)/length(ff);\n}\n\nfloat dhexagonpattern(vec2 p) \n{\n    vec2 q = vec2(p.x*1.2, p.y + p.x*.6),\n        qi = floor(q),\n        pf = fract(q);\n    float v = mod(qi.x + qi.y, 3.);\n    \n    return dot(step(pf.xy,pf.yx), 1.-pf.yx + step(1.,v)*(pf.x+pf.y-1.) + step(2.,v)*(pf.yx-2.*pf.xy));\n}\n\n// x: material\n// y: distance\n// z: reflectivity\nvec3 add(vec3 a, vec3 b)\n{\n    if(a.y < b.y) return a;\n    return b;\n}\n\n//vec3 hsv2rgb(vec3 cc)\n//{\n//    vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n//    vec3 p = abs(fract(cc.xxx + K.xyz) * 6. - K.www);\n//    return cc.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), cc.y);\n//}\n\nvec2 rgb2sv(vec3 cc)\n{\n    vec4 K = vec4(0., -1. / 3., 2. / 3., -1.),\n        p = mix(vec4(cc.bg, K.wz), vec4(cc.gb, K.xy), step(cc.b, cc.g)),\n        q = mix(vec4(p.xyw, cc.r), vec4(cc.r, p.yzx), step(p.x, cc.r));\n    return vec2((q.x - min(q.w, q.y)) / (q.x + 1.e-10), q.x);\n}\n\n\n\n#define pi acos(-1.)\n\n\n#define sint(a) (asin(sin(a))*2. - 1.)\n\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n//#define pmod(p,d) mod(p - (d)*0.5, (d)) - 0.5*(d)\n\nfloat r11(float i){ return fract(sin(i*12.126)*12.6);}\n\n#define xor(a,b,c) min(max((a),-(b)), max((b),-(a) - c)) \n\nfloat ss( float c, float power, float bias){\n    c = clamp(c,-0.,1.);\n    //c = smoothstep(0.,1.,c);\n    \n    c = pow(c,1. + bias);\n    \n    float a = pow( abs(c), power);\n    float b = 1.-pow( abs(c - 1.), power);\n    \n    return mix(a,b,c);\n}\nfloat valueNoise(float i, float p){ return mix(r11(floor(i)),r11(floor(i) + 1.), ss(fract(i), p,0.6));}\n\nfloat valueNoiseStepped(float i, float p, float steps){ return mix(  floor(r11(floor(i))*steps)/steps, floor(r11(floor(i) + 1.)*steps)/steps, ss(fract(i), p,0.6));}\n\n\n// See: https://www.shadertoy.com/view/ls2Bz1\n// Spectral Colour Schemes\n// By Alan Zucconi\n// Website: www.alanzucconi.com\n// Twitter: @AlanZucconi\n\n// Example of different spectral colour schemes\n// to convert visible wavelengths of light (400-700 nm) to RGB colours.\n\n// The function \"spectral_zucconi6\" provides the best approximation\n// without including any branching.\n// Its faster version, \"spectral_zucconi\", is advised for mobile applications.\n\n\n// Read \"Improving the Rainbow\" for more information\n// http://www.alanzucconi.com/?p=6703\n\n\n\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float x)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n", "buffer_b_code": "                                                                                                                                                                                                                                                                                        // See Image tab for details, also visit:\n//\n// https://xemantic.github.io/shader-web-background/\n//\n// In the original shader-web-background these values are provided as uniforms\n// feel free to play with them and if you will find something prettier than\n// the equilibrium I established, please send it back to me :)\nconst vec2  iFeedbackZoomCenter       = vec2(0., 0.);\nconst float iFeedbackZoomRate         = -.001;\nconst float iFeedbackFadeRate         = .997;\nconst float iFeedbackColorShiftZoom   = .1;\nconst float iFeedbackColorShiftImpact = 0.00525;\nconst vec2  iDrawCenter               = vec2(0., 0.);\nconst float iDrawIntensity            = .099;\nconst float iBlobEdgeSmoothing        = .02;\nconst float iBlob1Radius              = .66;\nconst float iBlob1PowFactor           = 50.;\nconst float iBlob1ColorPulseSpeed     = -.2;\nconst float iBlob2Radius              = .33;\nconst float iBlob2PowFactor           = 40.;\nconst float iBlob2ColorPulseSpeed     =- .023;\nconst float iBlob2ColorPulseShift     = 0.250;\nconst float iColorShiftOfRadius       = -0.025;\nconst float iFeedbackMouseShiftFactor = -.0;\n\n/*\n  Normally it would be provided by texture parameters, but on Mac/iOS the texture REPEAT\n  seems to work only for power-of-2 texture sizes.\n */\nvec4 repeatedTexture(in sampler2D channel, in vec2 uv) {\n    return texture(channel, mod(uv, 1.));\n}\n\nfloat drawBlob(\n    in vec2 st,\n    in vec2 center,\n    in float radius,\n    in float edgeSmoothing\n) {\n    float dist = length((st - center) / radius);\n    return dist * smoothstep(1., 1. - iBlobEdgeSmoothing, dist);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // in shader-web-background provided as uniforms: start\n    float iMinDimension = min(iResolution.x, iResolution.y);\n    vec2 iScreenRatioHalf =\n        (iResolution.x >= iResolution.y)\n            ? vec2(iResolution.y / iResolution.x * .5, .5)\n            : vec2(.5, iResolution.x / iResolution.y);\n    vec3 iBlob1Color = spectral_zucconi6(\n        mod(iTime * iBlob1ColorPulseSpeed, 1.)\n    );\n    \n    vec3 iBlob2Color = spectral_zucconi6(\n        mod(iTime * iBlob2ColorPulseSpeed + iBlob2ColorPulseShift, 1.)\n    );\n    vec2 iFeedbackShiftVector =\n        (iMouse.x > 0. && iMouse.y > 0.)\n            ? (iMouse.xy * 2. - iResolution.xy) / iMinDimension * iFeedbackMouseShiftFactor\n            : vec2(0);\n    // in shader-web-background provided as uniforms: end\n            \n    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 st = (fragCoord * 2. - iResolution.xy) / iMinDimension;\n\n    vec2  drawDelta = st - iDrawCenter;\n    float drawAngle = atan(drawDelta.x, drawDelta.y);\n    float drawDist = length(drawDelta);\n\nvec3 feedbk = repeatedTexture(iChannel1, uv - st).rgb;\n    vec3 colorShift = repeatedTexture(\n        iChannel0,\n        uv - st * iFeedbackColorShiftZoom * iScreenRatioHalf\n    ).rgb;\n\n    vec2 stShift = vec2(0);\n    stShift += iFeedbackZoomRate * (st - iFeedbackZoomCenter);\n    stShift += (feedbk.br/colorShift.gr - .5) * iFeedbackColorShiftImpact;\n    stShift += iFeedbackShiftVector;\n    stShift *= iScreenRatioHalf;\n\n    vec3 prevColor = repeatedTexture(iChannel2, uv - stShift).rgb;\n     vec3 prevColor2 = repeatedTexture(iChannel3, uv - stShift).rgb;\n//     prevColor -= (prevColor2 * .0050);\n //    prevColor2 += prevColor2 * .050;\n    //prevColor += mix(prevColor,prevColor2,0.5);\n    prevColor += prevColor2/512.;\n    prevColor *= iFeedbackFadeRate;\n\n    vec3 drawColor = vec3(0);\n   \n\n    float radius =\n        1.\n        + (colorShift.r + colorShift.g + colorShift.b) * iColorShiftOfRadius;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob1Radius, iBlobEdgeSmoothing),\n          iBlob1PowFactor\n        ) * iBlob1Color;\n    drawColor +=\n        pow(\n          drawBlob(st, iDrawCenter, radius * iBlob2Radius, iBlobEdgeSmoothing),\n          iBlob2PowFactor\n        ) * iBlob2Color;\n\n    vec3 color = vec3(0);\n    drawColor *= iDrawIntensity;\n    prevColor *= iFeedbackFadeRate;\n    color += prevColor;\n    color += drawColor;\n\n    color = clamp(color, 0., 1.);\n    fragColor = vec4(color, 1.);\n}\n", "buffer_b_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// created by florian berger (flockaroo) - 2016\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// single pass CFD\n// ---------------\n// this is some \"computational flockarooid dynamics\" ;)\n// the self-advection is done purely rotational on all scales. \n// therefore i dont need any divergence-free velocity field. \n// with stochastic sampling i get the proper \"mean values\" of rotations \n// over time for higher order scales.\n//\n// try changing \"RotNum\" for different accuracies of rotation calculation\n// for even RotNum uncomment the line #define SUPPORT_EVEN_ROTNUM\n\n#define RotNum 9\n//#define SUPPORT_EVEN_ROTNUM\n\n#define Res  iChannelResolution[0]\n#define Res1 iChannelResolution[1]\n\n//#define keyTex iChannel3\n//#define KEY_I texture(keyTex,vec2((105.5-32.0)/256.0,(0.5+0.0)/3.0)).x\n\nconst float ang = 2.0*3.1415926535/float(RotNum);\nmat2 mu = mat2(cos(ang),sin(ang),-sin(ang),cos(ang));\nmat2 mh = mat2(cos(ang*0.5),sin(ang*0.5),-sin(ang*0.5),cos(ang*0.5));\n\nvec4 randS(vec2 uv)\n{\n    return texture(iChannel1,uv*Res.xy/Res1.xy)-vec4(0.5);\n}\n\nfloat getRot(vec2 pos, vec2 b)\n{\n    vec2 p = b;\n    float rot=0.0;\n    for(int i=0;i<RotNum;i++)\n    {\n        rot+=dot(texture(iChannel0,fract((pos+p)/Res.xy)).xy-vec2(0.5),p.yx*vec2(1,-1));\n        p = mu*p;\n    }\n    return rot/float(RotNum)/dot(b,b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pos = fragCoord.xy;\n    float rnd = randS(vec2(float(iFrame)/Res.x,0.5/Res1.y)).x;\n    \n    vec2 b = vec2(cos(ang*rnd),sin(ang*rnd));\n    vec2 v=vec2(0);\n    float bbMax=0.7*Res.y; bbMax*=bbMax;\n    for(int l=0;l<20;l++)\n    {\n        if ( dot(b,b) > bbMax ) break;\n        vec2 p = b;\n        for(int i=0;i<RotNum;i++)\n        {\n#ifdef SUPPORT_EVEN_ROTNUM\n            v+=p.yx*getRot(pos+p,-mh*b);\n#else\n            // this is faster but works only for odd RotNum\n            v+=p.yx*getRot(pos+p,b);\n#endif\n            p = mu*p;\n        }\n        b*=2.0;\n    }\n    \n     vec2 uv = fragCoord/iResolution.xy; // Normalized pixel coordinates (from 0 to 1)\n\n//  vec4 col = texture(iChannel0,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 col2 = texture(iChannel3,fract((pos+v*vec2(-1,1)*2.0)/Res.xy));\n//  vec4 blend = mix(col2,col,0.5);\n  \n//  fragColor=blend;\n  \n   vec4 col = texture(iChannel0,fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col2 = texture(iChannel2,fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  vec4 col3 = texture(iChannel3,fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n  col3 = clamp(col3, 0., 1.);\n//  col = max(col,col2);\n//  col2= min(col,col2);\n  vec4 blend = mix(col,col2,col3);\n // blend = (blend*0.5)* ((max(col,blend))*0.5)+ ((min(col,blend))*0.5);\n  blend = clamp(blend, 0., 1.);\n  fragColor=blend,(fract((pos-v*vec2(-1,1)*2.0)/Res.xy));\n    \n    // add a little \"motor\" in the center\n //   vec2 scr=(fragCoord.xy/Res.xy)*2.0-vec2(1.0);\n//    fragColor.xy += (0.001*scr.xy / (dot(scr,scr)/0.1+0.3));\n    \n //   if(iFrame<=4 || KEY_I>0.5) fragColor=texture(iChannel2,fragCoord.xy/Res.xy);\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime;\n    float rotTime = sin(time);\n    \n    vec3 color1 = vec3(0.8, 0.2, 0.);\n    vec3 color2 = vec3(.0, 0.2, 0.8);\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n\n    vec3 destColor = vec3(2.0 * rotTime, .0, 0.5);\n    float f = 10.15;\n    float maxIt = 18.0;\n    vec3 shape = vec3(0.);\n    for(float i = 0.0; i < maxIt; i++){\n        float s = sin((time / 111.0) + i * cos(iTime*0.02+i)*0.05+0.05);\n        float c = cos((time / 411.0) + i * (sin(time*0.02+i)*0.05+0.05));\n        c += sin(iTime);\n        f = (.005) / abs(length(uv / vec2(c, s)) - 0.4);\n        f += exp(-400.*distance(uv, vec2(c,s)*0.5))*2.;\n        // Mas Particulas\n        f += exp(-200.*distance(uv, vec2(c,s)*-0.5))*2.;\n        // Circulito\n        f += (.008) / abs(length(uv/2. / vec2(c/4. + sin(time*4.), s/4.)));\n        float idx = float(i)/ float(maxIt);\n        idx = fract(idx*2.);\n        vec3 colorX = mix(color1, color2,idx);\n        shape += f * colorX;\n        \n        uv *= r2d(iTime*0.1 + cos(i*50.));\n    }\n    \n    // vec3 shape = vec3(destColor * f);\n    // Activar modo falopa fuerte\n    // shape = sin(shape*10.+time);\n    fragColor = vec4(shape,1.0);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdyW4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 192, 192, 271], [273, 273, 296, 296, 436], [438, 438, 495, 495, 2118]], "test": "untested"}
{"id": "ssccDN", "name": "illusion: length perception", "author": "FabriceNeyret2", "description": "click to check horizontality\nreference: https://www.youtube.com/watch?v=Wt7rR0MCYsg&t=146s\n", "tags": ["illusion", "perception", "short", "reproduction"], "likes": 18, "viewed": 373, "published": 3, "date": "1653467544", "time_retrieved": "2024-07-30T16:47:02.446347", "image_code": "#define R    iResolution.xy\n#define S(v) smoothstep(6./R.y, 0., v)               // AA draw\n\nfloat L(vec2 p, vec2 a,vec2 b) {                     // line drawing\n    p -= a, b -= a;\n    return S( length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) ) );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = 2.* ( U+U - R ) / R.y;\n    float d = .33, o = .6,\n          x = U.x, v = cos(x+2.*iTime)/5.,\n          y = U.y = abs(U.y);                        // symmetries: \n              U.x = abs(fract(U.x*6.+.5)-.5)/6.;     // consider only top half columns\n\n    O = vec4(1);\n    O -= L(U, vec2(0,0),vec2(0,1.5) )                // color bars\n         * ( abs(y-o) > d ? vec4(.4,1,1,0) : vec4(1,1,.4,0) )\n      +  L(U, vec2(0, 1.5),vec2(.07,1.5-v) )         // top half-arrow\n      +  L(U, vec2(0, o+d),vec2(.07, o+v+d) )        // mid\n      +  L(U, vec2(0, o-d),vec2(.07, o-v-d) );       // bottom ( in top half )\n      \n    if (iMouse.z>0.)                                 // if click\n        O = mix(O,vec4(0,1,0,0), S(min(abs(y-1.5), abs(abs(y-o)-d)) )); // green lines\n\n    O = sqrt(O);                                     // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssccDN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 125, 161, 254], [256, 256, 294, 294, 1134]], "test": "untested"}
{"id": "ss3cD4", "name": "(Fourier Series)", "author": "ccc9527", "description": "Fourier", "tags": ["fourier"], "likes": 2, "viewed": 228, "published": 3, "date": "1653453807", "time_retrieved": "2024-07-30T16:47:03.392817", "image_code": "#define PI 3.1415926857\n\nfloat Sine(vec2 uv,int n,float blur)\n{\n    float y = 4.0/(PI*float(n))*sin(float(n)*uv.x);\n    return y;\n}\n\nfloat AddSine(vec2 uv,int n,float blur)\n{\n    float y = 0.0;\n    for(int i=1;i<=n;i+=2)\n    {\n        y += Sine(uv,i,blur);\n    }\n    float d1 = smoothstep(y-0.1,y+0.1,uv.y);\n    float d2 = smoothstep(y+0.1,y-0.1,uv.y);\n    return d1*d2*5.0;\n}\nfloat SubSine(vec2 uv,int n,float blur)\n{\n    float y = 0.0;\n    for(int i=1;i<=n;i++)\n    {\n        if(i%2==0)\n            y -= Sine(uv,i,blur)/2.0;\n        else\n            y += Sine(uv,i,blur)/2.0;\n    }\n    float d1 = smoothstep(y-0.1,y+0.1,uv.y);\n    float d2 = smoothstep(y+0.1,y-0.1,uv.y);\n    return d1*d2*5.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    uv.x *= 10.0*PI;//x(-0.5,0.5)-->(-5*PI,5*PI)\n    uv.y *= 10.0*1.75;//yx\n    \n    int n = int(iTime)*3+1;\n\n    vec3 col = vec3(1.0);\n    \n    float d = AddSine(uv-2.5,n,0.02)+SubSine(uv+2.5,n,0.02);\n     \n    col *= d;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3cD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 63, 63, 131], [133, 133, 174, 174, 376], [377, 377, 418, 418, 697], [699, 699, 756, 756, 1133]], "test": "untested"}
{"id": "NsccWN", "name": "TL // ATOM DISTORT", "author": "fpiaggio", "description": "TL // ATOM DISTORT", "tags": ["tlatomdistort"], "likes": 13, "viewed": 614, "published": 3, "date": "1653438106", "time_retrieved": "2024-07-30T16:47:04.270470", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float rotTime = sin(iTime);\n    \n    vec3 color1 = vec3(0.8, 0.2, 0.);\n    vec3 color2 = vec3(.0, 0.2, 0.8);\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n\n    vec3 destColor = vec3(2.0 * rotTime, .0, 0.5);\n    float f = 10.15;\n    float maxIt = 18.0;\n    vec3 shape = vec3(0.);\n    for(float i = 0.0; i < maxIt; i++){\n        float s = sin((iTime / 111.0) + i * cos(iTime*0.02+i)*0.05+0.05);\n        float c = cos((iTime / 411.0) + i * (sin(iTime*0.02+i)*0.05+0.05));\n        c += sin(iTime);\n        f = (.005) / abs(length(uv / vec2(c, s)) - 0.4);\n        f += exp(-400.*distance(uv, vec2(c,s)*0.5))*2.;\n        // Mas Particulas\n        f += exp(-200.*distance(uv, vec2(c,s)*-0.5))*2.;\n        // Circulito\n        f += (.008) / abs(length(uv/2. / vec2(c/4. + sin(iTime*4.), s/4.)));\n        float idx = float(i)/ float(maxIt);\n        idx = fract(idx*2.);\n        vec3 colorX = mix(color1, color2,idx);\n        shape += f * colorX;\n        \n        uv *= r2d(iTime*0.1 + cos(i*50.)*f);\n    }\n    \n    // vec3 shape = vec3(destColor * f);\n    // Activar modo falopa fuerte\n    // shape = sin(shape*10.+time);\n    fragColor = vec4(shape,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsccWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 104], [105, 105, 162, 162, 1336]], "test": "untested"}
{"id": "NdccWN", "name": "Generative Beat", "author": "jpupper", "description": "The seed of the image changes in every beat for making a visual with the same pattern but similar.", "tags": ["beat", "generative", "feedback"], "likes": 6, "viewed": 285, "published": 3, "date": "1653436553", "time_retrieved": "2024-07-30T16:47:05.303707", "image_code": "\n#define fx iResolution.x/iResolution.y\n#define PI 3.14159235859\nfloat rdm(float p){\n    p*=1234.56;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\nfloat sm(float m1,float m2, float e){\n\treturn smoothstep(m1,m2,e);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nfloat mapr(float _value,float _low2,float _high2) {\n\tfloat val = _low2 + (_high2 - _low2) * (_value - 0.) / (1.0 - 0.);\n    //float val = 0.1;\n\treturn val;\n}\nvec3 l2(vec2 uv,float h){\n\n\tfloat red =mapr(rdm(h+201.),0.0,1.);\n\tfloat g =mapr(rdm(h+431.),0.0,1.);\n\tfloat b =mapr(rdm(h+3023.),0.0,1.);\n\n\tfloat spr =1.;\n\tvec2 sp = vec2(mapr(rdm(h+21.),-spr,spr),\n\t \t         mapr(rdm(h+4031.),-spr,spr));\n\tvec3 cf = vec3(red,g,b);\n\n \t\n\tfloat fr = mapr(rdm(h+453.),5.0,30.);\n\tuv.x*=fx;\n\tuv-=vec2(.5);\n\tuv*=rotate2d(rdm(h+324.)*PI*2.);\n\tuv+=vec2(.5);\n\tuv =fract(uv*fr+vec2(iTime)*sp);\n\t \n\t vec2 p =vec2(0.5*fx,.5)-uv;\n\t float r = length(p);\n\n\tfloat ridx = floor(mapr(rdm(h+4685.),0.0,3.0));\n\n\tfloat e = 0.0; \n\n\tif(ridx == 0.0){\n\n\t\te = 1.-sm(0.1,0.2,uv.x);\n\t}else if(ridx == 1.0 ){\n\n \t\te = 1.-sm(0.1,0.2,uv.x);\n \t\te+= 1.-sm(0.1,0.2,uv.y);\n\t}else if(ridx == 2.0){\n\t\tvec2 p =vec2(0.5,.5)-uv;\n\t \tfloat r = length(p);\n\t \te = 1.-sm(0.1,0.2,r);\n\n\t}\n\t \n\t vec3 dib = cf +sin(e*10.+iTime);\n\t return dib;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = gl_FragCoord.xy / iResolution.xy;\n   vec2 puv = uv;\n   vec2 puv2 = uv;\n\t\n\tfloat t  = floor(iTime*1.0)*0.01;\n\tfloat sr = t;\n vec3 d1 = l2(uv,sr);\n \n\n const int cnt = 5;\n\n vec3 d1aux = d1;\n vec3 fin = d1;\n\tfor(int i =0; i<cnt;i++){\n\t\t\n\t\tvec3 d2 = l2(uv,sr+120.+float(i)*4.);\n\t\tfloat idx = float(i)/float(cnt)*PI*2.;\n\t\t//MASK CIRCLE : \n\t\tvec2 uv_c = uv;\n\t\tuv_c.x*=fx;\n\n\t\tfloat fase = rdm(sr*465.+float(i))*PI*2.;\n\t\t\n\t\tfloat fase2 = rdm(sr*465.+float(i))*PI*2.;\n\n\t\tfloat ampx = sin(rdm(sr*4587.+float(i)*535.)+iTime*.02)*.15+.05;\n\t\tfloat ampy = cos(rdm(sr*4587.+float(i)*535.)+iTime*.02)*.15+.05;\n\t\tfloat s = mapr(rdm(sr+float(i)*325.),0.1,0.2);\n\t\tvec2 p = vec2(0.5*fx,.5) - uv_c;\n\t\tfloat r = length(p);\n\t\tfloat a = atan(p.x,p.y);\n\n\n\t\tfloat amp_mof = mapr(rdm(sr*6384.+float(i)*5341.+t*10.),0.01,0.08);\n\t\tfloat mof = sin(a*5.+iTime)*amp_mof;\n\t\tfloat e = 0.0;\n\t\t\n\t\tfloat ridx = floor(mapr(rdm(sr+4685.+float(i)*579.*10.),0.0,4.0));\n\t\t\n\t\tif(i == cnt){\n\t\t\tridx = 0.0;\n\t\t}\n\t\t\n\t\te = 1.-sm(s,s+0.8,sin(r*10.+idx*40.+sin(iTime+idx))-mof);\n\n\n\t\tif(fin != d1aux && e > 0.001){\n\t\t\tfin = mix(fin,d2,e);\n\t\t}else{\n\t\t\tvec3 d3 = l2(uv,sr+620.+float(i)*57.);\n\t\t\tfin = mix(fin,d3,e);\n\t\t}\n\t}\n\n\tfloat prom = length(fin);\n\t\n    \n\tvec4 fb2 = texture(iChannel0,uv);\n\tfloat fb2_prom = (fb2.r+fb2.g+fb2.b)/3.;\n\t\n\tpuv-=vec2(0.5+fb2_prom*.001);\n\tpuv*= scale(vec2(0.995+fb2_prom*.0001));\n\tpuv+=vec2(0.5-fb2_prom*.001);\n\t\n    \n   \n\tvec4 fb = texture(iChannel0,puv2);\n\t\t\n\tif(prom > 0.995){\n\t\tfin = vec3(0.0);\n\t}\n\t\n\tfloat prom2 = (fin.r+fin.g+fin.b)/3.;\n\t\n\tfin = smoothstep(0.1,0.9,fin);\n\tif( prom2 < 0.2){\n\t\tfin = fb.rgb*.992;\n\t}\n    \n     puv2-=length(fin)*.04;\n     puv2.y=1.-puv2.y;\n\tvec3 textoloco = texture(iChannel1,puv2).rgb;\n    \n    fin+=textoloco;\n\tfragColor = vec4(fin, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define fx iResolution.x/iResolution.y\n#define PI 3.14159235859\nfloat rdm(float p){\n    p*=1234.56;\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\nfloat sm(float m1,float m2, float e){\n\treturn smoothstep(m1,m2,e);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nfloat mapr(float _value,float _low2,float _high2) {\n\tfloat val = _low2 + (_high2 - _low2) * (_value - 0.) / (1.0 - 0.);\n    //float val = 0.1;\n\treturn val;\n}\nvec3 l2(vec2 uv,float h){\n\n\tfloat red =mapr(rdm(h+201.),0.0,1.);\n\tfloat g =mapr(rdm(h+431.),0.0,1.);\n\tfloat b =mapr(rdm(h+3023.),0.0,1.);\n\n\tfloat spr =1.;\n\tvec2 sp = vec2(mapr(rdm(h+21.),-spr,spr),\n\t \t         mapr(rdm(h+4031.),-spr,spr));\n\tvec3 cf = vec3(red,g,b);\n\n \t\n\tfloat fr = mapr(rdm(h+453.),5.0,30.);\n\tuv.x*=fx;\n\tuv-=vec2(.5);\n\tuv*=rotate2d(rdm(h+324.)*PI*2.);\n\tuv+=vec2(.5);\n\tuv =fract(uv*fr+vec2(iTime)*sp);\n\t \n\t vec2 p =vec2(0.5*fx,.5)-uv;\n\t float r = length(p);\n\n\tfloat ridx = floor(mapr(rdm(h+4685.),0.0,3.0));\n\n\tfloat e = 0.0; \n\n\tif(ridx == 0.0){\n\n\t\te = 1.-sm(0.1,0.2,uv.x);\n\t}else if(ridx == 1.0 ){\n\n \t\te = 1.-sm(0.1,0.2,uv.x);\n \t\te+= 1.-sm(0.1,0.2,uv.y);\n\t}else if(ridx == 2.0){\n\t\tvec2 p =vec2(0.5,.5)-uv;\n\t \tfloat r = length(p);\n\t \te = 1.-sm(0.1,0.2,r);\n\n\t}\n\t \n\t vec3 dib = cf +sin(e*10.+iTime);\n\t return dib;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\tvec2 puv = uv;\n\t\n\t\n\tfloat t  = floor(iTime*1.0)*0.01;\n\tfloat sr = t;\n vec3 d1 = l2(uv,sr);\n \n\n const int cnt = 5;\n\n vec3 d1aux = d1;\n vec3 fin = d1;\n\tfor(int i =0; i<cnt;i++){\n\t\t\n\t\tvec3 d2 = l2(uv,sr+120.+float(i)*4.);\n\t\tfloat idx = float(i)/float(cnt)*PI*2.;\n\t\t//MASK CIRCLE : \n\t\tvec2 uv_c = uv;\n\t\tuv_c.x*=fx;\n\n\t\tfloat fase = rdm(sr*465.+float(i))*PI*2.;\n\t\t\n\t\tfloat fase2 = rdm(sr*465.+float(i))*PI*2.;\n\n\t\tfloat ampx = sin(rdm(sr*4587.+float(i)*535.)+iTime*.02)*.15+.05;\n\t\tfloat ampy = cos(rdm(sr*4587.+float(i)*535.)+iTime*.02)*.15+.05;\n\t\tfloat s = mapr(rdm(sr+float(i)*325.),0.1,0.2);\n\t\tvec2 p = vec2(0.5*fx,.5) - uv_c;\n\t\tfloat r = length(p);\n\t\tfloat a = atan(p.x,p.y);\n\n\n\t\tfloat amp_mof = mapr(rdm(sr*6384.+float(i)*5341.+t*10.),0.01,0.08);\n\t\tfloat mof = sin(a*5.+iTime)*amp_mof;\n\t\tfloat e = 0.0;\n\t\t\n\t\tfloat ridx = floor(mapr(rdm(sr+4685.+float(i)*579.*10.),0.0,4.0));\n\t\t\n\t\tif(i == cnt){\n\t\t\tridx = 0.0;\n\t\t}\n\t\t\n\t\te = 1.-sm(s,s+0.8,sin(r*10.+idx*40.+sin(iTime+idx))-mof);\n\n\n\t\tif(fin != d1aux && e > 0.001){\n\t\t\tfin = mix(fin,d2,e);\n\t\t}else{\n\t\t\tvec3 d3 = l2(uv,sr+620.+float(i)*57.);\n\t\t\tfin = mix(fin,d3,e);\n\t\t}\n\t}\n\n\tfloat prom = length(fin);\n\t\n\t\n\tvec4 fb2 = texture(iChannel0,uv);\n\tfloat fb2_prom = (fb2.r+fb2.g+fb2.b)/3.;\n\t\n\tpuv-=vec2(0.5+fb2_prom*.001);\n\tpuv*= scale(vec2(0.995+fb2_prom*.0001));\n\tpuv+=vec2(0.5-fb2_prom*.001);\n\t\n\tvec4 fb = texture(iChannel0,puv);\n\t\t\n\tif(prom > 0.995){\n\t\tfin = vec3(0.0);\n\t}\n\t\n\tfloat prom2 = (fin.r+fin.g+fin.b)/3.;\n\t\n\tfin = smoothstep(0.1,0.9,fin);\n\tif( prom2 < 0.2){\n\t\tfin = fb.rgb*.992;\n\t}\n\t\n\tfragColor = vec4(fin, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvec3 generarTextoLoco(){\n   \n    //fragColor = vec4(fractalLoco();,1.);\n    //fragColor = vec4(vec3(1.0,0.0,0.0),1.);\n    vec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n    \n    \n\tuv *= 40.0 ;\n\t\n    uv -= vec2(-8., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\t//uv.x+=4. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ J P U P P E R _ _ _ _ _\n    float a = smoothstep(0.6,0.1,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    return col;\n\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec3 col=generarTextoLoco();\n       //  col+=texto;\n    fragColor = vec4(col, 1.0);\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdccWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 84, 84, 174], [175, 175, 212, 212, 243], [244, 244, 272, 272, 358], [359, 359, 383, 383, 446], [447, 447, 498, 498, 604], [605, 605, 630, 630, 1433], [1435, 1435, 1492, 1492, 3260]], "test": "untested"}
{"id": "fdcyWN", "name": "TL // Atom Pulse", "author": "fpiaggio", "description": "TL // CIRCLE ROTATE", "tags": ["tlcirclerotate"], "likes": 11, "viewed": 387, "published": 3, "date": "1653432828", "time_retrieved": "2024-07-30T16:47:06.422715", "image_code": "mat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel0, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float time = iTime;\n    float rotTime = sin(time);\n    \n    vec3 color1 = vec3(0.8, 0.2, 0.);\n    vec3 color2 = vec3(.0, 0.2, 0.8);\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n\n    vec3 destColor = vec3(2.0 * rotTime, .0, 0.5);\n    float f = 10.15;\n    float maxIt = 18.0;\n    vec3 shape = vec3(0.);\n    for(float i = 0.0; i < maxIt; i++){\n        float s = sin((time / 111.0) + i * cos(iTime*0.02+i)*0.05+0.05);\n        float c = cos((time / 411.0) + i * (sin(time*0.02+i)*0.05+0.05));\n        c += sin(iTime);\n        f = (.005) / abs(length(uv / vec2(c, s)) - 0.4);\n        f += exp(-400.*distance(uv, vec2(c,s)*0.5))*2.;\n        // Mas Particulas\n        f += exp(-200.*distance(uv, vec2(c,s)*-0.5))*2.;\n        // Circulito\n        f += (.008) / abs(length(uv/2. / vec2(c/4. + sin(time*4.), s/4.)));\n        float idx = float(i)/ float(maxIt);\n        idx = fract(idx*2.);\n        vec3 colorX = mix(color1, color2,idx);\n        shape += f * colorX;\n        \n        uv *= r2d(iTime*0.1 + cos(i*50.));\n    }\n    //texto(shape, vec2(-0.42,0.42));\n    \n    // vec3 shape = vec3(destColor * f);\n    // Activar modo falopa fuerte\n    // shape = sin(shape*10.+time);\n    fragColor = vec4(shape,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n    uv *= 2.5;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ F P I A G G I O _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 104], [105, 105, 146, 146, 299], [300, 300, 357, 357, 1586]], "test": "untested"}
{"id": "NscyWN", "name": "Debug LEL", "author": "Ossitech", "description": "test", "tags": ["fuf"], "likes": 1, "viewed": 186, "published": 3, "date": "1653431953", "time_retrieved": "2024-07-30T16:47:07.355222", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n   fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NscyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 140]], "test": "untested"}
{"id": "NdcyWN", "name": "Sound Laser Line Projector", "author": "Ossitech", "description": "Shader for projectors with fog machines.", "tags": ["sound", "audio", "laser", "projector"], "likes": 1, "viewed": 367, "published": 3, "date": "1653431504", "time_retrieved": "2024-07-30T16:47:08.255814", "image_code": "#define MULT 0.0\n#define SPEED 2.0\n\nfloat getOffset()\n{\n    float offset = 0.0;\n    \n    for (int i = 0; i < 512; i++)\n    {\n        offset += texture(iChannel0, vec2(float(i) / 512.0, 0.0)).x * MULT;\n    }\n    \n    offset /= 512.0;\n    \n    return offset;\n}\n\n// direction x + y must be 1.0.\n// d must be between 0.0 an 1.0.\nint line(vec2 uv, vec2 direction, float d)\n{\n    float v = uv.x * direction.x + uv.y * direction.y;\n    \n    if (abs(d - v) < 0.01) return 1;\n    \n    return 0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    int mask = 0;\n    \n    int second = int(iTime) % 60;\n    \n    float d = cos(iTime * SPEED) * 0.5 + 0.5 + getOffset();\n    \n    if (second < 10) mask += line(uv, vec2(1.0, 0.0), d);\n    else if(second < 20) mask += line(uv, vec2(0.0, 1.0), d);\n    else if(second < 30) mask += line(uv, vec2(0.5, 0.5), d);\n    else if(second < 40) mask += line(uv, vec2(0.25, 0.75), d);\n    else if(second < 50) mask += line(uv, vec2(0.8, 0.2), d);\n    else mask += line(uv, vec2(0.4, 0.6), d);\n    \n    if (mask > 0) fragColor = texture(iChannel1, uv);\n    else fragColor = vec4(0.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcyWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 258], [260, 325, 369, 369, 487], [489, 489, 546, 546, 1167]], "test": "untested"}
{"id": "Ns3yWN", "name": "Mationi - Colored Border 2", "author": "juanpetrik", "description": "Colored Border 2", "tags": ["coloredborder2"], "likes": 2, "viewed": 232, "published": 3, "date": "1653431000", "time_retrieved": "2024-07-30T16:47:09.104545", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p1 = vec2(.01, .01);\n    vec2 p2 = vec2(.99, .991);\n    vec2 p3 = vec2(.01, .99);\n    vec2 p4 = vec2(.99, .01);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c2 = texture(iChannel0, uv + iTime/10.);\n    \n    float d1 = step(p1.x,uv.x)*step(uv.x,p4.x)*abs(uv.y-p1.y)+\n        step(uv.x,p1.x)*distance(uv,p1)+step(p4.x,uv.x)*distance(uv,p4);\n    d1 = min(step(p3.x,uv.x)*step(uv.x,p2.x)*abs(uv.y-p2.y)+\n        step(uv.x,p3.x)*distance(uv,p3)+step(p2.x,uv.x)*distance(uv,p2),d1);\n    d1 = min(step(p1.y,uv.y)*step(uv.y,p3.y)*abs(uv.x-p1.x)+\n        step(uv.y,p1.y)*distance(uv,p1)+step(p3.y,uv.y)*distance(uv,p3),d1);\n    d1 = min(step(p4.y,uv.y)*step(uv.y,p2.y)*abs(uv.x-p2.x)+\n        step(uv.y,p4.y)*distance(uv,p4)+step(p2.y,uv.y)*distance(uv,p2),d1);\n        \n    float f1 = .01 / abs(d1 + c2.r/100.);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\tfragColor = vec4(f1 * col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3yWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1007]], "test": "untested"}
{"id": "fdcyD4", "name": "voronoi procedural islands", "author": "ArmandB", "description": "fps fixes", "tags": ["noise"], "likes": 4, "viewed": 260, "published": 3, "date": "1653428413", "time_retrieved": "2024-07-30T16:47:10.042039", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord),0).rgb;\n    float n = voronoi3d(vec3((uv+vec2(iTime/20.0,0))*5.0,40.0))*voronoi3d(vec3((uv+vec2(iTime/20.0,0))*30.0,40.0+iTime/3.0))/2.0;\n    col = smoothmix(vec3(1.0 - n*3.0), col, -0.01, 0.03, clamp(n-0.05,0.0,1.0));\n    \n    fragColor = vec4(col, 0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame <= 1){\n        vec2 uv = fragCoord/iResolution.y;\n\n        vec3 col = vec3(0,0,1);\n        \n        col = smoothmix(vec3(0,0.5,1), col, 0.1, 0.3, voronoi3d(vec3(uv*5.0,1.0))+voronoi3d(vec3(uv*10.0,1.0))/2.0-0.6);\n        col = smoothmix(vec3(0.9,1.0,0.4), col, 0.05, 0.08, voronoi3d(vec3(uv*5.0,1.0))+voronoi3d(vec3(uv*10.0,1.0))/2.0-0.6);\n        col = smoothmix(vec3(0.1,0.8,0), col, 0.0, 0.03, voronoi3d(vec3(uv*5.0,1.0))+voronoi3d(vec3(uv*10.0,1.0))/2.0-0.6);\n        col = smoothmix(vec3(0.2,0.6,0.1), col, -0.08, 0.0, voronoi3d(vec3(uv*5.0,1.0))+voronoi3d(vec3(uv*10.0,1.0))/2.0-0.6);\n        col = smoothmix(vec3(0,0.4,0.2), col, 0.0, 0.03, voronoi3d(vec3(uv*100.0,1.0))+mix(0.0,1.0,smoothstep(-0.1, -0.02, voronoi3d(vec3(uv*5.0,1.0))+voronoi3d(vec3(uv*10.0,1.0))/2.0-0.6))-0.6);\n        \n        fragColor = vec4(col,1);\n        \n    } else {\n        fragColor = texelFetch(iChannel0, ivec2(fragCoord),0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//given a point, output a random point with values from 0 to 1\n///  3 out, 3 in...\nvec3 hash33(vec3 p3) //https://www.shadertoy.com/view/4djSRW\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//https://iquilezles.org/articles/smin/\n// power smooth min (k=8)\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\nfloat voronoi3d(vec3 uv){\n    //assume uv is on a 0-1 scale\n    float n = 999.0;\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            for (int z = -1; z < 2; z++){\n                n = smin(n,distance(floor(uv) + vec3(x,y,z) + hash33(floor(uv) + vec3(x,y,z)),uv),8.0);\n            }\n        }\n    }\n    return n;\n}\n\nvec3 smoothmix(vec3 a, vec3 b, float l, float h, float t){\n    return mix(a,b,smoothstep(l,h,t));\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 411]], "test": "untested"}
{"id": "fd3yW8", "name": "Sound Spectrum Ossitech", "author": "Ossitech", "description": "Erster Shader mit Soundeingang.", "tags": ["sound"], "likes": 5, "viewed": 336, "published": 3, "date": "1653415711", "time_retrieved": "2024-07-30T16:47:10.953601", "image_code": "#define MULT 1.5\n\nfloat getMirroredFFT(vec2 uv)\n{\n    if (uv.x < 0.5) return texture(iChannel0, vec2(0.5 - uv.x, uv.y)).x;\n    return texture(iChannel0, uv - vec2(0.5, 0.0)).x;\n}\n\nfloat getOffset()\n{\n    float offset = 0.0;\n    \n    for (int i = 0; i < 512; i++)\n    {\n        offset += texture(iChannel0, vec2(float(i) / 512.0, 0.0)).x * MULT;\n    }\n    \n    offset /= 512.0;\n    \n    return offset;\n}\n\nvec4 line(vec2 pos)\n{\n    \n    float offset = getOffset();\n    \n    vec2 uv = pos / iResolution.xy;\n    \n    float v = 0.5 + cos(pos.x / (0.2 * iResolution.x) + pos.y * 0.005 + iTime * 10.0 + 20.0 * offset);\n    float fft = getMirroredFFT(uv) * MULT;\n    \n    float line_width = 100.0 * (offset - 0.3);\n    float line_distance = 200.0 + 100.0 * sin(iTime * 0.1);\n    \n    if (int((offset + fft * 2.0) * 100.0 + pos.y + cos(iTime * 2.0) * 100.0) % int(line_distance) < int(line_width))\n    {\n        //Basic Color\n        vec4 colBase = vec4(v, cos(iTime + offset), sin(iTime * 0.3), 1.0);\n        //Detail Color\n        vec4 colWave = vec4(sin(iTime + offset), cos(iTime * 0.3), v * fft, 1.0);\n        return colBase + colWave;\n    }\n    return vec4(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = line(fragCoord);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fd3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 49, 49, 178], [180, 180, 199, 199, 402], [404, 404, 425, 425, 1161], [1163, 1163, 1220, 1220, 1255]], "test": "untested"}
{"id": "fdtyDH", "name": "Dot Product Simple", "author": "djancool", "description": "A simple showcase how the dot product works. Grey/White line color and leght show the dot product result from the red and blue vector. If the white line becomes green the value is negative", "tags": ["simple", "explained", "dot", "product"], "likes": 4, "viewed": 537, "published": 3, "date": "1653406958", "time_retrieved": "2024-07-30T16:47:12.099537", "image_code": "// https://www.shadertoy.com/view/tsj3Rd\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    // Find vectors pa and ba:\n    vec2 pa = p-a, ba = b-a;\n    // Compute the dot product of vectors and divide to get the ratio\n    // Clamp the ratio between 0.0 and 1.0\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    // Return the distance from the given point to the nearest point on line ab\n    return length(pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y * 2.0;\n    vec2 mousePosOld = abs(iMouse.zw) / iResolution.y * 2.0;\n    vec2 mousePosCur = iMouse.xy / iResolution.y * 2.0;\n\n    float gradient = sin(uv.x * 0.8) * sin(uv.y * 1.57);\n    gradient = pow(gradient, 0.1);\n    vec3 outputCol = vec3(0.2, 0.2, 0.2) * gradient;\n\n\n    vec2 ro1 = vec2(1.6, 1.0);\n    vec2 rd1 = vec2(1.0, 0.0);\n    \n    vec2 ro2 = ro1;\n    vec2 rd2 = normalize(mousePosCur - ro2);\n    \n    float Drd1rd2 = dot(rd1, rd2);\n    \n    vec2 ro3 = ro1 + rd1 * Drd1rd2;\n    vec2 rd3 = normalize((ro2 + rd2) - ro3);\n    float rd3l = length((ro2 + rd2) - ro3);\n    \n    float lineSide = -sign(dot(vec2(0.0, 1.0), rd2));   \n    \n    vec2 ro4 = ro1 + vec2(0.0, 0.1) * lineSide;\n    vec2 rd4 = rd1 * Drd1rd2;\n    vec3 r4c = abs(Drd1rd2) * vec3(sign(Drd1rd2), 1.0, sign(Drd1rd2));\n\n    \n    float line1 = sdLine(uv, ro1, ro1 + rd1);\n    if(line1 < 0.01) outputCol = vec3(0.1, 0.1, 0.9);\n    \n    float line2 = sdLine(uv, ro2, ro2 + rd2);\n    if(line2 < 0.01) outputCol = vec3(1.0, 0.1, 0.1);\n    \n    float line3 = sdLine(uv, ro3, ro3 + rd3 * rd3l);\n    if(line3 < 0.006) outputCol = vec3(0.1, 0.9, 0.1);\n    \n    float line4 = sdLine(uv, ro4, ro4 + rd4);\n    if(line4 < 0.01) outputCol = r4c;\n\n\n\n    // Output to screen\n    fragColor = vec4(outputCol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 86, 117, 424], [426, 426, 483, 533, 1840]], "test": "untested"}
{"id": "ss3yW8", "name": "Flood Fill Shape Test", "author": "SnoopethDuckDuck", "description": "Very very very messy attempt at making pixel art\n\nadds a walk with random length lines, uses flood fill to find an outline, then automata for some other stuff (lots unused)", "tags": ["feedback", "pixelart", "cellularautomata"], "likes": 1, "viewed": 376, "published": 3, "date": "1653404698", "time_retrieved": "2024-07-30T16:47:18.086530", "image_code": "vec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5*cos( 6.28318*(0.5*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float zm = 0.2;\n    \n    vec2 res = floor(iResolution.xy);\n    \n    vec2 f = fragCoord;vec2(abs(fragCoord.x - 0.5 * res.x) + 0.5 * res.x, fragCoord.y);\n    vec2 f2 = vec2(res.x-f.x, f.y);\n\n    vec4 col = texelFetch( iChannel0, ivec2(zm * f + 0.5 * (1.-zm) * res), 0);\n    vec4 col2 = texelFetch( iChannel1, ivec2(zm * f + 0.5 * (1.-zm) * res), 0);\n    float b = col.b;\n    \n   // if (col.r >= 1.)\n     //   col *= 0.;\n    \n    if (col.rgb == vec3(0))\n       col.rgb = vec3(0.95);\n    else {\n        if (col.rgb == vec3(0,1,1))\n            col.rgb = vec3(0);\n        col.r /= col.a;\n        //col.g = col.a;\n    \n        if (col.r > 0.) {\n            //col.rgb = pal(floor(8. * col.r)/5. + cos(1.75 * 3.14159 * floor(float(iFrame)/360.)), 0.5 * vec3(0,1,2)/3.);\n            col.rgb = pal(1.5 + floor(uv.y * 16.) / 16., 0.5 * vec3(0,1,2)/3.);\n           \n            col.rgb = mix(col.rgb, vec3(1), col.r);\n        }\n        \n        if (col.g == 1.)\n            col.rgb = vec3(0);\n    }\n    \n    col2.rgb = col2.rrr;\n   // vec3 col3 = pal(floor(uv.y * 16.) / 16.+ floor(float(iFrame)/360.), 0.5 * vec3(0,1,2)/3.);\n   // vec3 col4 = pal(0.12 + floor(uv.y * 16.) / 16.+ floor(float(iFrame)/360.), 0.5 * vec3(0,1,2)/3.);\n    \n    vec3 col3 = pal(1.15 + floor(uv.y * 16.) / 16., 0.5 * vec3(0,1,2)/3.);\n    vec3 col4 = pal(0.12 + 1.2 + floor(uv.y * 16.) / 16., 0.5 * vec3(0,1,2)/3.);\n    \n    if (col.rgb == vec3(0))\n        col.rgb = mix(col3, col4, col2.r);\n    \n    if (b==1.)\n        col.rgb = vec3(0.1);\n     \n    //*/\n    fragColor.rgb = col.rgb;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\n#define pi 3.14159\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    f -= p;\n    vec2 dir = .5 * (q - p),\n         v = step(abs(f - round(dir/dir.yx * f.yx)), vec2(0)),\n         a = step(abs(f - dir), abs(dir));  \n    return max(v.x, v.y) * a.x * a.y ;           \n}\n\nfloat getShape(vec2 f) {\n    f -= 0.5;\n    vec2 p = vec2(0);\n    float s = 0.;\n    float t = 0.01 * floor(iTime);\n    float a = 0.;\n\n    float n = 100.;\n    for (float i = 0.; i < n; i++) {\n        float j = i + t;\n        float h = h21(vec2(j , 103. + j));\n        float h2 = h21(vec2(j-10.,3. * j));\n      \n       // float m = 0.;mod(i, 2.);\n        a += 0.25 * pi * (2. * floor(h) - 1.);// * (0.25 * floor((2. + m) * h)-m);\n               \n        vec2 q = p + ceil(h2 * 8.) * vec2(cos(a), sin(a));\n        q = round(q);\n        \n        s = max(s, pxLine(f, p, q));\n        s = max(s, pxLine(vec2(-f.x-1., f.y), p, q));\n\n        p = q;\n    }     \n    return s;\n}\n\nvec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\n// because im lazy\nfloat alpha(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).a;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n\n    col.rgb = cell(px);\n    col.a = alpha(px);\n    \n    vec3 b = cell(px - ivec2(0,1));\n    vec3 t = cell(px + ivec2(0,1));\n    vec3 l = cell(px - ivec2(1,0));\n    vec3 r = cell(px + ivec2(1,0));\n    \n    vec3 bl = cell(px + ivec2(-1,-1));\n    vec3 tl = cell(px + ivec2(-1,1));\n    vec3 br = cell(px + ivec2(1,-1));\n    vec3 tr = cell(px + ivec2(1,1));\n        \n    \n    vec3 col2 = vec3(0);\n    \n    if (frame == 0 || key_down(KEY_RESET)) {\n        vec2 res = floor(0.5 * iResolution.xy);\n\n        col.b = 0.;\n        col.rg = vec2(1) * clamp(getShape(f-res), 0., 1.);\n        col.a = 0.;\n        \n        //if (length(f-res) < 25. && length(f-res) > 24.)\n         //   col.r = 1.;\n\n        if (f.x < 1. || f.y < 1.)\n            col.g = 0.;\n        else\n            col.g = 1.;\n       // if (f.x < res.x && f.x > res.x - 1. && f.y < res.y && f.y > res.y - 1.)\n         //   col.g = 2.;\n        \n        return;\n    }\n    else if (frame < 20) {        \n        int n = 20;\n        for (int i = 0; i < n; i++) {\n            if (cell(px + ivec2(i,0)).r == 1. ||\n                cell(px + ivec2(0,i)).r == 1. ||\n                cell(px + ivec2(-i,0)).r == 1. ||\n                cell(px + ivec2(0,-i)).r == 1.) {\n                  //col.b = float(i)/float(n);\n                  break;              \n            }\n        \n            if (cell(px + ivec2(i,0)).g == 0. ||\n                cell(px + ivec2(0,i)).g == 0. ||\n                cell(px + ivec2(-i,0)).g == 0. ||\n                cell(px + ivec2(0,-i)).g == 0.) {\n                    col.g = 0.;\n            }\n        }\n    }\n    else if (frame < 21) { \n        vec3 b = cell(px - ivec2(0,1));\n        vec3 t = cell(px + ivec2(0,1));\n        vec3 l = cell(px - ivec2(1,0));\n        vec3 r = cell(px + ivec2(1,0));\n \n        float gsum = b.g + t.g + l.g + r.g;\n        \n        if (col.r == 1.) {\n            col.g = 1.;\n            col.r = 0.;\n        }\n       \n        if (col.r == 0. && col.g == 1.&& gsum != 4.) {\n            //col.g = 0.;\n            col.b = 1.;\n        }\n        \n       \n    } \n    else if (frame < 22) {\n        vec3 b = cell(px - ivec2(0,1));\n        vec3 t = cell(px + ivec2(0,1));\n        vec3 l = cell(px - ivec2(1,0));\n        vec3 r = cell(px + ivec2(1,0));\n        \n        float bsum = b.b + t.b + l.b + r.b;\n      \n        if (col.g == 1. && col.b == 0. && bsum > 0.) {\n            col.r = 1.;\n           // col.b = 0.;\n        }\n    }\n    else if (frame < 23) {\n        vec2 res = floor(0.5 * iResolution.xy);\n        if (abs(f.x-res.x) < 1. && f.y <= res.y && col.r == 1.)\n            col.r = 2.;\n    }\n    else if (frame < 163) {\n        vec3 v = vec3(1);\n        float mx = max(max(b.r,t.r),max(l.r,r.r));\n        mx = max( mx, max(max(bl.r,tl.r), max(br.r, tr.r)) );\n        if(mx > 1. && col.r == 1.) {\n            col.g = 0.;\n            col.r = mx + 1.;\n        }\n    }\n    else if (frame < 164) {\n        col.a = col.r;\n    }\n    else if (frame < 175) {\n        int n = 20;\n        for (int i = 0; i < n; i++) {\n            float a = max( max(alpha(px + ivec2(i,0)), alpha(px + ivec2(0,i))), \n                           max(alpha(px + ivec2(-i,0)), alpha(px + ivec2(0,-i))) );\n            //a = max( max(cell(px + ivec2(i,0)).b, cell(px + ivec2(0,i)).b), \n             //        max(cell(px + ivec2(-i,0)).b, cell(px + ivec2(0,-i)).b) );\n            \n            if (a > col.a)\n                col.a = a;\n        }\n    }\n   // if (col.rgb == vec3(0))\n    //    col.rgb = vec3(0.5);\n    // */\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec3 cell(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgb;\n}\n\nvec3 cell2(in ivec2 p) {\n    ivec2 r = ivec2(textureSize(iChannel1, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel1, p, 0 ).rgb;\n}\n\nvoid mainImage( out vec4 col, in vec2 f )\n{\n    ivec2 px = ivec2(f);\n    if (frame == 0) {\n        col.rgb = cell(px);\n    }\n    else \n        col.rgb = cell2(px);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define frame iFrame % 360", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 33, 33, 82], [84, 84, 141, 141, 1761]], "test": "untested"}
{"id": "NstyD8", "name": "TL // Grid + Dancing Lights", "author": "fpiaggio", "description": "TL // Grid + Dancing Lights", "tags": ["tlgriddancinglights"], "likes": 6, "viewed": 251, "published": 3, "date": "1653397722", "time_retrieved": "2024-07-30T16:47:19.032002", "image_code": "#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 1.0\n\n#define GRIDW 0.02\n\n#define GRID_R 0.672443156957688\n#define GRID_G 0.0103298230296269\n#define GRID_B 0.246201326707835\n#define FALLOFF_GRID 0.75\n\n// Grid from  https://www.shadertoy.com/view/3tlXWS\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\nfloat grid(vec2 pix, float t) {\n    \n    float d = t + (pix.y / 30.0) + sin(pix.x * 500.0);\n    \n    float distortion = (sin(d * 400.0)*2. + (sin(d * 600.0) / 2.0) + (sin(d * 800.0) / 3.0)) / 4.0;\n    \n    float w = tri((pix.x + distortion) / 50.0);\n    float h = tri((pix.y + distortion) / 50.0);\n    \n    \n    float power = 1.0 + 0.25 * tri(pix.y / 50.0 + t / 6.0);\n    \n    float falloff = power * FALLOFF_GRID;\n    \n    float dist = min(w, h) * 25.0;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 center = iResolution.xy / 2.0;\n    vec3 col = vec3(0);\n    float scale = 816.0 / iResolution.x;\n    // float scale = sin(iTime)*1512.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n    \n    vec2 uv_r = uv - vec2(sin(iTime / 3.0 + uv.y / 50.0) * 4.0, sin(uv.x / 75.0 + iTime / 8.0));\n    vec2 uv_g = uv;\n    vec2 uv_b = uv + vec2(cos(iTime / 2.0 + uv.y / 50.0) * 4.0, cos(uv.x / 50.0 + iTime / 4.0));\n\n    float grid_r = grid(uv_r, iTime) * GRID_R;\n    float grid_g = grid(uv_g, iTime - 0.1) * GRID_G;\n    float grid_b = grid(uv_b, iTime + 0.1) * GRID_B;\n    \n    vec3 grid_col = vec3(sRGB(grid_r), sRGB(grid_g), sRGB(grid_b));\n    \n    uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    float v = 0.0;\n    vec2 pos = uv * 2.;\n    float angle = 6. + sin(iTime*0.015);\n    float separation = 0.00195 + sin(iTime*0.2) * 0.02;\n    int maxIt = 150;\n    for (int i = 0; i < maxIt; i++) {\n        float s = (iTime*0.02) + float(i) * separation;\n        // vec2 mpos = 0.9 * vec2(sin(s * angle), - cos(s * (angle+1.) + iTime * 0.5));\n        vec2 mpos = (0.6 + sin(iTime * 0.5)) * vec2(sin(s * angle), - cos(s * (angle+1.) + iTime * 0.4));\n        float t = 1. / length(mpos - pos);\n        // float idx = float(i)/ float(maxIt);\n        v += t*t * float(i + 1) / 600000.0;\n    }\n\n    vec3 particles = vec3(vec3(v, v, v+0.5));\n    col = mix(grid_col, particles, particles);\n    //col = mix(col, particles, grid_col);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[269, 269, 290, 290, 402], [404, 404, 424, 424, 452], [454, 454, 474, 474, 518], [520, 520, 551, 551, 1049], [1052, 1052, 1109, 1109, 2588]], "test": "untested"}
{"id": "NsdcW8", "name": "TL // Morph Circle", "author": "fpiaggio", "description": "TL // Morph Flower", "tags": ["tlmorphflower"], "likes": 11, "viewed": 535, "published": 3, "date": "1653397094", "time_retrieved": "2024-07-30T16:47:20.080199", "image_code": "float getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n    }\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n\tvec2 pos = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    pos *= 1. + (sin(iTime) * 0.2)*1.2;\n\tconst float pi = 5.14159;\n\tconst float n = 6.0;\n\t\n\tfloat radius = length(pos) * 2.0 - 0.4;\n\tfloat t = atan(pos.y, pos.x) + cos(pos.x*5.*pos.y*5. + sin(iTime + pos.x));\n\t\n\tfloat color = 0.025 + sin(iTime)*0.01;\n\t\n\tfor (float i = 2.0; i <= n; i++){\n\t\tcolor += 0.012 / abs((0.01+sin(iTime)*0.5 + 0.5) * sin(\n\t\t\t4. * (t + i/n * iTime * .8)\n\t\t    ) - radius\n\t\t);\n\t}\n\t\n\tvec3 shape = vec3(1.2, 0.3 + sin(iTime), 0.15+cos(iTime)*0.5+0.5) * color;\n    fragColor = vec4(shape,1.0) * (getSound()+0.5);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdcW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 233], [239, 239, 296, 296, 896]], "test": "untested"}
{"id": "ss3yDH", "name": "2D Ray-Sphere Intersections", "author": "djancool", "description": "Wanted to learn how to do a ray sphere intersectioin. This could be handy in realtime applications for raymarching because you know the total distance that is traveled trough the spher (x1 + x2)\n\nYou can stop the movement with the SphereMove define", "tags": ["2d", "sphere", "intersections"], "likes": 2, "viewed": 221, "published": 3, "date": "1653383178", "time_retrieved": "2024-07-30T16:47:21.054594", "image_code": "#define SphereMove 1\n\n// https://www.shadertoy.com/view/tsj3Rd\nfloat sdLine(in vec2 p,in vec2 a,in vec2 b)\n{\n    // Find vectors pa and ba:\n    vec2 pa = p-a, ba = b-a;\n    // Compute the dot product of vectors and divide to get the ratio\n    // Clamp the ratio between 0.0 and 1.0\n\tfloat h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    // Return the distance from the given point to the nearest point on line ab\n    return length(pa - ba*h);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    vec2 mousePosOld = abs(iMouse.zw) / iResolution.y;\n    vec2 mousePosCur = iMouse.xy / iResolution.y;\n    \n    vec2 ro = mousePosOld;\n    vec2 rd = normalize(mousePosCur - mousePosOld);\n\n\n    float gradient = sin(uv.x * 1.57) * sin(uv.y * 3.14);\n    gradient = pow(gradient, 0.1);\n    vec3 outputCol = vec3(0.2, 0.2, 0.2) * gradient;\n    \n    // Ray colors\n    vec3 C_ROtX1 = vec3(1);\n    vec3 C_Sphere = vec3(0.1, 0.9, 0.1);  // Sphere color\n    vec3 C_ROtSO = vec3(0.9, 0.1, 0.1);   // Ray origin to sphere centre\n    vec3 C_SOtT = vec3(0.1, 0.1, 0.9);    // Sphere centre to closest point on ray\n    vec3 C_X1tT = vec3(0.5, 0.1, 1.0);    // First part of ray inside of sphere\n    vec3 C_TtX2 = vec3(1.0, 0.1, 0.5);    // Second part of ray inside of sphere\n    vec3 C_SOtX1 = vec3(0.3, 0.3, 0.3);   // Ray hit to sphere centre\n\n\n\n    // Ray Direction\n    float line = sdLine(uv, mousePosOld, mousePosOld + rd * 2.0);\n    //if(line < 0.007) outputCol = vec3(0.9, 0.9, 0.9);\n\n\n    //// Sphere ////\n    #if SphereMove\n    vec2 spherePos = vec2(0.8885, 0.5) + vec2(sin(iTime), cos(iTime)) * 0.1;\n    #else\n    vec2 spherePos = vec2(0.8885, 0.5);\n    #endif\n    float sphereRad = 0.3;\n    float sphereSDF = length(uv - spherePos) - sphereRad;\n    if(sphereSDF < 0.0 && sphereSDF > -0.01) outputCol = C_Sphere;\n    \n    \n    //----RO to Sphere Origin\n    float lineROtS = sdLine(uv, mousePosOld, mousePosOld + (spherePos - mousePosOld));\n    if(lineROtS < 0.003) outputCol = C_ROtSO;\n    \n    \n    //// Closest point from sphereOrigin to RD line ////\n    // t is the distance along RD where the closest point is\n    float t = dot(spherePos - mousePosOld, rd);\n    // position of t along RD\n    vec2 tpos = mousePosOld + rd * t;\n    // distance from centre of sphere to closest point of RD / tpos // Blue line\n    float tdis = distance(tpos, spherePos);\n    // render line from sphere origin to tpos // Blue line\n    float lineT = sdLine(uv, tpos, tpos + (spherePos - tpos));\n    // Check if the ray is insie the spher\n    if(sphereRad > tdis) // inside\n    {\n        if(lineT < 0.003) outputCol = C_SOtT;\n    }\n    else                 // outside\n    {\n        if(line < 0.003) outputCol = C_ROtX1;\n    }\n    \n    // hit points of sphere\n    // calculate tpos to sphere hit distance based on triangle\n    float x1 = sqrt( sphereRad*sphereRad - tdis*tdis);\n    float tx1 = t - x1;\n    float tx2 = t + x1;\n    vec2 tx1Pos = mousePosOld + rd * tx1;\n    vec2 tx2Pos = mousePosOld + rd * tx2;\n    \n    \n    // Visual line of the triangle exaction\n    float lineTris = sdLine(uv, spherePos, tx1Pos);\n    if(lineTris < 0.003) outputCol = C_SOtX1;\n    \n    \n    // Line from RO to x1\n    float lineX1 = sdLine(uv, mousePosOld, tx1Pos);\n    if(lineX1 < 0.004) outputCol = C_ROtX1;\n\n    \n    // Line from x1 to tpos\n    float lineX1tTPOS = sdLine(uv, mousePosOld + rd * t, tx1Pos);\n    if(lineX1tTPOS < 0.004) outputCol = C_X1tT;\n    \n    // Line from tpos to x2\n    float lineTPOStX2 = sdLine(uv, mousePosOld + rd * t, tx2Pos);\n    if(lineTPOStX2 < 0.004) outputCol = C_TtX2;\n    \n    // Line conitues from x2\n    float lineX2rd = sdLine(uv, mousePosOld + rd * tx2, tx1Pos + rd * 2.0);\n    if(lineX2rd < 0.004) outputCol = C_ROtX1;\n\n\n\n    // Output to screen\n    fragColor = vec4(outputCol, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3yDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 63, 108, 139, 446], [448, 448, 505, 505, 3836]], "test": "untested"}
{"id": "sd3yD8", "name": "Toni Reactor", "author": "Kali", "description": "to expose the api for a vj set by Tony Leys", "tags": ["tonidisk"], "likes": 11, "viewed": 469, "published": 3, "date": "1653368372", "time_retrieved": "2024-07-30T16:47:22.319213", "image_code": "#define time iTime\n#define resolution iResolution\n\nfloat s;\n\nmat2 rot(float a) {\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\nfloat t;\n\nvec3 fractal(vec2 p) {\n    p=vec2(abs(atan(p.x,p.y)/3.1416*sin(time*.1)*6.),length(p));\n    p.y-=tan(time*.1);\n    p.x=fract(p.x-t)+.5;\n    vec2 m=vec2(1000);\n    float ml=100.;\n    for (int i=0; i<4; i++) {\n        p=abs(p)/clamp(abs(p.x*p.y),.1,.6)-3.;\n        m = min(m, abs(p))+fract(p.x*.2+time*.5)+fract(p.y*.2+time);\n        ml=min(ml,length(p));;\n    }\n    m=exp(-1.5*m);\n    vec3 c=vec3(m.x*3.,length(m),m.y*2.)*1.;\n    //c.gb*=rot(time*2.);\n    //c=-abs(c);\n    //c=mix(c.rbb,c,.3);\n    ml=exp(-3.*ml)*3.*s;\n    c+=ml;\n    return c;\n}\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n    }\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/25.;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    s=getSound();\n    vec2 uv = -1. + 2. * fragCoord/resolution.xy;\n    vec2 puv = uv;\n    t=time*.1;\n    uv.x*=resolution.x/resolution.y;\n    uv.x*=1.-uv.y*.7;\n    uv*=1.5-s*.3;\n    //uv+=vec2(sin(t),cos(t))*.5;\n    //t*=.5+floor(length(uv)*6.)*.1;\n    t+=smoothstep(.0,.2,fract(length(uv*.5)-time*.5));\n //   uv*=1.+exp(-3*length(uv))*spectrum.x*100;\n    //uv=abs(.5-fract(uv));\n    vec3 c=fractal(uv);\n    c+=exp(-2.*length(uv))*(1.+4.*s*s);\n    c*=vec3(1.2,.9,.8);\n    texto(c, vec2(-0.35,-0.4));\n    fragColor = vec4(c, 1.0);//*mod(gl_FragCoord.y,10.)*.1;\n}\n\n\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 35.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ _ _ _ K A L I _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3yD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[61, 61, 80, 80, 149], [162, 162, 184, 184, 706], [708, 708, 727, 727, 941], [943, 943, 984, 984, 1137], [1140, 1140, 1197, 1197, 1760]], "test": "untested"}
{"id": "sd3yW8", "name": "Toni Disk", "author": "Kali", "description": "to expose the api for a vj set by Tony Leys", "tags": ["tonidisk"], "likes": 13, "viewed": 809, "published": 3, "date": "1653357994", "time_retrieved": "2024-07-30T16:47:23.345469", "image_code": "#define time iTime\n#define resolution iResolution\nfloat shard, ssoft;\n\n\nfloat t,as;\n\nvec3 fractal(vec2 p) {\n    p=vec2((atan(p.x,p.y)*3.14),length(p)*.5-1.);\n    p+=1.+as*.5;\n    p.x=fract(p.x*.1-t*.5+ssoft*.05);\n    vec2 m=vec2(1000);\n    float ml=100.;\n    for (int i=0; i<3; i++) {\n        p=abs(p)/clamp(abs(p.x*p.y),.1+floor(mod(time*.2,5.))/10.,.7)-2.;\n        m = min(m, abs(p))+fract(p.x*.5+ssoft*3.+time*.4)+fract(p.y*.5+time*.4);\n        ml=min(ml,length(p));;\n    }\n    m=exp(-2.*m);\n    vec3 c=vec3(m.x*10.,length(m*3.),m.y*5.);\n   // c=c.rgg;\n    ml=exp(-7.*ml)*2.;\n    c+=ml;\n    return c;\n}\n\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/20.;\n}\n\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 c=vec3(0.);\n    float ss=.4+abs(fract(time*.2))*.7;\n    as = getSound();\n\n    shard = ss*ss*ss;\n    ssoft = ss;\n    vec2 uv = -1. + 2. * fragCoord.xy/resolution.xy;\n    uv=floor(uv*100.)/100.;\n    t=time*.3;\n    float s=sin(time/4.);\n    uv+=vec2(sin(t),cos(t))*.3;\n    uv*=1.3+tan(ss*4.)*.1;\n    //uv.x*=1./pow(abs(s), .6)*sign(s);\n    uv.x*=resolution.x/resolution.y;\n    //uv=uv.yx;\n //   uv*=.7;\n    //t*=.5+floor(length(uv)*6)*.1;\n    t+=smoothstep(.0,.2,fract(length(uv*.5)-time*.5));\n //   uv*=1.+exp(-3*length(uv))*spectrum.x*100;\n    //uv=abs(.5-fract(uv));\n    c+=fractal(uv);\n    c+=max(0.,1.1-length(uv)*shard*5.);\n    //c=mix(c,texture(prevFrame,gl_FragCoord.xy/resolution).rgb,.8);\n    //c*=step(length(uv),3.);\n    //c*=mod(length(uv),.5)*5.;\n    texto(c, vec2(-0.35,-0.4));\n    fragColor = vec4(c, 1.0);//*mod(gl_FragCoord.y,10.)*.1;\n}\n\n", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 35.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ _ _ _ _ K A L I _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3yW8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 107, 107, 605], [607, 607, 626, 626, 799], [801, 801, 842, 842, 995], [999, 999, 1056, 1056, 1917]], "test": "untested"}
{"id": "fdcyDH", "name": "gogble", "author": "prishainabox", "description": "hi", "tags": ["raymarching"], "likes": 2, "viewed": 247, "published": 3, "date": "1653356888", "time_retrieved": "2024-07-30T16:47:24.304904", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 2;\nconst float FRESNEL_POWER = 4.5;\nconst int REF_BOUNCES = 1;\n\n//*******************************************************//\n\n// Light structs\n\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness;\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n    if (isPointLight) {\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n    return light;\n}\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    bool hasFresnel;\n    int id;\n    vec3 groundBounceClr;\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.hasFresnel = false;\n    mat.id = -1;\n    mat.groundBounceClr = vec3(0.0);\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec2 uv) {\n    \n\tvec2 fid = fract(uv); // fraction part of uv -> where in the grid\n\tfid = fid * fid * (3.0 - 2.0 * fid);\n\tvec2 id = floor(uv); // integer part of uvw -> which grid\n\t\n\t// corners of square\n\tfloat bl = random(id + vec2(0, 0));\n\tfloat br = random(id + vec2(1, 0));\n\tfloat tl = random(id + vec2(0, 1));\n\tfloat tr = random(id + vec2(1, 1));\n\t\n\t// interpolate between corner\n\tfloat b = mix(bl, br, fid.x);\n\tfloat t = mix(tl, tr, fid.x);\n\treturn mix(b, t, fid.y);\n    \n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\n\n//*******************************************************//\n\n// SDF SCENE\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res = MAX_DIST;\n    \n    // default\n    mat = defaultMaterial();\n    \n    {\n        \n        // sphere\n        float l = length(pt) - 3.0 - 0.2*cos(4.0*pt.x*pt.y+ iTime*8.0);\n        if (l < res) {\n            res = l;\n            mat.id = 3;\n            mat.amb = 0.01;\n            mat.dif = 0.5;\n            mat.spec = 10.0;\n            mat.hasFresnel = true;\n            mat.shininess = 10.0;\n            mat.ref = vec3(1.0);\n            mat.clr = vec3(0.08) * 0.05;\n        }\n        \n    }\n    \n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1;\n            mat.ref = vec3(0.0);\n            mat.hasFresnel = false;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 200 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.00005 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = light.isPointLight ? 1.0 : softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n\n    // COLORS\n    vec3 skyClr = vec3(0.45, 0.2, 0.35) * 1.5;\n    \n    // KEY LIGHT\n    Light sun = createLight(pt, false, 1.0, 10.9, normalize(vec3(10, 12.5, 3)), vec3(10, 9, 8));\n    \n    // background color\n    vec3 clr = skyClr;\n\n    // return background if too far (id is -1.0)\n    if (mat.id == -1) {// sun\n        // clr = mix(skyClr, sun.clr * 0.12, pow(max(dot(rd, sun.dir), 0.0), 50.0));\n        return clr;\n    }\n    \n    clr = mat.clr;\n    \n    // LIGHTS\n   \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor);\n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr; // sky diffuse\n\n    clr *= light * occ;\n    \n    // clr = applyFog(rd, d, clr, sun.clr * 0.1, sun.dir, skyClr);\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    Material mat;\n\n    float d = castRay(ro, rd, mat);\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    vec3 clr = calcClr(ro, rd, d, nor, mat);\n    \n    bool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n    if (mat.hasFresnel || willReflect) {\n    \n        int bounces = 1;\n        vec3 ref = vec3(0.0);\n        float fresnel = 0.5 * uclamp(pow(1.0 - dot(nor, -rd), FRESNEL_POWER));\n        \n        // if the material will reflect\n        if (willReflect) {\n            bounces = REF_BOUNCES;\n            // if reflective and doesn't have fresnel\n            if (!mat.hasFresnel) ref = mat.ref;\n            // if reflective with fresnel\n            else ref = fresnel * mat.ref;\n        } else {\n            ref = vec3(fresnel);\n        }\n        \n        // bouncing around for fresnel and reflection\n        vec3 fil = vec3(1.0);\n        if (fresnel > 0.0) {\n            for (int i = 0; i < bounces; i++) {\n                fil *= ref;\n                // to intersection point and reflect\n                ro += rd*d + nor*EPSILON*3.0;\n                rd = reflect(rd, nor);\n                // find new point\n                d = castRay(ro, rd, mat);\n                nor = calcNormal(ro + rd*d);\n                // add color\n                clr += fil * calcClr(ro, rd, d, nor, mat);\n                if (mat.id == -1) break;\n            }\n        }\n        \n    }\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime * 0.3;\n    vec2 res = iResolution.xy;\n    \n    // target\n    vec3 target = vec3(0, 0, 0);\n    // ray origin\n    vec3 ro = vec3(0, 0, 6);\n    float r = 6.0;\n    ro = vec3(r * cos(time), 0, r * sin(time));\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - res) / min(res.x, res.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            clr += render(ro, rd);\n        }\n    }    \n    \n    clr /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 423, 553, 553, 988], [1185, 1218, 1246, 1246, 1499], [1562, 1589, 1614, 1614, 1649], [1733, 1733, 1759, 1759, 1812], [1814, 1814, 1839, 1839, 1915], [1917, 1917, 1942, 1942, 2027], [2029, 2029, 2054, 2054, 2523], [2525, 2525, 2551, 2551, 3235], [3307, 3307, 3370, 3370, 3514], [3592, 3592, 3633, 3668, 4201], [4264, 4310, 4339, 4339, 4634], [4697, 4697, 4754, 4786, 5239], [5241, 5286, 5340, 5340, 5761], [5763, 5825, 5865, 5865, 6173], [6236, 6275, 6375, 6375, 6525], [6527, 6527, 6616, 6632, 7074], [7076, 7076, 7156, 7156, 8006], [8069, 8069, 8106, 8106, 9584], [9647, 9647, 9703, 9703, 9958], [9960, 9960, 10017, 10017, 10803]], "test": "untested"}
{"id": "fscyDH", "name": "Mationi - Colored Border", "author": "juanpetrik", "description": "colored border", "tags": ["coloredborder"], "likes": 4, "viewed": 338, "published": 3, "date": "1653355349", "time_retrieved": "2024-07-30T16:47:25.142664", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p1 = vec2(.01, .01);\n    vec2 p2 = vec2(.99, .99);\n    vec2 p3 = vec2(.01, .99);\n    vec2 p4 = vec2(.99, .01);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c2 = texture(iChannel0, uv + iTime/10.);\n    \n    float d1 = step(p1.x,uv.x)*step(uv.x,p4.x)*abs(uv.y-p1.y)+\n        step(uv.x,p1.x)*distance(uv,p1)+step(p4.x,uv.x)*distance(uv,p4);\n    d1 = min(step(p3.x,uv.x)*step(uv.x,p2.x)*abs(uv.y-p2.y)+\n        step(uv.x,p3.x)*distance(uv,p3)+step(p2.x,uv.x)*distance(uv,p2),d1);\n    d1 = min(step(p1.y,uv.y)*step(uv.y,p3.y)*abs(uv.x-p1.x)+\n        step(uv.y,p1.y)*distance(uv,p1)+step(p3.y,uv.y)*distance(uv,p3),d1);\n    d1 = min(step(p4.y,uv.y)*step(uv.y,p2.y)*abs(uv.x-p2.x)+\n        step(uv.y,p4.y)*distance(uv,p4)+step(p2.y,uv.y)*distance(uv,p2),d1);\n        \n    float f1 = .01 / abs(d1 + c2.r/100.);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\tfragColor = vec4(f1 * col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscyDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1006]], "test": "untested"}
{"id": "fs3yWn", "name": "2D Raymarching Mandelbrot", "author": "Fraktoler", "description": "https://en.wikipedia.org/wiki/Plotting_algorithms_for_the_Mandelbrot_set#Distance_estimates\nHold the mouse in the canvas (Outside the Mandelbrot set) to 2D raymarch from the mouse.", "tags": ["raymarching", "fractal", "mandelbrot"], "likes": 4, "viewed": 356, "published": 3, "date": "1653352228", "time_retrieved": "2024-07-30T16:47:25.941529", "image_code": "#define MAX_ITER 256.\n#define MAX_DIST 256.\n#define MIN_DIST 1.0e-3\n#define MAX_STEPS 100\n#define pi 3.14159265358979\nconst float r2 = 2.5e-3;\nconst float line_thickness = 6.0e-3;\nconst float circle_thickness = 5.0e-3;\n\nvec3 HSLtoRGB(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n    float v = c.z + c.y * min(c.z, 1. - c.z);\n    float s = v == 0. ? 0. : 2. * (1. - c.z / v);;\n\treturn v * mix(vec3(1.), rgb, s);\n}\n\nvec2 mandelbrotDE(vec2 c) {\n    vec2 z = c, dz = one;\n    float k = 0.0;\n    float r;\n    while (k < MAX_ITER) {\n        r = length(z);\n        if (r > 256.0) break;\n        dz = 2.0 * mul(z, dz) + one;\n        z = sqr(z) + c;\n        k++;\n    }\n    return vec2(k, 0.5 * log(r) * r / length(dz));\n}\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float t = clamp(dot(pa, ba) / mag2(ba), 0.0, 1.0);\n    return length(pa - t * ba);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 8.0;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col;\n\n    vec2 ro = zoom * (iMouse.xy - 0.5 * iResolution.xy) / iResolution.x;\n    vec2 rd = vec2(cos(0.2 * pi * iTime), sin(0.2 * pi * iTime));\n    float dO = 0., l;\n    vec2 p = ro;\n    bool b = false;\n    for (int n = 0; n < MAX_STEPS; n++) {\n        float DE = mandelbrotDE(p).y;\n        if (!b) {\n            l = length(uv - p);\n            b = b || (DE - circle_thickness < l && l < DE + circle_thickness);\n        }\n        p = ro + rd * (dO += DE);\n        if (dO > MAX_DIST || DE < MIN_DIST) break;\n    }\n    b = b || sdfSegment(uv, ro, p) < line_thickness;\n    if (b) fragColor = vec4(1.0);\n    else {\n        l = mag2(uv - ro);\n        if (l < r2) fragColor = vec4(0.0, 0.0, 1.0, 0.0);\n        else {\n            vec2 m = mandelbrotDE(uv);\n            if (m.x >= MAX_ITER) col = vec3(0.0);\n            else {\n                float lnd = log(m.y) * 2.0;\n                col = HSLtoRGB(vec3(mod(lnd * lnd, 360.0), 1.0, 0.5));\n                //col = vec3(0.1 * sqrt(n.x));\n            }\n            fragColor = vec4(col, 1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.)\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n normalizesqr(z) = normalize(z^2)\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n powerfv(x, z) = x^z (Complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n*/\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n//const float[] B = float[](1., .5, 1./6., 0., -1./30., 0., 1./42., 0., -1./30., 0., 5./66., 0., -691./2730., 0., 7./6.);\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 normalizesqr(in vec2 z) {\n    return one - conj(z.yx) * (z.y + z.y) / dot(z, z);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 powerfv(in float x, in vec2 z) {\n    float lnr = log(x);\n    return exp(z.x * lnr) * cis(z.y * lnr);\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(two, powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(two, powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fs3yWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 246, 246, 464], [466, 466, 493, 493, 764], [766, 766, 808, 808, 935], [937, 937, 994, 994, 2152]], "test": "untested"}
{"id": "Nd3cW8", "name": "Quadratic Circle - distance", "author": "iq", "description": "Exact distance to a shape made of four parabolic sections connected together, which can be solved analytically with a cubic equation. A bit squarer than a circle, and a lot circler than a square.", "tags": ["2d", "sdf", "quadratic"], "likes": 28, "viewed": 1603, "published": 3, "date": "1653345089", "time_retrieved": "2024-07-30T16:47:26.758344", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Distance to a shape made of four parabolic sections connected\n// together, which can be solved analytically with a cubic (unlike\n// Squircles and other similar shapes).\n//\n// This is an EXACT distance. I also provide a version (see line 48) which\n// is correct in the exterior of the shape and also in some interior parts.\n// Use the #define in lie 19 to enable. Use the mouse to to see the distances.\n//\n// List of some other 2D distances: https://www.shadertoy.com/playlist/MXdSRf\n//\n// and iquilezles.org/articles/distfunctions2d\n\n\n// Make this 1 to see the simpler but sometimes incorrect versin\n#define USE_SIMPLIFICATION 0\n\n\n#if USE_SIMPLIFICATION==0\nfloat sdQuadraticCircle( in vec2 p )\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx; // symmetries\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = a*a + c*c*c;\n    float t;\n    if( h>=0.0 )\n    {   \n        h = sqrt(h);\n        t = sign(h-a)*pow(abs(h-a),1.0/3.0) - pow(h+a,1.0/3.0);\n    }\n    else\n    {   \n        float z = sqrt(-c);\n        float v = acos(a/(c*z))/3.0;\n        t = -z*(cos(v)+sin(v)*1.732050808);\n    }\n    t *= 0.5;\n    vec2 w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w) * sign( a*a*0.5+b-1.5 );\n}\n#else\n// This version is correct everywhere except at the center of the shape\nfloat sdQuadraticCircle( in vec2 p )\n{\n    p = abs(p); if( p.y>p.x ) p=p.yx; // symmetries\n\n    float a = p.x-p.y;\n    float b = p.x+p.y;\n    float c = (2.0*b-1.0)/3.0;\n    float h = sqrt(max(a*a+c*c*c,0.0));\n    float u = pow(max(h-a,0.0),1.0/3.0);\n    float v = pow(    h+a,     1.0/3.0);\n    float t = (u-v)*0.5;\n    vec2  w = vec2(-t,t) + 0.75 - t*t - p;\n    return length(w)*sign( a*a*0.5+b-1.5 );\n}\n#endif\n\n/*\n// VERY BAD approximation, not usable\nfloat sdQuadraticCircle( in vec2 pos )\n{\n    pos = abs(pos); if( pos.y>pos.x ) pos=pos.yx;\n    float a = pos.x-pos.y; float a2 = a*a;\n    float b = pos.x+pos.y;\n    return (a2*0.5+b-1.5)/sqrt(a2+1.0)/sqrt(2.0);\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n\tvec2  p  = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2  m  = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    float px = 2.0/iResolution.y;\n    \n    const float si = 0.8;\n    \n    // distance\n    float d = sdQuadraticCircle(p/si)*si; \n    \n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-9.0*abs(d));\n\tcol *= 0.6 + 0.4*smoothstep(-0.5,0.5,cos(130.0*abs(d)));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.01-px,0.01+px,abs(d)) );\n    \n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = sdQuadraticCircle(m/si)*si; \n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n \n   \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3cW8.jpg", "access": "api", "license": "mit", "functions": [[3050, 3050, 3107, 3143, 3963]], "test": "untested"}
{"id": "fscyD8", "name": "Jumping dot", "author": "tuxifan", "description": "It's a jumping dot, jumping into the far distance!", "tags": ["simple", "sdf"], "likes": 0, "viewed": 172, "published": 3, "date": "1653342478", "time_retrieved": "2024-07-30T16:47:27.513325", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.x;\n\n    float abstime = abs(sin(iTime));\n    vec2 point = vec2(0.5, 0.1+abstime);\n    float dist = distance(uv, point);\n    if (dist > abstime/4.0) {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        fragColor = vec4(0.1+abstime, 0.0, 0.0, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscyD8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 414]], "test": "untested"}
{"id": "7stcR4", "name": "Squircle - distance", "author": "iq", "description": "Left, approximated (but incorrect) SDF to a Squircle. Right, correct SDF but brute-force and resolution dependent SDF. This is NOT a great way go blend between a circle and a square. For that use [url=https://www.shadertoy.com/view/7sdXz2]this[/url]", "tags": ["2d", "distancefield", "sdf"], "likes": 26, "viewed": 1035, "published": 3, "date": "1653338441", "time_retrieved": "2024-07-30T16:47:28.551550", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Left, incorrect SDF to a Squircle. Right, correct SDF with bisection root\n// finding. This is NOT a great way go blend between a circle and a square,\n// or that you can use https://www.shadertoy.com/view/7sdXz2\n\n// Gradient here: https://www.shadertoy.com/view/fs3yDM\n\n\nfloat sdSquircle(vec2 p, float n)\n{\n    // symmetries\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n    \n    n = 2.0/n; // note the remapping in order to match the implicit versions\n\n    float xa = 0.0, xb = 6.283185/8.0;\n    for( int i=0; i<6; i++ )\n    {\n        float x = 0.5*(xa+xb);\n        float c = cos(x);\n        float s = sin(x);\n        float cn = pow(c,n);\n        float sn = pow(s,n);\n        float y = (p.x-cn)*cn*s*s - (p.y-sn)*sn*c*c;\n\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    // compute distance\n    vec2  qa = pow(vec2(cos(xa),sin(xa)),vec2(n));\n    vec2  qb = pow(vec2(cos(xb),sin(xb)),vec2(n));\n    vec2  pa = p-qa, ba = qb-qa;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n\treturn length( pa - ba*h ) * sign(pa.x*ba.y-pa.y*ba.x);\n}\n\nfloat approx_sdSquircle(vec2 p, float n)\n{\n    // symmetries\n    p = abs(p); if( p.y>p.x ) p=p.yx;\n    \n    float w = pow(p.x,n) + pow(p.y,n);\n\n    // implicit\n    // return pow(w,1.0/n) - 1.0;\n\n    // linearlized implicit (taylor)\n    float b = 2.0*n-2.0;\n    float a = 1.0-1.0/n;\n    return (w-pow(w,a)) * inversesqrt(pow(p.x,b)+pow(p.y,b));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // normalized pixel coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    m *= 1.4;\n    \n     // animation\n    float n = 3.0 + 2.5*sin(6.283185*iTime/3.0);\n\n    // distance\n    float d = (p.y<p.x) ? sdSquircle(p, n) : \n                          approx_sdSquircle( p, n );\n    // coloring\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n\tcol *= 1.0 - exp(-8.0*abs(d));\n    col *= 0.6 + 0.4*smoothstep(-0.5,0.5,cos(90.0*abs(d)));\n    \n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n    d = (m.y<m.x) ? sdSquircle(m,n) : \n                    approx_sdSquircle(m,n);\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n    col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    col *= smoothstep( 0.005, 0.010, abs(p.y-p.x) );\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7stcR4.jpg", "access": "api", "license": "mit", "functions": [[1418, 1418, 1453, 1471, 2176], [2178, 2178, 2220, 2238, 2523], [2525, 2525, 2582, 2618, 3613]], "test": "untested"}
{"id": "wt2BWG", "name": "Bend Feedback ", "author": "Jaromir", "description": "bending feedback", "tags": ["postprocessing", "feedback", "bend"], "likes": 3, "viewed": 185, "published": 3, "date": "1653331679", "time_retrieved": "2024-07-30T16:47:29.589773", "image_code": "float hash21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx * 123.456) * .1031) ;\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n\n    vec4 col = texture(iChannel0,uv );\n\n    fragColor = col;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "mat2 rot(float a){\nreturn mat2(\n  cos(a), sin(a),\n  -sin(a), cos(a)\n  );\n}\n\nfloat hash(vec3 p) {\n    p  = fract( p*0.3183099+.1 );\n\tp *= 17.0;\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );\n}\n\nfloat noise( in vec3 x ){\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash(i+vec3(0,0,0)), \n                        hash(i+vec3(1,0,0)),f.x),\n                   mix( hash(i+vec3(0,1,0)), \n                        hash(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash(i+vec3(0,0,1)), \n                        hash(i+vec3(1,0,1)),f.x),\n                   mix( hash(i+vec3(0,1,1)), \n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n\nfloat fbm(vec3 p){\n\n  float amp = 1.;\n  float n = 0.;\n  for(int i = 0; i < 8; i++){\n    p*=2.;\n    amp*=0.5;\n    n+=noise(p)*amp;\n  }\n    \n  return n*n;\n}\n\nvec3 warp(vec3 p){\n  float t = iTime*0.01; \n    \n  vec3 q = vec3(\n      fbm(p + vec3(t,0.0,0.0)),\n      fbm(p + vec3(1.1,t*1.1,2.5)),\n      fbm(p + vec3(3.7,2.2,t*1.23))\n      );\n\n  \n  vec3 r = vec3(\n      fbm(q + vec3(0.0,0.0,t*1.123)),\n      fbm(q + vec3(1.1,t*1.321,2.5)),\n      fbm(q + vec3(t*1.65,2.2,1.5))\n      );\n\n  float n = fbm(p+r*4.);  \n  n*=5.;\n  n-=1.6;\n  n= max(0.,n);\n  \n  q*=2.;\n  r*=2.;\n  vec3 col = mix(vec3(0.),vec3(1.,0.,0.),vec3(q.x))*2.;\n  \t   col+= mix(vec3(0.),vec3(.9,.7,0.),vec3(q.x-r.y));\n  \t   col+= mix(vec3(0.),vec3(0.,0.,1.),vec3(q.x-r.x));\n    \n  return vec3(n*n);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 oUv = fragCoord/iResolution.xy;\n    vec2 uv = (fragCoord.xy*2.-iResolution.xy)/iResolution.y;\n    \n    float scale = 1.;\n    \n    vec3 p = vec3(uv*scale,iTime*0.05);\n            \n    vec4 toBendFx = vec4(warp(p),1.);\n    //vec4 toBendFx = texture(iChannel1,oUv); //britney\n\n    float ang = atan(uv.y,uv.x);\n    float line = uv.y;\n    vec2 bend = vec2(cos(ang),line);\n\tbend*=-1.;\n    \n    vec2 texPos = oUv;\n    vec2 push = vec2(1.)/iResolution.xy;\n    push*=vec2(2.5,5.);\n    \n    texPos+=bend*push;\n    \n    vec4 tIn = texture(iChannel0,texPos)-toBendFx;   \n\n    float fb = 0.95;\n    vec4 cOut = toBendFx + ((tIn*fb));\n        \n    fragColor = cOut - vec4(0.001);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2BWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 150], [154, 154, 211, 211, 316]], "test": "untested"}
{"id": "NstczN", "name": "TL // Lights and particles", "author": "fpiaggio", "description": "TEst", "tags": ["tlparticulasluces"], "likes": 6, "viewed": 454, "published": 3, "date": "1653322723", "time_retrieved": "2024-07-30T16:47:30.427534", "image_code": "// Just for testing with virtualDJ visuals feature\n\n#define TWO_PI 3.283185\n#define NUMBALLS 60.0\nfloat d = -TWO_PI;\nfloat drawfalopa(float x,float y,float fx,float fy,float sx,float sy,float t){ \n   x*=(x+sin(y*sin(iTime*0.)*32.0)*0.1);\n   float xx=x+sin(t*fx*(1.0+sin(iTime*4.5)*0.0002))*sx+sin(iTime*5.5)*0.5;\n   float yy=y+cos(t*fy*(1.0+cos(iTime*4.75)*0.0002))*sy;\n   return (sin(iTime*4.0)*0.5+1.0)/sqrt(xx*xx+yy*yy);\n}\nvoid texto(inout vec3 col, vec2 offset) {\n    vec2 uv=gl_FragCoord.xy/iResolution.xy;\n    uv.y=1.-uv.y;\n    vec4 tx = texture(iChannel1, uv+offset);\n    col = mix(col, tx.rgb, length(tx.rgb));\n}\nfloat getSound() \n{\n    float s=0.;\n    for (float i=0.; i<20.; i++) {\n        s+=texture(iChannel0,vec2(0.,i/20.)).r;\n        s+=texture(iChannel0,vec2(i/20.,0.)).r;\n    }\n    return s/25.;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    vec2 p=uv*6.;\n   \n   float x=p.x;\n   float y=p.y;\n\n   float r = drawfalopa(x,y,3.3,2.9,10.3,0.3,iTime * 0.05);\n   r=r+drawfalopa(x,y,1.9,2.0,0.4,0.4,iTime);\n   float g = drawfalopa(x,y,1.2,1.9,4.3,0.3,iTime * 0.1);\n   float b = drawfalopa(x,y,1.7,0.3,2.3,0.3,iTime * 0.3);\n   b=b+drawfalopa(x,y,2.2,1.7,2.6,0.3,iTime);\n   b=b+drawfalopa(x,y,0.3,0.2,0.2,0.2,iTime);\n   \n   \n   vec3 c = vec3(0);\n    float a1 = 4.0 ; // 3 \n    float a2 = 4. + sin(iTime * 0.5) + getSound() * 0.2; // 4 \n\tfor(float i = 1.0; i < NUMBALLS; i++) {\n\t\tfloat t = TWO_PI * i/NUMBALLS + sin(iTime*0.25);\n\t\tfloat x = cos(a1 * t + d);\n\t\tfloat y = sin(a2 * t + d);\n\t\tvec2 q = .4 * vec2(x, y);\n\t\tc += 0.004/distance(uv, q) * vec3(0.8 * abs(x), 0, abs(y));\n\t}\n\n    vec3 col = vec3(r,g,b);\n    col += getSound() * 0.8;\n    \n    col *= mix(col, c, 1.); // probar c al final\n    // texto(col, vec2(-0.42,-0.42));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \n//  \n//   \n// https://youtu.be/dQw4w9WgXcQ\n\n// compare algorithm performance, comment out line below to see previous performance:\n#define ANOTHER_ALGORITHM      // runs slower on ARM, so comment this out if mobile phone performance is priority\n\nvec2 uv;\n\n#define time iTime\n#define resolution iResolution\n\nconst vec2 ch_size  = vec2(1.0, 2.0) * 0.6;              // character size (X,Y)\nconst vec2 ch_space = ch_size + vec2(1.5, 1.0);    // character distance Vector(X,Y)\nconst vec2 ch_start = vec2 (ch_space.x * -5., 1.); // start position\n      vec2 ch_pos   = vec2 (0.0, 0.0);             // character position(X,Y)\n//      vec3 ch_color = vec3 (1.5, 0.75, 0.5);        // character color (R,G,B)\n//const vec3 bg_color = vec3 (0.2, 0.2, 0.2);        // background color (R,G,B)\n\n#define REPEAT_SIGN false // True/False; True=Multiple, False=Single\n\n/* 16 segment display...Akin to LED Display.\n\nSegment bit positions:\n  __2__ __1__\n |\\    |    /|\n | \\   |   / |\n 3  11 10 9  0\n |   \\ | /   |\n |    \\|/    |\n  _12__ __8__\n |           |\n |    /|\\    |\n 4   / | \\   7\n | 13 14  15 |\n | /   |   \\ |\n  __5__|__6__\n\n15 12 11 8 7  4 3  0\n |  | |  | |  | |  |\n 0000 0000 0000 0000\n\nexample: letter A\n\n   12    8 7  4 3210\n    |    | |  | ||||\n 0001 0001 1001 1111\n\n binary to hex -> 0x119F\n*/\n\n// split 16 Bit int into two 8 Bit int for mobile phones with ridiculous 1-byte int\n#define n0 ddigit(0x22,0xFF);\n#define n1 ddigit(0x02,0x81);\n#define n2 ddigit(0x11,0x77);\n#define n3 ddigit(0x11,0xE7);\n#define n4 ddigit(0x55,0x08);\n#define n5 ddigit(0x11,0xEE);\n#define n6 ddigit(0x11,0xFE);\n#define n7 ddigit(0x22,0x06);\n#define n8 ddigit(0x11,0xFF);\n#define n9 ddigit(0x11,0xEF);\n\n#define A ddigit(0x11,0x9F);\n#define B ddigit(0x92,0x7E);\n#define C ddigit(0x00,0x7E);\n#define D ddigit(0x44,0xE7);\n#define E ddigit(0x10,0x7E);\n#define F ddigit(0x10,0x1E);\n#define G ddigit(0x80,0x7E);\n#define H ddigit(0x11,0x99);\n#define I ddigit(0x44,0x66);\n#define J ddigit(0x44,0x36);\n#define K ddigit(0x92,0x18);\n#define L ddigit(0x00,0x78);\n#define M ddigit(0x0A,0x99);\n#define N ddigit(0x88,0x99);\n#define O ddigit(0x00,0xFF);\n#define P ddigit(0x11,0x1F);\n#define Q ddigit(0x80,0xFF);\n#define R ddigit(0x91,0x1F);\n#define S ddigit(0x88,0x66);\n#define T ddigit(0x44,0x06);\n#define U ddigit(0x00,0xF9);\n#define u ddigit(0x00,0xF0);\n#define V ddigit(0x22,0x18);\n#define W ddigit(0xA0,0x99);\n#define w ddigit(0xA0,0x90);\n#define X ddigit(0xAA,0x00);\n#define Y ddigit(0x4A,0x00);\n#define Z ddigit(0x22,0x66);\n#define _ ch_pos.x += ch_space.x;\n#define s_dot     ddigit(0,0);\n#define s_minus   ddigit(0x11,0x00);\n#define s_plus    ddigit(0x55,0x00);\n#define s_greater ddigit(0x28,0x00);\n#define s_less    ddigit(0x82,0x00);\n#define s_sqrt    ddigit(0x0C,0x02);\n#define s_sw      ddigit(0x55,0xAA);\n#define s_pow     ddigit(0x02,0x01);\n#define upper_u   ddigit(0x11,0x09);\n#define s_bra    ddigit(0x00,0x3C);\n#define s_ket    ddigit(0x00,0xC3);\n#define s_quotl    ddigit(0x04,0x01);\n#define s_quotr    ddigit(0x04,0x08);\n#define s_degrees    ddigit(0x05,0x03);\n#define s_ast    ddigit(0xFF,0x00);\n#define s_question ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x41,0x07);\n#define s_exclam   ch_pos-=vec2(-.45,.4); ddigit(0,0); ch_pos+=vec2(-ch_space.x-.45,.4); ddigit(0x44,0x00);\n#define s_comma   ch_pos-=vec2(.45); ddigit(0x20,0x00); ch_pos+=vec2(.45);\n#define nl1 ch_pos = ch_start;  ch_pos.y -= 3.0;\n#define nl2 ch_pos = ch_start;  ch_pos.y -= 6.0;\n#define nl3 ch_pos = ch_start;\tch_pos.y -= 9.0;\n\n#ifdef ANOTHER_ALGORITHM\nfloat dseg1(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x-(uv.y*.5-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\nfloat dseg2(vec2 p0, vec2 p1)\n{\n\tvec2 cp = vec2(uv.x+(uv.y*.5-.9-ch_pos.y*.5-p0.y), uv.y) - ch_pos - p0;\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n#else\nfloat dseg(vec2 p0, vec2 p1)\n{\n\tvec2 dir = normalize(p1 - p0);\n\tvec2 cp = (uv - ch_pos - p0) * mat2(dir.x, dir.y,-dir.y, dir.x);\n\treturn distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n}\n#endif\nfloat dsegH(vec2 p0, vec2 p1) // avoiding matric ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(distance(p0, p1), 0)));\n\treturn distance(cp, vec2(clamp(cp.x, 0., p1.x-p0.x), 0.) );\n}\nfloat dsegV(vec2 p0, vec2 p1) // avoiding matrix ops\n{\n\tvec2 cp = uv - ch_pos - p0;\n\t//return distance(cp, clamp(cp, vec2(0), vec2(0, distance(p0, p1))));\n\treturn distance(cp, vec2(0., clamp(cp.y, 0., p1.y-p0.y)) );\n}\n\nbool bit(int n)\n{\n\treturn (n/2)*2 != n;\n}\n\nfloat d = 1e6;\n\n#ifdef ANOTHER_ALGORITHM\t\t// Intel skylake GPU seems to prefer this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n\tvec2 cp = uv - ch_pos;\n\t// better performance in this order, on Intel Iris 550 skylake  (WHY does order matter??)\n\tif (n == 0 && nn==0)     v = min(v, dsegH(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/4)) v = min(v, dsegH(vec2( -0.438,  1.000), vec2(-0.063, 1.000)));\n\tif (bit(nn/2)) v = min(v, dsegH(vec2(0.063,  1.000), vec2(0.438,  1.000)));\n\tif (bit(nn/32)) v = min(v, dsegH(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dsegH(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(n/1)) v = min(v, dsegH(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/16)) v = min(v, dsegH(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(nn/1)) v = min(v, dsegV(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/128)) v = min(v, dsegV(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/4)) v = min(v, dsegV(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/64)) v = min(v, dsegV(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(nn/8)) v = min(v, dsegV(vec2(-0.500,  0.063), vec2(-0.500,  0.937)));\n\tif (bit(nn/16)) v = min(v, dsegV(vec2(-0.500, -0.938), vec2(-0.500, -0.063)));\n\t// matrix ops last\n\tif (bit(n/2)) v = min(v, dseg1(vec2( 0.063,  0.063), vec2( 0.063,  0.938)));\n\tif (bit(n/8)) v = min(v, dseg2(vec2(-0.963,  0.063), vec2(-1.338,  0.938)));\n\tif (bit(n/32)) v = min(v, dseg1(vec2(-0.963, -0.938), vec2(-0.963, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg2(vec2( 0.063, -0.938), vec2( 0.063, -0.063)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#else\t\t// some GPU's may run faster with this\nvoid ddigit(int n, int nn)\n{\n\tfloat v = 1e6;\n    vec2 cp = uv - ch_pos;\n    if (n == 0 && nn == 0)     v = min(v, dseg(vec2(-0.405, -1.000), vec2(-0.500, -1.000)));\n\tif (bit(nn/1)) v = min(v, dseg(vec2( 0.500,  0.063), vec2( 0.500,  0.937)));\n\tif (bit(nn/2)) v = min(v, dseg(vec2( 0.438,  1.000), vec2( 0.063,  1.000)));\n\tif (bit(nn/4)) v = min(v, dseg(vec2(-0.063,  1.000), vec2(-0.438,  1.000)));\n\tif (bit(nn/8)) v = min(v, dseg(vec2(-0.500,  0.937), vec2(-0.500,  0.062)));\n\tif (bit(nn/16)) v = min(v, dseg(vec2(-0.500, -0.063), vec2(-0.500, -0.938)));\n\tif (bit(nn/32)) v = min(v, dseg(vec2(-0.438, -1.000), vec2(-0.063, -1.000)));\n\tif (bit(nn/64)) v = min(v, dseg(vec2( 0.063, -1.000), vec2( 0.438, -1.000)));\n\tif (bit(nn/128)) v = min(v, dseg(vec2( 0.500, -0.938), vec2( 0.500, -0.063)));\n\tif (bit(n/1)) v = min(v, dseg(vec2( 0.063,  0.000), vec2( 0.438, -0.000)));\n\tif (bit(n/2)) v = min(v, dseg(vec2( 0.063,  0.063), vec2( 0.438,  0.938)));\n\tif (bit(n/4)) v = min(v, dseg(vec2( 0.000,  0.063), vec2( 0.000,  0.937)));\n\tif (bit(n/8)) v = min(v, dseg(vec2(-0.063,  0.063), vec2(-0.438,  0.938)));\n\tif (bit(n/16)) v = min(v, dseg(vec2(-0.438,  0.000), vec2(-0.063, -0.000)));\n\tif (bit(n/32)) v = min(v, dseg(vec2(-0.063, -0.063), vec2(-0.438, -0.938)));\n\tif (bit(n/64)) v = min(v, dseg(vec2( 0.000, -0.938), vec2( 0.000, -0.063)));\n\tif (bit(n/128)) v = min(v, dseg(vec2( 0.063, -0.063), vec2( 0.438, -0.938)));\n\tch_pos.x += ch_space.x;\n\td = min(d, v);\n}\n#endif\n\nmat2 rotate(float a)\n{\n\tfloat c = cos(a);\n\tfloat s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\nvec3 hsv2rgb_smooth( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\n\tvec2 aspect = resolution.xy / resolution.y;\n\tuv = ( gl_FragCoord.xy / resolution.y ) - aspect / 2.0;\n    uv *= 2.5;\n\tfloat _d =  1.0-length(uv);\n\tuv *= 24.0 ;\n\tuv -= vec2(-10., 4.);\n    //uv *= rotate(time+uv.x*0.05);\n\n\tuv.x+=3. + sin(uv.y*1.5+time*3.)*.15;\n\tch_pos = ch_start;\n\n\t\t\tnl2\n\t   \t\t_ _ _ _ _ _ F P I A G G I O _ _ _ _ _\n    float a = smoothstep(0.4,0.2,d);\n    float b = smoothstep(0.5,0.4,d) * .8;\n  \tvec3 ch_color = hsv2rgb_smooth(vec3(time*0.4+uv.y*0.1,0.5,1.0));\n    vec3 col=ch_color*a;\n    fragColor = vec4(col, max(a,b));\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NstczN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 195, 195, 425], [426, 426, 467, 467, 620], [621, 621, 640, 640, 813], [814, 814, 871, 871, 1852]], "test": "untested"}
{"id": "ssdyWn", "name": "Wang corner tiling", "author": "me_123", "description": "2d corner wang tiles. 16 states.", "tags": ["2d", "infinite", "tiles", "wang", "corner"], "likes": 6, "viewed": 254, "published": 3, "date": "1653320281", "time_retrieved": "2024-07-30T16:47:31.242356", "image_code": "const bool debug = false;\n\nfloat aa = 40.;\nconst vec3 color0 = vec3(0.25, 0.45, 1.0)*0.75;\nconst vec3 color1 = vec3(0.25, 0.8, 0.25);\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nvec4 s0(in vec2 p) {\n    vec3 color = color0;\n    return vec4(color, 1.0);\n}\nvec4 s1(in vec2 p) {\n    float d = abs(length(p-0.5)-0.5)-0.1;\n    vec3 color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), vec3(length(p-0.5)-0.5<0.0?color1:color0), clamp(d*aa, 0.0, 1.0)), clamp((abs(d)-0.025)*aa, 0.0, 1.0));\n    return vec4(color, d);\n}\nvec4 s2(in vec2 p) {\n    return s1(vec2(p.x, -p.y));\n}\nvec4 s3(in vec2 p) {\n    float d = abs(p.x)-0.1;\n    vec3 color = mix(vec3(0),mix(vec3(0.6,0.3,0.0),p.x>0.0?color1:color0,clamp(d*aa,0.0,1.0)),clamp((abs(d)-0.025)*aa,0.0,1.0));\n    return vec4(color, d);\n}\nvec4 s4(in vec2 p) {\n    return s1(vec2(-p.x, -p.y));\n}\nvec4 s10(in vec2 p) {\n    float d = abs(p.y)-0.1;\n    float d1 = abs(p.x)-0.1;\n    bool g = p.x<0.0 && p.y<0.0 || p.x > 0. && p.y > 0.0;\n    vec3 c = g?color0:color1;\n    vec3 color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), c, clamp(d*aa, 0.0, 1.0)), clamp((abs(d)-0.025)*aa, 0.0, 1.0));\n    color = mix(vec3(0), color, clamp(length(p*vec2(0.6, 1.0))*4., 0.0, 1.0));\n    color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), color, clamp(d1*aa, 0.0, 1.0)), clamp((abs(d1)-0.025)*aa, 0.0, 1.0));\n    return vec4(color, min(d, d1));\n}\nvec4 s6(in vec2 p) {\n    return s3(vec2(-p.y, p.x));\n}\nvec4 s8(in vec2 p) {\n    return s1(vec2(-p.x, p.y));\n}\nvec4 s5(in vec2 p) {\n    float d = abs(p.x)-0.1;\n    float d1 = abs(p.y)-0.1;\n    bool g = !(p.x<0.0 && p.y<0.0 || p.x > 0. && p.y > 0.0);\n    vec3 c = g?color0:color1;\n    vec3 color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), c, clamp(d*aa, 0.0, 1.0)), clamp((abs(d)-0.025)*aa, 0.0, 1.0));\n    color = mix(vec3(0), color, clamp(length(p*vec2(0.6, 1.0))*4., 0.0, 1.0));\n    color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), color, clamp(d1*aa, 0.0, 1.0)), clamp((abs(d1)-0.025)*aa, 0.0, 1.0));\n    return vec4(color, min(d, d1));\n}\nvec4 s14(in vec2 p) {\n    float d = abs(length(p-0.5)-0.5)-0.1;\n    vec3 color = mix(vec3(0), mix(vec3(0.6, 0.3, 0.0), vec3(length(p-0.5)-0.5<0.0?color0:color1), clamp(d*aa, 0.0, 1.0)), clamp((abs(d)-0.025)*aa, 0.0, 1.0));\n    return vec4(color, d);\n}\nvec4 s7(in vec2 p) {\n    return s14(vec2(-p.x, p.y));\n}\nvec4 s11(in vec2 p) {\n    return s14(vec2(-p.x, -p.y));\n}\nvec4 s9(in vec2 p) {\n    return s6(vec2(p.x, -p.y));\n}\nvec4 s12(in vec2 p) {\n    return s3(vec2(-p.x, p.y));\n}\nvec4 s13(in vec2 p) {\n    return s14(vec2(-p.y, p.x));\n}\nvec4 s15(in vec2 p) {\n    return vec4(color1, 1.0);\n}\nvec4 bits(in vec2 p, in int state) {\n    float c = 0.0;\n    if(p.x>0.0){\n        if (p.y>0.0)c=float(state&1);\n        if (p.y<0.0)c=float(state&2);\n    }\n    if (p.x<0.0){\n        if (p.y<0.0)c=float(state&4);\n        if (p.y>0.0)c=float(state&8);\n    }\n    return vec4(c>0.0?float(state)/15.:0.0);\n}\nvec4 state(in vec2 p, in int s) {\n    if(s==0)return s0(p);\n    if(s==1)return s1(p);\n    if(s==2)return s2(p);\n    if(s==3)return s3(p);\n    if(s==4)return s4(p);\n    if(s==5)return s5(p);\n    if(s==6)return s6(p);\n    if(s==7)return s7(p);\n    if(s==8)return s8(p);\n    if(s==9)return s9(p);\n    if(s==10)return s10(p);\n    if(s==11)return s11(p);\n    if(s==12)return s12(p);\n    if(s==13)return s13(p);\n    if(s==14)return s14(p);\n    if(s==15)return s15(p);\n}\nfloat hash21(vec2 p){return fract(sin(dot(p*0.001,vec2(27.609,57.583)))*43758.5453);}\nfloat noise(in vec2 p) {\n    vec2 f = floor(p);\n    vec2 fr = fract(p);\n    return mix(mix(hash21(f), hash21(f+vec2(1, 0)), fr.x),mix(hash21(f+vec2(0, 1)), hash21(f+vec2(1, 1)), fr.x), fr.y);\n}\nint random(in ivec2 p) {\n    int r = int(hash21(vec2(p))*16.);\n    return r;\n}\nint get(in ivec2 p) {\n    int l = random(p+ivec2(1, 0));\n    int r = random(p+ivec2(-1, 0));\n    int s = int((l&8)>0)<<0|int((r&1)>0)<<3|int((r&2)>0)<<2|int((l&4)>0)<<1;\n    return s;\n}\n\nint get1(in ivec2 p) {\n    int l = random(p+ivec2(0, 1));\n    int r = random(p+ivec2(0, -1));\n    int s = int((r&1) > 0)<<1|int((r&8) > 0)<<2|int((l&2) > 0)<<0|int((l&4) > 0)<<3;\n    return s;\n}\nint get3(in ivec2 p) {\n    return int((random(p+ivec2(1, 1))&4) > 0)<<0|int((random(p+ivec2(1, -1))&8) > 0)<<1|int((random(p+ivec2(-1, -1))&1) > 0)<<2|int((random(p+ivec2(-1, 1))&2)>0)<<3;\n}\n\nvec4 sdf(in vec2 p) {\n    ivec2 id = ivec2(floor(p));\n    p = fract(p)-0.5;\n    vec4 s = vec4(0);\n    if (!debug) {\n        if((id.x%2&id.y%2)==1)s=state(p,random(id));\n        if(((id.x+1)%2&(id.y)%2)==1)s=state(p,get(id));\n        if(((id.x)%2&(id .y+1)%2)==1)s=state(p,get1(id));\n        if(((id.x+1)%2&(id.y+1)%2)==1)s=state(p,get3(id));\n    } else {\n        if((id.x%2&id.y%2)==1)s=bits(p,random(id))*vec4(0,1,0,0);\n        if(((id.x+1)%2&(id.y)%2)==1)s=bits(p,get(id))*vec4(1,0,0,0);\n        if(((id.x)%2&(id .y+1)%2)==1)s=bits(p,get1(id))*vec4(0,0,1,0);\n        if(((id.x+1)%2&(id.y+1)%2)==1)s=bits(p,get3(id))*vec4(1,1,0,0);\n        s.xyz = mix(vec3(1), s.xyz, clamp(aa*(min(abs(p.x+0.5), abs(p.y+0.5))-0.05), 0.0, 1.0));\n    }\n        \n    return s;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aa = iResolution.y*0.15;\n    vec2 uv = (fragCoord.xy/iResolution.xy)-0.5;\n    uv.x += iTime*0.1;\n    uv.y += iTime*0.05;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 10.;\n    fragColor = vec4(sdf(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssdyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 171, 171, 251], [252, 252, 272, 272, 328], [329, 329, 349, 349, 579], [580, 580, 600, 600, 634], [635, 635, 655, 655, 841], [842, 842, 862, 862, 897], [898, 898, 919, 919, 1420], [1421, 1421, 1441, 1441, 1475], [1476, 1476, 1496, 1496, 1530], [1531, 1531, 1551, 1551, 2055], [2056, 2056, 2077, 2077, 2307], [2308, 2308, 2328, 2328, 2363], [2364, 2364, 2385, 2385, 2421], [2422, 2422, 2442, 2442, 2476], [2477, 2477, 2498, 2498, 2532], [2533, 2533, 2554, 2554, 2589], [2590, 2590, 2611, 2611, 2643], [2644, 2644, 2680, 2680, 2945], [2946, 2946, 2979, 2979, 3409], [3410, 3410, 3431, 3431, 3495], [3496, 3496, 3520, 3520, 3689], [3690, 3690, 3714, 3714, 3768], [3769, 3769, 3790, 3790, 3954], [3956, 3956, 3978, 3978, 4150], [4151, 4151, 4173, 4173, 4341], [4343, 4343, 4364, 4364, 5103], [5104, 5104, 5161, 5161, 5375]], "test": "untested"}
{"id": "NddcDr", "name": "Bracketing", "author": "huwb", "description": "Maps a texture to a plane using any arbitrary 2D vector field to give orientation. Places no constraints/requirements on vector field at all. Downside is lots of blending of samples. Right side naively computes tangent frame directly from vector field.", "tags": ["uv", "mapping", "interpolation"], "likes": 66, "viewed": 2051, "published": 3, "date": "1653318376", "time_retrieved": "2024-07-30T16:47:32.186830", "image_code": "// 'Bracketing' technique maps a texture to a plane using any arbitrary 2D vector field to give orientation\n// Copyright Huw Bowles May 2022\n// MIT license\n\n// Explanation: https://twitter.com/hdb1/status/1528761299701841921\n\n// A problem I've had working on water systems is having waves travel in arbitrary directions on a 2D plane, for example to align to\n// shorelines. While one can create a custom UV mapping that tracks a shoreline, this can easily break down if shoreline is non trivial\n// shape (high curvature, concave, small islands very close to shore). What we ideally want is to be able to map a texture onto\n// any arbitrary vector field, for example a vector to nearest coastline position.\n\n// A brute force approach would simply construct a UV coordinate frame directly from the vector field and use this to calculate\n// UVs, which is shown in the right pane). Unfortunately this breaks down badly. The problem is that the UVs vary\n// wildly across pixels and feeding these UVs directly as input to a function like texture sampling creates crazy high frequencies\n// and distortions in the function output.\n\n// Instead of feeding in wild varying UV input into the function, we snap the vector field direction to a set of canonical directions\n// (for example every 15 degrees), evaluate the function at the snapped angle and the other nearby snapped angle, and then\n// blend the outputs of the function based on the angle. So the function does it's thing on stable inputs, and we blend the outputs.\n// To make this snapping obvious, set AngleDelta below to PI/5.0 and inspect the vector field which blends directions using this\n// approach.\n\n// The result tends to be very robust. The vector field I use below from iChannel1 is very bad quality, see the left side of the screen.\n// Click the mouse to apply a circular vector field which is high quality, but exhibits extreme distortion without our bracketing method\n// (again compare with left hand side).\n\n// Blending artifacts are visible, and result is blurred. There are ways to combat this blurring such as histogram. But if the function\n// is animated the blending may not be noticeable at all. This approach has been very effective in the Crest Ocean System.\n\n// The worst remaining issues are where the vector field is divergent - when nearby directions vary strongly such as a sink/source. This\n// can potentially be masked out (enable MaskOutDivergence) or an extra sample can re-add in using a given frame which can work (enable\n// ReplaceDivergence).\n\n// As a final bonus, one can animate the UVs to create a \"flow\" effect as shown here. However this only supports flow which has a fixed\n// global speed rather than varying flow speeds. The flow technique could be applied on top of this.\n\n\n// Defined in Common tab\n//const float PI = 3.141592654;\n\nconst float RightPaneSize = 0.3;\nconst bool ShowVectorField = true;\nconst bool ShowBruteForceMethod = true;\nconst bool ColouriseSamples = false;\n\n// In diverging areas, take one more sample to get \"something\". For waves, blending in this additional sample\n// in the wind direction works well.\nconst bool ReplaceDivergence = true;\nconst bool MaskOutDivergence = false;\n\nconst float UVSpeedTexture = 1.0 / 160.0;\nconst float UVSpeedVectorField = 1.0 / 2000.0;\n\n// Parameter for bracketing - bracket size in radians. Large values create noticeable linear structure,\n// small values prone to simply replicating the issues with the brute force approach. In my use cases it\n// was quick and easy to find a sweet spot.\nconst float AngleDelta = PI / 20.0;\nconst mat2x2 RotateByAngleDelta = mat2x2(cos(AngleDelta), sin(AngleDelta), -sin(AngleDelta), cos(AngleDelta));\n\nvec2 CalculateUV(vec2 vAxis, vec2 position)\n{\n    vec2 uAxis = vec2(-vAxis.y, vAxis.x);\n    vec2 uv = vec2( dot(position, uAxis), dot(position, vAxis) );\n    // Animate\n    uv.y -= iTime * UVSpeedTexture;\n    return uv;\n}\n\n// This should return the normal to the field, which the texture will orient to.\n// This can be a normalized vector, but does not need to be. This shader\n// uses the length of the normal to mask out divergences. This is a mechanism\n// to hint that there is a divergence.\nvec2 Normal(vec2 position)\n{\n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    \n    if (iMouse.z > 0.0)\n    {\n        vec2 uvMouse = aspect * iMouse.xy / iResolution.xy;\n        return position - uvMouse;\n    }\n    else\n    {\n        // Sample normal from texture 1. This gives a very bad quality vector field, which\n        // helps to demonstrate the robustness of this technique.\n        vec2 posScaled = position / 8.0 + vec2(0.4, 0.5);\n        posScaled -= (iTime+35.0) * vec2(1.0, 1.33) * UVSpeedVectorField;\n        float lodBias = 4.0;\n        float v = textureLod(iChannel1, posScaled, lodBias).x;;\n        vec2 dx_0 = vec2(0.2, 0.0);\n        float v_x = textureLod(iChannel1, posScaled + dx_0.xy, lodBias).x;;\n        float v_y = textureLod(iChannel1, posScaled + dx_0.yx, lodBias).x;;\n        vec2 normal = vec2(v_x, v_y) - v;\n        \n        // If we don't normalize, the grad vector will go to 0 at divergent points.\n        // This term can be used as a mask.\n        if(!MaskOutDivergence && !ReplaceDivergence)\n        {\n            normal = normalize(normal);\n        }\n        return normal;\n    }\n}\n\n// This is whatever 2D function we want to map on the plane, such as sampling a texture\nvec4 Function(vec2 uv)\n{\n    return textureLod(iChannel0, uv, 1.0);\n}\n\n// Vector field direction is used to drive UV coordinate frame, but instead\n// of directly taking the vector directly, take two samples of the texture\n// using coordinate frames at snapped angles, and then blend them based on\n// the angle of the original vector.\nvoid Bracketing(vec2 normal, out vec2 vAxis0, out vec2 vAxis1, out float blendAlpha)\n{\n    // Heading angle of the original vector field direction\n    float angle = atan(normal.y, normal.x) + 2.0*PI;\n\n    // Snap to a first canonical direction by subtracting fractional angle\n    float fractional = mod(angle, AngleDelta);\n    float angle0 = angle - fractional;\n    \n    // Compute one V axis of UV frame. Given angle0 is snapped, this could come from LUT, but would\n    // need testing on target platform to verify that a LUT is faster.\n    vAxis0 = vec2(cos(angle0), sin(angle0));\n\n    // Compute the next V axis by rotating by the snap angle size\n    vAxis1 = RotateByAngleDelta * vAxis0;\n\n    // Blend to get final result, based on how close the vector was to the first snapped angle\n    blendAlpha = fractional / AngleDelta;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 aspect = vec2( iResolution.x / iResolution.y, 1.0 );\n    \n    vec2 uvPixel = aspect * fragCoord / iResolution.xy;\n    \n    // Normal is vector field direction, used to create UV coordinate frame\n    vec2 normal = Normal(uvPixel);\n    \n    // Demo things\n    float tNormalised = fract(iTime / 6.0);\n    bool vectorFieldOn = ShowVectorField && tNormalised > 0.5; // fragCoord.y/iResolution.y<0.3\n    bool bruteForceMethod = ShowBruteForceMethod && fragCoord.x/iResolution.x>(1.0-RightPaneSize);\n    \n    float uvScale = 4.0;\n    // Blur a bit to see vector field easier\n    //float lodBias = vectorFieldOn ? 3.0 : 1.0;\n\n    if (!bruteForceMethod)\n    {\n        ////////////////// Technique for texturing using UVs from vector field starts here! //////////////////\n        \n        vec2 vAxis0, vAxis1;\n        float blendAlpha;\n        Bracketing(normal, vAxis0, vAxis1, blendAlpha);\n        \n        // Compute the function for the two canonical directions\n        vec2 uv0 = uvScale * CalculateUV(vAxis0, uvPixel);\n        vec2 uv1 = uvScale * CalculateUV(vAxis1, uvPixel);\n        \n        // Now sample function/texture\n        vec4 sample0 = Function(uv0);\n        vec4 sample1 = Function(uv1);\n        \n        if (ColouriseSamples)\n        {\n            sample0.xy *= 0.5;\n            sample1.yz *= 0.5;\n        }\n        \n        // Blend to get final result, based on how close the vector was to the first snapped angle\n        fragColor = mix( sample0, sample1, blendAlpha );\n        \n        ////////////////// Technique for texturing using UVs from vector field ends here! //////////////////\n    }\n    else\n    {\n        fragColor = Function(uvScale * CalculateUV(normalize(normal), uvPixel));\n    }\n    \n    // Moar visualisation - colourise background based on vector field\n    if( false )\n    {\n        fragColor = vec4(0.5 + 0.35 * normalize(normal), 0.5, 1.0);\n    }\n    \n    if (!bruteForceMethod)\n    {\n    \n        // Apply patch\n        if (ReplaceDivergence)\n        {\n            float strength = smoothstep(0.0, 0.2, length(normal)*3.0);\n            vec2 arbitraryDirection = -vec2(cos(0.5),sin(0.5));\n            fragColor = mix(Function(uvScale * CalculateUV(arbitraryDirection, uvPixel)), fragColor, strength);\n        }\n        else if (MaskOutDivergence)\n        {\n            fragColor = mix(vec4(0.0, 1.0, 0.0, 1.0), fragColor, smoothstep(0.0, 0.2, length(normal)*3.0)); \n        }\n    }\n    \n\n    if (ShowBruteForceMethod && abs(fragCoord.x/iResolution.x - (1.0 - RightPaneSize)) < 2.0/iResolution.x)\n    {\n        fragColor = vec4(1.0);\n    }\n\n    if( vectorFieldOn )\n    {\n#if 0\n        // Output vector field directly\n        fragColor = max(0.8*fragColor, 0.9*arrow(uvPixel*iResolution.xy/aspect, normal*70.));\n#else\n        // Blend based on bracketing to show what is being used for the UV frame\n        vec2 arrowCenterUV = arrowTileCenterCoord(uvPixel*iResolution.xy/aspect)*aspect/iResolution.xy;\n        vec2 vAxis0, vAxis1;\n        float blendAlpha;\n        vec2 normalForArrow = Normal(arrowCenterUV);\n        Bracketing(normalForArrow, vAxis0, vAxis1, blendAlpha);\n        \n        float arrowVal = mix( arrow(uvPixel*iResolution.xy/aspect, vAxis0*70.), arrow(uvPixel*iResolution.xy/aspect, vAxis1*70.), blendAlpha);\n        \n        // Boost a bit\n        arrowVal = sqrt(arrowVal);\n        \n        if(MaskOutDivergence)\n        {\n            //arrowVal *= smoothstep(0.0, 0.2, length(normalForArrow)*3.0);\n        }\n        fragColor = max(0.8*fragColor, arrowVal);\n#endif\n    }\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Shared code\n\nconst float PI = 3.141592654;\n\n// From https://www.shadertoy.com/view/4s23DG\n// Morgan McGuire, @morgan3d, http://casual-effects.com\n\nconst int   ARROW_V_STYLE = 1;\nconst int   ARROW_LINE_STYLE = 2;\n\n// Choose your arrow head style\nconst int   ARROW_STYLE = ARROW_LINE_STYLE;\nconst float ARROW_TILE_SIZE = 32.0;\n\n// How sharp should the arrow head be? Used\nconst float ARROW_HEAD_ANGLE = 45.0 * PI / 180.0;\n\n// Used for ARROW_LINE_STYLE\nconst float ARROW_HEAD_LENGTH = ARROW_TILE_SIZE / 6.0;\nconst float ARROW_SHAFT_THICKNESS = 3.0;\n\t\n\n\n// Computes the center pixel of the tile containing pixel pos\nvec2 arrowTileCenterCoord(vec2 pos) {\n\treturn (floor(pos / ARROW_TILE_SIZE) + 0.5) * ARROW_TILE_SIZE;\n}\n\n\n// v = field sampled at tileCenterCoord(p), scaled by the length\n// desired in pixels for arrows\n// Returns 1.0 where there is an arrow pixel.\nfloat arrow(vec2 p, vec2 v) {\n\t// Make everything relative to the center, which may be fractional\n\tp -= arrowTileCenterCoord(p);\n\t\t\n    float mag_v = length(v), mag_p = length(p);\n\t\n\tif (mag_v > 0.0) {\n\t\t// Non-zero velocity case\n\t\tvec2 dir_p = p / mag_p, dir_v = v / mag_v;\n\t\t\n\t\t// We can't draw arrows larger than the tile radius, so clamp magnitude.\n\t\t// Enforce a minimum length to help see direction\n\t\tmag_v = clamp(mag_v, 5.0, ARROW_TILE_SIZE / 2.0);\n\n\t\t// Arrow tip location\n\t\tv = dir_v * mag_v;\n\t\t\n\t\t// Define a 2D implicit surface so that the arrow is antialiased.\n\t\t// In each line, the left expression defines a shape and the right controls\n\t\t// how quickly it fades in or out.\n\n\t\tfloat dist;\t\t\n\t\tif (ARROW_STYLE == ARROW_LINE_STYLE) {\n\t\t\t// Signed distance from a line segment based on https://www.shadertoy.com/view/ls2GWG by \n\t\t\t// Matthias Reitinger, @mreitinger\n\t\t\t\n\t\t\t// Line arrow style\n\t\t\tdist = \n\t\t\t\tmax(\n\t\t\t\t\t// Shaft\n\t\t\t\t\tARROW_SHAFT_THICKNESS / 4.0 - \n\t\t\t\t\t\tmax(abs(dot(p, vec2(dir_v.y, -dir_v.x))), // Width\n\t\t\t\t\t\t    abs(dot(p, dir_v)) - mag_v + ARROW_HEAD_LENGTH / 2.0), // Length\n\t\t\t\t\t\t\n   \t\t\t         // Arrow head\n\t\t\t\t\t min(0.0, dot(v - p, dir_v) - cos(ARROW_HEAD_ANGLE / 2.0) * length(v - p)) * 2.0 + // Front sides\n\t\t\t\t\t min(0.0, dot(p, dir_v) + ARROW_HEAD_LENGTH - mag_v)); // Back\n\t\t} else {\n\t\t\t// V arrow style\n\t\t\tdist = min(0.0, mag_v - mag_p) * 2.0 + // length\n\t\t\t\t   min(0.0, dot(normalize(v - p), dir_v) - cos(ARROW_HEAD_ANGLE / 2.0)) * 2.0 * length(v - p) + // head sides\n\t\t\t\t   min(0.0, dot(p, dir_v) + 1.0) + // head back\n\t\t\t\t   min(0.0, cos(ARROW_HEAD_ANGLE / 2.0) - dot(normalize(v * 0.33 - p), dir_v)) * mag_v * 0.8; // cutout\n\t\t}\n\t\t\n\t\treturn clamp(1.0 + dist, 0.0, 1.0);\n\t} else {\n\t\t// Center of the pixel is always on the arrow\n\t\treturn max(0.0, 1.2 - mag_p);\n\t}\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddcDr.jpg", "access": "api", "license": "mit", "functions": [[3686, 3686, 3731, 3731, 3907], [3909, 4180, 4208, 4208, 5314], [5316, 5404, 5428, 5428, 5473], [5475, 5738, 5824, 5884, 6569], [6571, 6571, 6628, 6628, 10164]], "test": "untested"}
{"id": "fstcz7", "name": "Mandelbrot to Julia transform", "author": "Fraktoler", "description": "Mandelbrot Set to Julia Set transformation.\nDefault formula for both is z -> z^2 + c\nwhere z_0 = 0\nc animated from canvas to mouse\n", "tags": ["fractal", "julia", "mandelbrot", "complex"], "likes": 6, "viewed": 212, "published": 3, "date": "1653302877", "time_retrieved": "2024-07-30T16:47:33.012622", "image_code": "#define MAX_ITER 256\n#define BAILOUT 256.\n#define PI 3.14159265358979\n\nvec2 toComplex(float zoom, vec2 center, vec2 pixel) {\n    return zoom * (pixel - .5 * iResolution.xy) / iResolution.x + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.;\n    vec2 uv = toComplex(zoom, vec2(0.0), fragCoord);\n    vec2 mouse = toComplex(zoom, vec2(0.0), iMouse.xy);\n    float r, effect = sin(iTime * PI * 0.2);\n    effect *= effect;\n    vec2 c = mix(uv, mouse, effect);\n    vec2 z = uv;\n    int k = 0;\n    while (k < MAX_ITER) {\n        r = dot(z, z);\n        if (r > BAILOUT) break;\n        z = z.x * z + z.y * vec2(-z.y, z.x) + c;\n        k++;\n    }\n    vec3 col = vec3(0.);\n    if (k != MAX_ITER) {\n        float invln = 1. / log(2.);\n        float lnlnb = log(log(BAILOUT));\n        float u = 2. * log(float(k) + invln*lnlnb - invln*log(.5 * log(r)));\n        col = vec3(sin(u), cos(u), 1.0) * 0.5 + 0.5;\n    }\n    fragColor = vec4(col * col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fstcz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 124, 124, 200], [202, 202, 259, 259, 976]], "test": "untested"}
{"id": "7dcyWn", "name": "Cineshader Basic Wave", "author": "jahnertz", "description": "cineshader test", "tags": ["cineshader"], "likes": 0, "viewed": 3191, "published": 3, "date": "1653266458", "time_retrieved": "2024-07-30T16:47:34.005966", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.xy;\n\tvec3 col = vec3(0.5 * (sin(iTime + uv.x) + 0.5), 0.5 * (cos(iTime + uv.y) + 0.5),1.000);\n    col.r *= (uv.x > 0.05 && uv.x < 0.95 && uv.y > 0.05 && uv.y < 0.95)?1.0:0.0;\n    fragColor = vec4(col, 0.5 * (sin(iTime + uv.x * 4.0 + uv.y * 4.0)) + 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcyWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 108, 402]], "test": "untested"}
{"id": "Ns3yDn", "name": "                   Equilibrium ", "author": "prishainabox", "description": "Yes the code is really bad I'm sorry", "tags": ["raymarching"], "likes": 8, "viewed": 189, "published": 3, "date": "1653261845", "time_retrieved": "2024-07-30T16:47:34.840734", "image_code": "const float EPSILON = 0.001;\nconst float MAX_DIST = 60.0;\nconst int AA = 2;\nconst float FRESNEL_POWER = 4.5;\nconst int REF_BOUNCES = 1;\n\n//*******************************************************//\n\n// Light structs\n\nstruct Light {\n    bool isPointLight;\n    vec3 clr;\n    float shadowSoftness;\n    // if isPointLight, set position, else set direction\n    vec3 pos;\n    vec3 dir;\n    float brightness;\n};\n\n// create a light\nLight createLight(in vec3 pt, in bool isPointLight, in float fadeAdjust, in float shadowSoftness, in vec3 dirOrPos, in vec3 clr) {\n    Light light;\n    light.clr = clr;\n    light.shadowSoftness = shadowSoftness;\n    if (isPointLight) {\n        light.pos = dirOrPos;\n        light.isPointLight = true;\n        float d = distance(pt, light.pos);\n        d = pow(d, fadeAdjust);\n        light.brightness = 1.0 / (d * d);\n        light.dir = normalize(light.pos - pt);\n    } else {\n        light.brightness = 1.0;\n        light.dir = dirOrPos;\n    }\n    return light;\n}\n\n// Material struct\nstruct Material {\n    vec3 clr;\n    float amb;\n    float dif;\n    float spec;\n    float shininess;\n    vec3 ref;\n    bool hasFresnel;\n    int id;\n    vec3 groundBounceClr;\n};\n\n// return a nondescript material\nMaterial defaultMaterial() {\n    Material mat;\n    mat.amb = 0.1;\n    mat.clr = vec3(0.05);\n    mat.dif = 1.0;\n    mat.spec = 1.0;\n    mat.shininess = 10.0;\n    mat.ref = vec3(0.0);\n    mat.hasFresnel = false;\n    mat.id = -1;\n    mat.groundBounceClr = vec3(0.0);\n    return mat;\n}\n\n//*******************************************************//\n\n// clamp value from 0 to 1\nfloat uclamp(float val) {\n    return clamp(val, 0.0, 1.0);\n}\n\n//*******************************************************//\n\n// random and noise\n\nfloat random(in float v) {\n    return fract(15465.1327854 * sin(v * 231.72));\n}\n\nfloat random(in vec2 v) {\n    return fract(15465.1327854 * sin(dot(v, vec2(173.93422, 102.5165))));\n}\n\nfloat random(in vec3 v) {\n    return fract(15465.1327854 * sin(dot(v, vec3(173.93422, 102.5165, 23.1234))));\n}\n\nfloat noise(in vec2 uv) {\n    \n\tvec2 fid = fract(uv); // fraction part of uv -> where in the grid\n\tfid = fid * fid * (3.0 - 2.0 * fid);\n\tvec2 id = floor(uv); // integer part of uvw -> which grid\n\t\n\t// corners of square\n\tfloat bl = random(id + vec2(0, 0));\n\tfloat br = random(id + vec2(1, 0));\n\tfloat tl = random(id + vec2(0, 1));\n\tfloat tr = random(id + vec2(1, 1));\n\t\n\t// interpolate between corner\n\tfloat b = mix(bl, br, fid.x);\n\tfloat t = mix(tl, tr, fid.x);\n\treturn mix(b, t, fid.y);\n    \n}\n\nfloat noise(in vec3 uvw) {\n    \n    vec3 fid = fract(uvw); // fraction part of uvw -> where in the grid cell\n    fid = fid * fid * (3.0 - 2.0 * fid);\n    vec3 id = floor(uvw); // integer part of uvw -> which grid cell\n    \n    // lerp bottom face\n    float bf = mix(random(id + vec3(0, 0, 0)), random(id + vec3(1, 0, 0)), fid.x);\n    float bb = mix(random(id + vec3(0, 0, 1)), random(id + vec3(1, 0, 1)), fid.x);\n    float b = mix(bf, bb, fid.z);\n \n    // lerp top face\n    float tf = mix(random(id + vec3(0, 1, 0)), random(id + vec3(1, 1, 0)), fid.x);\n    float tb = mix(random(id + vec3(0, 1, 1)), random(id + vec3(1, 1, 1)), fid.x);\n    float t = mix(tf, tb, fid.z);\n    \n    return mix(b, t, fid.y);\n    \n}\n\n//*******************************************************//\n\n// SDFs\n\nfloat sdCapsule(in vec3 pt, in vec3 a, in vec3 b, in float r) {\n    vec3 apt = pt - a;\n    vec3 ab = b - a;\n    float t = clamp(dot(apt, ab) / dot(ab, ab), 0.0, 1.0);\n    return length( apt - ab * t ) - r;\n}\n\n\n//*******************************************************//\n\n// SDF SCENE\n\nfloat sdf(in vec3 pt, out Material mat) {\n\n    // distance to closest object\n    float res = MAX_DIST;\n    \n    // default\n    mat = defaultMaterial();\n    vec3 t = vec3(iTime * 0.7);\n    \n    float n = - 1.0 +  0.7*noise(pt * 0.4 + t);\n    // water\n    {\n        float s = pt.y - n;\n        if (s < res) {\n            res = s;\n            mat.id = 0;\n            mat.hasFresnel = true;\n            mat.dif = 0.2;\n            mat.spec = 0.2;\n            mat.clr = vec3(0.06, 0.06, 0.2) * 0.07;\n            mat.ref = vec3(0.2, 0.25, 0.5);\n        }\n    \n    }\n    \n    {\n        vec3 p = pt - vec3(0, 0.25*noise(t), 0); \n        \n        // sphere\n        float b = length(p) - 2.0;\n        if (b < res) {\n            res = b;\n            mat.id = 1;\n            mat.dif = 0.8;\n            mat.spec = 0.5;\n            mat.shininess = 50.0;\n            mat.clr = p.y < 0.1 ? vec3(0.2, 0.2, 0.13) : vec3(0.3, 0.1, 0.1);\n            mat.ref = vec3(1.1);\n        }\n        \n        // attachment to sphere thingy\n        float s = sdCapsule(p, vec3(0), vec3(0, 2.35, 0), 0.18);\n        if (s < res) {\n            res = s;\n            mat.id = 2;\n            mat.dif = 0.4;\n            mat.spec = 0.9;\n            mat.shininess = 10.0;\n            mat.hasFresnel = false;\n            mat.clr = vec3(0.15);\n            mat.ref = vec3(0.15);\n        }\n        \n        // line\n        vec3 lp = p - vec3(0.0, smoothstep(1.0, 8.0, length(pt.xz)), 0.0);\n        float l = sdCapsule(lp, vec3(-4, 5.0 + 0.5*sin(t.x), -10), vec3(0, 2.35, 0), 0.04);\n        if (l < res) {\n            res = l;\n            mat.id = 3;\n            mat.dif = 0.9;\n            mat.spec = 0.5;\n            mat.hasFresnel = false;\n            mat.shininess = 50.0;\n            mat.ref = vec3(0.0);\n            mat.clr = vec3(0.08);\n        }\n        \n    }\n    \n    return res;\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(in vec3 pt) {\n    vec2 h = vec2(EPSILON, 0);\n    Material m;\n    // central difference sdf(pt + EPSILON) - sdf(pt - EPSILON)    \n    return normalize(vec3(\n       sdf(pt + h.xyy, m) - sdf(pt - h.xyy, m),\n       sdf(pt + h.yxy, m) - sdf(pt - h.yxy, m),\n       sdf(pt + h.yyx, m) - sdf(pt - h.yyx, m)\n    ));\n}\n\n//*******************************************************//\n\nfloat castRay(in vec3 ro, in vec3 rd, out Material mat) {\n\n    // total distance traveled\n    float td = 0.0;\n    \n    for (int i = 0; i < 100; i++) {\n        float h = sdf(ro + td*rd, mat);\n        // if distance is really close, break\n        if (abs(h) < (0.0001*td)) break;\n        // add to total distance\n        td += h;\n        // if too far, break\n        if (td >= MAX_DIST) {\n            mat.id = -1;\n            mat.ref = vec3(0.0);\n            mat.hasFresnel = false;\n            break;\n        }\n    }\n    \n    return td;\n    \n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat softShadow(in vec3 ro, in vec3 rd, in float k) {\n    float res = 1.0; // result\n    float td = 0.05; // total distance traveled\n    for (int i = 0; i < 200 && td < MAX_DIST; i++) {\n        Material m;\n        float d = sdf(ro + td*rd, m);\n        if (d < 0.001) {\n            // intersection, so return shadow\n            return 0.0;\n        }\n        res = min(res, k*d/td);\n        td += d;\n    }\n    // if no intersection -> shadow 0.0 to light 1.0\n    return res;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\n// ambient occlusion\nfloat calcOcc(in vec3 pt, in vec3 nor) {\n\n    float occ = 0.0;\n    float scl = 1.0;\n    \n    Material m; // placeholder\n    \n    for (int i = 0; i < 5; i++) {\n        float h = 0.01 + 0.11 * 0.25 * float(i);\n        float d = sdf(pt + h * nor, m);\n        occ += (h-d)*scl;\n        scl *= 0.95;\n    }\n    \n    return uclamp(1.0 - 2.0 * occ);\n    \n}\n\n//*******************************************************//\n\n// https://iquilezles.org/articles/fog\nvec3 applyFog(in vec3 rd, in float d, in vec3 clr, in vec3 sunClr, in vec3 sunDir, in vec3 skyClr) {\n    vec3 fogClr = mix( skyClr, sunClr, pow(max(dot(rd, sunDir), 0.0), 15.0) );\n    return mix(clr, fogClr, 1.0 - exp(-0.00005 * d * d * d)); // fog\n}\n\nvec3 calcLighting(in vec3 pt, in vec3 rd, in vec3 nor, in Light light, in Material mat) {\n\n    // diffuse\n    float dif = uclamp(dot(nor, light.dir)) * mat.dif;\n    \n    // shadow\n    float shadow = light.isPointLight ? 1.0 : softShadow(pt, light.dir, light.shadowSoftness);\n    \n    // specular\n    vec3 ref = reflect(light.dir, nor);\n    float spec = pow(uclamp(dot(rd, ref)), mat.shininess) * mat.spec;\n\n    // return dif * clr * shadow * spec + dif * clr * shadow; \n    return light.brightness * light.clr * shadow * dif * (spec + 1.0);\n    \n}\n\nvec3 calcClr(in vec3 ro, in vec3 rd, in float d, in vec3 nor, in Material mat) {\n\n    vec3 pt = ro + rd * d;\n\n    // COLORS\n    vec3 skyClr = vec3(0.75, 0.6, 0.5) + 0.15*smoothstep(5.5, -1.0, pt.y);\n    \n    // KEY LIGHT\n    Light sun = createLight(pt, false, 1.0, 10.9, normalize(vec3(8, 1.5, 10)), vec3(15.8, 9.0, 6.7));\n    \n    // background color\n    vec3 clr = skyClr;\n\n    // return background if too far (id is -1.0)\n    if (mat.id == -1) {// sun\n        clr = mix(skyClr, sun.clr * 0.12, 0.7 * smoothstep(8.0, -2.0, pt.y) * pow(max(dot(rd, sun.dir), 0.0), 20.0));\n        return clr;\n    }\n    \n    clr = mat.clr;\n    \n    // LIGHTS\n   \n    // CALCULATE COLOR\n    float occ = calcOcc(pt, nor);\n    vec3 light = vec3(mat.amb);\n    light += calcLighting(pt, rd, nor, sun, mat); // sun\n    light += (uclamp(dot(nor, vec3(0, 1, 0))) * 0.5 + 0.5) * skyClr; // sky diffuse\n\n    clr *= light * occ;\n    \n    clr = applyFog(rd, d, clr, sun.clr * 0.1, sun.dir, skyClr);\n    \n    return clr;\n\n}\n\n//*******************************************************//\n\nvec3 render(in vec3 ro, in vec3 rd) {\n    \n    Material mat;\n\n    float d = castRay(ro, rd, mat);\n    vec3 nor = calcNormal(ro + rd*d);\n    \n    vec3 clr = calcClr(ro, rd, d, nor, mat);\n    \n    bool willReflect = mat.ref.r > 0.0 || mat.ref.g > 0.0 || mat.ref.b > 0.0;\n    if (mat.hasFresnel || willReflect) {\n    \n        int bounces = 1;\n        vec3 ref = vec3(0.0);\n        float fresnel = 0.5 * uclamp(pow(1.0 - dot(nor, -rd), FRESNEL_POWER));\n        \n        // if the material will reflect\n        if (willReflect) {\n            bounces = REF_BOUNCES;\n            // if reflective and doesn't have fresnel\n            if (!mat.hasFresnel) ref = mat.ref;\n            // if reflective with fresnel\n            else ref = fresnel * mat.ref;\n        } else {\n            ref = vec3(fresnel);\n        }\n        \n        // bouncing around for fresnel and reflection\n        vec3 fil = vec3(1.0);\n        if (fresnel > 0.0) {\n            for (int i = 0; i < bounces; i++) {\n                fil *= ref;\n                // to intersection point and reflect\n                ro += rd*d + nor*EPSILON*3.0;\n                rd = reflect(rd, nor);\n                // find new point\n                d = castRay(ro, rd, mat);\n                nor = calcNormal(ro + rd*d);\n                // add color\n                clr += fil * calcClr(ro, rd, d, nor, mat);\n                if (mat.id == -1) break;\n            }\n        }\n        \n    }\n    \n    clr = pow(clr, vec3(1.0 / 2.2)); // gamma correction\n    return clr;\n    \n}\n\n//*******************************************************//\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target) {\n    vec3 forward = normalize(target - ro);\n    vec3 right = normalize(cross(forward, vec3(0, 1, 0)));\n    vec3 up = normalize(cross(right, forward));\n    // ray direction\n    vec3 rd = normalize(uv.x * right + uv.y * up + 1.2 * forward);\n    return rd;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float time = iTime;\n    vec2 res = iResolution.xy;\n    \n    // target\n    vec3 target = vec3(0, 0, 0);\n    // ray origin\n    vec3 ro = vec3(-6, 0, 0);\n    \n    // accumulate color\n    vec3 clr = vec3(0.0);\n    \n    for (int i = 0; i < AA; i++) {\n        for (int j = 0; j < AA; j++) {\n            // Normalized pixel coordinates\n            vec2 f = fragCoord + vec2(float(i), float(j)) / float(AA);\n            vec2 uv = (2.0*f - res) / min(res.x, res.y);\n            vec3 rd = setCamera(uv, ro, target);\n            // calculate color based on distance, etc\n            clr += render(ro, rd);\n        }\n    }    \n    \n    clr /= float(AA*AA);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3yDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[405, 423, 553, 553, 988], [1185, 1218, 1246, 1246, 1499], [1562, 1589, 1614, 1614, 1649], [1733, 1733, 1759, 1759, 1812], [1814, 1814, 1839, 1839, 1915], [1917, 1917, 1942, 1942, 2027], [2029, 2029, 2054, 2054, 2523], [2525, 2525, 2551, 2551, 3235], [3307, 3307, 3370, 3370, 3514], [3592, 3592, 3633, 3668, 5440], [5503, 5549, 5578, 5578, 5873], [5936, 5936, 5993, 6025, 6478], [6480, 6525, 6579, 6579, 7000], [7002, 7064, 7104, 7104, 7412], [7475, 7514, 7614, 7614, 7764], [7766, 7766, 7855, 7871, 8313], [8315, 8315, 8395, 8395, 9308], [9371, 9371, 9408, 9408, 10886], [10949, 10949, 11005, 11005, 11260], [11262, 11262, 11319, 11319, 12033]], "test": "untested"}
{"id": "NddyRM", "name": "Pixel Fun", "author": "SnoopethDuckDuck", "description": "Just messing around", "tags": ["pixelart"], "likes": 7, "viewed": 269, "published": 3, "date": "1653255803", "time_retrieved": "2024-07-30T16:47:35.735343", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = 0.15;mix(0.25, 0.1, tanh(iTime));\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define pi 3.14159\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    f -= p;\n    vec2 dir = .5 * (q - p),\n         v = step(abs(f - round(dir/dir.yx * f.yx)), vec2(0)),\n         a = step(abs(f - dir), abs(dir));  \n    return max(v.x, v.y) * a.x * a.y ;           \n}\n\nvec2 point(float i) {\n    float h = h21(vec2(i, i + 103.));\n    float h2 = h21(vec2(i + 53., i - 41.));\n    return round(40. * vec2(h,h2) - 20.);\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5*cos( 6.28318*(0.5*t+d) );\n}\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n   // vec3 col2 = \n   \n    f -= vec2(40,30) - 0.5;\n\n    float n = 200.;\n    for (float i = 0.; i < n; i++) {\n        //i += 0.001 * floor(iTime);\n        float io = 2. * pi * i / n;\n        \n        float a = 1.5 + 0.5 * thc(12., 0.25 * io + 0.5 * iTime);\n        float b = 1.5 + 0.5 * ths(12., 0.25 * io + 0.5 * iTime);\n\n        \n        vec2 p = round(20. * vec2(cos(0.5 * io + iTime), sin(0.5 * io + iTime)));\n        vec2 q = round(20. * vec2(1. * cos(a * io + 2. * iTime), sin(b * io + 1. * iTime)));\n        col += 16./n * step(length(f-q), 0.);\n        \n        col += 8./n * pxLine(f, p, q) * pal(i / n + cos(0.5 * io + iTime), 0.5* vec3(0,1,2)/3.);\n    }     \n    col += 0.04;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 211]], "test": "untested"}
{"id": "7ddyzn", "name": "Black Hole - Spi3lot", "author": "Spi3lot", "description": "Black Hole", "tags": ["space", "einstein", "newton", "hole", "horizon", "black", "relativity", "event", "theory", "general", "mass", "telescope", "m87", "sagittarius", "messier"], "likes": 13, "viewed": 389, "published": 3, "date": "1653248040", "time_retrieved": "2024-07-30T16:47:39.806457", "image_code": "// OUTDATED: Black hole - Curve light ray with REFRACTION -> distance/mass to the BH as eta (n1/n2)\n// CURRENT: Black hole - Curve light ray with normal of the black hole -> newton\n\n\n\n// CONSTANTS\n#define PI 3.1415926535\n#define TAU 2.0 * PI\n\n\n// RAY MARCHING SETTINGS\n#define EPSILON 0.001\n#define STEP_SIZE 0.1 * dS\n#define MAX_STEPS 10000\n#define MAX_DIST 1000.0\n\n#define ZOOM 1.0\n#define DISTANCE 7.0\n\n\n// BLACK HOLE SETTINGS\n#define CENTER vec3(0,0,0)\n#define RADIUS 0.8\n#define MASS 0.5\n\n#define ACCRETION_DISK_INNER_RADIUS 0.0\n#define ACCRETION_DISK_OUTER_RADIUS 4.0\n#define ACCRETION_DISK_SPEED 0.25\n\n#define GLOW\n#define TRANSLUCENT_ACCRETION_DISK\n#define MAX_ACCRETION_DISK_PENETRATIONS 10\n\n#define GRAVITATIONAL_LENSING\n\n\n\n// https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdDisk(vec3 p)\n{\n    //float torus = sdTorus(p, vec2(2.6 * RADIUS, 25.0 * RADIUS));\n    float torus = sdTorus(p, vec2(ACCRETION_DISK_INNER_RADIUS, ACCRETION_DISK_OUTER_RADIUS));\n    float plane = abs(p.y);\n\n    return max(torus, plane);\n }\n\nfloat sdBlackHole(vec3 p)\n{\n    return length(p - CENTER) - RADIUS;\n}\n\nfloat GetDist(vec3 p)\n{\n    float disk = sdDisk(p);\n    float bhole = sdBlackHole(p);\n\n    return min(disk, bhole);\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n\n    return normalize(d - vec3(GetDist(p - e.xyy),\n                              GetDist(p - e.yxy),\n                              GetDist(p - e.yyx)));\n}\n\n/*vec3 GetLight(vec3 p)\n{\n    return normalize(5.0 * vec3(cos(iTime),0,sin(iTime)) - p);\n}*/\n\nvec4 RayMarch(vec3 ro, inout vec3 rd, float side)\n{\n    vec3 p = ro;\n    float minDist = 1e20;\n    float traveled = 0.0;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float dS = side * GetDist(p);\n        traveled += STEP_SIZE;\n        \n        if (abs(dS) < minDist)\n            minDist = abs(dS);\n\n        if (abs(dS) <= EPSILON || traveled > MAX_DIST)\n            break;\n\n#ifdef GRAVITATIONAL_LENSING\n        vec3 d = p - CENTER;\n        float r = dot(d, d);\n        float bend = MASS / r;\n        vec3 n = d * inversesqrt(r);  // normalizing vector\n        rd = normalize(rd - n * (bend * STEP_SIZE));  // * STEP_SIZE means bend more when stepping further\n#endif\n        p += rd * STEP_SIZE;\n    }\n\n    return vec4(p, minDist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec2 mouse;\n\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0.5, 0.48);\n    else\n        mouse = iMouse.xy / iResolution.xy;\n\n    float yaw = mouse.x * TAU;\n    float pitch = mouse.y * PI;\n    vec4 cs = vec4(cos(yaw), sin(yaw), cos(pitch), sin(pitch));\n\n    vec3 ro = DISTANCE * cs.xzy * vec3(cs.w, 1, cs.w);\n    vec3 lookAt = CENTER,\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + r * uv.x + u * uv.y,\n         rd = normalize(i - ro);\n\n    vec3 col = vec3(0);\n    float j;\n    float iterations;\n\n#ifdef TRANSLUCENT_ACCRETION_DISK\n    iterations = float(MAX_ACCRETION_DISK_PENETRATIONS);\n#else\n    iterations = 1.;\n#endif\n\n    for (j = 0.; j < iterations; j++)\n    {\n        vec4 p_minDist = RayMarch(ro, rd, 1.0);\n        vec3 p = p_minDist.xyz;\n        //float minDist = p_minDist.w;\n        //col += 1e-7 * MAX_DIST / minDist;\n    \n        if (sdBlackHole(p) <= EPSILON)  // Light ray got swallowed by the black hole\n        {\n            //col = vec3(0,0,0);\n            break;\n        }\n        else if (sdDisk(p) <= EPSILON)  // Light ray is on the accretion disk\n        {\n            // Switching side of accretion disk\n            ro = p;\n            ro.y -= sign(p.y) * 2.0 * EPSILON;\n\n            float a = 0.5 + 0.5 * atan(p.z, p.x) / PI;\n            //float a = 0.5 * atan(p.z, p.x) / PI;\n            //float a = atan(p.z, p.x);\n            float d = 1.0 - sdBlackHole(p) / ACCRETION_DISK_OUTER_RADIUS;\n\n            //col += d * abs(1.0 + cos(a)) * vec3(1, 0.635, 0.475);\n            //col += 2.0 * d * /*d * */vec3(1, 0.635, 0.475);\n            //col += d * vec3(1, 0.635, 0.475);\n\n            //float motion = mod(iTime * ACCRETION_DISK_SPEED, 1.0);\n            float motion = iTime * ACCRETION_DISK_SPEED;\n            float u = a + motion/* * d*/;\n            float v = d;\n            //float v = d - motion;\n\n            vec3 tex = texture(iChannel0, vec2(u, v)).rgb;\n            float brightness = dot(tex, vec3(0.3, 0.6, 0.1));\n\n            //if (brightness > 0.25)\n            //{\n            col += exp2(-j) * 4.0 * d * brightness * vec3(1.0, 0.3, 0.0);\n        #ifdef GLOW\n            col += 2.0 * d * d;\n        #endif\n            //}\n        }\n        else\n        {\n            //col += texture(iChannel0, p.xy / MAX_DIST).rgb;\n            //col += texture(iChannel1, rd).rgb;\n            break;\n        }\n    }\n    \n    //col /= 0.25 * j;\n    //col += 0.8 - length(uv);\n    //col = pow(col, vec3(0.4545));\n    //col *= 1.25;\n    //col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[734, 784, 817, 817, 882], [884, 884, 906, 973, 1129], [1131, 1131, 1158, 1158, 1200], [1202, 1202, 1225, 1225, 1319], [1321, 1321, 1345, 1345, 1557], [1653, 1653, 1704, 1704, 2395], [2397, 2397, 2454, 2454, 5194]], "test": "untested"}
{"id": "fdcyDn", "name": "fix Topologica exebetche 666", "author": "exebetche", "description": "An animated topological pattern", "tags": ["fixtopological"], "likes": 3, "viewed": 264, "published": 3, "date": "1653242692", "time_retrieved": "2024-07-30T16:47:40.927461", "image_code": "const ivec2 samplePoints[9] = ivec2[9](\n    ivec2(-1,1), ivec2(0,1), ivec2(1,1),\n    ivec2(-1,0), ivec2(0,0), ivec2(1,0),\n    ivec2(-1,-1), ivec2(0,-1), ivec2(1,-1)\n);\n\nconst float XMatrix[9] = float[9](\n    1.0, 0.0, -1.0,\n    2.0, 0.0, -2.0,\n    1.0, 0.0, -1.0\n);\n\nconst float YMatrix[9] = float[9](\n    1.0, 2.0, 1.0,\n    0.0, 0.0, 0.0,\n    -1.0, -2.0, -1.0\n);\n\nfloat valueSobel(vec2 fragCoord)\n{\n    vec2 sobel = vec2(0,0);\n    \n    for(int i = 0; i < 9; i++) {\n        float value = texelFetch(iChannel0, ivec2(fragCoord) + samplePoints[i], 0).r;\n        sobel += value * vec2(XMatrix[i], YMatrix[i]);\n    }\n    \n    return length(sobel);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    float threshold = 0.9;\n    float edge = smoothstep(threshold, 0.0, valueSobel(fragCoord));\n    edge = pow(edge, 10.0);\n    edge = valueSobel(fragCoord);\n    fragColor = vec4(edge, edge, edge,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float posterize(float value){\n  float gamma = 0.3f;\n  float numColors = 8.0f;\n  \n\n  float c = value;\n  c = pow(c, gamma);\n  c = c * numColors;\n  c = floor(c);\n  c = c / numColors;\n  c = pow(c, 1.0/gamma);\n  \n  return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Pi = 6.28318530718; // Pi*2\n    \n    // GAUSSIAN BLUR SETTINGS {{{\n    float Directions = 16.0; // BLUR DIRECTIONS (Default 16.0 - More is better but slower)\n    float Quality = 4.0; // BLUR QUALITY (Default 4.0 - More is better but slower)\n    float Size = 5.0; // BLUR SIZE (Radius)\n    // GAUSSIAN BLUR SETTINGS }}}\n   \n    vec2 Radius = Size/iResolution.xy;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // Pixel colour\n    float value = texture(iChannel0, uv).r;\n    \n    // Blur calculations\n    for( float d=0.0; d<Pi; d+=Pi/Directions)\n    {\n\t\tfor(float i=1.0/Quality; i<=1.0; i+=1.0/Quality)\n        {\n\t\t\tvalue += texture( iChannel0, uv+vec2(cos(d),sin(d))*Radius*i).r;\t\t\n        }\n    }\n    \n    // Output to screen\n    value /= Quality * Directions - 15.0;\n    \n    value = posterize(value);\n\n\tfragColor = vec4(value, value, value,1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat hermite(float t)\n{\n  return t * t * (3.0 - 2.0 * t);\n}\n\nfloat noise(vec2 co, float frequency)\n{\n  vec2 v = vec2(co.x * frequency, co.y * frequency);\n\n  float ix1 = floor(v.x);\n  float iy1 = floor(v.y);\n  float ix2 = floor(v.x + 1.0);\n  float iy2 = floor(v.y + 1.0);\n\n  float fx = hermite(fract(v.x));\n  float fy = hermite(fract(v.y));\n\n  float fade1 = mix(rand(vec2(ix1, iy1)), rand(vec2(ix2, iy1)), fx);\n  float fade2 = mix(rand(vec2(ix1, iy2)), rand(vec2(ix2, iy2)), fx);\n\n  return mix(fade1, fade2, fy);\n}\n\nint modu(int x, int y)\n{\n    return x - y * (x/y);\n}\n\nfloat pnoise(vec2 co, float freq, int steps, float persistence)\n{\n  float value = 0.0;\n  float ampl = 1.0;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    vec2 crd = co + vec2(float(modu(i,2)) * iTime / 10.0, float(modu((i + 1),2)) * iTime / 10.0);\n    value += noise(crd, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nfloat inoise(vec2 co, float freq, int steps, float persistence, float prevVal)\n{\n  float value = prevVal;\n  float ampl = 0.5;\n  float sum = 0.0;\n  for(int i=0 ; i<steps ; i++)\n  {\n    sum += ampl;\n    vec2 crd = co + vec2(float(modu(i,2)) * iTime / 10.0, float(modu((i + 1),2)) * iTime / 10.0);\n    value -= noise(-crd, freq) * ampl;\n    freq *= 2.0;\n    ampl *= persistence;\n  }\n  return value / sum;\n}\n\nfloat posterize(float value){\n  float gamma = 0.3f;\n  float numColors = 20.0f;\n  \n\n  float c = value;\n  c = pow(c, gamma);\n  c = c * numColors;\n  c = floor(c);\n  c = c / numColors;\n  c = pow(c, 1.0/gamma);\n  \n  return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    float value = pnoise(uv, 5.0, 8, 0.5);\n    value = inoise(uv, 5.0, 1, 0.5, value);\n    value = abs(value);\n    \n    //value = posterize(value);\n\n\tfragColor = vec4(value, value, value,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyDn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[365, 365, 399, 399, 645], [647, 647, 704, 754, 1111]], "test": "untested"}
{"id": "Ns3cWn", "name": "Elden Rings", "author": "antonOTI", "description": "It has been a while since I've done a fan art.\nI've sunk too much time into elden ring lately.\nIf I have the time, I'll split the central column so I can make a define for each great runes", "tags": ["2d", "sdf", "fanart"], "likes": 10, "viewed": 479, "published": 3, "date": "1653241353", "time_retrieved": "2024-07-30T16:47:41.887892", "image_code": "\n#define FULL 255\n#define GODRICK 15\n#define MORGOT 17\n\nint GLYPHS = FULL;\n\n// ------------------------\n// FROM :  https://www.shadertoy.com/view/ldlXRS\n// BY : nimitz\n\n#define time iTime*0.0125\n#define tau 6.2831853\n\nmat2 makem2(in float theta){float c = cos(theta);float s = sin(theta);return mat2(c,-s,s,c);}\nfloat noise( in vec2 x ){return texture(iChannel0, x*.01).x;}\n\nfloat fbm(in vec2 p)\n{\t\n\tfloat z=2.;\n\tfloat rz = 0.;\n\tvec2 bp = p;\n    \n\tfor (float i= 1.;i < 6.;i++)\n\t{\n        float soundBias = texture(iChannel1, vec2(1. - (i / 6.), 0.)).x;\n        rz+= abs((noise(p) * (1. - soundBias*.2)-0.5)*2.)/z + soundBias * .02;\n        soundBias = soundBias * soundBias;\n        soundBias = 1.2 - soundBias;\n\t\tz = z*2. * soundBias;\n\t\tp = p*2.;\n\t}\n\treturn rz;\n}\n\n// ------------------------\n\n#define _smoothFactor 1. / iResolution.y\n#define _smooth(p,r,s) smoothstep(-s, s, p-(r))\n#define _smooths(p,r,sf) _smooth(p,r,_smoothFactor * sf)\n\n#define _circle(p, r, s, sf) (1. - _smooths(abs(length(p) - r), s/2., sf))\n\n#define _poly(p,x1,x2) (x1 + x2 * p * p)\n\nfloat eldenRing(vec2 uv)\n{\n    float fontSize = .015;\n    float circleSep = .05;\n    float sf = 4.;\n    float f = 0.;\n    \n     if((GLYPHS & 1) != 0)\n        f = max(f, _circle(uv, .155, fontSize * .25, sf));\n     if((GLYPHS & 2) != 0)\n        f = max(f, _circle(uv - vec2(0, circleSep), .14, fontSize, sf));\n    if((GLYPHS & 4) != 0)\n        f = max(f, _circle(uv - vec2(circleSep * -0.86602, circleSep * -0.49999), .14, fontSize, sf));\n    if((GLYPHS & 8) != 0)\n        f = max(f, _circle(uv - vec2(circleSep * 0.86602, circleSep * -0.49999), .14, fontSize, sf));\n    \n    if((GLYPHS & 16) != 0)\n        f = max(f, (1. - _smooths(abs(uv.x), fontSize * .5, sf)) * step(abs(uv.y) , .25));\n    \n    float parSize = fontSize * 2.6;\n    \n    if((GLYPHS & 32) != 0)\n        f = max(f, 1. - _smooths(abs(_poly(abs(uv.x), .25, 1.3) - uv.y), parSize  * (.0125 * sf-abs(uv.x * iResolution.y/iResolution.x)), sf));\n        \n    if((GLYPHS & 64) != 0)\n        f = max(f, 1. - _smooths(abs(_poly(abs(uv.x), -.09, 1.3) - uv.y), parSize * 1.2 * (.0125 * sf-abs(uv.x * iResolution.y/iResolution.x)), sf));\n    \n    if((GLYPHS & 128) != 0)\n        f = max(f, 1. - _smooths(abs(_poly(abs(uv.x), -.25, 1.2) - uv.y), parSize * (.025 * sf-abs(uv.x * iResolution.y/iResolution.x)), sf));\n    \n    return f;\n}\n\nfloat radagon(vec2 uv)\n{\n    uv = vec2(uv.x * 0.7071 - uv.y * 0.7071, uv.x * 0.7071 + uv.y * 0.7071);\n    uv = abs(mod(uv * 12., 1.) - .5);\n    return (.25 - pow(max(uv.x * uv.y, 0.0001), .75)) * 4.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y - vec2(iResolution.x / iResolution.y * .5, .5);\n    vec2 disp = vec2(fbm(uv),fbm(uv * .7 - time));\n    disp = pow(disp, vec2(2.)) * .025;\n    uv += disp;\n    float f = eldenRing(uv);\n    f += radagon(uv) * pow(max(.7 - length(uv), .0001), 2.2) * 3.5 * fbm(uv * .8 - .5);\n    f *= (1. + length(disp) * 400.) / 2.;\n    // fiery colors from https://www.shadertoy.com/view/MdKfDh\n    fragColor = vec4(2.*f, 2. *f*f*f, f*f*f*f, 1.);\n    fragColor = pow(fragColor, vec4(2.2));\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29040, "src": "https://soundcloud.com/samuelkimmusic/elden-ring-main-theme-the-final-battle-epic-version", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns3cWn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 246, 246, 311], [312, 312, 337, 337, 373], [375, 375, 397, 397, 764], [1060, 1060, 1086, 1086, 2348], [2350, 2350, 2374, 2374, 2551], [2553, 2553, 2610, 2610, 3123]], "test": "untested"}
{"id": "7ddyz7", "name": "Marmalade Flower I", "author": "luckyballa", "description": "My flower experiments from 2021, part I\n\n", "tags": ["raymarching", "sdf", "flower", "scattering", "ss", "fxaa", "salute"], "likes": 20, "viewed": 354, "published": 3, "date": "1653233091", "time_retrieved": "2024-07-30T16:47:42.975983", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n\n    fragColor = texture(iChannel0, uv);\n}\n\n\n\n\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define MAX_STEPS 60\n#define MAX_DIST 60.\n#define SURF_DIST .001\n#define PI 3.1415926535\n#define PHI 1.57079632679 // pi / 2\n#define TAU 6.28318530718 // 2 * pi\n#define tex(p) texture(iChannel0, p).rgb\n//#define MOUSE_CONTROL\n\n\nconst float DEG_TO_RAD = PI / 180.0;\n\n\nfloat hash(float x) {\n    return fract(sin(x * 171.2972) * 18267.978 + 31.287);\n}\n\nvec3 hash3( float n ) {\n    return fract(sin(vec3(n,n+1.0,n+2.0))*vec3(43758.5453123,22578.1459123,19642.3490423));\n}\n\nfloat noise( in vec2 x ) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = p.x + p.y*157.0;\n\n    return mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n               mix( hash(n+157.0), hash(n+158.0),f.x),f.y);\n}\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\nfloat fbm( vec2 p ) {\n    float f = 0.0;\n\n    f += 0.5000*noise( p ); p = m2*p*2.02;\n    f += 0.2500*noise( p ); p = m2*p*2.03;\n    f += 0.1250*noise( p ); p = m2*p*2.01;\n    f += 0.0625*noise( p );\n\n    return f/0.9375;\n}\n\nfloat sdSphere( vec3 p, float s ) { return length(p)-s; }\n\nfloat smax( float a, float b, float k ) {\n    k *= 1.4;\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*h/(6.0*k*k);\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n\nfloat sdSegment(vec3 p, float L, float r) {\n    p.y -= min(L,max(0.0,p.y));\n    return length(p)-r;\n}\n\n\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvec3 rot(vec3 P, float a, vec3 A) {\n    vec3 O = dot(P, A) * A;\n    return O + (P-O) * cos(a) -  cross(A,P) * sin(a);\n}\n\n\nvec3 opRepLim( in vec3 p, in float s, in vec3 lima, in vec3 limb ) {\n    return p-s*clamp(round(p/s),lima,limb);\n}\n\n\nfloat diffuse(vec3 p, vec3 n, vec3 lp) {\n    vec3 l = normalize(lp-p);\n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    return dif;\n}\n\nfloat G1V ( float dotNV, float k ) {\n    return 1.0 / (dotNV*(1.0 - k) + k);\n}\n\nfloat GGX(vec3 N, vec3 V, vec3 L, float roughness, float F0) {\n        float alpha = roughness*roughness;\n    vec3 H = normalize (V + L);\n\n    float dotNL = clamp (dot (N, L), 0.0, 1.0);\n    float dotNV = clamp (dot (N, V), 0.0, 1.0);\n    float dotNH = clamp (dot (N, H), 0.0, 1.0);\n    float dotLH = clamp (dot (L, H), 0.0, 1.0);\n\n    float D, vis;\n    float F;\n\n    float alphaSqr = alpha*alpha;\n    float pi = 3.1415926535;\n    float denom = dotNH * dotNH *(alphaSqr - 1.0) + 1.0;\n    D = alphaSqr / (pi * denom * denom);\n\n    float dotLH5 = pow (1.0 - dotLH, 5.0);\n    F = F0 + (1.0 - F0)*(dotLH5);\n\n    float k = alpha / 0.1;\n    vis = G1V (dotNL, k) * G1V (dotNV, k);\n\n    return D * F * vis;\n}\n\nfloat specular(vec3 p, vec3 rd, vec3 n, vec3 lp) {\n    vec3 ld = normalize(lp - p);\n    float roughness = 0.375;\n    return GGX(n,-rd, ld,roughness, 0.2);\n}\n\nvec3 rayDir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n", "buffer_a_code": "\nfloat flowerSDF(vec3 p, float size) {\n    p.y += p.y * 1.1;\n    vec3 q = p;\n\n    float n = 12.;\n    float a = TAU / n, ha = 0.5 * a;\n    p.xz = sin(mod(atan(p.z, p.x) - ha, a) - ha + vec2(PHI, 0.0)) * length(p.xz);\n    p = rot(p, 0.9, vec3(0., 0., 1.));\n\n    p = opRepLim(p, 0.3, vec3(0., -2., 0.), vec3(0., 4., 0.));\n    p.x -= p.x * .55;\n    p.z -= length(p.xz) * .5 * sign(p.z);\n    p.y += sin(dot(q.xz, q.xz) * 5.) * 0.05;\n    p = p - vec3(0.2 + q.y * 0.3, 0., 0.0);\n    p.xy -= fbm(p.zy * 15.) * 0.075;\n    \n    return  length(p) - size;\n   }\n\n\nvec2 getDist(vec3 p) {\n    float matId;\n\tvec3 hp = p;\n    hp = rot(hp, PHI / 3., vec3(0.,0., 1.));\n\n    float flower = flowerSDF(hp - vec3(0.0, 0.75, 0.), 0.2);\n    \n    vec3 sp = hp;\n    sp.x = 0.25 * atan( hp.x, hp.z );\n    sp.z = acos( hp.y/length(hp) );\n    sp.xz = (mod(20.0*(sp.xz+0.5),1.0) - 0.5)/20.;\n    sp.y -= 1.;\n\n    float c = sdSphere(hp - vec3(0. ,1., 0.), 0.4);\n    float c2 = sdSphere(hp - vec3(0. ,0.75, 0.), 0.4);\n    float s = smax(sdSegment(sp, 0.5, 0.01), c, 0.1);\n    \n    vec3 lp = hp;\n    lp.y -= 0.5;\n    lp.z -= 0.1;\n    lp.xz -= exp(lp.y) * sign(hp.xz) * 0.1;\n    lp = opRepLim(lp, 0.2,  vec3(-1., 0., -1.), vec3(0., 0., 0.));\n    lp.xz += sin(exp(lp.y * 2.) - iTime) * 0.02;\n    float cr = mod(atan(hp.x, hp.z), 3.) * 0.05;\n    s = min(s, sdSegment(lp, 1.1 - cr, 0.02));\n    \n    vec3 stp = rot(hp, 0.3, vec3(0., 0., 1.));\n    stp.x -= 0.1;\n    stp.y += 3.5;\n    stp.z += sin(smoothstep(1., -5., hp.y) * 4.) * 0.4;\n    \n    float stem = sdSegment(stp, 4.5, 0.075);\n    flower = smin(flower, s, 0.01);\n    flower = smin(flower, stem, 0.01);\n    flower = smin(flower, c2, 0.1);\n    \n    vec3 cp = rot(hp, 0.75, vec3(0., 0., 1.));\n    cp.y *= 0.8; cp.x -= 0.3; cp.z += 0.2; cp.y -= 0.3;\n    flower = smin(flower, sdSphere(cp, 0.1), 0.4);\n    float fin = flower;\n    \n    vec3 fxp = hp;\n    fxp = abs(fxp);\n    fxp.xz -= 1.;\n    fxp = rot(fxp, sin(iTime / 4.), vec3(1., 0., 1.));\n    fxp = abs(fxp);\n    float ft = abs(sin((iTime - 2.) / 8.));\n    float fx = sdSphere(fxp - 1., 0.04);\n    fx = smin(fx,  sdSphere(fxp  - ft * 3., 0.04), 0.2);\n    fxp = rot(fxp, cos(iTime / 4.), vec3(0., 0., 1.));\n    fx = smin(fx,  sdSphere(fxp - 0.75, 0.04), 0.3);\n\n    fin = min(fx, fin);\n    matId = 1.;\n    if (fx < flower) {\n      matId = 2.;\n    }\n    \n    return vec2(fin, matId);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float matId = -1.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        vec2 res = getDist(p);\n        float dS = res.x;\n        dO += dS;\n        matId = res.y;\n        \n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO, matId);\n}\n\nvec3 normals(vec3 p, float of ) {\n\tfloat d = getDist(p).x;\n    vec2 e = vec2(of, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p-e.xyy).x,\n        getDist(p-e.yxy).x,\n        getDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\n//https://www.shadertoy.com/view/lllBDM\nvec3 shade( in vec3 p, in vec3 n, in vec3 ro, in vec3 rd, vec3 lp,vec3 ld) {\t\t\n\tfloat latt = pow(length(lp-p)*.15, 3.) * 4.;\n\tvec3 diff = vec3(.0,.5,1.) * (max(dot(n, ld),0.) ) / latt;\n    vec3 col =  diff * 0.1;\n\tfloat trans =  pow( clamp( dot(-rd, -ld+n), 0., 1.), 1.) + 1.;\n\tcol += vec3(1.,.2,.35) * (trans / latt ) ;\n    col += vec3(specular(p, rd, n, lp)) * 0.25;\n    col += smoothstep(1., 0.6, dot(-rd, n)) * 0.1;\n\n\treturn col;\n}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 mo = vec2(0.5, -0.3) * vec2(sin(iTime / 2.), max(cos(iTime / 2.), 0.)) * 0.4;\n    #if defined(MOUSE_CONTROL) \n    mo = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    #endif\n    \n    vec3 col = vec3(0.0);\n    \n    float iTime = iTime * 2.;\n\n\tvec3 ro =  vec3( 0.0, 0.5, 7.);\n    vec3 rd = rayDir(45.0 , iResolution.xy, fragCoord.xy);\n\n\tmat3 rot = rotationXY(mo.yx  * PI);\n\trd = rot * rd;\n\tro = rot * ro;\n    \n    vec2 d = rayMarch(ro, rd);\n    vec3 p = ro + rd * d.x;\n    vec3 n = normals(p, 0.003);\n    vec3 lp =  vec3(-3. , -1., 5.);\n\n    if (d.y == 1. || d.y == 2.) {\n        col = shade(p, n, ro, rd, lp, lp - p);\n    }\n    \n    if (d.y == 2.) {\n        float dif = diffuse(p, n, lp);\n        float spec = specular(p, rd, n, lp);\n        vec3 bc = vec3(10., 14., 19.) / 255.;\n        col += mix(bc, vec3(0.5, 0.5, 1.) * (dif + spec), smoothstep(0., 1., dot(-rd, n)));\n     }\n   \n   if (d.y == 0. || d.x > MAX_DIST) {  \n        col = vec3(0.);\n    }  \n    \n    \n    fragColor = vec4(vec3(col),1.0);\n}", "buffer_a_inputs": [], "buffer_b_code": "// FXAA implementation from\n// https://www.shadertoy.com/view/4tf3D8\n#define RES iResolution.xy\n\nvec3 fxaa(vec2 p) {\n\tconst float FXAA_SPAN_MAX   = 16.0;\n    const float FXAA_REDUCE_MUL = 1.0 / 16.0;\n    const float FXAA_REDUCE_MIN = 1.0 / 128.0;\n\n    vec3 rgbNW = tex(p + (vec2(-1.,-1.) / RES));\n    vec3 rgbNE = tex(p + (vec2( 1.,-1.) / RES));\n    vec3 rgbSW = tex(p + (vec2(-1., 1.) / RES));\n    vec3 rgbSE = tex(p + (vec2( 1., 1.) / RES));\n    vec3 rgbM  = tex(p);\n\n    const vec3 luma = vec3(1.0/3.0);\n\n    float lumaNW = dot(rgbNW, luma);\n    float lumaNE = dot(rgbNE, luma);\n    float lumaSW = dot(rgbSW, luma);\n    float lumaSE = dot(rgbSE, luma);\n    float lumaM  = dot(rgbM,  luma);\n\n    vec2 dir;\n    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n    \n    float lumaSum   = lumaNW + lumaNE + lumaSW + lumaSE;\n    float dirReduce = max(lumaSum * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n    float rcpDirMin = 1. / (min(abs(dir.x), abs(dir.y)) + dirReduce);\n\n    dir = min(vec2(FXAA_SPAN_MAX), max(vec2(-FXAA_SPAN_MAX), dir * rcpDirMin)) / RES;\n\n    vec3 rgbA = .5 * (tex(p + dir * (1./3. - .5)) +\n        \t\t\t  tex(p + dir * (2./3. - .5)));\n    vec3 rgbB = rgbA * .5 + .25 * (\n        \t\t\t  tex(p + dir * (0./3. - .5)) +\n        \t\t\t  tex(p + dir * (3./3. - .5)));\n    \n    float lumaB = dot(rgbB, luma);\n    \n    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\n    return ((lumaB < lumaMin) || (lumaB > lumaMax)) ? rgbA : rgbB;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 uv = fragCoord.xy / iResolution.xy;  \n    vec3 col = fxaa(uv);\n    \n    fragColor = vec4(col, 1.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "untested"}
{"id": "7tSfzV", "name": "iRay", "author": "i11212", "description": "Free to use", "tags": ["ex"], "likes": 1, "viewed": 454, "published": 3, "date": "1653232452", "time_retrieved": "2024-07-30T16:47:43.894527", "image_code": "highp float hash(\n\thighp vec2 x){\nreturn fract(sin(dot(\n\tx,vec2(1,57)))*4e5);\n\t}\n\n#define saturate(x) clamp(x,0.0,1.0)\n#define chroma_key(x) x.g > x.b+x.r\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 uv = fragCoord/iResolution.xy;\n\nvec3 col = texture (iChannel0, uv).rgb;\nvec2 lightpos = vec2(0.5,0.5);\nuv -= lightpos;\nvec4 ray = texture(iChannel0,(uv*hash(\nfloor(uv*iResolution.xy))+lightpos));\n\nray.a = float(chroma_key(ray));\n     /*you can replace \n     this with luma*/\n\nif(chroma_key(col))\n     col = vec3(0);\n     //background\n\ncol = mix(col, vec3(1)/*rayColor*/,\n      ray.a*saturate(1.0-length(uv)));\n\n//float sound = texelFetch(iChannel1, ivec2(1), 0).a;\n//col *= sound;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29016, "src": "https://soundcloud.com/aryan-verma-651718575/naruto-flute?utm_source=mobi&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSfzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 213, 213, 734]], "test": "untested"}
{"id": "fsdyR7", "name": "analysing DoF algo in Xor's \"Typ", "author": "FabriceNeyret2", "description": "analysing filtering of \"The Typist\" by Xor. https://shadertoy.com/view/sd3czM\n\nclick and drag mouse to see the filtering footprint in texture space  ( magnified 5x )\nsampling:   left: original (128 samples)   right: adaptive\n\n", "tags": ["dof", "bokeh", "depthoffield", "fibonacci", "goldenspiral"], "likes": 7, "viewed": 350, "published": 3, "date": "1653204374", "time_retrieved": "2024-07-30T16:47:44.741263", "image_code": "// analysing filtering of \"The Typist\" by Xor. https://shadertoy.com/view/sd3czM\n\n#define T(U)         vec4( texture(iChannel0, (U)/R).rgb, 1)\n#define rot(a)       mat2( cos(a), sin(a), -sin(a), cos(a) )\n#define GOLDEN_ANGLE 2.3999632\n\n\n//#define sampling  16.\n//#define sampling  max(2., 69.*abs(p.x))\n  #define sampling ( U.x < R.x/2. ? 16. :  max(2., 69.*abs(p.x)) )\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    vec2  R = iResolution.xy,\n          p = vec2( dot( U+U-R , vec2(1,-5)/5e3 ), 0); // projection of direction along view axis \n    float r = sampling;\n    \n    O-=O;\n    // i grows as sqrt(2*count) , see https://www.shadertoy.com/view/fstyR7\n    // average texture along a pseudoGaussian ring of radius |p| ~ projection of direction along view axis \n    for(float i=1.; i<r; i+=1./i)\n        p *= rot(GOLDEN_ANGLE), // -mat2(.737, .676, -.676, .737),\n        O += T(U+p*i*16./r);\n  \n    O = sqrt(O/O.a);  // normalize + to sRGB\n    \n    vec2 M = iMouse.xy;\n  if (iMouse.z>0.|| length(M)<10. ) {  // --- if mouse click, show texture sampling footprint\n    O *= .5;                                     // fade previous image\n    if ( length(M)<10. ) M = R/2. + R/3.*cos(iTime+vec2(0,33)); // demo mode\n    p = vec2( dot( M+M-R , vec2(1,-5)/5e3 ), 0); // projection of direction along view axis \n    r = sampling;\n    for(float i=1.; i<r; i+=1./i)\n         p *= rot(GOLDEN_ANGLE), // -mat2(.737, .676, -.676, .737),\n        O = max( O, smoothstep(1.5,0.,length( M+p*i*5.*16./r - U )) );\n  }\n  if (int(U)==int(R)/2) O = vec4(1,0,0,1);       // red separator\n}", "image_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdyR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[371, 371, 407, 407, 1565]], "test": "untested"}
{"id": "NdtyRM", "name": "Pixel Line Equation", "author": "SnoopethDuckDuck", "description": "A simpler and more correct (but less general) way of doing what I've done here:\nhttps://www.shadertoy.com/view/7lffzj\n\nShould be useful for pixel art ", "tags": ["pixelart"], "likes": 8, "viewed": 327, "published": 3, "date": "1653183887", "time_retrieved": "2024-07-30T16:47:45.551098", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sc = mix(0.25, 0.1, tanh(iTime));\n    vec3 col = texelFetch(iChannel0, ivec2(sc *fragCoord), 0).rgb;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float pxLine(vec2 f, vec2 p, vec2 q) {\n    f -= p;\n\n    vec2 dir = 0.5 * (q - p);\n    \n    float d = min(abs(f.x - round(dir.x/dir.y * f.y)),\n                  abs(f.y - round(dir.y/dir.x * f.x)));\n                          \n    return step(d, 0.) * step(abs(f.x - dir.x), abs(dir.x))\n                       * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\n// Old version:\n/*\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n\n    // Get direction from p to q, use for gradient and bounding box dimensions\n    vec2 dir = 0.5 * (q - p);\n    \n    // Look at the line as a function of x, and as a function of y\n    float l = max( step(abs(f.x - round(dir.x/dir.y * f.y)), 0.),\n                   step(abs(f.y - round(dir.y/dir.x * f.x)), 0.) );\n               \n    // Restrict to the box bounded by p and q           \n    return l * step(abs(f.x - dir.x), abs(dir.x))\n             * step(abs(f.y - dir.y), abs(dir.y));           \n}\n\n// Old Old version:\n/*\nfloat pxLine(vec2 f, vec2 p, vec2 q) {\n    // Centre the coordinates at p\n    f -= p;\n    \n    vec2 dir = 0.5 * (q - p);\n    float a = atan(dir.y, dir.x) - 3.14159/4.;\n    float v = (cos(a)-sin(a))/(cos(a)+sin(a));\n    \n    // Is pixel within 0.5 of the line?\n    // Look at the line as a function of x, and as a function of y\n    // (smoothstep for anti-aliasing works well too: ss(-.5,.5,...))\n    float l = max( step(abs(f.x - v*f.y), 0.5), \n                   step(abs(f.x/v - f.y), 0.5) );\n        \n    // Restrict to the box bounded by p and q\n    return l * step(abs(f.x - dir.x), abs(dir.x))\n             * step(abs(f.y - dir.y), abs(dir.y));\n}\n*/\n\nvoid mainImage( out vec4 fragColor, in vec2 f )\n{\n    vec3 col = vec3(0);\n   \n    // fragCoord must be offset by 0.5\n    f -= vec2(30,20) - 0.5;\n\n    // pxLine must take rounded positions as inputs \n    vec2 p = round(10. * vec2(cos(iTime), sin(1.25 * iTime)));\n    vec2 q = round(14. * vec2(cos(1.15 * iTime), sin(iTime)));\n\n    // Draw the origin + points\n    col   += step(length(f), 0.);\n    col.r += step(length(f - p), 0.);\n    col.g += step(length(f - q), 0.);\n    \n    // Draw the line\n    col.b += pxLine(f, p, q);      \n   \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdtyRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 206]], "test": "untested"}
{"id": "ssccR7", "name": "Mationi - White Neon Border", "author": "juanpetrik", "description": "White neon border", "tags": ["whiteneonborder"], "likes": 6, "viewed": 354, "published": 3, "date": "1653172887", "time_retrieved": "2024-07-30T16:47:46.394842", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p1 = vec2(.01, .01);\n    vec2 p2 = vec2(.99, .99);\n    vec2 p3 = vec2(.01, .99);\n    vec2 p4 = vec2(.99, .01);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c2 = texture(iChannel0, uv + iTime/10.);\n    \n    float d1 = step(p1.x,uv.x)*step(uv.x,p4.x)*abs(uv.y-p1.y)+\n        step(uv.x,p1.x)*distance(uv,p1)+step(p4.x,uv.x)*distance(uv,p4);\n    d1 = min(step(p3.x,uv.x)*step(uv.x,p2.x)*abs(uv.y-p2.y)+\n        step(uv.x,p3.x)*distance(uv,p3)+step(p2.x,uv.x)*distance(uv,p2),d1);\n    d1 = min(step(p1.y,uv.y)*step(uv.y,p3.y)*abs(uv.x-p1.x)+\n        step(uv.y,p1.y)*distance(uv,p1)+step(p3.y,uv.y)*distance(uv,p3),d1);\n    d1 = min(step(p4.y,uv.y)*step(uv.y,p2.y)*abs(uv.x-p2.x)+\n        step(uv.y,p4.y)*distance(uv,p4)+step(p2.y,uv.y)*distance(uv,p2),d1);\n        \n    float f1 = .01 / abs(d1 + c2.r/100.);\n    \n\tfragColor = vec4(f1 * vec3(0.5, 0.6, 0.8), 1.0);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssccR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 933]], "test": "untested"}
{"id": "NddcR4", "name": "Mationi - White Border", "author": "juanpetrik", "description": "White Border", "tags": ["mationiwhiteborder"], "likes": 1, "viewed": 176, "published": 3, "date": "1653172882", "time_retrieved": "2024-07-30T16:47:47.185727", "image_code": "#define A .0 // Amplitude\n#define V 8. // Velocity\n#define W 9. // Wavelength\n#define T .07 // Thickness\n#define S 2. // Sharpness\n#define GAP vec2(0.006, 0.008) //gap for edge\n\nfloat sine(vec2 p){\n    return pow(T / abs((p.y + 0.0)), S);\n}\n\nbool detectEdge(vec2 fCoord, vec2 gap) {\n    vec2 uv = fCoord.xy / iResolution.xy;\n    vec2 edgeDistance = 0.5 -  abs(uv - 0.5);\n    \n    bvec2 edgeCompare = lessThan(edgeDistance, gap);\n    bool isEdge = edgeCompare.x || edgeCompare.y;\n    \n    return isEdge;\n}\n\nfloat blurEdge(vec2 fCoord, vec2 gap) {\n    vec2 uv = fCoord.xy / iResolution.xy;\n    \n    if(uv.y > (1.0 - gap.y)) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.y - (1.0 - gap.y)), S);\n        return blurValue;\n    } \n    \n    if(uv.y < gap.y) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.y - gap.y), S);\n        return blurValue;\n    }\n    \n    if(uv.x > (1.0 - gap.x)) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.x - (1.0 - gap.x)), S);\n        return blurValue;\n    } \n    \n    if(uv.x < gap.x) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.x - gap.x), S);\n        return blurValue;\n    } \n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(detectEdge(fragCoord, GAP)) {\n        float channelColor = blurEdge(fragCoord, GAP);\n    \tfragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    } else {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 197, 197, 240], [242, 242, 282, 282, 504], [506, 506, 545, 545, 1125], [1127, 1127, 1184, 1184, 1383]], "test": "untested"}
{"id": "7sccR7", "name": "Mationi - Static Blue Border", "author": "juanpetrik", "description": "Mationi - Static Blue Border", "tags": ["staticblueborder"], "likes": 2, "viewed": 203, "published": 3, "date": "1653172878", "time_retrieved": "2024-07-30T16:47:48.025483", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p1 = vec2(.01, .01);\n    vec2 p2 = vec2(.99, .99);\n    vec2 p3 = vec2(.01, .99);\n    vec2 p4 = vec2(.99, .01);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c2 = texture(iChannel0, uv + iTime/10.);\n    \n    float d1 = step(p1.x,uv.x)*step(uv.x,p4.x)*abs(uv.y-p1.y)+\n        step(uv.x,p1.x)*distance(uv,p1)+step(p4.x,uv.x)*distance(uv,p4);\n    d1 = min(step(p3.x,uv.x)*step(uv.x,p2.x)*abs(uv.y-p2.y)+\n        step(uv.x,p3.x)*distance(uv,p3)+step(p2.x,uv.x)*distance(uv,p2),d1);\n    d1 = min(step(p1.y,uv.y)*step(uv.y,p3.y)*abs(uv.x-p1.x)+\n        step(uv.y,p1.y)*distance(uv,p1)+step(p3.y,uv.y)*distance(uv,p3),d1);\n    d1 = min(step(p4.y,uv.y)*step(uv.y,p2.y)*abs(uv.x-p2.x)+\n        step(uv.y,p4.y)*distance(uv,p4)+step(p2.y,uv.y)*distance(uv,p2),d1);\n        \n    float f1 = .01 / abs(d1 + c2.r/100.);\n    \n\tfragColor = vec4(f1 * vec3(0.1, 0.3, 0.8), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sccR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 933]], "test": "untested"}
{"id": "fsdcR4", "name": "Mationi - Random Color Border", "author": "juanpetrik", "description": "Random Color Border", "tags": ["mationi"], "likes": 2, "viewed": 215, "published": 3, "date": "1653172873", "time_retrieved": "2024-07-30T16:47:48.808389", "image_code": "#define A .0 // Amplitude\n#define V 8. // Velocity\n#define W 9. // Wavelength\n#define T .07 // Thickness\n#define S 2. // Sharpness\n#define GAP vec2(0.006, 0.008) //gap for edge\n\nfloat sine(vec2 p){\n    return pow(T / abs((p.y + 0.0)), S);\n}\n\nbool detectEdge(vec2 fCoord, vec2 gap) {\n    vec2 uv = fCoord.xy / iResolution.xy;\n    vec2 edgeDistance = 0.5 -  abs(uv - 0.5);\n    \n    bvec2 edgeCompare = lessThan(edgeDistance, gap);\n    bool isEdge = edgeCompare.x || edgeCompare.y;\n    \n    return isEdge;\n}\n\nfloat blurEdge(vec2 fCoord, vec2 gap) {\n    vec2 uv = fCoord.xy / iResolution.xy;\n    \n    if(uv.y > (1.0 - gap.y)) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.y - (1.0 - gap.y)), S);\n        return blurValue;\n    } \n    \n    if(uv.y < gap.y) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.y - gap.y), S);\n        return blurValue;\n    }\n    \n    if(uv.x > (1.0 - gap.x)) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.x - (1.0 - gap.x)), S);\n        return blurValue;\n    } \n    \n    if(uv.x < gap.x) {\n    \tfloat blurValue = 1.0 - pow(T / abs(uv.x - gap.x), S);\n        return blurValue;\n    } \n    \n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    if(detectEdge(fragCoord, GAP)) {\n        \n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = fragCoord/iResolution.xy;\n\n        // Time varying pixel color\n        vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n        fragColor = vec4(col,1.0);\n    } else {\n    \tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsdcR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 197, 197, 240], [242, 242, 282, 282, 504], [506, 506, 545, 545, 1125], [1127, 1127, 1184, 1184, 1525]], "test": "untested"}
{"id": "7dccR7", "name": "Mationi - Blue Neon Border", "author": "juanpetrik", "description": "Mationi - Blue Neon Border", "tags": ["blueneon"], "likes": 6, "viewed": 488, "published": 3, "date": "1653172869", "time_retrieved": "2024-07-30T16:47:49.665098", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p1 = vec2(.01, .01);\n    vec2 p2 = vec2(.99, .99);\n    vec2 p3 = vec2(.01, .99);\n    vec2 p4 = vec2(.99, .01);\n\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c2 = texture(iChannel0, uv + iTime/10.);\n    \n    float d1 = step(p1.x,uv.x)*step(uv.x,p4.x)*abs(uv.y-p1.y)+\n        step(uv.x,p1.x)*distance(uv,p1)+step(p4.x,uv.x)*distance(uv,p4);\n    d1 = min(step(p3.x,uv.x)*step(uv.x,p2.x)*abs(uv.y-p2.y)+\n        step(uv.x,p3.x)*distance(uv,p3)+step(p2.x,uv.x)*distance(uv,p2),d1);\n    d1 = min(step(p1.y,uv.y)*step(uv.y,p3.y)*abs(uv.x-p1.x)+\n        step(uv.y,p1.y)*distance(uv,p1)+step(p3.y,uv.y)*distance(uv,p3),d1);\n    d1 = min(step(p4.y,uv.y)*step(uv.y,p2.y)*abs(uv.x-p2.x)+\n        step(uv.y,p4.y)*distance(uv,p4)+step(p2.y,uv.y)*distance(uv,p2),d1);\n        \n    float f1 = .01 / abs(d1 + c2.r/100.);\n    \n\tfragColor = vec4(f1 * vec3(0.1, 0.6, 0.8), 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dccR7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 933]], "test": "untested"}
{"id": "sdcyz7", "name": "phantomz000's first shader", "author": "Phantomz000", "description": "Basically phantomz000's first shader", "tags": ["shader", "misc"], "likes": 0, "viewed": 123, "published": 3, "date": "1653169690", "time_retrieved": "2024-07-30T16:47:50.561701", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = vec4(uv.y, uv.x, uv.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcyz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 144]], "test": "untested"}
{"id": "ss3cRM", "name": "mecanical screens (color)", "author": "FabriceNeyret2", "description": "Pixels flap with image intensity.\nmouse controls camera\nreference: http://zarfoubo.blogspot.com/2007/11/etranges-miroirs-et-drole-decrans.html", "tags": ["raymarching", "short", "reproduction"], "likes": 19, "viewed": 325, "published": 3, "date": "1653151912", "time_retrieved": "2024-07-30T16:47:51.542079", "image_code": "// variant of https://shadertoy.com/view/sd3cRM\n// variant of https://shadertoy.com/view/7d3yRM\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n\nvoid mainImage_(out vec4 O, vec2 U)\n{\n    float t=9., m; int C,c;\n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          p = 50./R, q,a,                                 // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(15,5,0)/5e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(-6.*M.y),                             // rotations\n        q.xz *= rot(-6.*M.x);\n        a = abs(q);\n        if ( q.z < -1. ) { O-=O;  break; }\n        if ( a.z<2. && max(a.x,a.y) > 15. ) continue;\n        for(int i=0; i<4; i++) {\n          a = q, a.y *= 3.;\n          a.xy = fract(a.xy) - vec2(i%2,i/2),\n          c = int(3.*q.y+99.5)%3,\n          a.xz *= rot(1.57-1.57*texture(iChannel0,round(q.xy)/30.+.5,0.)[c] ),\n          a = abs(a),\n          m = max(max(a.x-.4,a.y-.45),a.z-.02); \n          if (m<t) t = m,C=c;\n        }\n   \n       p += .5*t*D;                                       // step forward = dist to obj          \n   }\n   O[(C+1)%3] = O[(C+2)%3] = 0.;\n   O *= O*O*2.;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)                        // --- smart oversampling\n{\n    mainImage_(O,U); return;\n    if ( fwidth(O.x) > .1 ) {\n        vec4 O_; \n        for(int i=0; i<9; i+=i==3?2:1) {\n            mainImage_(O_,U+vec2(i%3-1,i/3-1)/3. );\n            O += O_;\n        }\n        O /= 9.;  // O.r++;\n    }\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3cRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 186, 223, 223, 1327], [1330, 1330, 1415, 1415, 1652]], "test": "untested"}
{"id": "sd3cRM", "name": "mecanical screens", "author": "FabriceNeyret2", "description": "Pixels flap with image intensity.\nmouse controls camera\nreference: http://zarfoubo.blogspot.com/2007/11/etranges-miroirs-et-drole-decrans.html", "tags": ["raymarching", "short", "reproduction"], "likes": 16, "viewed": 346, "published": 3, "date": "1653151325", "time_retrieved": "2024-07-30T16:47:52.296064", "image_code": "// variant of https://shadertoy.com/view/7d3yRM\n\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n\nvoid mainImage_(out vec4 O, vec2 U)\n{\n    float t=9.; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          p = 60./R, q,a,                                 // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(15,5,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(-6.*M.y),                             // rotations\n        q.xz *= rot(-6.*M.x);\n        a = abs(q);\n        if ( q.z < -1. ) { O-=O;  break; }\n        if ( a.z<2. && max(a.x,a.y) > 15. ) continue;\n        for(int i=0; i<4; i++) \n          a = q,\n          a.xy = fract(a.xy) - vec2(i%2,i/2),\n          a.xz *= rot(1.57-1.57*texture(iChannel0,round(q.xy)/30.+.5,0.).r ),\n          a = abs(a),\n          t = min(t, max(max(a.x-.4,a.y-.45),a.z-.02) ); \n          \n       p += .5*t*D;                                       // step forward = dist to obj          \n   }\n  O*=O*O*2.;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)                        // --- smart oversampling\n{\n    mainImage_(O,U);\n    if ( fwidth(O.x) > .1 ) {\n        vec4 O_; \n        for(int i=0; i<9; i+=i==3?2:1) {\n            mainImage_(O_,U+vec2(i%3-1,i/3-1)/3. );\n            O += O_;\n        }\n        O /= 9.;  // O.r++;   // uncomment to see oversampled pixels\n    }\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sd3cRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[138, 138, 175, 175, 1161], [1164, 1164, 1249, 1249, 1519]], "test": "untested"}
{"id": "7d3yRM", "name": "kinetics facade", "author": "FabriceNeyret2", "description": "shades which torsion let a shape appear.\nmouse controls camera\nreference: https://www.youtube.com/watch?v=ocJHPZLStmM", "tags": ["raymarching", "short", "reproduction"], "likes": 17, "viewed": 258, "published": 3, "date": "1653150978", "time_retrieved": "2024-07-30T16:47:53.116869", "image_code": "\n#define rot(a)       mat2(cos(a+vec4(0,11,33,0)))         // rotation                  \n\nvoid mainImage_(out vec4 O, vec2 U)\n{\n    float t=9.; \n    vec3  R = iResolution,\n          D = normalize(vec3(U+U, -3.5*R.y) - R),         // ray direction\n          p = 60./R, q,a,                                 // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5: vec3(15,5,0)/1e2*cos(iTime+vec3(0,11,0)); // auto thumbnail\n     \n    for (O=vec4(1); O.x > 0. && t > .01; O-=.01) {\n        q = p,\n        q.yz *= rot(-6.*M.y),                             // rotations\n        q.xz *= rot(-6.*M.x);\n        a = abs(q);\n        if ( q.z < -1. ) { O-=O;  break; }\n        if ( a.z<2. && max(a.x,a.y) > 15. ) continue;\n        for(int i=0; i<4; i++)\n          a = q,\n          a.xy = fract(a.xy) - vec2(i%2,i/2),\n          a.xz *= rot(iTime-.5*length(q) ),\n          a = abs(a),\n          t = min(t, max(max(a.x-.4,a.y-.45),a.z-.02) ); \n   \n       p += .5*t*D;                                       // step forward = dist to obj          \n   }\n  O*=O*O*2.;\n}\n\n\nvoid mainImage(out vec4 O, vec2 U)                        // --- smart oversampling\n{\n    mainImage_(O,U);\n    if ( fwidth(O.x) > .1 ) {\n        vec4 O_; \n        for(int i=0; i<9; i+=i==3?2:1) {\n            mainImage_(O_,U+vec2(i%3-1,i/3-1)/3. );\n            O += O_;\n        }\n        O /= 9.;  // O.r++;  // uncomment to see oversampled pixels\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7d3yRM.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 127, 127, 1071], [1074, 1074, 1159, 1159, 1428]], "test": "untested"}
{"id": "Nd3cz7", "name": "Water Tiles", "author": "bmatcuk", "description": "A rather simple shader to play with refractions, noise, and the oklab colorspace.", "tags": ["water"], "likes": 5, "viewed": 299, "published": 3, "date": "1653147876", "time_retrieved": "2024-07-30T16:47:53.911744", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#define GLSLIFY 1\n#endif\n\n// Modulo 289 without a division (only multiplications)\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\n// Permutation polynomial: (34x^2 + 6x) mod 289\nfloat permute(float x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\nvec3 permute(vec3 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\nvec4 permute(vec4 x) {\n  return mod289((34.0 * x + 10.0) * x);\n}\n\n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p, float rot) {\n#if 0\n// Map from a line to a diamond such that a shift maps to a rotation.\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n  u = 4.0 * fract(u) - 2.0;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.0, abs(abs(u+1.0)-2.0)-1.0);\n#else\n// For more isotropic gradients, sin/cos can be used instead.\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot; // Rotate by shift\n  u = fract(u) * 6.28318530718; // 2*pi\n  return vec2(cos(u), sin(u));\n#endif\n}\n\n//\n// 2-D non-tiling simplex noise with rotating gradients and analytical derivative.\n// The first component of the 3-element return vector is the noise value,\n// and the second and third components are the x and y partial derivatives.\n//\nvec3 srdnoise(vec2 pos, float rot) {\n  // Offset y slightly to hide some rare artifacts\n  pos.y += 0.001;\n  // Skew to hexagonal grid\n  vec2 uv = vec2(pos.x + pos.y*0.5, pos.y);\n\n  vec2 i0 = floor(uv);\n  vec2 f0 = fract(uv);\n  // Traversal order\n  vec2 i1 = (f0.x > f0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\n  // Unskewed grid points in (x,y) space\n  vec2 p0 = vec2(i0.x - i0.y * 0.5, i0.y);\n  vec2 p1 = vec2(p0.x + i1.x - i1.y * 0.5, p0.y + i1.y);\n  vec2 p2 = vec2(p0.x + 0.5, p0.y + 1.0);\n\n  // Integer grid point indices in (u,v) space\n  i1 = i0 + i1;\n  vec2 i2 = i0 + vec2(1.0, 1.0);\n\n  // Vectors in unskewed (x,y) coordinates from\n  // each of the simplex corners to the evaluation point\n  vec2 d0 = pos - p0;\n  vec2 d1 = pos - p1;\n  vec2 d2 = pos - p2;\n\n  vec3 x = vec3(p0.x, p1.x, p2.x);\n  vec3 y = vec3(p0.y, p1.y, p2.y);\n  vec3 iuw = x + 0.5 * y;\n  vec3 ivw = y;\n\n  // Avoid precision issues in permutation\n  iuw = mod289(iuw);\n  ivw = mod289(ivw);\n\n  // Create gradients from indices\n  vec2 g0 = rgrad2(vec2(iuw.x, ivw.x), rot);\n  vec2 g1 = rgrad2(vec2(iuw.y, ivw.y), rot);\n  vec2 g2 = rgrad2(vec2(iuw.z, ivw.z), rot);\n\n  // Gradients dot vectors to corresponding corners\n  // (The derivatives of this are simply the gradients)\n  vec3 w = vec3(dot(g0, d0), dot(g1, d1), dot(g2, d2));\n\n  // Radial weights from corners\n  // 0.8 is the square of 2/sqrt(5), the distance from\n  // a grid point to the nearest simplex boundary\n  vec3 t = 0.8 - vec3(dot(d0, d0), dot(d1, d1), dot(d2, d2));\n\n  // Partial derivatives for analytical gradient computation\n  vec3 dtdx = -2.0 * vec3(d0.x, d1.x, d2.x);\n  vec3 dtdy = -2.0 * vec3(d0.y, d1.y, d2.y);\n\n  // Set influence of each surflet to zero outside radius sqrt(0.8)\n  if (t.x < 0.0) {\n    dtdx.x = 0.0;\n    dtdy.x = 0.0;\n\tt.x = 0.0;\n  }\n  if (t.y < 0.0) {\n    dtdx.y = 0.0;\n    dtdy.y = 0.0;\n\tt.y = 0.0;\n  }\n  if (t.z < 0.0) {\n    dtdx.z = 0.0;\n    dtdy.z = 0.0;\n\tt.z = 0.0;\n  }\n\n  // Fourth power of t (and third power for derivative)\n  vec3 t2 = t * t;\n  vec3 t4 = t2 * t2;\n  vec3 t3 = t2 * t;\n\n  // Final noise value is:\n  // sum of ((radial weights) times (gradient dot vector from corner))\n  float n = dot(t4, w);\n\n  // Final analytical derivative (gradient of a sum of scalar products)\n  vec2 dt0 = vec2(dtdx.x, dtdy.x) * 4.0 * t3.x;\n  vec2 dn0 = t4.x * g0 + dt0 * w.x;\n  vec2 dt1 = vec2(dtdx.y, dtdy.y) * 4.0 * t3.y;\n  vec2 dn1 = t4.y * g1 + dt1 * w.y;\n  vec2 dt2 = vec2(dtdx.z, dtdy.z) * 4.0 * t3.z;\n  vec2 dn2 = t4.z * g2 + dt2 * w.z;\n\n  return 11.0*vec3(n, dn0 + dn1 + dn2);\n}\n\n/**\n * Convert OKLab to RGB\n * @param lab Color in OKLab\n * @see https://bottosson.github.io/posts/oklab/\n */\nvec3 oklab2rgb(vec3 lab) {\n  const mat3 m1 = mat3(\n    1.0, 1.0, 1.0,\n    0.3963377774, -0.1055613458, -0.0894841775,\n    0.2158037573, -0.0638541728, -1.2914855480\n  );\n  const mat3 m2 = mat3(\n    4.0767416621, -1.2684380046, -0.0041960863,\n    -3.3077115913, 2.6097574011, -0.7034186147,\n    0.2309699292, -0.3413193965, 1.7076147010\n  );\n  vec3 lms = m1 * lab;\n  return clamp(m2 * (lms * lms * lms), 0.0, 1.0);\n}\n\n/**\n * Convert LCh(oklab) to RGB\n * @param lch Color in LCh(oklab)\n */\nvec3 lchoklab2rgb(vec3 lch) {\n  float hrad = radians(lch.z);\n  vec3 lab = vec3(\n    lch.x,\n    lch.y * cos(hrad),\n    lch.y * sin(hrad)\n  );\n  return oklab2rgb(lab);\n}\n\nfloat _rgbLinear2Component_1540259130(float c) {\n  if (c <= 0.0031308) {\n    return 12.92 * c;\n  }\n  return 1.055 * pow(c, 1.0 / 2.4) - 0.055;\n}\n\n/**\n * Convert linear RGB to RGB\n * @param linear Color in linear RGB\n * @see http://www.brucelindbloom.com/index.html?Eqn_XYZ_to_RGB.html\n */\nvec3 linear2rgb(vec3 linear) {\n  return vec3(\n    _rgbLinear2Component_1540259130(linear.r),\n    _rgbLinear2Component_1540259130(linear.g),\n    _rgbLinear2Component_1540259130(linear.b)\n  );\n}\n\nconst vec3 blue = vec3(0.8, 0.470, 230.0);\nconst vec3 pink = vec3(0.8, 0.470, 280.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float minor_axis = min(iResolution.x, iResolution.y);\n  vec2 st = fragCoord.xy / minor_axis;\n\n  // These values are used to put a roughly 5% border around the whole image.\n  // The border is aligned to an even multiple of 15px so no fractional boxes\n  // will appear. Additionally, since the bottom/left borders may be different\n  // than the top/right depending on how close the edges are to even-15px\n  // rounding, we use an adjustment to recenter the image later on.\n  vec2 borderwidthbl = vec2(15.0 * floor(0.05 * minor_axis / 15.0));\n  vec2 borderwidthtr = iResolution.xy - borderwidthbl;\n  vec2 adjustment = mod(borderwidthtr, 15.0);\n  borderwidthtr = (borderwidthtr - adjustment) / minor_axis;\n  borderwidthbl /= minor_axis;\n  adjustment /= 2.0 * minor_axis;\n\n  // calculate noise - multiply the partial derivatives by 0.5 to \"calm down\"\n  // the waves, otherwise it's too choppy; noise is on a grid roughly 400x400\n  vec3 ndxdy = srdnoise((st + iTime * 0.1) * minor_axis / 400.0, 0.4);\n  vec2 dxdy = ndxdy.yz * 0.5;\n  float n = ndxdy.x;\n\n  // calculate normal from partial derivatives\n  vec3 normal = normalize(vec3(-dxdy.x, -dxdy.y, 1.0));\n\n  // calculate the transmission vector as if we're looking straight down on\n  // some water (with refraction index 1.33)\n  vec3 T = refract(vec3(0.0, 0.0, -1.0), normal, 1.0 / 1.33);\n\n  // follow that vector down 25 units... p represents the offset from our\n  // current position to what we'd be looking at through the water\n  vec2 p = T.xy * 25.0 / (abs(T.z) * minor_axis);\n\n  // imagine under the water is an infinite grid of 15x15px squares - by adding\n  // p to st, we can calculate what part of the grid we'd see at the current\n  // location. The adjustment is used to recenter the image here.\n  vec2 boxpos = p + st - adjustment;\n  if (\n    any(lessThan(boxpos, borderwidthbl)) ||\n    any(greaterThan(boxpos, borderwidthtr))\n  ) {\n    // add a border around the image\n    fragColor = vec4(1.0);\n    return;\n  }\n\n  // dist is how far away we are from a grid line, width is how wide the grid\n  // lines are, pct will be 0 if we're on a grid line and 1 as we move away\n  float boxsize = minor_axis / 15.0;\n  vec2 dist = 1.0 - 2.0 * abs(fract(boxpos * boxsize) - 0.5);\n  vec2 width = vec2(mix(3.0, 3.5, n) * boxsize / minor_axis);\n  vec2 pct = smoothstep(vec2(0.0), width, dist);\n\n  // the color will be a gradient from top right to bottom left and white on\n  // the grid lines\n  vec2 bgpct = gl_FragCoord.xy / iResolution.xy;\n  vec3 color = mix(blue, pink, bgpct.x * bgpct.y);\n  color = mix(vec3(1.0, 0.0, color.z), color, pct.x * pct.y);\n  color = lchoklab2rgb(color);\n  color = linear2rgb(color);\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nd3cz7.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 120, 141, 141, 190], [192, 192, 213, 213, 262], [264, 264, 285, 285, 334], [336, 336, 359, 359, 408], [410, 458, 482, 482, 524], [526, 526, 548, 548, 590], [592, 592, 614, 614, 656], [658, 745, 777, 777, 1309], [1311, 1550, 1586, 1637, 4087], [4089, 4199, 4225, 4225, 4614], [4616, 4687, 4716, 4716, 4854], [4856, 4856, 4904, 4904, 5000], [5002, 5145, 5175, 5175, 5337], [5426, 5426, 5483, 5483, 8173]], "test": "untested"}
{"id": "sddyRN", "name": "von Koch snowflake 2", "author": "FabriceNeyret2", "description": "reference: https://twistedsifter.com/wp-content/uploads/2022/05/Armedforcesday244.gif\n\n( could be smoother at flip time )", "tags": ["fractal", "kifs", "short", "reproduction"], "likes": 16, "viewed": 314, "published": 3, "date": "1653121139", "time_retrieved": "2024-07-30T16:47:54.821312", "image_code": "// snowflake from https://shadertoy.com/view/7sdcz4\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U =   ( u+u - R ) / R.y;\n    float t = iTime, w = 3./R.y;\n \n    t = mod(iTime,3.1416);\n // U *= 1.- ( 2.*smoothstep(3.1416,0.,t) + 1. ) / 6.; // zoom             \n    U *= 1.-  .5* cos(1.608*t);                        // zoom ( 2*pi-acos(1/3) )/pi          \n    U *= mat2(cos(.5*t+vec4(0,11,33,0)));              // rot\n    U.x = abs(U.x)-1.1+.1*cos(2.*t);                   // move close or appart\n    \n    O -= O;                                            // draw the snowflake\n    for( int i = 0; i < 6; i++  )\n        U = length(U) * cos( (mod( 6.*atan(U.y,U.x)+3.14, 6.28)-3.14)/6. +vec2(0,1.57) ),\n        O = max(O, smoothstep( w, -w, U.x+1.73*abs(U.y) - 1. )), // * (i<5? 1.: t/3.1416),\n        U *= 3., U.x -= 2., w *= 3.;\n\n    if (sin(iTime)<0.) O = 1.-O;             \n    O = sqrt(O);                                       // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sddyRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 91, 91, 979]], "test": "untested"}
{"id": "7sdcz4", "name": "short von Koch snowflake (242ch)", "author": "FabriceNeyret2", "description": "from hexagons, using 6-symmetry instead of loop+recursion.", "tags": ["fractal", "kifs", "2tweets", "short"], "likes": 10, "viewed": 256, "published": 3, "date": "1653115918", "time_retrieved": "2024-07-30T16:47:55.749829", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    float w = 3./R.y;\n    O -= O;\n    for( int i = 0; i < 7; i++  )\n        U = length(U) * cos( (mod( 6.*atan(U.y,U.x)+3.14, 6.28)-3.14)/6. +vec2(0,11) ),\n        O += smoothstep( w, -w, U.x+1.73*abs(U.y) - 1. ),\n        U *= 3., U.x -= 2., w *= 3.;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7sdcz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 354]], "test": "untested"}
{"id": "7ddyR4", "name": "pacman map-v2", "author": "jorge2017a2", "description": "pacman map-v2", "tags": ["pacmanmapv2"], "likes": 8, "viewed": 210, "published": 3, "date": "1653099531", "time_retrieved": "2024-07-30T16:47:56.626485", "image_code": "///-----por jorge2017a2\n//pacman map-v2----20-may-2022\n///referencia\n///https://www.shadertoy.com/view/MlGfD3\n\n\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(0.8),b,d)\n#define S2(d,b) smoothstep(8.0*antialiasing(1.0),b,d)\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\nfloat sdBox( in vec2 p, in vec2 b )\n{ vec2 d = abs(p)-b;  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);  }\n\nvec3 DrawFigBorde(vec3 pColObj, vec3 colOut, float distObj )\n{ colOut = mix(colOut,pColObj ,S2( distObj,0.0));\n  colOut = mix(colOut,vec3(0.0) ,S2(abs( distObj)-0.005,0.0));\n  return colOut;\n}\n\n\nvec2 pt60[60]=vec2[](  \nvec2(1,1),vec2(1,2),vec2(1,3),vec2(1,4),vec2(1,5),vec2(2,5),\nvec2(3,5),vec2(4,5),vec2(4,6),vec2(4,7),vec2(4,8),vec2(4,9),\nvec2(4,10),vec2(4,11),vec2(4,12),vec2(3,12),vec2(2,12),vec2(1,12),\nvec2(1,13),vec2(1,14),vec2(2,14),vec2(2,15),vec2(3,15),\nvec2(4,15),vec2(5,15),vec2(6,15),vec2(7,15),vec2(8,15),\nvec2(9,15),vec2(10,15),vec2(10,14),vec2(10,13),vec2(10,12),vec2(11,12),\nvec2(12,12),vec2(13,12),vec2(14,12),vec2(14,11),vec2(14,10),vec2(14,9),\nvec2(14,8),vec2(14,7),vec2(14,6),vec2(14,5),vec2(14,4),vec2(14,3),\nvec2(13,3),vec2(12,3),vec2(11,3),vec2(10,3),vec2(9,3),vec2(8,3),\nvec2(7,3),vec2(6,3),vec2(5,3),vec2(4,3),vec2(4,2),vec2(4,1),vec2(3,1),\nvec2(2,1)  );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    ivec2 pix = ivec2(floor(vec2(1,-1)*(fragCoord-iResolution.xy/2.)/11.)) + 9;\n    ///hacer el mapa\n    if (pix.x>= 0 && pix.x< 19  && pix.y>= 0 &&  pix.y<= 16 ) \n    {  float op= float( heart[pix.x+pix.y*19]);\n        if (op>0.0)\n            col*=vec3(0.0);\n        else\n            col*=vec3(1.0);\n        \n    } else \n     col = vec3(0.0);\n    \n    ///camino de pacman\n    int ind=int(mod(iTime*5.0,60.0));\n    vec2 pos=pt60[ind];\n    float d1= sdBox(vec2( float(pix.x), float(pix.y))- pos, vec2(0.5,0.5) );\n    col= DrawFigBorde(vec3(1.0,1.0,0.0), col, d1 );\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "\nint[323] heart = int[323](\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,\n0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,\n0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,\n0,1,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,1,0,\n0,1,1,1,1,0,1,1,1,0,1,1,1,0,1,1,1,1,0,\n0,0,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,0,0,\n0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,\n0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,\n0,1,1,1,1,1,1,0,0,0,0,0,1,1,1,1,1,1,0,\n0,0,0,0,1,0,1,1,1,1,1,1,1,0,1,0,0,0,0,\n0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0,0,0,0,\n0,1,1,1,1,1,1,1,1,0,1,1,1,1,1,1,1,1,0,\n0,1,0,0,1,0,0,0,1,0,1,0,0,0,1,0,0,1,0,\n0,1,1,0,1,0,0,0,1,0,1,0,0,0,1,0,1,1,0,\n0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,\n0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\n);\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[327, 327, 364, 364, 438], [440, 440, 502, 502, 632], [1323, 1323, 1380, 1380, 2079]], "test": "untested"}
{"id": "fdtyzN", "name": "weird smin", "author": "ArmandB", "description": "A strange version of smin I made while messing around in Desmos", "tags": ["sdf", "smin"], "likes": 5, "viewed": 213, "published": 3, "date": "1653089117", "time_retrieved": "2024-07-30T16:47:57.451281", "image_code": "float weirdsmin(float a, float b, float k){\n    return abs(a*b)-k;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    \n    vec2 c1 = vec2(0.5,0.5);\n    vec2 c2 = iMouse.xy/iResolution.y;\n    if (iMouse.z <= 0.0){\n        c2 = vec2(cos(iTime)/2.0,sin(iTime)/4.0) + vec2(1.0,0.5);\n    }\n\n    vec3 col = vec3(0);\n    col = mix(col, vec3(1), smoothstep(0.0,0.01,weirdsmin(distance(c1, uv)-0.3, distance(c2, uv)-0.2, 0.001)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdtyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 43, 43, 68], [70, 70, 127, 127, 508]], "test": "untested"}
{"id": "NsdyR4", "name": "XY Oscilloscope - Custom Audio", "author": "shyshokayu", "description": "Read the top of code, for steps on how to set up custom audio.", "tags": ["oscilloscope", "framework", "music", "optimized", "xy", "xyoscilloscope"], "likes": 7, "viewed": 391, "published": 3, "date": "1653082816", "time_retrieved": "2024-07-30T16:47:58.288043", "image_code": "/* \n    I n s t r u c t i o n s :\n\n    Since Shadertoy doesn't have support for stereo audio waveform format,\n    you need to get the chrome extension called \"Shadertoy Custom Textures\" (sorry non-chrome users...),\n    after that, reload this page to make sure the extension works,\n    split the single audio file that you want to play into two,\n    one for the left and another for the right audio channel,\n    drag the left channel audio to iChannel0, and right channel audio to iChannel1,\n    then, finally, rewind the playback for both audio channels to sync.\n*/\n\n/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\n#define VISUAL_LINE_COLOR vec3(0.4, 1.0, 0.4)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 2000.0\n\n// The shadertoy audio waveform texture format is fixed to 512, so don't touch this. (As of 2022)\n#define VISUAL_ITERATIONS 512 // Number of iterations to draw the whole line for the current frame\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define lengthSqr(v) dot(v, v)\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    vec2 p = vec2(texture(iChannel0, vec2(t, 1.0)).x, texture(iChannel1, vec2(t, 1.0)).x);\n    p.x = mix(p.x, 0.5, step(p.x, 0.001));\n    p.y = mix(p.y, 0.5, step(p.y, 0.001));\n    p = (p * 4.0) - 2.0;\n    return p;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + lengthSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec2 lp = pointTex(0.0);\n    vec2 cp;\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS);\n    float k;\n    \n    for(int i = 0; i < VISUAL_ITERATIONS; ++i) {\n        k = float(i) * fv;\n        cp = pointTex(k); // Get the point\n        cv = imageVectorScopeLine(lp.xy, cp.xy, uv) * (1.0 - k);\n        v += max(cv, lv);\n        lv = cv;\n        lp = cp;\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv, in float un) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridLineSize = 0.015;\n    float gridSize = 4.0;\n    float gridV =  0.1 * (max(max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.x * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.x * gridSize))), max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.y * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.y * gridSize)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv, in float un) {\n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    un *= 2.0;\n    \n    vec2 uv = (u - (0.5 * iResolution.xy)) * un;\n    \n    vec3 col = mix(\n        imageVectorScope(uv, un),\n        imageOscilloscope(uv, un),\n        texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n    );\n\n    col = pow(col, vec3(1.0 / 1.2));\n\n    col = aces(col);\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    // Essentially for free.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 18, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NsdyR4.jpg", "access": "api", "license": "mit", "functions": [[2482, 2482, 2538, 2538, 2602], [2604, 2604, 2661, 2661, 2698], [2700, 2700, 2756, 2756, 2819], [2821, 2821, 2887, 2887, 2955], [2957, 2957, 3011, 3011, 3079], [3081, 3081, 3132, 3132, 3175], [3177, 3177, 3204, 3204, 3422], [3424, 3424, 3485, 3485, 3771], [3773, 3773, 3814, 3814, 4312], [4314, 4314, 4362, 4362, 5447], [5449, 5449, 5511, 5511, 5770], [5772, 5772, 5805, 5805, 5862], [5864, 5864, 5913, 5913, 7048], [7050, 7050, 7069, 7069, 7157], [7159, 7159, 7198, 7198, 8147]], "test": "untested"}
{"id": "sdcyz4", "name": "Soap MetaBubble", "author": "yasuo", "description": "It's like the soup bubble with the metaball animation.", "tags": ["metaball"], "likes": 18, "viewed": 463, "published": 3, "date": "1653060201", "time_retrieved": "2024-07-30T16:47:59.146747", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 256\n#define MAX_DIST 256.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nvec3 N33(vec3 p) {\n    vec3 a = fract(p*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec3(a.x*a.y,a.y*a.z,a.z*a.x));\n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat metaball(vec3 p, float i, float t) {\n    vec3 n = N33(vec3(i));\n    vec3 p2 = sin(n*t)*0.2;\n    vec3 spp = p-p2;\n    float sp = length(spp)-0.01;\n    return sp;\n}\n\nvec2 GetDist(vec3 p) {\n\n    float k = 0.7;\n    float d = 10.0;\n    float t = iTime*3.0;\n\n    d = smin(d,metaball(p,0.3, t),k); \n    d = smin(d,metaball(p,0.6, t),k); \n    d = smin(d,metaball(p,0.9, t),k); \n\n    vec2 model = vec2(d,MATERIAL);\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n\nfloat charS(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(length(p-vec2(-0.02,0.06))-0.06)-0.02;\n    float d2 = B(p-vec2(0.03,0.02),vec2(0.045,0.04));\n    d = max(-d2,d);\n    \n    d2 = abs(length(p-vec2(-0.02,-0.06))-0.06)-0.02;\n    float d3 = B(p-vec2(-0.06,-0.02),vec2(0.045,0.04));\n    d2 = max(-d3,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat charH(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.06;\n    float d = B(p,vec2(0.02,0.14));\n    p = prevP;\n    float d2 = B(p,vec2(0.08,0.02));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charA(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.04;\n    p*=Rot(radians(-15.0));\n    float d = B(p,vec2(0.02,0.16));\n    p = prevP;\n    float d2 = B(p-vec2(0.0,-0.03),vec2(0.05,0.02));\n    d = min(d,d2);\n    d = max((abs(p.y)-0.09),d);\n    p = prevP;\n    p*=Rot(radians(22.0));\n    d2 =  B(p-vec2(-0.037,-0.12),vec2(0.019,0.12));\n    return d;\n}\n\nfloat charD(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p,vec2(0.02,0.075))-0.04)-0.02;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charE(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = B(p,vec2(0.065,0.13));\n    p.y = abs(p.y)-0.055;\n    float d2 = B(p-vec2(0.03,0.0),vec2(0.065,0.03));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat charR(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p-vec2(-0.01,0.05),vec2(0.03,0.022))-0.04)-0.023;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    p*=Rot(radians(-20.0));\n    d2 = B(p-vec2(0.02,-0.14),vec2(0.02,0.13));\n    p*=Rot(radians(20.0));\n    d2 = max(-p.y-0.132,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat shaderText(vec2 p){\n    vec2 prevP = p;\n    p.y*=0.9;\n    float d = charS(p-vec2(-0.5,0.0));\n    float d2 = charH(p-vec2(-0.34,0.0));\n    d = min(d,d2);\n    d2 = charA(p-vec2(-0.14,0.0));\n    d = min(d,d2);\n    d2 = charD(p-vec2(0.05,0.0));\n    d = min(d,d2);\n    d2 = charE(p-vec2(0.22,0.0));\n    d = min(d,d2);\n    d2 = charR(p-vec2(0.38,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 drawBg(vec2 p, vec3 col){\n    float d = shaderText(p*1.7);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    return col;\n}\n\nvec3 reflectMaterial(vec3 p, vec3 rd, vec3 n) {\n    vec3 r = reflect(rd,n);\n    \n    vec3 refTex = drawBg(p.xy,vec3(max(0.95,r.y)))+(r*sin(iTime)*0.5);\n\n    return refTex;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = reflectMaterial(p,rd,n);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.0);\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = drawBg(uv,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sdcyz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 386, 404, 404, 528], [530, 530, 571, 571, 662], [664, 664, 684, 684, 756], [758, 758, 800, 800, 926], [928, 928, 950, 950, 1189], [1191, 1191, 1249, 1249, 1516], [1518, 1518, 1542, 1542, 1743], [1745, 1745, 1787, 1787, 1982], [1984, 2044, 2081, 2081, 2161], [2164, 2164, 2184, 2184, 2525], [2527, 2527, 2547, 2547, 2729], [2731, 2731, 2751, 2751, 3103], [3105, 3105, 3125, 3125, 3330], [3332, 3332, 3352, 3352, 3538], [3540, 3540, 3560, 3560, 3939], [3941, 3941, 3966, 3966, 4328], [4330, 4330, 4360, 4360, 4450], [4452, 4452, 4499, 4499, 4625], [4627, 4627, 4686, 4686, 4774], [4776, 4776, 4833, 4833, 5426]], "test": "untested"}
{"id": "ssccR4", "name": "fractal box", "author": "me_123", "description": "A simple fractal bounded in a cube.", "tags": ["raymarching", "occlusion", "3dfractal"], "likes": 11, "viewed": 382, "published": 3, "date": "1653059439", "time_retrieved": "2024-07-30T16:48:00.039360", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);//vec4(0.0,0.0,1.0,1.0);\n    fragColor /= fragColor.w;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int it = 10;\nconst float eps = 0.001;\n\nvec3 getRay(in vec3 cameraDir, in vec2 uv) { //get camear ray direction\n    vec3 cameraPlaneU = vec3(normalize(vec2(cameraDir.y, -cameraDir.x)), 0);\n    vec3 cameraPlaneV = cross(cameraPlaneU, cameraDir) ;\n\treturn normalize(cameraDir + uv.x * cameraPlaneU + uv.y * cameraPlaneV);\n}\nvec3 hash33(vec3 p3)\n{ //by Dave_Hoskins https://www.shadertoy.com/view/4djSRW\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\nvec3 rus(in vec3 seed) {\n    return normalize(hash33(seed)-0.5);\n}\nfloat box( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\nvec3 transform(in vec3 p) {\n    float r = 0.4;\n    mat2 rot = mat2(cos(r), -sin(r), sin(r), cos(r));\n    for (int i = 0; i < it; i += 1) {\n        p = abs(p);\n        p *= 2.0;\n        p -= 0.5;\n        p.xy *= rot;\n        p.zx *= rot;\n        p.zy *= rot;\n    }\n    return p;\n}\nfloat sdf(in vec3 p) { //signed distance function - vorinoi inside a sphere\n    vec3 tp = transform(p);\n\treturn max((length(tp)-0.5)*pow(2., -float(it)), box(p, vec3(0.5)));\n}\nvec3 normal( vec3 p)\n{\n    const float h = eps;\n    const vec2 k = vec2(1,-1);\n    return normalize(k.xyy * sdf(p + k.xyy * h) +\n                     k.yyx * sdf(p + k.yyx * h) +\n                     k.yxy * sdf(p + k.yxy * h) +\n                     k.xxx * sdf(p + k.xxx * h));\n}\nstruct hit {\n    vec3 p;\n    vec3 n;\n    float d;\n};\nhit trace(in vec3 ro, in vec3 rd) {\n\tfloat d0 = 0.0;\n    vec3 p;\n    int i;\n    for (i = 0; i < 1000; i += 1) {\n    \tp = ro+rd*d0;\n        float d = sdf(p);\n        d0 += d;\n        if (d < eps || d0 > 100.) break;\n    }\n    if (d0 > 100.) return hit(vec3(-1), vec3(-1), -1.);\n    return hit(p, normal(p), d0);\n}\nvec3 getColor(in vec3 ro, in vec3 rd) {\n    hit t = trace(ro, rd);\n    if (t.d == -1.0) return vec3(0);\n    vec3 np = t.p+t.n*eps*1.25;\n    vec3 nd = normalize(rus(vec3(iFrame))+t.n);\n    hit nt = trace(np, nd);\n    return (nt.d>0.0?vec3(0):vec3(abs(nd)));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord+hash33(vec3(fragCoord.xy, iTime)).xy) - 0.5 * iResolution.xy) / iResolution.y;\n    \n    //camera\n    vec2 m = iMouse.z>0.0?((iMouse.xy)/iResolution.xy) * vec2(6.28, 3.14159263):vec2(0.7, 1.0);\n        \n    vec3 ro = vec3(sin(m.y) * cos(-m.x), sin(m.y) * sin(-m.x), cos(m.y))*1.8;\n    vec3 rd = getRay(-normalize(ro), uv);\n    \n    //render\n    vec3 color = getColor(ro, rd);\n    vec4 old = texelFetch(iChannel0, ivec2(fragCoord.xy), 0);\n    \n    //super sample\n    if (iMouse.z > 0.0) {\n        fragColor = vec4(color, 1);\n        return;\n    };\n    fragColor = vec4(color, 1)+old;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ssccR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 173]], "test": "untested"}
{"id": "fdcyzN", "name": "Maze Truchet", "author": "cmzw", "description": "simple truchet maze", "tags": ["2d", "simple", "truchet"], "likes": 2, "viewed": 232, "published": 3, "date": "1653057605", "time_retrieved": "2024-07-30T16:48:01.039686", "image_code": "float hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float t = iTime / 3.;\n    vec2 p = (2.*I - iResolution.xy) / iResolution.y * 4. + t;\n    vec2 f = fract(p);\n \n    O = vec4(\n        smoothstep(0.05,0.,mix(\n            abs(abs(dot(f,vec2(-1,1)))-.5),\n            abs(abs(dot(f,vec2(1,1))-1.)-.5),\n            step(hash12(floor(p)+floor(t)),.5))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 139], [141, 141, 182, 182, 485]], "test": "untested"}
{"id": "fscyR4", "name": "Custom Julia", "author": "Fraktoler", "description": "Default Julia Set: z = z^2 + c\nHold the mouse in the canvas to generate Julia for c seed corresponding to the mouse.", "tags": ["julia", "mandelbrot", "complex"], "likes": 3, "viewed": 216, "published": 3, "date": "1653050301", "time_retrieved": "2024-07-30T16:48:02.304304", "image_code": "#define MAX_ITER 256\n#define BAILOUT 256.\n#define normalizer vec4(vec3(255.), 400.)\nconst vec4 palette[] = vec4[](\nvec4(0., 7., 100., 0.) / normalizer,\nvec4(32., 107., 203., 64.) / normalizer,\nvec4(237., 255., 255., 168.) / normalizer,\nvec4(255., 170., 0., 257.) / normalizer,\nvec4(0., 2., 0., 343.) / normalizer,\nvec4(0., 7., 100., 400.) / normalizer\n);\n\nvec3 gradient(float x) {\n    int m = palette.length() - 2;\n    while (m > 0) {\n        if (x > palette[m].w) break;\n        else if (x == palette[m].w) return palette[m].rgb;\n        m--;\n    }\n    return mix(palette[m].rgb, palette[m + 1].rgb, smoothstep(palette[m].w, palette[m + 1].w, x));\n}\n\nvec2 toComplex(float zoom, vec2 center, vec2 pixel) {\n    return zoom * (pixel - .5 * iResolution.xy) / iResolution.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.;\n    vec2 center = vec2(0.0);\n    vec2 uv = toComplex(zoom, center, fragCoord);\n    float r;\n    vec2 c, z = uv;\n    if (iMouse.z > 0.001) {\n        c = toComplex(zoom, center, iMouse.xy);\n    } else {\n        c = cis(iTime * pi * 0.1);\n    }\n    int k = 0;\n    float exponent = 3.0;\n    while (k < MAX_ITER) {\n        r = dot(z, z);\n        if (r > BAILOUT) break;\n        z = power(z, exponent) + c;\n        k++;\n    }\n    vec3 col = vec3(0.);\n    if (k != MAX_ITER) {\n        float invln = 1. / log(exponent);\n        float lnlnb = log(log(BAILOUT));\n        float u = 0.7 * log(float(k) + invln*lnlnb - invln*log(.5 * log(r))) - 0.4;\n        col = gradient(fract(u));\n    }\n    fragColor = vec4(col * col,1.);\n}", "image_inputs": [], "common_code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n linearroot(a, b) = -b / a (Solution of a * z + b = 0)\n gamma(z) (Gamma function)\n*/\n#define one vec2(1., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(vec2(2.0, 0.0), powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(vec2(2.0, 0.0), powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 linearroot(in vec2 a, in vec2 b) {\n    return div(-b, a);\n}\n\nvec2 gamma(in vec2 z) {\n    //https://www.shadertoy.com/view/WtlGDN\n    const float[6] p = float[] (2.506628275635, 225.525584619175, -268.295973841305, 80.9030806934622, -5.007578639705, 0.0114684895435);\n    vec2 zz = z.x > 1. ? z : one - z;\n    vec2 m = vec2(p[0], 0.);\n    for (int k = 1; k < p.length(); k++) {\n        m = m + p[k] * recip(zz + vec2(k, 0.));\n    }\n    vec2 zh = zz + vec2(5.65, 0.0);\n    vec2 w = powexp(ln(m) + mul(zz + vec2(.5, 0.), ln(zh)) - ln(zz) - zh);\n    return z.x > 1. ? w : pi * recip(mul(w, sine(pi * z)));\n}\n\n//vec2 W0(in vec2 z) {\n//    //https://www.shadertoy.com/view/3lsGD4\n//    vec2 v = sqrtp(2. * e * (z - i * 0.3678796) + 2.);\n//    vec2 w = 2. * ln(one + 0.8842 * v);\n//    return div(w - ln(one + 0.9294 * ln(one + 0.5106 * v)) - vec2(1.213, 0.), one + recip(w + vec2(4.69483568, 0.)));\n//}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fscyR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[356, 356, 380, 380, 650], [652, 652, 705, 705, 772], [774, 774, 831, 831, 1567]], "test": "untested"}
{"id": "fdccR4", "name": "GI style digits", "author": "jvb", "description": "global illum style digit counter", "tags": ["2d", "counter", "digits"], "likes": 36, "viewed": 458, "published": 3, "date": "1653047045", "time_retrieved": "2024-07-30T16:48:03.077238", "image_code": "\nconst float PI = 3.14159265359;\nfloat seg2(vec2 p, float w2)\n{\n\tfloat w = 0.25;\n\treturn 0.5+(atan(p.y,p.x-w)-atan(p.y,p.x+w))*0.55; \n}\nvec3 digit(vec2 p, int n)\n{\n\tvec3 col = vec3(0);\n\tfloat w = 0.25;\n\tfloat mx = 0.0;\n\tfloat my = 0.0;\n\tvec3 segcol = vec3(1.0);\n\t// middle seg\n\tif (n==2 ||n==3||n==4||n==5||n==6||n==8||n==9) col += segcol*seg2(p, w);\n\t// upper seg\n\tif (n==0||n==2 ||n==3||n==5||n==6||n==7||n==8||n==9) col += segcol*seg2(p-vec2(0,0.5), w);\n\t// lower seg\n\tif (n==0||n==2 ||n==3||n==5||n==6||n==8||n==9) col += segcol*seg2(p-vec2(0,-0.5), w);\n\n\t// left seg up\n\tif (n==0||n==4||n==5||n==6||n==8||n==9) col += segcol*seg2(p.yx-vec2(0.25,-0.25), w*1.0);\n\t// left seg down\n\tif (n==0||n==2||n==6||n==8) col += segcol*seg2(p.yx-vec2(-0.25,-0.25), w*1.0);\n\t\n\n\t// right seg up\n\tif (n==0||n==1||n==2||n==3||n==4||n==7||n==8||n==9) col += segcol*seg2(p.yx-vec2(0.25,0.25), w*1.0);\n\t// right seg down\n\tif (n==0||n==1||n==3||n==4||n==5||n==6||n==7||n==8||n==9) col += segcol*seg2(p.yx-vec2(-0.25,0.25), w*1.0);\n\n\treturn col*0.3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 2.0*( fragCoord.xy / iResolution.xy )-1.0;\n\t\n\tp.x *= iResolution.x/iResolution.y; \n\tvec3 col = vec3(0);\n\t\n\t\n\t\n\n\t\n\t\n\tvec3 segcol = vec3(0.5,0.8,1.0);\n\tint n = int(mod(iTime*10.0, 1000.0)); \n\n\tcol += segcol*digit(p-vec2(-0.75,0.0), n/100);\n\tcol += segcol*digit(p-vec2(+0.0,0.0),  int(mod(float(n/10), 10.0)));\n\tcol += segcol*digit(p-vec2(+0.75,0.0), int(mod(float(n), 10.0)));\n\tcol *= 0.3;\n\tcol += vec3(0.3);\n\tcol *= clamp(vec3(1)-vec3(1)*length(0.125*p.xy), 0.0, 1.0);\n\tfragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdccR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 63, 63, 135], [136, 136, 163, 163, 1033], [1035, 1035, 1092, 1092, 1601]], "test": "untested"}
{"id": "fdccR8", "name": "Grids all the way down", "author": "ruojake", "description": "Grids within grids within grids.", "tags": ["2d", "grid", "pattern"], "likes": 23, "viewed": 426, "published": 3, "date": "1653046083", "time_retrieved": "2024-07-30T16:48:04.066593", "image_code": "// Grids all the way down by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nfloat hash12(vec2 p)\n{\n    vec3 q = fract(p.xyy * vec3(5717./2048., 6451./4096., 1249./512.) + vec3(.5, .125, .25));\n    q += dot(q.xz, p.yx) * .0156253;\n    return fract(dot(q + p.y * .38325, p.xyx / 127.) + dot(q, vec3(2., .25, .125-p.x)) + .4);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    \n    return mat2(c,-s,s,c);\n}\n\nvec3 color(float v)\n{\n    v = fract(v * 13.1257) * 7.;\n    vec3 c = normalize(vec3(1, 1, 1));\n    c.xy *= rot(v);\n    c.yz *= rot(v * 2.);\n    return mix(vec3(c.g), c, 1. + fract(v * 11.) * 2.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\n    float res = 0.;\n    float o = 1.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    \n    for(int i = 0; i < 5; ++i)\n    {\n        o *= s;\n        uv *= r;\n        uv += iTime * .25;\n        vec2 _uv = uv * rot(res * 8.);\n        float fw = fwidth(length(_uv));\n        s = min(s, .75 + min(fract(_uv.x), fract(_uv.y)) / fw * .05);\n        vec2 fuv = 1. - abs(fract(_uv) * 2. - 1.);\n        o = min(o, min(fuv.x, fuv.y) / fw * .75);\n        res = hash12(floor(_uv));\n        uv = uv * 2. + 5.;\n    }\n    \n    vec3 col = clamp(mix(color(res) * res * 2., vec3(res), res), vec3(0), vec3(1)) * o;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdccR8.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[123, 123, 145, 145, 372], [374, 374, 393, 393, 471], [473, 473, 494, 494, 669], [671, 671, 728, 728, 1418]], "test": "untested"}
{"id": "ft2BDG", "name": "SongShu007-Day01", "author": "SongShu007", "description": "learn", "tags": ["2d"], "likes": 2, "viewed": 174, "published": 3, "date": "1653037560", "time_retrieved": "2024-07-30T16:48:04.890390", "image_code": "// \nfloat Circle(vec2 uv, vec2 pos, float r, float blur)\n{\n    float color = length(uv - pos);\n    color = smoothstep(r, r - blur, color); \n    return color;\n}\n// \nfloat Band(float t, float start, float end, float blur)\n{\n    float color = smoothstep(start, start + blur, t); \n    color *= smoothstep(end, end - blur, t);\n    return color;\n}\n// \nfloat Rect(vec2 uv, vec2 pos, float width, float height, float blur)\n{\n    float color = Band(uv.x, pos.x, pos.x + width, blur);\n    color *= Band(uv.y, pos.y - height, pos.y, blur);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    // \n    vec3 lvjing = vec3(1.0, .0, .5);\n    \n    float col;\n    float t = (uv.x*10.)+iTime*2.5+uv.y*3.;\n    float y = sin((.4*10.)+iTime*2.5+uv.y*3.)*.03;\n    float uvx = uv.x;\n    float uvy = uv.y + sin(t)*.03;\n    \n    col = Rect(vec2(uvx, uvy), vec2(-.4, 0.2+y), 0.8, 0.4, 0.01);\n    \n    col *= .6+(cos(t)*1.6)*.2;\n    lvjing *= col;\n    \n    fragColor = vec4(lvjing, .0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2BDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 64, 64, 165], [166, 182, 239, 239, 359], [360, 373, 443, 443, 575], [577, 577, 634, 684, 1178]], "test": "untested"}
{"id": "fddcRH", "name": "low res color is ok", "author": "FabriceNeyret2", "description": "Bottom: luminance  high res + chrominance  low res. \nTop: chrominance only \nin each: chrominance LOD 0-3 then 4-8.    LOD 6 still seems pretty ok\n", "tags": ["illusion", "perception"], "likes": 7, "viewed": 310, "published": 3, "date": "1653033960", "time_retrieved": "2024-07-30T16:48:05.670305", "image_code": "// variant of https://shadertoy.com/view/NddyRH\n\n#define T(U,l) textureLod(iChannel0, (U)/vec2(288./352.,1), l)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u / R * 3.*R.y/288.;                 // normalized coordinates\n    \n    O = T(U, 0.);                                 // high res texture luminance\n    float lum = dot(O, vec4(.21,.72,.07,0) );\n    \n    ivec2 I = ivec2(U/vec2(288./352.,1)); int i = I.x + 4*I.y; // tiles id\n    if (I.x> 3 ) { O = vec4(lum); return; }       // ( right: show lum )\n    \n    vec4 C = T(U, float(i));                      // lowres chrominance\n    if ( i > 7 ) { O = T(U, float(i-8)); return; }// ( top: show it )\n    C -= dot(C, vec4(.21,.72,.07,0) );\n\n    O = lum + C;   // highres luminance + low-res chrominance\n    \n    if ( abs(U.y-2.)<1./48. ) O++;                // separator\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddcRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 151, 151, 859]], "test": "untested"}
{"id": "NddyRH", "name": "color persistance of vision", "author": "FabriceNeyret2", "description": "only 1 every 4 frames is colored.\nStop to check.\n( if you try Britney, switch off the chrominance boost )", "tags": ["illusion", "perception", "pov"], "likes": 8, "viewed": 258, "published": 3, "date": "1653031412", "time_retrieved": "2024-07-30T16:48:06.532998", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;                         // normalized coordinates\n    \n    O = texture(iChannel0, U); O*=O;             // texture (flat space)\n# if 1                                           // boost chrominance    \n    vec4  M = texture(iChannel0, U, 99.); M*=M;\n    float w = min(M.r, min(M.g,M.b)); \n    O = (O-w)/(1.-w);\n# endif \n\n    if (iFrame%4 > 0 ) \n    // O = vec4( dot(O, vec4(.21,.72,.07,0) ) ); // luminance (sRGB)\n    // O = vec4(O.r+O.g+O.b)/3.;                 // ( approx versions cause flickering )\n       O = vec4( dot(O, vec4(.3,.59,.11,0) ) );  // luminance (flat space)\n       \n    O = sqrt(O);                                 // to sRGB\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NddyRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 711]], "test": "untested"}
{"id": "fsccRH", "name": "4D Mandelbulb", "author": "Fraktoler", "description": "4-dimensional version of Mandelbulb\nThis shader shows the 3d XYZ slices of the 4D Mandelbulb.", "tags": ["raymarching", "fractal", "mandelbrot", "mandelbulb", "4d"], "likes": 5, "viewed": 430, "published": 3, "date": "1653017004", "time_retrieved": "2024-07-30T16:48:07.375745", "image_code": "#define MAX_ITER 10\n#define MAX_STEPS 100\n#define MAX_DIST 8.\n#define MIN_DIST .0001\n#define EPSILON .0001\n\n//3 dimensional rotations\n\nvec3 rotate(vec3 p, vec3 rot) {\n    vec2 v = mulComplex(p.yz, cis(rot.x));\n    vec3 p_prime = vec3(p.x, v.xy);\n    v = mulComplex(p_prime.xz, cis(rot.y));\n    p_prime = vec3(v.x, p_prime.y, v.y);\n    v = mulComplex(p_prime.xy, cis(rot.z));\n    p_prime = vec3(v.xy, p_prime.z);\n    return p_prime;\n}\n\n//4 dimensional rotations\n\nvec4 rotateXY(vec4 p, float rot) {\n    mat4 rotXY = mat4(\n    cos(rot), -sin(rot), 0.0, 0.0,\n    sin(rot), cos(rot), 0.0, 0.0,\n    0.0, 0.0, 1.0, 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXY * p;\n}\n\nvec4 rotateXZ(vec4 p, float rot) {\n    mat4 rotXZ = mat4(\n    cos(rot), 0.0, -sin(rot), 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    sin(rot), 0.0, cos(rot), 0.0,\n    0.0, 0.0, 0.0, 1.0\n    );\n    return rotXZ * p;\n}\n\nvec4 rotateZW(vec4 p, float rot) {\n    mat4 rotZW = mat4(\n    1.0, 0.0, 0.0, 0.0,\n    0.0, 1.0, 0.0, 0.0,\n    0.0, 0.0, cos(rot), -sin(rot),\n    0.0, 0.0, sin(rot), cos(rot)\n    );\n    return rotZW * p;\n}\n\n\nvec4 toSpherical(vec4 z) {\n    float r = length(z);\n    return vec4(r, acos(z.wz / vec2(r, length(z.xyz))), atan(z.y, z.x));//2.0 * atan(z.x / (z.y + length(z.xy))));\n}\n\nvec4 toCartesian(vec4 z) {\n    return z.x * vec4(cos(z.y), sin(z.y) * vec3(cos(z.z), sin(z.z) * cis(z.w)));\n}\n\nfloat DE(vec3 v) {\n    vec4 c = vec4(v, sin(iTime * 0.25));\n    vec4 z = toSpherical(c);\n    float power = 8.0;\n    float bailout = 2.0;\n    float dr = 1.0;\n    float r = 0.0;\n    for (int k = 0; k < MAX_ITER; k++) {\n\t\tif (z.x > bailout) break;\n\t\tdr = power * pow(z.x, power - 1.0) * dr + 1.0;\t\t\n\t\tz = toCartesian(vec4(pow(z.x, power), power * z.yzw)) + c;\n        z = toSpherical(z);\n    }\n    return 0.5 * log(z.x) * z.x / dr;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.0;    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = DE(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<MIN_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 normalVector(vec3 p) {\n\tfloat d = DE(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    vec3 n = d - vec3(\n        DE(p-e.xyy),\n        DE(p-e.yxy),\n        DE(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat lighting(vec3 p) {\n    vec3 lightPos = vec3(0.0, -5.0, 5.0);\n    //lightPos = rotate(lightPos, vec3(-0.5, 0., -iTime / 5.));\n    vec3 l = normalize(lightPos - p);\n    vec3 n = normalVector(p);\n    \n    float dif = clamp(dot(n, l), 0.0, 1.0);\n    float d = RayMarch(p + n * MIN_DIST * 2.0, l);\n    //if(d < length(lightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float zoom = 1.5;\n    vec2 uv = zoom * (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    //vec3 rot = vec3(-0.5, 0.0, -iTime / 5.);\n    vec3 ro = vec3(0.0, -3.0, 0.0);\n    //ro = rotate(ro, rot);\n    vec3 rd = normalize(vec3(uv.x, 1.0, uv.y));\n    //rd = rotate(rd, rot);\n\n    float d = RayMarch(ro, rd);\n    \n    vec3 p = ro + rd * d;\n    \n    float dif = lighting(p);\n    vec3 col = vec3(dif);\n    \n    col = pow(col, vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "//Complex (C) functions\nvec2 cis(float theta) {\n    return vec2(cos(theta), sin(theta));\n}\n\nvec2 mulComplex(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fsccRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 166, 166, 433], [462, 462, 496, 496, 666], [668, 668, 702, 702, 872], [874, 874, 908, 908, 1078], [1081, 1081, 1107, 1107, 1249], [1251, 1251, 1277, 1277, 1360], [1362, 1362, 1380, 1380, 1792], [1794, 1794, 1828, 1828, 2028], [2030, 2030, 2057, 2057, 2230], [2232, 2232, 2256, 2256, 2599], [2601, 2601, 2658, 2658, 3145]], "test": "untested"}
{"id": "Ns2yDy", "name": "mouse drag", "author": "ArmandB", "description": "Creates a point that is dragged by the mouse.\nuse it to eliminate jumping when the user clicks somewhere else on the screen", "tags": ["mouse", "buffer"], "likes": 4, "viewed": 225, "published": 3, "date": "1653001387", "time_retrieved": "2024-07-30T16:48:08.213505", "image_code": "//blue dot is last clicked pos\n//red is current mouse pos\n//green is dragged mouse pos\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec4 m = iMouse/iResolution.y;\n    float pxunit = 1.0/iResolution.y;\n    //calculated in buffer a\n    vec2 draggedPos = texelFetch(iChannel0, ivec2(1,0), 0).xy/iResolution.y;\n    \n    vec3 col = texture(iChannel1, uv + draggedPos, 0.0).rgb;\n    \n    col = mix(vec3(0,1,0), col, smoothstep(0.01, 0.01 + pxunit*2.0, distance(uv, draggedPos)));\n    col = mix(vec3(1,0,0), col, smoothstep(0.01, 0.01 + pxunit*2.0, distance(uv, m.xy)));\n    col = mix(vec3(0,0,1), col, smoothstep(0.01, 0.01 + pxunit*2.0, distance(uv, abs(m.zw))));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = vec4(0);\n    if (floor(fragCoord) == vec2(1,0)) {\n        vec2 prevpos = texelFetch(iChannel0, ivec2(1,0), 0).zw; //previous dragged mouse pos\n        vec4 mp = texelFetch(iChannel0, ivec2(2,0), 0); //prev mouse pos\n        vec4 m = iMouse; //current mouse pos\n        \n        //if mouse button up\n        if (m.z < 0.0 && mp.z >= 0.0){\n            col = texelFetch(iChannel0, ivec2(1,0), 0).xyxy;\n        } else if (m.z >= 0.0){\n            col = vec4(m.xy - abs(m.zw) + prevpos, prevpos);\n        } else {\n            col = texelFetch(iChannel0, ivec2(1,0), 0);\n        }\n    }\n    //the last mouse position\n    if (floor(fragCoord) == vec2(2,0)) {\n        col = iMouse;\n    }\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ns2yDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 145, 145, 749]], "test": "untested"}
{"id": "7ddyzr", "name": "XY Oscilloscope Music - Polygons", "author": "shyshokayu", "description": " A short one, again... I have yet to find the motivation to make a catchy, and long music...", "tags": ["oscilloscope", "framework", "music", "optimized", "xy", "xyoscilloscope"], "likes": 31, "viewed": 911, "published": 3, "date": "1652998043", "time_retrieved": "2024-07-30T16:48:09.336503", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\nvec3 getColor(float t) {\n    vec3 col = randomnoise13(floor(t));\n    return col / max(length(col), 0.0001);\n}\n\n#define VISUAL_LINE_COLOR getColor(iTime)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 2000.0\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    // Estimate location based on texture coordinate\n    t *= float(VISUAL_ITERATIONS_HALF);\n    \n    // Convert to int for texelFetch and for more reliable arithmetic\n    int i = int(t);\n    int j = i + 1;\n    \n    // Interpolation between two sampled points\n    ivec2 ip1 = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n    vec4 p1 = texelFetch(iChannel0, ip1, 0).xyzw;\n    \n    vec2 p = mix(p1.xy, p1.zw, fract(t));\n\n    return p;\n}\n\nvec4 pointTexi(in int i) {\n    int r = int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(i % r, i / r), 0).xyzw;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + distanceSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec4 cp;\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS_HALF);\n    float k;\n    \n    for(int i = 0; i < VISUAL_ITERATIONS_HALF; ++i) {\n        k = float(i) * fv;\n        cp = pointTexi(i); // Get the point\n        cv = imageVectorScopeLine(cp.xy, cp.zw, uv) * (1.0 - k);\n        v += max(cv, lv);\n        lv = cv;\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv, in float un) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridLineSize = 0.015;\n    float gridSize = 4.0;\n    float gridV =  0.1 * (max(max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.x * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.x * gridSize))), max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.y * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.y * gridSize)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv, in float un) {\n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    un *= 2.0;\n    \n    vec2 uv = (u - (0.5 * iResolution.xy)) * un;\n    \n    vec3 col = mix(\n        mix(\n            imageVectorScope(uv, un),\n            imageOscilloscope(uv, un),\n            texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n        ),\n        ((texture(iChannel0, (u / iResolution.xy)).xyz * 0.5) + 0.5), // Show cached points visually\n        texelFetch(iChannel3, ivec2(81, 2), 0).x\n    );\n\n    col = pow(col, vec3(1.0 / 1.2));\n\n    col = aces(col);\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    // Essentially for free.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n#define VISUAL_ITERATIONS 600 // Number of iterations to draw the whole line for the current frame\n#define VISUAL_DURATION (2.0 / 60.0) // How long the line should last for a frame\n\n#define VISUAL_ITERATIONS_HALF (VISUAL_ITERATIONS / 2) // Actual texture calls internally, but actual iterations is VISUAL_ITERATIONS (not half)\n\n// Mathematical functions\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n#define rote(r) rot(r * PI)\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\nmat4 matrixTransform(float x, float y, float z) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x  , y  , z  , 1.0\n    );\n}\n\nmat4 matrixTransform(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        p.x, p.y, p.z, 1.0\n    );\n}\n\nmat4 matrixScale(float x, float y, float z) {\n    return mat4(\n        x  , 0.0, 0.0, 0.0,\n        0.0, y  , 0.0, 0.0,\n        0.0, 0.0, z  , 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixScale(vec3 p) {\n    return mat4(\n        p.x, 0.0, 0.0, 0.0,\n        0.0, p.y, 0.0, 0.0,\n        0.0, 0.0, p.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat randomnoise11(float p) {\n    return fract(cos(p * 12.9898) * 43758.5453123);\n}\n\nvec2 randomnoise12(float p) {\n    float x = randomnoise11(p);\n    return vec2(x, randomnoise11(p + x));\n}\n\nvec3 randomnoise13(float p) {\n    float x = randomnoise11(p);\n    float y = randomnoise11(p + x);\n    return vec3(x, y, randomnoise11(p + y));\n}\n\n// Musical functions\n#define pitch(x) (pow(1.059460646483, x) * 440.0)\n\n#define sine(x) sin((x) * PI)\n#define cosine(x) cos((x) * PI)\n#define square(x) ((fract((x) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define cosquare(x) ((fract(((x) + 0.5) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define saw(x) ((fract((x) * 0.5) * 2.0) - 1.0)\n#define cosaw(x) ((fract(((x) + 0.5) * 0.5) * 2.0) - 1.0)\n#define cotriangle(x) (-(abs(fract((x) * 0.5) - 0.5) * 4.0) + 1.0)\n#define triangle(x) cotriangle((x) + 0.5)\n\n// Some musical functions made specifically for this preview\nvec3 hihats(float t) {\n    vec3 p = vec3(0.0);\n\n    p.xy = ((randomnoise12(t) * 2.0) - 1.0) * 0.5 * fract(-t + 0.25);\n    \n    p.xy *= step(fract(t * 2.0), 0.125);\n    \n    return p;\n}\n\nvec3 kick(float t) {\n    float tf = (t * 300.0) - (20.0 * (fract(-t * 0.5) * easeOut(0.0, 0.1, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= 3.0 * fract(-t * 3.0);\n    p *= smoothstep(0.0625, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 kicks(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.25) * 4.0;\n    \n    p += kick(t2);\n    p += kick(t2 - 2.5);\n    \n    return p;\n}\n\nvec3 snare(float t) {\n    float tf = (t * 400.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy = mix(p.xy, ((randomnoise12(t) * 2.0) - 1.0), easeOut(fract(t * 3.0)));\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.25, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snares(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.25) * 4.0;\n    \n    p += snare(t2 - 1.0);\n    p += snare(t2 - 3.0);\n    \n    return p;\n}\n\nvec3 drums(float t) {\n    vec3 p;\n    \n    p += kicks(t);\n    p += snares(t);\n    \n    return p;\n}\n\nfloat freqArpeggiator1(float t) {\n    float s = 0.0;\n    \n    // Repeating pattern for each beat\n    s += fract(floor(t * 4.0) * 0.25) * 8.0;\n    s += ((triangle(floor(t * 1.0) * 0.5) * 0.5) + 0.5) * 8.0;\n    \n    // Offset each bar for some variation\n    s += fract(floor(t * 0.125) * 0.5) * 2.0 * 3.0;\n    \n    return pitch(s - 14.0);\n}\n\n// Fade in at t = (0.0 .. 0.0 + delta) then fade out at t = (1.0 .. 1.0 - delta)\nfloat declick(float t, float delta) {\n    return linearstep(0.0, delta, t) * linearstep(1.0, 1.0 - delta, t);\n}\n\nvec3 polygon(float t, float edges) {\n    t *= edges;\n    float a1 = fract(floor(t) / edges) * 2.0;\n    float a2 = fract(floor((t) + 1.0) / edges) * 2.0;\n    float k = fract(t);\n    \n    return vec3(mix(vec2(sine(a1), cosine(a1)), vec2(sine(a2), cosine(a2)), k), 0.0);\n}\n\n// This is your sandbox:\nvec2 point(float t) {\n    vec3 p = vec3(0.0);\n    \n    t = fract(t / 32.0) * 32.0; // Loop\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    float edges = floor(mix(3.0, 7.0, fract(-t * 0.25)));\n    \n    p = polygon(tf, edges);\n    \n    float vibration = step(0.5, fract(t * 0.125));\n    float vibrationK = mix(1.0, 0.5, step(0.5, fract(t * 0.0625)));\n    p += vec3(sine((tf * vibrationK) + t) * 0.25 * vibration, cosine((tf * vibrationK) + t) * 0.25 * vibration, 0.0);\n    \n    float rt = (t + 0.5) * step(16.0, t);\n    p.yz *= rote(rt * 1.0);\n    p.xy *= rote(rt * 0.5);\n    \n    p *= (easeOut(fract(t)) * 0.5) + 0.5;\n    p *= (fract(-t * 8.0) * 0.125) + 0.875;\n    p *= (fract(-t * 1.0) * 0.25) + 0.75;\n    p *= declick(fract(t * 4.0), 0.01);\n\n    p -= vec3(0.0, 0.0, -2.0);\n    \n    p.xy /= p.z * (1.0 / 1.5);\n    \n    //p.xy *= vec2(sine(t * 2.0), -sine(t * 2.0)) * 0.25 + 0.75;\n    \n    p += step(5.0, t) * hihats(t) * 0.5;\n    p += step(4.0, t) * snares(t) * 0.4;\n    p += step(8.0, t) * kicks(t) * 0.4;\n    \n    p.xy += step(fract(t * 0.5), 0.5) * fract(-t * 2.0) * 0.0625 * ((randomnoise12(tf) * 2.0) - 1.0);\n    \n    return clamp(p.xy, vec2(-1.0), vec2(1.0));\n}\n", "buffer_a_code": "// Samples coordinates every frame instead of sampling every iteration for every pixel for every frame\nvoid mainImage(out vec4 o, in vec2 u) {\n    // Estimate time based on pixel and calculate point\n    u.y -= 0.5; // For some reason this fixes the error where t > VISUAL_ITERATIONS is wrong\n    float t = u.x + (u.y * iResolution.x);\n    \n    // Skip samples if outside used region\n    /*if(t > float(VISUAL_ITERATIONS)) {\n        o = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }*/\n    \n    t *= VISUAL_DURATION / float(VISUAL_ITERATIONS);\n    \n    float tk = (iTime + iTimeDelta) - t;\n    \n    // Output point result\n    o.xy = point(tk);\n    o.zw = point(tk - (VISUAL_DURATION / float(VISUAL_ITERATIONS)));\n}\n", "buffer_a_inputs": [], "sound_code": "vec2 mainSound(int s, float t) {\n    vec2 v = point(t);\n\n    // Some background noise (optional)\n    v += (((texture(iChannel0, vec2(t * 1.4236, t * 1.2267)).xy * 2.0) - 1.0) * 0.0625 * 0.25);\n\n    return v * 0.5; // User convenience, we don't want to destroy any ears\n}\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ddyzr.jpg", "access": "api", "license": "mit", "functions": [[1331, 1331, 1355, 1355, 1440], [1552, 1552, 1608, 1608, 1672], [1674, 1674, 1731, 1731, 1768], [1770, 1770, 1826, 1826, 1889], [1891, 1891, 1957, 1957, 2025], [2027, 2027, 2081, 2081, 2149], [2151, 2151, 2202, 2202, 2245], [2247, 2247, 2274, 2327, 2739], [2741, 2741, 2767, 2767, 2874], [2876, 2876, 2937, 2937, 3225], [3227, 3227, 3268, 3268, 3731], [3733, 3733, 3781, 3781, 4866], [4868, 4868, 4930, 4930, 5189], [5191, 5191, 5224, 5224, 5281], [5283, 5283, 5332, 5332, 6467], [6469, 6469, 6488, 6488, 6576], [6578, 6578, 6617, 6617, 7752]], "test": "untested"}
{"id": "NdcyR8", "name": "30 Minutes 5/18", "author": "scry", "description": "not sure why these spheres are so noisy (beyond the artifacting from polar coords, the refraction doesn't look quite right, weird shading on the edges)\ntimelapse: https://twitter.com/Scrygl/status/1527390966457323520", "tags": ["3d", "refraction"], "likes": 1, "viewed": 222, "published": 3, "date": "1652995278", "time_retrieved": "2024-07-30T16:48:10.170274", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = texture(iChannel0,uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//////////////////////////////////////////\n#define time iTime*0.1\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nvec4 map(vec3 p) {\n    p.z -= 3.;\n    p.xz *= r2d(time/10.);\n    p.yz *= r2d(sin(time*0.5)*1.5);\n    float d = -(length(p)-10.1);\n    float s = 0.5;\n    for (int i=0;i<5;i++) {\n        d = min(d,length(p)-s);\n        p.xz *= r2d(time/1.);\n        p.xz = vec2(length(p.xz),atan(p.x,p.z));\n        p.z *= 1.;\n        p.z = fract(p.z)-0.5;\n        p.xz = vec2(p.x*sin(p.z),p.x*cos(p.z));\n        p.z -= s*3.14;\n        s *= 0.5;\n        d = min(d,length(p)-s*0.2);\n    }\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd, float side) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<96;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w*side;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 100. || dS< 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001, 0.);\n    return normalize(vec3(\n        map(p-h.xyy).w-map(p+h.xyy).w,\n        map(p-h.yxy).w-map(p+h.yxy).w,\n        map(p-h.yyx).w-map(p+h.yyx).w\n    ));\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d) {\n    vec3 col = 1.-d.xxx/8.;\n    col -= n*0.1;\n    //col = clamp(col,0.,1.);\n    if (d.x > 99.) {\n        col *= 0.;\n        col = d.yyy;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd,1.);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    float ior = 1.1;\n    float rl = 0.99;\n    vec3 oro = ro;\n    vec3 ord = rd;\n    vec2 od = d;\n    vec3 ocol = colo(p,n,d);\n    col += ocol;\n    for (int i=0;i<1;i++) {\n        ro = p+n*0.003;\n        rd = refract(p,-n,1./ior);\n        d = RM(ro,rd,-1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*rl*0.5;\n        ro = p-n*0.003;\n        rd = refract(p,n,ior);\n        if (dot(rd,rd)==0.) {rd = 1.-reflect(rd,n);}\n        d = RM(ro,rd,1.);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*rl*0.5;\n        rl *= rl;\n    }\n    col *= 0.5;\n    ////col -= 1.;\n    col *= ocol;\n    //col *= 0.1;\n    //col += d.xxx/8.;\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NdcyR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 280]], "test": "untested"}
{"id": "fddczr", "name": "Raytracing 1 owo", "author": "vainstains", "description": "jhb", "tags": ["rtx"], "likes": 2, "viewed": 248, "published": 3, "date": "1652990602", "time_retrieved": "2024-07-30T16:48:11.056903", "image_code": "vec3 sundir = vec3(0.);\n// vertical\nfloat sdCylinder(vec3 p,vec2 h)\n{\n    vec2 d=abs(vec2(length(p.xz),p.y))-h;\n    return min(max(d.x,d.y),0.)+length(max(d,0.));\n}\nvec3 getBumpMap(vec3 pos)\n{\n    return texture(iChannel1,pos.xz).xyz/10.;\n}\nfloat Dist(vec3 pos)\n{\n    float sphere = length(pos-vec3(0.,0.,3.))-1.;\n    return min(min(sphere, pos.y+1.),sdCylinder(pos-vec3(2,0,3),vec2(0.5,1)));\n}\nfloat Dist1(vec3 pos)\n{\n    float sphere = length(pos-vec3(0.,0.,3.))-1.;\n    float a = min(min(sphere, pos.y+1.),sdCylinder(pos-vec3(2,0,3),vec2(0.5,1)));\n    return a*a*a/2000000000.+0.1;\n}\nfloat rand(vec2 co){\n  return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nvec3 EstimateNormal(vec3 pos)\n{\n    vec3 norm = vec3(0.);\n    vec3 posx = pos;\n    vec3 posy = pos;\n    vec3 posz = pos;\n    posx.x+=0.01f;\n    posy.y+=0.01f;\n    posz.z+=0.01f;\n    float distx = (Dist(posx)-Dist(pos))*100.;\n    float disty = (Dist(posy)-Dist(pos))*100.;\n    float distz = (Dist(posz)-Dist(pos))*100.;\n    return normalize(vec3(distx,disty,distz));\n}\nfloat EstimateAO(vec3 pos)\n{\n    vec3 norm = vec3(0.);\n    vec3 posx = pos;\n    vec3 posy = pos;\n    vec3 posz = pos;\n    posx.x+=0.002f;\n    posy.y+=0.002f;\n    posz.z+=0.002f;\n    float distx = (Dist1(posx)-Dist1(pos))*1.;\n    float disty = (Dist1(posy)-Dist1(pos))*1.;\n    float distz = (Dist1(posz)-Dist1(pos))*1.;\n    return length(vec3(distx+disty+distz)-pos)*0.3/length(pos-vec3(0,1.,0.));\n}\nfloat shadow(vec3 pos,float seed)\n{\n    vec3 ray = pos+(EstimateNormal(pos)/200.);\n    vec3 dir = sundir+(EstimateNormal(pos)*rand(pos.xy+vec2(seed))/5.);\n    float dist = Dist(ray);\n    for(int i = 0; i<100; i++)\n    {\n        float dist = Dist(ray);\n        ray += dir*dist;\n        \n    }\n    bool hit = Dist(ray)<0.0005;\n    return hit?2.:0.5;\n}\n\n\nvec3 HitRay(vec2 scrcoord)\n{\n    vec3 col = vec3(0.3,0.8,0.9);\n    \n    sundir = vec3((iMouse.xy-(iResolution.xy/2.))/80.,2.);\n    sundir/=length(sundir);\n    vec3 ray = vec3(1.,0.5,0.);\n    vec3 dir = vec3(scrcoord.xy, 1.)/length(vec3(scrcoord.xy, 1.));\n    float dist = Dist(ray);\n    float steps=0.;\n    for(int i = 0; i<1000; i++)\n    {\n        float dist = Dist(ray);\n        ray += dir*dist;\n        if(dist>0.001)\n           steps += 0.3;\n    }\n    bool hit = Dist(ray)<0.001;\n    float AO = EstimateAO(ray-EstimateNormal(ray)/20.);\n    if(!hit)\n    {\n        col = vec3(0.3,0.8,0.9)*(1.+(dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir))/3.);\n        col = col + (vec3(1,1,0.3)-col)*clamp(dot(dir,sundir)-0.8,0.,1.);\n        col = col + (vec3(1,1,1)-col)*clamp((dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)-0.95)*300.,0.,1.);\n        \n    }\n    else\n    {\n        float sunlight = (dot(EstimateNormal(ray),sundir)-0.5);\n        float shadow = 1.-(0.5*((shadow(ray,1.+iTime)+shadow(ray,2.+iTime)+shadow(ray,3.+iTime)+shadow(ray,4.+iTime)+shadow(ray,5.+iTime)+shadow(ray,6.+iTime)+shadow(ray,7.+iTime))/7.));\n        if(ray.y>-1.01){shadow/=2.;shadow+=0.5;\n            col = (ray.y<-1.+0.001?(texture(iChannel0,ray.xz).xyz):vec3(1.,1.,1.))*((shadow*2.)+(sunlight+4.)/3.)/4.;\n        }\n        steps /= 2.;\n        steps += EstimateAO(ray);\n        steps /=length(ray-vec3(0,1.,0.));\n        col *= 1.-((AO)+(steps*steps)/16.)/2.;\n        col *= 1.5;\n    }\n    vec3 col1 = vec3(1);\n    vec3 col2 = col;\n    int reflections = 2;\n    if(ray.y<-0.999){reflections=1;}\n    for(int i1 = 0; i1<2; i1++)\n    {\n    if(hit)\n    {\n        dir = reflect(dir,EstimateNormal(ray)+(getBumpMap(ray)/8.));\n        ray += EstimateNormal(ray)/200.;\n        for(int i = 0; i<100; i++)\n        {\n            float dist = Dist(ray);\n            ray += dir*dist;\n        \n        }\n    }\n    hit = Dist(ray)<0.001;\n    if(!hit)\n    {\n        col1 = vec3(0.2,0.4,0.8)*(1.+(dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir))/30.);\n        col1 = col1 + (vec3(1,1,0.3)-col1)*clamp(dot(dir,sundir)-0.8,0.,1.);\n        col1 = col1 + (vec3(1,1,1)-col1)*clamp((dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)*dot(dir,sundir)-0.95)*300.,0.,1.);\n    }\n    else\n    {\n        float sunlight = (dot(EstimateNormal(ray),sundir)-0.5);\n        float shadow = 1.-(0.5*((shadow(ray,1.+iTime)+shadow(ray,2.+iTime)+shadow(ray,3.+iTime)+shadow(ray,4.+iTime)+shadow(ray,5.+iTime)+shadow(ray,6.+iTime)+shadow(ray,7.+iTime))/7.));\n        if(ray.y>-1.01){shadow/=5.;shadow+=0.5;\n            col1 = (ray.y<-1.+0.001?(texture(iChannel0,ray.xz).xyz):vec3(1.,1.,1.))*((shadow*2.)+(sunlight+4.)/3.)/4.;\n    }\n    \n    \n    }\n    col2 += col1;\n    }\n    col2 /= 2.;\n    \n    \n    //return vec3((1.-AO)-steps);\n    return col * col2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = ((fragCoord/iResolution.yy)*2.);\n    uv.y-=1.;\n    uv.x-=(iResolution.x/iResolution.y);\n    // Time varying pixel color\n    vec2 col = (uv);\n    vec3 hit = HitRay(uv);\n    \n    // Output to screen\n    fragColor = vec4(hit,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fddczr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 36, 69, 69, 164], [165, 165, 192, 192, 240], [241, 241, 263, 263, 394], [395, 395, 418, 418, 586], [587, 587, 607, 607, 677], [678, 678, 709, 709, 1045], [1046, 1046, 1074, 1074, 1444], [1445, 1445, 1480, 1480, 1794], [1797, 1797, 1825, 1825, 4698], [4700, 4700, 4757, 4807, 5051]], "test": "untested"}
{"id": "7dccRr", "name": "Solitons", "author": "TreborHuang", "description": "Sine-Gordon equation. It starts out with a 1D standing soliton (a domain wall). Click to excite a wave.", "tags": ["pde"], "likes": 1, "viewed": 240, "published": 3, "date": "1652975001", "time_retrieved": "2024-07-30T16:48:11.919596", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pos = texture(iPosition, uv).x;\n    float vel = texture(iVelocity, uv).x;\n\n    // Amplitude mode\n    fragColor = vec4(sin(pos), cos(pos - PI) - 0.7, -sin(pos), 1);\n    \n    // Energy mode\n    // ??\n    \n    // Momentum mode\n    // ??\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/* -------- The Sine-Gordon Equation -------- *\\\n\n More introductory stuff here...\n \n Using Verlet intergration.\n Buffer A : Position history\n Buffer B : Laplacian of Buffer A (Control boundary here)\n Buffer C : Acceleration\n Buffer D : Velocity\n\n\\* ------------------------------------------ */\n\n// Spacetime scale:\nconst float dx = 0.05;\nconst float dt = 0.002;\n// Light speed is set to 1, or on screen, dx/dt / frameRate\n\n// Plank's constant is also set to 1.\n// So mass is equivalent to frequency (maybe off by a factor of 2).\nconst float mass = .7;\n\n// The damping coefficient controls how fast things die out.\n// const float damp = 0.;\n\n// The equation of motion:\nconst float K = mass * mass;\nfloat acceleration(float field, float laplacian){\n    return laplacian - K * sin(field);\n}\n\n// Returns the energy and momentum density\nfloat energy(float field, float velocity, vec2 gradient){\n    return .5 * (velocity * velocity + dot(gradient, gradient)) + mass * (1. - cos(field));\n}\nvec2 momentum(float velocity, vec2 gradient){\n    return velocity * gradient;\n}\n\n// Defines a click-excited pulse\nfloat pulse(float r){\n    return 4. * atan(\n        .6 / (.8 * cosh(.8 * r)) // One dimensional breather, will disperse.\n    );\n}\n\n// Defines the initial speed of the wall\nconst float speed = 0.3;  // Not very tolerant of high speed :(\nconst float gamma = 1./sqrt(1. - speed * speed);\n// position = 4. * atan(exp(mass * gamma * (d.x - v * t)))\n// velocity = - 4. / (1 + exp(2 * mass * gamma * (d.x - v * t)))\n//    * exp(mass * gamma * (d.x - v*t)) * mass * gamma * v\n\nfloat initpos(vec2 d){\n    return 4. * atan(exp(mass * gamma * d.x));\n}\n\nfloat initvel(vec2 d){\n    return\n        4. * mass * gamma * speed /\n            (exp(mass * gamma * d.x) + exp(-mass * gamma * d.x));\n}\n\n\n// Convenient numbers\n#define PI 3.1415926535897\n#define iPosition iChannel0\n#define iLaplacian iChannel1\n#define iAcceleration iChannel2\n#define iVelocity iChannel3\n\n", "buffer_a_code": "// Calculates position\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.xyzw = texture(iPosition, uv).xxyz;\n    float lastVel = texture(iVelocity, uv).x;\n    float lastAcc = texture(iAcceleration, uv).x;\n    \n    fragColor.x += dt *\n        (lastVel + .5 * dt * lastAcc);\n    if (iFrame == 0) {\n        fragColor.x = initpos((fragCoord - .5 * iResolution.xy) * dx);\n    }\n    if (iMouse.z > 0.) {\n        fragColor.x += pulse(length(iMouse.zw - fragCoord) * dx);\n    }\n}\n\n// TODO implement some Lorentz transform\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "const vec2\n    U = vec2(+1,0),\n    R = vec2(0,+1);\n\nfloat fix(float x){\n    return mod(x + PI, 2.*PI) - PI;\n}\n\n// Control boundary condition here\nfloat get(vec2 vec)\n{\n    return //(vec.x <= 0. || vec.x >= iResolution.x || vec.y <= 0. || vec.y >= iResolution.y ) ?\n        //4. * atan(exp(mass * (vec.x - .5*iResolution.x) * dx)) :\n        texture(iPosition, vec / iResolution.xy).x;\n}\n\n// Takes laplacian of the positions\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.yzw = texture(iLaplacian, uv).xyz;\n    float pos = texture(iPosition, uv).x;\n    fragColor.x =\n        ( .25 * fix(get(fragCoord+U+R) - pos) / dx\n        + .25 * fix(get(fragCoord+U-R) - pos) / dx\n        + .25 * fix(get(fragCoord-U+R) - pos) / dx\n        + .25 * fix(get(fragCoord-U-R) - pos) / dx\n        + .50 * fix(get(fragCoord+U  ) - pos) / dx\n        + .50 * fix(get(fragCoord-U  ) - pos) / dx\n        + .50 * fix(get(fragCoord  +R) - pos) / dx\n        + .50 * fix(get(fragCoord  -R) - pos) / dx ) / dx;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Calculates acceleration\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor.yzw = texture(iAcceleration, uv).xyz;\n    fragColor.x = acceleration(\n        texture(iPosition, uv).x,\n        texture(iLaplacian, uv).x\n    );\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Velocity\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iVelocity, uv).xxyz;\n    vec2 ac = texture(iAcceleration, uv).xy;\n    fragColor.x += (ac.x + ac.y)*.5;\n    \n    if (iFrame == 0) {\n        fragColor.x = initvel((fragCoord - .5 * iResolution.xy) * dx);\n    }\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dccRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 348]], "test": "untested"}
{"id": "7s2BW1", "name": "2D ray color", "author": "bgold", "description": "\"almost\" realtime 2D photon mapping (using dumb brute force) with refraction\n\nuse mouse to move the light source", "tags": ["raymarch", "lighting", "photon"], "likes": 6, "viewed": 407, "published": 3, "date": "1652972955", "time_retrieved": "2024-07-30T16:48:13.122380", "image_code": "void mainImage( out vec4 C, in vec2 U ) {\n    C = texture(iChannel0, U/iResolution.xy);\n    C = pow(C, vec4(1.0/2.2));\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define IOR 1.55\n#define DISP 0.05\n\n#define CIRCPOS vec2(0.5,0.5)\n#define RADIUS 0.1\n#define LENSPOS vec2(0.8,0.5)\n\nvec3 blockdist(in vec2 p) {\n    float d = max(max(max(p.y - 0.5, 0.4 - p.y), p.x-0.5), 0.4-p.x);\n    vec2 r = p-vec2(0.45, 0.45);\n    vec2 n;\n    if (r.y > r.x && r.y > -r.x) n = vec2(0.0, 1.0);\n    if (r.y < r.x && r.y < -r.x) n = vec2(0.0, -1.0);\n    if (r.y < r.x && r.y > -r.x) n = vec2(1.0, 0.0);\n    if (r.y > r.x && r.y < -r.x) n = vec2(-1.0, 0.0);\n    return vec3(n,d);\n}\n\nvec3 circdist(in vec2 p, in vec2 c, in float radius) {\n    vec2 r = p-c;\n    return vec3(normalize(r), length(r)-radius);\n}\n\nvec3 lensdist(in vec2 p, in vec2 c) {\n    vec2 r = p-c;\n    float d;\n    vec2 n;\n    if (r.x < 0.0) return circdist(r, vec2(0.17,0.0),0.2);\n    return circdist(r, vec2(-0.17, 0.0), 0.2);\n}\n        \n\nvoid mainImage( out vec4 C, in vec2 U ) {\n    vec2 p0 = U/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.y;\n    bool isDown = iMouse.z > 0.5;\n    if (iFrame < 1) m = vec2(0.95,0.5);\n    \n    vec4 noi = texture(iChannel1, U/iResolution.xy);\n    vec3 col;\n\n    for (int ci=0; ci<3; ci++) {\n        float sh = 0.0;\n        float th = 6.2831 * (length(noi)*62.8 + iTime*6.28*2.0);\n        vec2 v = vec2(cos(th), sin(th));\n        vec2 p = p0;\n\n        float r = 0.0;\n        float lastdbz = lensdist(p0, LENSPOS).z;\n        float lastdcz = circdist(p0, CIRCPOS, RADIUS).z;\n        float ior = IOR + float(ci-1) * DISP;\n        for (int i=0; i<10000; i++) {\n            vec3 d = vec3(normalize(p-m), distance(p,m));\n            vec3 db = lensdist(p, LENSPOS);\n            vec3 dc = circdist(p, CIRCPOS, RADIUS);\n            if (d.z < 0.03) {\n                sh += 1.0 / (r + 1.0) / (r + 1.0); \n                break;\n            }\n           \n            if (db.z < 0.0 && lastdbz > 0.0) v = refract(v, db.xy, 1.0/ior);\n            if (db.z > 0.0 && lastdbz < 0.0) v = refract(v, -db.xy, ior);\n            if (dc.z < 0.0 && lastdcz > 0.0) v = refract(v, dc.xy, 1.0/ior);\n            if (dc.z > 0.0 && lastdcz < 0.0) v = refract(v, -dc.xy, ior);\n\n            float s = min(abs(d.z) / abs(dot(d.xy, v)), abs(db.z) / abs(dot(db.xy, v)));\n            s = min(s, abs(dc.z) / abs(dot(dc.xy,v)));\n            s = max(s,0.01);\n            p += 0.1 * v * s;\n            r += 0.1 * s;\n            if (p.y > 1.0 || p.y < 0.0 || p.x > iResolution.x/iResolution.y || p.x < 0.0) {\n                sh += 0.0;\n                break;\n            }\n            lastdbz = db.z;\n            lastdcz = dc.z;\n        }\n        col[ci]=sh;\n    }\n    \n    col *= 1.0 + 2.0 * step(lensdist(p0, LENSPOS).z, 0.0);\n    col *= 1.0 + 2.0 * step(circdist(p0, CIRCPOS, RADIUS).z, 0.0);\n    \n    vec4 b = texture(iChannel0, U/iResolution.xy);\n    \n    if (isDown) {\n        C = 2.2*vec4(col,1.0);\n    } else {\n        C = 0.99*b + 0.03*vec4(col,1.0);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7s2BW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 125]], "test": "untested"}
{"id": "ss3cRr", "name": "Distortion Automata 500", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nmessy code", "tags": ["feedback", "cellularautomata"], "likes": 2, "viewed": 240, "published": 3, "date": "1652962568", "time_retrieved": "2024-07-30T16:48:14.125698", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col =  texelFetch(iChannel0, ivec2(1. * fragCoord), 0);//.rgba;\n    \n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.xy;\n    vec4 col2 = texture(iChannel1, uv + 0.5 * (col.rg-0.5));\n\n    col = sqrt(col) + 0.04;\n    fragColor = mix(col,col2,0.5);\n    //fragColor.rgb = (col.a) * col.rgb;\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 Cell( in ivec2 p ) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame == 0 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n       \n        vec3 e = vec3(0.5);\n        float h = h21(f + 113.);\n        float s = step(0.99, h);\n      \n        vec3 col = pal(10. * h, e, e, e, 1. * vec3(0,1,2)/3.);\n        //col *= s;\n        vec2 uv = fragCoord / iResolution.xy;\n        col = texture(iChannel2, uv).rgb;\n        \n        \n        //col *= step(length((uv-0.5) * iResolution.xy/iResolution.y), 0.4);\n        //col = vec3(uv.x * step(length(uv-0.5), 0.4));\n        fragColor = vec4(col, h21(col.rg));\n        //fragColor = vec4(col, s * h21(f + 50.));\n        return;\n    }\n    \n    // center cell\n    vec4 e = Cell(px); \n\n    // neighbour cells\n    vec4 t = Cell(px + ivec2(0,-1));\n    vec4 b = Cell(px + ivec2(0,1));\n    vec4 l = Cell(px + ivec2(-1,0));\n    vec4 r = Cell(px + ivec2(1,0));   \n    \n    float a = e.a;\n\n    float vt = abs(t.r-e.r)+abs(t.g-e.g)+abs(t.b-e.g);\n    float vb = abs(b.r-e.r)+abs(b.g-e.g)+abs(b.b-e.g);\n    float vl = abs(l.r-e.r)+abs(l.g-e.g)+abs(l.b-e.g);\n    float vr = abs(r.r-e.r)+abs(r.g-e.g)+abs(r.b-e.g);\n    \n    vec4 th = vec4(0);\n    float mx = max(max(vt,vb),max(vl,vr));\n    float mn = min(min(vt,vb),min(vl,vr));\n    int c = 0;\n    \n    if (vt == mx) {\n        th = t; c++;\n    }\n    if (vb == mx) {\n        th = b; c++;\n    }\n    if (vl == mx) {\n        th = l; c++;\n    }\n    if (vr == mx) {\n        th = r; c++;\n    }\n    \n    if (mx > 0. * sqrt(2.) && c == 1) {\n        if (e.a < th.a) {\n            e = mix(e,th,0.9);\n           // e.a = mix(e.a, th.a, 0.9) + 0.0;\n        }\n        else \n            e.rgb += 0.001;\n    }    \n    e.a += 0.0;\n    e = fract(e);\n    \n   // if (a == e.a)\n     //   e.a += 0.;\n        \n  //  e.a = fract(e.a);\n    //if (a != e.a)\n      //  e.a = mix(a, e.a, h21(e.rg + r.b));\n    \n    //e.a += 0.005;\n    \n   // e.a -= 0.005;\n    //e.a = fract(e.a);\n\n    e = clamp(e, 0., 1.);\n\tfragColor = e;\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgba = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    else\n        fragColor.rgba = texelFetch(iChannel1, ivec2(fragCoord), 0).rgba;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ss3cRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 369]], "test": "untested"}
{"id": "Nl2BWG", "name": "sphere and plain", "author": "Itay_milles", "description": "raymarcher with colors and movment", "tags": ["raymarching"], "likes": 1, "viewed": 170, "published": 3, "date": "1652961609", "time_retrieved": "2024-07-30T16:48:14.965452", "image_code": "#define MAX_ITR 120\n#define MIN_DST .01\n#define pi 3.14159\n\n#define sphere1 vec4(0., .51, 3., .5)\n#define sphere1col vec3(0.3, 0., 0.)\n#define plain1 .0\n#define plain1col vec3(0., 0., 0.)\n#define sun1 vec4(3.*sin(.5*iTime), 2., -3.*cos(.5*iTime), .02)\n#define sun1col vec3(1., 1., 0.)\n\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\nconst ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\n\n\nfloat sphereSdf(vec4 sphere, vec3 p)\n{\n    return length(sphere.xyz - p) - sphere.w;\n}\n\nfloat plainSdf(float plain, vec3 p)\n{\n    return p.y - plain;\n}\n\nfloat sceneSdf(vec3 p)\n{\n    float ds = sphereSdf(sphere1, p);\n    float dp = plainSdf(plain1, p);\n    \n    return min(ds, dp);\n}\n\nvec2 sphereToTexture(vec3 p)\n{\n    float R = sphere1.w;\n    float longitude = p.x / R;\n    float latitude = 2. * atan(exp(p.y/R)) - pi/2.;\n    \n    return vec2(-latitude, longitude);\n}\n\nvec4 dstToScene(vec3 rd, vec3 ro)\n{\n    float d = 0.;\n    float ds;\n    vec3 p;\n    for (int i = 0; i < MAX_ITR && d < 100.; i++)\n    {\n        p = rd*d + ro;\n        ds = sceneSdf(p);\n        if (ds < MIN_DST) {break;}\n        d += ds;\n    }\n    bool s1 = sphereSdf(sphere1, p) < MIN_DST;\n    bool p1 = plainSdf(plain1, p) < MIN_DST;\n    bool nn = !(p1 || s1);\n    \n    //texture(iChannel0, p.xz)*0.6)\n    vec3 col = vec3(float(s1)*sphere1col) + vec3(float(p1)*texture(iChannel0, p.xz)*0.6) + float(nn)*vec3(-1.);\n    return vec4(col, d);\n}\n\nvec3 cnormal(vec3 p)\n{\n    return normalize(vec3(\n                sceneSdf(p) - sceneSdf(p-vec3(.01, 0., 0.)),\n                sceneSdf(p) - sceneSdf(p-vec3(0., .01, 0.)),\n                sceneSdf(p) - sceneSdf(p-vec3(0., 0., .01))));\n}\n\nfloat clight(vec3 p, vec3 sun)\n{\n    vec3 light = normalize(sun - p);\n    vec3 normal = cnormal(p);\n    return dot(light, normal);\n}\n\nvec3 cfog(vec3 col, float d)\n{\n    vec3 fogcolor = vec3(.5294, .8078, .9216);\n    float weight = (1. - exp(-d*0.01));\n    return mix(col, fogcolor, weight);\n}\n\nfloat cshadow(vec3 ro, vec3 rd, float mint, float maxt)\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = sceneSdf(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        t += h;\n    }\n    return 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - .5;\n    uv.x *= 1.7777777777777777777777777777778;\n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    mouse.x *= 1.7777777777777777777777777777778;\n    \n    //camera\n    vec3 ro = fetchData(iChannel1, SCREEN_COLOR_ADDR).xyz;\n    vec3 rd = normalize(vec3(uv.x + mouse.x*2.*pi, uv.y, 1.));\n    \n    vec3 sun = sun1.xyz;\n    \n    //raymarch\n    vec4 d = dstToScene(rd, ro);\n    if (d.xyz == vec3(-1.)) {fragColor = vec4(.5294, .8078, .9216,1.0); return;}\n    vec3 p = ro + rd*d.w;\n    float light = .4*clight(p, sun);\n    float shadow = cshadow(p, normalize(sun - p), 0.1, 50.);\n    vec3 col = clamp(light, 0., 1.)*vec3(1., 0.788, 0.392)*.4*shadow + cfog(d.xyz, d.w);\n    col = pow( col, vec3(1.0/2.2) );\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const ivec2 SCREEN_COLOR_ADDR = ivec2(0, 0);\n#define fetchData(buf, addr) texelFetch(buf, addr, 0)\n#define storeData(buf_pos, addr) ivec2(buf_pos) == addr\n\n// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int LEFT  = 37;\nconst int UP    = 38;\nconst int RIGHT = 39;\nconst int DOWN  = 40;\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0); // Initial value\n    }\n\n    if (iFrame > 0) { // After initialization\n        if (storeData(fragCoord, SCREEN_COLOR_ADDR)) {\n            fragColor = fetchData(iChannel0, SCREEN_COLOR_ADDR); // Load value from previous frame\n\n            // Update:\n            float stepsize = 0.1;\n            fragColor.x += texelFetch(iChannel1, ivec2(LEFT, 0), 0).x*-stepsize;\n            fragColor.x += texelFetch(iChannel1, ivec2(RIGHT, 0), 0).x*stepsize;\n            fragColor.z += texelFetch(iChannel1, ivec2(UP, 0), 0).x*stepsize;\n            fragColor.z += texelFetch(iChannel1, ivec2(DOWN, 0), 0).x*-stepsize;\n            }\n        }\n    }", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2BWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[544, 544, 582, 582, 630], [632, 632, 669, 669, 695], [697, 697, 721, 721, 826], [828, 828, 858, 858, 1012], [1014, 1014, 1049, 1049, 1555], [1557, 1557, 1579, 1579, 1793], [1795, 1795, 1827, 1827, 1927], [1929, 1929, 1959, 1959, 2087], [2089, 2089, 2146, 2146, 2310], [2312, 2312, 2369, 2419, 3227]], "test": "untested"}
{"id": "7dcyRr", "name": "test_but", "author": "butadiene", "description": "test", "tags": ["test"], "likes": 40, "viewed": 913, "published": 3, "date": "1652961169", "time_retrieved": "2024-07-30T16:48:16.037586", "image_code": "float PI = acos(-1.);\nmat2 rot(float r){\n    vec2 s = vec2(cos(r),sin(r));\n    return mat2(s.x,s.y,-s.y,s.x);\n}\nfloat cube(vec3 p,vec3 s){\n    vec3 q = abs(p);\n    vec3 m = max(s-q,0.);\n    return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nvec4 map( in vec3 p )\n{\n   float d = cube(p,vec3(1.0));\nvec3 col = vec3(0);\n   float s = 1.0;\n   float ite = 4.0;\n   for( int m=0; m<4; m++ )\n   {\n      vec3 a = mod( p*s, 2.0 )-1.0;\n      s *= 3.0;\n      vec3 r = abs(1.1 - 3.0*abs(a));\n\n      float da = max(r.x,r.y);\n      float db = max(r.y,r.z);\n      float dc = max(r.z,r.x);\n      float k = 2.0*pow(abs(sin(0.5*iTime)),0.2);\n       if(r.x<r.y)col.z+=1.2*abs((float(m)-k))/ite;\n        if(r.y>r.z)col.y+=1.*abs((float(m)-k))/ite,col.z += 0.2*abs((float(m)-k))/ite;\n        if(r.x>r.z)col.x+=1.2*abs((float(m)-k))/ite;\n      float c = (min(da,min(db,dc))-1.0)/s;\n\n      d = max(d,c);\n   }\n\n   return vec4(col,d);\n}\n#define BOXITER 5.\n\nfloat cnbox(vec3 ps,float t, float k){\n    ps.xy *= rot(0.25*3.14);\n    ps.xz *= rot(0.25*3.14);\n    ps.xy *= rot(1.*t*3.14);\n    ps.xz *= rot(1.*t*3.14);\n    float sc = 0.45;\n    ps = abs(ps);\n    vec3 pk = ps;\n    if(k>1.){\n        for(int i = 0;i<int(BOXITER)+1;i++){\n            if(float(i)<floor(k)-1.){\n            ps = abs(ps)-sc/pow(2.,4.+float(i));\n            }else if(BOXITER>k){\n             ps = mix(ps,abs(ps)-sc/pow(2.,4.+float(i)),clamp(k-1.-float(i),0.0,1.0));\n             break;\n            }else{\n                 ps = mix(ps,pk,clamp(k-1.-float(i),0.0,1.0));\n            }\n        }\n    }\n    float sac = pow(2.2,k-1.);\n    if(BOXITER<k)\n    sac = mix(sac,1.0,pow(k-BOXITER,0.4));\n    float d1 = cube(ps,sc*0.5*vec3(0.2,0.2,0.2)/sac);\n    return d1;\n}\nfloat ease_in_out_cubic(float x) {\n\treturn x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nvec4 dist(vec3 p){\n    vec3 p1 = p;\n    float k = 2.;\n    float ksstx = clamp(3.*(fract(0.1*iTime)-2./3.),0.0,1.0);\n    float kssty = clamp(3.*(fract(0.1*iTime)-1./3.),0.0,1.0);\n    float ksstz = clamp(3.*fract(0.1*iTime),0.0,1.0);\n    p.x += 4.*ease_in_out_cubic(ksstx);\n    p.y += 4.*ease_in_out_cubic(kssty);\n    p.z += 4.*ease_in_out_cubic(ksstz);\n    p = mod(p,k)-0.5*k;\n    //p.xy *= rot(0.25*3.14);\n    //p.xz *= rot(0.25*3.14);\n    vec4 sd = map(p);\n    float d= sd.w;\n    vec3 col = 0.4*sd.xyz;\n    col *= exp(-2.5*d)*2.6;\n    vec3 ps = p1-vec3(1.);\n    float ktx = 0.3;\n    float kt = fract(iTime*ktx);\n    float d1 = cnbox(ps,ease_in_out_cubic(kt),1.+mod(ease_in_out_cubic(kt)+floor(iTime*ktx),BOXITER));\n    return vec4(col,min(d,d1));\n}\n\nvec3 gn(vec3 p){\nvec2 e = vec2(0.001,0.);\nreturn normalize(vec3(dist(p+e.xyy).w-dist(p-e.xyy).w,\ndist(p+e.yxy).w-dist(p-e.yxy).w,\ndist(p+e.yyx).w-dist(p-e.yyx).w\n\n));\n\n}\n  //https://www.shadertoy.com/view/lsKSWR\nfloat vig(vec2 uv)\n{\n   float time = iTime;\n   uv *=  1.0 - uv.yx;\n   float vig = uv.x*uv.y;\n   vig = pow(vig, 0.45);\n   return vig;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p = (uv-0.5)*2.;\n    p.y *= iResolution.y/iResolution.x;\n\n    float rsa =0.2;\n    float time = iTime+17.5;\n    float rkt = time*0.3;\n    vec3 dmo = vec3(1.)+vec3(0,0,0);\n    vec3 ro = vec3(rsa*cos(rkt),0.*sin(time*0.2),rsa*sin(rkt))+dmo;\n    vec3 ta = vec3(0)+dmo;\n    vec3 cdir = normalize(ta-ro);\n    vec3 side = cross(cdir,vec3(0,1,0));\n    vec3 up = cross(side,cdir);\n    vec3 rd = normalize(p.x*side+p.y*up+1.2*cdir);\n   // rd.xz *= rot(time*0.13+1.);\n    float d,t= 0.;\n    vec3 ac = vec3(0.);\n    vec3 ac2 = vec3(0.);\n    float frag = 0.;\n    float ep = 0.00001;\n vec3 as =ro + 0.0*(p.x*side+p.y*up); \n    for(int i =0;i<75;i++){\n        vec4 rsd = dist(as+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    vec3 sp = as + rd*t;\nvec3 normal = gn(sp);\nrd = reflect(rd,normal);\n\nvec3 col  =0.013*ac;\n    ac *= 0.;\n    t = 0.1;\n   for(int i =0;i<75;i++){\n        vec4 rsd = dist(sp+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    col += 0.013*ac;\n    \n      sp = as + rd*t;\n normal = gn(sp);\nrd = reflect(rd,normal);\n\n    ac *= 0.;\n    t = 0.1;\n   for(int i =0;i<75;i++){\n        vec4 rsd = dist(sp+rd*t);\n        d = max(rsd.w,0.000);\n        t += d;\n        ac += rsd.xyz;\n        if(d<ep) break;\n    }\n    col += 0.013*ac;\n    //col = pow(col,vec3(0.8));\n    \tfragColor = vec4(col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcyRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 111], [112, 112, 138, 138, 241], [932, 932, 970, 970, 1704], [1705, 1705, 1739, 1739, 1809], [1811, 1811, 1829, 1829, 2560], [2562, 2562, 2578, 2578, 2731], [2734, 2774, 2794, 2794, 2908], [2910, 2910, 2967, 2967, 4436]], "test": "untested"}
{"id": "7dcczn", "name": "draw reflected ray", "author": "jcyuan", "description": "visualize it for a guy", "tags": ["reflect"], "likes": 3, "viewed": 206, "published": 3, "date": "1652948642", "time_retrieved": "2024-07-30T16:48:16.851410", "image_code": "#define PI 3.141592653589793\n#define ARROW_SIZE .05\n#define LINE_W 2.\n\n#define ORANGE vec3(1, .3, 0)\n#define BLUE vec3(0, .3, 1)\n#define GREEN vec3(0, 1, 0)\n#define BLACK vec3(.3)\n\nfloat lineBetween(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);\n    return length(pa - ba * h);\n}\n\n// Piecewise Polynomial from https://iquilezles.org/articles/smoothsteps/\nfloat ss_pp(float a, float b, float n) {\n    float x = clamp((n - a) / (b - a), 0.0, 1.0);\n    const float P = 2.;\n    return (x < 0.5) ? 0.5 * pow(2.0 * x, 1.0 / P) : 1.0 - 0.5 * pow(2.0 * (1.0 - x), 1.0 / P);\n}\n\nvec2 reflectRay(vec2 inputRay, vec2 normal) {\n    return inputRay - 2. * normal * dot(normal, inputRay);\n    // uncomment to use the native function, actually the same thing\n    // return reflect(inputRay, normal);\n}\n\nstruct Surface {\n    vec2 a;\n    vec2 b;\n    vec2 origin;\n    vec2 normal;\n};\n\nSurface getSurface(vec2 a, vec2 b, float r) {\n    float cs = cos(r), ss = sin(r);\n    mat2 mat = mat2(cs, ss, -ss, cs);\n    a = mat * a;\n    b = mat * b;\n    vec2 d = b - a;\n    return Surface(a, b, a + d * .5, normalize(vec2(-d.y, d.x)));\n}\n\nvec3 visualizeLine(float d, float w, vec3 color, inout vec3 oc) {\n    oc = mix(oc, color, 1. - ss_pp(-w, w, d));\n    return oc;\n}\n\nvec3 visualizeLine(vec2 p, vec2 a, vec2 b, float w, vec3 color, inout vec3 oc) {\n    return visualizeLine(lineBetween(p, a, b), w, color, oc);\n}\n\nconst float ArrowAngle = 20. * PI / 180.;\nconst float ArrowCS = cos(ArrowAngle);\nconst float ArrowSS = sin(ArrowAngle);\n\nvec3 visualizeArrow(vec2 p, vec2 origin, vec2 n, float h, float w, vec3 color, inout vec3 oc) {\n    vec2 o2 = origin + n * h * 2.;\n    visualizeLine(p, origin, o2, w, color, oc);\n    \n    float a = atan(n.y, n.x);\n    \n    float cs = cos(a + PI), ss = sin(a + PI);\n    vec2 e1 = mat2(cs, ss, -ss, cs) * (vec2(ArrowCS, ArrowSS) * h);\n    visualizeLine(p, o2, o2 + e1, w, color, oc);\n    \n    cs = cos(a), ss = sin(a);\n    vec2 e2 = mat2(cs, ss, -ss, cs) * (vec2(ArrowCS, ArrowSS) * vec2(-h, h));\n    visualizeLine(p, o2, o2 + e2, w, color, oc);\n    \n    return oc;\n}\n\nvec3 visualizeSurface(vec2 p, Surface s, float w, vec3 color, inout vec3 oc) {\n    visualizeLine(p, s.b, s.a, w, color, oc);\n    visualizeArrow(p, s.origin, s.normal, ARROW_SIZE, w, color, oc);\n    return oc;\n}\n\nvec4 charLUT(in vec2 p, in int c) {\n    p.y += 1.;\n    vec2 range = step(vec2(0.), p) * step(p, vec2(1.));\n    float check = range.x * range.y;\n    if (check == 0.) return vec4(vec3(0.), 1e+3);\n    vec2 o = p / 16.;\n\treturn textureGrad(iChannel0, o + fract(vec2(c, 15 - c / 16) / 16.), dFdx(o), dFdy(o));\n}\n\n#define SS pow(1. - ss_pp(-w, w, textOutput.w), 1.5)\n\nvec3 drawDesc(in vec2 p, float size, float spacing, float w, inout vec3 col) {\n    textUv = p * 64. / size;\n    charSpacing = spacing;\n    \n    float sx = textUv.x;\n    w *= 4.;\n    \n    _G _r _e _e _n\n    col = mix(col, GREEN, SS);\n    textOutput.w = 1e+3;\n    \n    _colon _space _space _S _u _r _f _a _c _e\n    col = mix(col, BLACK, SS);\n    textOutput.w = 1e+3;\n    textUv.y += spacing * 2.2;\n    textUv.x = sx;\n    \n    _O _r _a _n _g _e\n    col = mix(col, ORANGE, SS);\n    textOutput.w = 1e+3; \n    \n    _colon _space _I _n _p _u _t _space _R _a _y\n    col = mix(col, BLACK, SS);\n    textOutput.w = 1e+3;\n    textUv.y += spacing * 2.2;\n    textUv.x = sx;\n    \n    _B _l _u _e\n    col = mix(col, BLUE, SS);\n    textOutput.w = 1e+3;\n    \n    _colon _space _space _space _R _e _f _l _e _c _t _e _d _space _R _a _y\n    col = mix(col, BLACK, SS);\n    textOutput.w = 1e+3;\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 ouv = fragCoord / iResolution.xy;\n    vec2 ratio = vec2(iResolution.x / iResolution.y, 1.);\n    \n    vec3 col = vec3(.95, .99, .9);\n    \n    vec2 tUv = 2. * (ouv - vec2(0., 1.)) * ratio;\n    drawDesc(tUv + vec2(-.05, .05), 6., .45, dFdy(tUv.y) * 2., col);\n    \n    vec2 uv = 2. * (ouv - .5) * ratio;\n    uv.y += .45;\n    float w = dFdy(uv.y) * LINE_W;\n    \n    Surface surface = getSurface(vec2(-.8, 0.) + vec2(cos(iTime) * .5, 0.), vec2(.8, 0.), cos(iTime * 2.) * .2);\n    \n    vec2 inputRay = normalize(surface.origin - vec2(-.6, .3));\n    vec2 reflectedRay = normalize(reflectRay(inputRay, surface.normal));\n    \n    visualizeSurface(uv, surface, w, GREEN, col);\n    \n    visualizeLine(uv, surface.origin - inputRay, surface.origin, w, ORANGE, col);\n    visualizeArrow(uv, surface.origin - inputRay * .5, inputRay, ARROW_SIZE, w, vec3(1, 0, 0), col);\n    \n    visualizeLine(uv, surface.origin, surface.origin + reflectedRay, w, BLUE, col);\n    visualizeArrow(uv, surface.origin + reflectedRay * .5, reflectedRay, ARROW_SIZE, w, vec3(0, 0, 1), col);\n    \n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define S(c) _tmpChrVal = charLUT(textUv, c); textOutput.xyz += _tmpChrVal.xyz; textOutput.w = min(textOutput.w, 2. * _tmpChrVal.w - 1.); textUv.x -= charSpacing;\n\n#define _A S(65)\n#define _B S(66)\n#define _C S(67)\n#define _D S(68)\n#define _E S(69)\n#define _F S(70)\n#define _G S(71)\n#define _H S(72)\n#define _I S(73)\n#define _J S(74)\n#define _K S(75)\n#define _L S(76)\n#define _M S(77)\n#define _N S(78)\n#define _O S(79)\n#define _P S(80)\n#define _Q S(81)\n#define _R S(82)\n#define _S S(83)\n#define _T S(84)\n#define _U S(85)\n#define _V S(86)\n#define _W S(87)\n#define _X S(88)\n#define _Y S(89)\n#define _Z S(90)\n\n#define _a S(97)\n#define _b S(98)\n#define _c S(99)\n#define _d S(100)\n#define _e S(101)\n#define _f S(102)\n#define _g S(103)\n#define _h S(104)\n#define _i S(105)\n#define _j S(106)\n#define _k S(107)\n#define _l S(108)\n#define _m S(109)\n#define _n S(110)\n#define _o S(111)\n#define _p S(112)\n#define _q S(113)\n#define _r S(114)\n#define _s S(115)\n#define _t S(116)\n#define _u S(117)\n#define _v S(118)\n#define _w S(119)\n#define _x S(120)\n#define _y S(121)\n#define _z S(122)\n\n#define _0 S(48)\n#define _1 S(49)\n#define _2 S(50)\n#define _3 S(51)\n#define _4 S(52)\n#define _5 S(53)\n#define _6 S(54)\n#define _7 S(55)\n#define _8 S(56)\n#define _9 S(57)\n\n#define _add  S(43)\n#define _dot  S(46)\n#define _exc  S(33)\n#define _space S(32)\n#define _colon S(58)\n\nvec4 _tmpChrVal = vec4(vec3(0.), 1e+3);\n\nfloat charSpacing = .5;\nvec2 textUv = vec2(0);\nvec4 textOutput = vec4(vec3(0), 1e+3);\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7dcczn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[181, 181, 224, 224, 347], [349, 423, 463, 463, 635], [637, 637, 682, 682, 853], [934, 934, 979, 979, 1175], [1177, 1177, 1242, 1242, 1306], [1308, 1308, 1388, 1388, 1452], [1575, 1575, 1670, 1670, 2140], [2142, 2142, 2220, 2220, 2352], [2354, 2354, 2389, 2389, 2660], [3612, 3612, 3667, 3667, 4766]], "test": "untested"}
{"id": "fdcyzr", "name": "Simple Incompressible Fluid", "author": "davidar", "description": "Yet another fluid simulation, just advection with a \"Poisson filter\" based pressure solver to zero out divergence. Click and drag the mouse the interact", "tags": ["simulation", "filter", "fluid", "poisson", "advection", "gaussian", "ca", "separable", "incompressible", "divergence", "svd"], "likes": 20, "viewed": 620, "published": 3, "date": "1652938699", "time_retrieved": "2024-07-30T16:48:17.893623", "image_code": "vec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    // https://iquilezles.org/articles/palettes\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float d = texture(iChannel0, uv).z;\n    vec3 col = pal( d, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\nBuffers B and C calculate fluid pressure using the two-pass Poisson solver described in\n    \"Fast Eulerian Fluid Simulation In Games Using Poisson Filters\"\n    https://www.shahinrabbani.ca/torch2pd.html\n\nSolutions are initialised with a Gaussian blur of the previous solution\n*/\n\n// https://youtu.be/_3eyPUyqluc?t=355\nconst float poisson_filter[7] = float[](\n    .57843719174,\n    .36519596949,\n    .23187988879,\n    .14529589353,\n    .08816487385,\n    .05184872885,\n    .02906462467\n);\n\nfloat gaussian(float w, float s) {\n    return exp(-(w*w) / (2.*s*s)) / (s * sqrt(radians(360.)));\n}\n\n\n\n/* Texture Stencil Library https://www.shadertoy.com/view/ssBczm\n\nThe MIT License\n\nCopyright (c) 2022 David A Roberts <https://davidar.io/>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nvec4 texStencil(sampler2D ch, vec2 uv, float coeff[9]) {\n    vec2 texel = 1. / vec2(textureSize(ch, 0));\n    const vec2 stencilOffset[9] = vec2[](\n        vec2(-1, 1), vec2( 0, 1), vec2( 1, 1),\n        vec2(-1, 0), vec2( 0, 0), vec2( 1, 0),\n        vec2(-1,-1), vec2( 0,-1), vec2( 1,-1)\n    );\n    vec4 r = vec4(0);\n    for (int i = 0; i < 9; i++)\n        r += coeff[i] * texture(ch, uv + texel * stencilOffset[i]);\n    return r;\n}\n\n// Gaussian/binomial blur\n// https://bartwronski.com/2021/10/31/practical-gaussian-filter-binomial-filter-and-small-sigma-gaussians/\nvec4 texBlur(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        .0625, .125, .0625,\n        .125,  .25,  .125,\n        .0625, .125, .0625\n    ));\n}\n\n// Laplacian, optimal 9-point stencil\n// https://docs.lib.purdue.edu/cgi/viewcontent.cgi?article=1928&context=cstech\nvec4 texLapl(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        1.,   4., 1.,\n        4., -20., 4.,\n        1.,   4., 1.\n    )) / 6.;\n}\n\n// horizontal gradient (Sobel filter)\nvec4 texGradX(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n        -1., 0., 1.,\n        -2., 0., 2.,\n        -1., 0., 1.\n    )) / 8.;\n}\n\n// vertical gradient (Sobel filter)\nvec4 texGradY(sampler2D ch, vec2 uv) {\n    return texStencil(ch, uv, float[](\n         1.,  2.,  1.,\n         0.,  0.,  0.,\n        -1., -2., -1.\n    )) / 8.;\n}\n\n\n\n// Hash without Sine\n// MIT License...\n/* Copyright (c)2014 David Hoskins.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.*/\n\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//----------------------------------------------------------------------------------------\n//  2 out, 1 in...\nvec2 hash21(float p)\n{\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//----------------------------------------------------------------------------------------\n///  2 out, 3 in...\nvec2 hash23(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n\n//----------------------------------------------------------------------------------------\n///  3 out, 2 in...\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n    \n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 2 in...\nvec4 hash42(vec2 p)\n{\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 3 in...\nvec4 hash43(vec3 p)\n{\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n//----------------------------------------------------------------------------------------\n// 4 out, 4 in...\nvec4 hash44(vec4 p4)\n{\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\n\n\n/* https://www.shadertoy.com/view/XsX3zB\n *\n * The MIT License\n * Copyright  2013 Nikita Miropolskiy\n * \n * ( license has been changed from CCA-NC-SA 3.0 to MIT\n *\n *   but thanks for attributing your source code when deriving from this sample \n *   with a following link: https://www.shadertoy.com/view/XsX3zB )\n *\n * ~\n * ~ if you're looking for procedural noise implementation examples you might \n * ~ also want to look at the following shaders:\n * ~ \n * ~ Noise Lab shader by candycat: https://www.shadertoy.com/view/4sc3z2\n * ~\n * ~ Noise shaders by iq:\n * ~     Value    Noise 2D, Derivatives: https://www.shadertoy.com/view/4dXBRH\n * ~     Gradient Noise 2D, Derivatives: https://www.shadertoy.com/view/XdXBRH\n * ~     Value    Noise 3D, Derivatives: https://www.shadertoy.com/view/XsXfRH\n * ~     Gradient Noise 3D, Derivatives: https://www.shadertoy.com/view/4dffRH\n * ~     Value    Noise 2D             : https://www.shadertoy.com/view/lsf3WH\n * ~     Value    Noise 3D             : https://www.shadertoy.com/view/4sfGzS\n * ~     Gradient Noise 2D             : https://www.shadertoy.com/view/XdXGW8\n * ~     Gradient Noise 3D             : https://www.shadertoy.com/view/Xsl3Dl\n * ~     Simplex  Noise 2D             : https://www.shadertoy.com/view/Msf3WH\n * ~     Voronoise: https://www.shadertoy.com/view/Xd23Dh\n * ~ \n *\n */\n\n/* skew constants for 3d simplex functions */\nconst float F3 = 1./3.;\nconst float G3 = 1./6.;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(hash33(s) - 0.5, x);\n\t d.y = dot(hash33(s + i1) - 0.5, x1);\n\t d.z = dot(hash33(s + i2) - 0.5, x2);\n\t d.w = dot(hash33(s + 1.0) - 0.5, x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n\n\n// https://iquilezles.org/articles/fbm\n\nfloat fbm( in vec3 x, in float G, in int numOctaves )\n{    \n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*simplex3d(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n", "buffer_a_code": "void interaction(in vec2 uv, inout vec2 velocity, inout float ink) {\n    // this function describes any external forces on the fluid, for example:\n\n    vec3 seed = vec3(uv, iTime / 10.);\n    velocity += .05 * fbm(20. * seed, .5, 8);\n    velocity *= .99;\n    ink += (fbm(seed, .5, 8) + 1.) * 7e-3;\n    ink = clamp(.99 * ink, 0., 1.);\n\n    if (iMouse.z > 0.) {\n        vec2 p = iMouse.xy / iResolution.xy;\n        vec4 iMousePrev = texelFetch(iChannel3, ivec2(0,0), 0);\n        vec2 v = iMouse.xy - iMousePrev.xy;\n        if (length(v) > 1.) v = normalize(v);\n        velocity += v * exp(-1000. * dot(uv-p, uv-p));\n    }\n}\n\nvec3 fetch(vec2 uv) {\n    // subtract pressure gradient from velocity\n    return vec3(\n        texture(iChannel0, uv).x - texGradX(iChannel2, uv).x,\n        texture(iChannel0, uv).y - texGradY(iChannel2, uv).x,\n        texture(iChannel0, uv).z);\n}\n\nvec3 advect(vec2 uv) {\n    return fetch(uv - fetch(uv).xy / iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 r = advect(uv);\n    interaction(uv, r.xy, r.z);\n    fragColor = vec4(r, 1.);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Poisson solver - horizontal pass\n\nfloat rhs(vec2 pos) { // rhs of the poisson equation\n    vec2 uv = pos / iResolution.xy;\n    float divergence = texGradX(iChannel0, uv).x + texGradY(iChannel0, uv).y;\n    return -divergence;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int i = -6; i <= 6; i++) {\n        vec2 pos = fragCoord + vec2(i,0);\n        p += poisson_filter[abs(i)] * rhs(pos);\n        g += gaussian(float(i), 3.) * texelFetch(iChannel2, ivec2(pos), 0).x;\n    }\n\tfragColor = vec4(p, g, 0, 0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Poisson solver - vertical pass\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 0., g = 0.;\n    for (int j = -6; j <= 6; j++) {\n        vec4 pass1 = texelFetch(iChannel1, ivec2(fragCoord) + ivec2(0,j), 0);\n        p += poisson_filter[abs(j)] * pass1.x;\n        g += gaussian(float(j), 3.) * pass1.y;\n    }\n    fragColor = vec4(g + p);\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = iMouse;\n}", "buffer_d_inputs": [], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdcyzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 68, 116, 159], [161, 161, 218, 218, 431]], "test": "untested"}
{"id": "st2fDt", "name": "Color Automata Thing 500", "author": "SnoopethDuckDuck", "description": "Press r to reset\n\nmessy code", "tags": ["feedback", "cellularautomata"], "likes": 3, "viewed": 234, "published": 3, "date": "1652925893", "time_retrieved": "2024-07-30T16:48:18.715426", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 col = texelFetch( iChannel0, ivec2(1. * fragCoord), 0 ).rgba;\n\n    col = sqrt(col) + 0.04;\n    fragColor.rgb = col.rgb;\n    //fragColor.rgb = (col.a) * col.rgb;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define KEYBOARD iChannel1\n#define KEY_RESET 82\n\nvec4 Cell( in ivec2 p ) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;\n    return texelFetch(iChannel0, p, 0 ).rgba;\n}\n\nbool key_down(int key) {\n    return int(texelFetch(KEYBOARD, ivec2(key, 0), 0).x) == 1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 px = ivec2( fragCoord );\n    \n    if (iFrame < 120 || key_down(KEY_RESET)) {\n        vec2 f = fragCoord + 0.01 * iTime; \n       \n        vec3 e = vec3(0.5);\n        float h = h21(f + 113.);\n        float s = 1.;step(0.999, h);\n        \n        vec3 col = (pal(10. * h21(f), e, e, e, 1. * vec3(0,1,2)/3.));\n        col *= s;\n        \n        vec2 uv = (fragCoord - 0.* iResolution.xy) / iResolution.xy;\n        col = texture(iChannel2, uv).rgb;\n        col *= step(length((uv-0.5) * iResolution.xy/iResolution.y), 0.4);\n        //col = vec3(uv.x * step(length(uv-0.5), 0.4));\n        fragColor = vec4(col, max(col.r,max(col.g,col.b)));\n        //fragColor = vec4(col, s * h21(f + 50.));\n        return;\n    }\n    \n    // center cell\n    vec4 e = Cell(px); \n\n    // neighbour cells\n    vec4 t = Cell(px + ivec2(0,-1));\n    vec4 b = Cell(px + ivec2(0,1));\n    vec4 l = Cell(px + ivec2(-1,0));\n    vec4 r = Cell(px + ivec2(1,0));   \n    \n    float a = e.a;\n\n    float vt = abs(t.a-a);\n    float vb = abs(b.a-a);\n    float vl = abs(l.a-a);\n    float vr = abs(r.a-a);\n    \n    vec4 th = vec4(0);\n    float mx = max(max(vt,vb),max(vl,vr));\n    //mx = min(min(vt,vb),min(vl,vr));\n    int c = 0;\n    \n    if (vt == mx) {\n        th = t; c++;\n    }\n    if (vb == mx) {\n        th = b; c++;\n    }\n    if (vl == mx) {\n        th = l; c++;\n    }\n    if (vr == mx) {\n        th = r; c++;\n    }\n      \n    if (th.a < 1.) {\n        if (c == 1) {\n            e.rgb = fract(th.rgb * (1. + 0.1 * th.a));\n            e.a = mix(a, th.a, 0.5 +  (th.a - a) * 2.*  h21(vec2(e.r + e.g + e.b, e.a))) * 1.0;\n        }\n      //  else\n      //      e.a = h21(vec2(th.r + th.g + th.b, e.a + th.a)); //idk\n    }\n    \n   // if (a == e.a)\n     //   e.a += 0.;\n        \n  //  e.a = fract(e.a);\n    //if (a != e.a)\n      //  e.a = mix(a, e.a, h21(e.rg + r.b));\n    \n    //e.a += 0.005;\n    \n   // e.a -= 0.005;\n    //e.a = fract(e.a);\n\n    e = clamp(e, 0., 1.);\n\tfragColor = e;\n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.1415926535\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_b_code": "// Flicker reduction.\n// This CA tends to produce structures that flicker between two states.\n// Code here copies CA output on odd frames and stays unchanged on even.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame % 2 == 1)\n        fragColor.rgba = texelFetch(iChannel0, ivec2(fragCoord), 0).rgba;\n    else\n        fragColor.rgba = texelFetch(iChannel1, ivec2(fragCoord), 0).rgba;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2fDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 229]], "test": "untested"}
{"id": "stjBWd", "name": "2x Downsampling Filter", "author": "TinyTexel", "description": " An 8x8 downsampling filter with smooth frequency response that removes significantly more high frequency content than a simple 2x2 box filter while presering low frequencies.", "tags": ["antialiasing", "filtering", "aa", "signalprocessing", "kernel", "downsampling"], "likes": 5, "viewed": 576, "published": 3, "date": "1652917840", "time_retrieved": "2024-07-30T16:48:19.652920", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    An 8x8 downsampling filter with smooth frequency response that removes significantly \n    more high frequency content than a simple 2x2 box filter while preserving low frequencies.\n    \n    The demo automatically switches back and forth between a box filter and the 8x8 one.\n    The jittering helps to highlight aliased frequencies (the box filter produces way more).\n    \n    Relevant code is in Buffer A.\n    \n    Tab   - toggle between texture and white noise\n    Space - visualize filter response on/off\n    \n    \n    Related: \"2X AA Downsampling filter\" by Bart Wronski: https://www.shadertoy.com/view/fsjBWm\n    -> besides optimizing the tab count Bart's filter attenuates more high frequency content than \n       mine does while boosting mid-frequencies a bit, see:\n       https://bartwronski.com/2022/03/07/fast-gpu-friendly-antialiasing-downsampling-filter/\n       \n    \"Band-Split Filter\": https://www.shadertoy.com/view/stSBWc\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = ceil((iResolution.y - SIZE)*0.5);\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // fft\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*1.5,0.0)), 0).xy);\n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*.5,0.0)), 0).xy); amp *= 0.5;\n        \n        float s = 0.005;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        #if 0\n        if(amp <= exp2(-10.0)) col = sqrt(sqrt(amp*exp2(10.0)))* vec3(1.0, 0.0, 0.0);\n        //if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        #endif\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // input\n        float n = texelFetch(iChannel0, ivec2(uv0-0.5), 0).x;\n        col = vec3((n));\n        //if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. ONeill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n", "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Tab   - toggle between texture and white noise\n    Space - visualize filter response on/off\n*/\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel3, ivec2(keyCode, 2), 0).x;}\n\n\nfloat InputScale = 2.0;\nbool showFilter = true;\n\nfloat Read(vec2 uv)\n{\n    if(ReadKeyToggle(KEY_TAB) != 0.0 && !showFilter)\n    return pow(textureLod(iChannel0, (uv + 0.5) / iChannelResolution[0].xy, 0.0).g, 2.2);\n    \n    #if 1\n    float size = SIZE*InputScale;\n    if(uv.x < 0.0) uv.x += size;\n    if(uv.y < 0.0) uv.y += size;\n    \n    if(uv.x >= size) uv.x -= size;\n    if(uv.y >= size) uv.y -= size;\n    #endif\n    \n    return Hash01(uv, 0u);\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    #if 0\n    if((uint(uv.x) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }\n    #endif\n    #if 0\n    if((uint(uv.y) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }    \n    #endif\n    //uv = floor(uv * 0.5) * 2.0;\n    \n    showFilter = ReadKeyToggle(KEY_SPACE) != 0.0;\n    \n    if(showFilter) InputScale = 1.0;\n    \n    uv *= InputScale;\n\n   #if 1\n    if(!showFilter)\n    {\n        if((uint(iFrame) & 2u) != 0u) uv.x += 1.0;\n        if((uint(iFrame) & 4u) != 0u) uv.y += 1.0;\n    }\n   #endif\n   \n    float v = 0.0;\n\n    bool useNiceFilter = (uint(iFrame) & 128u) == 0u;\n    // useNiceFilter = true;\n    // useNiceFilter = false;\n    \n    if(useNiceFilter)\n    {\n        // 8x8 band split\n        int r = 3;\n        float ws[] = float[](0.410104, 0.136729, -0.0273127, -0.0195209);\n\n        for(int y = -r; y <= r+1; ++y)\n        for(int x = -r; x <= r+1; ++x)\n        {\n            int x0 = x > 0 ? x - 1 : x;\n            int y0 = y > 0 ? y - 1 : y;\n\n            float w = ws[abs(x0)] * ws[abs(y0)];\n\n            v += Read(uv + vec2(x, y)) * w;\n        }\n    }\n    else\n    {\n        // 2x2 box filter\n        v += Read(uv + vec2(0.0, 0.0)) * 0.25;\n        v += Read(uv + vec2(1.0, 0.0)) * 0.25;\n        v += Read(uv + vec2(0.0, 1.0)) * 0.25;\n        v += Read(uv + vec2(1.0, 1.0)) * 0.25;\n    }\n   \n    //v = Read(uv/InputScale);\n    //v = Read(uv);\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        //vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\t//fragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\t//vec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\t//fragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjBWd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[1019, 1019, 1065, 1065, 2225]], "test": "untested"}
{"id": "slBBDd", "name": "turn heart", "author": "jorge2017a2", "description": "turn heart", "tags": ["turnheart"], "likes": 3, "viewed": 233, "published": 3, "date": "1652906590", "time_retrieved": "2024-07-30T16:48:20.437821", "image_code": "//----------image\n//por jorge2017a2-\n///https://iquilezles.org/articles/distfunctions2d/\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n///iq\nfloat sdHeart( in vec2 p )\n{\n    p.x = abs(p.x);\n\n    if( p.y+p.x>1.0 )\n        return sqrt(dot2(p-vec2(0.25,0.75))) - sqrt(2.0)/4.0;\n    return sqrt(min(dot2(p-vec2(0.00,1.00)),\n                    dot2(p-0.5*max(p.x+p.y,0.0)))) * sign(p.x-p.y);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    float t=iTime*1.0;\n    \n    float d1a= sdCylinderXY(p, vec2(22.0,2.0) );\n    float d1b= sdCylinderXY(p, vec2(21.0,2.5) );\n     d1a= Difference(d1a, d1b);\n    p=p0; \n    float d2a= sdCylinderXY(p, vec2(17.0,2.0) );\n    float d2b= sdCylinderXY(p, vec2(16.5,2.5) );\n     d2a= Difference(d2a, d2b); \n    p=p0;\n    \n    //cruz 1\n    p= rotate_y(p, -t); \n    p= rotate_z(p, 0.79);\n    float d3a= sdBox(p, vec3(40.0,1.0,3.0) );\n    float d3b= sdBox(p, vec3(1.0,40.0,3.0) );\n    p=p0;\n    \n    //cruz 2\n    p= rotate_x(p, 0.79); //45 grad\n    p= rotate_z(p, 0.79);\n    float d4a= sdBox(p-vec3(0.0,0.0,10.0), vec3(40.0,1.0,3.0) );\n    float d4b= sdBox(p-vec3(0.0,0.0,10.0), vec3(1.0,40.0,3.0) );\n    p=p0;\n    \n     p= rotate_y(p,-t);\n    float d5a= sdHeart((p.xy-vec2(-10.0,-5.0))*0.155 );\n    float d5b= sdBox(p-vec3(-10.0,-5.0,8.0), vec3(10.0,10.0,1.0) );\n    d5a= Intersect(d5a, d5b);\n    \n    res =opU2(res, vec2(d1a,100.0));\n    res =opU2(res, vec2(d2a,100.0));\n        res =opU2(res, vec2(d3a,101.0));\n        res =opU2(res, vec2(d3b,101.0));\n    res =opU2(res, vec2(d4a,100.0));\n    res =opU2(res, vec2(d4b,100.0));\n        res =opU2(res, vec2(d5a,2.0));\n    \n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) \n    { \n    float t=iTime;\n    p= rotate_y(p, -t); \n    p= rotate_z(p, 0.79);//45 grad\n    \n    return tex3D(iChannel0, p/32., nor)*2.0; \n    }\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color==2) { return vec3(1.0,0.0,0.0); }\n     \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=35.0;\n   float veltime=10.0;  \n    float tt = radians( -iTime*veltime);\n    vec3  pos=vec3(0.0,0.0,35.0);\n    vec3 rotation1 = pos+vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n   ///mObj.uv=uv;\n    float t;\n    t=mod(iTime*1.0,500.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,0.0,-35.0);\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   if (10.0*sin(t*0.5)>0.0)\n   {\n     Ray rt=RotarEnCirculo(ro,rd);\n     ro=rt.ro;\n     rd=rt.rd;\n   }\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[515, 515, 547, 547, 631], [632, 632, 671, 671, 766], [767, 767, 806, 806, 901], [902, 902, 941, 941, 1036], [1038, 1082, 1126, 1126, 1153], [1154, 1154, 1194, 1194, 1221], [1222, 1222, 1267, 1267, 1295], [1297, 1322, 1356, 1356, 1452], [1453, 1453, 1487, 1487, 1578], [1579, 1579, 1613, 1613, 1704], [1706, 1706, 1731, 1731, 1750], [1751, 1751, 1776, 1776, 1795], [1796, 1796, 1832, 1832, 1860], [1862, 1868, 1896, 1896, 2116], [2118, 2118, 2143, 2143, 3412], [3414, 3414, 3438, 3438, 3600], [3602, 3602, 3650, 3650, 3929], [3932, 3932, 3976, 3976, 4297], [4299, 4299, 4336, 4336, 4593], [4595, 4595, 4685, 4685, 5645], [5647, 5647, 5696, 5696, 5932], [5936, 5936, 5968, 5968, 6258], [6261, 6261, 6331, 6331, 6487], [6489, 6489, 6516, 6516, 6605], [6607, 6607, 6665, 6665, 6713], [6715, 6715, 6738, 6738, 6850], [6852, 6852, 6883, 6883, 7503], [7506, 7506, 7543, 7543, 7813], [7815, 7815, 7872, 7872, 8429]], "test": "untested"}
{"id": "flSBDt", "name": "Pixel Tiling", "author": "SnoopethDuckDuck", "description": "I'm pretty happy with this one\n\nCC0 if you want to use it in a game or anything", "tags": ["grid", "pixel", "pixelart", "cc0"], "likes": 13, "viewed": 246, "published": 3, "date": "1652901499", "time_retrieved": "2024-07-30T16:48:21.191805", "image_code": "#define thc(a,b) tanh(a*cos(b))/tanh(a)\n\n// Square length\nfloat mlength(vec2 p) {\n    return max(abs(p.x), abs(p.y));\n}\n\nvec3 pal(in float t, in vec3 d) {\n    return 0.5 + 0.5 * cos( 6.28318*(t+d) );\n}\n\nfloat h21(vec2 a) {\n    a = mod(a, 301.); // Change 301. if you want\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nvec4 btlr(vec2 pos, float thr) {\n    return vec4( step( h21(pos - vec2(0,0.5)), thr ),\n                 step( h21(pos + vec2(0,0.5)), thr ),\n                 step( h21(pos - vec2(0.5,0)), thr ),\n                 step( h21(pos + vec2(0.5,0)), thr ) );\n}\n\nvec2 pattern(vec2 uv, float thr, float thk, vec4 bias) {\n    // Cut into a grid\n    vec2 ipos = floor(uv) + 0.5;\n    vec2 fpos = uv - ipos;\n    \n    // Cell edges (e.g. (1,0,0,1) => we have bottom and right edges)\n    vec4 ce = btlr(ipos, thr);\n  \n    // Draw the edges\n    float v =  ce.x * step(fpos.y, -thk);\n    v = max(v, ce.y * step(thk, fpos.y));\n    v = max(v, ce.z * step(fpos.x, -thk));\n    v = max(v, ce.w * step(thk, fpos.x));\n    \n    // (I'm only using 1.5 because thk = 0.25, 0.375 work well together)\n    thk *= 1.5;\n    \n    // Draw smaller edges (so we can keep v as an outline)\n    // bias determines which smaller edges get drawn/removed\n    float v2 =   bias.x * ce.x * step(fpos.y, -thk);\n    v2 = max(v2, bias.y * ce.y * step(thk, fpos.y));\n    v2 = max(v2, bias.z * ce.z * step(fpos.x, -thk));\n    v2 = max(v2, bias.w * ce.w * step(thk, fpos.x));\n\n    // Centre a grid at current grids corners, check edges attached to it        \n    // If there aren't any, don't draw a corner block\n    vec2 ipos2 = floor(uv - 0.5) + 0.5;\n    vec2 fpos2 = uv - 0.5 - ipos2;\n\n    // Shifted cell edges + number of edges in shifted cell\n    vec4 tle = btlr(ipos2 + 0.5, thr);\n    float sum = tle.x + tle.y + tle.z + tle.w;\n    \n    // Draw corner \"blocks\" if sum > 0\n    v = max(v, step(mlength(fpos2), 0.125) * (1. - step(sum,0.)));\n   \n    // Exterior, interior\n    return vec2(v, v2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    float osc = thc(3., uv.x - 0.5 * iTime);\n\n    uv += vec2(2,-1) * iTime / 32.;\n    uv *= 12.;\n    uv.y += 0.5 * osc;\n    \n    //uv.x = mix(uv.x, uv.x -0.5 + 0. * h21(floor(uv)), 0.5 + 0.5 * thc(4., 1.25 * uv.y + iTime));  \n          \n    // Threshold + thickness + which sides are removed internally (bias)\n    float thr = 0.75 - 0.25 * osc;\n    float thk = 0.25;\n    vec4 bias = vec4(1,0,1,0); // vec4(1,1,0,0); //vec4(1,0.25,1,0.25);\n    \n    // Get layer stuff\n    vec2 p1 = pattern(uv, thr * 0.25,  thk, bias);\n    vec2 p2 = pattern(uv, thr * 0.5,   thk, bias);\n    vec2 p3 = pattern(uv, thr * 0.75,  thk, bias);\n    vec2 p4 = pattern(uv, thr * 0.875, thk, bias);\n   \n    // Remove interior from exterior + darken\n    float v1 = (p1.x - p1.y) * 0.75;\n    float v2 = (p2.x - p2.y) * 0.25;\n    float v3 = (p3.x - p3.y) * 0.125;\n    float v4 = (p4.x - p4.y) * 0.0625;\n    \n    // Mix layers (mix with exterior so layers don't overlap)\n    float v = mix(v2, v1, p1.x);\n          v = mix(v3, v,  p2.x);\n          v = mix(v4, v,  p3.x);\n   \n    // Invert\n    v = 1. - v;\n    \n    vec3 col = v * pal(-0.1 * osc, 0.25 * vec3(1,0,0)/3.);\n \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSBDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 58, 81, 81, 119], [121, 121, 154, 154, 201], [203, 203, 222, 222, 341], [343, 343, 375, 375, 595], [597, 597, 653, 676, 1993], [1995, 1995, 2052, 2052, 3294]], "test": "untested"}
{"id": "NtBBDd", "name": "other UVs 2", "author": "elenzil", "description": "I keep trying stuff like this over the years but honestly it never delivers.\nU = lum(channel0)\nV = lum(channel1)", "tags": ["displacement", "uv"], "likes": 6, "viewed": 286, "published": 3, "date": "1652890122", "time_retrieved": "2024-07-30T16:48:21.955763", "image_code": "float lum(in vec3 rgb) {\n    return dot(rgb, rgb) / 3.0;\n}\n\nvoid mainImage(out vec4 RGBA, in vec2 XY) {\n    vec2 UV = XY/iResolution.xy;\n\n    float l0 = lum(texture(iChannel0, UV).rgb);\n    float l1 = lum(texture(iChannel1, UV).rgb);\n    \n    vec2 uv = vec2(l0, l1);\n    \n//  uv = iResolution.x/100.* vec2(dFdx(l0),dFdy(l0));\n    \n    uv = mix(uv, UV, cos(iTime * 0.2) * 0.1 + 0.9);\n    \n    RGBA = texture(iChannel2, uv);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBBDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 58], [60, 60, 103, 103, 424]], "test": "untested"}
{"id": "flSfDt", "name": "rotate curve", "author": "yanglian", "description": "curve", "tags": ["curve"], "likes": 3, "viewed": 210, "published": 3, "date": "1652889453", "time_retrieved": "2024-07-30T16:48:23.016925", "image_code": "/**\n\n*/\n#define PI 3.14159265\nbool isRenderAxis = false;\nfloat renderLine1(float x, float y)\n{\n    if(abs(y - sin(x)*sin(iTime)) < 0.01)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\nfloat renderLine2(float x, float y)\n{\n    if(abs(y - sin(x - 1.0)*sin(iTime + 1.0 * PI / 3.0)) < 0.01)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\nfloat renderLine3(float x, float y)\n{\n    if(abs(y - sin(x + 1.0)*sin(iTime + 2.0 * PI / 3.0)) < 0.01)\n    {\n        return 0.0;\n    }\n    else\n    {\n        return 1.0;\n    }\n}\nvec3 renderAxis(vec3 oriColor, float x, float y)\n{\n    vec3 color;\n    //render axis x\n    color = mix(oriColor, vec3(0.0, 0.0, 0.0), smoothstep(0.008, 0.0, abs(y)));\n    //render axis y\n    color = mix(color, vec3(0.0, 0.0, 0.0), smoothstep(0.008, 0.0, abs(x)));\n    return color;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos;\n    //,[-pipi][-1, 1]\n    if(iResolution.x > iResolution.y)\n    {\n        pos = 2.0 * (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n        if(PI * iResolution.y / iResolution.x > 1.0)\n        {\n            pos *= (PI * iResolution.y / iResolution.x);\n        }\n    }\n    else\n    {\n        pos = 2.0 * (fragCoord - 0.5 * iResolution.xy)/iResolution.x;\n        pos *= PI;\n    }\n    vec3 color = vec3(1.0, 0.70, 0.70);\n    float xx = pos.x;\n    float yy = pos.y;\n\n    if(isRenderAxis)\n    {\n        color = renderAxis(color, xx, yy);\n    }\n    color = mix(vec3(0.0, 1.0, 0.0), color, renderLine1(xx, yy));\n    color = mix(vec3(1.0, 0.0, 0.0), color, renderLine2(xx, yy));\n    color = mix(vec3(0.0, 0.0, 1.0), color, renderLine3(xx, yy));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSfDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 127, 127, 244], [245, 245, 282, 282, 422], [423, 423, 460, 460, 600], [601, 601, 651, 651, 884], [885, 885, 940, 940, 1806]], "test": "untested"}
{"id": "fljfWc", "name": "road ci", "author": "jorge2017a2", "description": "\n\nroad ci", "tags": ["roadci"], "likes": 16, "viewed": 264, "published": 3, "date": "1652882823", "time_retrieved": "2024-07-30T16:48:23.950429", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 110.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n//----------oPeraciones de Repeticion\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\nvec2 cilindromedida(vec3 p, vec3 pos, vec2 medida)\n{\tvec2 res= vec2(9999.0, -1.0); \n    float  d1a= sdCylinderXZ( p-pos, vec2(medida.x+0.5,medida.y) );\n    float  d1b= sdCylinderXZ( p-pos, vec2(medida.x,medida.y+.5) );\n    d1a= Difference(d1a, d1b);\n    res =opU2(res, vec2(d1a,100.0));\n    return res;\n}\n\nvec2 cilindrotdo(vec3 p, vec3 pos, vec2 medida)\n{\tvec2 res= vec2(9999.0, -1.0); \n    float  d1a= sdCylinderXZ( p-pos, vec2(medida.x+0.5,medida.y) );\n    res =opU2(res, vec2(d1a,100.0));\n    return res;\n}\n\nvec2 modelo1(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0); \n    vec2 re1= cilindromedida(p, vec3(0.0,7.0,0.0), vec2(4.0,5.0));\n    vec2 re2= cilindromedida(p, vec3(0.0,16.0,0.0), vec2(2.5,5.5));\n    vec2 re3= cilindromedida(p, vec3(0.0,25.0,0.0), vec2(1.5,7.25));\n    res =opU2(res, re1);\n    res =opU2(res, re2);\n    res =opU2(res, re3);\n    return res;\n}\n    \n\nvec2 modelo2(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0); \n    vec2 re1= cilindromedida(p, vec3(0.0,7.0,0.0), vec2(6.0,8.0));\n    vec2 re2= cilindromedida(p, vec3(0.0,20.0,0.0), vec2(4.5,5.0));\n    vec2 re3= cilindromedida(p, vec3(0.0,25.0,0.0), vec2(2.8,7.0));      \n    res =opU2(res, re1);\n    res =opU2(res, re2);\n    res =opU2(res, re3);\n    return res;\n}\n\n\nvec2 modelo3(vec3 p)\n{\tvec2 res= vec2(9999.0, -1.0); \n    vec2 re1= cilindrotdo(p, vec3(0.0,7.0,0.0), vec2(10.0,8.5));\n    vec2 re2= cilindromedida(p, vec3(5.0,18.0,0.0), vec2(3.5,5.3));\n    vec2 re3= cilindromedida(p, vec3(-5.0,18.0,0.0), vec2(3.5,7.0));      \n    res =opU2(res, re1);\n    res =opU2(res, re2);\n    res =opU2(res, re3);\n    return res;\n}\n\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n   vec3 p1=p;\n   vec3 p2=p-vec3(12.0,0.0,0.0);\n   vec3 p3=p-vec3(32.0,0.0,0.0);\n   p1.x= opRep1D(p.x, 40.0 );\n   p2.x= opRep1D(p.x, 55.0 );\n   p3.x= opRep1D(p.x, 75.0 );\n   vec2 m1= modelo1(p1);\n   vec2 m2= modelo2(p2);\n   vec2 m3= modelo3(p3);\n   res =opU2(res,m1);\n   res =opU2(res,m2);\n   res =opU2(res,m3);\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n}\n\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n}\n\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*10.0,1000.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   \n   vec3 ro=vec3(15.0+t,45.0,-20.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, radians(45.0));\n   rd= rotate_y(rd, radians(20.0));\n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljfWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 462, 501, 501, 596], [597, 597, 636, 636, 731], [732, 732, 771, 771, 866], [868, 912, 956, 956, 983], [984, 984, 1024, 1024, 1051], [1052, 1052, 1097, 1097, 1125], [1126, 1164, 1200, 1200, 1245], [1246, 1271, 1305, 1305, 1401], [1402, 1402, 1436, 1436, 1527], [1528, 1528, 1562, 1562, 1653], [1656, 1656, 1708, 1708, 1960], [1962, 1962, 2011, 2011, 2165], [2167, 2167, 2189, 2189, 2517], [2524, 2524, 2546, 2546, 2879], [2882, 2882, 2904, 2904, 3236], [3239, 3239, 3264, 3264, 3676], [3678, 3678, 3702, 3702, 3864], [3866, 3866, 3914, 3914, 4193], [4196, 4196, 4240, 4240, 4561], [4563, 4563, 4600, 4600, 4857], [4859, 4859, 4949, 4949, 5909], [5911, 5911, 5960, 5960, 6038], [6042, 6042, 6074, 6074, 6364], [6367, 6367, 6437, 6437, 6535], [6537, 6537, 6564, 6564, 6653], [6655, 6655, 6713, 6713, 6761], [6763, 6763, 6786, 6786, 6898], [6900, 6900, 6931, 6931, 7551], [7553, 7553, 7610, 7610, 8124]], "test": "untested"}
{"id": "NljfDc", "name": "Simple Tiling 615", "author": "SnoopethDuckDuck", "description": "Trying to make pixel art and got this along the way, thought it looked nice. \n\nMaybe a wang tiling? Haven't put much thought into it", "tags": ["e"], "likes": 5, "viewed": 257, "published": 3, "date": "1652840567", "time_retrieved": "2024-07-30T16:48:24.954744", "image_code": "// Other ideas:\n// https://www.shadertoy.com/view/st2BW3\n// https://www.shadertoy.com/view/ft2fDc\n// https://www.shadertoy.com/view/sl2BW3\n\nfloat h21 (vec2 a, float rep) {\n    a = mod(a, rep);\n    return fract(sin(dot(a, vec2(12.9898, 78.233)))*43758.5453123);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float sc = 40.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n    vec2 fpos = fract(sc * uv) - 0.5;\n    \n    // threshold\n    float thr = 0.5;\n    float rep = 301.;\n    float hl = step( h21(ipos - vec2(0.5,0), rep), thr );\n    float hr = step( h21(ipos + vec2(0.5,0), rep), thr );\n    float hb = step( h21(ipos - vec2(0,0.5), rep), thr );\n    float ht = step( h21(ipos + vec2(0,0.5), rep), thr );\n    \n    float v =  hl * step(fpos.x, -0.25);\n    v = max(v, hr * step(0.25, fpos.x));\n    v = max(v, hb * step(fpos.y, -0.25));\n    v = max(v, ht * step(0.25, fpos.y));\n        \n    fragColor = vec4(v,v,v,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 171, 171, 262], [264, 264, 321, 321, 995]], "test": "untested"}
{"id": "fljBWc", "name": "Liquid Toy", "author": "leon", "description": "Another liquid blob", "tags": ["noise", "mouse", "fluid", "abstract", "oil", "smoke", "paint"], "likes": 363, "viewed": 10850, "published": 3, "date": "1652839245", "time_retrieved": "2024-07-30T16:48:25.711721", "image_code": "\n// Liquid toy by Leon Denise 2022-05-18\n// Playing with shading with a fake fluid heightmap\n\n// 2023-01-20 update:\n// fix scalars to be resolution independant\n// (samed speed and look at different frame size)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy / 1024.).rgb;\n    \n    // value from buffer A\n    vec4 data =  texture(iChannel0, uv);\n    float gray = data.x;\n    \n    // gradient normal from gray value\n    float range = 3.;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1);\n    vec3 unit = vec3(range/472./aspect,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray*gray));\n        \n    // backlight\n    vec3 color = vec3(.3)*(1.-abs(dot(normal, vec3(0,0,1))));\n    \n    // specular light\n    vec3 dir = normalize(vec3(0,1,2));\n    float specular = pow(dot(normal, dir)*.5+.5,20.);\n    color += vec3(.5)*ss(.2,1.,specular);\n    \n    // rainbow\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*1.+dot(normal, dir)*4.-uv.y*3.-3.);\n    color += tint * smoothstep(.15,.0,gray);\n\n    // dither\n    color -= dither.x*.1;\n    \n    // background blend\n    vec3 background = vec3(1);\n    background *= smoothstep(1.5,-.5,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), ss(.01,.1,gray));\n    \n    // display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(tint);\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Liquid toy by Leon Denise 2022-05-18\n// Playing with shading with a fake fluid heightmap\n\nconst float speed = .01;\nconst float scale = .1;\nconst float falloff = 3.;\nconst float fade = .4;\nconst float strength = 1.;\nconst float range = 5.;\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += texture(iChannel0, p/amplitude).xyz * amplitude;\n        amplitude /= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec2 aspect = vec2(iResolution.x/iResolution.y, 1);\n    \n    // noise\n    vec3 spice = fbm(vec3(uv*scale,iTime*speed));\n    \n    // draw circle at mouse or in motion\n    float t = iTime*2.;\n    vec2 mouse = (iMouse.xy - iResolution.xy / 2.)/iResolution.y;\n    if (iMouse.z > .5) uv -= mouse;\n    else uv -= vec2(cos(t),sin(t))*.3;\n    float paint = trace(length(uv),.1);\n    \n    // expansion\n    vec2 offset = vec2(0);\n    uv = fragCoord.xy / iResolution.xy;\n    vec4 data = texture(iChannel1, uv);\n    vec3 unit = vec3(range/472./aspect,0);\n    vec3 normal = normalize(vec3(\n        TEX1(uv - unit.xz)-TEX1(uv + unit.xz),\n        TEX1(uv - unit.zy)-TEX1(uv + unit.zy),\n        data.x*data.x)+.001);\n    offset -= normal.xy;\n    \n    // turbulence\n    spice.x *= 6.28*2.;\n    spice.x += iTime;\n    offset += vec2(cos(spice.x),sin(spice.x));\n    \n    uv += strength * offset / aspect / 472.;\n    \n    // sample buffer\n    vec4 frame = texture(iChannel1, uv);\n    \n    // temporal fading buffer\n    paint = max(paint, frame.x - iTimeDelta * fade);\n    \n    // print result\n    fragColor = vec4(clamp(paint, 0., 1.));\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n#define TEX1(uv) texture(iChannel1, uv).r\n#define TEX2(uv) texture(iChannel2, uv).r\n#define TEX3(uv) texture(iChannel3, uv).r\n\n// shorcut for smoothstep uses\n#define trace(edge, thin) smoothstep(thin,.0,edge)\n#define ss(a,b,t) smoothstep(a,b,t)\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljBWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 268, 292, 1692]], "test": "untested"}
{"id": "7lBBDc", "name": "Tent and Logistic Map", "author": "mAmaro", "description": "Reading Fractal Horizons which introduced tent and logistic maps so I decided to make this to help me understand them. ", "tags": ["map", "logistic", "tent"], "likes": 7, "viewed": 312, "published": 3, "date": "1652823058", "time_retrieved": "2024-07-30T16:48:26.599347", "image_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a,\n    b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    float l = length(p - b * h);                         // dist to segment\n    return smoothstep(0.001, 0.0, l);\n}\n\nfloat UVDot(float UVRadius, vec2 UVPos, float UVFade, vec2 uv, float UVRange)\n{\n    return smoothstep(UVRange-UVFade, UVRange, length(uv-UVPos)/UVRadius);\n}\n\nfloat rand(vec2 uv, float freq)\n{\n    float result = 0.0; \n    vec3 a = fract(uv.xyx * vec3(123.45, 345.678, 567.89));\n    a += dot(a, a + 345.578*(1.0+0.5*cos(iTime*freq)));   \n    result = fract(a.x*a.y*a.z);\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(0.0);\n    vec2 uv = gl_FragCoord.xy/iResolution.xy;\n    float olduvx =uv.x;\n    uv.x*=iResolution.x/iResolution.y;\n    uv.x+=1.5-iResolution.x/iResolution.y;\n    color += vec3(uv.x, uv.y, abs(sin(iTime)))*0.2;\n    \n    //~ Tent Map I think???\n    float x0 = 1.0*(.5+.5*sin(iTime*0.4));\n    float c0 = line(uv, vec2(0.0, 0.), vec2(1., 1.));\n    float c1 = 0.0;\n    float c2 = 0.0;\n#if 1\n    //Tent Map Plot\n    for(int i=0;i<10;i++)\n    {\n        float r = 2.;//(.5+.5*sin(iTime*0.2));\n        float x1 = (r/2.)-r*abs(x0-1./2.);\n        vec2 Point = vec2(x0,x1);\n        c0 += 1.-UVDot(0.02, Point, 1.5, uv, 1.0);\n        c0 += line(uv, vec2(x0, 0.0), vec2(x0, x1));\n        c0 += line(uv, vec2(0.0, x1), vec2(x0, x1));\n        x0 = x1;\n    }\n#endif\n#if 1\n    //Logistic Map Plot from r = 3.68\n    float x = mod(iTime*0.000002, 50.0)/50.0;\n    int itr= 50;\n    for(int i=0;i<itr;i++)\n    {\n        float r = 3.68;\n        float x1 = x*r*(1.-x);\n        float x0 = float(i)/float(itr);\n        vec2 Point = vec2(x0,x1);\n        c1 += 1.-UVDot(0.005, Point, 0.0, uv, 1.0);\n        c1 += line(uv, vec2(x0, 0.0), vec2(x0, x1));\n        //c1 += line(uv, vec2(0.0, x1), vec2(x0, x1));\n        x = x1;\n    }\n#endif\n#if 1\n    {\n        //Logistic Map Bifurcation Diagram\n        float x = mod(iTime*0.00000001, 100.0)/100.0;\n        int itr= 50;\n        for(int i=0;i<itr;i++)\n        {\n            float r = uv.x*4.0;\n            float x1 = x*r*(1.-x);\n            float x0 = float(i)/float(itr);\n            vec2 Point = vec2(x0,x1);\n            c2 += 1.-UVDot(0.01, Point, 900.0, uv, 1.0);\n            c2 += line(uv, vec2(x0, 0.0), vec2(x0, x1));\n            c2 += line(uv, vec2(0.0, x1), vec2(x0, x1));\n            x = x1;\n        }\n    }\n#endif\n    color += c0*vec3(1.0,0.,1.) + c1*vec3(1.,1.,0.) + c2*vec3(0.,1.,1.);\n    fragColor = vec4(color,1.0);\n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBBDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 252], [254, 254, 333, 333, 410], [412, 412, 445, 445, 643], [645, 645, 702, 702, 2573]], "test": "untested"}
{"id": "slBBDc", "name": "Cantorized Smoothstep Motion", "author": "iq", "description": "Testing this shader: [url]https://www.shadertoy.com/view/7tBfD3[/url]", "tags": ["2d", "smoothstep", "cantorization"], "likes": 29, "viewed": 1050, "published": 3, "date": "1652822783", "time_retrieved": "2024-07-30T16:48:27.361310", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Testing this shader: https://www.shadertoy.com/view/7tBfD3\n\n\n// smoothstep and its inverse\n// https://iquilezles.org/articles/ismoothstep/\nfloat csmoothstep( float x ) { return x*x*(3.0-2.0*x); }\nfloat inverse_csmoothstep( float x) { return 0.5-sin(asin(1.0-2.0*x)/3.0); }\n\n// cantorization of smoothstep\nfloat cantor( float x )\n{\n    float y = 0.0;\n    float sc = 0.5;\n    float bi = 0.0;\n    float xa = 0.0;\n    float xb = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        // choose subdivision intervals\n        float ya = csmoothstep(xa);\n        float yb = csmoothstep(xb);\n        float wa = inverse_csmoothstep(ya+(yb-ya)/3.0);\n        float wb = inverse_csmoothstep(yb-(yb-ya)/3.0);\n        // recurse\n             if( x<wa ) { bi+=0.0*sc; y=bi+sc*(x-xa)/(wa-xa); xb=wa; }\n        else if( x>wb ) { bi+=1.0*sc; y=bi+sc*(x-wb)/(xb-wb); xa=wb; }\n        else            { bi+=0.0*sc; y=bi+sc;                break; }\n        sc *= 0.5;\n    }\n    return y;\n}\n\n// render\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // pixel coordinates\n    vec2  p = fragCoord/iResolution.y;\n    float px = 1.0/iResolution.y;\n    float mx = iResolution.x*px;\n\n    // size of disks\n    const float ra = 0.15;\n\n    // movement (repeat every 4 seconds)\n    float time = 1.0-abs(2.0*fract(iTime/4.0)-1.0);\n    float x = (p.y>0.5) ? cantor(time) : \n                          csmoothstep(time);\n    // center\n    vec2 c = vec2(ra+(mx-ra*2.0)*x, (p.y>0.5)?0.75:0.25);\n    \n    // disks\n    float d = length(p-c)-ra;\n    \n    // color\n    vec3 col = vec3( 0.2+0.8*smoothstep(px,-px,d) );\n\n    fragColor = vec4( col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBBDc.jpg", "access": "api", "license": "mit", "functions": [[1142, 1220, 1250, 1250, 1276], [1277, 1277, 1314, 1314, 1353], [1355, 1386, 1411, 1411, 2042], [2044, 2054, 2111, 2136, 2699]], "test": "untested"}
{"id": "st2BzK", "name": "Fluid Spectrum", "author": "theschwa", "description": "Using a simple fluid simulator to advect the rainbow. Spacebar to reset. Mouse to interact. \n\nUsing a fluid solver based on \"Simple and Fast Fluids\" https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids", "tags": ["spectrum", "fluid", "rainbow", "liquid"], "likes": 3, "viewed": 325, "published": 3, "date": "1652820308", "time_retrieved": "2024-07-30T16:48:28.168152", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1./iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    //vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    vec2 st = uv;\n    uv = move(uv, iTime*.05);\n    vec3 col;\n    col = texture(iChannel0, uv ).rgb;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Velocity Field\n\nvec2 initialVel( vec2 uv ) {\n    //uv += vec2( iTime*.029, iTime*.017 );\n    // Start with a nice looking flow field and switch to noise after 1min\n    vec2 noise = vec2( fbm(uv), fbm(uv + vec2(31., 70.) ) );\n    vec2 field = vec2( cos( 2. * 3.14159 * uv.y ), cos( 2. * 3.14159 * uv.x) );\n    return step(-60., -iTime)*field + step(60., iTime)*noise;\n}\n\nfloat window( float t, float width ) {\n    return step(-width, -t)*step(0., t);\n}\n\nfloat sawWave( float t, float width ) {\n    return mod(-t, width)/width;\n}\n\nfloat impulse( float t, float width ) {\n    return sawWave(t, width)*window(t, width);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 texel = 1./iResolution.xy;\n    vec2 uv = fragCoord * texel;\n    bool spaceBar = texelFetch(iChannel1,ivec2(32,1),0).x > 0.;\n    if( iFrame < 10 || spaceBar ) {\n        vec3 col = vec3( initialVel(uv) , 0.5 );\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    \n    // Adapted from https://www.researchgate.net/publication/229039366_Simple_and_Fast_Fluids\n    \n    float dt = iTimeDelta;\n    dt = 0.15;\n    float v = 0.5; // viscosity \n    vec2 ExternalForces = vec2( 0. );\n    vec3 CScale = vec3(.5);\n    float K = .2;\n    float S = K/dt;\n    \n    vec4 FC = texture( iChannel0, uv );\n    vec3 FR = texture( iChannel0, uv + vec2(1., 0.)*texel ).xyz;\n    vec3 FL = texture( iChannel0, uv - vec2(1., 0.)*texel ).xyz;\n    vec3 FT = texture( iChannel0, uv + vec2(0., 1.)*texel ).xyz;\n    vec3 FD = texture( iChannel0, uv - vec2(0., 1.)*texel ).xyz;\n    \n    // du/dx , du/dy\n    vec3 UdX = (FR - FL) * CScale;\n    vec3 UdY = (FT - FD) * CScale;\n    \n    float Udiv = UdX.x + UdY.y;\n    vec2 DdX = vec2( UdX.z, UdY.z );\n    \n    \n    //\n    // Solve for density\n    //\n    FC.z -= dt * dot( vec3(DdX, Udiv) , FC.xyz );\n    //FC.z -= dt*( UdX.z * FC.x + UdY.z * FC.y + Udiv * FC.z );\n    \n    // Related to stability\n    FC.z = clamp( FC.z, 0.5, 3.0 );\n    \n    //\n    // Solve for Velocity\n    //\n    vec2 PdX = S * DdX;\n    vec2 Laplacian = ( FR + FL + FT + FD - 4.*FC.xyz ).xy;\n    \n\n    vec2 ViscosityForce = v*Laplacian;\n    \n    // Semi-lagrangian advection\n    vec2 Was = uv - dt*FC.xy*texel;\n    FC.xy = texture( iChannel0, Was ).xy;    \n    \n    if(iMouse.z>0.) {\n        vec2 offset = move(uv, iTime*.05) -uv;\n        vec2 corrected = mod( uv - offset, 1.);\n        vec2 m = 22.* (corrected -iMouse.xy*texel );\n        ExternalForces += normalize(m)*exp(-dot(m,m));\n    }\n    \n    // Periodically re-add inital forces\n    float period = 60.;\n    ExternalForces += impulse( mod(iTime, period), 1.)*initialVel(uv)*step(period,iTime)*.1;\n    \n    FC.xy += dt*( ViscosityForce - PdX + ExternalForces );\n    \n    FC = clamp(FC, vec4(-5.,-5.,0.5,0.), vec4(5.,5.,3.,5.));\n    \n    fragColor = FC;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Rainbow \n\nfloat isin( float ang ) {\n    return sin(ang)*.5 + .5;\n}\n\nfloat icos( float ang ) {\n    return cos(ang)*.5 + .5;\n}\n\n// Starting Color Field\nvec3 randColInit( vec2 uv ) {\n    uv += vec2(.157, .293);\n    // Slowly move to add some color variety when zoomed in\n    uv += vec2( sin(iTime*.0607 + 563.), -cos(iTime*.0613 + 857.) );\n    float val = fbm( uv * 5. )*.5 + .5 ;\n    // Change the gain with the zoom to prevent it from getting too dark\n    val = gain(val, mix(2.,7., isin(iTime*.223)) ); \n    return spectral_zucconi( val );\n}\n\n// Color Field to Add\nvec4 randCol( vec2 uv ) {\n    uv = (uv-.5)*isin(iTime*.223);\n    return vec4(randColInit( uv ), 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord  )\n{\n    vec2 texel = 1./iResolution.xy;\n    \n    vec2 uv = fragCoord * texel;\n    bool spaceBar = texelFetch(iChannel2,ivec2(32,1),0).x > 0.;\n    if( iFrame < 10 || spaceBar ) {\n        vec3 col;\n        col = randColInit(uv);\n        fragColor = vec4(col, 1.);\n        return;\n    }\n    vec2 vel  = texture(iChannel0, uv).xy;    \n    vec4 new  = texture(iChannel1, uv - vel*texel ); // Advection\n    \n    // Acount for the \"camera\" movement in the Image tab\n    vec2 offset = move(uv, iTime*.05) -uv;\n    vec2 corrected = mod( uv - offset, 1.);\n    \n    // Vary the scale and position of the color noise field\n    vec4 orig = randCol(corrected);\n    orig = 1.5*(orig - .5) + .5; // Incrase contrast\n    \n    //fragColor = orig;\n    //return;\n    \n    // Continually add new colors varying the amount added\n    fragColor = mix( new, orig, mix(0.0001,.003, icos(iTime*.053) ) );\n    \n    if(iMouse.z>0.) {\n        vec2 m = 22.* (corrected -iMouse.xy*texel );\n        float alpha = exp(-dot(m,m));\n        fragColor = mix(fragColor, orig, alpha);\n    }\n\n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float to01( float num ) {\n    return num*.5 + .5;\n}\n\nvec2 move( vec2 uv, float t ) {\n    t *= .997;\n    return vec2( uv.x + cos(t), uv.y + sin(t) );\n}\n//----- From: https://www.alanzucconi.com/2017/07/15/improving-the-rainbow-2/\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 bump3y (vec3 x, vec3 yoffset) {\n    vec3 y = 1. - x * x;\n    y = clamp(y-yoffset, 0., 1.);\n    return y;\n}\nvec3 spectral_zucconi(float x) {\n    // x: [0,   1]\n    vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n    vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n    vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n    return bump3y (    cs * (x - xs), ys);\n}\n\n//----- END\n\n// By IQ: https://www.shadertoy.com/view/XdXBRH\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n\n// return gradient noise (in x) and its derivatives (in yz)\nfloat noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 0\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return va  + u.x*(vb-va) \n               + u.y*(vc-va) \n               + u.x*u.y*(va-vb-vc+vd);\n}\n\nfloat fbm( vec2 x )\n{    \n    float G = .5;\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    int numOctaves = 4;\n    for( int i=0; i<numOctaves; i++ )\n    {\n        t += a*noised(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n// https://iquilezles.org/articles/warp/\nvec2 warp( vec2 p ) {\n    p *= 2.;\n    vec2 q = vec2( fbm( p + vec2(0.0,0.0) ),\n                   fbm( p + vec2(5.2,1.3) ) );\n    vec2 r = vec2( fbm( p + 4.0*q + vec2(1.7,9.2) ),\n                   fbm( p + 4.0*q + vec2(8.3,2.8) ) );\n    return p + 4.*q;\n}\n\nfloat gain(float x, float k) \n{\n    float a = 0.5*pow(2.0*((x<0.5)?x:1.0-x), k);\n    return (x<0.5)?a:1.0-a;\n}\n\nvec3 colGain(vec3 c, float k ) {\n    float r = gain(c.r, k);\n    float g = gain(c.g, k);\n    float b = gain(c.b, k);\n    return vec3(r, g, b);\n}\n\nvec3 colorNoise ( vec2 uv ) {\n    uv *= 40.;\n    vec3 col = vec3(0., 0., 0.);\n    col.x = noised( uv );\n    col.y = noised( uv + vec2(10., 13.) );\n    col.z = noised( uv + vec2(-17., -15.) );\n    \n    col = .5 + .5*col;\n    return colGain(col, 3.);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2BzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 323]], "test": "untested"}
{"id": "7tBfD3", "name": "Generalized Devil's Stairs", "author": "iq", "description": "The standard [url=https://en.m.wikipedia.org/wiki/Cantor_function]Devil's Stairs[/url] climbs around the y=x line, but it can be generalize to any monotonic function for which we can compute its inverse; in this case I'm using a smoothstep.", "tags": ["2d", "fractal", "stairs", "devil", "cantor", "generalized", "generalization"], "likes": 36, "viewed": 883, "published": 3, "date": "1652818950", "time_retrieved": "2024-07-30T16:48:29.011896", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// The Devil's Stairs (https://en.m.wikipedia.org/wiki/Cantor_function) climbs around f(x)=x\n// but can be generalize to any monotonic function for which we can compute the inverse.\n\nfloat fun_smt( float x, float k ) { return pow(x,k)/(pow(x,k)+pow(1.0-x,k)); }\nfloat inv_smt( float x, float k ) { return fun_smt(x,1.0/k); }\nfloat fun_pow( float x, float k ) { return pow(x,k); }\nfloat inv_pow( float x, float k ) { return fun_pow(x,1.0/k); }\n\nfloat function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? fun_smt(x,k) : fun_pow(x,k);\n}\nfloat inverse_function( float x, float t )\n{\n    float k = exp2(3.0*(0.5-0.5*cos(t*6.283185/3.0)));\n    return (t<3.0) ? inv_smt(x,k) : inv_pow(x,k);\n}\n\n// generalization of Devil's Staircase\nfloat cantor( float x, float t )\n{\n    float y = 0.0;\n    float sc = 0.5;\n    float bi = 0.0;\n    float xa = 0.0;\n    float xb = 1.0;\n    for( int i=0; i<9; i++ )\n    {\n        // choose subdivision intervals\n        float ya = function(xa,t);\n        float yb = function(xb,t);\n        float wa = inverse_function(ya+(yb-ya)/3.0,t);\n        float wb = inverse_function(yb-(yb-ya)/3.0,t);\n        // recurse\n             if( x<wa ) { bi+=0.0*sc; y=bi+sc*(x-xa)/(wa-xa); xb=wa; }\n        else if( x>wb ) { bi+=1.0*sc; y=bi+sc*(x-wb)/(xb-wb); xa=wb; }\n        else            { bi+=0.0*sc; y=bi+sc;                break; }\n        sc *= 0.5;\n    }\n    return y;\n}\n\n// https://iquilezles.org/articles/distfunctions2d/\nfloat sdLine( in vec2 p, in vec2 a, in vec2 b )\n{\n\tvec2 pa = p-a, ba = b-a;\n\treturn length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // pixel coords\n    float px = 1.0/iResolution.y;\n    vec2  p = (vec2((iResolution.y-iResolution.x)/2.0,0.0)+fragCoord)*px;\n    \n    // animation loop\n    float t = mod(iTime,6.0);\n\n    // render\n    vec3 col = vec3(0.0);\n    if( p.x>0.0 && p.x<1.0 )\n    {\n        // background\n        col = vec3( 0.04 + 0.008*mod(floor(p.x*10.0)+floor(p.y*10.0),2.0) );\n\n        // plot\n        vec2 d = vec2(1e20);\n        for( int i=-2; i<2; i++ )\n        {\n            float x0 = p.x + px*float(i+0);\n            float x1 = p.x + px*float(i+1);\n            d.x = min( d.x, sdLine(p, vec2(x0, function(x0,t)), \n                                      vec2(x1, function(x1,t))));\n            d.y = min( d.y, sdLine(p, vec2(x0, cantor(  x0,t)), \n                                      vec2(x1, cantor(  x1,t))));\n        }\n        col = mix( col, vec3(0.25,0.25,0.25), 1.0-smoothstep(0.0007,0.0007+px,d.x) );\n        col = mix( col, vec3(1.00,0.36,0.04), 1.0-smoothstep(0.0007,0.0007+px,d.y) );\n    }\n    \n    // gamma\n    col = sqrt(col);\n \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBfD3.jpg", "access": "api", "license": "mit", "functions": [[1261, 1261, 1296, 1296, 1339], [1340, 1340, 1375, 1375, 1402], [1403, 1403, 1438, 1438, 1457], [1458, 1458, 1493, 1493, 1520], [1522, 1522, 1558, 1558, 1665], [1666, 1666, 1710, 1710, 1817], [1819, 1858, 1892, 1892, 2519], [2521, 2573, 2622, 2622, 2710], [2712, 2712, 2769, 2790, 3835]], "test": "ok"}
{"id": "stSBWc", "name": "Band-Split Filter", "author": "TinyTexel", "description": "A filter with arbitrarily steep cut-off that cuts the frequency content in half.", "tags": ["filtering", "kernel"], "likes": 4, "viewed": 230, "published": 3, "date": "1652815392", "time_retrieved": "2024-07-30T16:48:30.037155", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    A filter with arbitrarily steep cut-off that cuts the frequency content in half.\n    \n    This actually is just the smooth square wave from here https://www.shadertoy.com/view/tlyyzd used as a filter response.\n  \n    Relevant code is in Buffer A.\n*/\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    float b = ceil((iResolution.y - SIZE)*0.5);\n    \n    if(uv0.y < b || uv0.y > iResolution.y-b) { outCol = vec4(0.11); return; }\n    \n    uv0.y -= b;\n    \n    vec2 tc = uv0/iResolution.xy;\n    \n    vec3 col = vec3(0.0);\n    \n    if (tc.x > 0.5)\n    {\n        // fft\n        vec2 dft = texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE,0.0)), 0).xy;\n        \n        float amp = length(dft); \n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*1.5,0.0)), 0).xy);\n         //amp += length(texelFetch(iChannel1, ivec2(uv0-0.5-vec2(SIZE*.5,0.0)), 0).xy); amp *= 0.5;\n        \n        float s = 0.005;\n        amp *= s;\n        \n        col = vec3(amp);\n\n        if(amp <= exp2(-13.0)) col = vec3(1.0, 0.0, 0.0)*0.25;\n        if(amp <= exp2(-16.0)) col = vec3(1.0, 0.5, 0.0)*0.25;\n        \n        col = clamp01(col);\n    }\t\n    else\n    {\n        // input\n        float n = texelFetch(iChannel0, ivec2(uv0-0.5), 0).x;\n        col = vec3((n));\n        //if(n < 0.0) col *= vec3(1.0, 0., 0.0);\n        \n        col = pow(clamp01(col), vec3(1.0/2.2));\n    }\n    \n\n    outCol = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n  #define SIZE (floor(iResolution.y/2.25)*2.)\n\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nvec2 cossin(float x) { return vec2(cos(x), sin(x)); }\n\nvec2 cmul(vec2 c0, vec2 c1)\n{\n\treturn vec2(c0.x * c1.x - c0.y * c1.y, \n\t\t        c0.y * c1.x + c0.x * c1.y);\n}\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Melissa E. ONeill - \"PCG: A Family of Simple Fast Space-Efficient Statistically Good Algorithms for Random Number Generation\"\n// https://www.cs.hmc.edu/tr/hmc-cs-2014-0905.pdf\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nvec4  Hash01x4(inout uint state) { return Float01(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash01x3(inout uint state) { return Float01(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash01x2(inout uint state) { return Float01(uvec2(pcg(state), pcg(state))); }\nfloat Hash01  (inout uint state) { return Float01(      pcg(state)); }\n\nvec4  Hash11x4(inout uint state) { return Float11(uvec4(pcg(state), pcg(state), pcg(state), pcg(state))); }\nvec3  Hash11x3(inout uint state) { return Float11(uvec3(pcg(state), pcg(state), pcg(state))); }\nvec2  Hash11x2(inout uint state) { return Float11(uvec2(pcg(state), pcg(state))); }\nfloat Hash11  (inout uint state) { return Float11(      pcg(state)); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n", "buffer_a_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define FILTER_WIDTH 8\n\n\nfloat Read(vec2 uv)\n{\n    float size = SIZE*1.0;\n    if(uv.x < 0.0) uv.x += size;\n    if(uv.y < 0.0) uv.y += size;\n    \n    if(uv.x >= size) uv.x -= size;\n    if(uv.y >= size) uv.y -= size;\n    \n    return Hash01(uv, 0u);\n}\n\nvoid mainImage(out vec4 outCol, in vec2 uv0)\n{\n    if(uv0.x > SIZE || uv0.y > SIZE)\n    {\n        discard;\n    }\n    \n    vec2 uv = uv0 - 0.5;\n    \n    #if 0\n    if((uint(uv.x) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }\n    #endif\n    #if 0\n    if((uint(uv.y) & 1u) != 0u)\n    {\n        outCol = vec4(0.0);\n        return;\n    }    \n    #endif\n    //uv = floor(uv * 0.5) * 2.0;\n    //uv *= 2.0;\n    \n    float v = 0.0;\n   \n   #if 0\n    int r = 0;\n    float ws[] = float[](1.0);\n   #elif 0\n    int r = 1;\n    float ws[] = float[](0.5, 0.25);\n   #elif 0\n    int r = 2;\n    float ws[] = float[](0.5, 9.0/32.0, -1.0/32.0);\n   #elif 0\n    int r = 3;\n    float ws[] = float[](0.5, 75.0/256.0, -25.0/512.0, 3.0/512.0);\n   #elif 0\n    int r = 4;\n    float ws[] = float[](0.5, 1225.0/4096.0, -245.0/4096.0, 49.0/4096.0, -5.0/4096.0);\n   #elif 0\n    int r = 5;\n    float ws[] = float[](0.5, 19845.0/65536.0, -2205.0/32768.0, 567.0/32768.0, -405.0/131072.0, 35.0/131072.0 );\n   #elif 0\n    int r = 6;\n    float ws[] = float[](0.5, 160083.0/524288.0, -38115.0/524288.0, 22869.0/1048576.0, -5445.0/1048576.0, 847.0/1048576.0, -63.0/1048576.0);\n   #elif 1\n    \n    const int r = FILTER_WIDTH;\n    float ws[r+1];\n    \n    float n = float(r);\n    \n    float ww = 0.25;\n    for(float i = 1.0; i < n; ++i)\n    {\n        ww *= -(i * 2.0 - 1.0) / (i * 8.0);\n    }\n    \n    ws[r] = ww;\n    \n    float a = n * 2.0 - 1.0;\n    float b = n * 2.0;\n    float c = n * 2.0 + 1.0;\n    \n    int j = 1;\n    for(float i = 1.0; i < n; ++i, ++j)\n    {\n        ww *= ((i * 2.0 - c) * (i - b)) / \n              ((i * 2.0 - a) *  i     );\n        \n        ws[r - j] = ww;\n    }\n    \n    ws[0] = 0.5;\n    \n   #endif\n   \n    for(int y = -r; y <= r; ++y)\n    for(int x = -r; x <= r; ++x)\n    {\n        float w = ws[abs(x)] * ws[abs(y)];\n        // 0, 1, 3, 5, 7, ...\n        int x0 = (abs(x) * 2 - 1) * sign(x);\n        int y0 = (abs(y) * 2 - 1) * sign(y);\n        v += Read(uv + vec2(x0, y0)) * w;\n    }\n    \n    outCol = vec4(v, 0.0, 0.0, 1.0);\n    \n    return;\n}", "buffer_a_inputs": [], "buffer_b_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\tvec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        //vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\tfragColor.zw += cmul(xn, ang.x);\n\t\t//fragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal + Vertical Discrete Fourier Transform of the input \n//adapted from FabriceNeyret2's https://www.shadertoy.com/view/XtScWt\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord )\n{\n   \tfragColor = vec4(0);\n    \n    vec2 uv = fragCoord.xy - 0.5;\n    \n    if(fragCoord.x >= SIZE || fragCoord.y >= SIZE) {fragColor = vec4(0.01); return;}\n    \n    for(float i = 0.; i < SIZE; i++)  \n\t{\n\t\t//vec2 xn = texelFetch(iChannel0, ivec2(i, uv.y), 0).rg;\n        vec2 yn = texelFetch(iChannel1, ivec2(uv.x, i), 0).ba;\n\t\tvec2 ang = - 6.2831853 * (uv -SIZE/2.) * i/SIZE;\n\t\t//fragColor.zw += cmul(xn, ang.x);\n\t\tfragColor.xy += cmul(yn, ang.y);\n    }\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSBWc.jpg", "access": "api", "license": "cc0-1.0", "functions": [[328, 328, 374, 374, 1480]], "test": "untested"}
{"id": "NlSBW3", "name": "Brush toy", "author": "leon", "description": "Another graphic programming rabbit hole", "tags": ["abstract", "paint"], "likes": 79, "viewed": 2788, "published": 3, "date": "1652805483", "time_retrieved": "2024-07-30T16:48:30.841006", "image_code": "\n// Brush toy by Leon Denise 2022-05-17\n\n// I wanted to play further with shading and lighting from 2D heightmap.\n// I started by generating a heightmap from noise, then shape and curves.\n// Once the curve was drawing nice brush strokes, I wanted to add motion.\n// Also wanted to add droplets of paints falling, but that will be\n// for another sketch.\n\n// This is the color pass\n// Click on left edge to see layers\n\n// The painting pass (Buffer A) is using FBM noise to simulate brush strokes\n// The curve was generated with a discrete Fourier Transform,\n// from https://www.shadertoy.com/view/3ljXWK\n\n// Frame buffer sampling get offset from brush motion,\n// and the mouse also interact with the buffer.\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color = vec3(.0);\n    \n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 dither = texture(iChannel1, fragCoord.xy / 1024.).rgb;\n    \n    // value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    // gradient normal from gray value\n    vec3 unit = vec3(3./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    \n    // specular light\n    vec3 dir = normalize(vec3(0,1,2.));\n    float specular = pow(dot(normal, dir)*.5+.5,20.);\n    color += vec3(.5)*specular;\n    \n    // rainbow palette\n    vec3 tint = .5+.5*cos(vec3(1,2,3)*1.5+gray*5.+uv.x*5.);\n    dir = normalize(vec3(uv-.5, 0.));\n    color += tint*pow(dot(normal, -dir)*.5+.5, 0.5);\n    \n    // background blend\n    vec3 background = vec3(.8)*smoothstep(1.5,0.,length(uv-.5));\n    color = mix(background, clamp(color, 0., 1.), smoothstep(.2,.5,noise.x));\n    \n    // display layers when clic\n    if (iMouse.z > 0.5 && iMouse.x/iResolution.x < .1)\n    {\n        if (uv.x < .33) color = vec3(gray);\n        else if (uv.x < .66) color = normal*.5+.5;\n        else color = vec3(.2+specular)*gray;\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Brush toy by Leon Denise 2022-05-17\n\n// The painting pass is using FBM noise to simulate brush strokes\n// The curve was generated with a discrete Fourier Transform,\n// from https://www.shadertoy.com/view/3ljXWK\n\n// Frame buffer sampling get offset from brush motion,\n// and the mouse also interact with the buffer.\n\nconst float speed = .01;\nconst float scale = 0.8;\nconst float falloff = 2.;\n\nvec2 mouse;\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += (texture(iChannel0, p/amplitude).xyz) * amplitude;\n        amplitude /= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    mouse = (iMouse.xy - iResolution.xy / 2.)/iResolution.y;\n    \n    // dithering\n    vec3 dither = texture(iChannel2, fragCoord.xy / 1024.).rgb;\n    \n    // sample curve position\n    float speed = 1.;\n    float t = -iTime*speed+dither.x*.01;\n    vec2 current = cookie(t);\n    \n    // velocity from current and next curve position\n    vec2 next = cookie(t+.01);\n    vec2 velocity = normalize(next-current);\n    \n    // move brush cursor along curve\n    vec2 pos = uv-current*1.6;\n    \n    float paint = fbm(vec3(pos, 0.) * scale).x;\n    \n    // brush range\n    float brush = smoothstep(.3,.0,length(pos));\n    paint *= brush;\n    \n    // add circle shape to buffer\n    paint += smoothstep(.05, .0, length(pos));\n    \n    // motion mask\n    float push = smoothstep(.3, .5, paint);\n    push *= smoothstep(.4, 1., brush);\n    \n    // direction and strength\n    vec2 offset = 10.*push*velocity/iResolution.xy;\n    \n    // mouse interaction\n    vec4 data = texture(iChannel1, vec2(0,0));\n    bool wasNotPressing = data.w < 0.5;\n    if (wasNotPressing && iMouse.z > .5) data.z = 0.;\n    else data.z += iTimeDelta;\n    data.z = clamp(data.z, 0., 1.);\n    vec2 mousePrevious = data.xy;\n    float erase = 0.;\n    if (iMouse.z > 0.5)\n    {\n        uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n        float mask = fbm(vec3(uv-mouse, 0.) * scale * .5).x;\n        mask = smoothstep(.3,.6,mask);\n        push = smoothstep(.2,.0,length(uv-mouse));\n        push *= mask;\n        vec2 dir = normalize(mousePrevious-mouse+.001);\n        float fadeIn = smoothstep(.0, .5, data.z);\n        float fadeInAndOut = sin(fadeIn*3.1415);\n        offset += 10.*push*normalize(mouse-uv)/iResolution.xy*fadeInAndOut;\n        erase = (.001 + .01*(1.-fadeIn)) * push;\n        push *= 500.*length(mousePrevious-mouse)*fadeIn;\n        offset += push*dir/iResolution.xy;\n    }\n    \n    // sample frame buffer with motion\n    uv = fragCoord.xy / iResolution.xy;\n    vec4 frame = texture(iChannel1, uv + offset);\n    \n    // temporal fading buffer\n    paint = max(paint, frame.x - .0005 - erase);\n    \n    // print result\n    fragColor = vec4(clamp(paint, 0., 1.));\n    \n    // save mouse position for next frame\n    if (fragCoord.x < 1. && fragCoord.y < 1.) fragColor = vec4(mouse, data.z, iMouse.z);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n// rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// generated with discrete Fourier transform\nvec2 cookie(float t) {\n\treturn vec2(0.08+cos(t-1.58)*0.23+cos(t*2.-1.24)*0.14+cos(t*3.-1.12)*0.09+cos(t*4.-0.76)*0.06+cos(t*5.-0.59)*0.05+cos(t*6.+0.56)*0.03+cos(t*7.-2.73)*0.03+cos(t*8.-1.26)*0.02+cos(t*9.-1.44)*0.02+cos(t*10.-2.09)*0.03+cos(t*11.-2.18)*0.01+cos(t*12.-1.91)*0.02,cos(3.14)*0.05+cos(t+0.35)*0.06+cos(t*2.+0.54)*0.09+cos(t*3.+0.44)*0.03+cos(t*4.+1.02)*0.07+cos(t*6.+0.39)*0.03+cos(t*7.-1.48)*0.02+cos(t*8.-3.06)*0.02+cos(t*9.-0.39)*0.07+cos(t*10.-0.39)*0.03+cos(t*11.-0.03)*0.04+cos(t*12.-2.08)*0.02);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSBW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[707, 707, 764, 764, 2053]], "test": "untested"}
{"id": "7tjfDV", "name": "Taste of Noise 18", "author": "leon", "description": "In the name of noise, fragmatum compilum", "tags": ["abstract"], "likes": 14, "viewed": 454, "published": 3, "date": "1652789007", "time_retrieved": "2024-07-30T16:48:31.685748", "image_code": "// Taste of Noise 18 by Leon Denise 2022-05-17\n// variation of https://www.shadertoy.com/view/fljBWK\n\n// A very distorted volume\n// Playing with a 3D FBM noise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Render result of Buffer A\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Taste of Noise 18 by Leon Denise 2022-05-17\n// variation of https://www.shadertoy.com/view/fljBWK\n\n// A very distorted volume\n// Playing with a 3D FBM noise\n\nfloat details;\n\n// rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// shortcut for lighting\n#define dt(rn,v,p) pow(dot(rn,normalize(v))*.5+.5,p)\n\n#define ss(a,b,t) smoothstep(a,b,t)\n\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*6.28*4.-iTime * .2));\n}\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float falloff = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += bend(texture(iChannel0, p/falloff).xyz) * falloff;\n        falloff /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float d = 0.;\n    d = length(p)-1.0;\n    \n    // FBM animated noise\n    vec3 ps = p * .04;\n    ps.z += iTime*.0005+.2;\n    vec3 spicy = fbm(ps);\n    details = spicy.x;\n    spicy = spicy * 2. - 1.;\n    \n    // displace volume\n    d += spicy.x * .9;\n    \n    // volume to surface\n    d = abs(d);\n    \n    return d * .025;\n}\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.01,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 noise = texture(iChannel1, fragCoord.xy/1024.+iTime).rgb;\n    vec3 ray = normalize(vec3(uv, .5));\n    vec3 pos = vec3(0,0,0);\n    \n    // init variables\n    vec3 color, normal, tint, dir, refl;\n    float index, shade, light;\n    const float count = 70.;\n\n    // ray marching\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*noise.z;\n        pos += ray*dist;\n    }\n    \n    // lighting\n    shade = index/count;\n    normal = getNormal(pos);\n    refl = reflect(ray, normal);\n    tint = .5+.5*cos(vec3(1,2,3)+details*5. + .5);\n    color += tint * dt(refl, vec3(0,1,-1), .3);\n    color += vec3(0.459,0.102,0.173)*dt(refl, vec3(0,-1,.5), .5);\n    color = mix(color, vec3(1), ss(.4,1.,dot(normal, -ray)));\n    color = clamp(color * shade * 1.5, 0., 1.);\n    \n    // temporal buffer\n    uv = fragCoord.xy / iResolution.xy;\n    vec3 frame = texture(iChannel2, uv).rgb;\n    color = mix(color, frame, .9);\n    \n    fragColor = vec4(color, 1.);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjfDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 218, 251, 338]], "test": "untested"}
{"id": "fl2fDK", "name": "Feather Fractal recreated", "author": "Fraktoler", "description": "Feather Fractal (z^3 / (1 + z  z)) recreated in Shadertoy.\nFractalSoundExplorer by @CodeParade reference.", "tags": ["fractal", "mandelbrot", "complex"], "likes": 3, "viewed": 775, "published": 3, "date": "1652762697", "time_retrieved": "2024-07-30T16:48:32.562404", "image_code": "//Credit: https://youtu.be/GiAj9WW1OfQ?t=315\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = exp((0.5 + 0.5 * cos(iTime * 0.35)) * (log(6.) - log(0.035)) + log(0.035));\n    vec2 center = vec2(0.254, 0.844);\n    vec2 c = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    vec2 z = c, z2;\n    int iter = 0;\n    const int max_iter = 256;\n    while (iter < max_iter) {\n        z2 = z * z;\n        z *= vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx;\n        z = div(z, vec2(1.0, 0.0) + z2) + c;\n        if (z2.x + z2.y > 1.0e3) {\n            break;\n        }\n        iter++;\n    }\n    if (iter == max_iter) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        float n = float(iter) * 0.1;\n        vec3 col = vec3(sin(n), cos(n), 1.0) * 0.5 + 0.5;\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2fDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 78, 78, 138], [140, 140, 197, 197, 941]], "test": "untested"}
{"id": "fljBWK", "name": "Taste of Noise 17", "author": "leon", "description": "Another colorful noise hell", "tags": ["abstract"], "likes": 21, "viewed": 652, "published": 3, "date": "1652760369", "time_retrieved": "2024-07-30T16:48:33.410137", "image_code": "\n// Taste of Noise 17 by Leon Denise 2022-05-17\n\n// A very distorted volume\n// Playing with a 3D FBM noise\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Render result of Buffer A\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// Taste of Noise 17 by Leon Denise 2022-05-17\n\n// A very distorted volume\n// Playing with a 3D FBM noise\n\nfloat details;\n\n// rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// shortcut for lighting\n#define dt(rn,v,p) pow(dot(rn,normalize(v))*.5+.5,p)\n\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k) { float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 ); return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n// transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*6.28*2.-iTime*.5));\n}\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float falloff = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += bend(texture(iChannel0, p/falloff).xyz) * falloff;\n        falloff /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float d = 0.;\n    \n    // FBM animated noise\n    vec3 ps = p * .05;\n    ps.z += iTime*.001;\n    vec3 spicy = fbm(ps);\n    details = spicy.x;\n    spicy = spicy * 2. - 1.;\n    \n    // displace volume\n    d += spicy.x * .2;\n    \n    // volume to surface\n    d = abs(d)-.1;\n\n    // substract volume from origin\n    float carve = -1.25+.25*sin(iTime*.1+length(p));\n    d = smin(d, -(length(p)-0.), carve);\n    \n    return d * .25;\n}\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.005,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 noise = texture(iChannel1, fragCoord.xy/1024.+iTime).rgb;\n    vec3 ray = normalize(vec3(uv, .5));\n    vec3 pos = vec3(0,0,0);\n    \n    // init variables\n    vec3 color, normal, tint, dir, refl;\n    float index, shade, light;\n    const float count = 50.;\n\n    // ray marching\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*noise.z;\n        pos += ray*dist;\n    }\n    \n    // lighting\n    shade = index/count;\n    normal = getNormal(pos);\n    tint = .5+.5*cos(vec3(1,2,3)+details*20.);\n    refl = reflect(ray, normal);\n    color += tint;\n    color += vec3(1.000,0.502,0.792)*dt(refl, vec3(0,0,-1), .5);\n    color = clamp(color * shade, 0., 1.);\n    \n    // temporal buffer\n    uv = fragCoord.xy / iResolution.xy;\n    vec3 frame = texture(iChannel2, uv).rgb;\n    color = mix(color, frame, .9);\n    \n    fragColor = vec4(color, 1.);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljBWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 165, 198, 285]], "test": "untested"}
{"id": "7tSfWV", "name": "Taste of Noise 16", "author": "leon", "description": "Noice noise", "tags": ["abstract"], "likes": 12, "viewed": 392, "published": 3, "date": "1652754514", "time_retrieved": "2024-07-30T16:48:34.215982", "image_code": "\n// Taste of Noise 16 by Leon Denise 2022-05-17\n\n// An experiment of lighting with a 3D FBM noise.\n// Trying to render organic volumes without raymarching.\n// Clic to display the diffent layers, which are from left to right: \n// height, normal, noise, glow, lighting and shape\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // value from noise buffer A\n    vec3 noise = texture(iChannel0, uv).rgb;\n    float gray = noise.x;\n    \n    // gradient normal from gray value\n    vec3 unit = vec3(5./iResolution.xy,0);\n    vec3 normal = normalize(vec3(\n        TEX(uv + unit.xz)-TEX(uv - unit.xz),\n        TEX(uv - unit.zy)-TEX(uv + unit.zy),\n        gray*gray));\n    \n    vec3 dir = normalize(vec3(0,1,.2)); // light direction\n    float angle = dot(normal, dir); // light and surface angle\n    vec3 color = vec3(.2); // ambient\n    float light = pow(angle*.5+.5,10.);\n    float soft = .5*smoothstep(.0,.2,gray-.75);\n    float glow = .1/(noise.y*noise.y)*noise.z;\n    vec3 tint = .5+.5*cos(vec3(1,2,3)+length(uv)*3.+iTime+angle); // iq palette\n    color += vec3(1)*light; // specular light\n    color += soft; // soft white\n    color += tint*glow; // glow rainbow\n    color *= gray; // shadows\n    \n    // display layers when clic\n    if (iMouse.z > 0.5)\n    {\n        if (uv.x < .16) color = vec3(gray);\n        else if (uv.x < .33) color = normal*.5+.5;\n        else if (uv.x < .5) color = vec3(1.-noise);\n        else if (uv.x < .66) color = vec3(glow);\n        else if (uv.x < .86) color = vec3(.2+light)*gray;\n        else color = vec3(soft);\n        if (uv.y < .02) color = .5+.5*cos(vec3(1,2,3)+uv.x*3.+iTime);\n    }\n\n    fragColor = vec4(color, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n// The noise animated pass with shape and glow layers\n\nconst float speed = .01;\nconst float scale = 0.08;\nconst float cycle = 1.5;\nconst float falloff = 1.8;\n\n// transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*cycle*6.283+iTime*6.283*speed*10.));\n}\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float amplitude = 0.5;\n    for (float index = 0.; index < 4.; ++index)\n    {\n        result += bend(texture(iChannel0, p/amplitude).xyz) * amplitude;\n        amplitude /= falloff;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // noise from coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 noise = fbm(vec3(uv, iTime * speed) * scale);\n    \n    // fade noise with circle\n    noise.x -= .5*smoothstep(.3,0.,abs(length(uv)-.6));\n    \n    // keyhole shape\n    float shape = 10.;\n    shape = min(shape, max(0.,length(uv-vec2(0,.05))-.07));\n    uv.y += .1;\n    shape = min(shape, max(0., moda(uv*rot(1.57), 3.).r-.05));\n    \n    // add shape to soft white\n    noise.x += .5*smoothstep(.1,0.,abs(shape-.03));\n    \n    // add shape to glow\n    noise.y *= smoothstep(.0,.1,abs(shape-.01));\n    \n    // remove shape\n    float hole = smoothstep(.04,.0,shape+.02);\n    noise.x -= hole*1.9;\n    noise.y += hole;\n    \n    fragColor = vec4(clamp(noise, 0., 1.), 1);\n}", "buffer_a_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// shortcut to sample texture\n#define TEX(uv) texture(iChannel0, uv).r\n\n// polar domain repetition used for the triangle\nvec2 moda(vec2 p, float repetitions)\n{\n\tfloat angle = 2.*3.14/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\ta = mod(a,angle) - angle/2.;\n\treturn vec2(cos(a), sin(a))*length(p);\n}\n\n// rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSfWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 278, 335, 354, 1734]], "test": "untested"}
{"id": "7tSfWm", "name": "Complex Numbers", "author": "Horriblebarry12", "description": "A shader trying to play around with rendering and visualizing complex numbers and complex functions. May turn into a c++ program in the future. Very much a work in progress.", "tags": ["math", "numbers", "complexnumbers"], "likes": 0, "viewed": 240, "published": 3, "date": "1652751073", "time_retrieved": "2024-07-30T16:48:35.230271", "image_code": "vec2 speed = vec2(1.0);\nconst float AxisThickness = 0.012;\nconst float MinorGridlines = 0.01;\n\nvec4 char(vec2 p, int c) \n{\n    if (p.x<.0|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n\treturn textureGrad( iChannel0, p/16. + fract( vec2(c, 15-c/16) / 16. ), dFdx(p/16.),dFdy(p/16.) );\n}\n\nvec4 print(vec2 uv, vec2 scale, vec2 position, int character)\n{\n    return char(((1.0/scale) * uv) - position, character).xxxx;\n}\n\nvec4 pInt(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) \n        v += char(p - vec2(-.5,0), 45 ),\n        n = -n;\n\n    for (float i = 3.; i>=0.; i--) \n        n /=  9.999999, // 10., // for windows :-(\n        v += char(p - .5*vec2(i,0), 48+ int(fract(n)*10.) );\n    return v;\n}\n\n// --- display float4.4\nvec4 pFloat(vec2 p, float n) {\n    vec4 v = vec4(0);\n    if (n < 0.) v += char(p - vec2(-.5,0), 45 ), n = -n;\n    float upper = floor(n);\n    float lower = fract(n)*1e4 + .5;  // mla fix for rounding lost decimals\n    if (lower >= 1e4) { lower -= 1e4; upper++; }\n    v += pInt(p,upper); p.x -= 2.;\n    v += char(p, 46);   p.x -= .5;\n    v += pInt(p,lower);\n    return v;\n}\n\nvec4 printFloat(vec2 uv ,vec2 scale, vec2 position, float number)\n{\n    return pFloat(((1.0/scale) * uv) - position, number).xxxx;\n}\n\nvec2 MovementOffset() \n{\n    return texelFetch(iChannel1, ivec2(0,0), 0).xy + (1.0*(texelFetch(iChannel3, ivec2(0), 0).xy));\n}\n\nvec2 LastMousePos()\n{\n    return texelFetch(iChannel2, ivec2(0), 0).xy;\n}\n\nfloat Zoom()\n{\n    float zoom = (texelFetch(iChannel1, ivec2(0), 0).z) + 1.0;\n    \n    \n   \n    return max(zoom,0.0000001);\n}\n\n\n\nvec2 ToLocal(vec2 point)\n{\n    return vec2((iResolution.x/2.0) + (point.x + (MovementOffset().x*speed.x)),\n    -(iResolution.y/2.0) + (point.y + (MovementOffset().y*speed.y)) )*0.01*Zoom();\n}\n\nvec2 ToVec2(ComplexNum num)\n{\n    return vec2(num.Real, num.Imaginary);\n}\n\nvec2 direction(vec2 from, vec2 to)\n{\n    return normalize(to-from);\n}\n\nint QuadrantNumber(vec2 coord)\n{\n    if (coord.x >= 0.0)\n    {\n        if (coord.y >= 0.0)\n        {\n            return 1;\n        }\n        else if (coord.y < 0.0)\n        {\n            return 4;\n        }\n    }\n    else if (coord.x < 0.0)\n    {\n        if (coord.y >= 0.0)\n        {\n            return 2;\n        }\n        else if (coord.y < 0.0)\n        {\n            return 3;\n        }\n    }\n}\n\n// x is the radius, y is the angle\nvec2 ToPolar(vec2 coord)\n{\n    float offset;\n    \n    int quadNum = QuadrantNumber(coord);\n    \n    if (quadNum == 1)\n    {\n        offset = 0.0;\n    }\n    else if (quadNum == 2 || quadNum == 3)\n    {\n        offset = 180.0;\n    }\n    \n    else\n    {\n        offset = 360.0;\n    }\n\n    return vec2(sqrt((coord.x*coord.x) + (coord.y*coord.y)), degrees(atan(coord.y/coord.x)) + offset);\n}\n\nvec3 HUEtoRGB(in float hue)\n{\n    // Hue [0..1] to RGB [0..1]\n    // See http://www.chilliant.com/rgb2hsv.html\n    vec3 rgb = abs(hue * 6. - vec3(3, 2, 4)) * vec3(1, -1, -1) + vec3(-1, 2, 2);\n    return clamp(rgb, 0., 1.);\n}\n\n\n// Hue-Saturation-Value [0..1] to RGB [0..1]\nvec3 HSVtoRGB(vec3 hsv)\n{\n    vec3 rgb = HUEtoRGB(hsv.x);\n    return ((rgb - 1.) * hsv.y + 1.) * hsv.z;\n}\n\nComplexNum ToComplexNum(vec2 inPoint)\n{\n    return ComplexNum(inPoint.x, inPoint.y);\n}\n\nbool inRange(float value, float range)\n{\n    return (value >= -range) && (value <= range);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    //speed = normalize(iResolution.xy);\n    speed*= 500.0;\n    \n    ComplexNum inPoint = ToComplexNum(ToLocal(vec2(fragCoord.x,fragCoord.y )));\n\n    ComplexNum fPoint = f(inPoint, iTime);\n    \n    vec2 uv = fragCoord/iResolution.y;\n\n    vec2 dir = direction(ToVec2(inPoint), ToVec2(fPoint));\n    \n    vec3 col = HUEtoRGB((ToPolar(dir).y)/360.0);\n    \n    if (length(dir) == 0.0)\n    {\n        col = vec3(0.0);\n    }\n    \n    \n    fragColor = vec4(col,1.0) * min(distance(vec2(0), ToVec2(fPoint)) * (2.0), 1.0);\n    \n    \n    \n    // Line\n    vec2 a = ToLocal(LastMousePos());\n    vec2 b = ToVec2(f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ) );\n    \n    \n    if (distance(ToVec2(fPoint), vec2(0)) < 0.001)\n    {\n        fragColor = vec4(0.0);\n    }\n    \n    if (DistanceToSegment(a, b, ToLocal(fragCoord)) < 0.01 * Zoom())\n    {\n        vec2 c = (a+b)/2.0;\n    \n        if(distance(ToLocal(fragCoord), c) <= distance(a, c))\n        {\n                fragColor = vec4(0.0);\n        }\n        \n        \n    }\n    \n\n    if (inRange(inPoint.Real, (AxisThickness* Zoom())))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    else if (inRange(inPoint.Imaginary, (AxisThickness* Zoom())))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    if (inRange(mod(inPoint.Imaginary, 1.0), MinorGridlines*Zoom()))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    if (inRange(mod(inPoint.Real, 1.0), MinorGridlines*Zoom()))\n    {\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    \n    \n    if (distance(ToLocal(fragCoord.xy), ToLocal(LastMousePos())) < 0.05 * Zoom())\n    {\n        fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    }\n    \n    if (distance(ToLocal(fragCoord.xy), ToVec2(f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ) ) ) <  0.05 * Zoom())\n    {\n        fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    \n        texelFetch(iChannel3, ivec2(1), 0);\n    vec2 scale = vec2(20.0 *(1.0/iResolution.y));\n    fragColor += vec4( print(uv, scale, vec2(0), 122).x); // z\n    fragColor += vec4( print(uv, scale, vec2(0.5,0), 61).x); // =\n    fragColor += vec4( print(uv, scale, vec2(1,0), 40).x); // (\n    fragColor += vec4( printFloat(uv, scale, vec2(2,0.0), ToLocal(LastMousePos()).x).x); // real\n    fragColor += vec4( print(uv, scale, vec2(6.5,0), 43).x); // +\n    fragColor += vec4( printFloat(uv, scale, vec2(7.5,0.0), ToLocal(LastMousePos()).y).x);\n    fragColor += vec4( print(uv, scale, vec2(12,0), 105).x); // i\n    fragColor += vec4( print(uv, scale, vec2(12.5,0), 41).x); // )\n    \n    fragColor += vec4( print(uv, scale, vec2(0, 1), 102).x); // f\n    fragColor += vec4( print(uv, scale, vec2(0.5, 1), 40).x); // (\n    fragColor += vec4( print(uv, scale, vec2(1,1), 122).x); // z\n    fragColor += vec4( print(uv, scale, vec2(1.5,1), 41).x); // )\n    fragColor += vec4( print(uv, scale, vec2(2.0,1), 61).x); // =\n    fragColor += vec4( print(uv, scale, vec2(2.5,1), 40).x); // (\n    fragColor += vec4( printFloat(uv, scale, vec2(3.5,1.0), f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ).Real).x); // real\n    fragColor += vec4( print(uv, scale, vec2(8,1), 43).x); // +\n    fragColor += vec4( printFloat(uv, scale, vec2(9,1.0), f(ToComplexNum( ToLocal(LastMousePos()) ), iTime ).Imaginary).x);\n    fragColor += vec4( print(uv, scale, vec2(13.5,1), 105).x); // i\n    fragColor += vec4( print(uv, scale, vec2(14,1), 41).x); // )\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// For details on how the keyboard input works, see iq's tutorial: https://www.shadertoy.com/view/lsXGzf\n\n\n\nvec3 handleKeyboard(vec3 offset) {\n    float velocity = 1. / 100.; // This will cause offset to change by 0.01 each time an arrow key is pressed\n    \n    // texelFetch(iChannel1, ivec2(KEY, 0), 0).x will return a value of one if key is pressed, zero if not pressed\n    vec2 left = texelFetch(iChannel1, ivec2(KEY_LEFT, 0), 0).x * vec2(-1, 0);\n    vec2 up = texelFetch(iChannel1, ivec2(KEY_UP,0), 0).x * vec2(0, 1);\n    vec2 right = texelFetch(iChannel1, ivec2(KEY_RIGHT, 0), 0).x * vec2(1, 0);\n    vec2 down = texelFetch(iChannel1, ivec2(KEY_DOWN, 0), 0).x * vec2(0, -1);\n    \n    float zoom = (-texelFetch(iChannel1, ivec2(KEY_IN, 0), 0).x) + (texelFetch(iChannel1, ivec2(KEY_OUT, 0), 0).x);\n    \n    offset += vec3(left + up + right + down, zoom) * velocity;\n    \n    return offset;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Return the offset value from the last frame (zero if it's first frame)\n    vec3 offset = texelFetch( iChannel0, ivec2(0, 0), 0).xyz;\n    \n    // Pass in the offset of the last frame and return a new offset based on keyboard input\n    offset = handleKeyboard(offset);\n    \n    // Store offset in the XY values of every pixel value and pass this data to the \"Image\" shader and the next frame of Buffer A\n    fragColor = vec4(offset, 0);\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// Numbers are based on JavaScript key codes: https://keycode.info/\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\n\nconst int KEY_IN = 73;\nconst int KEY_OUT = 79;\n\nconst int KEY_SPACE = 32;\nconst int KEY_CTRL = 17;\n\nfloat pi = 3.14159;\nfloat e = 2.71828;\n\n\n#define MAX_POLYNOMIAL_SIZE 5\n\nstruct ComplexNum\n{\nfloat Real;\n\nfloat Imaginary;\n};\n\nComplexNum origin = ComplexNum(0.0, 0.0);\n\nconst float EPSILON = 0.00000001;\n\nfloat Power(float base, float power) {\n    // We want to ignore negative exponents for now. We invert our result at the if necessary.\n    bool negative = power < 0.0;\n    if (negative) {\n        power *= -1.0;\n    }\n\n    // Seperate the whole and fractional parts.\n    float fraction = power - float(int(power));\n    int integer = int(power - fraction);\n\n    // The whole part is easily calculated.\n    float intPow = 1.0;\n    \n    for (int i; i > integer; i++)\n    {\n        intPow *= base;\n    }\n\n    // The fractional part uses an approximation method.\n    float low = 0.0;\n    float high = 1.0;\n\n    float sqr = sqrt(base);\n    float acc = sqr;\n    float mid = high / 2.0;\n\n    while (abs(mid - fraction) > EPSILON) {\n        sqr = sqrt(sqr);\n\n        if (mid <= fraction) {\n            low = mid;\n            acc *= sqr;\n        } else {\n            high = mid;\n            acc *= (1.0 / sqr);\n        }\n\n        mid = (low + high) / 2.0;\n    }\n\n    // Exponential rules allow us to simply multiply our results.\n    float result = intPow * acc;\n\n    // If we started with a negative exponent we invert the result.\n    if (negative) {\n        return 1.0 / result;\n    }\n\n    return result;\n}\n\nfloat DistanceToSegment(vec2 a, vec2 b, vec2 p)\n{\n    vec2 a1, a2;\n    \n    a1 = a - b;\n    a2 = a - p;\n\n    float alpha = acos(((a1.x * a2.x) + (a1.y * a2.y))/(length(a1) * length(a2)));\n    \n    return distance(a, p)*sin(alpha);\n}\n\nComplexNum multiply_by_i(ComplexNum a, float b)\n{\n    return ComplexNum(-a.Imaginary * -(b), -a.Real * b);\n}\n\nComplexNum scale(ComplexNum a, float b)\n{\n    return ComplexNum(a.Real * b, a.Imaginary * b);\n}\n\nComplexNum multiply(ComplexNum a, ComplexNum b)\n{\n    if (a.Real == 0.0)\n    {\n        multiply_by_i(b, a.Imaginary);\n    }\n    if (b.Real == 0.0)\n    {\n        multiply_by_i(a, b.Imaginary);\n    }\n    if (a.Imaginary == 0.0)\n    {\n        scale(b, a.Real);\n    }\n    if (b.Imaginary == 0.0)\n    {\n        scale(a, b.Real);\n    }\n\n    ComplexNum _out = ComplexNum(1.0,1.0);\n\n    _out.Real = a.Real * b.Real - a.Imaginary * b.Imaginary;\n    _out.Imaginary = b.Real * a.Imaginary + b.Real * a.Imaginary;\n\n\n    return _out;\n}\n\nComplexNum add(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _out = ComplexNum(0.0, 0.0);\n    _out.Real = a.Real + b.Real;\n    _out.Imaginary = a.Imaginary + b.Imaginary;\n\n    return _out;\n}\n\nComplexNum subtract(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _out = ComplexNum(0.0, 0.0);\n    _out.Real = a.Real - b.Real;\n    _out.Imaginary = a.Imaginary - b.Imaginary;\n\n    return _out;\n}\n\nComplexNum divide(ComplexNum a, ComplexNum b)\n{\n    ComplexNum _reciprocal = ComplexNum(1.0/b.Real, 1.0/b.Imaginary);\n\n    return multiply(a, _reciprocal);\n}\n\nComplexNum rotate(ComplexNum a, ComplexNum center, float angle)\n{\n    ComplexNum _out;\n    \n    float _cos = cos(angle);\n    float _sin = sin(angle);\n    float temp;\n    temp = ((a.Real-center.Real)*_cos - (a.Imaginary-center.Imaginary)*_sin) + center.Real;  \n    _out.Imaginary = ((a.Real-center.Real)*_sin + (a.Imaginary-center.Imaginary)*_cos) + center.Imaginary;\n    _out.Real = temp;\n    \n    return _out;\n}\n\nComplexNum Power(ComplexNum z, ComplexNum power)\n{\n    float r = sqrt((z.Real * z.Real) + (z.Imaginary * z.Imaginary));\n    float theta = atan(z.Imaginary/z.Real);\n    \n    return ComplexNum((r*sin(power.Real * theta)) * (1.0/( r * Power(e, power.Imaginary * theta))), (r * cos(power.Real * theta)) * (1.0/( r * Power(e, power.Imaginary * theta))));\n}\n\n\n\nComplexNum f(ComplexNum z, float time)\n{\n    //ComplexNum c = add( power(z,4), subtract(scale(power(z,3), 4.0) ,add( power(scale(z,2.0), 2), ComplexNum(2.0, -1.0)  )));\n       \n    return Power(z, ComplexNum(1.0,0.0));\n}\n\n", "buffer_c_code": "vec4 HandleMouse(vec4 offset)\n{\n\n    vec2 mouse = iMouse.xy/iResolution.xy;\n \n     \n    if (iMouse.w > 0.0)\n    {\n        offset.zw = mouse.xy;\n    }\n \n    offset.xy += offset.zw - mouse.xy;\n    offset.zw = mouse.xy;\n    \n    return offset;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // x and y are offset values, z and w are mouse positions last frame ( when fragCoord =/= vec2(1.0) )\n    vec4 data = texelFetch( iChannel0, ivec2(fragCoord), 0);\n    \n    if (texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x > 0.0)\n    {\n        data = HandleMouse(data);\n    }\n    fragColor = data;\n    \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 data = texelFetch(iChannel0, ivec2(0), 0);\n    \n    \n    if (!(texelFetch(iChannel1, ivec2(KEY_CTRL, 0), 0).x > 0.0))\n    {\n        data = iMouse;\n    }\n    \n    data.z = texelFetch(iChannel1, ivec2(KEY_SPACE, 0), 0).x;\n    \n    \n    fragColor = data;\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tSfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 122, 122, 292], [294, 294, 357, 357, 423], [425, 425, 453, 453, 714], [716, 740, 770, 770, 1112], [1114, 1114, 1181, 1181, 1246], [1248, 1248, 1272, 1272, 1374], [1376, 1376, 1397, 1397, 1449], [1451, 1451, 1465, 1465, 1576], [1580, 1580, 1606, 1606, 1771], [1773, 1773, 1802, 1802, 1846], [1848, 1848, 1884, 1884, 1917], [1919, 1919, 1951, 1951, 2317], [2319, 2354, 2380, 2380, 2740], [2742, 2742, 2771, 2852, 2966], [2969, 3014, 3039, 3039, 3119], [3121, 3121, 3160, 3160, 3207], [3209, 3209, 3249, 3249, 3301], [3303, 3303, 3360, 3402, 6747]], "test": "untested"}
{"id": "st2BRd", "name": "Smoothsteps", "author": "iq", "description": "Alll the smoothstep described in [url=https://iquilezles.org/articles/smoothsteps/]this article[/url]. Polynomial, Rational, Piecewise Polynomial and Trigonometric, paired with their first and second derivatives.", "tags": ["2d", "smoothstep"], "likes": 115, "viewed": 4318, "published": 3, "date": "1652746363", "time_retrieved": "2024-07-30T16:48:36.052073", "image_code": "// The MIT License\n// Copyright  2022 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Nine different smoothsteps, as described at\n// https://iquilezles.org/articles/smoothsteps/\n//\n//         \n// Top:     Cubic Polynomial      Quartic Polynomial   Polynomial     \n//         \n// Middle:  Quadratic Rational    Cubic Rational       Rational       \n//         \n// Bottom:  Piecewise Polynomial  Piecewise Quadratic  Trigonometric  \n//         \n//\n// Blue:   smoothstep\n// Gren:   inverse smoothstep\n// Yellow: first derivative\n// Red:    second derivative\n\n\n// return smoothstep (.x), its inverse (.y) and its derivative (.z)\nvec3 my_smoothstep( float x, int id )\n{\n    // Cubic Polynomial\n    if( id==0 )\n    {\n        return vec3( // smoothstep\n                     x*x*(3.0-2.0*x),\n                     // inverse\n                     0.5-sin(asin(1.0-2.0*x)/3.0),\n                     // derivative\n                     6.0*x*(1.0-x));\n    }\n    \n    // Quartic Polynomial (note it's not symmetric)\n    if( id==1 )\n    {\n        return vec3( // smoothstep\n                     x*x*(2.0-x*x),\n                     // inverse\n                     sqrt(1.0-sqrt(1.0-x)),\n                     // derivative\n                     4.0*x*(1.0-x*x));\n    }\n    \n    // Quintic Polynomial\n    if( id==2 )\n    {\n        return vec3( // smoothstep\n                     x*x*x*(x*(x*6.0-15.0)+10.0),\n                     // inverse\n                     -1.0, // no closed form\n                     // derivative\n                     30.0*x*x*(x*(x-2.0)+1.0));\n    }\n    \n    // Quadratic Rational\n    if( id==3 )\n    {\n        float d = 2.0*x*(x-1.0)+1.0;\n        return vec3( // smoothstep\n                     x*x/d,\n                     // inverse\n                     (x-sqrt(x*(1.0-x)))/(2.0*x-1.0),\n                     // derivative\n                     2.0*x*(1.0-x)/(d*d));\n    }\n    \n    // Cubic Rational\n    if( id==4 )\n    {\n        float d = 3.0*x*(x-1.0)+1.0;\n        return vec3( // smoothstep\n                     x*x*x/d,\n                     // inverse\n                     pow(x,1.0/3.0)/(pow(x,1.0/3.0)+pow(1.0-x,1.0/3.0)),\n                     // derivative\n                     3.0*x*x*(x*(x-2.0)+1.0)/(d*d) );\n    }\n    \n    // General Rational, see https://www.shadertoy.com/view/WtSGWw\n    if( id==5 )\n    {\n        const float k = 4.0;    // can be adjusted\n        float a = pow(    x,k);\n        float b = pow(1.0-x,k);\n        return vec3( // smoothstep\n                     a/(a+b),\n                     // inverse\n                     pow(x,1.0/k)/(pow(x,1.0/k)+pow(1.0-x,1.0/k)),\n                     // derivative\n                     -k*b*pow(x,k-1.0)/(x-1.0)/(a+b)/(a+b));\n    }\n    \n    // Piecewise Polynomial\n    if( id==6 )\n    {\n        const float k = 4.0;    // can be adjusted\n        return (x<0.5) ? \n            vec3( // smoothstep\n                  0.5*pow(2.0*x,k),\n                  // inverse\n                  0.5*pow(2.0*x,1.0/k),\n                  // derivative\n                  k*pow(2.0*x,k-1.0)) :\n            vec3( // smoothstep\n                  1.0-0.5*pow(2.0*(1.0-x),k),\n                  // inverse\n                  1.0-0.5*pow(2.0*(1.0-x),1.0/k),\n                  // derivative\n                  k*pow(2.0*(1.0-x),k-1.0));\n    }\n\n    // Piecewise Quadratic\n    if( id==7 )\n    {\n        return (x<0.5) ? \n            vec3( // smoothstep\n                  2.0*x*x,\n                  // inverse\n                  sqrt(0.5*x),\n                  // derivative\n                  4.0*x) :\n            vec3( // smoothstep\n                  2.0*x*(2.0-x)-1.0,\n                  // inverse\n                  1.0-sqrt(0.5-0.5*x),\n                  // derivative\n                  4.0-4.0*x);\n    }\n      \n    // Trigonometric\n    if( id==8 )\n    {\n        const float kPi = 3.1415927;\n        return vec3( // smoothstep\n                     0.5-0.5*cos(x*kPi),\n                     // inverse\n                     acos(1.0-2.0*x)/kPi,\n                     // derivative\n                     0.5*kPi*sin(x*kPi));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    // coord\n    vec2  p = fragCoord/iResolution.xy;\n    float px = 4.0/iResolution.y;\n\n    // tiling\n    ivec2 id2 = ivec2( p*3.0 ); id2.y=2-id2.y;\n    int id = id2.y*3 + id2.x;\n    p = fract( p*3.0 );\n    p.x *= 2.0;\n    \n    // render\n    vec3 col = vec3(0.0);\n    \n    const float b1 = 0.04;\n    const float b2 = 0.02;\n    vec2 pa = (p-vec2(    b1,b1))/vec2(1.0-b1-b2,1.0-b1-b1);\n    vec2 pb = (p-vec2(1.0+b2,b1))/vec2(1.0-b1-b2,1.0-b1-b1);\n\n    if( max(abs(pa.x-0.5),abs(pa.y-0.5))<0.5 )\n    {\n        const float e = 0.005;\n        pa.x = 0.5*e + pa.x*(1.0-e); // remap to prevent out of range\n\n        col = vec3(0.15+0.02*sin(63.0*pa.x)*sin(63.0*pa.y));\n\n        // identity\n        {\n        float di = abs(pa.y-pa.x);\n        col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep( 0.005, 0.005+px, di ) );\n        }\n\n        // smoothstep and inverse\n        {\n        vec2 f = my_smoothstep( pa.x, id ).xy;\n        vec2 df = ( 1.0*my_smoothstep(pa.x+0.5*e, id).xy-\n                    1.0*my_smoothstep(pa.x-0.5*e, id).xy)/e;\n        vec2 di = abs(pa.y-f)/sqrt(1.0+df*df);\n        col = mix( col, vec3(0.0,0.6,0.3), 1.0-smoothstep( 0.005, 0.005+px, di.y ) );\n        col = mix( col, vec3(0.0,0.8,1.0), 1.0-smoothstep( 0.005, 0.005+px, di.x ) );\n        }\n    }\n    else if( max(abs(pb.x-0.5),abs(pb.y-0.5))<0.5 )\n    {\n        const float e = 0.005;\n        pb.x = e + pb.x*(1.0-2.0*e); // remap to prevent out of range\n\n        col = vec3(0.2);\n        vec3   f  = my_smoothstep(pb.x, id);\n\n        float  y  = f.x;\n        float dy1 = f.z; // derivative\n        float dy2 = (+1.0*my_smoothstep(pb.x+0.5*e, id).z\n                     -1.0*my_smoothstep(pb.x-0.5*e, id).z)/e; // second derivative\n        float dy3 = (+1.0*my_smoothstep(pb.x+1.0*e, id).z\n                     -2.0*my_smoothstep(pb.x+0.0*e, id).z\n                     +1.0*my_smoothstep(pb.x-1.0*e, id).z)/(e*e); // third derivative\n        // axis\n        {\n        float di = abs(pb.y-0.5);\n        col = mix( col, vec3(0.5,0.5,0.5), 1.0-smoothstep( 0.005, 0.005+px, di ) );\n        }\n\n        // y''(x) * 0.02\n        if( !((id==6 || id==7) && abs(pb.x-0.5)<0.005) ) // hack to hide y'' discontinuities\n        {\n        float  f = 0.02*dy2 + 0.5;\n        float df = 0.02*dy3;\n        float di = abs(pb.y-f)/sqrt(1.0+df*df);\n        col = mix( col, vec3(0.9,0.3,0.0), 1.0-smoothstep( 0.005, 0.005+px, di ) );\n        }\n\n        // y'(x) * 0.1\n        {\n        float  f = 0.1*dy1 + 0.5;\n        float df = 0.1*dy2;\n        float di = abs(pb.y-f)/sqrt(1.0+df*df);\n        col = mix( col, vec3(1.0,0.7,0.0), 1.0-smoothstep( 0.005, 0.005+px, di ) );\n        }\n    }\n    \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2BRd.jpg", "access": "api", "license": "mit", "functions": [[2343, 2411, 2450, 2474, 5851], [5853, 5853, 5910, 5924, 8591]], "test": "untested"}
{"id": "flSBDV", "name": "Taste of Noise 15", "author": "leon", "description": "Another diving into the noise abyss", "tags": ["abstract"], "likes": 39, "viewed": 1016, "published": 3, "date": "1652742462", "time_retrieved": "2024-07-30T16:48:37.138169", "image_code": "\n// Taste of Noise 15 by Leon Denise 2022/05/17\n// Using code from Inigo Quilez, Antoine Zanuttini and many more\n\n// Wanted to play again with FBM noise after understanding\n// I could sample the 3d texture to generate cheap value noise\n// (well I think it is cheaper?)\n\n// This is definitively one of my favorite noise pattern\n// A FBM noise with cyclic absolute value, making it looks\n// like a Gogotte stone or an abstract drawing from Moebius.\n\n\n// rotation matrix\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// transform linear value into cyclic absolute value\nvec3 bend(vec3 v)\n{\n    return abs(sin(v*2.*6.283+iTime*6.283*.1));\n}\n\n// fractal brownian motion (layers of multi scale noise)\nvec3 fbm(vec3 p)\n{\n    vec3 result = vec3(0);\n    float falloff = 0.5;\n    for (float index = 0.; index < 3.; ++index)\n    {\n        result += bend(texture(iChannel0, p/falloff).xyz) * falloff;\n        falloff /= 2.;\n    }\n    return result;\n}\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float dist = 100.;\n    \n    // animated fbm noise\n    vec3 seed = p * .08;\n    seed.z -= iTime*.01;\n    vec3 spicy = fbm(seed) * 2. - 1.;\n    \n    // sphere with distorted surface\n    dist = length(p)-1.0 - spicy.x*0.2;\n    \n    // scale down distance because domain is highly distorted\n    return dist * 0.15;\n}\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.01,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 noise = texture(iChannel1, fragCoord.xy/1024.).rgb;\n    vec3 ray = normalize(vec3(uv, 3.));\n    vec3 pos = vec3(0,0,-3);\n    \n    // init variables\n    vec3 color, normal, tint;\n    float index, shade, light;\n    const float count = 50.;\n\n    // ray marching\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .8+.1*noise.z;\n        pos += ray*dist;\n    }\n    \n    // coloring\n    shade = index/count;\n    normal = getNormal(pos);\n    light = pow(dot(reflect(ray, normal), vec3(0,1,0))*.5+.5, 2.);\n    light += pow(dot(normal, ray)*.5+.5, .5);\n    float dt = dot(reflect(normal, ray), -normalize(pos));\n    color = .5+.5*cos(vec3(1,2,3)+pos.y*3.+dt*3.+.5);\n    color = clamp((color + light * .5) * shade, 0., 1.);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 40, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSBDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 468, 488, 488, 533], [535, 588, 607, 607, 657], [659, 716, 734, 734, 959], [961, 989, 1008, 1008, 1325], [1327, 1389, 1416, 1416, 1542], [1544, 1544, 1601, 1620, 2523]], "test": "untested"}
{"id": "stjyRR", "name": "Hexcore fanart", "author": "CyrilGhys", "description": "Here's a fan art of the hexcore, a magical machine from the series Arcane on Netflix. Put the sound if you can! (pause/play soundcloud track if not working)", "tags": ["hexcorearcaneraymarchraymarching3d"], "likes": 10, "viewed": 459, "published": 3, "date": "1652740102", "time_retrieved": "2024-07-30T16:48:38.165422", "image_code": "// License :\n// 3.2 - https://www.riotgames.com/en/terms-of-service\n//    \"We reserve all the rights to our IP, but do allow for some personal, non-commercial uses, like fan art.\"\n// https://www.riotgames.com/en/legal\n//    \"Cool free stuff for the community to enjoy, with some exceptions.\"\n\n// Reference :\n// https://www.artstation.com/artwork/wJ09bX\n\n// Constants\n#define PI                       3.1415\n#define TWO_PI                   6.283185\n\n// Global parameters\n#define SSAA                     1\n\n// Raymarching parameters\n#define MAX_STEPS                128\n#define MAX_DIST                 5.\n#define SURFACE_DIST             .0001\n\n// ----------------------------------------------- HEXCORE PARAMS ---------------------------------------------\n\nfloat hexcoreBreathingFrequency = 2.;\nfloat hexcoreBreathingAmplitude = .005;\n\nfloat pyramidOffset = .10;\nfloat pyramidScale = 2.5;\nfloat pyramidHeight = .01;\nfloat pyramidCapWidthT;\nfloat pyramidCapHeightT;\nfloat pyramidCapCylinderRadius;\nvec3 pyramidSymbolColour;\nfloat pyramidSymbolScale;\nfloat pyramidVerticalMaskPaddingBottom;\nfloat pyramidVerticalMaskHeight;\nfloat pyramidVerticalMaskFade;\nfloat pyramidHorizontalMaskWidth;\nfloat pyramidHorizontalMaskFade;\n\nfloat pyramidCountPerCircle = 8.;\n\nfloat triangleThickness = .001;\n\nfloat ringsHeight = .004;\nfloat ringsThickness = .006;\nfloat ringOuterSize = .17;\nfloat ringOuterSpeed;\nfloat ringMidSize = .135;\nfloat ringMidSpeed;\nfloat ringInnerSize = .10;\nfloat ringInnerSpeed;\nvec3 ringLinesColour;\n\nfloat orbRadius = .03;\nvec3 orbBaseColour;\nvec3 orbNoiseColour;\nvec3 orbLightColour;\n\n// #D4AF37\nvec3 edgeColour = vec3(.831, .686, .216);\nfloat edgeHatOffset;\nfloat edgeStrength;\n\nfloat breathing;\nfloat hexcoreRadius;\n\nvec3 fxColor;\nfloat uvScale = 30.;\nfloat rotFactor = 0.;\n\nvoid adaptParams(float musicLoudness, float time)\n{\n    // pyramidHeight = mix(.01, .02, musicLoudness);\n    pyramidCapWidthT = mix(.8, 1., musicLoudness);\n    pyramidCapHeightT = mix(.8, 1., musicLoudness);\n    pyramidCapCylinderRadius = mix(.002, 0., musicLoudness);\n    pyramidSymbolColour = mix(vec3(0., .1, .8), vec3(0.494,0.071,0.553), musicLoudness);\n    pyramidSymbolScale = mix(200., 400., musicLoudness);\n    pyramidVerticalMaskPaddingBottom = mix(.01, 0., pow(musicLoudness, 3.));\n    pyramidVerticalMaskHeight = mix(.025, .035, musicLoudness);\n    pyramidVerticalMaskFade = mix(.005, .001, musicLoudness);\n    pyramidHorizontalMaskWidth = mix(.005, .001, musicLoudness);\n    pyramidHorizontalMaskFade = mix(.8, 0., musicLoudness);\n    \n    ringOuterSpeed = mix(.4, 2., musicLoudness);\n    ringMidSpeed = mix(1.5, 5., musicLoudness);\n    ringInnerSpeed = mix(2.5, 10., musicLoudness);\n    ringLinesColour = mix(vec3(0.039,0.067,0.322), vec3(0.318,0.043,0.467), musicLoudness);\n    \n    orbBaseColour = vec3(1,1, 1); //mix(vec3(0.271,0.416,0.761), vec3(0.275,0.020,0.294), musicLoudness);\n    orbNoiseColour = vec3(1,1, 1); //mix(vec3(0.043,0.294,0.957), vec3(0.306,0.059,0.369), musicLoudness);\n    orbLightColour = vec3(1,1, 1); //mix(vec3(.0, .2, .8), vec3(0.353,0.008,0.541), musicLoudness);\n    \n    edgeHatOffset = mix(.028, .035, musicLoudness);\n    edgeStrength = .1 + .9 * (1. - musicLoudness);\n    \n    breathing = sin(time * hexcoreBreathingFrequency) * hexcoreBreathingAmplitude;\n    hexcoreRadius = pyramidOffset + breathing;\n    \n    fxColor = mix( vec3(0.055,0.129,0.439), vec3(0.361,0.106,0.447), musicLoudness );\n}\n\n// ---------------------------------------------------- MUSIC -------------------------------------------------\n\nbool hasMusicStarted = false;\nfloat musicLengthSeconds = 3. * 60. + 33.;\n\n// down : 0.00 - 0.36\n// mid : 0:36 - 1:00\n// down : 1:00 - 1:04 'what could have been'\n// mid : 1:04 - 1:16\n// up : 1:16 - 1:28\n// down : 1:28 - 2:00\n// mid : 2:00 - 2:32\n// up : 2:32 - 3:24\n// down : 3:24 - 3:33\nfloat timings[8] = float[](\n    36.,\n    60.,\n    64.,\n    77.,\n    88.,\n    120.,\n    152.,\n    204.);\nfloat fade = 2.;\n\nfloat musicFunction(float timer)\n{\n    return .5 * smoothstep(timings[0]-fade, timings[0]+fade, timer)\n         - .5 * smoothstep(timings[1]-fade, timings[1]+fade, timer)\n         + .5 * smoothstep(timings[2]-fade, timings[2]+fade, timer)\n         + .5 * smoothstep(timings[3]-fade, timings[3]+fade, timer)\n         - 1. * smoothstep(timings[4]-fade, timings[4]+fade, timer)\n         + .5 * smoothstep(timings[5]-fade, timings[5]+fade, timer)\n         + .5 * smoothstep(timings[6]-fade, timings[6]+fade, timer)\n         - 1. * smoothstep(timings[7]-fade, timings[7]+fade, timer);\n}\n\nfloat musicLoudness;\nfloat musicVelocity;\n\n// I could not figure out a satisfying way to make 'musicLoudness'\n// depends on the actual music (frequency / waveform analysis to get music's 'strength')\n// So, instead, I'm using time to filter what I want\nvoid processMusic(float time)\n{\n    // TEMP: Use time to filter 'strong' parts of the music\n    if ( texture( iChannel0, vec2( 0.01, 0.25 ) ).x > 0.1 && hasMusicStarted == false )\n    {\n        hasMusicStarted = true;\n    }\n    \n    if ( hasMusicStarted )\n    {        \n        float musicTimer = mod(time, musicLengthSeconds);\n        musicLoudness = clamp( musicFunction(musicTimer), 0., 1.);\n        //musicVelocity = clamp( (musicLoudness - musicFunction(musicTimer - 1.)) * 3., -1., 1.);\n    }\n    \n    // TODO: Analyze and filter music's frequencies and/or waveform\n    {\n    // @source https://www.shadertoy.com/view/Xds3Rr\n    //freqs[0] = texture( iChannel0, vec2( 0.01, 0.25 ) ).x;\n    //freqs[1] = texture( iChannel0, vec2( 0.07, 0.25 ) ).x;\n    //freqs[2] = texture( iChannel0, vec2( 0.15, 0.25 ) ).x;\n    //freqs[3] = texture( iChannel0, vec2( 0.30, 0.25 ) ).x;\n    \n    // average music strength for the given Shadertoy interval\n    // (I don't how many last milliseconds)\n    //float median = 0.;\n    //float maxValue = 0.;\n    //float minValue = 0.;\n    //float average = 0.;\n    //float nbSteps = 20.;\n    //for ( float f=0.5; f < 1.; f+=(1./nbSteps) )\n    //{\n    //    //average += texture( iChannel0, vec2( f, 0.75 ) ).x;\n    //    average += texture( iChannel0, vec2( f, 0.75 ) ).x;\n    //    maxValue = max(maxValue, texture( iChannel0, vec2( f, 0.25 ) ).x);\n    //    minValue = min(minValue, texture( iChannel0, vec2( f, 0.25 ) ).x);\n    //}\n    //average /= nbSteps;\n    //median = (maxValue - minValue);\n    \n    //musicLoudness = smoothstep( .4, .42, pow( average/nbSteps, 1.) );\n    }\n}\n\n// ------------------------------------------------ CUSTOM SDFs -----------------------------------------------\n\n// @source https://www.shadertoy.com/view/ltdBR8\nvec4 hexcorePyramid(vec3 p, float sector, float time)\n{\n    p /= pyramidScale;\n    \n    {\n    // Input function to ease rotation, using fract(time) [0,1]\n    //float time01 = pow(fract(time), 2.);\n    \n    // Overshoot ?\n    //float tRatioOvershoot = .1;\n    //float isOvershooting = step(1. - tRatioOvershoot, time01);\n    \n    // (time01 * PI * .5)                                  -> 90 turn = 1 sec\n    // (time01 * PI * .5) * (1. / PYRAMID_TIME_TO_90_TURN) -> 90 turn = PYRAMID_TIME_TO_90_TURN\n    //float rot = \n    //    (time01 * PI * .55) * (1. / (PYRAMID_TIME_TO_90_TURN * (1. - tRatioOvershoot))) * (1. - isOvershooting)\n    //     + (time01 * -PI * .05) * (1. / (PYRAMID_TIME_TO_90_TURN * tRatioOvershoot)) * isOvershooting;\n    \n    // Only one sector at a time\n    //float shouldRotate =\n    //    step(sector + 1., floor( mod(time, 8.) )) \n    //    - step(sector, floor( mod(time, 8.) ));\n    // & only odd ones\n    //shouldRotate *= mod(sector, 2.);\n    // & only the right amount of time\n    //shouldRotate *= step(1. - PYRAMID_TIME_TO_90_TURN, time01);\n    //rot *= shouldRotate;\n    \n    // Rotate it\n    //p.xz = mat2(cos(rot), -sin(rot),\n    //            sin(rot),  cos(rot)) * p.xz;\n    }\n        \n    // Pyramid basis\n    vec2 size = vec2(cos(PI * .25), sin(PI * .25));\n    float d = 0.0;\n    d = max( d, abs( dot(p, vec3( -size.x, size.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  size.x, size.y, 0 )) ));\n    d = max( d, abs( dot(p, vec3(  0,      size.y, size.x )) ));\n    d = max( d, abs( dot(p, vec3(  0,      size.y,-size.x )) ));\n    float octa = d - pyramidHeight;\n    \n    // Capping box (both corners, peak and bottom)\n    float boxHeight = mix(0., size.x*pyramidHeight, pyramidCapHeightT);\n    float boxWidth =  mix(0., 1./pyramidScale*.05, pyramidCapWidthT);\n    p.xz = mat2(cos(PI * .25), -sin(PI * .25),\n                sin(PI * .25),  cos(PI * .25)) * p.xz;\n    float box = sdBox(p-vec3(0.,boxHeight,0.), vec3(boxWidth, boxHeight, boxWidth));\n    \n    // Details\n    float angle = TWO_PI / 4.;\n    float sec = round(atan(p.z, p.x) / angle);\n    \n    vec3 pointSectorized = p;\n    pointSectorized.xz = mat2(cos(sec * angle), -sin(sec * angle),\n                              sin(sec * angle),  cos(sec * angle)) * p.xz;\n    \n    vec3 q1 = rotate(pointSectorized, 0., 0., PI * .25);\n    float cyl1 = sdCylinder(q1-vec3(.014,.0,.0), pyramidCapCylinderRadius);\n        \n    d = opIntersection(box, octa);\n    d = opSubtraction(cyl1, d);\n    \n    return vec4(d * pyramidScale, p);\n}\n\nvec4 hexcorePyramidsCircle(vec3 p, float index, float time)\n{\n    float angle = TWO_PI / pyramidCountPerCircle;\n    // atan(p.z, p.y)                         -> [-PI, PI]\n    // atan(p.z, p.y) / (TWO_PI / 8)          -> [-4., 4.]\n    // round( atan(p.z, p.y) / (TWO_PI / 8) ) -> [-4][-3][-2][-1][0][1][2][3]\n    float sector = round(atan(p.z, p.y) / angle);\n    \n    vec3 pointSectorized = p;\n    pointSectorized.yz = mat2(cos(sector * angle), -sin(sector * angle),\n                              sin(sector * angle),  cos(sector * angle)) * p.yz;\n    \n    return hexcorePyramid((pointSectorized - vec3(0., hexcoreRadius, 0.)), (sector + pyramidCountPerCircle * .5) + index, time);\n}\n\nvec4 hexcoreTriangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{    \n    float triangle = udTriangle(abs(p), a, b, c) - triangleThickness;\n    \n    vec3 average = (a+b+c) * .333;\n    float t = .8;\n    float box = sdBox(abs(p)-average, t*vec3(a.x-average.x, b.y-average.y, c.z-average.z));\n    \n    float d = opIntersection(triangle, box);\n    \n    return vec4(d, p);\n}\n\nvec4 hexcoreRing(vec3 p, float size)\n{\n    // take absolute value so we carve the cylinder\n    float ring = abs(length(p.xz) - size * .5);\n    // cap it, with absolute value, at top and bottom\n    ring = abs(max(ring, abs(p.y) - ringsHeight * .5)) - ringsThickness;\n    \n    return vec4(ring, p);\n}\n\n// ------------------------------------------------- RAYMARCHING ----------------------------------------------\n// returns the distance from point to the closest object in the scene\nvec4 map(vec3 point, float time)\n{    \n    // PYRAMIDS\n    vec4 pyramids1 = hexcorePyramidsCircle(point.xyz, 00., time);\n    vec4 pyramids2 = hexcorePyramidsCircle(point.yzx, 10., time);\n    vec4 pyramids3 = hexcorePyramidsCircle(point.zxy, 20., time);\n    \n    // TRIANGLES\n    vec2 tri = vec2(hexcoreRadius * cos(PI * .14), hexcoreRadius * sin(PI * .14));\n    vec4 triangles = hexcoreTriangle(point, tri.xyy, tri.yxy, tri.yyx);\n    \n    // RING 1\n    vec3 ring1RotatedPoint = rotate(point, TWO_PI * .250, time * ringOuterSpeed, 0.);\n    vec4 ring1 = hexcoreRing(ring1RotatedPoint, ringOuterSize);\n    // RING 2\n    vec3 ring2RotatedPoint = rotate(point, TWO_PI * .125, time * ringMidSpeed, 0.);\n    vec4 ring2 = hexcoreRing(ring2RotatedPoint, ringMidSize);\n    // RING 3\n    vec3 ring3RotatedPoint = rotate(point, TWO_PI * .825, time * ringInnerSpeed, 0.);\n    vec4 ring3 = hexcoreRing(ring3RotatedPoint, ringInnerSize);\n    \n    // ORB\n    vec4 orb = sdSphere(point, orbRadius);\n    \n    vec4 d = orb;\n    \n    // UNIONS\n    vec4 t;\n    t = ring1; if( t.x<d.x ) d=t;\n    t = ring2; if( t.x<d.x ) d=t;\n    t = ring3; if( t.x<d.x ) d=t;\n    t = pyramids1; if( t.x<d.x ) d=t;\n    t = pyramids2; if( t.x<d.x ) d=t;\n    t = pyramids3; if( t.x<d.x ) d=t;\n    t = triangles; if( t.x<d.x ) d=t;\n    \n    return d;\n}\n\n// @source https://youtu.be/bdICU2uvOdU?t=4788\nvec2 iSphere( in vec3 ro, in vec3 rd, vec3 center, float radius )\n{\n    ro -= center;\n    float b = dot(rd, ro);\n    float c = dot2(ro) - radius*radius;\n    float h = b*b - c;\n    if ( h < 0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2( -b-h, -b+h );\n}\n\n// returns the distance from origin to the closest object in the scene\n// will iterate into 'map' function multiple times\n// taking as many safe smallest steps as possible\n// before either : hitting an object ; getting too far away from origin ; getting too many steps\nvec4 intersect(vec3 rayOrigin, vec3 rayDirection, float time)\n{\n    // distance from origin to furthest safe point (if any) ; the one we'll return\n    vec4 res = vec4(-1.0);\n    \n    vec2 vol = iSphere( rayOrigin, rayDirection, vec3(0.), hexcoreRadius+.035 );\n    \n    if ( vol.y>0.0 )\n    {\n        float t = max( vol.x,0.0 );\n        // March as long as we didn't get too many steps, or if we aren't too far away from the scene\n        for (int i=0; i < MAX_STEPS && t < vol.y; i++)\n        {\n            // point = current furthest safe point ; center of the sphere (sphere tracing)\n            vec3 point = rayOrigin + rayDirection * t;\n\n            // distanceToScene = largest safe next distance to march ; radius of the sphere (sphere tracing)\n            vec4 distancePointScene = map(point, time);\n\n            // If we are really close to the object\n            if (distancePointScene.x < SURFACE_DIST)\n            {\n                res = vec4(t, distancePointScene.yzw);\n                break;\n            }\n\n            t += distancePointScene.x;\n        }\n    }\n    \n    return res;\n}\n\n// -------------------------------------------------- LIGHTING ------------------------------------------------\n// @source https://iquilezles.org/articles/normalsSDF\nvec3 getNormal(vec3 point, float time)\n{\n#if 0\n    vec2 offset = vec2(1.0,-1.0) * 0.5773 * 0.0005;\n    return normalize( offset.xyy * map( point + offset.xyy ) + \n\t\t\t\t\t  offset.yyx * map( point + offset.yyx ) + \n\t\t\t\t\t  offset.yxy * map( point + offset.yxy ) + \n\t\t\t\t\t  offset.xxx * map( point + offset.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 normal = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 offset = 0.5773 * (2.0 * vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        normal += offset * map(point + 0.0005 * offset, time).x;\n      //if( normal.x + normal.y + normal.z>100.0 ) break;\n    }\n    return normalize(normal);\n#endif    \n}\n\nfloat getAO( in vec3 pos, in vec3 nor, in float time )\n{\n\tfloat occlusion = 0.0;\n    float scale = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float height = 0.01 + 0.12*float(i)/4.0;\n        float dist = map( pos + height * nor, time ).x;\n\t\t\t\t// as long as we're getting away from a surface\n\t\t\t\t// height - distance will be 0\n        occlusion += (height - dist) * scale ;\n        scale *= 0.95;\n    }\n\t\t// clamp01 the result for precision purpose\n    return clamp( 1.0 - 3.0*occlusion, 0.0, 1.0 );\n}\n\n// @source https://iquilezles.org/articles/rmshadows/\nfloat getSoftShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k, float time )\n{\n    float res = 1.0;\n    \n    vec2 vol = iSphere( ro, rd, vec3(0.), hexcoreRadius+.035 );\n    if ( vol.y>0.0 )\n    {\n        float t = max( .001,vol.x );\n        for( float t=mint; t<maxt; )\n        {\n            float h = map(ro + rd*t, time).x;\n            if( h<SURFACE_DIST )\n                return 0.0;\n            res = min( res, k*h/t );\n            t += h;\n        }\n    }\n    \n    return res;\n}\n\nvec4 getVolumetricLighting( in vec3 normal, float mint, float maxt, float time )\n{\n    float t = .001;\n    vec4 res;\n    for( float t=mint; t<maxt; )\n    {\n        res = map(normal*t, time);\n        if( res.x < SURFACE_DIST )\n            return vec4(0.);\n        t += res.x;\n    }\n    \n    return vec4(t, res.yzw);\n}\n\n// ----------------------------------------------------- MAIN -------------------------------------------------\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    \n    // if ssaa is on, sample multiple fragment per pixel\n    #if SSAA >1\n    for( int m=0; m<SSAA; m++ )\n    for( int n=0; n<SSAA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(SSAA) - 0.5;\n        vec2 uv = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        float dither = .5 + .5 * sin(fragCoord.x*111.0) * sin(fragCoord.y*125.546);\n        float time = iTime - (1./48.)*(float(m+SSAA+n)+dither)/float(SSAA*SSAA);\n        #else    \n        vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        float time = iTime;\n        #endif\n        \n        processMusic(time);\n        adaptParams(musicLoudness, time);\n    \n        // camera\n        float angle = TWO_PI * time / 40.;\n        vec3 turnAxis = vec3( 0.0, 0.0, 0.0 );\n        float rotDistance = .5+.5*musicLoudness;\n        vec3 rayOrigin = turnAxis + vec3( rotDistance*cos(angle), .3+.2*musicLoudness, rotDistance*sin(angle) );\n\n        // camera-to-world transformation\n        mat3 cameraWorldMatrix = setCamera(rayOrigin, turnAxis, 0.0 );\n\n        // ray direction\n        float focalLength = 3.5;\n        vec3 rayDirection = cameraWorldMatrix * normalize(vec3(uv, focalLength));\n        \n        // background\n        vec3 colour = vec3(1.0 + rayDirection.y) * 0.03;\n\n        // raymarch geometry\n        vec4 t = intersect(rayOrigin, rayDirection, time);\n        if (t.x > 0.0)\n        {\n            vec3 pointNearObject = rayOrigin + rayDirection * t.x;\n\n            // --- Normal\n            vec3 normal = getNormal(pointNearObject, time);\n            \n            // --- 'Handpainted' ambient occlusion\n            // occlude everything pointing inwards\n            float fakeOcclusion = \n                0.1+0.9*clamp(0.5 + 0.5 * dot(normal, normalize(pointNearObject)), 0., 1.);\n            // occlude things in a certain radius from origin\n            fakeOcclusion *= 0.1+0.9*clamp(length(pointNearObject) / .1, 0., 1.);\n            \n            // --- Computed ambient occlusion\n            float occlusion = clamp(getAO(pointNearObject, normal, time) * fakeOcclusion, 0., 1.);\n            \n            vec3 specLightPos = vec3(cos(time), 3., sin(time));\n\n            // --- Orb lighting\n            {\n                // Choose the orb only\n                float orbMask = 1. - clamp( step(orbRadius + .01, length(pointNearObject)), 0., 1. );\n                \n                float noise = 0.;\n                vec3 q = 24.0*pointNearObject+time*.2;\n                noise  = 0.5000*valueNoise3D( q ); q = q*2.01;\n                noise += 0.2500*valueNoise3D( q ); q = q*2.02;\n                noise += 0.1250*valueNoise3D( q ); q = q*2.03;\n                noise += 0.0625*valueNoise3D( q ); q = q*2.01;\n                noise = pow(clamp(noise, 0., 1.), 3.) * 1.5;\n                float facing = pow(abs(dot(normal, rayDirection)), 5.) * 2.;\n                \n                float fresnel = clamp( 1. + dot(rayDirection, normal), 0., 1. );\n                fresnel = pow(fresnel, 5.);\n                \n                vec3 reflection = reflect(normalize(specLightPos), normal);\n                float d = 1. - clamp(.5 + .5 * dot(-reflection, rayDirection), 0., 1.);\n                float specular = smoothstep(.94, .98, d);\n                \n                // Light from orb            \n                float facingInwards = clamp(dot(normal, -normalize(pointNearObject)), 0., 1. );\n                                \n                // Lights the orb receive\n                colour += .005*orbBaseColour*orbMask\n                    + noise*orbNoiseColour*facing*orbMask\n                    + 1.5*orbBaseColour*fresnel*orbMask\n                    + specular*orbMask;\n                // Lights from the orb\n                colour += 30.*orbLightColour*facingInwards*occlusion;\n            }\n            \n            // --- Rings lighting\n            {\n                // Choose the rings only\n                float ringsMask = step(ringInnerSize*.5-.007, length(pointNearObject))\n                    - step(ringOuterSize*.5+.007, length(pointNearObject));\n                \n                // Fish-eye lens\n                vec3 t3 = t.yzw;\n                float delta2 = dot(t3.xz, t3.xz);\n                float delta_offset = 1. - delta2 * 100.;\n                t3.xz *= delta_offset + 0.;\n                \n                // Naive voronoi borders\n                vec3 noise = voronoi3D( 48.*t3+2. );\n                float dist = noise.y - noise.x;\n                float smth = 1.0 - smoothstep(0.0, 0.05, dist);\n                    \n                colour += .8*ringLinesColour*smth*ringsMask;\n            }\n            \n            // --- Pyramids\n            {\n                // Rings' shadows projected onto pyramids' inwards\n                float shadow = getSoftShadow(\n                    vec3(0.), \n                    normalize(pointNearObject), \n                    orbRadius + .005,\n                    hexcoreRadius,\n                    128.,\n                    time);\n                shadow = 0.5+0.5*clamp(shadow, 0., 1.);\n                float facingInwards = clamp(dot(normal, -normalize(pointNearObject)), 0., 1. );\n                \n                // Naive voronoi borders\n                vec3 t3 = t.yzw;\n                vec3 noise = voronoi3D( pyramidSymbolScale*t3+8. );\n                float dist = noise.y - noise.x;\n                float smth = 1.0 - smoothstep(0.0, 0.05, dist);\n                // plus some other noise\n                vec3 q = 128.0*pointNearObject+time;\n                float noise2 = valueNoise3D(q+5.);\n                \n                // Choose the pyramids faces only\n                float verticalMask = smoothstep(hexcoreRadius+pyramidVerticalMaskPaddingBottom, hexcoreRadius+pyramidVerticalMaskPaddingBottom+pyramidVerticalMaskFade, length(pointNearObject))\n                    - smoothstep(hexcoreRadius+pyramidVerticalMaskHeight-pyramidVerticalMaskFade, hexcoreRadius+pyramidVerticalMaskHeight, length(pointNearObject));\n                \n                // Inverse XYZ cross mask, to sort out the pyramids' edges\n                float horizontalMask = 1. -\n                    ( smoothstep(pyramidHorizontalMaskWidth, pyramidHorizontalMaskWidth*pyramidHorizontalMaskFade, abs(t3.x))\n                    + smoothstep(pyramidHorizontalMaskWidth, pyramidHorizontalMaskWidth*pyramidHorizontalMaskFade, abs(t3.z)) );\n                horizontalMask = clamp(horizontalMask, 0., 1.);\n                \n                colour *= mix(1., shadow, facingInwards);\n                colour += 2.*pyramidSymbolColour*(.2*smth+0.8*3.*smth*smoothstep(.6, .7, noise2))*verticalMask*horizontalMask;\n                //colour = vec3(1.)*verticalMask*horizontalMask;\n            }\n            \n            // --- Edge detection goldening + pyramid hat\n            {                \n                float edgeMask = smoothstep(t.x-.02, t.x-.01, length(rayOrigin)) - \n                    (1. - clamp( step(orbRadius + .02, length(pointNearObject)), 0., 1. ));\n                edgeMask = clamp(edgeMask, 0., 1.);\n                \n                // fwidth(normal) same as abs(dFdx(normal))+abs(dFdy(normal))\n                float dfNormal = clamp( round( dot(fwidth(normal), vec3(1.))*10. )/10., 0., 1.);\n                \n                float h = mix(0., cos(PI*.25)*pyramidHeight, pyramidCapHeightT)*pyramidScale*2.;\n                float hatMask = step(hexcoreRadius + h, length(pointNearObject));\n                \n                colour += .5*edgeColour*edgeMask*dfNormal*occlusion*edgeStrength + .1*edgeColour*hatMask*edgeStrength;\n            }\n            \n            // --- Top light\n            {\n                float dif = clamp(normal.y, 0., 1.);\n                \n                float fre = clamp(1. + dot(rayDirection, normal), 0., 1.);\n                fre = pow(fre, 3.);\n                \n                colour += .5*vec3(0., .1, .5) *  dif * occlusion\n                    + vec3(0., .1, .5) * fre;\n            }\n            \n            // --- Side light\n            {\n                float dif = clamp( dot(normal, normalize(vec3(.7, .2, -.4))) , 0., 1.);\n                \n                colour += .07*vec3(.9, .3, .0) *  dif * occlusion;\n            }\n            \n            // colour = vec3(1.) * pow(length(t.yzx), 10.);\n            // colour = vec3(1.) * pow(length(pointNearObject), 1.);\n            // colour = 0.5 + 0.5 * normal;\n        }\n        else\n        {\n            // --- Spiral fx background\n            float fxMask = 1. - smoothstep(0., .8, pow( length(uv) - .5, 3. ));\n            \n            float fxInhaleStrength = 5. * ( 1. - smoothstep( 0., 1., length(uv) * .5 ) );\n            vec2 rotUVs = mat2(cos(fxInhaleStrength), -sin(fxInhaleStrength),\n                               sin(fxInhaleStrength),  cos(fxInhaleStrength)) * (uv) * uvScale;\n            float an = time * rotFactor;\n            rotUVs = mat2(cos(an), -sin(an),\n                          sin(an),  cos(an)) * (rotUVs);\n            \n            float noise = valueNoise2D( rotUVs );\n            \n            noise = smoothstep(.8, 1., noise);\n            \n            colour += .1 * fxColor * noise * fxMask;\n        }\n        \n        // --- Lightnings\n        {\n            //float mask = 1. - smoothstep(0., .05, pow( length(uv) - .5, 3. ));\n            //mask *= 1. - step( 0.15, mod( time - length(uv), 2.) );\n            //mask *= smoothstep( .8, .85, valueNoise2D( .1 * time - uv * 5. ) );\n            \n            //vec2 voro = voronoi2D( time - abs(uv * 8.) );\n            //float dist = voro.y - voro.x;\n            //float bord = 1. - smoothstep(0., .05, dist);\n            \n            //colour += fxColor * bord * mask;\n        }\n        \n        // --- Volumetric lighting?\n        {\n            //vec3 normal = vec3(0.);\n            \n            //vec2 intersections = iSphere( rayOrigin, rayDirection, vec3(0.), orbRadius );\n            //if (intersections.x > 0.)\n           // {\n             //   normal = normalize(rayOrigin + rayDirection * intersections.x);\n            //}\n            \n            //vec4 vol = getVolumetricLighting( \n             //   normal,  \n              //  orbRadius + .005,\n               // hexcoreRadius * 1.3,\n                //time);\n            \n            //colour += vec3(1.) * vol.x;\n        }\n        \n        // vignetting\n        colour *= 1. - .25*dot(uv, uv);\n\n        // gamma        \n        tot += pow(colour,vec3(.45));\n        \n    // if ssaa is on, take the average of the samples\n    #if SSAA >1\n    }\n    tot /= float(SSAA*SSAA);\n    #endif\n    \n    // dithering\n    tot += (1./512.)*(sin(fragCoord.y*111.0) * sin(fragCoord.x*125.546));\n\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [{"id": 28943, "src": "https://soundcloud.com/sting/what-could-have-been-feat-ray", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "\n// ------------------------------------------------- SHORTHANDS ------------------------------------------------\n\n// @source https://iquilezles.org/articles/distfunctions/\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\n// ------------------------------------------------- CONVERSION ------------------------------------------------\n\n// example input : 134. \n// example output: 2.14\nfloat convertSecondsToMinutes(float seconds)\n{\n    // 0.017 = 1. / 60.\n    return floor(seconds * .017) + mod(seconds, 60.) * .01;\n}\n\n// example input : 2.14 \n// example output: 134.\nfloat convertMinutesToSeconds(float minutes)\n{\n    return floor(minutes) * 60. + fract(minutes) * 100.;\n}\n\n// ----------------------------------------------------- SDFs -------------------------------------------------\n\nvec4 sdSphere( vec3 p, float radius )\n{\n    return vec4(length(p) - radius, p);\n}\n\nfloat sdCylinder( vec3 p, float radius )\n{\n    return length(p.xz)-radius;\n}\n\n// @source https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 point, vec3 b )\n{\n    vec3 d = abs(point) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// @source https://iquilezles.org/articles/distfunctions/\n// Triangle - exact   (https://www.shadertoy.com/view/4sXXRN)\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\n\n// ------------------------------------------------- POSITIONING ----------------------------------------------\n\n// rot Z, X, Y in radians\nvec3 rotate(vec3 point, float rotX, float rotY, float rotZ)\n{\n    vec3 rotatedPoint = point;\n    \n    rotatedPoint = mat3(cos(rotZ), -sin(rotZ), 0,\n                        sin(rotZ),  cos(rotZ), 0,\n                        0,          0,         1) \n                        \n                 * mat3(1, 0,          0,\n                        0, cos(rotX), -sin(rotX), \n                        0, sin(rotX),  cos(rotX))\n    \n                 * mat3(cos(rotY),  0, sin(rotY),\n                        0,          1, 0,\n                        -sin(rotY), 0, cos(rotY))\n                        \n                 * point;\n    \n    return rotatedPoint;\n}\n\n// --------------------------------------------- PRIMITIVE COMBINATIONS ---------------------------------------\n// -------------------------------- https://iquilezles.org/articles/distfunctions/ ----------------------------\n\nfloat opUnion( float d1, float d2 ) { return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return min(d1, d2) - h*h*0.25/k;\n\t//float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k )\n{\n    float h = max(k-abs(-d1-d2),0.0);\n    return max(-d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n\t//return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k )\n{\n    float h = max(k-abs(d1-d2),0.0);\n    return max(d1, d2) + h*h*0.25/k;\n\t//float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n\t//return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\n// ---------------------------------------- DEFORMATIONS & DISTORTIONS ----------------------------------------\n\nvec3 opTwist( in vec3 p, float amount )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(amount*p.y);\n    float s = sin(amount*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\nvec3 opCheapBend( in vec3 p, float amount )\n{\n    const float k = 10.0; // or some other amount\n    float c = cos(amount*p.x);\n    float s = sin(amount*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n\n// ---------------------------------------------------- NOISE ------------------------------------------------\n\n// @source https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// @source https://www.shadertoy.com/view/4djSRW\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.zyx + 31.32);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// @source https://www.shadertoy.com/view/4djSRW\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n// @source https://www.shadertoy.com/view/4djSRW\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// @source https://iquilezles.org/articles/voronoilines/\nvec2 voronoi2D( in vec2 x )\n{\n    vec2 p = floor( x );\n    vec2  f = fract( x );\n\n    vec2 res = vec2( 8.0 );\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 b = vec2(i, j);\n        vec2  r = vec2(b) - f + hash22(p + b);\n        float d = dot(r, r);\n\n        if( d < res.x )\n        {\n            res.y = res.x;\n            res.x = d;\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return sqrt( res );\n}\n\n// @source https://www.shadertoy.com/view/lsf3WH\nfloat valueNoise2D( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// @source https://www.shadertoy.com/view/4sfGzS\n// Value Noise 3D \nfloat valueNoise3D( in vec3 x )\n{\n    vec3 i = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n\t\n    return mix(mix(mix( hash13(i+vec3(0,0,0)), \n                        hash13(i+vec3(1,0,0)),f.x),\n                   mix( hash13(i+vec3(0,1,0)), \n                        hash13(i+vec3(1,1,0)),f.x),f.y),\n               mix(mix( hash13(i+vec3(0,0,1)), \n                        hash13(i+vec3(1,0,1)),f.x),\n                   mix( hash13(i+vec3(0,1,1)), \n                        hash13(i+vec3(1,1,1)),f.x),f.y),f.z);\n}\n\n// @source https://www.shadertoy.com/view/ldl3Dl\n// returns closest, second closest, and cell id\nvec3 voronoi3D( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash33( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjyRR.jpg", "access": "api", "license": "proprietary-license", "functions": [[1791, 1791, 1842, 1895, 3432], [3957, 3957, 3991, 3991, 4538], [4583, 4792, 4823, 4883, 6406], [6521, 6570, 6625, 6625, 9088], [9090, 9090, 9151, 9151, 9772], [9774, 9774, 9828, 9828, 10132], [10134, 10134, 10172, 10224, 10432], [10434, 10616, 10650, 10670, 11926], [11928, 11975, 12042, 12042, 12238], [12240, 12509, 12572, 12655, 13606], [13608, 13774, 13814, 13814, 14505], [14507, 14507, 14563, 14563, 15012], [15014, 15068, 15160, 15160, 15564], [15566, 15566, 15648, 15648, 15882], [15884, 15996, 16048, 16048, 16225]], "test": "untested"}
{"id": "flSfWK", "name": "Animated Flag of Brasil", "author": "kroltan", "description": "My previous shader, but with some displacement and lighting just for pretty.", "tags": ["sdf", "flag", "brazil", "brasil"], "likes": 3, "viewed": 289, "published": 3, "date": "1652730186", "time_retrieved": "2024-07-30T16:48:39.072996", "image_code": "// Palette\nconst vec3 BACKGROUND_COLOR = vec3(0.0000, 0.6117, 0.2157);\nconst vec3 RHOMBUS_COLOR =    vec3(0.9961, 0.8745, 0.0000);\nconst vec3 CIRCLE_COLOR =     vec3(0.0000, 0.1529, 0.4627);\nconst vec3 DETAIL_COLOR =     vec3(1.0000, 1.0000, 1.0000);\nconst vec3 TEXT_COLOR =       vec3(0.0000, 0.6078, 0.2274);\n\n// Definitions\nconst float BASIS_HALF_WIDTH = 10.0;\nconst float BASIS_HALF_HEIGHT = 7.0;\n\nconst float RHOMBUS_INSET = 1.7;\n\nconst float CIRCLE_RADIUS = 3.5;\n\nconst vec2 STRIPE_CENTER_OFFSET = vec2(-2.0, -BASIS_HALF_HEIGHT);\nconst float STRIPE_INNER_RADIUS = 8.0;\nconst float STRIPE_OUTER_RADIUS = 8.5;\n\nconst int TEXT_SMALL_INDEX = 6;\nconst int TEXT_LENGTH = 17;\nconst int[TEXT_LENGTH] TEXT_CHARS = int[TEXT_LENGTH](\n    79, 82, 68, 69, 77,\n    32,  69,  32,\n    80, 82, 79, 71, 82, 69, 83, 83, 79\n);\n\nconst int STAR_SIZES_LENGTH = 5;\nconst float[STAR_SIZES_LENGTH] STAR_SIZES = float[STAR_SIZES_LENGTH](\n    1.0 / 3.0,\n    1.0 / 4.0,\n    1.0 / 5.0,\n    1.0 / 7.0,\n    1.0 / 10.0\n);\n\nconst int STARS_LENGTH = 27;\nconst vec3[STARS_LENGTH] STARS = vec3[STARS_LENGTH](\n    // X and Y from center, Z is size\n    // Extracted from https://upload.wikimedia.org/wikipedia/commons/f/ff/Flag_of_Brazil_%28sphere%29.svg\n    // Using the snippet\n    /*\n        [...document.querySelectorAll('use[id*=_]')]\n            .map(x => {\n                const xy = x.getAttribute(\"transform\")\n                    .match(/\\((.*?)\\)/)[1]\n                    .split(\",\")\n                    .map(x => parseInt(x, 10) * 0.00548245614035087719298245614035);\n                const size = parseInt(x.getAttribute(\"xlink:href\").at(-1), 10);\n                return [...xy, size]\n            })\n            .map(([x, y, size]) => `vec3(${y}, ${x}, ${size.toFixed(1)})`)\n            .join(\",\\n\")\n     */\n    vec3(-3.289473684210526, -0.7236842105263157, 1.0),\n    vec3(-2.933114035087719, 0.9703947368421052, 1.0),\n    vec3(-3.426535087719298, 1.332236842105263, 2.0),\n    vec3(-2.538377192982456, 0.7236842105263157, 4.0),\n    vec3(-2.094298245614035, 1.3706140350877192, 2.0),\n    vec3(-2.2149122807017543, 1.7708333333333333, 3.0),\n    vec3(1.25, -1.25, 1.0),\n    vec3(2.8234649122807016, 1.4144736842105263, 1.0),\n    vec3(3.382675438596491, 1.4528508771929824, 3.0),\n    vec3(2.9879385964912277, 1.7708333333333333, 2.0),\n    vec3(2.017543859649123, 2.615131578947368, 2.0),\n    vec3(2.012061403508772, 3.020833333333333, 3.0),\n    vec3(2.4177631578947367, 2.2971491228070176, 3.0),\n    vec3(2.7412280701754383, 2.094298245614035, 2.0),\n    vec3(2.00109649122807, 2.2203947368421053, 3.0),\n    vec3(-1.5350877192982455, 0.1644736842105263, 2.0),\n    vec3(1.0964912280701753, -0.20285087719298245, 3.0),\n    vec3(0, 1.8092105263157894, 1.0),\n    vec3(0.46600877192982454, 1.0087719298245614, 2.0),\n    vec3(0, 0.6469298245614035, 2.0),\n    vec3(-0.4057017543859649, 1.0087719298245614, 3.0),\n    vec3(-0.20285087719298245, 1.2883771929824561, 4.0),\n    vec3(1.2061403508771928, 2.713815789473684, 2.0),\n    vec3(1.5515350877192982, 2.357456140350877, 3.0),\n    vec3(0.888157894736842, 2.258771929824561, 3.0),\n    vec3(-1.6173245614035088, 2.138157894736842, 1.0),\n    vec3(0, 3.1524122807017543, 5.0)\n);\n\n\n// *cracks knuckles*\n\n\nvoid paint(inout vec3 canvas, in vec3 color, in float shape, in float width) {\n    canvas = mix(canvas, color, smoothstep(width, 0.0, shape));\n}\n\n\nvec2 polarUv(in vec2 uv, in vec2 center) {\n    vec2 local = uv - center;\n    float angle = atan(local.y, local.x);\n    float radius = length(local);\n    \n    return vec2(angle, radius);\n}\n\n\nfloat textTexture(in vec2 uv, in int index) {\n    if (index < 0 || index >= TEXT_LENGTH) return 9999.0;\n    \n    if (index == TEXT_SMALL_INDEX) uv *= 1.2;\n    \n    return char(iChannel0, uv, TEXT_CHARS[index]).w;\n}\n\n\nvec3 flag(in vec2 uv) {\n    float rhombus = sdRhombus(uv, vec2(BASIS_HALF_WIDTH - RHOMBUS_INSET, BASIS_HALF_HEIGHT - RHOMBUS_INSET));\n    \n    float circle = sdCircle(uv, CIRCLE_RADIUS);\n    \n    // I don't like the magic numbers here, but my brain is too smooth to make this exact\n    vec2 stripeUv = polarUv(uv, STRIPE_CENTER_OFFSET)\n        * vec2(-float(TEXT_LENGTH) * 1.3, 1.0)\n        - vec2(float(-TEXT_LENGTH) * 2.125, STRIPE_INNER_RADIUS);\n    \n    float stripeThickness = (STRIPE_OUTER_RADIUS - STRIPE_INNER_RADIUS) / 2.0;\n    float stripe = abs(stripeUv.y - stripeThickness) - stripeThickness;\n    stripe = max(stripe, circle - fwidth(circle) / 2.0);\n    \n    float text = textTexture(\n        vec2(\n            (fract(stripeUv.x) - 0.5) / 2.0 + 0.5,\n            stripeUv.y / stripeThickness * 0.5\n        ),\n        int(ceil(stripeUv.x))\n    ) - 0.5;\n    \n    float stars = 9999.0;\n    for (int i = 0; i < STARS_LENGTH; ++i) {\n        vec3 star = STARS[i];\n        // Ugly vec and sizes magic numbers, too :/\n        stars = min(stars, sdStar(uv - star.xy * vec2(.9, -.9), STAR_SIZES[int(star.z) - 1] * 0.6, 5, 3.3));\n    }\n    \n    vec3 canvas = BACKGROUND_COLOR;\n    paint(canvas, RHOMBUS_COLOR, rhombus, fwidth(rhombus));\n    paint(canvas, CIRCLE_COLOR, circle, fwidth(circle));\n    paint(canvas, DETAIL_COLOR, stars, fwidth(stars));\n    paint(canvas, DETAIL_COLOR, stripe, fwidth(stripe));\n    paint(canvas, TEXT_COLOR, text, 0.02);\n    return canvas;\n}\n\n\nfloat heightMap(in vec2 uv) {\n    float wavy = sin(-1.0 * uv.x + 0.333 * uv.y + cos(uv.y / 3.0) + iTime * 2.0) * 0.75;\n    float turbulence = sin(uv.y * -0.5 + iTime) * (uv.x + BASIS_HALF_WIDTH) * 0.05;\n    float pinch =\n        - sin(0.3 * uv.x * uv.y + iTime) * 0.075\n        * pow(smoothstep(BASIS_HALF_WIDTH, 0.0, uv.x), 5.0);\n    \n    return wavy + pinch + turbulence;\n}\n\n\nvoid distort(inout vec2 uv, out vec3 normal) {\n    float self = heightMap(uv);\n    \n    normal = normalize(vec3(\n        heightMap(uv + vec2(0.1, 0.0)) - heightMap(uv - vec2(0.1, 0.0)),\n        heightMap(uv + vec2(0.0, 0.1)) - heightMap(uv - vec2(0.0, 0.1)),\n        1.0\n    ));\n\n    uv += vec2(self * 0.05, self * 0.2);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 flagUv = uv * BASIS_HALF_HEIGHT;\n    \n    vec3 normal;\n    distort(flagUv, normal);\n    \n    float light = dot(normal, vec3(1.25, 0.0, 1.0));\n    \n    fragColor = vec4(flag(flagUv) * light, 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * SDFs from Inigo Quilez's website: https://iquilezles.org/articles/distfunctions2d/\n */\n\n// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en));\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n/*\n * Font texture access pilfered from FabriceNeyret2's shader here, unknown license: https://www.shadertoy.com/view/ltcXzs\n */\n\nvec4 char(sampler2D tex, vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    return textureGrad( tex, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSfWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3216, 3216, 3294, 3294, 3360], [3363, 3363, 3405, 3405, 3550], [3553, 3553, 3598, 3598, 3767], [3770, 3770, 3793, 3793, 5239], [5242, 5242, 5271, 5271, 5617], [5620, 5620, 5666, 5666, 5942], [5945, 5945, 6000, 6000, 6273]], "test": "untested"}
{"id": "Nt2fzD", "name": "Space Donuts Yumm", "author": "byt3_m3chanic", "description": "Space donuts - cause time has stopped moving for me..", "tags": ["reflection", "torus", "raymarcing", "donuts"], "likes": 25, "viewed": 378, "published": 3, "date": "1652713172", "time_retrieved": "2024-07-30T16:48:39.830969", "image_code": "/**\n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n        \n    Space Donuts | 5/15/22  \n    byt3_m3chainc\n\n*/\n\n#define R iResolution\n#define M iMouse\n#define T iTime\n\n#define PI  3.1415926535\n#define PI2 6.2831853071\n\n#define MIN_DIST .0001\n#define MAX_DIST 90.\n\nmat2 rot (float a) { return mat2(cos(a),sin(a),-sin(a),cos(a)); }\nfloat hash21(vec2 a) { return fract(sin(dot(a,vec2(215.23,41.232)))*4123.2323); }\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.-2.*f);\n    return mix( mix( hash21( i + vec2(0,0) ), \n                     hash21( i + vec2(1,0) ), u.x),\n                mix( hash21( i + vec2(0,1) ), \n                     hash21( i + vec2(1,1) ), u.x), u.y);\n}\n\n//@iq torus\nfloat torus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nvec3 hit,hitPoint,sto,gto;\nvec2 gid,sid;\nfloat time;\nmat2 r90;\nfloat zoom = 35.;\nconst vec2 sc = vec2(.125), hsc = .5/sc; \n\nvec2 map(vec3 p) {\n    p.y+=1.;\n    p.x+=T*1.5;\n    \n    vec3 qq=p;\n    vec2 id=floor((p.xz-7.)/14.);\n    float hs = hash21(id);\n    p.xz=mod(p.xz-7.,14.)-7.;\n    \n    vec2 res = vec2(1e5,0);\n    vec3 q = p-vec3(0,1.05,0);\n    \n    float fs = (.1+hs);\n    float rbase = (fs*2.)+T;\n    q.yz*=rot(rbase*fs);\n    q.xy*=rot(rbase*.75*fs);\n\n    float ns = noise(q.xz)*2.;\n    float b2 = torus(q,vec2(2.75 ,1.25 ))-(ns*.15);\n    float b3 = torus(q,vec2(2.75 ,1.265 ))-(ns*.2);\n    float wv = .2*sin(q.x*3.2)+.2*cos(q.z*2.2);\n    float fq = q.y -wv;\n    b3=max(fq,b3);\n    \n    if(b2<res.x) {\n        res = vec2(b2,3.);\n    \thit=q;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    if(b3<res.x) {\n        res = vec2(b3,4.);\n    \thit=q;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    // I am clueles on how to place ojects on the\n    // surface - so here I make a circle of sprinkles\n    // in a circle around the torus..\n    \n    // it's hacky - so if there is a better way let\n    // me know\n    \n    vec3 q1=q;\n    float amount = 32.;\n    //@Shane polar rep\n    float a = atan(q1.z, q1.x);\n    float ia = floor(a/PI2*amount);\n    ia = (ia + .5)/amount*PI2;\n\n    float qd = -mod(ia,.0);\n\n    mat2 rxa = rot(ia);\n    q1.xz *= rxa;\n    q1.xy -= vec2(2.715,0);\n\n    amount = 12.;\n    vec3 q2 = q1;\n    \n    q2.xz*=r90;\n    \n    a = atan(q2.z, q2.y);\n    float da = floor(a/PI2*amount);\n    da = (da + .5)/amount*PI2;\n    float dd = mod(da,.0);\n\n    rxa = rot(da);\n    q2.yz *= rxa;\n    q2.yx -= vec2(1.4+(ns*.15),0);\n    \n    float xs = hash21(vec2(qd,dd));\n    \n    float d5 = length(q2)-.115;\n\n    if(xs<.6) d5=1.;\n    \n    if(d5<res.x &&q.y<0.) {\n        res = vec2(d5,6.);\n    \thit=q;\n        gid=vec2(qd,dd)+id;\n        gto=vec3(id,.5);\n    }\n    \n    // floor\n    float d9 = qq.y;\n    d9 = max(d9,-(length(q)-5.25));\n    if(d9<res.x) {\n        res = vec2(d9,1.);\n    \thit=qq;\n        gid=id;\n        gto=vec3(id,.5);\n    }\n\n    return res;\n}\n\n// Tri-Planar blending function. Ryan Geiss: \n// https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n ){\n    n = max(abs(n), 0.001);\n    n /= dot(n, vec3(1));\n\tvec3 tx = texture(t, p.yz).xyz;//vec3(noise(p.yz*22.));\n    vec3 ty = texture(t, p.zx).xyz;//vec3(noise(p.zx*22.)); \n    vec3 tz = texture(t, p.xy).xyz;//vec3(noise(p.xy*22.)); \n    //return mat3(tx*tx, ty*ty, tz*tz)*n;\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n// https://www.shadertoy.com/view/ld3yDn\nvec3 doBumpMap( sampler2D tx, vec3 p, vec3 n, float bf, float per){\n    vec2 e = vec2(per*MIN_DIST, 0);   \n    mat3 m = mat3( \n        tex3D(tx, p - e.xyy, n), \n        tex3D(tx, p - e.yxy, n), \n        tex3D(tx, p - e.yyx, n)\n    );\n\n    const vec3 gn = vec3(0.580,0.839,0.420);\n    vec3 g = gn* m; \n    g = (g - dot(tex3D(tx,  p , n), gn) )/e.x; g -= n*dot(n, g);  \n    return normalize( n + g*bf );\n}\n\nvec3 normal(vec3 p, float t){\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e).x+\n             h.yyx * map(p+h.yyx*e).x+\n             h.yxy * map(p+h.yxy*e).x+\n             h.xxx * map(p+h.xxx*e).x;\n    return normalize(n);\n}\n\nvec3 hue(float t, vec3 d) { \n    return .375 + .375*cos(PI2*t*(vec3(.985,.98,.95)+d)); \n}\n\nvec4 FC = vec4(0.306,0.337,0.353,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d) {\n\n    vec3 C = vec3(0);\n    float m = 0.;\n    vec3 p = ro;\n    \n    for(int i=0;i<75;i++)\n    {\n        p = ro + rd * d;\n        vec2 ray = map(p);\n        if(abs(ray.x)<MIN_DIST*d||d>MAX_DIST)break;\n        d += i<32? ray.x*.5: ray.x;\n        m  = ray.y;\n    } \n\n    hitPoint = hit;\n    sid = gid;\n    sto = gto;\n    \n    float alpha = 0.;\n    if(d<MAX_DIST)\n    {\n        vec3 n = normal(p,d);\n        vec3 lpos =  vec3(1,18,-13);\n        vec3 l = normalize(lpos-p);\n\n        if(m==3.){\n            vec3 hp = hitPoint;\n            n = doBumpMap(iChannel0, hp*.075, n, .005 ,d);\n        }\n        \n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 18.; ) {\n            float h = map(p + l*t).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 18.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>32. ) break;\n        }\n        diff = mix(diff,diff*shdw,.75);\n\n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.), 14.);\n\n        vec3 h = vec3(.5);\n        \n        if(m==1.) {\n            vec3 hp = hitPoint*sc.xxx;\n            h = vec3(.7);\n            vec2 f = fract(hp.xz*3.)-.5;\n            if(f.x*f.y>0.) h=clamp( hue( sin(hp.x*.25),vec3(0.961,0.541,0.220) )+.2,vec3(0),vec3(1) );\n            if(hp.y<.0)h=vec3(.8);\n            ref = vec3(h*.5);\n        }\n        \n        if(m==2.) {\n            h=vec3(.5);\n            ref = h;\n        }\n        \n        if(m==3.) {\n            h=mix(vec3(0.573,0.310,0.008),vec3(0.914,0.714,0.169),clamp((hitPoint.y-.25)*.5,0.,1.));\n            ref = vec3(.001);\n        }\n        \n        if(m==4.) {\n            h=hue(3.+hash21(sid)*1.3,vec3(0.220,0.875,0.961));\n            ref = h;\n        }\n        \n        if(m==6.) {\n            h=hue(3.+hash21(sid)*.25,vec3(0.914,0.169,0.753));\n            ref = h;\n        }\n        \n        C = h*diff+min(shdw,spec);\n        C = mix(FC.rgb,C,  exp(-.0000025*d*d*d));\n    \n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    \n    }\n    \n    return vec4(clamp(C,vec3(.03),vec3(1.)),alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{\n    time = T*.75;\n    r90=rot(1.5707);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    if(uv.x>0.)zoom=20.;\n    vec3 ro = vec3(uv*zoom,-zoom);\n    vec3 rd = vec3(0,0,1.);\n    mat2 rx = rot(-45.*PI/180.);\n    mat2 ry = rot(-.78*sin(T*2.*PI/180.));\n    ro.yz *= rx;ro.xz *= ry;\n    rd.yz *= rx;rd.xz *= ry;\n\n    vec3 C = vec3(0);\n    vec3 ref=vec3(0); \n    vec3 fil=vec3(1);\n    \n    float d =0.;\n    float bnc = 2.;\n    \n    for(float i=0.; i<bnc; i++) {\n        d =0.;\n        vec4 pass = render(ro, rd, ref, i==bnc-1., d);\n        C += pass.rgb*fil;\n        fil*=ref;\n    }\n\n    C=clamp(C,vec3(.01),vec3(1.));\n    if(uv.x<.001&&uv.x>-.001)C=vec3(1);\n    // gamma correction\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fzD.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[305, 305, 325, 325, 370], [371, 371, 393, 393, 452], [454, 454, 480, 480, 761], [763, 775, 806, 806, 871], [997, 997, 1015, 1015, 2942], [2944, 3058, 3105, 3105, 3430], [3432, 3473, 3540, 3540, 3876], [3878, 3878, 3907, 3907, 4146], [4148, 4148, 4175, 4175, 4237], [4278, 4278, 4363, 4363, 6528], [6530, 6530, 6571, 6571, 7297]], "test": "untested"}
{"id": "Nl2fWy", "name": "Cool Space", "author": "eiffie", "description": "The file was named coolspace.glsl but I didn't remember writing it and it wasn't that cool so I thought I should rename it. After several minutes of writer's block trying I instead added alien batbots. Batbots make everything cool.", "tags": ["ufobats"], "likes": 23, "viewed": 439, "published": 3, "date": "1652711873", "time_retrieved": "2024-07-30T16:48:42.250500", "image_code": "#define R iResolution\n#define OPI 3.5\nfloat ff=1.,time,T,J=-1.,glw=0.,rad=20.5;\nfloat oSin(float a){a=mod(a,OPI*2.);\n  float b=.87,c=.37,pi4=OPI/4.,s=a<OPI?1.:-1.;a=mod(a,OPI);if(a>OPI/2.)a=OPI-a;\n  return (a<pi4?a*b:pi4*b+(a-pi4)*c)*s;\n}\nfloat oCos(float a){return oSin(a+OPI/2.);}\nfloat dot2(vec2 a){return dot(a,a);}\n#define RMX mat2(.92388,.38268,-.38268,.92388)*(rad+sin(J+t*mod(J,32.))*.3)\nvec3 path(float t){t+=J*.976+sin(J)*.3;t*=2.05/rad*(mod(rad/2.,2.)<1.?1.:-1.);vec2 p=vec2(oCos(t),oSin(t))*RMX;return vec3(p.x,1.8+sin(t*(1.+mod(J,25.)))*.5,p.y);}\nmat2 face(vec2 a){a=normalize(a);return mat2(a.y,-a.x,a.x,a.y);}\nvec2 rotate(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nfloat jet(vec3 p){\n  return ff*max(abs(p.y)-.05+5.*p.x*p.x*max(0.,p.z+.1)+min(dot(p.xz,p.xz)*3.,length(p.xz)*.25),-p.x*p.x-p.z-.05);\n}\nvec3 rot(vec3 p){\n  vec3 p0=path(time+.1),p1=path(time),p2=path(time-.1),p3=path(time+1.),p4=path(time-1.);\n  p-=(p0+p2)*.5;\n  p.xz=p.xz*face(p0.xz-p2.xz);\n  p.xy=rotate(p.xy,dot2((p3.xz+p4.xz)*.5-p1.xz)*2.);\n  return p;\n}\nvoid GetJ(vec2 p){//get closest jet\n  vec4 O=texture(iChannel0,(p+vec2(100.))/200.);\n  J=O.x;rad=O.y;ff=O.w;time=O.z;\n}\nvec3 mcol=vec3(0.0);\nfloat DE(vec3 p){ \n vec4 z=vec4(abs(mod(p,6.)-3.),max(1.0,2.-T*.1)),p0=vec4(.09,.98,.09,.0);//0.08,1.0,-1.0,.0);\n for (int n = 0; n < 3; n++) { \n  z.xyz=clamp(z.xyz, -1.0, 1.0) *2.0-z.xyz; \n  z=z/min(dot(z.xyz,z.xyz),1.0)+p0;\n }p=rot(p);\n float d=(max(z.x,max(z.y,z.z))-1.0)/z.w;\n float dJ=jet(p);\n d=min(d,dJ);\n if(mcol.x>0.){\n  if(d==dJ){\n   if(p.y<.024)mcol+=abs(sin(vec3(J,J+.4,J+1.2)));\n   else mcol+=vec3(0);\n  }\n  else mcol+=abs(sin(z.xyz));\n }\n p.y+=0.005;p.x=abs(p.x)-.045;\n float dL=dot2(p.xy)+abs(p.z*.001);\n if(dL<.00025){\n   if(mcol.x>0.)mcol.r+=2.;\n   else glw+=exp(dL);\n }\n return d;\n}\nvec3 sky(vec3 rd, vec3 L){\n  float d=1.-abs(rd.y);\n  return pow(d,8.)*(rd*.5+.5)*(0.4*dot(rd,L)+0.6);\n}\nfloat rnd;\nvoid randomize(in vec2 p){rnd=fract(float(iTime)+sin(dot(p,vec2(13.3145,117.7391)))*4317.7654321);}\n\nfloat ShadAO(in vec3 ro, in vec3 rd){\n float t=0.01*rnd,s=1.0,d,mn=0.01;\n for(int i=0;i<12;i++){\n  d=max(DE(ro+rd*t)*1.5,mn);\n  s=min(s,d/t+t*0.5);\n  t+=d;\n }\n return s;\n}\nvec3 rt,up=vec3(0,1,0);\nvec3 scene(vec3 ro, vec3 rd){GetJ(ro.xz);\n  float t=DE(ro)*rnd,d,px=1.0/R.x;\n  for(int i=0;i<99;i++){\n    T=t;\n    GetJ(ro.xz+rd.xz*t);\n    t+=d=DE(ro+rd*t);\n    if(t>200.0 || d<px*t)break;\n  }\n  vec3 L=normalize(vec3(0.3,0.03,0.5));\n  vec3 bg=sky(rd,L),col=bg;\n  if(d<px*t*5.0){\n    while(d<px*t){t-=max(px*t,abs(d));d=DE(ro+rd*t);}\n    mcol=vec3(0.001);\n    vec3 so=ro+rd*t;\n    d=DE(so);\n    vec3 N=normalize(rt*(DE(so+rt*d)-d)+up*(DE(so+up*d)-d)-rd*(DE(so-rd*d)-d));\n    vec3 scol=mcol*0.25;\n    if(scol.r>1.1)col=vec3(1.,rnd*.5,0.);\n    else{\n      float dif=.5+.5*dot(N,L),vis=clamp(dot(N,-rd),.05,1.),fr=pow(1.-vis,5.),shad=ShadAO(so,L);\n      col=((scol+abs(N.yxz)*.3)*dif+fr*sky(reflect(rd,N),L))*shad;\n    }\n  }\n  return mix(col,bg,min(1.,t*t*0.001))+glw*vec3(1,.5*rnd,0.);\n}\nmat3 lookat(vec3 fw){fw=normalize(fw);rt=normalize(cross(fw,up));\n  up=cross(rt,fw);return mat3(rt,up,fw);\n}\nvoid mainImage(out vec4 O, in vec2 U){\n//O=vec4(abs(sin(texture(iChannel0,U/R.xy).x)));return;//view map\n  randomize(U);J=5.;\n  vec3 ro=path(iTime*1.4-2.),rd=lookat(path(iTime*1.4)-ro)*normalize(vec3(U-R.xy*.5,R.x));\n  ro.y+=.35;\n  O=vec4(scene(ro,rd),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//requires NEAREST\n//find the closest jet with minimal checks then fudge\n#define time iTime\n#define rez iResolution.xy\n#define OPI 3.5\nfloat oSin(float a){a=mod(a,OPI*2.);\n  float b=.87,c=.37,pi4=OPI/4.,s=a<OPI?1.:-1.;a=mod(a,OPI);if(a>OPI/2.)a=OPI-a;\n  return (a<pi4?a*b:pi4*b+(a-pi4)*c)*s;\n}\nfloat oCos(float a){return oSin(a+OPI/2.);}\nfloat octo(vec2 p){return max(max(abs(p.x),abs(p.y)),max(abs(p.x+p.y),abs(p.x-p.y))*.707);}\n#define RMX mat2(.92388,.38268,-.38268,.92388)*(rad+sin(J+t*mod(J,32.))*.3)\nfloat J,rad;\nvec2 path(float t){t+=J*.976+sin(J)*.3;t*=2.05/rad*(mod(rad/2.,2.)<1.?1.:-1.);return vec2(oCos(t),oSin(t))*RMX;}\nvoid mainImage(out vec4 O, in vec2 U){\n  vec2 uv=100.*(2.0*U-rez)/rez;\n  float t=time,dm=250.,c=-1.,ff=1.,r;\n  rad=floor(octo(uv)*.5+.5)*2.+.5;\n  for(J=0.;J<64.;J+=1.){\n    float d=length(uv-path(t));\n    if(d<dm){if(dm<.5)ff=.5;dm=d;c=J;r=rad;}\n  }\n  O=vec4(c,r,t,ff);//jet,radius,time,fudge factor \n}", "buffer_a_inputs": [], "sound_code": "#define bps 8.\n#define pi 3.14159\nfloat scale(float note){//throws out dissonant tones\n float n2=mod(note,12.);\n if((n2==1.)||(n2==3.)||(n2==5.)||(n2==8.)||(n2==11.))note=-100.;//locrian\n return note;\n}\n// note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(int n0){\n float n=scale(float(n0));\n return (n>0.)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;\n}\nvec2 rot(vec2 v, float a) {return cos(a)*v+sin(a)*vec2(v.y,-v.x);}\nvec2 I(int n, float t){\n  float f=ntof(n);\n  if(f==0.)return vec2(0);t=pow(t,.999);\n  return (1.-t)*rot(fract(vec2(t,t*2.005)*f),f);\n}\nvec2 Sound(float time){\n  float tim=time*bps;//tim+=pow(1.-fract(tim),20.0);\n  float bt=floor(tim),t=fract(tim);\n  int n1=int(bt/64.)%8;\n  int n0=n1+(int(bt/8.)%8),n=n0+(int(bt)%8),n2=n0+(int(bt/2.)%8),n4=n0+(int(bt/4.)%8);\n  vec2 v=I(n+12,t+=pow(1.-fract(tim),20.0))*.75;\n  v-=I(n2+24,fract(tim/2.));\n  v+=I(n4+31,fract(tim/4.));\n  v-=I(n0+24,fract(tim/8.));\n  return v*.2;\n}\nvec2 mainSound(int samp, float time){\n  return Sound(time)+Sound(time-.5)*.6-Sound(time-1.5)*.3;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2fWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 100, 100, 238], [239, 239, 259, 259, 282], [283, 283, 302, 302, 319], [396, 396, 415, 415, 559], [560, 560, 578, 578, 624], [625, 625, 655, 655, 694], [695, 695, 713, 713, 829], [830, 830, 847, 847, 1052], [1053, 1053, 1071, 1088, 1172], [1194, 1194, 1211, 1211, 1794], [1795, 1795, 1821, 1821, 1898], [1910, 1910, 1936, 1936, 2009], [2011, 2011, 2048, 2048, 2182], [2207, 2207, 2236, 2236, 2992], [2993, 2993, 3014, 3014, 3101], [3102, 3102, 3140, 3206, 3361]], "test": "untested"}
{"id": "Nl2fWG", "name": "Sine-Gordon equation", "author": "TreborHuang", "description": "2-dimensional sine-Gordon equation. Click to excite a wave.\nChange the K parameter to increase/decrease non-linearity.\nLook at the excite function in Buffer A for more detail. We have moving breathers that seems capable of colliding and turning directions", "tags": ["pde", "soliton"], "likes": 5, "viewed": 223, "published": 3, "date": "1652702639", "time_retrieved": "2024-07-30T16:48:43.137130", "image_code": "#define hue(v) ( .6 + .6 * cos( (v) + vec4(0,-2.*Pi/3.,2.*Pi/3.,0) ) )\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float strength = get(fragCoord).x;\n    float it = sin(strength * ANGLE)*1.3;\n    // the field strength is already an angle (radians)\n    it = sign(it) * pow(abs(it), 1.6);  // Reverse(!) gamma-correct\n    fragColor = vec4(it, (cos((strength*ANGLE)-Pi)-0.8)/.3, -it, 1.0);\n    // A tint of green to show that it went round the phase circle.\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nfloat laplace(vec2 pos) {\n    return(WRAP(get(pos + vec2(1,0)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(1,0)).x - get(pos).x) / dx) / dx\n         \n         +(WRAP(get(pos + vec2(0,1)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(0,1)).x - get(pos).x) / dx) / dx;\n}\n\nfloat excite(float dist, float x){\n    return sin(2.6*x*sin(iTime*.3)+2.) *   // This factor seems to create a pair of moving solitons?\n        3.2 * (1. - exp(-1./pow(dist+0.00001,2.))) * exp(-.1*pow(dist, 2.)) / ANGLE;\n        // Of course everything is approximate.\n}\n\n// Calculates the position.\n// x - records the corrent position.\n// y - records last position.\n// z - records last acceleration.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xy = get(fragCoord).xx;\n    fragColor.z = laplace(fragCoord) + sin(fragColor.x * ANGLE) * K;  // Acceleration\n    \n    fragColor.x += (getv(fragCoord) + fragColor.z * .5 * dt) * dt;\n    \n    if(iMouse.z > 0.) {\n        // mouse\n        fragColor.xy += excite(length(iMouse.zw - fragCoord) * dx,\n            ((iMouse.z-fragCoord.x)* sin(iTime)\n            +(iMouse.w-fragCoord.y)* cos(iTime))* dx);\n    }\n    if(iFrame < 2) {\n        // initial position\n        fragColor = vec3(\n            .3 * exp(- pow(length(2. * fragCoord - iResolution.xy),2.) / iResolution.x * .2) * sin(fragCoord.x * .09 + fragCoord.y * 0.03),\n            0.,\n            1.\n        ).xxyz;\n    }\n    fragColor *= smooth;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dx 0.1\n#define dt 0.03\n\n#define Pi 3.141592653589793\n\n#define get(p) texture(iChannel0, vec2(p)/iResolution.xy)\n#define getv(p) texture(iChannel1, vec2(p)/iResolution.xy).x\n\n#define smooth 0.99999\n#define K -3.\n\n#define ANGLE (2.*Pi)\n\n#define WRAP(t) (t)\n// Todo..\n", "buffer_b_code": "\nfloat laplace(vec2 pos) {\n    return(WRAP(get(pos + vec2(1,0)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(1,0)).x - get(pos).x) / dx) / dx\n         \n         +(WRAP(get(pos + vec2(0,1)).x - get(pos).x) / dx\n         + WRAP(get(pos - vec2(0,1)).x - get(pos).x) / dx) / dx;\n}\n\n\n// Calculates the velocity\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 pos = get(fragCoord);\n    fragColor.x = getv(fragCoord) + (pos.z +\n        laplace(fragCoord) + sin(pos.x * ANGLE) * K) * .5 * dt;\n    fragColor.x = clamp(fragColor.x, -3., 3.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2fWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 128, 128, 474]], "test": "untested"}
{"id": "ftSfDy", "name": "bus stop", "author": "jorge2017a2", "description": "bus stop", "tags": ["busstop"], "likes": 5, "viewed": 200, "published": 3, "date": "1652668283", "time_retrieved": "2024-07-30T16:48:44.183332", "image_code": "//----------image\n//por jorge2017a2-\n//bus stop---15-may-2022\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);\n    p= rotate_y( p, radians(iTime*20.0));\n    \n    vec3 p0=p;\n    p.y=p.y-5.0;\n    //caja atras\n    float d1a= sdBox(p-vec3(0.0,4.0,0.0), vec3(11.0,5.5,5.0) );\n    float d1as= sdBox(p-vec3(0.0,4.0,0.0), vec3(10.0,5.0,5.5) );\n    float d1b= sdBox(p-vec3(0.0,4.0,0.0), vec3(10.0,5.0,5.0) );\n    float d1c= sdBox(p-vec3(0.0,9.0,0.0), vec3(10.0,0.7,4.0) );\n    \n    ///ventanas\n    float d2a= sdBox(p-vec3(-5.0,6.0,0.0), vec3(3.0,2.0,5.5) );\n    float d2b= sdBox(p-vec3(-5.0,1.0,0.0), vec3(3.0,1.5,5.5) );\n    \n    float d2c= sdBox(p-vec3(4.0,6.0,0.0), vec3(5.5,1.5,5.5) );\n    float d2d= sdBox(p-vec3(2.0,3.0,0.0), vec3(2.5,1.,5.5) );\n    float d2e= sdBox(p-vec3(5.0,0.5,0.0), vec3(3.0,1.0,5.5) );\n    \n    //llantas atras\n    float d3aa= sdCylinderXY(p- vec3(-5.0,-0.5,-5.0), vec2(2.0,1.0) );\n    float d3ab= sdCylinderXY(p- vec3(-5.0,-0.5,-5.5), vec2(1.0,1.0) );\n    \n    float d3ba= sdCylinderXY(p- vec3(20.0,-0.5,-5.0), vec2(2.0,1.0) );\n    float d3bb= sdCylinderXY(p- vec3(20.0,-0.5,-5.5), vec2(1.0,1.0) );\n    \n    //llantas lateral\n    float d3ca= sdCylinderXY(p- vec3(-5.0,-0.5,5.0), vec2(2.0,1.0) );\n    float d3cb= sdCylinderXY(p- vec3(-5.0,-0.5,5.5), vec2(1.0,1.0) );\n    \n    float d3da= sdCylinderXY(p- vec3(20.0,-0.5,5.0), vec2(2.0,1.0) );\n    float d3db= sdCylinderXY(p- vec3(20.0,-0.5,5.5), vec2(1.0,1.0) );\n    \n    //caja delantera\n    float d4a= sdBox(p-vec3(16.0,4.0,0.0), vec3(4.0,5.5,5.0) );\n    float d4ad= sdBox(p-vec3(16.0,6.0,0.0), vec3(3.0,2.5,5.5) ); //diferencia\n    float d4ca= sdBox(p-vec3(16.0,6.0,0.0), vec3(3.0,2.5,4.5) ); //ventana lateral\n    float d4cb= sdBox(p-vec3(17.0,6.0,0.0), vec3(4.,2.5,4.5) ); //ventana frente\n    float d4ba= sdBox(p-vec3(23.0,1.0,0.0), vec3(3.0,2.5,4.5) );  //caja delante\n    float d4bb= sdBox(rotate_z(p-vec3(22.5,1.5,0.0),radians(10.0)) , vec3(3.0,2.5,4.0) );  //caja delante ang\n    \n    //calle\n    float d5aa= sdBox(p-vec3(0.0,-4.5,0.0), vec3(20.0,2.0,8.0) );\n    float d5ab= sdBox(p-vec3(0.0,-4.5, 10.0), vec3(20.0,3.0,2.0) );\n    float d5ac= sdBox(p-vec3(0.0,-4.5,-10.0), vec3(20.0,3.0,2.0) );\n    \n    d1a= Difference(d1a, d1as);\n    d4a= Difference(d4a, d4ad);\n    d4a= Difference(d4a, d4cb); //ventana frontal\n    \n    res =opU2(res, vec2(d1a,11.0));\n    res =opU2(res, vec2(d1b,1.0));\n    res =opU2(res, vec2(d1c,1.0));\n\n    res =opU2(res, vec2(d2a,2.0));\n    res =opU2(res, vec2(d2b,3.0));\n    \n    res =opU2(res, vec2(d2c,4.0));\n    res =opU2(res, vec2(d2d,5.0));\n    res =opU2(res, vec2(d2e,6.0));\n    \n    ///llanta der\n    res =opU2(res, vec2(d3aa,1.0)); //llanta atras  \n    res =opU2(res, vec2(d3ab,0.0)); //ring atras\n    \n    res =opU2(res, vec2(d3ba,1.0)); //llanta delante\n    res =opU2(res, vec2(d3bb,0.0)); //ring delante \n    \n    ///llanta izq\n    res =opU2(res, vec2(d3ca,1.0)); //llanta atras  \n    res =opU2(res, vec2(d3cb,0.0)); //ring atras\n    \n    res =opU2(res, vec2(d3da,1.0)); //llanta delante\n    res =opU2(res, vec2(d3db,0.0)); //ring delante \n    \n    res =opU2(res, vec2(d4a,1.0)); //caja delantera\n    res =opU2(res, vec2(d4ca,6.0)); //ventana\n    //res =opU2(res, vec2(d4cb,6.0));\n    \n    res =opU2(res, vec2(d4ba,1.0)); //cada frente\n    res =opU2(res, vec2(d4bb,1.0)); //cada frente ang\n    \n    res =opU2(res, vec2(d5aa,9.0));\n    res =opU2(res, vec2(d5ab,8.0));\n    res =opU2(res, vec2(d5ac,8.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n     float d = pow(rd.z+0.2,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n\t//return sky;\n    return sky*d;\n\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color<40) { colobj=getColor(int( id_color));  return colobj; }     \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(8.0,22.0,-30.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd, 0.62);\n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//-------common\n#define PI 3.14159265\n\n\nvec3  Arrcolores[] = vec3[] (\nvec3(0,0,0),  //0\nvec3(1.,1.,1.), //1\nvec3(1,0,0),  //2\nvec3(0,1,0),   //3\nvec3(0,0,1),   //4\nvec3(1,1,0),  //5\nvec3(0,1,1),  //6 \nvec3(1,0,1),   //7\nvec3(0.7529,0.7529,0.7529),  //8\nvec3(0.5,0.5,0.5),  //9\nvec3(0.5,0,0),   //10\nvec3(0.5,0.5,0.0),  //11\nvec3(0,0.5,0)   //12\n);\n\nvec3 getColor(int i)\n{ if (i>-1 )  return Arrcolores[i]; }\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSfDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[487, 487, 519, 519, 603], [604, 604, 643, 643, 738], [739, 739, 778, 778, 873], [874, 874, 913, 913, 1008], [1010, 1054, 1098, 1098, 1125], [1126, 1126, 1166, 1166, 1193], [1194, 1194, 1239, 1239, 1267], [1269, 1294, 1328, 1328, 1424], [1425, 1425, 1459, 1459, 1550], [1551, 1551, 1585, 1585, 1676], [1678, 1678, 1703, 1703, 5058], [5060, 5060, 5084, 5084, 5246], [5248, 5248, 5296, 5296, 5575], [5577, 5577, 5621, 5621, 5942], [5944, 5944, 5981, 5981, 6238], [6240, 6240, 6330, 6330, 7290], [7293, 7293, 7325, 7325, 7617], [7619, 7619, 7689, 7689, 7787], [7789, 7789, 7816, 7816, 7905], [7907, 7907, 7965, 7965, 8013], [8015, 8015, 8038, 8038, 8150], [8152, 8152, 8183, 8183, 8803], [8805, 8805, 8862, 8862, 9321]], "test": "untested"}
{"id": "NlSBWy", "name": "cool tonemapper test", "author": "EliTheCoder", "description": "I wanted to try to make darks look purplish and brights look yellow/orange. I am also mildly colorblind so this might look terrible to other people but I like the way it looks.", "tags": ["tonemap"], "likes": 6, "viewed": 221, "published": 3, "date": "1652660674", "time_retrieved": "2024-07-30T16:48:45.013114", "image_code": "vec3 coolTone( float b )\n{\n    return vec3(max(3.0*(b-0.3)*(b-0.3),1.2*b-0.1), max(0.0, 1.7*b-0.6), max(-b/2.0+0.3, 2.0*b*b-0.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 col2 = coolTone((col.r+col.g+col.b)/3.0);\n    \n    float weight = 3.0;\n\n    fragColor = vec4((col+col2*weight)/(weight+1.0),1.0);\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSBWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 132], [134, 134, 191, 191, 416]], "test": "untested"}
{"id": "stjfRt", "name": "progressive antialiasing", "author": "FabriceNeyret2", "description": "temporal oversampling using noise texture for jittering.\n( blue/white above/below diagonal, but the way it is used it is all white sampling ;-) ).\n\nNB: for real use, one wants point distribution rather than field.\n  box integration over pixel let some Ali", "tags": ["antialiasing", "temporal"], "likes": 8, "viewed": 418, "published": 3, "date": "1652636696", "time_retrieved": "2024-07-30T16:48:45.836912", "image_code": "void mainImage( out vec4 O, vec2 U )\n{\n    T;\n    O = sqrt(O.xxxx/O.a);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 O, vec2 U )\n{\n    T;\n    U += 1.* ( U.y > U.x // subpixel jittering through time\n          ? texelFetch(iChannel1,ivec2(U+float(iFrame)*vec2(17,13))%1024,0).xy -.5\n          : texelFetch(iChannel2,ivec2(U+float(iFrame)*vec2(17,13))%256,0).xy -.5 );\n          \n    U *= 20./iResolution.xy; \n    U *= sin(U.yx);\n    O.x += fract(U.x*U.y);\n    O.a++;         // frame count\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T O = texelFetch(iChannel0, ivec2(U), 0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjfRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 73]], "test": "untested"}
{"id": "NljfRd", "name": "Water VFX", "author": "rge15", "description": "Simple water effect practicing with some noise and curves", "tags": ["water", "masking", "gradientnoise"], "likes": 3, "viewed": 322, "published": 3, "date": "1652628550", "time_retrieved": "2024-07-30T16:48:46.666693", "image_code": "#define PI 3.14159265358979\n\n\nfloat N21(in vec2 p)\n{\n    p = 50.*fract((p + vec2(7.3945,0.2594273))/PI);\n    return -1.+2.*fract( p.x*p.y/(p.x+p.y) );\n}\n\nvec2 N22(in vec2 p)\n{\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n    return 1. - 2.*fract(p * vec2(p.x+p.y, p.y*p.x) + vec2(0.29137,0.9348));\n}\n\nfloat valueNoise(in vec2 uv)\n{\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 func = f*f*(3.-2.*f);\n\n    float a = N21(i+vec2(0.,0.));\n    float b = N21(i+vec2(1.,0.)); \n    float c = N21(i+vec2(0.,1.)); \n    float d = N21(i+vec2(1.,1.)); \n    \n    return a + (b-a)*func.x + (c-a)*func.y + (a-b-c+d)*func.x *func.y;\n\n}\n\nfloat gradientNoise(in vec2 uv)\n{\n\n    vec2 i = floor(uv);\n    vec2 f = fract(uv);\n\n    vec2 func = f*f*(3.-2.*f);\n\n    vec2 a = N22(i+vec2(0.,0.));\n    vec2 b = N22(i+vec2(1.,0.)); \n    vec2 c = N22(i+vec2(0.,1.)); \n    vec2 d = N22(i+vec2(1.,1.)); \n    \n    float gA = dot(a,f-vec2(0.,0.));\n    float gB = dot(b,f-vec2(1.,0.));\n    float gC = dot(c,f-vec2(0.,1.));\n    float gD = dot(d,f-vec2(1.,1.));\n    \n    return gA + (gB-gA)*func.x + (gC-gA)*func.y + (gA-gB-gC+gD)*func.x *func.y;\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n\n    float p = 0.7 + 0.15 * valueNoise(4.*uv);\n\n    float b = 0.5 + gradientNoise(10.*uv) ;\n\n    float c = 0.2 + .75*gradientNoise(2.*uv);\n    float t = smoothstep( 0.1,1. , c + gradientNoise(3.5*uv-0.7*iTime));\n    \n    vec3 w = p * vec3(0.05,0.75,0.9) + (p*t) * vec3(1.,1.,1.);\n\n    // Output to screen\n    fragColor = vec4(vec3(w),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 152], [154, 154, 175, 175, 302], [304, 304, 334, 334, 633], [635, 635, 668, 668, 1126], [1128, 1128, 1185, 1185, 1587]], "test": "untested"}
{"id": "Nljfzt", "name": "Improved 3x3 Denoising", "author": "TinyTexel", "description": "Improving a 3x3 denoising box filter by weighing the samples proportionally to the sizes of their sorted noise values' voronoi intervals.", "tags": ["noise"], "likes": 5, "viewed": 460, "published": 3, "date": "1652624558", "time_retrieved": "2024-07-30T16:48:47.861498", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Improving a 3x3 denoising box filter by weighing the samples proportionally to the sizes of their sorted noise values' voronoi intervals.\n    The resulting 9 weights per texel should be pre-computed in practice (done at run-time here for simplicity).\n    Doing this mainly improves white noise dithering. For blue noise it attenuates high frequencies that the box filter doesn't handle.\n    For IGN it usually makes not much of a difference (as expected since IGN is already optimized for 3x3 box filtering).\n    Overall not really worth it, I think.\n    \n    Left to right: white noise | blue noise | IGN.\n    \n    Top to bottom: test gradient | raw noise | 3x3 denoising | improved 3x3 denoising | reference\n*/\n\nint xc = 0;\n\n// Jorge Jimenez http://www.iryoku.com/next-generation-post-processing-in-call-of-duty-advanced-warfare\nfloat IGN(vec2 uv) { return fract(52.9829189 * fract(dot(uv, vec2(0.06711056, 0.00583715)))); }\n\nfloat ReadNoise(ivec2 uvi)\n{\n    if(xc == 0) return Hash01(vec2(uvi), 0u);\n    if(xc == 2) return IGN(vec2(uvi));\n    return texelFetch(iChannel0, ivec2(uvec2(uvi) % 1024u), 0).r;\n}\n\nvec3 SampleGradient(float x)\n{\n    //return vec3(x);\n    //return x < 0.25 || x > 0.75 ? vec3(1.0) : vec3(0.0);\n    //return x < 0.25 || x > 0.75 ? vec3(0.0) : vec3(1.0);\n    return round(Hue_to_RGB(x)*2.0)/2.0;\n    //return Hue_to_RGB(x);\n    return mix(vec3(0.0), vec3(1.0), greaterThan(vec3(x), vec3(0.25, 0.5, 0.75)));\n    return round(pow(textureLod(iChannel1, vec2(x * 0.02 + 0.4, 0.5), 0.0).rgb, vec3(2.2)) * 4.0)*0.5;\n    return pow(textureLod(iChannel1, vec2(x * 0.02 + 0.4, 0.5), 0.0).rgb, vec3(2.2));\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    vec2 tc = uv0 / iResolution.xy;\n    \n    if(tc.x > 1.0/3.0) xc = tc.x < 2.0/3.0 ? 1 : 2;\n    \n    vec3 col = vec3(0.0);\n    \n    vec2 uv = uv0 - 0.5;\n    ivec2 uvi = ivec2(uv);\n    \n    \n    if(tc.y > 0.98)// test gradient\n    {\n        col = SampleGradient(tc.x);\n    }\n    else if(tc.y > 0.9)// raw noise\n    {\n        col = SampleGradient(ReadNoise(uvi));\n    }\n    else if(tc.y < 0.1)// reference\n    {\n        float r2 = fract(dot(uv0-0.5, vec2(0.7548776662, 0.56984029)));\n        //r2 = 0.5;\n        col = vec3(0.0);\n        float count = 64.0;\n        for(float i = 0.0; i < count; ++i)\n        col += SampleGradient((i + r2) / count);\n        col /= count;\n    }\n    else if(tc.y > 0.5)// 3x3 denoising\n    {\n        col = vec3(0.0);\n\n        for(int y = -1; y <= 1; ++y)\n        for(int x = -1; x <= 1; ++x)\n        {\n            ivec2 o = ivec2(x, y);\n\n            float n = ReadNoise(uvi + o);\n\n            float w = 1.0;\n\n            col += SampleGradient(n);\n        }\n\n        col /= 9.0;\n    }\n    else// improved 3x3 denoising\n    {\n        float vs[9];\n\n        uint i = 0u;\n        for(int y = -1; y <= 1; ++y)// fill noise values\n        for(int x = -1; x <= 1; ++x)\n        {\n            float n = ReadNoise(uvi + ivec2(x, y));\n\n            vs[i] = n;\n            ++i;\n        }\n\n        for(uint j = 0u; j < 9u; ++j)\n        for(uint i = 0u; i < 8u-j; ++i)// sort noise valus\n        {\n            float a = vs[i     ];\n            float b = vs[i + 1u];\n\n            if(b < a)\n            {\n                vs[i     ] = b;\n                vs[i + 1u] = a;\n            }\n        }\n\n\n        float c[9];// compute voronoi intervals\n\n       #if 1\n        float c08 = vs[0] + (1.0 - vs[8]);\n        \n        c[0] = (c08 + (vs[1] - vs[0])) * 0.5;\n        c[8] = (c08 + (vs[8] - vs[7])) * 0.5;        \n       #else\n        // this version is biased\n        c[0] = (      vs[0]) + (vs[1] - vs[0]) * 0.5;\n        c[8] = (1.0 - vs[8]) + (vs[8] - vs[7]) * 0.5;\n       #endif\n        \n        for(uint i = 1u; i < 8u; ++i)\n        {\n            c[i] = ((vs[i] - vs[i-1u]) + (vs[i+1u] - vs[i])) * 0.5;\n        }\n\n        col = vec3(0.0);\n\n        for(int y = -1; y <= 1; ++y)// denoise\n        for(int x = -1; x <= 1; ++x)\n        {\n            ivec2 o = ivec2(x, y);\n\n            float n = ReadNoise(uvi + o);\n\n            float w = 128.0;\n\n            for(uint i = 0u; i < 9u; ++i)// find noise value in sorted array\n            {\n                if(vs[i] == n)\n                {\n                    w = c[i];// weigh according to voronoi interval\n                    break;\n                }\n            }\n\n            col += SampleGradient(n) * w;\n        }\n        //col = vec3(1.0) * v;\n    }\n    \n    outCol.rgb = pow(col, vec3(1.0/2.2));\n    //outCol.rgb = col;\n    outCol.a = 1.0;\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 Resolution;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nljfzt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[804, 908, 928, 928, 1003], [1005, 1005, 1033, 1033, 1186], [1188, 1188, 1218, 1358, 1701], [1703, 1703, 1751, 1751, 4556]], "test": "untested"}
{"id": "Nt2fRt", "name": "Sarumaru LogPolar Animation", "author": "yasuo", "description": "Fujiko Fujio A", "tags": ["reproduction", "sarumaru"], "likes": 4, "viewed": 229, "published": 3, "date": "1652621213", "time_retrieved": "2024-07-30T16:48:48.682304", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 64\n#define MAX_DIST 64.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n\n#define ZERO (min(iFrame,0))\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 GetDist(vec3 p) {\n    float d = p.y;\n    vec2 model = vec2(d,MATERIAL);\n    return model;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(5,0,-5));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff;\n    diffCol += col*vec3(1.0,1.0,1.0)*skyDiff;\n    diffCol += col*vec3(0.9)*bounceDiff;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.); // spec\n        \n    return diffCol;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\nvec3 sarumaru(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    p*=Rot(radians(-15.0));\n    p.x*=1.5;\n    p-=vec2(-0.3,0.01);\n    float ear = length(p)-0.07;\n    col = mix(col,vec3(1.0,0.9,0.8),S(ear,0.0));\n    ear = abs(length(p)-0.07)-0.005;\n    col = mix(col,vec3(0.0),S(ear,0.0));\n    \n    p = prevP;\n    p.y+=0.06;\n    p.x*=0.8;\n    float d = length(p)-0.15;\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,0.0));\n    d = abs(length(p)-0.15)-0.005;\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.y-=0.01;\n    d = length(p)-0.2;\n    d = max(-p.y-0.07,d);\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,0.0));\n    d = abs(length(p)-0.2)-0.005;\n    d = max(-p.y-0.07,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    // hair\n    p = prevP;\n    p.y-=0.01;\n    d = length(p)-0.2;\n    d = max(-p.y+0.02,d);\n    \n    p.x-=-0.02;\n    p.x*=1.0;\n    p.x=abs(p.x)-0.08;\n    float d2 = length(p)-0.1;\n    d = max(-d2,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    p = prevP;\n    \n    p-=vec2(0.1,0.25);\n    p*=Rot(radians(50.0));\n    d = sdTriangleIsosceles(p,vec2(0.03,-0.09));\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    // eye\n    p = prevP;\n    p.x-=-0.09;\n    p.y-=-0.01;\n    p.x*=1.5;\n    d = length(p)-0.065;\n    p = prevP;\n    p.x-=-0.09;\n    p.y-=-0.01;\n    p*=Rot(radians(90.0));\n    d2 = sdTriangleIsosceles(p-vec2(0.00,0.02),vec2(0.02,0.03));\n    d = max(-d2,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p.x-=0.03;\n    p.y-=-0.01;\n    p.x*=1.5;\n    d = length(p)-0.065;\n    p = prevP;\n    p.x-=0.03;\n    p.y-=-0.01;\n    p*=Rot(radians(90.0));\n    d2 = sdTriangleIsosceles(p-vec2(0.00,0.02),vec2(0.02,0.03));\n    d = max(-d2,d);\n    col = mix(col,vec3(0.0),S(d,0.0));    \n    \n    p = prevP;\n    p*=Rot(radians(10.0));\n    p.x*=1.5;\n    p-=vec2(0.28,0.01);\n    ear = length(p)-0.07;\n    col = mix(col,vec3(1.0,0.9,0.8),S(ear,0.0));\n    ear = abs(length(p)-0.07)-0.005;\n    col = mix(col,vec3(0.0),S(ear,0.0));\n    \n    // mouth\n    p = prevP;\n    p*=Rot(radians(-10.0));\n    p.y*=1.8;\n    p-=vec2(-0.03,-0.23);\n    d = length(p)-0.1;\n    d = max(p.y,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-30.0));\n    p.y*=2.1;\n    p-=vec2(-0.138,-0.05);\n    d = length(p)-0.1;\n    d = max(p.x+0.06,d);\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,0.0));\n    d = abs(length(p)-0.1)-0.005;\n    d = max(p.x+0.06,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-5.0));\n    p.y*=2.0;\n    p-=vec2(-0.11,-0.19);\n    d = length(p)-0.1;\n    d = max(p.y+0.05,d);\n    d = max(-p.x-0.05,d);\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,0.0));\n    d = abs(length(p)-0.1)-0.005;\n    d = max(p.y+0.05,d);\n    d = max(-p.x-0.05,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    p = prevP;\n    p*=Rot(radians(-10.0));\n    p.y*=2.0;\n    p-=vec2(0.01,-0.19);\n    d = length(p)-0.1;\n    d = max(p.y+0.03,d);\n    d = max(-p.x-0.07,d);\n    col = mix(col,vec3(1.0,0.9,0.8),S(d,0.0));\n    d = abs(length(p)-0.1)-0.005;\n    d = max(p.y+0.03,d);\n    d = max(-p.x-0.07,d);\n    col = mix(col,vec3(0.0),S(d,0.0));\n    \n    return col;\n}\n\nvec3 drawTex(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    // https://en.wikipedia.org/wiki/Log-polar_coordinates\n    float r = log(sqrt(p.x*p.x+p.y*p.y)); // or log(length(p))\n    float theta = atan(p.y/p.x);\n    p.x = r;\n    p.y = theta;\n    \n    p.x+=iTime*0.3;\n    p*=2.0;\n    p = fract(p)-0.5;\n    p*=0.75;\n    p*=Rot(radians(iTime*-20.0));\n    \n    col = sarumaru(p,col);\n    \n    p = prevP;\n    \n    p*=0.15;\n    p*=Rot(radians(iTime*-20.0));\n    col = sarumaru(p,col);\n    \n    return col;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        col = diffuseMaterial(n,rd,p,drawTex(p.xz,col));\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -10.0);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(3.0,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(35.0));\n        ro.xz *= Rot(radians(iTime*10.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0.0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[384, 384, 404, 404, 476], [478, 478, 500, 500, 574], [576, 576, 634, 634, 901], [903, 903, 927, 927, 1128], [1130, 1130, 1172, 1172, 1367], [1369, 1369, 1426, 1426, 1911], [1913, 1973, 2024, 2024, 2332], [2334, 2334, 2366, 2366, 5428], [5430, 5430, 5462, 5462, 5932], [5934, 5934, 5993, 5993, 6099], [6101, 6101, 6158, 6158, 6943]], "test": "untested"}
{"id": "7tBBRd", "name": "bezier eye with open and close", "author": "shudal", "description": "bezier eye with open and close", "tags": ["bezier"], "likes": 5, "viewed": 204, "published": 3, "date": "1652604636", "time_retrieved": "2024-07-30T16:48:49.566938", "image_code": "vec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n  vec3 E = mix(A, B, t);\n  vec3 F = mix(B, C, t);\n  vec3 G = mix(C, D, t);\n\n  vec3 H = mix(E, F, t);\n  vec3 I = mix(F, G, t);\n\n  vec3 P = mix(H, I, t);\n\n  return P;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float addx=abs(sin(iTime)/2.);\n    \n    vec3 pn=bezier(vec3(-0.1,0.5,0.),vec3(0.25,0.63+addx,0.),vec3(0.75,0.66+addx,0.),vec3(1.1,0.6,0.),uv.x);\n    vec3 pn2=bezier(vec3(-0.1,0.4,0.),vec3(0.25,0.27-addx,0.),vec3(0.75,0.24-addx,0.),vec3(1.1,0.5,0.),uv.x);\n    \n    if (uv.y>pn.y) { \n        col = col *smoothstep(0.1,0.,abs(uv.y-pn.y));\n    }\n    if (uv.y <pn2.y) { \n        col = col *smoothstep(0.1,0.,abs(uv.y-pn2.y));\n    }\n    \n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 221], [222, 222, 279, 329, 967]], "test": "untested"}
{"id": "slSBRd", "name": "beizier eye", "author": "shudal", "description": "beizier eye", "tags": ["bezier"], "likes": 1, "viewed": 190, "published": 3, "date": "1652603984", "time_retrieved": "2024-07-30T16:48:50.404699", "image_code": "vec3 bezier(vec3 A, vec3 B, vec3 C, vec3 D, float t) {\n  vec3 E = mix(A, B, t);\n  vec3 F = mix(B, C, t);\n  vec3 G = mix(C, D, t);\n\n  vec3 H = mix(E, F, t);\n  vec3 I = mix(F, G, t);\n\n  vec3 P = mix(H, I, t);\n\n  return P;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 pn=bezier(vec3(-0.1,0.5,0.),vec3(0.25,0.63,0.),vec3(0.75,0.66,0.),vec3(1.1,0.6,0.),uv.x);\n    vec3 pn2=bezier(vec3(-0.1,0.4,0.),vec3(0.25,0.27,0.),vec3(0.75,0.24,0.),vec3(1.1,0.5,0.),uv.x);\n    if (uv.y>pn.y || uv.y <pn2.y) {\n        col = vec3(0.);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSBRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 221], [222, 222, 279, 329, 786]], "test": "untested"}
{"id": "NlBBR3", "name": "Just desert(s)", "author": "ruojake", "description": "A desert terraiin. \n\n[UPDATE 2022-05-15]\nRaplaced FXAA with TAA,  much smoother", "tags": ["3d", "raymarching", "terrain", "clouds", "desert", "taa"], "likes": 14, "viewed": 375, "published": 3, "date": "1652573916", "time_retrieved": "2024-07-30T16:48:51.337205", "image_code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// This is a post-processing pass, adding dither and vignette\n// Rendering in Buffer A, TAA in buffer B\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nfloat vignette(vec2 fc)\n{\n    vec2 uv = fc / iResolution.xy * 2. - 1.;\n    float v = length(uv);\n    return 1. - v * v * v * .2;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 col = texelFetch(iChannel1, fc, 0).rgb;\n    \n    col *= vignette(fragCoord);\n    // dither\n    col += fract(dot(fragCoord + float((iFrame & 7) * 23), vec2(1.14321,1.23422))) * .0125 - .00625;\n    \n    fragColor = vec4(col,1.0);\n}\n\n/* \n//Old FXAA pass\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec2 uv = fragCoord / iResolution.xy;\n    float m = texelFetch(iChannel0, fc, 0).a;\n    \n    float l  = texelFetchOffset(iChannel0, fc, 0, ivec2(-1,  0)).a;\n    float r  = texelFetchOffset(iChannel0, fc, 0, ivec2( 1,  0)).a;\n    float t  = texelFetchOffset(iChannel0, fc, 0, ivec2( 0,  1)).a;\n    float b  = texelFetchOffset(iChannel0, fc, 0, ivec2( 0, -1)).a;\n    \n    float tl = texelFetchOffset(iChannel0, fc, 0, ivec2(-1,  1)).a;\n    float tr = texelFetchOffset(iChannel0, fc, 0, ivec2( 1,  1)).a;\n    float bl = texelFetchOffset(iChannel0, fc, 0, ivec2(-1, -1)).a;\n    float br = texelFetchOffset(iChannel0, fc, 0, ivec2( 1, -1)).a;\n    \n    float mn = min(l, min(r, min(t, min(b, m))));\n    float mx = max(l, max(r, max(t, max(b, m))));\n    float con = mx - mn;\n    \n    float thr = max(.03125, mx * .125);\n    \n    vec3 col = texture(iChannel0, uv).rgb; \n    if(con > thr)\n    {\n        float flt = 2. * (t + b + l + r)\n                  + tl + tr + bl + br;\n        flt = smoothstep(0., 1., abs(flt / 12. - m) / con);\n        flt *= flt;\n\n        float hz = abs(b + t - 2. * m) * 2.\n                 + abs(bl + tl - 2. * l)\n                 + abs(br + tr - 2. * r);\n        float vt = abs(l + r - 2. * m) * 2.\n                 + abs(bl + br - 2. * b)\n                 + abs(tl + tr - 2. * t);\n\n        float pLum, nLum;\n        vec2 o, uvE = uv;\n        if(vt > hz)\n        {\n            pLum = r;\n            nLum = l;\n            o = vec2(0,1);\n            uvE += vec2(.5 / iResolution.x, 0); \n        }\n        else\n        {\n            pLum = t;\n            nLum = b;\n            o = vec2(1,0);\n            uvE += vec2(0, .5 / iResolution.y);\n        }\n\n        float pGr = abs(pLum - m);\n        float nGr = abs(nLum - m);\n\n        o /= iResolution.xy;\n        vec2 oE = o;\n        float gr, oppLum;\n        if(pGr < nGr)\n        {\n            gr = nGr;\n            o *= -1.;\n            oppLum = nLum;\n        }\n        else\n        {\n            gr = pGr;\n            oppLum = pLum;\n        }\n\n        float lumE = (m + oppLum) * .5;\n        float grThr = gr * .25;\n        \n        float steps[10] = float[](1., 1.5, 2., 2., 2., 2., 2., 2., 2., 4.);\n        \n        vec2 uvP = uvE + oE;\n        float pDLum = texture(iChannel0, uvP).a - lumE;\n        bool atEnd = abs(pDLum) >= grThr;        \n        \n        for(int i = 0; i < 9 && !atEnd; ++i)\n        {\n            uvP += oE * steps[i];\n            pDLum = texture(iChannel0, uvP).a - lumE;\n            atEnd = abs(pDLum) >= grThr;\n        }\n        if (!atEnd) uvP += oE * 8.;\n        \n        vec2 uvN = uvE - oE;\n        float nDLum = texture(iChannel0, uvN).a - lumE;\n        atEnd = abs(nDLum) >= grThr;\n        \n        for(int i = 0; i < 9 && !atEnd; ++i)\n        {\n            uvN -= oE * steps[i];\n            nDLum = texture(iChannel0, uvN).a - lumE;\n            atEnd = abs(nDLum) >= grThr;\n        }\n        if (!atEnd) uvN -= oE * 8.;\n        \n        float distP = vt > hz ? uvP.y - uv.y : uvP.x - uv.x;\n        float distN = vt > hz ? uv.y - uvN.y : uv.x - uvN.x;\n        float dist = min(distP, distN);\n        bool dSgn = distN < distP ? nDLum >= 0. : pDLum >= 0.;\n        \n        float blFac = dSgn == ((m - lumE) >= 0.) ? 0. : .5 - dist / (distN + distP);\n        flt = max(blFac, flt * .8);\n        \n        uv += o * flt;\n        col = texture(iChannel0, uv).rgb;\n        //col = vec3(flt);\n    }\n    //else col *= 0.;\n    \n    col *= vignette(fragCoord);\n    // dither\n    col += fract(dot(fragCoord + float((iFrame & 7) * 23), vec2(1.14321,1.23422))) * .0125 - .00625;\n    \n    fragColor = vec4(col,1.0);\n}*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\nfloat hash12(vec2 p)\n{\n    vec3 q = fract(p.xyx * vec3(.15431,.16233,.14635) - .0001);\n    q -= p.y * q.y * .002312;\n    return fract((dot(p.yxy * 3.12103 + q.z, -q) - q.x + p.x) * 2. - q.y);\n}\n\nmat2 rot(float a)\n{\n    float s = sin(a),\n          c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = smoothstep(.1, .9, p - i);\n    \n    vec2 o = vec2(1, 0);\n    \n    return mix(\n        mix(hash12(i),hash12(i + o), f.x),\n        mix(hash12(i + o.yx), hash12(i + 1.), f.x), \n        f.y);\n}\n\nfloat fbm3(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 3; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat fbm5(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 5; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat fbm7(vec2 p)\n{\n    p.x *= .4;\n    float res = 0.;\n    float s = 1.;\n    mat2 r = rot(2.);\n    for(int i = 0; i < 7; ++i)\n    {\n        p *= r;\n        res += noise(p * s) / s;\n        s *= 3.;\n    }\n    return res * .6666;\n}\n\nfloat sceneLD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm3(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nfloat sceneMD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm5(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nfloat sceneHD(vec3 p)\n{\n    p.y = p.y - smoothstep(-.6, .6, p.y - 1.) * .7;\n    float h = max(0., fbm7(p.xz * .2) * 1.6 - .6);\n    return p.y - h * h * 2.;\n}\n\nvec3 normal(vec3 p)\n{\n    const vec2 e = vec2(.0001, 0.);\n    \n    return normalize(\n        sceneHD(p) - vec3(\n            sceneHD(p - e.xyy),\n            sceneHD(p - e.yxy),\n            sceneHD(p - e.yyx)\n        )\n    );\n}\n\nvec3 normLD(vec3 p, float d)\n{\n    const vec2 e = vec2(.01, 0.);\n    \n    return normalize(\n        d - vec3(\n            sceneLD(p - e.xyy),\n            sceneLD(p - e.yxy),\n            sceneLD(p - e.yyx)\n        )\n    );\n}\n\nvec3 normMD(vec3 p)\n{\n    const vec2 e = vec2(.01, 0.);\n    \n    return normalize(\n        sceneMD(p) - vec3(\n            sceneMD(p - e.xyy),\n            sceneMD(p - e.yxy),\n            sceneMD(p - e.yyx)\n        )\n    );\n}\n\nfloat clouds(vec2 p)\n{\n    p += iTime * vec2(-.2, .7); \n    p *= rot(1.4); \n    float res = smoothstep(0.,1.,fbm3(p * .05));\n    res *= smoothstep(.3, .7, fbm3(p * .02 + 2.));\n    return res;\n}\n\nvec3 sky(vec3 rd, vec3 ld)\n{\n    float sun = dot(ld, rd);\n    sun = pow(sun, 20.) + pow(sun, 900.) * 5.;\n    vec3 col = vec3(.05,.2,1.) + clamp(rd.y * -.6 + .5, 0., 1.);\n    if(rd.y > 0.)\n    {\n        vec2 p = (rd * 25. / rd.y).xz;\n        float c = clouds(p);\n        c *= smoothstep(0.,.1, rd.y);\n        sun *= clamp(1. - c, 0., 1.);\n        col += c * (1. + sun);\n        p += ld.xz / ld.y * .5;\n        col *= 1. - clouds(p) * c * .3;\n        p += ld.xz / ld.y * .5;\n        col *= 1. - clouds(p) * c * .3;\n    }\n    return col + sun * vec3(1., .8, .7);\n}\n\nvec4 matTerrain(vec3 p, vec3 n)\n{\n    float pat = fbm3(p.xz * .5);\n    pat = smoothstep(.1, .9, pat);\n    vec4 c = mix(vec4(.5,.125,.05, .8), vec4(.6,.3,.125, 0), clamp(pat + smoothstep(.7, 1., n.y) * .8, 0., 1.));\n    float t = iTime;\n    float h = smoothstep(.3, 1., noise(sin(p.xz * .7 + t)));\n    float w = n.y * n.y * n.y * n.y \n            * smoothstep(0., 1., sin(dot(vec2(3,-2), p.xz) - t * 4.) * noise(p.xz * 3.)) \n            * h * .1;\n    c.rgb += w * vec3(1., .7, .4);\n    c.a *= 1. - w;\n    return c;\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float t = .01;\n    float res = 1.;\n    for(int i = 0; i < 100; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float d = sceneLD(p);\n        if(abs(d) < .0001) return 0.;\n        res = min(d/t * 3., res);\n        t += d;\n    }\n    \n    return clamp(res, 0., 1.);\n}\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nvec3 reinhard(vec3 c)\n{\n    float l = lum(c);\n    float n = l * (1. + l / 9.) / (1. + l);\n    return c * n / l;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    \n    vec3 ro = vec3(0,3,iTime - 200.), // my hash func is a bit bad, pull the camera back\n         rd = normalize(vec3(uv,3)),\n         p;\n    \n    // vary ray origin for TAA\n    ro.xy += fract((fragCoord + float((iFrame & 7) * 23)) * vec2(1.14321,1.23422)) * .006 - .003;\n    \n    vec3 ld = normalize(vec3(1,1,6));\n    vec3 col = sky(rd, ld);\n    float t = 100.;\n     \n    if(rd.y < 0.)\n    {\n        float i = 0.,\n              d, m;\n        t = 0.;\n\n        for(;i < 1.; i += 3./512.)\n        {\n            p = ro + rd * t;\n            d = sceneLD(p);\n\n            if(abs(d) < .001 * min(log(t), 1.)) break;\n            t += d;\n        }\n        \n        vec3 n = t < 80. ? normal(p) : t < 120. ? normMD(p) : normLD(p, d);\n        \n        float l = dot(n, ld) * .5 + .5;\n        l *= clamp(clouds((p + ld * (25. - p.y) / ld.y).xz) + .2, 0., 1.);\n        l *= 1. - i * .25;\n        float sh = shadow(p + n * .2, ld);\n        l *= sh;\n        \n        vec3 sk = col;\n        vec4 mat = matTerrain(p, n);\n        col = mat.rgb;\n        vec3 sd = reflect(rd, n);\n        float spec = max(pow(clamp(dot(sd, ld), 0., 1.), 16. * mat.a) * mat.a, 0.);\n        spec *= clouds((p + sd * (25. - p.y) / max(sd.y, .001)).xz);\n        col *= mix(vec3(.05, .1, .3), vec3(1.,.98,.92) * 3., l);\n        col += spec * clamp(1. - t * .01, 0. ,1.);\n        col = mix(col, sk, clamp(1. - exp(-t * .006 + .4 * (1. - sh) + .1), 0., 1.));\n    }\n\n    col = reinhard(col); // tonemapping\n    col = mix(vec3(lum(col)), col, 1.5); // some saturation\n    col = pow(col, vec3(1./2.2)); // gamma correction\n\n    //fragColor = vec4(col, clamp(lum(col), 0., 1.)); // output luminance for FXAA\n    fragColor = vec4(col, t * rd.z + iTime); // output Z position for TAA\n}", "buffer_a_inputs": [], "buffer_b_code": "// Just desert(s) by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// TAA pass\n// An improvised hack, don't use as reference for anything!\n// Works surprisingly well here though.\n\nfloat lum(vec3 c)\n{\n    return dot(c, vec3(.2126,.7152,.0722));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 fc = ivec2(fragCoord);\n    vec4 a = texelFetch(iChannel0, fc, 0);\n    vec4 b = iFrame > 0 ? texelFetch(iChannel1, fc, 0) : a;\n    a.rgb = clamp(a.rgb, vec3(0), vec3(1));\n    b.rgb = clamp(b.rgb, vec3(0), vec3(1));\n    \n    float d = clamp(abs(b.a - a.a), 0., 1.);\n    float dl = lum(abs(a.rgb - b.rgb));\n    d = max(d, clamp((1.2 + d) * dl, .25, 1.));\n    fragColor = mix(b, a, d);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlBBR3.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[220, 220, 239, 239, 285], [287, 287, 312, 312, 417], [419, 419, 476, 476, 790]], "test": "untested"}
{"id": "7l2fzc", "name": "Deformed bubbles 2", "author": "VPas", "description": "Improved bubbles", "tags": ["3d", "bubbles", "raymatch"], "likes": 7, "viewed": 291, "published": 3, "date": "1652558004", "time_retrieved": "2024-07-30T16:48:52.156016", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t=iTime;\n    vec2 r=iResolution.xy,\n    uv=(fragCoord*2.-r)/min(r.x,r.y);\n    vec3 ro=vec3(0.,0.3,t),c,f,dir=normalize(vec3(uv,1.)),p;\n    vec3 l1=ro+vec3(3.,2.,-4.),\n    l2=ro+vec3(-2.,-1.,-3.),\n    l3=ro+vec3(3.,-1.,-4.);\n    ro+=5.*(vec3(mix(vec2(0.49,0.57), iMouse.rg/r, step(0.1, iMouse.z)),-0.4)*2.-1.);\n    float d=.5,e=1.,i,j,s,ss;\n  \n    for(;i++<99.&&e>.001;j=0.){\n        p=ro+dir*d;\n        p.z+=p.x*.1;\n        p.x+=sin((p.z+p.y*.4))*.3;\n        p.y+=cos((p.z+p.x*.3))*.4;\n        vec3 \n        n=l1-p;c+=vec3(.5,1.,2.)/(1.+dot(n,n));\n        n=l2-p;c+=vec3(1.5,.5,.5)/(1.+dot(n,n));\n        n=l3-p;c+=vec3(.5,1.,.5)/(1.+dot(n,n));\n        ss=2.;\n        for(;j++<9.;) {\n            p=mod(p,2.)-1.;\n            s=1./max(.1, dot(p,p));\n            ss*=s;\n            p=p.zxy;\n            p*=s;\n        }\n        e=length(p)/ss-.02;\n        e*=.5;\n        d+=e*.5;\n    }\n    c*=.1;\n    fragColor = vec4(c/(1.+c),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2fzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 997]], "test": "untested"}
{"id": "7t2fWD", "name": "Normal Oriented Color Bleeding", "author": "iY0Yi", "description": "This is a fake GI. I call this \"Normal Oriented Color Bleeding\".\nThis time, I added roughly multi bounced indirect light.\nIt looks like a path tracing. But it's very rough.", "tags": ["gi", "global", "illumination", "lighting", "bleeding"], "likes": 19, "viewed": 514, "published": 3, "date": "1652547821", "time_retrieved": "2024-07-30T16:48:53.295968", "image_code": "//#define DEBUG_VIEW\n//#define AA\n#define PIXEL_NOISE\nconst float MAX_SAMP = 16.;\nconst float BOUNCE = 4.;\n\nstruct Ray{\n\tvec3 origin;\n\tvec3 direction;\n};\n\nstruct Light{\n\tvec3 direction;\n\tvec3 color;\n\tfloat intensity;\n\tfloat shadowStart;\n\tfloat shadowEnd;\n\tfloat shadowSoft;\n};\n\nstruct RenderData{\n\tvec3 position;\n\tvec3 albedo;\n\tvec3 normal;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat shadow;\n\tfloat ao;\n    vec3 bleed;\n\tfloat depth;\n\tvec3 result;\n}renDat;\n\nRay ray;\nLight lit0;\n\n#define MIN_DIST 0.001\n#define MAX_DIST 20.0\n#define ITERATION 50\n\n#define MAT_VOID vec3(-1)\n#define MAT_WHITE vec3(0.85)\n#define MAT_BLACK vec3(0.03)\n#define MAT_RED vec3(.850,0.149,0.000)\n#define MAT_BLUE vec3(0.000,0.667,.850)\n#define MAT_GREEN vec3(0.000,.850,0.165)\n#define MAT_YELLOW vec3(.850,.850,0.149)\n#define MAT_PURPLE vec3(.850,0.078,.850)\n#define AMB_COL vec3(0.486,0.655,0.996)\n#define AMB_COL2 vec3(0.000,0.157,0.941)\n#define AMB_STRENGTH 0.3\n#define FOG_COL AMB_COL\n#define FOG_START 0.0\n#define FOG_POW 1.85\n\n#define LIGHT_STRENGTH 2.\n\nfloat sdBox( vec3 p, vec3 b ) {\n    const float r = .01;\n\tvec3 d = abs(p) - b+r;\n\treturn min(0.,max(d.x,max(d.y,d.z))) + length(max(d,0.)) - .01;\n}\n\nfloat fOpUnion(in float a,in float b){\n\treturn a<b?a:b;\n}\n\nvec4 v4OpUnion(in vec4 a,in vec4 b){\n\treturn a.x<b.x?a:b;\n}\n\nfloat map(in float dist, in float c, in float l, in float q)\n{\n    return 1. - 1. / (c + l * dist + q * pow(dist,2.5));\n}\n\nfloat opIntS(float a,float b,float r){\n  float h = max( r-abs(a-b), 0. )/r;\n  return max( a, b ) + h*h*h*r*(1./6.);\n}\n\nvec4 v4OpSub(in vec4 a,in vec4 b){\n\treturn a.x>b.x?a:b;\n}\n\nfloat txGrid(vec2 uv, float size){\n    if(ceil(sin(iTime*.6)*5.)>2.5)return 1.;\n    return float(abs(ceil(fract(uv.x*size)-.5)+ceil(fract(uv.y*size)-.5)-1.));\n}\n\nvec4 sdScene(vec3 p){\n\tfloat d = MAX_DIST;\n\tvec4 res = vec4(MAX_DIST, MAT_VOID);\n    \n    // room box\n    vec3 bs = vec3(.025,1.025,1.025);\n    float grds = 0.5;\n    grds = abs(floor(sin(iTime*1.)*4.));\n    \n    bool v = (ceil(sin(iTime*.2)*2.)>1.);\n    bool bw = (ceil(cos(iTime*.8)*2.)>1.);\n    \n    vec4 w0 = vec4(sdBox(p+vec3(1,0,0),bs), mix(MAT_WHITE, MAT_GREEN, txGrid(p.yz, grds)));\n    vec4 w1 = vec4(sdBox(p+vec3(-1,0,0),bs), mix(MAT_WHITE, MAT_RED, txGrid(p.yz, grds)));\n    vec4 w2 = vec4(sdBox(p+vec3(0,1,0),bs.yxz), mix(MAT_WHITE, v?MAT_PURPLE:bw?MAT_BLACK:MAT_WHITE, txGrid(p.xz, grds)));\n    vec4 w3 = vec4(sdBox(p+vec3(0,0,-1),bs.zyx), MAT_WHITE);\n    vec4 w4 = vec4(sdBox(p+vec3(0,-1,0),bs.yxz), mix(MAT_WHITE, v?MAT_BLUE:bw?MAT_WHITE:MAT_BLACK, txGrid(p.xz, grds)));\n    res = v4OpUnion(w0,res);\n    res = v4OpUnion(w1,res);\n    res = v4OpUnion(w2,res);\n    res = v4OpUnion(w3,res);\n    res = v4OpUnion(w4,res);\n    \n    vec3 q = p;\n    q += vec3(.3,.75*.5-.15,-.5);\n    R(q.xz,PI*.125);\n    \n    vec4 o0 = vec4(sdBox(q,vec2(.3+abs(cos(q.y*40.))*.0,.75).xyx), MAT_WHITE);\n    vec4 o1 = vec4(length(p-vec3(.35,-.7+.07,-.2))-.35, MAT_YELLOW); //\n    vec4 o2 = vec4(length(p-vec3(sin(iTime*.5)*.8,.3+cos(iTime)*.3,-.3))-.15, MAT_WHITE);\n    res = v4OpUnion(o0,res);\n    res = v4OpUnion(o1,res);\n    res = v4OpUnion(o2,res);\n    \n\treturn res;\n}\n\nvec4 intersect(){\n\tfloat d = 1.;\n\tvec3  m = MAT_VOID;\n\tfor (int i = ZERO; i < ITERATION; i++){\n\t\tvec4 res = sdScene(ray.origin + d * ray.direction);\n\t\tm = res.yzw;\n\t\tif (abs(res.x) < MIN_DIST || res.x >= MAX_DIST) break;\n\t\td += res.x;\n\t\tif (d >= MAX_DIST) break;\n\t}\n\treturn vec4(d,m);\n}\n\nvec3 normal(vec3 p){\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*sdScene(p+0.0005*e).x;\n    }\n    return normalize(n);\n}\n\nfloat shadow(vec3 o, vec3 n){\n    o+=n*.01;\n\tfloat t=.01;\n\tfor( int i=ZERO; i < 70; i++){\n\t\tfloat res = sdScene(o + lit0.direction*t).x;\n\t\tt += res;\n\t\tif(res<0.01)return 0.;\n        if(t>15.) break;\n\t}\n\treturn 1.;\n}\n\nfloat shadowLow(vec3 o, vec3 n){\n    o+=n*.01;\n\tfloat t=.01;\n\tfor( int i=ZERO; i < 40; i++){\n\t\tfloat res = sdScene(o + lit0.direction*t).x;\n\t\tt += res;\n\t\tif(res<0.01)return 0.;\n        if(t>10.) break;\n\t}\n\treturn 1.;\n}\n\nfloat aoSeed = 0.;\n\nvec2 c = vec2(0);\nvec3 amb = vec3(0);\nvec4 fakeGI(vec3 p, vec3 n, float radius) {\n  float ao = 0.;\n  float tbnc = 0.;\n  vec3 bleed = vec3(0);\n  bleed = renDat.albedo;\n  float mskDirect=0., litIndirect=1., roughness = 1.;\n  for(float i = 0.; i <= MAX_SAMP; i++) {\n    vec2 rnd = hash21(i + aoSeed++ + length(c));\n    \n    float scale = (i + 1.) / (MAX_SAMP+1.);\n    scale = mix(0., 1., pow(scale, .5));\n\n    rnd.x = (rnd.x * 2. - 1.) * PI*.05*roughness;\n    rnd.y = (rnd.y * 2. - 1.) * PI*roughness;\n    vec2 rnd1 = hash21(i + aoSeed++ + length(c))*roughness;\n    vec2 rnd2 = hash21(i + aoSeed++ + length(c))*roughness;\n    vec3 rd = normalize(n + vec3(rnd1.xy, rnd2.x));\n    rd.xz *= mat2(cos(rnd.x), sin(rnd.x), -sin(rnd.x), cos(rnd.x));\n    rd.xy *= mat2(cos(rnd.y), sin(rnd.y), -sin(rnd.y), cos(rnd.y));\n    rd *= sign(dot(rd, n));\n    //sign(-dot(n, r.d))\n    rd = normalize(n + rd);\n    \n    float raylen = radius * scale;\n    vec3 rndp = p + rd * raylen;\n    vec4 res = sdScene(rndp);\n    vec3 vp = p+rd*res.x;\n    \n    // ao\n    float rndao = distance(p,vp) / raylen;\n    ao += rndao;\n    \n    vec3 vn = n;\n    // color bleeding and bounce light\n    vec3 tot = res.yzw;\n    vec3 mask = vec3(1);\n    for(float j=float(ZERO);j<BOUNCE;j++){\n        \n        vec2 rnd3 = hash21(j + aoSeed++ + length(c));\n        //float scale = (i+j + 1.) / (MAX_SAMP+1.);\n        //scale = mix(MIN_DIST, 1., pow(scale, 1.));\n\n        rnd3.x = (rnd3.x * 2. - 1.) * PI*.025*roughness;\n        rnd3.y = (rnd3.y * 2. - 1.) * PI*roughness;\n        vec2 rnd4 = hash21(i+j + aoSeed++ + length(c))*roughness;\n        vec2 rnd5 = hash21(i+j + aoSeed++ + length(c))*roughness;\n        vec3 rd = normalize(vn + vec3(rnd4.xy, rnd5.x));\n        rd.xz *= mat2(cos(rnd3.x), sin(rnd3.x), -sin(rnd3.x), cos(rnd3.x));\n        rd.xy *= mat2(cos(rnd3.y), sin(rnd3.y), -sin(rnd3.y), cos(rnd3.y));\n        rd *= sign(dot(rd, vn));\n        rd = normalize(vn + rd);\n        \n        vp = vp+rd*res.x;\n        res = sdScene(vp);\n        vn = normal(vp);\n        float direct = sat(dot(vn, lit0.direction));\n        float shadow = shadowLow(vp, vn);\n        float mskDirect = direct*shadow;\n        \n        if(res.x>radius){tot+=AMB_STRENGTH*AMB_COL+mskDirect*lit0.color*LIGHT_STRENGTH*mask;break;}\n        tot+=res.yzw*mskDirect*lit0.color*LIGHT_STRENGTH*mask;\n        mask*=res.yzw;\n        // https://www.shadertoy.com/view/4sfGDB\n        // acc += mask * obj.e * E + mask * obj.c * e;\n\t\t// mask *= obj.c;\n        \n    }\n    bleed += tot/(BOUNCE+1.);\n  }\n    \n  //return vec4(bleed/(MAX_SAMP+1.), ao / float((MAX_SAMP+1.)));\n  return vec4(bleed/(MAX_SAMP+1.), ao / float((MAX_SAMP+1.)));\n}\n\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvoid render(){\n\tvec4 res = intersect();\n\tvec3 p = ray.origin + res.x * ray.direction;\n    #ifdef PIXEL_NOISE\n    aoSeed=fract(iTime)+10.;\n    \n    #endif\n    if (res.x>=MAX_DIST){\n        amb = mix(AMB_COL, AMB_COL2, smoothstep(-.75, .75, ray.direction.y));\n\t\trenDat.position = vec3(0);\n\t\trenDat.albedo = amb;\n\t\trenDat.normal = vec3(0);\n\t\trenDat.diffuse = 0.;\n\t\trenDat.specular = 0.;\n\t\trenDat.shadow = 0.;\n\t\trenDat.ao = 0.;\n\t\trenDat.depth = 1.;\n\t\trenDat.result = amb;\n\t}\n\telse{\n\t\trenDat.albedo = res.yzw;\n\t\trenDat.normal = normal(p);\n        \n        renDat.diffuse = sat(dot(renDat.normal, lit0.direction));\n\t\trenDat.shadow = shadow(p, renDat.normal);\n        \n        vec4 ind0 = fakeGI(p, renDat.normal, 2.);\n        renDat.ao = ind0.w;\n        renDat.bleed = ind0.rgb;\n        renDat.result = vec3(0);\n\t\t//renDat.result = mix(vec3(0), lit0.color*LIGHT_STRENGTH, renDat.diffuse*renDat.shadow);\n        \n        amb = mix(AMB_COL, AMB_COL2, smoothstep(-.75, .75, renDat.normal.y));\n\t\t\n\t\t\n        renDat.result = max(mix(vec3(0), lit0.color*LIGHT_STRENGTH, renDat.diffuse*renDat.shadow), renDat.bleed);\n        //renDat.result = renDat.bleed;\n        //renDat.result += mix(vec3(0), amb, AMB_STRENGTH*renDat.ao);\n        renDat.result *= renDat.albedo;\n\t}\n}\n\nvoid light(){\n\tlit0.direction = normalize(vec3(0, .75, -1.5));\n    \n    R(lit0.direction.xz, cos(iTime*.25)*PI*.25);\n\t\n    lit0.color = vec3(1.000,0.957,0.722);\n\tlit0.shadowStart = 0.05;\n\tlit0.shadowEnd = 30.0;\n\tlit0.shadowSoft = 50.0;\n}\n\nvoid camera(vec2 uv)\n{\n    const float cL = 8.;\n    const vec3 forcus = vec3(0,0,0);\n    const float fov = .25;\n\n    vec3 up = vec3(0,1,0);\n    vec3 pos = vec3(0,0,-8);\n    if(iMouse.z>.5){\n        pos.x += sin((iMouse.x/iResolution.x-.5)*TAU)*cL;\n        pos.y += sin((iMouse.y/iResolution.y-.5)*TAU)*cL;\n    }\n    \n    vec3 dir = normalize(forcus-pos);\n    vec3 target = pos-dir;\n    vec3 cw = normalize(target - pos);\n    vec3 cu = normalize(cross(cw, up));\n    vec3 cv = normalize(cross(cu, cw));\n\n    mat3 camMat = mat3(cu, cv, cw);\n    ray.direction = normalize(camMat * normalize(vec3(sin(fov) * uv.x, sin(fov) * uv.y, -cos(fov))));\n\n    ray.origin = pos;\n}\n\n//https://www.shadertoy.com/view/XlKSDR\nvec3 ACESFilm(vec3 x) {\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\n#ifdef AA\nvoid mainImage0(out vec4 fragColor, in vec2 fragCoord) {\n#else\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n#endif\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 offset = u2s(hash22(fragCoord+iTime))/iResolution.xy*.5; // AA: Offset coord for each frame.\n    //uv += offset; //\n#ifdef PIXEL_NOISE\n    c = fragCoord*20.;\n#endif\n\n#ifdef DEBUG_VIEW\n    uv*=3.;\n    vec2 iuv = floor(uv);\n    uv.x=mod(uv.x,1.);\n    uv*=.333;\n    uv.x+=.4;\n#endif\n\n\tuv = (uv*2.-1.)*iResolution.y/iResolution.x;\n\tuv.x *= iResolution.x / iResolution.y;\n    \n\tlight();\n\tcamera(uv);\n\trender();\n    fragColor = vec4(renDat.result, 1.);\n    \n#ifdef DEBUG_VIEW\n    if(iuv.x==0.)d3V(pow(renDat.albedo*renDat.diffuse*renDat.shadow, vec3(2.2))); //L: Direct\n    if(iuv.x==1.)d3V(renDat.bleed);                                               //C: Bleeded color\n    if(iuv.x==2.)d3V(pow(renDat.result, vec3(2.2)));                              //R: Direct + Bleeded \n#endif\n    fragColor.rgb = ACESFilm(fragColor.rgb);\n    fragColor.rgb = pow(fragColor.rgb, vec3(.4545));\n    drawDebug(fragColor);\n}\n\n#ifdef AA\n// === easy adaptive sampling. === https://shadertoyunofficial.wordpress.com/2021/03/09/advanced-tricks/\n//                           more: https://www.shadertoy.com/results?query=easy+adaptive+sampling\nvoid mainImage(out vec4 O, vec2 U) {\n  mainImage0(O, U);\n  if(fwidth(length(O)) > .01) {  // difference threshold between neighbor pixels\n    vec4 o;\n    for(int k = 0; k < 9; k += k == 3 ? 2 : 1) {\n      mainImage0(o, U + vec2(k % 3 - 1, k / 3 - 1) / 3.);\n      O += o;\n    }\n    O /= 9.;\n    // O.r++;                        // uncomment to see where the oversampling occurs\n  }\n}\n#endif", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// General\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define iFrameRate 24.0\n#define PI acos(-1.)\n#define HALF_PI (PI*.5)\n#define TAU (PI*.5)\n#define ZERO min(0,iFrame)\n\n#define sat(x) clamp(x, 0.0, 1.0)\n#define sms(min, max, x) smoothstep(min, max, x)\n#define s2u(x) (x*.5+.5)\n#define u2s(x) ((x*2.)-1.)\n#define linearstep(edge0, edge1, x) min(max((x - edge0) / (edge1 - edge0), 0.0), 1.0)\n\n// Visual Debugging Util by iY0Yi\n// dbg_1F() / dbg_2V() / dbg_3V() / drawDebug()\n// https://www.shadertoy.com/view/ttVcWD\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec4 dbC=vec4(0);\nvoid d1F(float v){dbC=vec4(v,v,v,1);}\nvoid d2V(vec2 v) {dbC=vec4(v,0,1);}\nvoid d3V(vec3 v) {dbC=vec4(v,1);}\nvoid drawDebug(inout vec4 frC)\n{if(dbC.w>0.)frC=pow(sat(dbC),vec4(.4545));}\n\n// Cheap Rotation by las:\n// http://www.pouet.net/topic.php?which=7931&page=1\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y,-p.x)\nvec3 rot(vec3 p,vec3 r){\n\tR(p.xz, r.y);\n\tR(p.yx, r.z);\n\tR(p.zy, r.x);\n\treturn p;\n}\n\n// \"hash11()\" - \"hash44()\"\n// \"Hash without Sine\" by Dave_Hoskins:\n// https://www.shadertoy.com/view/4djSRW\n//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\nvec2 hash21(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n  p3 += dot(p3, p3.yzx + 33.33);\n  return fract((p3.xx + p3.yz) * p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2fWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1030, 1030, 1061, 1061, 1177], [1179, 1179, 1217, 1217, 1236], [1238, 1238, 1274, 1274, 1297], [1299, 1299, 1361, 1361, 1420], [1422, 1422, 1460, 1460, 1539], [1541, 1541, 1575, 1575, 1598], [1600, 1600, 1634, 1634, 1760], [1762, 1762, 1783, 1783, 3120], [3122, 3122, 3139, 3139, 3408], [3410, 3410, 3430, 3430, 3630], [3632, 3632, 3661, 3661, 3847], [3849, 3849, 3881, 3881, 4067], [4127, 4127, 4170, 4170, 6744], [6746, 6818, 6832, 6832, 8076], [8078, 8078, 8091, 8091, 8315], [8317, 8317, 8339, 8339, 8981], [8983, 9023, 9046, 9046, 9190]], "test": "untested"}
{"id": "st2fR3", "name": "Deformed bubbles", "author": "VPas", "description": "Simple shader with raymatch", "tags": ["bubblesraymatch3d"], "likes": 11, "viewed": 351, "published": 3, "date": "1652541433", "time_retrieved": "2024-07-30T16:48:54.285323", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t=iTime;\n    vec2 r=iResolution.xy;\n    vec3 c,p,n,\n    ro=vec3(0.,0.3,t*.3)+5.*(vec3(iMouse.xy/r,0.)*2.-1.),\n    rd=normalize(vec3((fragCoord.xy*2.-r)/min(r.x,r.y),1.)),\n    l1=ro+vec3(3.+sin(t)*5.,2.+sin(5.-t*.4),2.+cos(t*.6)),\n    l2=ro-vec3(2.-cos(t+2.)*3.,1.-sin(t*.8)*2.,1.),\n    l3=ro-vec3(-3.,1.+cos(t+7.)*2.,2.+sin(-t*.38+.9)*4.);\n    float d=.5,e=1.,i;\n    for(;i++<99.&&e>.005;){\n        p=ro+rd*d;\n        p.z+=p.x*.1;\n        p.x+=sin(p.z+p.y*.4);\n        p.y+=cos(p.z+p.x*.3);\n        n=l1-p;c+=vec3(.5,1.,2.)/(1.+dot(n,n));\n        n=l2-p;c+=vec3(1.5,.5,.5)/(1.+dot(n,n));\n        n=l3-p;c+=vec3(.5,1.,.5)/(1.+dot(n,n));\n        p=mod(p,2.)-1.;\n        e=(length(p)-.35)*.3;\n        d+=e;\n    }\n    fragColor = vec4(c*.04,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2fR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 811]], "test": "untested"}
{"id": "st2fRK", "name": "Custom Domain Coloring", "author": "Fraktoler", "description": "Complex functions can be visualized using domain coloring.", "tags": ["function", "complex", "domaincoloring"], "likes": 1, "viewed": 253, "published": 3, "date": "1652537756", "time_retrieved": "2024-07-30T16:48:55.247749", "image_code": "#define ITERS 1\nfloat zoom = 5.;\nvec2 center = vec2(0.);\n\nvec3 HSLtoRGB(in vec3 c) { //From @tpfto's comment\n    vec3 rgb = clamp(abs(mod(c.x / 60. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.);\n    float v = c.z + c.y * min(c.z, 1. - c.z);\n    float s = v == 0. ? 0. : 2. * (1. - c.z / v);;\n\treturn v * mix(vec3(1.), rgb, s);\n}\n\nvec2 pixelToComplex(in float zoom, in vec2 center, in vec2 pixel) {\n    return (2. * pixel - iResolution.xy) / iResolution.x * zoom + center;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 c = pixelToComplex(zoom, center, fragCoord);\n    vec2 z = c;\n    int iter = 0;\n    while (iter < ITERS) {\n\n        z = power(z, iTime); //Function\n\n        iter++;\n    }\n    float h, l;\n    if (isnan(arg(z))) {\n        h = 0.;\n    } else {\n        h = arg(z);\n        if (h < 0.) {\n            h += pi + pi;\n        }\n        h *= 180. / pi;\n    }\n    l = length(z);\n    l = isnan(l) ? 1. : 1. - 1. / (sqrt(l) + 1.);\n    //l = 0.5;\n    vec3 col = HSLtoRGB(vec3(h, 1., l));\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "/*\nConstants\n\n one = vec2(1., 0.)\n i = vec2(0., 1.\n pi = 3.14159265358979\n e = 2.718281828459045\n\nComplex functions\n\n mag2(z) = |z|^2 = dot(z, z)\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n normalizesqr(z) = normalize(z^2)\n cube(z) = z^3\n power5(z) = z^5\n power7(z) = z^7\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n powerfv(x, z) = x^z (Complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n cbrt(z) = z^(1/3) (Principal cube root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n gamma(z) (Gamma function)\n productlog(k, z) (Lambert W function (kth branch))\n digamma(z) (Digamma function)\n trigamma(z) (Trigamma function)\n*/\n#define one vec2(1., 0.)\n#define two vec2(2., 0.)\n#define i vec2(0., 1.)\n#define pi 3.14159265358979\n#define e 2.718281828459045\n//const float[] B = float[](1., .5, 1./6., 0., -1./30., 0., 1./42., 0., -1./30., 0., 5./66., 0., -691./2730., 0., 7./6.);\n\nfloat mag2(in vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(in vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(in vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(in vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 rabs(in vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(in vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(in float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(in vec2 z, in vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(in vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(in vec2 z, in vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / dot(w, w);\n}\n\nvec2 recip(in vec2 z) {\n    return conj(z) / dot(z, z);\n}\n\nvec2 sqr(in vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 normalizesqr(in vec2 z) {\n    return one - conj(z.yx) * (z.y + z.y) / dot(z, z);\n}\n\nvec2 cube(in vec2 z) {\n    vec2 z2 = z * z;\n    return z * (vec2(z2.x - z2.y) + vec2(-2.0, 2.0) * z2.yx);\n}\n\nvec2 power5(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power7(in vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z6 = z2 * z2 * z2;\n    return conj(z) * (z6 - 7. * z6.yx - z2.x * z2.y * (21. * z2 - 35. * z2.yx));\n}\n\nvec2 power(in vec2 z, in float p) {\n    return pow(dot(z, z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(in vec2 z, in vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(dot(z, z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 powerfv(in float x, in vec2 z) {\n    float lnr = log(x);\n    return exp(z.x * lnr) * cis(z.y * lnr);\n}\n\nvec2 sqrtp(in vec2 z) {\n    float r = length(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 cbrt(in vec2 z) {\n    return power(z, .333333333333);\n}\n\nvec2 powexp(in vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(in vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(in vec2 z, in vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(in vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(in vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) + one) - i;\n}\n\nvec2 tangent(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(in vec2 z) {\n    return div(vec2(0.0, 2.0), powexp(mulI(z + z)) - one) + i;\n}\n\nvec2 cot(in vec2 z) {\n    if (z.y < -44.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(in vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(in vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(in vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(in vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(in vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 2.0), z + i) - one));\n}\n\nvec2 arccot(in vec2 z) {\n    return -0.5 * mulI(ln(div(vec2(0.0, 2.0), z - i) + one));\n}\n\nvec2 arcsec(in vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(in vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(in vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(in vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(in vec2 z) {\n    return one - div(two, powexp(z + z) + one);\n}\n\nvec2 tanhyp(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(in vec2 z) {\n    return one + div(two, powexp(z + z) - one);\n}\n\nvec2 coth(in vec2 z) {\n    if (z.x > 44.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(in vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(in vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(in vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(in vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(in vec2 z) {\n    return .5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(in vec2 z) {\n    return .5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(in vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(in vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(in vec2 z, in vec2 a, in vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(in vec2 z, in vec2 a, in vec2 b, in vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(in vec2 z, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 gamma(in vec2 z) {\n    //https://www.shadertoy.com/view/WtlGDN\n    const float[6] p = float[] (2.506628275635, 225.525584619175, -268.295973841305, 80.9030806934622, -5.007578639705, 0.0114684895435);\n    vec2 zz = z.x > 1. ? z : one - z;\n    vec2 m = vec2(p[0], 0.);\n    for (int k = 1; k < p.length(); k++) {\n        m = m + p[k] * recip(zz + vec2(k, 0.));\n    }\n    vec2 zh = zz + vec2(5.65, 0.0);\n    vec2 w = powexp(ln(m) + mul(zz + vec2(.5, 0.), ln(zh)) - ln(zz) - zh);\n    return z.x > 1. ? w : pi * recip(mul(w, sine(pi * z)));\n}\n\nvec2 productlog(in int k, in vec2 z) {\n    vec2 m, w, mw, w2;\n    if (k == 0) {\n        //https://www.shadertoy.com/view/3lsGD4\n        m = sqrtp(2. * e * z + vec2(2., 0.));\n        w = 2. * ln(one + .8842 * m);\n        w = div(w - ln(one + .9294 * ln(one + .5106 * m)) - vec2(1.213, 0.), one + recip(w + vec2(4.69483568, 0.)));\n    } else {\n        w = ln(z) + float(2 * k) * pi * i;\n        w -= ln(w);\n    }\n    for (int k = 0; k < 8; k++) {\n        m = powexp(w);\n        mw = mul(m, w);\n        w2 = w + two;\n        w = div(mul(mw, sqr(w)) + mul(sqr(w2) - two, z), mul(mw + z, w2) + (m + m));\n    }\n    return w;\n}\n\nvec2 digamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(w);\n        w += one;\n    }\n    vec2 zinv = recip(w);\n    w = ln(w) - 0.5 * zinv;\n    zinv = sqr(zinv);\n    w -= zinv / 12. - sqr(zinv) / 120. + cube(zinv) / 252. + a;\n    return (z.x < .5 ? pi * cot(pi * zz) + w : w);\n}\n\nvec2 trigamma(in vec2 z) {\n    vec2 zz = z.x < .5 ? one - z : z, a = vec2(0.), w = zz;\n    while (w.x < 8.) {\n        a += recip(sqr(w));\n        w += one;\n    }\n    w = recip(w) + 0.5 * recip(sqr(w)) + recip(cube(w)) / 6. - recip(power5(w)) / 30. + recip(power7(w)) / 42. + a;\n    return z.x < .5 ? sqr(pi * recip(sine(pi * zz))) - w : w;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2fRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 84, 108, 326], [328, 328, 395, 395, 471], [473, 473, 530, 530, 1045]], "test": "untested"}
{"id": "NlK3Rc", "name": "ShadowDemoparty2021", "author": "z0rg", "description": "Thought I had published it, but I did not", "tags": ["zef"], "likes": 5, "viewed": 231, "published": 3, "date": "1652511876", "time_retrieved": "2024-07-30T16:48:56.078529", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\n\nmat2 r2d(float a) { float c = cos(a); float s = sin(a); return mat2(c, -s, s, c); }\n\nvec3 getCam(vec3 rd, vec2 uv)\n{\n  float fov = 1.;\n  vec3 r = normalize(cross(rd, vec3(0.,1.,0.)));\n  vec3 u = normalize(cross(rd, r));\n  return normalize(rd+(r*uv.x+u*uv.y)*fov);\n}\n\nvec2 _min(vec2 a, vec2 b)\n{\n  if (a.x < b.x)\n    return a;\n  return b;\n}\n\nfloat _cube(vec3 p, vec3 s)\n{\n  vec3 l = abs(p)-s;\n    l.xz *= r2d(iTime*.1);\n  l+= vec3(.5,0.1,0.);\n    l.xy *= r2d(iTime*.1+sin(p.x));\n  l = abs(l)-.5;\n\n\n  return max(l.x, max(l.y, l.z));\n}\n\nvec3 accCol;\n\nvec2 map(vec3 p)\n{\n  p.xy *= r2d(iTime*.25);\n  p.xz *= r2d(iTime*.25);\n  float acc = 1000.;\n  \n  for (int i = 0; i < 16; ++i)\n  {\n    float fi = float(i)*.25;\n    vec3 pc = p;\n    float r = 5.;\n    pc.x += sin(iTime*.25+fi*3.3)*r;\n    pc.y += cos(iTime*.5+fi*2.)*r;\n    pc.z += abs(sin(iTime*.1+fi*2.));\n    pc.xy *= r2d(iTime+fi);\n    pc.xz *= r2d(iTime*.5+fi*2.);\n    acc = min(acc, _cube(pc, fi+vec3(5.5)*sin(fi+iTime)));\n  }  \n  vec2 main = vec2(_cube(p, vec3(.5)),0.);\n  return _min(main, vec2(acc, 1.));\n}\n\nvec3 getNorm(float d, vec3 p)\n{\n  //return normalize(cross(dFdx(p), dFdy(p)));\n  vec2 e = vec2(0.01,0.);\n  return normalize(vec3(d)-vec3(map(p-e.xyy).x, map(p-e.yxy).x, map(p-e.yyx).x));\n}\n\nvec3 trace(vec3 ro, vec3 rd, int steps)\n{\n  accCol = vec3(0.);\n  vec3 p = ro;\n  for (int i = 0; i < steps; ++i)\n  {\n    float fi = float(i);\n    vec2 res = map(p);\n    if (res.x < 0.01)\n    {\n        return vec3(res.x, distance(p, ro), res.y);\n    }\n   \n    vec3 rgb = vec3(1.);\n     if (res.y == 1.)\n       rgb = vec3(1.,.5,.25);\n      accCol += rgb*(rd+.5)*vec3(sin(fi)*.5+.5, cos(fi)*.5+.5,.5)*pow(1.-sat(res.x/0.75),2.)*.15;\n     \n    p += rd * res.x;\n  }\n  return vec3(-1.);\n}\n\nvec3 rdr(vec2 uv)\n{\n\n\n  vec3 ro = vec3(sin(iTime*.25),5.*sin(iTime),-15.*cos(iTime));\n  vec3 ta = vec3(0.,0.,0.);\n  vec3 rd = normalize(ta-ro);\n    vec3 col = pow(texture(iChannel0, uv*5.).x, 5.)*vec3(2.)+mix(vec3(.5,.5,.6)*.25, vec3(.95,.56,.34), (1.-sat(abs(uv.y*5.)))*sat(length(uv)));\n  rd = getCam(rd, uv);\n  vec3 res = trace(ro, rd, 32);\n  if (res.y > 0.)\n  {\n      vec3 p = ro + rd * res.y;\n      vec3 n  = getNorm(res.x, p);\n      col = n * .5 + .5;\n    if (res.z == 1.)\n    {\n      col = vec3(.25);\n      col += vec3(.75,0.2,.14)*pow(sat(-dot(rd, n)),5.);\n      if (res.z == 0.)\n        col = vec3(0.);\n    }\n  }\n  col += accCol.zxy;\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  vec2 dir = normalize(vec2(1.));\n  float strength = .01;\n  vec3 col = vec3(0.);\n  col.r = rdr(uv+strength*dir).x;\n  col.g = rdr(uv).y;\n  col.b = rdr(uv-strength*dir).z;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy-vec2(.5)*iResolution.xy)/iResolution.xx;\n\n  /*\n\tfloat f = texture( texFFT, d ).r * 100;\n\tm.x += sin( fGlobalTime ) * 0.1;\n\tm.y += fGlobalTime * 0.25;\n*/\n    vec3 col = vec3(0.);\n    col = rdr2(uv)*.5;\n  \n  float stp = 0.025;\n  uv = floor(uv/stp)*stp;\n  col = mix(rdr(uv), col, 1.-sat(length(uv*2.))*sat(abs(uv.y*3.)));\n  col += (1.-sat(length(uv*2.)))*vec3(.1,.2,.3)*5.*(sat((abs(sin((uv.x+uv.y)*5.+iTime))-.95)*400.));\n\t\tfragColor = vec4(col, 1.);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlK3Rc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[430, 430, 449, 449, 513], [515, 515, 546, 546, 695], [697, 697, 724, 724, 769], [771, 771, 800, 800, 962], [978, 978, 996, 996, 1489], [1491, 1491, 1522, 1569, 1679], [1681, 1681, 1722, 1722, 2162], [2164, 2164, 2183, 2183, 2822], [2824, 2824, 2844, 2844, 3030], [3032, 3032, 3089, 3089, 3565]], "test": "untested"}
{"id": "7lBfRc", "name": "Audio Visualiser Test 98765", "author": "SnoopethDuckDuck", "description": "Strobe warning, it flashes a little bit\n\nFirst time trying this, sometimes the audio doesnt load :|", "tags": ["e"], "likes": 11, "viewed": 361, "published": 3, "date": "1652500364", "time_retrieved": "2024-07-30T16:48:56.924267", "image_code": "#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.xy;\n    \n    float res = iResolution.x/ iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    float drop = clamp(iTime / 11., 0., 1.); step(iTime, 5.); // changed music so doesnt work as well now\n    drop = smoothstep(0., 1., drop);\n    \n    float sc = 20. * tanh(iTime / 5.) + 30. * tanh(iTime / 30.); //idk\n    float ix = floor(sc * uv.x) / sc;\n    float fx = fract(sc * uv.x) - 0.5;\n      \n    float r = texture( iChannel0, vec2(ix, uv.y * 0.)).r;\n    float t = texture(iChannel0, vec2(0.25,0)).r; // doesnt change very smoothly\n    \n    fx += (0.1 + 0.1 * t) * cos(sc * uv.y * r + 0.12 * r * iTime);\n    \n    float d = sdBox(vec2(fx, uv.y), vec2(0.4 - 0.3 * r, r));\n    d = min(d, length(vec2(fx, (uv.y-r) *sc / res)) - 0.4 + 0.3 * r);\n   \n    float k = 80. * r / iResolution.y;\n    float s = smoothstep(-k, k, -d); \n    \n    vec3 e = vec3(0.5);   \n    \n    col = s * pal(0.5 * t + r - 0.5 * exp(-2.5 * uv.y) + 1.5, e, e, e, drop * (0.5 * t) * vec3(0,1,2)/3.);\n   // col += 0.01 * (1.-s) * pal(80. * exp(-2.5 * uv.y) + iTime, e, e, e, drop * (0.5 * t) * vec3(0,1,2)/3.);\n    vec3 col2 = (1.-s) * pal(0.5 * t + 0.5 * exp(-2.5 * uv.y) + 1., e, e, e, drop * 0.2 * vec3(0,1,2)/3.);\n    //col = mix(col, col2, s);\n    col += (0.5 + 0.5 * t + 0.25 * uv.x) * col2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28973, "src": "https://soundcloud.com/tverdiyhleb/gogo-penguin-hopopono", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBfRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 86, 86, 129], [131, 131, 168, 168, 248], [250, 250, 307, 307, 1663]], "test": "untested"}
{"id": "NtBBRc", "name": "Flag of Brasil", "author": "kroltan", "description": "I started off strong, with all the measurements... Then I realized the font is unspecified and the star positions are only available on a document that was probably digitized via fax, since the DPI is lamentable. The result is \"reasonably accurate\".", "tags": ["sdf", "flag", "brazil", "brasil"], "likes": 6, "viewed": 254, "published": 3, "date": "1652471022", "time_retrieved": "2024-07-30T16:48:57.677254", "image_code": "// Palette\nconst vec3 BACKGROUND_COLOR = vec3(0.0000, 0.6117, 0.2157);\nconst vec3 RHOMBUS_COLOR =    vec3(0.9961, 0.8745, 0.0000);\nconst vec3 CIRCLE_COLOR =     vec3(0.0000, 0.1529, 0.4627);\nconst vec3 DETAIL_COLOR =     vec3(1.0000, 1.0000, 1.0000);\nconst vec3 TEXT_COLOR =       vec3(0.0000, 0.6078, 0.2274);\n\n// Definitions\nconst float BASIS_HALF_WIDTH = 10.0;\nconst float BASIS_HALF_HEIGHT = 7.0;\n\nconst float RHOMBUS_INSET = 1.7;\n\nconst float CIRCLE_RADIUS = 3.5;\n\nconst vec2 STRIPE_CENTER_OFFSET = vec2(-2.0, -BASIS_HALF_HEIGHT);\nconst float STRIPE_INNER_RADIUS = 8.0;\nconst float STRIPE_OUTER_RADIUS = 8.5;\n\nconst int TEXT_SMALL_INDEX = 6;\nconst int TEXT_LENGTH = 17;\nconst int[TEXT_LENGTH] TEXT_CHARS = int[TEXT_LENGTH](\n    79, 82, 68, 69, 77,\n    32,  69,  32,\n    80, 82, 79, 71, 82, 69, 83, 83, 79\n);\n\nconst int STAR_SIZES_LENGTH = 5;\nconst float[STAR_SIZES_LENGTH] STAR_SIZES = float[STAR_SIZES_LENGTH](\n    1.0 / 3.0,\n    1.0 / 4.0,\n    1.0 / 5.0,\n    1.0 / 7.0,\n    1.0 / 10.0\n);\n\nconst int STARS_LENGTH = 27;\nconst vec3[STARS_LENGTH] STARS = vec3[STARS_LENGTH](\n    // X and Y from center, Z is size\n    // Extracted from https://upload.wikimedia.org/wikipedia/commons/f/ff/Flag_of_Brazil_%28sphere%29.svg\n    // Using the snippet\n    /*\n        [...document.querySelectorAll('use[id*=_]')]\n            .map(x => {\n                const xy = x.getAttribute(\"transform\")\n                    .match(/\\((.*?)\\)/)[1]\n                    .split(\",\")\n                    .map(x => parseInt(x, 10) * 0.00548245614035087719298245614035);\n                const size = parseInt(x.getAttribute(\"xlink:href\").at(-1), 10);\n                return [...xy, size]\n            })\n            .map(([x, y, size]) => `vec3(${y}, ${x}, ${size.toFixed(1)})`)\n            .join(\",\\n\")\n     */\n    vec3(-3.289473684210526, -0.7236842105263157, 1.0),\n    vec3(-2.933114035087719, 0.9703947368421052, 1.0),\n    vec3(-3.426535087719298, 1.332236842105263, 2.0),\n    vec3(-2.538377192982456, 0.7236842105263157, 4.0),\n    vec3(-2.094298245614035, 1.3706140350877192, 2.0),\n    vec3(-2.2149122807017543, 1.7708333333333333, 3.0),\n    vec3(1.25, -1.25, 1.0),\n    vec3(2.8234649122807016, 1.4144736842105263, 1.0),\n    vec3(3.382675438596491, 1.4528508771929824, 3.0),\n    vec3(2.9879385964912277, 1.7708333333333333, 2.0),\n    vec3(2.017543859649123, 2.615131578947368, 2.0),\n    vec3(2.012061403508772, 3.020833333333333, 3.0),\n    vec3(2.4177631578947367, 2.2971491228070176, 3.0),\n    vec3(2.7412280701754383, 2.094298245614035, 2.0),\n    vec3(2.00109649122807, 2.2203947368421053, 3.0),\n    vec3(-1.5350877192982455, 0.1644736842105263, 2.0),\n    vec3(1.0964912280701753, -0.20285087719298245, 3.0),\n    vec3(0, 1.8092105263157894, 1.0),\n    vec3(0.46600877192982454, 1.0087719298245614, 2.0),\n    vec3(0, 0.6469298245614035, 2.0),\n    vec3(-0.4057017543859649, 1.0087719298245614, 3.0),\n    vec3(-0.20285087719298245, 1.2883771929824561, 4.0),\n    vec3(1.2061403508771928, 2.713815789473684, 2.0),\n    vec3(1.5515350877192982, 2.357456140350877, 3.0),\n    vec3(0.888157894736842, 2.258771929824561, 3.0),\n    vec3(-1.6173245614035088, 2.138157894736842, 1.0),\n    vec3(0, 3.1524122807017543, 5.0)\n);\n\n\n// *cracks knuckles*\n\n\nvoid paint(inout vec3 canvas, in vec3 color, in float shape, in float width) {\n    canvas = mix(canvas, color, smoothstep(width, 0.0, shape));\n}\n\n\nvec2 polarUv(in vec2 uv, in vec2 center) {\n    vec2 local = uv - center;\n    float angle = atan(local.y, local.x);\n    float radius = length(local);\n    \n    return vec2(angle, radius);\n}\n\n\nfloat textTexture(in vec2 uv, in int index) {\n    if (index < 0 || index >= TEXT_LENGTH) return 9999.0;\n    \n    if (index == TEXT_SMALL_INDEX) uv *= 1.2;\n    \n    return char(iChannel0, uv, TEXT_CHARS[index]).w;\n}\n\n\nvec3 flag(in vec2 uv) {\n    float rhombus = sdRhombus(uv, vec2(BASIS_HALF_WIDTH - RHOMBUS_INSET, BASIS_HALF_HEIGHT - RHOMBUS_INSET));\n    \n    float circle = sdCircle(uv, CIRCLE_RADIUS);\n    \n    // I don't like the magic numbers here, but my brain is too smooth to make this exact\n    vec2 stripeUv = polarUv(uv, STRIPE_CENTER_OFFSET)\n        * vec2(-float(TEXT_LENGTH) * 1.3, 1.0)\n        - vec2(float(-TEXT_LENGTH) * 2.125, STRIPE_INNER_RADIUS);\n    \n    float stripeThickness = (STRIPE_OUTER_RADIUS - STRIPE_INNER_RADIUS) / 2.0;\n    float stripe = abs(stripeUv.y - stripeThickness) - stripeThickness;\n    stripe = max(stripe, circle);\n    \n    float text = textTexture(\n        vec2(\n            (fract(stripeUv.x) - 0.5) / 2.0 + 0.5,\n            stripeUv.y / stripeThickness * 0.5\n        ),\n        int(ceil(stripeUv.x))\n    ) - 0.5;\n    \n    float stars = 9999.0;\n    for (int i = 0; i < STARS_LENGTH; ++i) {\n        vec3 star = STARS[i];\n        // Ugly vec and sizes magic numbers, too :/\n        stars = min(stars, sdStar(uv - star.xy * vec2(.9, -.9), STAR_SIZES[int(star.z) - 1] * 0.6, 5, 3.3));\n    }\n    \n    vec3 canvas = BACKGROUND_COLOR;\n    paint(canvas, RHOMBUS_COLOR, rhombus, fwidth(rhombus));\n    paint(canvas, CIRCLE_COLOR, circle, fwidth(circle));\n    paint(canvas, DETAIL_COLOR, stars, fwidth(stars));\n    paint(canvas, DETAIL_COLOR, stripe, fwidth(stripe));\n    paint(canvas, TEXT_COLOR, text, 0.02);\n    return canvas;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec2 flagUv = uv * BASIS_HALF_HEIGHT;\n    \n    fragColor = vec4(flag(flagUv), 1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n * SDFs from Inigo Quilez's website: https://iquilezles.org/articles/distfunctions2d/\n */\n\n// The MIT License\n// Copyright  2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en));\n\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\n\n/*\n * Font texture access pilfered from FabriceNeyret2's shader here, unknown license: https://www.shadertoy.com/view/ltcXzs\n */\n\nvec4 char(sampler2D tex, vec2 p, int C) {\n    if (p.x<0.|| p.x>1. || p.y<0.|| p.y>1.) return vec4(0,0,0,1e5);\n    return textureGrad( tex, p/16. + fract( vec2(C, 15-C/16) / 16. ) , \n                       dFdx(p/16.),dFdy(p/16.) );\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBBRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3216, 3216, 3294, 3294, 3360], [3363, 3363, 3405, 3405, 3550], [3553, 3553, 3598, 3598, 3767], [3770, 3770, 3793, 3793, 5216], [5219, 5219, 5274, 5274, 5430]], "test": "untested"}
{"id": "7l2fRV", "name": "Passthrough firmly", "author": "kostik1337", "description": "Yet another tunnel, yet another IFS", "tags": ["raymarching", "tunnel", "ifs"], "likes": 12, "viewed": 340, "published": 3, "date": "1652464684", "time_retrieved": "2024-07-30T16:48:58.724454", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define mr(a) (mat2(cos(a),sin(a),-sin(a),cos(a)))\n#define INF 1e10\n#define rep(p, s) mod(p,(s))-(s)/2.\n#define rep2(p, s) abs(rep(p, (s)*2.))-(s)/2.\n#define PI 3.14159265\n#define TAU (2.*3.14159265)\n#define time iTime\n\nfloat hash(float x) {return fract(sin(x)*43758.5453);}\nfloat hash(vec2 x) {return hash(dot(x, vec2(43.123, 32.12345)));}\nfloat hash(vec3 x) {return hash(dot(x, vec3(12.9898, 4.1414, 5.6135)));}\n\nvec3 ct(vec3 p) {\n  if (p.x > p.y) p.xy = p.yx;\n  if (p.y > p.z) p.yz = p.zy;\n  if (p.x > p.y) p.xy = p.yx;\n  return p;\n}\n\nfloat box2(vec3 p, vec3 s) {\n    p = abs(p)-s;\n    return length(max(p,0.0)) + min(max(p.x,max(p.y,p.z)),0.0);\n}\n\nvec2 repPolar(vec2 p, float n) {\n    p = vec2(length(p), atan(p.y, p.x));\n    p.y = rep(p.y+PI/n, 2.*PI/n);\n    return p.x * vec2(cos(p.y), sin(p.y));\n}\n\nfloat ngon(vec2 p, float w, float n) {\n    return repPolar(p, n).x-w;\n}\n\nint material = 0;\nvec2 lightParams = vec2(.7, 6.); // radius, z mod\nbool mapRings = true;\n\nvec2 lightOffset(float i) {\n    float h = hash(i)*TAU;\n    return .1*vec2(cos(h+1.31*time), sin(h+time));\n}\n\nfloat glow = 0.;\n\nfloat map(vec3 op) {\n    float m = INF;\n\n    vec3 p=op;\n    float mbs = 1.6, sides=6.;\n\n    material = 0;\n    p=op;\n    vec3 s=4.*vec3(2., 1., 2.);\n    float shift = time * .1;\n    shift = floor(shift) + smoothstep(0., .2, fract(shift));\n    vec3 p1 = op;\n    p.xy = abs(p.xy)-10.5;\n    for(int i=0; i<4;++i) {\n        if(i==0) m = INF;\n        vec3 p2 = p;\n        p.xy += 3.*vec2(.1, .13)*shift;\n        p = rep2(p, s);\n        p = ct(p);\n        \n        s /= 1.781;\n        s.xz *= mr(1.93);\n        s.xy *= mr(.46);\n        s = abs(s);\n        float wall = box2(p, s/3.);\n\n        wall = max(wall, -ngon(p1.xy, mbs, sides));\n        mbs *= .8;\n        m = min(m, wall);\n    }\n\n    if (mapRings) {\n        p = op;\n        float cz = floor(p.z / lightParams.y);\n        p.z = rep(p.z, lightParams.y);\n        p.xy += lightOffset(cz);\n        p.xy = vec2(length(p.xy)-lightParams.x, atan(p.y, p.x));\n        float rings = INF;\n        for(float i=0.; i<3.; ++i) {\n            float ring = length(vec2(p.x, p.z)) - (.02 + i*.02);\n            if (i>0.) {\n                float phase = mix(.5, .7, hash(i+cz+.13)) * (hash(i+cz)>.5?1.:-1.) * time;\n                p.y = rep2(p.y+phase, TAU/(i+2.));\n                ring = max(ring, p.y);\n            }\n            rings = min(rings, ring);\n        }\n        if (rings < m) {\n            m = rings;\n            material = 10;\n        }\n        glow += .0005 / (rings);\n    }\n\n    return m;\n}\n\nvec3 normal(vec3 p) {\n    vec2 E = vec2(.001, .0);\n    return normalize(\n        vec3(map(p+E.xyy), map(p+E.yxy), map(p+E.yyx)) - map(p)\n    );\n}\n\nfloat getAO(vec3 O, vec3 D) {\n    float totao = 0.;\n    float sca = 1.0;\n\n    for (int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.03 * float(i * i);\n        vec3 p = O + D * hr;\n        float m = map(p);\n        float ao = clamp(hr-m, 0.0, 1.0);\n        totao += ao * sca;\n        sca *= 0.7;\n    }\n\n    return 1.0 - clamp(2. * totao, 0.0, 1.0);\n}\n\nfloat march(vec3 O, vec3 D, float I, float md, out float shadow) {\n    float d = 0.;\n    shadow = INF;\n    for(float i=0.;i<I;++i) {\n        vec3 p = O+D*d;\n        float m = map(p);\n        d += m;\n        shadow = min(shadow, 20.*m/d);\n        if (d > md || m < .001*d) {\n            return d;\n        }\n    }\n    return INF;\n}\n\nvec3 ACESFilm(vec3 x){\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 O = vec3(0.), D=normalize(vec3(uv, 1.));\n    float t=time;\n    O.xy += .2*vec2(sin(t*.3), sin(t*.35));\n    D.xy *= mr(.6*sin(.1*t));\n    D.xz *= mr(.2*sin(.1*t));\n    O.z += 1.*time;\n\n    float md = 30., shad;\n    float d = march(O, D, 64., md, shad);\n    vec3 p = O+D*d;\n\n    vec3 color = vec3(0.);\n    vec3 bg = vec3(.01);\n    vec3 fogp = vec3(.2, .18, .13);\n    if (d > md) {\n        color = bg;\n    } else if (material == 10) {\n        color = vec3(100.) * exp(-d * fogp * 2.5);\n    } else {\n        float lightIndex = floor(p.z / lightParams.y);\n        vec3 lightPos = vec3(0., 0., (lightIndex+.5) * lightParams.y);\n\n        float randAng = TAU*hash(fract(40.*p) + t+2.3);\n        lightPos.xy += (vec2(cos(randAng), sin(randAng)) + lightOffset(lightIndex)) * lightParams.x;\n        vec3 toLight = lightPos-p;\n        vec3 normToLight = normalize(toLight);\n        float lenToLight = length(toLight);\n\n        mapRings = false;\n        vec3 n = normal(p);\n        float shadow = march(p + n*d*.05, normToLight, 12., lenToLight, shad);\n        shadow = min(1., shad);\n\n        vec3 c1 = vec3(.6, .8, 1.);\n        vec3 c2 = vec3(1., .8, .8);\n        vec3 diff = .7 * c1 * max(0., dot(n, normToLight));\n        vec3 h = normalize(-D + normToLight);\n        vec3 spec = 5. * c2 * pow(max(0., dot(n, h)), 80.);\n        vec3 c = vec3(0.);\n        c += diff * min(1., 600.*exp(-3.1*abs(lenToLight)));\n        c += spec  * min(1., 600.*exp(-2.1*abs(lenToLight)));\n        c *= shadow;\n        c += vec3(.01);\n        if (shadow > 0.) c *= getAO(p, n);\n        color += c;\n        color = mix(bg, color, min(exp(-d * fogp), 1.));\n    }\n    color += glow;\n    color = clamp(color, vec3(0.), vec3(1.));\n    color = ACESFilm(color);\n    color = sqrt(color);\n\n    uv = fragCoord/iResolution.xy;\n    vec3 prev = texture(iChannel0, uv).rgb;\n    color = mix(color, prev, .8);\n    fragColor = vec4(color,1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2fRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 139]], "test": "untested"}
{"id": "7l2fzV", "name": "Dancing color lights", "author": "fpiaggio", "description": "dancing color lights", "tags": ["dancing"], "likes": 2, "viewed": 313, "published": 3, "date": "1652463108", "time_retrieved": "2024-07-30T16:48:59.513345", "image_code": "#define PI  3.14159265359\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233))) * 43758.5453123);\n}\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nmat2 r2d(float a) {\n\tfloat c = cos(a), s = sin(a);\n\t// https://en.wikipedia.org/wiki/Rotation_matrix\n    return mat2(\n        c, s,\n        -s, c\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( fragCoord -.5*iResolution.xy )/iResolution.y;\n    uv *= r2d(iTime*0.25);\n\tvec2 p = vec2(0.,0.) - uv;\n\tvec3 color = vec3(0.0);\n\tfloat maxH = map(sin(iTime), -1., 1., 1600., 1820.);\n    float maxp2 = map(sin(iTime*2.), -1., 1., 1., 2.);\n    float maxq =  map(sin(iTime*0.01), -1., 1., 2., 6.);\n\tfor (float i = 0.0; i < 5.0; i += 0.1) {\n\t\tvec2 p2 = p;\n\t\tvec2 inf = vec2(0.);\n        /*\n        Probar\n        inf.x += cos((iTime * 0.5 + i + cos(iTime*0.01+i*2.)*0.5+0.6) / maxq * PI);\n\t\tinf.y += sin((iTime * 0.5 + i + cos(iTime*0.01+i*2.)*0.5+0.6) / maxq * PI * 2.0) / 2.0;\n        */\n\t\tinf.x += cos((iTime * 1.2 + i + cos(iTime*0.4+uv.x+i*1.5) + cos(iTime*0.4+i*2.)) / maxq * PI);\n\t\tinf.y += sin((iTime * 1.2 + i + sin(iTime*0.4+uv.y+i*1.5) + cos(iTime*0.4+i*2.)) / maxq * PI * 2.0) / 2.0;\n\t\tp2 *= p2;\n\t\tp2.x += inf.x/4.8;\n\t\tp2.y += inf.y/4.8;\n\t\tp2 += random(p2) * p2 * maxp2;\n\t\tfloat h = (0.006 + i / 900.0) / abs(0.001 + i / maxH - length(p2));\n\t\tcolor += vec3(h);\n\t}\n    \n\tfragColor = vec4(color * vec3(uv.x, uv.y, .2), 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2fzV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 49, 49, 123], [124, 124, 196, 196, 262], [264, 264, 283, 283, 418], [420, 420, 477, 477, 1523]], "test": "untested"}
{"id": "7t2fRK", "name": "Cubic Dispersal broke the scene", "author": "iapafoto", "description": "Inspired by  Tater [Cubic Dispersal] https://www.shadertoy.com/view/fldXWS\n\nThe goal of this Shader was to show that we can create a very simple Cut dispersal operator applicable to any scene with a simple function call (opCutDispersal).\n\n", "tags": ["text", "effect", "font", "slice", "cubic", "cut", "operator", "dispersal"], "likes": 37, "viewed": 483, "published": 3, "date": "1652457268", "time_retrieved": "2024-07-30T16:49:00.333153", "image_code": "// Created by Sebastien Durand - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// -----------------------------------------------\n// The goal of this Shader was to show that we can create a very simple Cut dispersal \n// operator applicable to any scene with a simple function call (opCutDispersal). (opCutVoronoi ).\n// -----------------------------------------------\n// Other cutting space: \n//   [CrashTest]                       https://www.shadertoy.com/view/wsSGDD\n//   [Voronoi broke the scene]         https://www.shadertoy.com/view/7tBBDw\n//   [Cubic Dispersal broke the scene] https://www.shadertoy.com/view/7t2fRK\n// -----------------------------------------------\n// inspired by  Tater [Cubic Dispersal] https://www.shadertoy.com/view/fldXWS\n// Tater [Fully Animated Subdivision] https://www.shadertoy.com/view/stdGz4\n\n#define WITH_EDGE\n//#define WITH_MIN_BLOCK_SIZE // introduce imprecisions\n\n#define WITH_ROTATION\n\n\nfloat ITERS = 4.;\n\n\nfloat tOpen;\n\n// SPACE txt\n//int[] gtxt = int[] (83,80,65,67,69);\n// SCENE\nint[] gtxt = int[] (83,67,69,78,69);\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));;\n}\n\nvec3 hash33(vec3 p) {   \n\tp = vec3(dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t dot(p,vec3(113.5,271.9,124.6)));\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// --------------------------------------\n// Space Operators\n// --------------------------------------\n\n// [iq] https://www.shadertoy.com/view/4lyfzw\nfloat opExtrussion(vec3 p, float sdf, float h) {\n    vec2 w = vec2(sdf, abs(p.z) - h);\n  \treturn min(max(w.x,w.y),0.) + length(max(w,0.));\n}\n\n// [iapafoto] https://www.shadertoy.com/view/7t2fRK\n// Adapted from Tater [Fully Animated Subdivision] https://www.shadertoy.com/view/stdGz4\nfloat opCutDispersal(inout vec3 uv, vec3 kdiv) {\n\nkdiv *= .3+.7*smoothstep(-2.,2.,uv.x+10.*cos(.5*iTime));\n#ifdef WITH_ROTATION\n    // Rotate\n    uv.xz *= rot(.2);\n    uv.xy *= rot(.3);\n#endif    \n    vec3 l0 = 2.*1.9*vec3(4.8,1.4,1.2);\n    vec3 dMin = -l0*.5 - kdiv*pow(2.,ITERS-1.);\n    vec3 dMax = l0*.5 + kdiv*pow(2.,ITERS-1.);\n    \n    float MIN_SIZE = 0.105;\n    vec3 diff2 = vec3(1); \n    vec3 posTxt = uv;\n    vec3 div0;\n\n    float i = 0.;\n    \n    for(; i<ITERS;i++){\n        // divide the box into quads\n        div0 = vec3(.1) + .8*hash33(diff2);  // ratio in compact form\n        \n        // here is the tricky part!\n        // how to converve a constant size in both side by tweaking the interval\n        vec3 dd = kdiv*pow(2.,ITERS-1.-i),\n            a0 = div0*l0,\n            a2 = a0 + dd,\n            l2 = l0 + 2.*dd,\n            div2 = a2/l2; // new ratio in expended form\n            \n        vec3 divide = mix(dMin, dMax, div2);\n        \n#ifdef WITH_MIN_BLOCK_SIZE\n        //Find the minimum dimension size\n        vec3 minAxis = min(abs(a0), abs(l0-a0));\n        float minSize = min(minAxis.x, min( minAxis.y, minAxis.z));\n        \n        // if minimum dimension is too small break out\n        // => this introduce imprecision in distance field\n        bool smallEnough = minSize < MIN_SIZE;\n        if (smallEnough && i + 1. > 1.) { break; }\n#endif\n\n        l0 = mix(l0-a0, a0, step(uv, divide));\n        \n        // update the box domain\n        dMax = mix( dMax, divide, step(uv, divide ));\n        dMin = mix( divide, dMin, step(uv, divide ));\n\n        //Deterministic seeding for future divisions \n        diff2 = step(uv, divide) - 10.*hash33(diff2);\n        posTxt -= dd*(.5 - step(uv, divide));\n    }\n     \n    // Calculate 3d box sdf for distance between blocks\n    vec3 center = (dMin + dMax)/2.0;\n    vec3 dd0 = .5*kdiv*pow(2., ITERS-(i-1.));\n    float d = sdBox(uv-center, .5*(dMax - dMin) - .5*dd0);\n    uv = posTxt;\n    \n#ifdef WITH_ROTATION    \n    // rotate back\n    uv.xy *= rot(-.3);\n    uv.xz *= rot(-.2);\n#endif   \n    return d;\n}\n\n\n// --------------------------------------\n// Distance Functions\n// --------------------------------------\n\n// Adapted from [FabriceNeyret2] https://www.shadertoy.com/view/llyXRW\nfloat sdFont(vec2 p, int c) {\n    vec2 uv = (p + vec2(float(c%16), float(15-c/16)) + .5)/16.;\n    return max(max(abs(p.x) - .25, max(p.y - .35, -.38 - p.y)), textureLod(iChannel0, uv, 0.).w - 127./255.);\n}\n\nfloat sdMessage2D(vec2 p, int[5] txt, float scale) { \n    p.y += .1;\n    p /= scale;\n \tfloat d = 999., w = .45; // letter width  \n    p.x += w*float(txt.length()-1)*.5; // center text arround 0\n    for (int id = 0; id<5; id++){\n    \td = min(d, sdFont(p, txt[id]));   \n    \tp.x -= w; \n    }\n    return scale*d;\n}\n\nfloat sdMessage3D(in vec3 p, int[5] txt, float scale, float h) { \n    return opExtrussion(p, sdMessage2D(p.xy, txt, scale), h);\n}\n\n// --------------------------------------\n// Distance to scene\n// --------------------------------------\nfloat map(vec3 p) {\n    float dcut = opCutDispersal(p, .7*vec3(.8,.4,.8)*tOpen), //opSuperCut(p),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return max(dScn, dcut);\n}\n\n// --------------------------------------\n// Shading Tools\n// --------------------------------------\n// Find initial space position\nvec4 MCol(vec3 p) {\n    float dcut = opCutDispersal(p, .7*vec3(.8,.4,.8)*tOpen),\n          dScn = sdMessage3D(p, gtxt,4.,1.);\n    return vec4(p, dScn >= dcut ? 1. : 2.);\n}\n\n// Shane - normal + edge\nvec3 normal(vec3 p, vec3 rd, inout float edge, float t) { \n    float eps = 4.5/mix(450., min(850., iResolution.y), .35),\n          d = map(p);\n#ifdef WITH_EDGE\n    vec3 e = vec3(eps, 0, 0),\n         da = vec3(-2.*d);\n    for(int i = min(iFrame,0); i<3; i++) {\n        for( int j=min(iFrame,0); j<2; j++ )\n            da[i] += map(p + e*float(1-2*j));\n        e = e.zxy;\n    }\n    da = abs(da);\n    edge = da.x + da.y + da.z;\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n#endif\n    vec3 n = vec3(0);\n    for( int i=min(iFrame, 0); i<4; i++) {\n        vec3 e = .57735*(2.*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1)) - 1.);\n        n += e*map(p + .001*e);\n    }\n    return normalize(n - max(.0, dot(n,rd))*rd);\n}\n\n// Box:  https://www.shadertoy.com/view/ld23DV\nbool iBox( vec3 ro, vec3 rd, vec3 sz, inout float tN, inout float tF) {\n    vec3 m = sign(rd)/max(abs(rd), 1e-8),\n         n = m*ro,\n         k = abs(m)*sz,\n         t1 = -n - k,\n         t2 = -n + k;\n\ttN = max( max( t1.x, t1.y ), t1.z );\n\ttF = min( min( t2.x, t2.y ), t2.z );\n    return !(tN > tF || tF <= 0.0);\n}\n\n//----------------------------------\n// Texture 3D (Shane)\n//----------------------------------\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){  \n    n = max(n*n, .001);\n    n /= n.x + n.y + n.z;  \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){   \n    const vec2 e = vec2(.001, 0);\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)) )/e.x; \n    g -= n*dot(n, g);\n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n}\n\n\n//----------------------------------\n// Shading\n//----------------------------------\nvec3 render(vec3 ro, vec3 rd, float res, vec3 pos, vec3 n, vec3 cobj, vec3 light, vec3 cback, float spec) {\n    float \n         amb = clamp(.5+.5*n.y, .0, 1.),\n         dif = clamp(dot( n, light ), 0., 1.),\n         pp = clamp(dot(reflect(-light,n), -rd),0.,1.),\n         fre = (.7+.3*dif)*pow( clamp(1.+dot(n,rd),0.,1.), 2.);\n    vec3 brdf = .5*(amb)+ 1.*dif*vec3(1.,.9,.7),\n         sp = 3.*pow(pp,spec)*vec3(1, .6, .2),\n\t     col = cobj*(brdf + sp) + fre*(.5*cobj+.5);\n    return mix(col, vec3(.02,.2,.2),smoothstep(6.,20.,res));\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float r ) {\n\tvec3 w = normalize(ta-ro),\n         p = vec3(sin(r), cos(r),.0),\n         u = normalize( cross(w,p) ),\n         v =          ( cross(u,w) );\n    return mat3( u, v, w );\n}\n\n\n// --------------------------------------\n// Main\n// --------------------------------------\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n\n    vec2 r = iResolution.xy, \n         m = iMouse.xy / r,\n\t     q = fragCoord.xy/r.xy;\n \n    tOpen = .4*smoothstep(.6,0.,cos(.3*iTime));\n\n    float a = 1.+mix(.3,3.*cos(.4*3.*iTime),.5+.5*cos(.2*iTime))+3.14*m.x;\n    \n    // camera\t\n    vec3 ta = vec3(0),\n         ro = ta + 2.4*vec3(4.5*cos(a), 3.*cos(.4*iTime) + 4.*m.y, 4.5*sin(a));\n    mat3 ca = setCamera( ro, ta, .1*cos(.123*iTime) );\n  \n    // ray direction\n    vec3 rd = ca * normalize( vec3((2.*fragCoord-r.xy)/r.y, 2.5));\n\n    float h = .1, t, tN = 0., tF = 20.;\n    \n    // Background color\n\tvec3 c = .09*vec3(hash33(q.xyx).x + 1.);\n\n    if (iBox(ro, rd, vec3(4.8,1.4,1.2)*(1.+vec3(1.,2.,3.)*tOpen), tN, tF)) {\t\t\n        t = tN;// - .02*hash33(q.xyx).x;\n\t// Ray marching\n        for(int i=min(0,iFrame);i<200;i++) { \n            if (h<1e-3 || t>tF) break;\n            t += h = map(ro + rd*t);\n        }\n    \n        // light pos\n        vec3 lp =  ro + 3.*vec3(.25, 2, -.1);\n\n        // Calculate color on point\n        if (t<tF) {\n            vec3 pos = ro + t * rd;\n            float edge = 0.;\n            vec4 txt = MCol(pos); \t\n            vec3 n = normal(pos, rd, edge, t),     \n                 cobj = txt.w<1.5 ? vec3(.7) : 1.5*vec3(.8,.4,.0);\n            if (txt.w<1.5) {\n                n = doBumpMap(iChannel1, txt.xyz*2., n, .01);\n            } else {\n                n = doBumpMap(iChannel2, txt.xyz*2., n, .02);\n            }\n            // keep in visible side\n            n = normalize(n - max(.0,dot(n,rd))*rd);\n            // Shading\n            c = render(ro, rd, t, pos, n, cobj, normalize(lp-pos), c, txt.w<1.5 ? 99. : 16.);\n    #ifdef WITH_EDGE\n            c *= 1. - edge*.8;\n    #endif\n        } \n    } //else{\n    //c *= 2.; \n    //}\n    \n    \n    // post prod\n    c = pow(c, vec3(.75));\n    c = vec3(c* pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y),.7f));\n\tfragColor = vec4(c, t);\t\n}", "image_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7t2fRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1107, 1107, 1126, 1126, 1179], [1181, 1181, 1202, 1202, 1362], [1364, 1364, 1395, 1395, 1482], [1588, 1634, 1682, 1682, 1774], [1776, 1917, 1965, 1965, 3988], [4098, 4169, 4198, 4198, 4374], [4820, 4925, 4944, 4944, 5097], [5099, 5231, 5250, 5250, 5402], [5404, 5429, 5486, 5486, 6137], [6139, 6186, 6257, 6257, 6500], [6599, 6753, 6803, 6803, 6947], [6949, 7136, 7198, 7198, 7667], [7670, 7755, 7862, 7862, 8289], [8291, 8291, 8335, 8335, 8507], [8510, 8602, 8655, 8655, 10514]], "test": "untested"}
{"id": "NljfzV", "name": "Single Fractal", "author": "morimea", "description": "Randomly made this SDF fractal.\nSingle function with different parameters.\n[b]Loop is eight different shapes.[/b]\n\nCineshader support [url]https://cineshader.com/view/NljfzV[/url]", "tags": ["3d", "fractal", "volumetric", "cineshader"], "likes": 80, "viewed": 4890, "published": 3, "date": "1652456120", "time_retrieved": "2024-07-30T16:49:01.098108", "image_code": "\n// Created by Danil (2022+) https://github.com/danilw\n// License - CC0 or use as you wish\n\n\n// main point of this shader is - fractal that generate different image depends of parameters\n// look map function\n\n\n\n// to play with parameters and use Mouse control, 5 is index in arrays below that size of psz\n//#define use_func 5\n\n\n// to test animation loop with mouse\n//#define mouse_loop\n\n\n#define cam_orbit 2.05\n\n// params\n#define psz 8\n\n// scale\nfloat p0[psz] = float[]( 0.7, 0.7, 0.7, 0.7, 0.57, 0.697, .09, 2.57);\n\n\n// biggest visual impact \nfloat p1[psz] = float[]( 0.07,  0.07, -0.107, -0.07, -0.69,  -0.69,   -0.1069,  -0.69);\n\nfloat p2[psz] = float[](-0.15, -0.15,  1.84,  -0.15, -0.015,  0.015,  -0.02015, -0.015);\n\nfloat p3[psz] = float[]( 0.465, 0.184, 0.465,  0.465, 0.2465, 0.1465,  1.465,    0.2465);\n\n\n// number of loops, keep low (clamped to 1 to 30 to not kill your GPU)\nint p5[psz] = int[](5,5,10,5,5,5,10,5);\n\n\n\n// main fractal func\nfloat map(in vec3 p, int idx) {\n\t\n\tfloat res = 0.;\n    vec3 c = p;\n\tfor (int i = 0; i < clamp(p5[idx],1,30); ++i) {    \n        p =p0[idx]*abs(p)/max(dot(p,p+p2[idx]*p/(p+0.0001*(1.-abs(sign(p))))),0.0001) + p1[idx];\n        p=p.zxy;\n        res += exp(-33. * abs(dot(p,p3[idx]*c)));        \n\t}\n\treturn res;\n}\n\n\nvec3 postProcess(vec3 col, float ct);\nvec3 march(vec3 ro, vec3 rd, int idx, float c_timer, float ct2) {\n  float t   = 0.;\n  float dt  = 0.152;\n  vec3 col  = vec3(0.0);\n  float c   = 0.;\n  const int max_iter = 48;\n  for(int i = 0; i < max_iter; ++i) {\n      t += dt*exp(-1.50*c);\n      vec3 pos = ro+t*rd;\n      c = map(pos,idx); \n      \n      //c *= 0.025+2.*iMouse.y/iResolution.y; //test color with mouse\n      c *= 0.025+2.*c_timer;\n      float center = -0.35; // center of color shift\n      float dist = (abs(pos.x + pos.y + center))*2.5;\n      vec3 dcol = vec3(c*c+0.5*c*c-c*dist, c*c-c, c); // color func\n      col = col + dcol*1./float(max_iter);\n  }\n  col *= 0.18;\n  col=clamp(col,0.,1.);\n  return postProcess(col, ct2);\n}\n\nvec3 postProcess(vec3 col, float ct) {\n  col = col*0.85+0.85*col*col.brb;\n  col = col*0.6+0.64*col*col*(3.0-2.0*col)+0.5*col*col;\n  col = col+0.4*(col.rrb-vec3(dot(col, vec3(0.33))));\n  vec3 c1=col-0.344*(col.brb-vec3(dot(col, vec3(0.33))));\n  vec3 c2=col+0.64*(col.ggr-vec3(dot(col, vec3(0.33))));\n  col=mix(col,c1,min(ct*2.,1.));\n  col=mix(col,c2,-clamp(ct*2.-1.,0.,1.));\n  //col*=1.5;\n  col=col*01.5+0.5*col*col;\n  return col;\n}\n\n\n\n// fractal color function\n\n#define PI 3.14159265\nvec4 get_color(vec2 p , int idx, float timer, float c_timer)\n{\n    idx = idx%psz;\n    vec4 fragColor;\n\tfloat time = iTime;\n    vec3 ret_col = vec3(0.0);\n    float mouseY = 0.15 * PI;\n    mouseY = (1.0 - 0.5*1.15 * (1.83-timer)) * 0.5 * PI;\n#ifdef use_func\n    mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.w<iResolution.y)mouseY = (1.0 - 1.15 * iMouse.y / iResolution.y) * 0.5 * PI;\n#endif\n    float mouseX = -1.25*PI;\n    mouseX+=-(timer*1.5+0.25) * .5 * PI;\n#ifdef use_func\n    mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI; //test MOUSE\n#endif\n#ifndef mouse_loop\n    if(iMouse.z>0.&&iMouse.z<iResolution.x)mouseX=-1.25*PI-(iMouse.x / iResolution.x) * 3. * PI;\n#endif\n    vec3 eye = cam_orbit*vec3(cos(mouseX) * cos(mouseY), sin(mouseX) * cos(mouseY), sin(mouseY));\n    eye = eye+0.0001*(1.-abs(sign(eye)));\n    vec3 ro = eye;\n\n    vec3 w = normalize(-eye);\n    vec3 up = vec3(0., 0., 1.);\n    vec3 u = normalize(cross(w, up));\n    vec3 v = cross(u, w);\n\n    vec3 rd = normalize(w + p.x * u + p.y * v);\n    \n    vec3 col =  march(ro, rd, idx, timer*0.30+0.15*timer*timer+0.25, c_timer);\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n    return fragColor;\n}\n\n\n\n// everything else is just Shadertoy presentation, not related to fractal\n// mainImage has godrays + image slider logic\n\nvec2 plane(vec2 uv, float timer);\nfloat GetBayerFromCoordLevel(vec2 pixelpos);\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d );\nfloat hash(vec2 p);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    fragColor = vec4(0.);\n    vec2 res = iResolution.xy/iResolution.y;\n    vec2 uv = fragCoord/iResolution.y;\n\n#ifdef use_func\n    fragColor = get_color((uv-res*0.5)*2., use_func, 0.65, 0.);\n    return;\n#endif\n\n    const float grn = 7.; // number of tiles for slider\n\n    float sx = 0.5*(1./grn)+0.5*0.25*(floor(res.x/(1./grn))-0.5*res.x/(1./grn));\n    uv.x += sx;\n    vec2 gid = floor(uv*grn);\n    uv = fract(uv*grn)-0.5;\n    \n    // timers\n    float gtime = iTime*.645;\n    // gtime=float(psz)*6. sec loop\n    \n#ifdef mouse_loop\n    gtime=float(psz)*6.*iMouse.x/iResolution.x; //test MOUSE\n#endif\n\n    // timer logic\n    float tt = mod(gtime,12.);\n    float tt2 = mod(gtime+6.,12.);\n    float i1 = smoothstep(3.,6.,tt);float i2 = smoothstep(9.,12.,tt);\n    float ltime = (i1+i2)*3.+floor(gtime/12.)*6.;\n    float s_timer = (smoothstep(3.,12.,tt2));\n    float s_timer2 = (smoothstep(3.,12.,tt));\n    int itdx = int(ltime+3.)/6;\n    int itdx2 = int(ltime)/6;\n    \n    float gmix1 = 0.5-0.5*cos(gtime/6.*0.35);\n    float gmix2 = 0.5-0.5*cos(gtime/6.*0.25);\n\n    // godrays \n    vec3 occ_col=vec3(0.);\n    {\n        #define DECAY .974\n        #define EXPOSURE .116907\n        #define SAMPLES\t32\n        #define DENSITY\t.595\n        #define WEIGHT .25\n        vec2 coord = fragCoord.xy/iResolution.xy;\n        float cd = 1.75*length(coord-0.5);\n        float occ=0.;\n        vec2 lightpos = vec2(0.51,0.503);\n        float dither = GetBayerFromCoordLevel(fragCoord);    \n        vec2 dtc = (coord - lightpos) * (1. / float(SAMPLES) * DENSITY);\n        float illumdecay = 1.;\n        for(int i=0; i<SAMPLES; i++)\n        {\n            coord -= dtc;\n            vec2 otuv = coord+(dtc*dither);\n            vec2 tuv = otuv*res;\n            tuv.x += sx; vec2 lgid = floor(tuv*grn); tuv = fract(tuv*grn)-0.5;\n            float lctimer = 0.0;\n            float lctime = ltime - (lgid.y/grn - lgid.x/(grn*res.x))*1.-grn/16.+2.;\n            lctime = mod(lctime, 6.);\n            lctimer += smoothstep(0.0, 1.0, lctime);\n            lctimer += 1. - smoothstep(3.0, 4.0, lctime);\n            lctimer = abs(lctimer-1.0);\n            vec2 tuv_pl = plane(tuv,lctimer);\n            float noplx = float(abs(tuv_pl.x)>0.5||abs(tuv_pl.y)>0.5);\n            float s = (noplx)*(1.-smoothstep(-0.03,0.75,.5*length(otuv-0.5)));\n            s *= illumdecay * WEIGHT;\n            occ += s;\n            illumdecay *= DECAY;\n        }\n        occ=1.5*occ*EXPOSURE;\n        occ_col = occ*(1./max(cd,0.0001))*\n            pal( mix(cd*occ*0.35,cd+occ*0.35,gmix1), \n            vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) ).gbr;\n        occ_col=clamp(occ_col,0.,1.);\n    }\n    //----\n\n    float timer = 0.0;\n    float time = ltime - (gid.y/grn - gid.x/(grn*res.x))*1.-grn/16.+2.;\n    time = mod(time, 6.);\n    timer += smoothstep(0.0, 1.0, time);\n    timer += 1. - smoothstep(3.0, 4.0, time);\n    timer = abs(timer-1.0);\n    float side = step(0.5, timer);\n    vec2 uv_pl = plane(uv,timer);\n    \n    vec2 tp = (fragCoord.xy/iResolution.xy-0.5)*2.;\n    tp = pow(abs(tp), vec2(2.0)); \n    float tcd = 0.5+0.5*clamp(1.0 - dot(tp, tp),0.,1.);\n    float cineshader_alpha = smoothstep(0.,1.,(timer))*0.5*tcd;\n    //float cineshader_alpha = smoothstep(0.,1.,2.*abs(timer-.5))*0.5*tcd;\n    \n    bool nopl = abs(uv_pl.x)>0.5||abs(uv_pl.y)>0.5;\n    uv_pl += 0.5;\n    if(side<0.5)uv_pl.x=1.-uv_pl.x;\n    \n    if (nopl)\n    {\n        fragColor = vec4(occ_col,cineshader_alpha);\n        return;\n    }\n    vec2 tuv = ((uv_pl*1./res)*1./grn+((gid*1./grn)+vec2(-sx,0.))*1./res);\n    if(side>0.5)fragColor = get_color((tuv-0.5)*res*2.,0+itdx*2,s_timer, gmix2);\n    else fragColor = get_color((tuv-0.5)*res*2.,1+itdx2*2,s_timer2, gmix2);\n    \n    //fragColor.rgb*=smoothstep(0.,1.,2.*abs(timer-.5));\n    \n    fragColor = vec4(fragColor.rgb+occ_col,cineshader_alpha);\n    fragColor.rgb = clamp(fragColor.rgb,0.,1.);\n}\n\n\nvec2 plane(vec2 uv, float timer)\n{\n    timer = radians(timer*180.0);\n    vec4 n = vec4(cos(timer),0,sin(timer),-sin(timer));\n    vec3 d = vec3(1.0,uv.y,uv.x);\n    vec3 p = vec3(-1.0+n.w/4.0,0.,0.);\n    \n    vec3 up = vec3(0.,1.,0.);\n    vec3 right = cross(up, n.xyz);\n    float dn = dot(d, n.xyz);dn+=0.00001*(1.-abs(sign(dn)));\n    float pn = dot(p, n.xyz);\n    vec3 hit = p - d / dn * pn;\n    return vec2(dot(hit, right), dot(hit, up));\n}\n\n\nfloat GetBayerFromCoordLevel(vec2 pixelpos)\n{\n    ivec2 ppos = ivec2(pixelpos);\n    int sum = 0; const int MAX_LEVEL = 3;\n    for(int i=0; i<MAX_LEVEL; i++)\n    {\n        ivec2 tv = ppos>>(MAX_LEVEL-1-i)&1;\n        sum += ((4-(tv).x-((tv).y<<1))%4)<<(2*i);\n    }\n    return float(sum) / float(2<<(MAX_LEVEL*2-1));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfzV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[929, 950, 981, 981, 1259], [1300, 1300, 1365, 1365, 1992], [1994, 1994, 2032, 2032, 2425], [2478, 2478, 2540, 2540, 3740], [4033, 4033, 4089, 4089, 7984], [7987, 7987, 8021, 8021, 8427], [8430, 8430, 8475, 8475, 8745], [8747, 8747, 8815, 8815, 8858]], "test": "ok"}
{"id": "sljBRG", "name": "Glass Candy", "author": "leon", "description": "I can feel his sour sweet taste", "tags": ["abstract"], "likes": 31, "viewed": 635, "published": 3, "date": "1652429153", "time_retrieved": "2024-07-30T16:49:01.977755", "image_code": "\n// Glass Candy by Leon Denise 2022/05/13\n// Using code from Inigo Quilez, Antoine Zanuttini and many more\n\n// A classic kaleidoscopic iterated function with spheres\n// I was playing with reflections and inversed the ray and normal for curiosity\n// It gave a funky fake refraction that was fun to play with\n\nconst float falloff = 1.2;\nconst float size = .5;\nconst float range = 1.1;\n\nfloat colorOffset;\n\nmat2 rot (float a) { return mat2(cos(a),-sin(a),sin(a),cos(a)); }\n\n// signed distance function\nfloat map(vec3 p)\n{\n    float d = 100.;\n    float s = 100.;\n    float a = 1.;\n    float t = 196.+iTime * .1;\n    for (float i = 0.; i < 12.; ++i)\n    {\n        p.x = abs(p.x)-range*a;\n        p.xz *= rot(t/a);\n        p.yx *= rot(t/a);\n        s = length(p)-size*a;\n        colorOffset = s < d ? i : colorOffset;\n        d = min(d, s);\n        a /= falloff;\n    }\n    \n    return d;\n}\n\n// Antoine Zanuttini\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    vec3 noise = texture(iChannel0, fragCoord.xy/1024.).rgb;\n    vec3 ray = normalize(vec3(uv, 1));\n    vec3 pos = vec3(0,0,-3);\n    \n    // init variables\n    vec3 color, normal, tint;\n    float index, shade, light;\n    const float count = 25.;\n    colorOffset = 0.;\n\n    // ray marching\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*noise.z;\n        pos += ray*dist;\n    }\n    \n    // lighting\n    shade = index/count;\n    normal = getNormal(pos);\n    light = pow(dot(reflect(ray, normal), vec3(0,1,0))*.5+.5, 4.);\n    light += pow(dot(normal, ray)*.5+.5, .5);\n    color = vec3(.5) * shade * light;\n    \n    // ray bouncing (where the funky stuff happens)\n    ray = reflect(normal, ray); // should be ray = reflect(ray, normal);\n    pos += ray * (.2+.19*sin(iTime*2.+length(uv)*6.)); // jumpy bounce\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*noise.z;\n        pos += ray*dist;\n    }\n\n    // coloring\n    normal = getNormal(pos);\n    light = pow(dot(normal, ray)*.5+.5, 1.);\n    tint = .5+.5*cos(vec3(0,.3,.6)*6.+colorOffset*2.+pos.y*2.+light);\n    color += tint * shade * index/count * (noise.r*.3+.7);\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [{"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljBRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[404, 404, 424, 424, 469], [471, 499, 518, 518, 883], [885, 947, 974, 974, 1101], [1103, 1103, 1160, 1179, 2569]], "test": "untested"}
{"id": "Nt2BzG", "name": "Main Cardioid to Circle Mapping", "author": "Fraktoler", "description": "The main cardioid of the Mandelbrot set is mapped to the unit circle and back.", "tags": ["fractal", "mandelbrot", "complex", "mapping", "cardioid"], "likes": 2, "viewed": 277, "published": 3, "date": "1652404353", "time_retrieved": "2024-07-30T16:49:02.855409", "image_code": "#define MAX_ITER 256\n#define BAILOUT 256.\n#define PI 3.14159265358979\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 6.;\n    vec2 uv = zoom * (fragCoord - .5 * iResolution.xy) / iResolution.x;\n    float r, effect = sin(iTime * .2);\n    effect *= effect;\n    vec2 c = uv - .25 * effect * mul(normalize(uv) + vec2(2, 0), uv);\n    vec2 z = c;\n    int k = 0;\n    while (k < MAX_ITER) {\n        r = dot(z, z);\n        if (r > BAILOUT) break;\n        z = mul(z, z) + c;\n        k++;\n    }\n    vec3 col = vec3(0.);\n    if (k != MAX_ITER) {\n        float invln = 1. / log(2.);\n        float lnlnb = log(log(BAILOUT));\n        float u = log(float(k) + invln*lnlnb - invln*log(.5 * log(r))) + 1.3;\n        col = cos(vec3(u * 2.5, u * 1.5, 3. * u + 1.25 * PI));\n    }\n    fragColor = vec4(col * col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2BzG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 97, 97, 143], [145, 145, 202, 202, 897]], "test": "untested"}
{"id": "7l2fRy", "name": "Sgr A*", "author": "ufffd", "description": "https://eventhorizontelescope.org/blog/astronomers-reveal-first-image-black-hole-heart-our-galaxy", "tags": ["blackhole", "photorecreation"], "likes": 13, "viewed": 446, "published": 3, "date": "1652400424", "time_retrieved": "2024-07-30T16:49:05.650934", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R;\n    vec2 uvc = ( 2.*fragCoord - R ) / R.y; \n    vec3 col = vec3(0.);\n    col = texture(iChannel0,uv,7.).rgb;\n    col = mix(col,texture(iChannel0,uv,6.).rgb,0.5);\n    col = mix(col,texture(iChannel0,uv,5.).rgb,0.5);\n    col = mix(col,texture(iChannel0,uv,4.).rgb,0.5);\n    col = mix(col,texture(iChannel0,uv,3.).rgb,0.5);\n    col = mix(col,texture(iChannel0,uv).rgb,0.5);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// draw blackhole\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fragCoord/R;\n    vec2 uvc = ( 2.*fragCoord - R ) / R.y; \n\n    vec3 col = vec3(0.);\n    \n    int t = int(iTime*2.)%100;\n    \n    float bh = 0.;\n    // draw main blackhole donut\n    bh = 1.1*circle(uvc*rot(-0.2)*vec2(1.,1.4)*0.9); // base shape\n    bh -= 1.1*circle2(uvc*rot(-0.2)*vec2(1.1,1.4)*1.3); // cut out center\n    // draw main blackhole donut\n    bh += .05*circle(uvc*rot(-0.2)*vec2(1.,1.5)*1.); // base shape\n    // add 3 bright spots on donut\n    mixin(bh, .9*circle2(uvc*rot(-0.25)*vec2(0.8,1.5)*1.9-vec2(0.1,.9))); // top right bigdot\n    mixin(bh, 1.05*circle(uvc*rot(-0.4)*vec2(0.8,1.5)*1.8-vec2(0.15,0.95))); // top right bigdot big\n    mixin(bh, 0.8*circleS(uvc*rot(3.6)*vec2(1.,1.3)*2.7-vec2(-0.4,1.7))); // bot right bigdot\n    bh += 0.1*circleS(uvc*rot(3.6)*vec2(1.,1.3)*2.7-vec2(-0.4,1.7)); // bot right bigdot big\n    mixin(bh,.85*circleS(uvc*rot(3.5)*vec2(1.,1.3)*2.7-vec2(-0.4,1.6))); // bot right bigdot big2\n    mixin(bh, 0.8*circle(uvc*rot(1.4)*vec2(1.,1.)*1.5-vec2(0.05,.7))); // left bigdot\n    bh -= .1*circleS(uvc*rot(-0.2)*vec2(0.9,1.7)*2.); // cut out center\n    mixin(bh,.2*circle(uvc*rot(-0.2)*vec2(1.,1.7)*0.9)); // base shape\n    // reduce background redness\n    // bh -= 0.05;\n    // background blobs (approximately starting at top left and going counterclockwise)\n    float bs = 2.; // blob size\n    vec2 bp = vec2(1.1,-1.5); // blob pos\n    mixin(bh, circleS(uvc*bs+bp)*0.2);\n    bp = vec2(0.9,-0.9);\n    mixin(bh, circleS(uvc*bs+bp)*.25);\n    bp = vec2(1.3,-0.9);\n    mixin(bh, circleS(uvc*bs+bp)*.25);\n    bp = vec2(2.5,0.6);\n    mixin(bh, circle(uvc*bs+bp)*.15);\n    bp = vec2(1.7,0.8);\n    mixin(bh, circle(uvc*bs+bp)*.15);\n    bp = vec2(1.3,1.7);\n    mixin(bh, circle(uvc*bs+bp)*.1);\n    bp = vec2(-0.6,1.8);\n    mixin(bh, circle(uvc*bs+bp)*.15);\n    bp = vec2(-.98,1.25);\n    mixin(bh, circleS(uvc*bs+bp)*.19);\n    bp = vec2(-.7,-.8);\n    mixin(bh, circle(uvc*bs+bp)*.3);\n    bs = 1.2;\n    bp = vec2(.6,-.6);\n    mixin(bh, circle2(uvc*bs+bp)*.3);\n    bs = 1.3;\n    bp = vec2(.45,-.75);\n    mixin(bh, circle(uvc*bs+bp)*.25);\n    bs = 4.;\n    bp = vec2(-.98,1.2) * 2.;\n    bh += circle(uvc*bs+bp)*.1;\n    \n    bh -= length(uv-0.5)*0.1;\n    \n    col = colormap(bh);\n    // col = vec3(bh); // grayscale\n\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "common_code": "vec3 colormap(in float c) {\n    vec3 col = vec3(0.);\n    // color steps\n    vec3 c1 = vec3(1., 0., 0.)/255.;\n    vec3 c2 = vec3(121., 5., 1.)/255.;\n    // vec3 c3 = vec3(201., 73., 0.)/255.;\n    vec3 c3 = vec3(231., 100., 10.)/255.;\n    vec3 c4 = vec3(247., 200., 98.)/255.;\n    vec3 c5 = vec3(254., 253., 247.)/255.;\n    c*=4.;\n    if (c<1.) {\n        col = mix(c1,c2,c);\n    } else if (c<2.) {\n        col = mix(c2,c3,c-1.);\n    } else if (c<3.) {\n        col = mix(c3,c4,c-2.);\n    } else {\n        col = mix(c4,c5,c-3.);\n    }\n    return col;\n}\n\n#define SS(a,b,c) smoothstep(a-b,a+b,c)\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n//  Function from Iigo Quiles\n//  www.iquilezles.org/www/articles/functions/functions.htm\nfloat cubicPulse( float c, float w, float x ){\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat circle(in vec2 uv) {\n    float c=0.;\n    c = 1.-length(uv);\n    c = clamp(c,0.,1.);\n    return c;\n}\n\nfloat circle2(in vec2 uv) {\n    float c = circle(uv);\n    return c*c;\n}\n\nfloat circleS(in vec2 uv) {\n    float c = circle(uv);\n    return pow(c,0.7);\n}\n\nfloat smax(float a, float b, float k)\n{\n    return log(exp(k * a) + exp(k * b)) / k;\n}\nfloat smax(float a, float b) {\n    return smax(a,b,30.);\n}\n\nvoid mixin(inout float a, in float b) {\n    a = smax(a,b);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2fRy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 546]], "test": "untested"}
{"id": "7ljfRG", "name": "easy 2d voronoi", "author": "ArmandB", "description": "voronoi noise with an explanation", "tags": ["voronoi", "noise"], "likes": 0, "viewed": 200, "published": 3, "date": "1652384472", "time_retrieved": "2024-07-30T16:49:06.679185", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y*cells; //screen coordinate normalized from 0 to the number of cells\n    vec2 cellCoord = floor(uv); //the corner of the cell this pixel is in\n    float n = 999.0; //the value of the noise at this point\n\n    //sample all cells in 3x3 cell area\n    for (int x = -1; x < 2; x++){\n        for (int y = -1; y < 2; y++){\n            if (!do_smoothing){\n                //normal distance function\n                n = min(n,distance(cellCoord + vec2(x,y) + hash22(cellCoord + vec2(x,y)),uv));\n            } else {\n                //rounds edges and points\n                n = smin(n,distance(cellCoord + vec2(x,y) + hash22(cellCoord + vec2(x,y)),uv), 8.0);\n            }\n        }\n    }\n\n    //set color\n    vec3 col = vec3(n);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "//how many cells are along the vertical edge\nfloat cells = 4.0;\n//should the noise be smoothed\nbool do_smoothing = true;\n\n//https://iquilezles.org/articles/smin/\n// power smooth min (k=8)\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n//given a point, output a random point with values from 0 to 1\nvec2 hash22(vec2 p) //https://www.shadertoy.com/view/4djSRW\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 849]], "test": "untested"}
{"id": "Nt2fzG", "name": "Fractal Experiment 33", "author": "aiekick", "description": "the same layering texhnique use here [url=https://www.shadertoy.com/view/7lXBz4]Voronoi Tracking Experiment 3(/url]", "tags": ["fractal", "experiment", "12"], "likes": 9, "viewed": 291, "published": 3, "date": "1652377732", "time_retrieved": "2024-07-30T16:49:07.738353", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Voronoi Tracking Experiment 1\n\n// based on the shader https://www.shadertoy.com/view/tlKGDh of michael0884\n\n// use mouse for add particles\n// use spacebar for clear the screen\n\n#define COUNT_STEPS 1000\n#define SCALE_STEP 0.001\n    \nfloat layer(vec2 p, float scale)\n{\n\tp -= iResolution.xy * 0.5;\n\tp *= scale;\n\tp += iResolution.xy * 0.5;\n\t\t\n\treturn texelFetch(iChannel0, ivec2(p), 0).w;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0,0,0,1);\n    vec3 color = vec3(1);\n    \n    // layering of same texture\n\tfloat fcount = float(max(COUNT_STEPS, 1));\n\tfloat scale = 1.0 + fcount * SCALE_STEP;\n\tfloat fog = 0.0;\n\tfloat fogStep = 1.0 / fcount;\n\tfor (int i = 0 ; i < COUNT_STEPS ; ++i)\n\t{\n\t\tscale -= SCALE_STEP;\n\t\tfog += fogStep;\n\t\tfloat k = layer(fragCoord, scale);\n\t\tif (k < 0.5) // smart merge for avoid overwrite\n\t\t\tfragColor.rgb = color * fog;\n\t}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define ITERATIONS 8\n\nvoid mainImage( out vec4 f, vec2 z )\n{\n    f.xyz=iResolution;\n    z = (z+z-f.xy)/f.y * 1.4;\n    vec2 g = z*(.5+.5*sin(iTime * 0.5));\n    \n   \tz -= g;\n    \n    for (int i=0;i<ITERATIONS;i++)\n    {\tz = (f.w = dot(z,z)) < 4. \n        ? mat2(z,-z.y,z.x) * z +  g - vec2(1,.3) : z;}\n \n    float sdf = sqrt(f.w)*log(f.w)-0.1;\n    //sdf = step(0.1, abs(sdf) - 0.1);\n    sdf = step(0.5, sdf) + step(sdf, -0.5);\n    f = vec4(sdf);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[373, 373, 407, 407, 527], [529, 529, 586, 586, 1024]], "test": "untested"}
{"id": "ftjBzG", "name": "Mriya Plans", "author": "dr2", "description": "Based on \"Mighty Mriya\" (7llfz2) - mouseable", "tags": ["projection", "plan", "aircraft"], "likes": 35, "viewed": 409, "published": 3, "date": "1652372143", "time_retrieved": "2024-07-30T16:49:08.868332", "image_code": "// \"Mriya Plans\" by dr2 - 2022\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  No. 5 in \"Sketches\" series\n    \"Ingenuity Mk.2 ?\"   (NsXXRj)\n    \"Engine Sketches\"    (sdt3R7)\n    \"Gear Projection\"    (ssjGWy)\n    \"Mercedes Sketches\"  (fl33zM)\n*/\n\n#define AA  0   // (= 0/1) optional antialiasing (and motion)\n\n#if 1\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrCaps2Df (vec2 p, float r, float h);\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Noisefv2 (vec2 p);\n\nvec4 csWm, csWt;\nvec3 qHit, pgSize, ltDir, ltDirS, flPos, dwf, dwr;\nvec2 csFl;\nfloat tCur, dstFar, angWm, drpWm, angWt, drpWt, szFac;\nint idObj;\nbool wlDown;\nconst int idFus = 1, idCkp = 2, idEng = 3, idWngM = 4, idWngT = 5, idFin = 6,\n   idWhl = 7, idLeg = 8, idFr = 9;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 ww;\n  float dMin, d, s, w, t, wg;\n  dMin = dstFar / szFac;\n  p /= szFac;\n  p -= flPos;\n  p.xz = Rot2Cs (p.xz, csFl);\n  q = p;\n  w = 1.;\n  s = 0.;\n  if (q.z < -1.5) {\n    s = q.z + 1.5;\n    s *= s;\n    w *= 1. - 0.025 * s;\n    s *= 0.026;\n  } else if (q.z > 3.5) {\n    s = q.z - 3.5;\n    s *= s;\n    w *= 1. - 0.05 * s;\n    s *= -0.02;\n  }\n  d = PrCapsDf (q - vec3 (0., s, 0.), w, 7.);\n  if (wlDown) d = max (d, - min (PrBoxDf (vec3 (abs (q.x) - 0.45, q.y + 1., q.z - 0.4),\n     vec3 (0.2, 0.25, 1.6)), PrBoxDf (vec3 (abs (q.x) - 0.2, q.y + 1., q.z - 4.8),\n     vec3 (0.1, 0.3, 0.2))));\n  DMINQ (idFus);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.65, 0.1, 6.);\n  d = PrCapsDf (q, 0.02, 0.3);\n  DMINQ (idFr);\n  q = p;\n  q.z -= -0.7;\n  q.xz = abs (q.xz);\n  q -= vec3 (0.2, 0.8, 4.);\n  d = PrCapsDf (q.xzy, 0.07, 0.2);\n  DMINQ (idFr);\n  q = p;\n  q.yz -= vec2 (0.4, 3.5);\n  d = PrCapsDf (q, 0.6, 1.5);\n  DMINQ (idCkp);\n  ww = vec2 (4., 1.4);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.7, 1.3);\n  q.xy = Rot2Cs (q.xy, csWm.xy);\n  q.xz = Rot2Cs (q.xz, csWm.zw);\n  t = ww.y * (1. - 0.3 * q.x / ww.x);\n  s = 1.1 * (q.z - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.15 * (t - s * s), t), abs (abs (p.x) - ww.x) - ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (abs (p.x) - 6.9, q.z - 0.085 * q.x + 1.2),\n     vec2 (0.85, 0.2))), 0.03);\n  DMINQ (idWngM);\n  for (float k = 0.; k < 4.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.1) * dwr + vec3 (0., 0.65, 0.1);\n    d = PrCapsDf (q, 0.05, 0.25);\n    DMINQ (idFr);\n  }\n  for (float k = 0.; k < 3.; k ++) {\n    q = p;\n    q.x = abs (q.x);\n    q -= (k + 1.3) * dwf + vec3 (0., 0.22, 2.8);\n    d = max (PrRoundCylDf (q.yzx - vec3 (0.25, -0.1, 0.), 0.25, 0.05, 0.), 0.3 - q.y);\n    DMINQ (idFr);\n    d = min (SmoothMax (abs (PrCapsDf (q, 0.3 * (1. - 0.5 * q.z * q.z), 0.9)) - 0.02,\n       abs (q.z + 0.1) - 0.55, 0.02), PrCylDf (q, 0.28, 0.25));\n    s = q.z + 0.2;\n    d = max (min (d, PrCapsDf (q + vec3 (0., 0., 0.2), 0.25 * (1. - 2. * s * s), 0.7)),\n       - PrCylDf (vec3 (q.xy, q.z + 0.8), 0.07, 0.2));\n    DMINQ (idEng);\n  }\n  ww = vec2 (1.3, 0.85);\n  q = p;\n  q.x = abs (q.x);\n  q.yz -= vec2 (0.8, -5.8);\n  q.xy = Rot2Cs (q.xy, csWt.xy);\n  q.xz = Rot2Cs (q.xz, csWt.zw);\n  d = min (ww.x - abs (abs (p.x) - ww.x), abs (PrBox2Df (vec2 (abs (p.x) - 1.7,\n     q.z - 0.07 * q.x + 0.6), vec2 (0.7, 0.25))));\n  t = ww.y * (1. - 0.25 * q.x / ww.x);\n  s = (q.z - 0.1) / ww.y;\n  d = SmoothMax (PrCaps2Df (q.yz, 0.12 * (t - s * s), t), - d, 0.03);\n  DMINQ (idWngT);\n  ww = vec2 (1.5, 0.65);\n  q = p;\n  q.x = abs (q.x);\n  q.xy = Rot2Cs (q.xy, sin (drpWt + vec2 (0.5 * pi, 0.)));\n  q -= vec3 (2.7, 0.8, -6.9);\n  t = ww.y * (1. - 0.25 * abs (q.y) / ww.x);\n  s = (q.z + 0.1 * abs (q.y) / ww.x - 0.2) / ww.y;\n  d = SmoothMax (PrCaps2Df (vec2 (q.x, q.z + 0.1 * abs (q.y) / ww.x), 0.1 * (t - s * s), t),\n     abs (q.y - 0.35 * ww.x) - 0.65 * ww.x, 0.06);\n  d = SmoothMax (d, - abs (PrBox2Df (vec2 (q.y - 0.8, q.z + 0.3), vec2 (0.5, 0.2))), 0.03);\n  DMINQ (idFin);\n  q.z -= -0.3;\n  d = PrCapsDf (q, 0.05, 0.2);\n  DMINQ (idFr);\n  if (wlDown) {\n    q = p;\n    q.yz -= vec2 (-1., 0.4);\n    t = 0.45;\n    s = abs (q.z) - 3.5 * t;\n    q.z = mod (q.z + 0.5 * t, t) - 0.5 * t;\n    q.x = abs (q.x) - 0.5;\n    d = max (PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.09), 0.16, 0.03, 0.02), s);\n    DMINQ (idWhl);\n    d = max (min (PrCylDf (q.yzx, 0.05, 0.09), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2)), s);\n    DMINQ (idLeg);\n    q = p;\n    q.x = abs (q.x);\n    q -= vec3 (0.2, -1.06, 4.8);\n    d = PrRoundCylDf (vec3 (q.yz, abs (q.x) - 0.07), 0.1, 0.03, 0.01);\n    DMINQ (idWhl);\n    d = min (PrCylDf (q.yzx, 0.05, 0.07), PrCylDf (vec3 (q.xz, q.y - 0.2), 0.03, 0.2));\n    DMINQ (idLeg);\n  }\n  return 0.6 * szFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 40; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nfloat ExObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  q = p;\n  q -= vec3 (14.5, 0.35, 8.);\n  d = PrRoundCylDf (q, 0.28, 0.04, 4.);\n  d = max (d, - dot (vec2 (q.z, dot (q.xy, cos (2. * pi * floor (16. * (atan (q.y, - q.x) / (2. * pi) +\n     0.5) + 0.5) / 16. + vec2 (0., 0.5 * pi)))), sin (-0.4 * pi + vec2 (0.5 * pi, 0.))) - 1.27);\n  DMINQ (1);\n  q = p;\n  q.yz -= vec2 (-0.1, 4.);\n  d = max (PrRoundBoxDf (q, vec3 (pgSize + vec3 (1., 0.1, 1.)), 0.03), - PrBox2Df (q.xz, pgSize.xz));\n  DMINQ (2);\n  return dMin;\n}\n\nfloat ExObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 80; j ++) {\n    d = ExObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ExObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ExObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ExObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ExObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.1 * d, h));\n    d += h;\n    if (sh < 0.05 || d > dstFar) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShGrid (vec2 p, vec2 g, int stag)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (stag > 0 && 2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.05, 0.1, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.3 * smoothstep (0.3, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.xy, 1. - 0.1 * sq.x * sq.y).xzy;\n}\n\nvec2 ExBlkHit (vec3 ro, vec3 rd)\n{\n  vec3 v, tm, tp, u, fcBlk;\n  vec2 qBlk;\n  float dn, df, bSize;\n  bSize = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n    u = (v + dn) * rd;\n    qBlk = vec2 (dot (u.zxy, fcBlk), dot (u.yzx, fcBlk)) / bSize;\n  } else qBlk = vec2 (0.);\n  return qBlk;\n}\n\nvec4 BlkHit (vec3 ro, vec3 rd, vec3 bSize)\n{\n  vec3 v, tm, tp, fcBlk;\n  vec2 qBlk;\n  float dMin, dn, df;\n  dMin = dstFar;\n  if (rd.x == 0.) rd.x = 0.001;\n  v = ro / rd;\n  tp = bSize / abs (rd) - v;\n  tm = - tp - 2. * v;\n  dn = Maxv3 (tm);\n  df = Minv3 (tp);\n  if (df > 0. && dn < df) {\n    dMin = dn;\n    fcBlk = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  }\n  return vec4 (dMin, fcBlk);\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4, colY4, colB4;\n  vec2 s;\n  float t;\n  col4 = vec4 (1., 1., 0.95, 0.2);\n  colY4 = vec4 (0.8, 0.8, 0., 0.2);\n  colB4 = vec4 (0.2, 0.2, 1., 0.2);\n  if (idObj == idFus) {\n    col4 = mix (colB4, col4, smoothstep (0.07, 0.09, abs (qHit.y + 0.6)));\n    col4 = mix (colY4, col4, smoothstep (0.07, 0.09, abs (qHit.y + 0.35)));\n    if (PrCylDf (qHit - vec3 (0., 0., 0.4), 0.98, 1.7) < 0. ||\n       abs (qHit.x) < 0.4 && qHit.y < 0. && PrCylDf (qHit - vec3 (0., 0., 4.7), 0.93, 0.3) < 0.)\n       col4 *= vec4 (vec3 (0.2), 0.);\n    if (! wlDown && qHit.y < 0.) col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.012, \n       min (abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.45) - 0.1, qHit.z - 0.4), vec2 (0.1, 1.6))),\n       abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 0.2) - 0.05, qHit.z - 4.8), vec2 (0.05, 0.2)))));\n    col4 *= 0.7 + 0.3 * smoothstep (0.008, 0.01, abs (PrRoundBox2Df (qHit.yz - vec2 (-0.4, 3.5),\n       vec2 (0.3, 0.15), 0.05)));\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.4 && abs (qHit.y - 0.45) < 0.07 && abs (abs (qHit.x) - 0.2) > 0.03 &&\n       abs (abs (qHit.z - 1.35) - 0.2) > 0.03) col4 = vec4 (0.5, 0.5, 0.5, -1.);\n  } else if (idObj == idEng) {\n    t = length (qHit.xy);\n    if (PrCapsDf (qHit, 0.3 * (1. - 0.5 * qHit.z * qHit.z), 0.85) < 0.) {\n      if (qHit.z > 0. && t < 0.14) col4 = vec4 (1., 0., 0., 0.2);\n      else col4 *= vec4 (vec3 (0.3), 0.);\n    } else {\n      if (abs (qHit.z + 0.1) > 0.5) col4 = colY4;\n      else col4 = mix (colB4, col4, smoothstep (0.02, 0.04, abs (qHit.z - 0.3)));\n    }\n  } else if (idObj == idWngM) {\n    t = qHit.z + 0.1 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.03, 0.05, abs (t - 1.2)));\n    col4 = mix (colY4, col4, smoothstep (0.03, 0.05, abs (t - 1.)));\n    if (qHit.y < 0.) {\n      if (abs (abs (qHit.x) - 3.9) < 2.1) col4 *= 0.8 + 0.2 *\n         smoothstep (0.008, 0.012, abs (qHit.z - 0.1 * abs (qHit.x) + 1.));\n    } else {\n      s = Rot2D (qHit.xz - vec2 (3.5, -0.3), -0.1 * pi);\n      s.x = abs (abs (s.x) - 0.8) - 0.3;\n      col4 *= 0.8 + 0.2 * smoothstep (0.008, 0.012, abs (PrBox2Df (s, vec2 (0.3, 0.15))));\n    }\n  } else if (idObj == idWngT) {\n    t = qHit.z + 0.15 * abs (qHit.x);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.04, abs (t - 0.7)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.04, abs (t - 0.6)));\n  } else if (idObj == idFin) {\n    t = qHit.z + 0.15 * abs (qHit.y);\n    col4 = mix (colB4, col4, smoothstep (0.02, 0.04, abs (t - 0.4)));\n    col4 = mix (colY4, col4, smoothstep (0.02, 0.04, abs (t - 0.3)));\n  } else if (idObj == idWhl) {\n    col4 = mix (vec4 (0.7, 0.7, 0.75, 0.1), vec4 (0.3, 0.3, 0.3, 0.),\n       step (0.07, length (qHit.yz)));\n  } else if (idObj == idLeg) {\n     col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n  }\n  return col4;\n}\n\nvoid FlyerParms ()\n{\n  angWm = 0.1 * pi;\n  drpWm = 0.02 * pi;\n  csWm = vec4 (sin (drpWm + vec2 (0.5 * pi, 0.)), sin (angWm + vec2 (0.5 * pi, 0.)));\n  angWt = 0.12 * pi;\n  drpWt = -0.03 * pi;\n  csWt = vec4 (sin (drpWt + vec2 (0.5 * pi, 0.)), sin (angWt + vec2 (0.5 * pi, 0.)));\n  dwr = vec3 (1.4, 0., 0.);\n  dwr.xy = Rot2Cs (dwr.xy, sin (- drpWm + vec2 (0.5 * pi, 0.)));\n  dwr.xz = Rot2Cs (dwr.xz, sin (-0.7 * angWm + vec2 (0.5 * pi, 0.)));\n  dwf = vec3 (1.5, 0., 0.);\n  dwf.xy = Rot2Cs (dwf.xy, sin (-0.9 * drpWm + vec2 (0.5 * pi, 0.)));\n  dwf.xz = Rot2Cs (dwf.xz, sin (-1.3 * angWm + vec2 (0.5 * pi, 0.)));\n  wlDown = true;\n}\n\nvec3 SkShowScene (vec3 ro, vec3 rd, vec2 uv)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n    col = vec3 (0.95) * Maxv3 (col4.rgb);\n    col *= (0.95 + 0.05 * Noisefv2 (Rot2D (uv, 0.2 * pi) * vec2 (8., 128.))) *\n       (0.5 + 0.5 * max (dot (vn, ltDirS), 0.));\n  } else {\n    col = vec3 (1.);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvec3 SkMain (vec2 fCoord, float vp)\n{\n  mat3 vuMat;\n  vec3 ro, rd, col, flPosT;\n  vec2 uv, csFlT;\n  float el, az, szFacT;\n  szFacT = szFac;\n  uv = fCoord / vec2 (5., 5.5);\n  flPosT = flPos;\n  flPos = vec3 (0.);\n  csFlT = csFl;\n  csFl = sin (0. + vec2 (0.5 * pi, 0.));\n  if (vp == 0.) {\n    szFac = 0.75;\n    uv -= vec2 (0., -1.);\n    el = -0.11 * pi;\n    az = pi;\n  } else if (vp == 1.) {\n    szFac = 0.6;\n    uv -= vec2 (0.25, -1.1);\n    el = 0.42 * pi;\n    az = 0.25 * pi;\n  } else if (vp == 2.) {\n    szFac = 0.75;\n    uv -= vec2 (-0.1, -1.3);\n    el = -0.1 * pi;\n    az = 0.5 * pi;\n  } else if (vp == 3.) {\n    szFac = 0.6;\n    uv -= vec2 (0.25, -1.05);\n    el = -0.5 * pi;\n    az = 0.25 * pi;\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., -5., -20.);\n  rd = vuMat * normalize (vec3 (uv, 4.2));\n  ltDirS = vuMat * normalize (vec3 (0.5, 1., -0.5));\n  col = SkShowScene (ro, rd, uv);\n  szFac = szFacT;\n  flPos = flPosT;\n  csFl = csFlT;\n  return clamp (col, 0., 1.);\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, db4;\n  vec3 col, vn, qHitEx;\n  vec2 qBlk, q, sq;\n  float dstObj, dstExObj, sh, r, z, a;\n  int idObjEx;\n  bool isBg;\n  FlyerParms ();\n  szFac = 1.3;\n  a = 1.3 * pi;\n  flPos = vec3 (1.1, 1.2, 1.);\n#if AA\n  flPos.xz += 3. * SmoothBump (0.25, 0.75, 0.25, mod (0.04 * tCur, 1.)) *\n     Rot2D (vec2 (0., 1.), - a);\n#endif\n  csFl = sin (a + vec2 (0.5 * pi, 0.));\n  pgSize = vec3 (15., 0.1, 10.);\n  isBg = false;\n  dstExObj = ExObjRay (ro, rd);\n  idObjEx = idObj;\n  qHitEx = qHit;\n  dstObj = ObjRay (ro, rd);\n  db4 = BlkHit (ro - vec3 (0., -0.1, 4.), rd, pgSize);\n  if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n    if (dstObj < dstExObj) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      qBlk = mod (2. * ExBlkHit (ro, reflect (rd, vn)), 1.);\n      col4 = ObjCol ();\n    } else {\n      ro += dstExObj * rd;\n      vn = ExObjNf (ro);\n      if (idObjEx == 1) {\n        r = length (qHit.xy);\n        col4 = mix (vec4 (0.9, 0.7, 0.1, 0.1), vec4 (1., 0.9, 0.1, 0.01), step (0.34, r));\n        col4 = mix (vec4 (0.3, 0.3, 0.3, 0.1), col4, step (0.18, r));\n        col4 = mix (vec4 (0.8, 0.4, 0.1, 0.), col4, step (qHit.z, 3.5));\n        z = abs (qHit.z - 3.2);\n        col4 = mix (vec4 (0.9, 0.9, 1., 0.3), col4, step (0.3, z));\n        col4 = mix (vec4 (0.5, 0.5, 0.5, 0.3), col4, step (0.03, abs (z - 0.27)));\n      } else if (idObjEx == 2) {\n        col4 = vec4 (0.5, 0.3, 0.2, 0.) * (0.9 + 0.1 * Noisefv2 (32. * qHit.xz));\n      }\n    }\n  } else if (db4.x < dstFar) {\n    ro += db4.x * rd;\n    vn = db4.yzw;\n    q = ro.xz - vec2 (0., 4.);\n    if (vn.y > 0.5 && PrBox2Df (q, pgSize.xz - 0.96) < 0.) {\n      sq = sign (q);\n      col = SkMain (q - 0.5 * sq * pgSize.xz, sq.y + 1. + 0.5 * (sq.x + 1.));\n      if (Minv3 (col) > 0.95) {\n        q = smoothstep (0.02, 0.05, abs (mod (q + 0.5, 1.) - 0.5));\n        col = mix (vec3 (0.6, 0.9, 0.8), vec3 (0.97, 0.97, 1.), min (q.x, q.y));\n      }\n    } else {\n      col = vec3 (0.97, 0.97, 1.) * (0.8 + 0.2 * step (0.5, vn.y));\n      sh = 1.;\n    }\n  } else {\n    isBg = true;\n  }\n  if (! isBg) {\n    sh = min (ObjSShadow (ro + 0.01 * vn, ltDir), ExObjSShadow (ro + 0.01 * vn, ltDir));\n    if (min (dstObj, dstExObj) < min (db4.x, dstFar)) {\n      if (col4.a < 0.) col4.a = 0.2;\n      col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.);\n      col += col4.a * vec3 (0.2) * (0.5 + 0.5 * SmoothBump (0.25, 0.75, 0.05, qBlk.x) *\n         SmoothBump (0.25, 0.75, 0.05, qBlk.y));\n    } else {\n      col *= 0.3 + 0.7 * sh * max (dot (vn, ltDir), 0.);\n    }\n  } else {\n    qBlk = mod (8. * ExBlkHit (ro, rd), 1.);\n    col = vec3 (0.5, 0.4, 0.4) * (0.05 + 0.245 * (rd.y + 1.) * (rd.y + 1.)) +\n       vec3 (0.2) * (0.9 + 0.1 * SmoothBump (0.25, 0.75, 0.1, qBlk.x) *\n       SmoothBump (0.25, 0.75, 0.1, qBlk.y));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.25 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.8 * pi * mPtr.y;\n  }\n  el = clamp (el, -0.5 * pi, -0.05 * pi);\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 1.5, -40.);\n  dstFar = 100.;\n  ltDir = vuMat * normalize (vec3 (0.7, 1., -0.7));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), 4.7));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrCaps2Df (vec2 p, float r, float h)\n{\n  return length (p - vec2 (0., clamp (p.y, - h, h))) - r;\n}\n\nfloat PrRoundCylDf (vec3 p, float r, float rt, float h)\n{\n  return length (max (vec2 (length (p.xy) - r, abs (p.z) - h), 0.)) - rt;\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b - h * r, a, h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjBzG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1410, 1410, 1432, 1432, 5208], [5210, 5210, 5243, 5243, 5426], [5428, 5428, 5449, 5449, 5704], [5706, 5706, 5743, 5743, 5985], [5987, 5987, 6011, 6011, 6516], [6518, 6518, 6553, 6553, 6737], [6739, 6739, 6762, 6762, 7019], [7021, 7021, 7060, 7060, 7304], [7306, 7306, 7346, 7346, 7710], [7712, 7712, 7746, 7746, 8190], [8192, 8192, 8236, 8236, 8592], [8594, 8594, 8610, 8610, 11366], [11368, 11368, 11388, 11388, 11994], [11996, 11996, 12042, 12042, 12444], [12446, 12446, 12483, 12483, 13427], [13429, 13429, 13464, 13464, 16358], [16360, 16360, 16413, 16413, 17401], [17403, 17403, 17435, 17435, 17535], [17537, 17537, 17583, 17583, 17630], [17632, 17632, 17665, 17665, 17754], [17756, 17756, 17803, 17803, 17850], [17852, 17852, 17894, 17894, 17945], [17947, 17947, 17990, 17990, 18054], [18056, 18056, 18100, 18100, 18160], [18162, 18162, 18219, 18219, 18295], [18297, 18297, 18319, 18319, 18357], [18359, 18359, 18381, 18381, 18419], [18421, 18421, 18466, 18466, 18558], [18560, 18560, 18605, 18605, 18643], [18645, 18645, 18702, 18702, 18785], [18787, 18787, 18823, 18823, 19029], [19031, 19031, 19061, 19061, 19174], [19176, 19176, 19207, 19207, 19271], [19305, 19305, 19329, 19329, 19441], [19443, 19443, 19468, 19468, 19654]], "test": "untested"}
{"id": "stBBzy", "name": "particles graph", "author": "makscee", "description": "Randomly rendering particles across a sin graph", "tags": ["2d", "particles"], "likes": 2, "viewed": 255, "published": 3, "date": "1652365126", "time_retrieved": "2024-07-30T16:49:09.913538", "image_code": "const float pi = 3.14159;\n\nvec3 p_colors[3];\nconst int p_count = 200;\nconst float p_radius = 0.02;\nconst float p_glow_radius = 0.6;\n\nvec4 alphaBlend(vec4 c1, vec4 c2)\n{\n    return vec4(\n        mix(c1.r, c2.r, c2.a),\n        mix(c1.g, c2.g, c2.a),\n        mix(c1.b, c2.b, c2.a),\n        clamp(max(c1.a, c2.a) + c1.a * c2.a * .3, 0., 1.));\n}\n\nvec2 N22(vec2 p) \n{\n  vec3 a = fract(p.xyx*vec3(123.34, 234.34, 345.65));\n  a += dot(a, a+34.45);\n  return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nfloat rand(int i)\n{\n    return N22(vec2(i)).x;\n}\n\nvec3 mix3Colors(float t, vec3 colors[3])\n{\n    t += float(t < 0.);\n    int colorInd = int(t * 3.);\n    vec3 c1 = colors[colorInd];\n    vec3 c2 = colors[(colorInd + 1) % 3];\n    return mix(c1, c2, t * 3. - float(colorInd));\n}\n\nvec2 p_graph(float t)\n{\n    float scale = sin(iTime * .5) * 8.;\n    t -= floor(t + 0.5);\n    t *= 10.;\n    return vec2(t, sin(t * scale));\n}\n\nvec2 p_positionOverT(int i, float t)\n{\n    const float part = 0.25;\n    float r0 = rand(i);\n    float r1 = rand(i + 1);\n    return float(r1 < part) * (vec2(fract(r0 + iTime * .1) * 10. - 5., sign(r1 - part * .5)))\n        + float(r1 > part) * p_graph(r0 - 0.5 + t * 1.);\n}\n\nvec3 p_color(int i)\n{\n    return mix3Colors(rand(i), p_colors);\n}\n\nfloat p_glow(float dist)\n{\n    return smoothstep(p_glow_radius, 0., dist - p_radius) * .3;\n}\n\nvec4 p_renderParticle(vec2 uv, int i, float t)\n{\n    vec2 position = p_positionOverT(i, t);\n    float dist = distance(uv, position);\n    float alpha = max(float(dist < p_radius), p_glow(dist));\n    return vec4(p_color(i), alpha);\n}\n\nbool p_discardCheck(vec2 uv, float t)\n{\n    return abs(uv.y) - p_radius - p_glow_radius > 1.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    p_colors[0] = vec3(0.862, 0.078, 0.235);\n    p_colors[1] = vec3(0.541, 0.168, 0.886);\n    p_colors[2] = vec3(0.117, 0.564, 1);\n\n    float t = iTime * .1;\n    fragCoord -= iResolution.xy / 2.0;\n    vec2 uv = fragCoord/iResolution.x*10.0;\n    if (p_discardCheck(uv, t))\n    {\n        fragColor = vec4(0);\n        return;\n    }\n\n    vec4 col = vec4(0);\n    for (int i = 0; i < p_count; i++)\n        col = alphaBlend(col, p_renderParticle(uv, i, t));\n    fragColor = alphaBlend(vec4(0), col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBBzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[133, 133, 168, 168, 340], [342, 342, 361, 361, 481], [483, 483, 502, 502, 531], [533, 533, 575, 575, 757], [759, 759, 782, 782, 899], [901, 901, 939, 939, 1173], [1175, 1175, 1196, 1196, 1240], [1242, 1242, 1268, 1268, 1334], [1336, 1336, 1384, 1384, 1567], [1569, 1569, 1608, 1608, 1664], [1666, 1666, 1721, 1721, 2216]], "test": "untested"}
{"id": "flSfRG", "name": "Quad interpolation test", "author": "Suslik", "description": "A simple test of reverse bilinear interpolation", "tags": ["quadinterpolation"], "likes": 4, "viewed": 336, "published": 3, "date": "1652345209", "time_retrieved": "2024-07-30T16:49:10.756284", "image_code": "vec2 SolveQuadratic(float A, float B, float C)\n{\n    float D = B * B - 4.0f * A * C;\n    if(D < 1e-5f) return vec2(-1.0f);\n    float sqrtD = sqrt(D);\n    return (vec2(-B) + vec2(-sqrtD, sqrtD)) / (2.0f * A);\n}\n\nvec2 SolveQuadraticOrLinear(float A, float B, float C)\n{\n    if(abs(A) > 1e-5f) return SolveQuadratic(A, B, C);\n    if(abs(B) > 1e-5f) return vec2(-C / B);\n    return vec2(-1.0f);\n}\n\nfloat cross2(vec2 a, vec2 b)\n{\n    return a.x * b.y - a.y * b.x;\n}\n\n//solves either of the two (depending which k[] is better)\n//c[0] + k[0] * x = 0;\n//c[1] + k[1] * x = 0;\nfloat SolveBestLinear(vec2 c, vec2 k)\n{\n    return abs(k[0]) > abs(k[1]) ? (-c[0] / k[0]) : (-c[1] / k[1]);\n}\n\n\n//solves system:\n//c[0] + mx[0] * rx + my[0] * ry + mxy[0] * rx * ry = 0;\n//c[1] + mx[1] * rx + my[1] * ry + mxy[1] * rx * ry = 0;\nvec2 SolveQuadratic2(\n    vec2 c, vec2 mx, vec2 my, vec2 mxy)\n{\n    vec2 rx = SolveQuadraticOrLinear(cross2(mxy, mx), cross2(mxy, c) + cross2(my, mx), cross2(my, c));\n    \n    vec2 uv;\n    uv.x = rx.x;\n    uv.y = SolveBestLinear(c + mx * uv.x, my + mxy * uv.x);\n    \n    //this part is stolen from iq's: https://www.shadertoy.com/view/lsBSDm\n    //as i simply gave up on the part that figures out which root to use\n    if(!(uv.x > 0.0f && uv.x < 1.0f && uv.y > 0.0f && uv.y < 1.0f))\n    {\n        uv.x = rx.y;\n        uv.y = SolveBestLinear(c + mx * uv.x, my + mxy * uv.x);\n    }\n    \n    return uv;\n}\n\n//p00 -- lower left, p01 -- lower right, p10 -- upper left, p11 -- upper right\nvec2 GetQuadInterpWeights(vec3 p00, vec3 p01, vec3 p10, vec3 p11, vec3 p)\n{\n    vec3 c = p00 - p;\n    vec3 mx = p01 - p00;\n    vec3 my = p10 - p00;\n    vec3 mxy = p00 - p01 + p11 - p10;\n    \n    vec3 proj0 = mx / (1e-7f + dot(mx, mx)); //these are arbitrary vectors hopefully not perpendicular to mx/my\n    vec3 proj1 = my / (1e-7f + dot(my, my)); //so might as well scale them to produce normalized products\n    \n    return SolveQuadratic2(\n        vec2(dot(c, proj0), dot(c, proj1)),\n        vec2(dot(mx, proj0), dot(mx, proj1)),\n        vec2(dot(my, proj0), dot(my, proj1)),\n        vec2(dot(mxy, proj0), dot(mxy, proj1)));\n}\n\nvec2 LoopBouncingBox(vec2 coord, vec2 box_size)\n{\n    vec2 phase2f = coord / box_size;\n    vec2 ratio = fract(phase2f);\n    vec2 phase_mirroring = floor(fract(phase2f * 0.5f) + 0.5f); //0.0f or 1.0f depending whether this period is mirrored\n    \n    return mix(ratio, vec2(1.0f) - ratio, phase_mirroring) * box_size;\n}\n\nfloat LineSdf(vec2 p0, vec2 p1, vec2 p)\n{\n    float dist = length(p0 - p);\n    dist = min(dist, length(p1 - p));\n    \n    vec2 delta = p1 - p0;\n    float sqrlen = dot(delta, delta);\n    float proj = dot(p - p0, delta);\n    \n    if(proj > 0.0f && proj < sqrlen)\n    {\n        vec2 proj_pos = p0 + delta * (proj / sqrlen);\n        dist = min(dist, length(proj_pos - p));\n    }\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 p00 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(10.0f, 50.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p01 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(90.0f, 40.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p10 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(30.0f, 10.0f) * iTime, iResolution.xy), 0.0f);\n    vec3 p11 = vec3(LoopBouncingBox(vec2(100.0f, 105.0f) + vec2(150.0f, 50.0f) * iTime, iResolution.xy), 0.0f);\n    \n    /*p00 = vec3(100.0f, 100.0f, 0.0f);\n    p01 = vec3(410.0f, 100.0f, 0.0f);\n    p11 = vec3(400.0f, 200.0f, 0.0f);\n    p10 = vec3(100.0f, 200.0f, 0.0f);*/\n    \n    vec2 r = GetQuadInterpWeights(p00, p01, p10, p11, vec3(fragCoord, 0.0f));\n    \n    fragColor = vec4(0.5f);\n\n    if(r.x >= 0.0f && r.x <= 1.0f && r.y >= 0.0f && r.y <= 1.0f)\n        fragColor = vec4(fract(r), 0.0f, 1.0f);\n        \n    if(LineSdf(p00.xy, p01.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p01.xy, p11.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p11.xy, p10.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n    if(LineSdf(p10.xy, p00.xy, fragCoord.xy) < 2.0f) fragColor.rgb += vec3(0.5f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSfRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 48, 48, 209], [211, 211, 267, 267, 392], [394, 394, 424, 424, 460], [462, 567, 606, 606, 676], [679, 810, 873, 873, 1411], [1413, 1492, 1567, 1567, 2120], [2122, 2122, 2171, 2171, 2440], [2442, 2442, 2483, 2483, 2835], [2837, 2837, 2894, 2894, 4069]], "test": "untested"}
{"id": "flSBDw", "name": "Voronoi broke the picture", "author": "iapafoto", "description": "Simple voronoi Split as operator function in one single shader\n", "tags": ["2d", "voronoi", "worley", "cells", "polygon"], "likes": 14, "viewed": 444, "published": 3, "date": "1652306209", "time_retrieved": "2024-07-30T16:49:11.518247", "image_code": "// Created by Sebastien Durand - 2022\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//-----------------------------------\n\n// get ids in a cyclic order to i,j neigbourg elements\n#define ID_POS(x) clamp(abs(4.-8.*fract(vec2(x+3,x-3)/8.))-2.,-1.,1.)\n\nmat2 mRot;\n\nmat2 rot(float a) {\n    return mat2(cos(a), sin(a), -sin(a), cos(a));\n}\n\nvec2 hash2(vec2 p) {\n    vec2 o = .3*texture(iChannel0, (p+0.5)/256.0,-100.0).xy;\n    o = .3*cos(.5*(3.+o)*6.3 + o*6.2831853);\n    return o;\n}\n\n//-----------------------------------\n// Minimalist voronoi distance for one cell\n// Inexact outside of cells\n// Generalisable to 3D cells\n//-----------------------------------\nvec3 sdVoronoiCell(in vec2 p, in vec2 cellId ) {\n    float md = 8.0;    \n    vec2 mr = hash2(cellId);\n    for(int i=0; i<8; i++) {\n        vec2 g = ID_POS(i),\n             r = g + hash2(cellId + g);\n        md = min(md, dot(.5*(mr+r)-p, normalize(r-mr)));\n    }\n    return vec3(-md, mr-p);\n}\n\nfloat opCutVoronoi(inout vec2 p, float k) {\n    k += 1.;\n    float d = 999.;\n    vec2 posTxt = p;\n    for( int j=-1; j<=1; j++)\n    for( int i=-1; i<=1; i++) {\n         vec2 g = vec2(i,j) + floor(p/k);\n         if (length(k*g-p)<1.5) { // do it only on neighbourhood\n             vec3 v = sdVoronoiCell((p-k*g)*mRot, g);\n             if (d>v.x) {\n                 posTxt = (p-k*g)*mRot+g;\n             }\n             d  = min(d,v.x);\n         }\n    }\n    p = posTxt;\n    return d;\n}\n\n\n//-----------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord) {\n    float time = mod(iTime, 10.);\n    \n    // Noisy background\n    vec2 q = fragCoord.xy/iResolution.xy;\n    float h = dot(vec3(q,1.),vec3(127.1,311.7,758.5453));\t\n\tvec3 col = .75*(vec3(.0512) + .05*fract(sin(h)*43758.5453123));\n    \n    // Animation ticks\n    float a5 = 1.25*smoothstep(28.,32.,time);\n           \n    // Coords on screen\n    float sc = step(512., iResolution.y)*4. + 6., // Scale differently for fullscreen\n\t      ss = (a5+sc) / iResolution.y; // Size of 1 pixel\n    vec2 p = (fragCoord.xy - iResolution.xy*.5)*ss;\n    \n    // checker\n    p.x += .1*cos(50.*iTime)*(smoothstep(1.,2., time)-smoothstep(2.,4., time));\n    // space\n    float k = .5*(smoothstep(3.,6., time)-smoothstep(6.,7., time)); \n    // rotation\n    float a = 6.28*smoothstep(5.,6.5, time);  \n    mRot = rot(a);\n    \n    p *= 1.-.4*a5;\n    p += (1.5+.5*cos(.5*iTime))*a5;\n    \n    // The selected cell\n    vec2 posTxt = p;\n    float dCut = opCutVoronoi(posTxt, k);\n       \n    col = mix(vec3(0.), sqrt(col), .5*smoothstep(.0, 0.2, abs(dCut)+.1));    \n    col = mix(col, texture(iChannel1, .5+posTxt*.1).xyz, smoothstep(.01, 0.,dCut));\n\n    // Post prod\n    col = pow(col, vec3(.7));\n    col *= pow(16.*q.x*q.y*(1.-q.x)*(1.-q.y), .5);   \n    fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSBDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[302, 302, 321, 321, 373], [375, 375, 395, 395, 517], [519, 696, 744, 744, 987], [989, 989, 1032, 1032, 1471], [1474, 1512, 1568, 1568, 2821]], "test": "untested"}
{"id": "fl2fWw", "name": "Black&WhiteImageColor", "author": "Evgeniy2030", "description": "Black&WhiteImageColor", "tags": ["blackwhiteimagecolor"], "likes": 0, "viewed": 164, "published": 3, "date": "1652293658", "time_retrieved": "2024-07-30T16:49:12.296167", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 xy = fragCoord.xy / iResolution.xy; //    \n    \n    vec4 texColor = texture(iChannel0,xy); //  iChannel0    xy\n    \n    float gray = texColor.r * 0.299 + texColor.g * 0.587 + texColor.b * 0.114;\n    texColor.r = gray;\n    texColor.g = gray; // 4     -\n    texColor.b = gray;\n\n    \n    fragColor = texColor; //    \n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2fWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 639]], "test": "untested"}
{"id": "stSfWw", "name": "Balmer RGB", "author": "josemorval", "description": "Just a quick test. Fork from Alan Zucconi's https://www.shadertoy.com/view/ls2Bz1", "tags": ["rgb", "physics", "spectral", "atomic"], "likes": 1, "viewed": 240, "published": 3, "date": "1652293390", "time_retrieved": "2024-07-30T16:49:13.047159", "image_code": "\nfloat saturate (float x)\n{\n    return min(1.0, max(0.0,x));\n}\nvec3 saturate (vec3 x)\n{\n    return min(vec3(1.,1.,1.), max(vec3(0.,0.,0.),x));\n}\n\n// --- Spectral Zucconi --------------------------------------------\n// By Alan Zucconi\n// Based on GPU Gems: https://developer.nvidia.com/sites/all/modules/custom/gpugems/books/GPUGems/gpugems_ch08.html\n// But with values optimised to match as close as possible the visible spectrum\n// Fits this: https://commons.wikimedia.org/wiki/File:Linear_visible_spectrum.svg\n// With weighter MSE (RGB weights: 0.3, 0.59, 0.11)\nvec3 bump3y (vec3 x, vec3 yoffset)\n{\n\tvec3 y = vec3(1.,1.,1.) - x * x;\n\ty = saturate(y-yoffset);\n\treturn y;\n}\nvec3 spectral_zucconi (float w)\n{\n    // w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 cs = vec3(3.54541723, 2.86670055, 2.29421995);\n\tconst vec3 xs = vec3(0.69548916, 0.49416934, 0.28269708);\n\tconst vec3 ys = vec3(0.02320775, 0.15936245, 0.53520021);\n\n\treturn bump3y (\tcs * (x - xs), ys);\n}\n\n// --- Spectral Zucconi 6 --------------------------------------------\n\n// Based on GPU Gems\n// Optimised by Alan Zucconi\nvec3 spectral_zucconi6 (float w)\n{\n\t// w: [400, 700]\n\t// x: [0,   1]\n\tfloat x = saturate((w - 400.0)/ 300.0);\n\n\tconst vec3 c1 = vec3(3.54585104, 2.93225262, 2.41593945);\n\tconst vec3 x1 = vec3(0.69549072, 0.49228336, 0.27699880);\n\tconst vec3 y1 = vec3(0.02312639, 0.15225084, 0.52607955);\n\n\tconst vec3 c2 = vec3(3.90307140, 3.21182957, 3.96587128);\n\tconst vec3 x2 = vec3(0.11748627, 0.86755042, 0.66077860);\n\tconst vec3 y2 = vec3(0.84897130, 0.88445281, 0.73949448);\n\n\treturn\n\t\tbump3y(c1 * (x - x1), y1) +\n\t\tbump3y(c2 * (x - x2), y2) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float wl = uv.x*300.+400.;\n    \n    float s = texture(iChannel0,vec2(uv.x,0.)).r;\n    \n    //Uncomment when sound is not working\n    //s=1.;\n    \n    //Evaluate color at some wavelengths\n    vec3 col;\n    vec3 base = spectral_zucconi6(wl);\n    col = vec3(0.);\n    col += 3.*smoothstep(0.2,0.,abs(wl-410.0))*base;\n    col += 3.*smoothstep(0.2,0.,abs(wl-434.0))*base;\n    col += 3.*smoothstep(0.2,0.,abs(wl-486.0))*base;\n    col += 3.*smoothstep(0.2,0.,abs(wl-656.0))*base;\n    col += 0.1*smoothstep(10.5+10.*s,0.,abs(wl-410.0))*base*fract(13.11*iTime);\n    col += 0.1*smoothstep(10.5+10.*s,0.,abs(wl-434.0))*base*fract(14.11*iTime+0.1);\n    col += 0.1*smoothstep(10.5+10.*s,0.,abs(wl-486.0))*base*fract(12.11*iTime+0.2);\n    col += 0.1*smoothstep(10.5+10.*s,0.,abs(wl-656.0))*base*fract(15.11*iTime+0.3);\n    col *= 0.1+2.*smoothstep(0.,1.,s);\n    col += 0.15*base;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28930, "src": "https://soundcloud.com/lasers/yellow", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSfWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 62], [63, 63, 87, 87, 144], [146, 564, 600, 600, 673], [674, 674, 707, 744, 1003], [1077, 1127, 1161, 1195, 1663], [1666, 1666, 1723, 1723, 2665]], "test": "untested"}
{"id": "Nt2fWw", "name": "ColorI-1/2", "author": "Evgeniy2030", "description": "ColorI-1/2", "tags": ["colori12"], "likes": 0, "viewed": 148, "published": 3, "date": "1652293319", "time_retrieved": "2024-07-30T16:49:13.877938", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 xy = fragCoord.xy; //   \n\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    xy.x = xy.x / iResolution.x; //    \n    \n    xy.y = xy.y / iResolution.y;\n    //  x      0,      1\n\n    vec4 solidRed = vec4(1.0,0.0,0.0,1.0); // \n    \n    vec4 solidBlack = vec4(0.0,0.0,0.0,1.0); //   \n    \n    if(xy.x > 0.5) {  // ,     !   ( -  , y -  )\n    \n    //solidBlack.r = 1.0; //    1.0 (.)\n    solidBlack.r = xy.x; // \n    \n    }\n    // Output to screen\n    fragColor = solidBlack;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1176]], "test": "untested"}
{"id": "7lBfWm", "name": "more (i*i)/j", "author": "eiffie", "description": "Makes a good random number generator too! ... If you're the government.", "tags": ["iij"], "likes": 15, "viewed": 380, "published": 3, "date": "1652283468", "time_retrieved": "2024-07-30T16:49:14.762573", "image_code": "//even more (i*i)%j\nvec3 cmap(float a){return abs(sin(vec3(a,a*.4,a*4.)));}\nvoid map(inout vec4 c, vec3 p){\n  ivec3 ip=ivec3(floor(p));ip*=ip;int j=int((iTime-30.)*3.);\n  float a=float((ip.x%j)*(ip.y%j)*(ip.z%j));\n  vec3 col=cmap(a);\n  p=fract(p)-vec3(.5);\n  float d=length(p*(.1+.9*col));\n  c+=vec4(col*exp(-d*50.),d);\n}\nvec3 scene(vec3 ro,vec3 rd){\n  vec4 c=vec4(0);\n  for(int i=0;i<100;i++){\n    map(c,ro+rd*c.a);\n  }\n  return c.rgb;\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  float tim=mod(iTime,75.);\n  if(tim<30. || tim>60.){\n    vec2 m=mod(U,vec2(4));\n    int t=int(floor(tim*3.))%256;\n    ivec2 v=ivec2((floor(U/4.)-iResolution.xy/8.)*(iTime>15.?cos(sin(iTime*iTime*.001)):1.));\n    v+=ivec2(t/2);v*=v;v.x=v.x%t;v.y=v.y%t;v+=ivec2(1);\n    float a=float(v.x*v.y);\n    O=vec4(sin(a+5.),sin(a),sin(a+.4),1.)*((m.x<1. || m.y<1.)?0.4:(m.y>3.)?1.:.75);\n  }else{\n    float t=iTime-30.;\n    U+=sin(t*t*.001)*U.yx;\n    vec3 rd=normalize(vec3((U-.5*iResolution.xy)/iResolution.x,1.)),ro=vec3(13.3,13.7,t*10.);\n    O=vec4(scene(ro,rd),1.);\n  }\n}", "image_inputs": [], "sound_code": "//Euler Beats (i*i*n)%d, d gives a cycle, n a pattern, i the note # 1,2,3...\n#define d 512\n#define pi 3.141592653\n#define bps 6.\nint scale(int note){int n2=note % 12;//shifts dissonant tones into scale\n if((n2==1)||(n2==3)||(n2==6)||(n2==8)||(n2==11))note=note-1;\n return note;\n}// mod of note number to frequency  from https://www.shadertoy.com/view/ldfSW2\nfloat ntof(int n){n=scale(n);return (n>0)?440.0 * pow(2.0, (float(n) - 67.0) / 12.0):0.0;}\nfloat spow(float n, float p){return sign(n)*pow(abs(n),p);}\nvec2 Sound(int n, float time, float p, int o){//(i*i*n)%d as a MIDI note shifted into a minor scale\n  int i=int(floor(time*bps))%d;//sin^p, o=MIDI note offset\n  i=(((i*((n*i)%d)))%d)/12;//being far too specific with the parens\n  return vec2(1.,1.+sin(time)*0.005)*spow(sin(ntof(i+o)*mod(time*pi,pi*2.)),p*fract(time*bps));\n}\nvec2 mainSound(int samp, float time){\n  return (Sound(7,time,4.,36)-Sound(9,time+bps/3.,2.,36).yx+fract(Sound(63,time+bps/2.,1.,48)*1.25)/3.)*.25;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 20, 39, 39, 75], [76, 76, 107, 107, 321], [322, 322, 350, 350, 438], [439, 439, 477, 477, 1042]], "test": "untested"}
{"id": "7lBBWm", "name": "Planet of Doubt!", "author": "Ashk4nX", "description": "A simple circle with color changing shader", "tags": ["color"], "likes": 0, "viewed": 154, "published": 3, "date": "1652282469", "time_retrieved": "2024-07-30T16:49:15.558445", "image_code": "vec3 sdfCircle(vec2 uv, float r) {\n  float x = uv.x;\n  float y = uv.y;\n  \n  float d = length(vec2(x, y)) - r;\n  \n  return d > 0. ? vec3(0.) : 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy; // <0,1>\n  uv -= 0.5;\n  uv.x *= iResolution.x/iResolution.y; // fix aspect ratio\n  \n  vec3 col = sdfCircle(uv, .2);\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBBWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 190], [192, 192, 249, 249, 457]], "test": "untested"}
{"id": "7lsBRr", "name": "Simplex Noise 3d", "author": "TinyTexel", "description": "https://en.wikipedia.org/wiki/Simplex_noise\n\ncamera controls via mouse + shift key", "tags": ["noise", "simplex"], "likes": 0, "viewed": 207, "published": 3, "date": "1652281748", "time_retrieved": "2024-07-30T16:49:16.770206", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    camera controls via mouse + shift key\n*/\n\n///////////////////////////////////////////////////////////////////////////\n//=======================================================================//\n\nfloat ReadKey      (int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(iChannel1, ivec2(keyCode, 2), 0).x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(iChannel0, ivec2(cx, cy), 0).w;}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nvec4 AA[8], BB[8], CC[8], DD[8];\nvec4 A0, B0, C0, D0;\nvec4 A1, B1, C1, D1;\n\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float);\nbool ImplicitRC(vec3, vec3, float, float, float, float, float, out float, out float, out float, inout vec3);\n    \n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\n\n//////////////////////////////////////////////////////////////////////////\n//======================================================================//\n\nfloat SimplexNoise(vec3 x, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n    vec3 v1 = min(m0.xyz, m1.yzx);\n    vec3 v2 = max(m0.xyz, m1.yzx);\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define DIR(x) normalize(Hash11x3(x, seed))\n     \n    vec4 d;\n\td.x = dot(DIR(xb + v0), off0);\n\td.y = dot(DIR(xb + v1), off1);\n\td.z = dot(DIR(xb + v2), off2);\n\td.w = dot(DIR(xb + v3), off3);    \n         \n    #undef DIR\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    \n    return dot(d, w * w * w) * 4.73;\n}\n\nfloat TriWave(float x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec2  TriWave(vec2  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec3  TriWave(vec3  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\nvec4  TriWave(vec4  x) { return abs(fract(x) * 2.0 - 1.0) * 2.0 - 1.0; }\n\nfloat SimplexNoise(vec3 x, float time, uint seed)\n{\n    // https://en.wikipedia.org/wiki/Simplex_noise\n    float F = 1.0/3.0;\n    float G = 1.0/6.0;\n    \n    vec3 xp = x + dot(x, vec3(1.0)) * F;\n    \n    vec3 xb = floor(xp);\n    vec3 xi = xp - xb;\n \n    vec3 m0 = step(0.0, xi - xi.zxy);\n    vec3 m1 = 1.0 - m0;\n    \n    vec3 v0 = vec3(0.0);\n    vec3 v1 = min(m0.xyz, m1.yzx);\n    vec3 v2 = max(m0.xyz, m1.yzx);\n    vec3 v3 = vec3(1.0);\n    \n    vec3 o = x - xb + dot(xb, vec3(1.0)) * G;\n    \n    vec3 off0 = o - v0 + 0.0 * G;\n    vec3 off1 = o - v1 + 1.0 * G;\n    vec3 off2 = o - v2 + 2.0 * G;\n    vec3 off3 = o - v3 + 3.0 * G;\n     \n    #define DIR(x) (TriWave(Hash11x3(x, seed) + time * vec3(1.0, 0.91, 1.13)))\n     \n    vec4 d;\n\td.x = dot(DIR(xb + v0), off0);\n\td.y = dot(DIR(xb + v1), off1);\n\td.z = dot(DIR(xb + v2), off2);\n\td.w = dot(DIR(xb + v3), off3);    \n         \n    #undef DIR\n    \n    vec4 w;\n    w.x = dot(off0, off0);\n    w.y = dot(off1, off1);\n    w.z = dot(off2, off2);\n    w.w = dot(off3, off3);\n    \n    w = max(1.0 - 2.0 * w, 0.0);\n    \n    return dot(d, w * w * w) * 4.73;\n}\n\n//======================================================================//\n//////////////////////////////////////////////////////////////////////////\n\nfloat sdBoxE(vec3 p, vec3 b, float r, float e)\n{\n    b -= r;\n    \n    vec3 d = abs(p)-b;\n    vec3 x = max(d, 0.0);\n    \n    float u = pow(dot(pow(abs(x), vec3(e)), vec3(1.0)), 1.0/e);\n    \n    return u + min(max(d.x, max(d.y, d.z)), 0.0) - r;\n}\n\nfloat Map(vec3 x)\n{\n    \n    float f0;\n    if(ReadKeyToggle(KEY_SPACE) == 0.0)\n    {\n        f0 = length(x) - 0.5;\n    }\n    else\n    {\n        float e = 8.0;\n        f0 = sdBoxE(x, vec3(0.51), 0.125, 4.0);\n    }\n    \n\n    float f = f0;\n    \n    for(float i = 0.0; i < 1.0; ++i)\n    f += SimplexNoise(x * A0.x * 16.0 * (exp2(i)), iTime, 25632u) * B0.x*0.125 * exp2(-i);\n    \n    return f;\n}\n\n\n\nfloat Intersect_Scene(\nvec3 rp, vec3 rd, mat3 cmat, bool shadowRay,\nout float t, out vec3 n, out vec3 col)\n{\n    float hit = 0.0;\n    t = 1e10;\n    col = vec3(0.0);\n    \n    vec2 tt; vec3 n0, n1;\n    float th = Intersect_Ray_Cube(rp, rd, vec3(0.0, 0.0, 0.0), vec3(0.55), tt, n0, n1);\n\n    if(th > 0.0)\n    if(hit <= 0.0 || tt.x < t)\n    {   \n        bool inside = tt.y < 0.0;\n\n        vec3 p = inside ? rp : rp + rd * tt.x;\n\n        float intervalLen = inside ? tt.x : tt.y - tt.x;\n        float stepCount = 64.0;\n        float minBinaryCount = shadowRay ? 0.0 : 4.0;\n        float sdfBlendF = 0.0;\n        float minStepF = 0.0;\n\n        float t0, tm, t1;\n\n        vec3 N = inside ? -rd : n0;\n        bool th2 = ImplicitRC(p, rd, intervalLen, stepCount, minBinaryCount, sdfBlendF, minStepF, /*out*/ t0, tm, t1, N);\n\n        if(th2)\n        {\n            hit = 1.0;\n\n            t = (inside ? 0.0 : tt.x) + tm;\n\n            //vec3 p = rp + rd * t;\n            p += rd * t1;\n\n            n = normalize(N);\n            n = normalize(vec4(N, exp2(-16.0))).xyz;\n\n            //float c = cellTile(p*B0.x * 80.0);\n            float c = Map(p);\n            //n = normalize(cellIdB - cellIdA);\n           // if(dot(-rd,n)<0.0)n=-n;\n            col = EvalWaxMtl(-rd * cmat, n * cmat);\n            \n            //col = mix(col.gbr * c, col, sqrt(c));\n\n            //float ha = fract(dot(cellIdA, rPhif3));\n            //float hb = fract(dot(cellIdB, rPhif3));\n            //float hc = fract((ha*1.0 + hb) * rPhif1);\n            //\n            //col = n * 0.5 + 0.5;\n            //col = hc*vec3(1.0);\n            //col *= fract(dot(cellId, rPhif3));\n\n            if(t0 == 0.0) col = col.gbr;\n        }\n    }\n\n    return hit;\n}\n\n\nvec3 EvalSceneCol(vec3 rp, vec3 rd, mat3 cmat, vec3 light)\n{\n    vec3 col = vec3(0.0119);\n    \n    #if 1\n    {\n        bvec2 a = bvec2(rd.y > 0.0, abs(rd.y) > 0.8);\n        \n        bool b = (rd.x > 0.0) != (rd.z > 0.0); \n        \n        col = b != a.y ? col * (a.x ? 1.2 : 0.6) : col * (a.x ? 1.5 : 0.7);\n    }\n    #endif\n    \n    #if 1\n    if(ReadKeyToggle(KEY_Q) != 0.0)\n    {\n        float s = 0.25;\n        float r = 0.96;\n        col = mix(col, vec3(1.0, rd.x < 0.0 ? 0.125 : 0.0, 0.0), abs(rd.x) < r ? 0.0 : s);\n        col = mix(col, vec3(0.0, 1.0, rd.y < 0.0 ? 0.500 : 0.0), abs(rd.y) < r ? 0.0 : s);\n        col = mix(col, vec3(rd.z < 0.0 ? 0.250 : 0.0, 0.0, 1.0), abs(rd.z) < r ? 0.0 : s);\n    }\n    #endif\n    \n    float t; vec3 n; vec3 c;\n    float hit = Intersect_Scene(rp, rd, cmat, false, t, n, c);\n \n    if(hit > 0.0)\n    {\n        vec3 p = rp + rd * t;\n\n        col = c;\n    }\n\n    return col;\n}\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n    Resolution = iResolution;\n    \n    vec3 col = vec3(0.0);\n    vec2 uv = uv0.xy - 0.5;\n    ivec2 uvi = ivec2(uv);\n    \n    int I = 0;\n    vec4 iMouse     = ReadVar4(I);\n    vec4 mouseAccu  = ReadVar4(I);\n    vec4 wasdAccu   = ReadVar4(I);\n    float frameAccu = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n\n    for(int i = 0; i < KnobMatCount; ++i)\n    {\n        int KnobMatId = i;\n        ivec2 KnobMatStateBuffOrigin = ivec2(KnobMatId * 4, KnobMatStateBuffY0);\n\n        #define READ(xy) texelFetch(iChannel0, xy + KnobMatStateBuffOrigin, 0).w;\n        \n        for(int j = 0; j < 4; ++j)\n        {\n            AA[i][j] = READ(ivec2(j, 0));\n            BB[i][j] = READ(ivec2(j, 1));\n            CC[i][j] = READ(ivec2(j, 2));\n            DD[i][j] = READ(ivec2(j, 3));\n        }\n        \n        #undef READ\n    }\n        \n    A0 = AA[0]; B0 = BB[0]; C0 = CC[0]; D0 = DD[0];\n    A1 = AA[1]; B1 = BB[1]; C1 = CC[1]; D1 = DD[1];\n    \n    vec2 lightAng = vec2(Pi * 0.7, Pi * 0.2);\n    lightAng.x += (wasdAccu.y - wasdAccu.w) * 0.06; \n    lightAng.y += (wasdAccu.x - wasdAccu.z) * 0.04;    \n    \n    vec3 light = AngToVec(lightAng);\n    \n    vec2 ang = vec2(Pi * -0.5, -Pi * 0.2);\n    ang += mouseAccu.xy * 0.008;\n    \n    mat3 cmat;\n    {\n        float sinPhi   = sin(ang.x);\n        float cosPhi   = cos(ang.x);\n        float sinTheta = sin(ang.y);\n        float cosTheta = cos(ang.y);    \n\n        vec3 front = vec3(cosPhi * cosTheta, \n                                   sinTheta, \n                          sinPhi * cosTheta);\n\n        vec3 right = vec3(-sinPhi, 0.0, cosPhi);\n        \n        vec3 up    = vec3(-cosPhi * sinTheta,\n                                    cosTheta,\n                          -sinPhi * sinTheta);\n        \n        cmat = mat3(right, up, front);\n    }\n    \n    float cdist = exp2(0.2 + mouseAccu.w * 0.02);\n    vec3 cpos = -cmat[2] * cdist;\n\n    float focalLen = 0.7;// = 0.5 * tan(Pi05 - fov * 0.5)\n\n    float txlSize = 1.0 / iResolution.x * 2.0;\n    vec2 tc = uv0.xy * txlSize - vec2(1.0, iResolution.y / iResolution.x);\n   \n   #if 0\n\n    vec3 rd = normalize(cmat * vec3(tc, focalLen)); \n    \n    col = EvalSceneCol(cpos, rd, cmat, light);  \n    \n   #elif 1\n\n    //vec2 flip = vec2(1.0, (fract(uv.x * 0.5) * 4.0 - 1.0) * (fract(uv.y * 0.5) * 4.0 - 1.0));\n    vec2 flip = fract(uv.yx * 0.5) * 4.0 - 1.0;\n    vec3 off = vec3(2.0, 0.0, -2.0) / 6.0;\n\n    for(uint i = 0u; i < 3u; ++i)\n   \t{\n        vec3 rd = normalize(cmat * vec3(tc + off.xy*flip * txlSize, focalLen)); \n\n        off = off.zxy;\n        \n     \tcol += EvalSceneCol(cpos, rd, cmat, light);  \n    }\n    \n    col /= 3.0;\n    \n   #elif 1\n    \n    vec2 off0 = vec2(0.0);\n    vec4 off = vec4(-2.0, -4.0, 4.0, 2.0) * 0.1;\n    \n    for(uint i = 0u; i < 5u; ++i)\n   \t{\n    \tvec3 rd = normalize(cmat * vec3(tc + off0 * txlSize, focalLen)); \n         \n     \tcol += EvalSceneCol(cpos, rd, cmat, light); \n        \n        off = off.zxwy;\n        off0 = off.xy;\n    }\n    \n    col *= 0.2;\n    \n   #endif\n\n   #if 1\n    if(ReadKeyToggle(KEY_TAB) != 0.0 && (IsKnobUITexel(uv) || IsNumValueUITexel(uv)))\n    {    \n        col = mix(col, col * 0.125 + 0.004, GetKnobUIMask(uv));\n\n        // knobs\n        vec3 ui = texelFetch(iChannel0, ivec2(uv), 0).rgb;\n\n        vec3 kcol = vec3(1.0);\n        if(ui.z <  0.0) kcol = vec3(0.0, 0.0, 0.0); else\n        if(ui.z == 1.0) kcol = vec3(1.0, 0.0, 0.0); else\n        if(ui.z == 2.0) kcol = vec3(0.0, 0.5, 0.0); else\n        if(ui.z == 3.0) kcol = vec3(0.0, 0.0, 1.5); else\n        if(ui.z == 4.0) kcol = vec3(0.9, 0.9, 0.0); else\n        if(ui.z == 5.0) kcol = vec3(0.0, 0.8, 0.8); else\n        if(ui.z == 6.0) kcol = vec3(0.8, 0.0, 0.8);\n    \n       #if 0\n        col = mix(col, kcol, ui.y);\n        col = mix(col, vec3(0.99), ui.x);\n       #else\n        col = mix(col, vec3(0.0), ui.y);\n        col = mix(col, mix(kcol, vec3(1.0), 0.25)*0.8, ui.x);\n       #endif\n    }\n   #endif    \n\n    #if 1\n    {\n        vec2 s = abs(uv0/iResolution.xy*2.0-1.0);\n        s *= s; s *= s; s = 1.0 - s;\n        float u = 1.0 - sqrt(s.x*s.y);\n        col *= mix(1.0, 0.75, u*u);\n    }\n    #endif\n    \n    #if 1\n    {\n        float r2 = fract(dot(uv, vec2(0.7548776662, 0.56984029)));\n        r2 = abs(r2 * 2.0 - 1.0);\n        col += (r2 - 0.5) * 0.001;\n    }\n    #endif\n    \n\toutCol = vec4(sRGB_Encode(clamp01(col)), 1.0);\n    //outCol = vec4(col, 1.0);\n}\n\n\n\n\n// ========================================================= RAY MARCHING ROUTINES =====================================================================\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit ? (t0 + t1) * 0.5 : \n                   clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        f = Map(p);\n\n        if (f < 0.0)\n        {\n            t1 = tm;\n            f1 = f;\n\n            if (minBinaryCount == 0.0)\n            {\n                hit = true;\n            }\n            else\n            if(!hit)\n            {\n                hit = true;\n\n                i = min(i, stepCount - minBinaryCount);\n            }\n        }\n        else\n        {\n            t0 = tm;\n            f0 = f;\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n\nbool ImplicitRC(\n    vec3 x,\n    vec3 dir,\n    float intervalLen,\n\n    float stepCount,\n    float minBinaryCount,\n    float sdfBlendF,\n    float minStepF,\n\n    out float t0, out float tm, out float t1, inout vec3 N)\n{\n    bool hit = false;\n\n    float stepSize = 1.0 / stepCount;\n    float ts = intervalLen * stepSize;\n\n    t0 = tm = t1 = 0.0;\n\n    float f  = 0.0;\n    float f0 = 0.0;\n    float f1 = 0.0;\n\n    bool calcN = false;\n    vec3 e = vec3(1.0);\n    \n    for (float i = 0.0; i <= stepCount; ++i)\n    {\n        tm = hit || calcN ? (t0 + t1) * 0.5 : \n                            clamp(mix(i * ts, tm + f, sdfBlendF), tm + ts * minStepF, intervalLen);\n\n        vec3 p = x + dir * tm;\n\n        p += e * (calcN ? exp2(-14.0) : 0.0);\n            \n        f = Map(p);\n\n\t\tif(calcN)\n        {\n            N += e * f;\n            e = vec3(e.z, -e.yx);            \n        }\n        else\n        {\n            if (f < 0.0)\n            {\n                t1 = tm;\n                f1 = f;\n\n                if (minBinaryCount == 0.0)\n                {\n                    hit = true;\n                }\n                else\n                if(!hit)\n                {\n                    hit = true;\n                    \n                    if(i == 0.0) return true;\n                    \n                    i = min(i, stepCount - minBinaryCount);\n                }\n            }\n            else\n            {\n                t0 = tm;\n                f0 = f;\n            }\n            \n            if(i == stepCount)\n            {\n                N = vec3(0.0);\n            \n                calcN = true;\n                i = 0.0;\n                stepCount = 4.0;\n            }\n        }\n    }\n\n    {\n        float w = clamp01(f0 / (f0 - f1));\n        tm = t0 * (1.0 - w) + t1 * w;\n    }\n    \n    return hit;\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n\n#define KeyBoard iChannel1\nfloat ReadKey(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 0), 0).x;}\nfloat ReadKeyToggle(int keyCode) {return texelFetch(KeyBoard, ivec2(keyCode, 2), 0).x;}\n\n#define VarTex iChannel0\n#define OutCol col\n#define OutChannel w\n\n#define WRITEVAR(v, cx, cy) {if(uv.x == float(cx) && uv.y == float(cy)) OutCol.OutChannel = v;}\n#define WRITEVAR2(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1)}\n#define WRITEVAR3(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2)}\n#define WRITEVAR4(v, cx, cy) {WRITEVAR(v.x, cx, cy) WRITEVAR(v.y, cx, cy + 1) WRITEVAR(v.z, cx, cy + 2) WRITEVAR(v.w, cx, cy + 3)}\n\n#define WriteVar(v, x) {WRITEVAR(v, x, 0) ++x;}\n#define WriteVar2(v, x) {WRITEVAR2(v, x, 0) ++x;}\n#define WriteVar3(v, x) {WRITEVAR3(v, x, 0) ++x;}\n#define WriteVar4(v, x) {WRITEVAR4(v, x, 0) ++x;}\n\nfloat ReadVar(int cx, int cy) {return texelFetch(VarTex, ivec2(cx, cy), 0).OutChannel;}\nvec2 ReadVar2(int cx, int cy) {return vec2(ReadVar(cx, cy), ReadVar(cx, cy + 1));}\nvec3 ReadVar3(int cx, int cy) {return vec3(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2));}\nvec4 ReadVar4(int cx, int cy) {return vec4(ReadVar(cx, cy), ReadVar(cx, cy + 1), ReadVar(cx, cy + 2), ReadVar(cx, cy + 3));}\n\nfloat ReadVar(inout int x) { return ReadVar(x++, 0); }\nvec2 ReadVar2(inout int x) { return ReadVar2(x++, 0); }\nvec3 ReadVar3(inout int x) { return ReadVar3(x++, 0); }\nvec4 ReadVar4(inout int x) { return ReadVar4(x++, 0); }\n\nbool IsKnobStateTexel(vec2 uv)\n{\n    return uv.x < float(KnobMatCount) * 4.0 && uv.y >= float(KnobMatStateBuffY0) && uv.y < float(KnobMatStateBuffY0 + 4);\n}\n\nbool IsActiveTexel(vec2 uv)\n{\n    // state variables\n    if(uv.y < 4.0) return true;\n\n    // knob states\n    if(IsKnobStateTexel(uv)) return true;\n\n    // UI\n    {\n        // numerical value\n        if(IsNumValueUITexel(uv)) return true;\n        \n        if(IsKnobUITexel(uv)) return true;\n    }\n    \n    return false;\n}\n\nbool HandleStateAndDrawUI( out vec4 col, in vec2 uv0 )\n{  \n    Resolution = iResolution;\n    \n    col = vec4(0.0);\n    vec2 uv = uv0 - 0.5;\n   \n    //if(IsActiveTexel(uv) == false) return false;\n    \n    int I = 0;\n    vec4 iMouseLast     = ReadVar4(I);\n    vec4 iMouseAccuLast = ReadVar4(I);\n    vec4 wasdAccuLast   = ReadVar4(I);\n    float frameAccuLast = ReadVar (I);\n    ActiveKnobMatId = int(ReadVar(I));\n    //float numKeyLast    = ReadVar (I);\n    \n    vec2 iMouseClick    = ReadVar2(I);\n    \n    //float numKey = \n    bool isClick = iMouseLast.z < 0.0 && iMouse.z >= 0.0;\n    \n    if(isClick) iMouseClick = iMouse.xy;\n    \n    bool shift = ReadKey(KEY_SHIFT) != 0.0;\n    \n    float kW = ReadKey(KEY_W);\n    float kA = ReadKey(KEY_A);\n    float kS = ReadKey(KEY_S);\n    float kD = ReadKey(KEY_D);\n    \n    float left  = ReadKey(KEY_LEFT);\n    float right = ReadKey(KEY_RIGHT);\n    float up    = ReadKey(KEY_UP);\n    float down  = ReadKey(KEY_DOWN);\n    \n    vec2 mouseDelta = iMouse.xy - iMouseLast.xy;\n    \n    bool didInteractUI = false;\n    \n    float knopMouseDelta = mouseDelta.y * (1.0 / 96.0 * (shift ? 0.125 : 1.0));\n     \n    {\n        float i;\n        if((i = KnobMatIdButtonMat(iMouseClick.xy)) >= 0.0)\n        {\n            if(isClick)\n            ActiveKnobMatId = int(i);\n            \n            didInteractUI = true;\n        }\n    }\n        \n    // if current texel holds a knobs state update it if necessary\n    if(IsKnobStateTexel(uv))\n    {\n        int ActiveKnobMatIdTemp = ActiveKnobMatId;\n        \n        ActiveKnobMatId = int(uint(uv.x) / 4u);\n        \n        bool IsKnobMatActuallyActive = ActiveKnobMatId == ActiveKnobMatIdTemp;\n        \n        ivec2 KnobMatStateBuffOrigin = ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n    \n        KnobState knob;\n    \tif(GetKnob(ivec2(uv) - KnobMatStateBuffOrigin, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            if(!isClick && IsKnobMatActuallyActive && knob.colId >= 0.0)\n            if(SqrLen(iMouseClick.xy - knob.p) < Pow2(knob.r.x))\n            {\n                float n = clamp(knob.n + knopMouseDelta * (knob.signed ? 2.0 : 1.0), knob.signed ? -1.0 : 0.0, 1.0);\n                //n = round(n*32.0)/32.0;\n                knob.n = n;\n                didInteractUI = true;\n            }\n\n            col.w = knob.n;// write knob state\n        }\n        \n        ActiveKnobMatId = ActiveKnobMatIdTemp;\n    }\n    \n    // check for knob interaction (irrespective of whether current texel holds a knobs state or not)\n    float knobVal = 0.0;\n    {\n        KnobState knob;\n        if(GetKnob(iMouseClick.xy, iChannel0, /*doInit:*/ false, /*out*/ knob))\n        {\n            knobVal = knob.n;\n            didInteractUI = true;\n        }\n    }\n\n    // draw knob mat UI\n    {\n        KnobState knob;\n        \n        if(GetKnob(uv0, iChannel0, /*doInit:*/ frameAccuLast == 0.0, /*out*/ knob))\n        {\n            vec3 k = Knob(uv0, knob);\n            col.rgb = k;\n        }\n        \n    \tValueText(col, uv0, knobVal, iChannel2);\n        KnobMatIdButtonMat(col, uv0);\n    }\n    \n\n    \n    bool anyK = false;\n    \n    anyK = anyK || iMouse.z > 0.0;\n    anyK = anyK || shift;\n    anyK = anyK || kW != 0.0;\n    anyK = anyK || kA != 0.0;\n    anyK = anyK || kS != 0.0;\n    anyK = anyK || kD != 0.0;\n    anyK = anyK || left  != 0.0;\n    anyK = anyK || right != 0.0;\n    anyK = anyK || up    != 0.0;\n    anyK = anyK || down  != 0.0;\n    \n    \n    float frameAccu = frameAccuLast + 1.0;\n    //if(anyK) frameAccu = 0.0;\n    \n    \n    vec4 wasdAccu = wasdAccuLast;\n    wasdAccu += vec4(kW, kA, kS, kD);\n    wasdAccu += vec4(up, left, down, right);        \n    \n        \n    bool cond0 = iMouse.z > 0.0 && iMouseLast.z > 0.0;\n    cond0 = cond0 && !didInteractUI;\n    \n    vec2 mouseDelta2 = cond0 && !shift ? mouseDelta.xy : vec2(0.0);\n    vec2 mouseDelta3 = cond0 &&  shift ? mouseDelta.xy : vec2(0.0);\n    \n    vec4 iMouseAccu = iMouseAccuLast + vec4(mouseDelta2, mouseDelta3);\n    \n\n    \n    int J = 0;\n    WriteVar4(iMouse,       J);\n    WriteVar4(iMouseAccu,   J);\n    WriteVar4(wasdAccu,     J);\n    WriteVar(frameAccu,     J);\n    WriteVar(float(ActiveKnobMatId), J);\n\n    WriteVar2(iMouseClick,  J);\n    \n    return true;\n}\n\nvoid mainImage( out vec4 col, in vec2 uv0 )\n{\n    vec2 uv = uv0 - 0.5;\n\n    if(!HandleStateAndDrawUI(col, uv0)) return;\n}\n", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec3 Resolution;\n\n#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\n/* http://keycode.info/ */\n#define KEY_LEFT  37\n#define KEY_UP    38\n#define KEY_RIGHT 39\n#define KEY_DOWN  40\n\n#define KEY_TAB 9\n#define KEY_CTRL 17\n#define KEY_SHIFT 16\n#define KEY_SPACE 32 \n#define KEY_A 0x41\n#define KEY_D 0x44\n#define KEY_S 0x53\n#define KEY_W 0x57\n#define KEY_Q 81\n#define KEY_E 69\n#define KEY_R 82\n#define KEY_T 84\n#define KEY_Z 90\n#define KEY_U 85\n#define KEY_I 73\n#define KEY_O 79\n#define KEY_P 80\n#define KEY_F 70\n#define KEY_G 71\n#define KEY_H 72\n#define KEY_J 74\n#define KEY_K 75\n#define KEY_L 76\n#define KEY_Y 89\n#define KEY_X 88\n#define KEY_C 67\n#define KEY_V 86\n#define KEY_B 66\n#define KEY_N 78\n#define KEY_M 77\n\n#define KEY_N0 48\n#define KEY_N1 49\n#define KEY_N2 50\n#define KEY_N3 51\n#define KEY_N4 52\n#define KEY_N5 53\n#define KEY_N6 54\n#define KEY_N7 55\n#define KEY_N8 56\n#define KEY_N9 57\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec2 AngToVec(float ang)\n{\t\n\treturn vec2(cos(ang), sin(ang));\n}\n\n\nvec3 AngToVec(vec2 ang)\n{\n    float sinPhi   = sin(ang.x);\n    float cosPhi   = cos(ang.x);\n    float sinTheta = sin(ang.y);\n    float cosTheta = cos(ang.y);    \n\n    return vec3(cosPhi * cosTheta, \n                         sinTheta, \n                sinPhi * cosTheta); \n}\n\nvec2 CosSin(float x)\n{\t\n\treturn vec2(cos(x), sin(x));\n}\n\nvec2 CmplxMul(vec2 a, vec2 b)\n{\n    return vec2(a.x*b.x - a.y*b.y, \n                a.x*b.y + a.y*b.x); \n}\n\nvec2 Rotate(vec2 v, float ang)\n{\n    return CmplxMul(v, CosSin(ang));\n}\n\nfloat SqrLen(float v) {return v * v;}\nfloat SqrLen(vec2  v) {return dot(v, v);}\nfloat SqrLen(vec3  v) {return dot(v, v);}\nfloat SqrLen(vec4  v) {return dot(v, v);}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\n\nvoid NormAndNormalize(vec3 vec, out float len, out vec3 dir)//TODO: fix nans\n{\n\tfloat sqrLen = dot(vec, vec);\n\tfloat rcpLen = rsqrt(sqrLen);\n\t\n\tlen = sqrLen * rcpLen;\n\tdir = vec * rcpLen;\n}\n\nfloat sRGB_Encode(float c)\n{\n    return c > 0.0031308 ? pow(c, 1.0/2.4) * 1.055 - 0.055 : c * 12.92;\n}\n\nfloat sRGB_Decode(float c)\n{\n    return c > 0.04045 ? pow(c / 1.055 + 0.055/1.055, 2.4) : c / 12.92;\n}\n\nvec3 sRGB_Encode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.0031308)), pow(rgb, vec3(1.0/2.4)) * 1.055 - 0.055, rgb * 12.92);\n}\n\nvec3 sRGB_Decode(vec3 rgb)\n{\n    return If(greaterThan(rgb, vec3(0.04045)), pow(rgb / 1.055 + 0.055/1.055, vec3(2.4)), rgb / 12.92);\n}\n\n    \n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//==============================================================================================================================================//\n\nuint  asuint2(float x) { return x == 0.0 ? 0u : floatBitsToUint(x); }\nuvec2 asuint2(vec2 x) { return uvec2(asuint2(x.x ), asuint2(x.y)); }\nuvec3 asuint2(vec3 x) { return uvec3(asuint2(x.xy), asuint2(x.z)); }\nuvec4 asuint2(vec4 x) { return uvec4(asuint2(x.xy), asuint2(x.zw)); }\n\nfloat Float01(uint x) { return float(    x ) * (1.0 / 4294967296.0); }\nfloat Float11(uint x) { return float(int(x)) * (1.0 / 2147483648.0); }\n\nvec2 Float01(uvec2 x) { return vec2(      x ) * (1.0 / 4294967296.0); }\nvec2 Float11(uvec2 x) { return vec2(ivec2(x)) * (1.0 / 2147483648.0); }\n\nvec3 Float01(uvec3 x) { return vec3(      x ) * (1.0 / 4294967296.0); }\nvec3 Float11(uvec3 x) { return vec3(ivec3(x)) * (1.0 / 2147483648.0); }\n\nvec4 Float01(uvec4 x) { return vec4(      x ) * (1.0 / 4294967296.0); }\nvec4 Float11(uvec4 x) { return vec4(ivec4(x)) * (1.0 / 2147483648.0); }\n\n// http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n// https://probablydance.com/2018/06/16/fibonacci-hashing-the-optimization-that-the-world-forgot-or-a-better-alternative-to-integer-modulo/\nconst float rPhif1 =      0.6180340;\nconst vec2  rPhif2 = vec2(0.7548777, 0.5698403);\nconst vec3  rPhif3 = vec3(0.8191725, 0.6710436, 0.5497005);\nconst vec4  rPhif4 = vec4(0.8566749, 0.7338919, 0.6287067, 0.5385973);\n\nconst uint  rPhi1 =       2654435769u;\nconst uvec2 rPhi2 = uvec2(3242174889u, 2447445413u);\nconst uvec3 rPhi3 = uvec3(3518319153u, 2882110345u, 2360945575u);\nconst uvec4 rPhi4 = uvec4(3679390609u, 3152041523u, 2700274805u, 2313257605u);\n\n// low bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash(uint x)\n{\n    x ^= x >> 16u;\n    x *= 0x7feb352dU;\n    x ^= x >> 15u;\n    x *= 0x846ca68bU;\n    x ^= x >> 16u;\n\n    return x;\n}\n\n// minimal bias version | https://nullprogram.com/blog/2018/07/31/\nuint WellonsHash2(uint x)\n{\n    x ^= x >> 17u;\n    x *= 0xed5ad4bbU;\n    x ^= x >> 11u;\n    x *= 0xac4c1b51U;\n    x ^= x >> 15u;\n    x *= 0x31848babU;\n    x ^= x >> 14u;\n\n    return x;\n}\n\n// http://marc-b-reynolds.github.io/math/2016/03/29/weyl_hash.html\nuint WeylHash(uvec2 c)\n{ \n    return ((c.x * 0x3504f333u) ^ (c.y * 0xf1bbcdcbu)) * 741103597u;\n}\n\n// Pierre L'Ecuyer - \"TABLES OF LINEAR CONGRUENTIAL GENERATORS OF DIFFERENT SIZES AND GOOD LATTICE STRUCTURE\"\n// https://www.ams.org/journals/mcom/1999-68-225/S0025-5718-99-00996-5/S0025-5718-99-00996-5.pdf\nconst uint lcgM = 2891336453u;// ideal for 32 bits with odd c\n\nuint lcg(uint h)\n{\n    return h * lcgM + 0x5C995C6Du;\n}\n\n#define SEED uvec4(0x5C995C6Du, 0x6A3C6A57u, 0xC65536CBu, 0x3563995Fu)\n\n// Mark Jarzynski & Marc Olano - \"Hash Functions for GPU Rendering\"\n// http://jcgt.org/published/0009/03/02/ | https://www.shadertoy.com/view/XlGcRh\nuvec3 pcg3Mix(uvec3 h)\n{\n    h.x += h.y * h.z; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    \n    return h;\n}\n\nuvec3 pcg3Permute(uvec3 h)\n{\n    h = pcg3Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg3Mix(h);\n}\n\nuvec3 pcg3(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg3Permute(uvec3(2447445413u, state, 3242174889u));\n}\n\nuvec3 pcg3(uvec3 h, uint seed)\n{\n    uvec3 c = (seed << 1u) ^ SEED.xyz;\n    \n    return pcg3Permute(h * lcgM + c);\n}\n\nuvec4 pcg4Mix(uvec4 h)\n{\n    h.x += h.y * h.w; \n    h.y += h.z * h.x; \n    h.z += h.x * h.y;\n    h.w += h.y * h.z;\n    \n    return h;\n}\n\nuvec4 pcg4Permute(uvec4 h)\n{\n    h = pcg4Mix(h);\n\n    h ^= h >> 16u;\n    \n    return pcg4Mix(h);\n}\n\nuvec4 pcg4(inout uint state)\n{\n    state = lcg(state);\n\n    return pcg4Permute(uvec4(2882110345u, state, 3518319153u, 2360945575u));\n}\n\nuvec4 pcg4(uvec4 h, uint seed)\n{\n    uvec4 c = (seed << 1u) ^ SEED;\n\n    return pcg4Permute(h * lcgM + c);\n}\n\nuint pcg(inout uint state)\n{\n    state = lcg(state);\n    \n    uint word = ((state >> ((state >> 28u) + 4u)) ^ state) * 277803737u;\n    \n    return (word >> 22u) ^ word;\n}\n\nuint pcg(uint h, uint seed)\n{\n    uint c = (seed << 1u) ^ SEED.x;\n\n    h = h * lcgM + c;\n    \n    h = ((h >> ((h >> 28u) + 4u)) ^ h) * 277803737u;\n    \n    return (h >> 22u) ^ h;\n}\n\n#undef SEED\n\n\nvec4  Hash01x4(inout uint state) { return Float01(pcg4(state)   ); }\nvec3  Hash01x3(inout uint state) { return Float01(pcg3(state)   ); }\nvec2  Hash01x2(inout uint state) { return Float01(pcg3(state).xy); }\nfloat Hash01  (inout uint state) { return Float01(pcg (state)   ); }\n\nvec4  Hash11x4(inout uint state) { return Float11(pcg4(state)   ); }\nvec3  Hash11x3(inout uint state) { return Float11(pcg3(state)   ); }\nvec2  Hash11x2(inout uint state) { return Float11(pcg3(state).xy); }\nfloat Hash11  (inout uint state) { return Float11(pcg (state)   ); }\n\n\nvec4 Hash01x4(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed)); }\nvec4 Hash01x4(vec3  v, uint seed) { return Hash01x4(vec4(v, 0.0          ), seed); }\nvec4 Hash01x4(vec2  v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash01x4(float v, uint seed) { return Hash01x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash01x3(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash01x3(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed)); }\nvec3 Hash01x3(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed); }\nvec3 Hash01x3(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash01x2(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).xy); }\nvec2 Hash01x2(vec2  v, uint seed) { return Hash01x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash01x2(float v, uint seed) { return Hash01x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash01(vec4  v, uint seed) { return Float01(pcg4(asuint2(v), seed).x); }\nfloat Hash01(vec3  v, uint seed) { return Float01(pcg3(asuint2(v), seed).x); }\nfloat Hash01(vec2  v, uint seed) { return Float01(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash01(float v, uint seed) { return Float01(pcg(asuint2(v), seed)); }\n\n\nvec4 Hash11x4(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed)); }\nvec4 Hash11x4(vec3  v, uint seed) { return Hash11x4(vec4(v, 0.0          ), seed); }\nvec4 Hash11x4(vec2  v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0     ), seed); }\nvec4 Hash11x4(float v, uint seed) { return Hash11x4(vec4(v, 0.0, 0.0, 0.0), seed); }\n\nvec3 Hash11x3(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xyz); }\nvec3 Hash11x3(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed)); }\nvec3 Hash11x3(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed); }\nvec3 Hash11x3(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed); }\n\nvec2 Hash11x2(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).xy); }\nvec2 Hash11x2(vec2  v, uint seed) { return Hash11x3(vec3(v, 0.0     ), seed).xy; }\nvec2 Hash11x2(float v, uint seed) { return Hash11x3(vec3(v, 0.0, 0.0), seed).xy; }\n\nfloat Hash11(vec4  v, uint seed) { return Float11(pcg4(asuint2(v), seed).x); }\nfloat Hash11(vec3  v, uint seed) { return Float11(pcg3(asuint2(v), seed).x); }\nfloat Hash11(vec2  v, uint seed) { return Float11(pcg3(asuint2(vec3(v, 0.0)), seed).x); }\nfloat Hash11(float v, uint seed) { return Float11(pcg(asuint2(v), seed)); }\n\n//==============================================================================================================================================//\n//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tcp\t\t: cube position\n\tcth\t\t: cube thickness (cth = 0.5 -> unit cube)\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n\tvec3 o = If(lessThan(rd, vec3(0.0)), -cth, cth);\n\t\n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\tt.x = max(uf.x, max(uf.y, uf.z));\n\tt.y = min(ub.x, min(ub.y, ub.z));\n\t\n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) {t.xy = t.yx;  return 1.0;}\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\n[...]\n\nOUT:\n\tn0 : normal for t.x\n\tn1 : normal for t.y\n\nEXAMPLE:\t\n\tvec2 t; vec3 n0, n1;\n\tfloat hit = Intersect_Ray_Cube(pos, dir, vec3(0.0), vec3(0.5), OUT t, n0, n1);\n*/\nfloat Intersect_Ray_Cube(\nvec3 rp, vec3 rd, \nvec3 cp, vec3 cth, \nout vec2 t, out vec3 n0, out vec3 n1)\n{\t\n\trp -= cp;\n\t\n\tvec3 m = 1.0 / -rd;\n    vec3 os = If(lessThan(rd, vec3(0.0)), vec3(1.0), vec3(-1.0));\n    //vec3 os = sign(-rd);\n\tvec3 o = -cth * os;\n\t\n    \n\tvec3 uf = (rp + o) * m;\n\tvec3 ub = (rp - o) * m;\n\t\n\t//t.x = max(uf.x, max(uf.y, uf.z));\n\t//t.y = min(ub.x, min(ub.y, ub.z));\n\t\n    if(uf.x > uf.y) {t.x = uf.x; n0 = vec3(os.x, 0.0, 0.0);} else \n                    {t.x = uf.y; n0 = vec3(0.0, os.y, 0.0);}\n    if(uf.z > t.x ) {t.x = uf.z; n0 = vec3(0.0, 0.0, os.z);}\n    \n    if(ub.x < ub.y) {t.y = ub.x; n1 = vec3(os.x, 0.0, 0.0);} else \n                    {t.y = ub.y; n1 = vec3(0.0, os.y, 0.0);}\n    if(ub.z < t.y ) {t.y = ub.z; n1 = vec3(0.0, 0.0, os.z);}\n    \n    \n\t// if(ray start == inside cube) \n\tif(t.x < 0.0 && t.y > 0.0) \n    {\n        t.xy = t.yx;  \n        \n        vec3 n00 = n0;\n        n0 = n1;\n        n1 = n00;\n        \n        return 1.0;\n    }\n\t\n\treturn t.y < t.x ? 0.0 : (t.x > 0.0 ? 1.0 : -1.0);\n}\n\n/*\nIN:\n\trp\t\t: ray start position\n\trd\t\t: ray direction (normalized)\n\t\n\tsp2\t\t: sphere position\n\tsr2\t\t: sphere radius squared\n\t\nOUT:\n\tt\t\t: distances to intersection points (negative if in backwards direction)\n\nEXAMPLE:\t\n\tvec2 t;\n\tfloat hit = Intersect_Ray_Sphere(pos, dir, vec3(0.0), 1.0, OUT t);\n*/\nfloat Intersect_Ray_Sphere(\nvec3 rp, vec3 rd, \nvec3 sp, float sr2, \nout vec2 t)\n{\t\n\trp -= sp;\n\t\n\tfloat a = dot(rd, rd);\n\tfloat b = 2.0 * dot(rp, rd);\n\tfloat c = dot(rp, rp) - sr2;\n\t\n\tfloat D = b*b - 4.0*a*c;\n\t\n\tif(D < 0.0) return 0.0;\n\t\n\tfloat sqrtD = sqrt(D);\n\t// t = (-b + (c < 0.0 ? sqrtD : -sqrtD)) / a * 0.5;\n\tt = (-b + vec2(-sqrtD, sqrtD)) / a * 0.5;\n\t\n\t// if(start == inside) ...\n\tif(c < 0.0) t.xy = t.yx;\n\n\t// t.x > 0.0 || start == inside ? infront : behind\n\treturn t.x > 0.0 || c < 0.0 ? 1.0 : -1.0;\n}\n\n\nvec3 Hue_to_RGB(float hue)\n{\n    float H6 = hue * 6.0;\n    \n\tfloat R =       abs(H6 - 3.0) - 1.0;\n\tfloat G = 2.0 - abs(H6 - 2.0);\n\tfloat B = 2.0 - abs(H6 - 4.0);\n    \n\treturn clamp(vec3(R, G, B), 0.0, 1.0);\n}\n\nvec3 HSV_to_RGB(vec3 hsv)\n{\n    return (Hue_to_RGB(hsv.x) * hsv.y + vec3(1.0 - hsv.y)) * hsv.z;\n}\n\nfloat RGB_to_Hue(vec3 rgb)\n{\n    float v = (rgb.r - rgb.g - rgb.b) *  (1.0/6.0) + (1.0/3.0);\n    \n    return (rgb.b < rgb.g ? -v : v) + 0.5;     \n}\n\nvec3 RGB_to_HSV(vec3 rgb)\n{\n    float v = max(rgb.r, max(rgb.g, rgb.b));\n    \n    if(v == 0.0) return vec3(0.0);\n    \n    rgb /= v;\n    \n    float ds = min(rgb.r, min(rgb.g, rgb.b));\n    float s = 1.0 - ds;\n    \n    if(ds == 1.0) return vec3(0.0, 0.0, v);\n    \n    rgb = (rgb - ds) / s;\n    \n    float h = RGB_to_Hue(rgb);\n    \n    return vec3(h, s, v);\n}\n\nvec3 EvalWaxMtl(vec3 V, vec3 N)\n{\n    vec3 up = normalize(vec3(0.0, 1.0, -1.0));\n    vec3 Ld = normalize(vec3(0.5, 1.0, -0.4));\n    vec3 L  = normalize(vec3(0.75, 0.5, -1.0));\n    \n    float LdN = dot(L, N);\n    float VdN = dot(V, N);\n    vec3 H = normalize(V + L);\n\tvec3 Hr = vec3(-H.xy, H.z);\n    \n    vec3 R = N * (2.0 * dot(N, V)) - V;\n\n    float f = Pow3(clamp01(dot(N, V)));\n    \n    vec3 c = vec3(1.0, 0.04, 0.03) * 0.2;\n    c *= 1.0 + f * 0.1;\n\n    float diff = cubic(clamp01(dot(N, Ld) * 0.5 + 0.5));\n    \n    float fd = mix(f, 1.0, diff);\n\n    vec3 col = mix(vec3(1.0, 0.0, 0.0)*diff*0.15,c, clamp01(dot(N, Ld)*0.8+0.2))*fd;\n\n    float s = 0.5;\n    col += (1.0/(1.025- clamp01(dot(N, H )))) * (s*0.0015*vec3(0.75, 0.9, 1.0))*cubic(clamp01(dot(R, up)*2.))*1.5;\n    col += (1.0/(1.03 - clamp01(dot(N, Hr)))) *    0.0002*vec3(0.25, 0.6, 1.0);\n    col += vec3(0.0, 0.5, 1.0) * (0.02*s) * cubic(clamp01((dot(R, up)*0.75+0.25)*2.));\n\n    col += vec3(1.0, 0.1, 0.3)*0.05 *(1.0-fd)*f;\n    col += vec3(1.0)*0.1*(1.0-diff)*(1.0-clamp01(VdN))*(c*c+c);\n    col *= mix(1.0, 0.75, Pow4(1.0-clamp01(VdN)));\n    col *= 1.3;\n    \n    float fuzz = Pow4(clamp01(LdN) / (clamp01(LdN) + clamp01(VdN) + exp2(-16.0)));\n    col += fuzz * diff * (0.1 * vec3(0.1, 0.8, 1.0));\n    \n    col *= mix(0.5, 1.0, sqrt(clamp01(dot(N, V)))) * 1.05;\n    \n    return col;\n}\n\n\n// ===============================================  KNOB STUFFS  =========================================================================== //\nstruct KnobState\n{\n    vec2 p;\n    vec2 r;\n    bool signed;\n    float colId;\n    \n    float n;\n};\n\nKnobState CreateKnobState(vec2 p, vec2 r, bool signed, float n)\n{\n    KnobState state;\n    state.p = p;\n    state.r = r;\n    state.signed = signed;\n    state.colId = 0.0;\n    state.n = n;\n\n    return state;\n}\n\nint ActiveKnobMatId = 0;\n\nconst int KnobMatCount = 1;// <=== set this to number of matrices you want to use \nconst int KnobMatKnobCount = 16;\nconst int KnobCount = KnobMatKnobCount * KnobMatCount;\n\nconst int KnobMatStateBuffY0 = 4;\n\nconst float KnobOuterRadius = 16.0; \nconst float KnobCircleThick =  4.0; \nconst float KnobPadding     =  4.0; \nconst float KnobSizeTotal   =  2.0 * (KnobOuterRadius + KnobPadding);\nfloat GetKnobMatPosY0() { return Resolution.y*0.5 + (KnobSizeTotal*2.0); } \nfloat GetKnobMatPosY1() { return Resolution.y*0.5 - (KnobSizeTotal*2.0); } \n\nivec2 GetKnobMatStateBuffOrigin()\n{\n    return ivec2(ActiveKnobMatId * 4, KnobMatStateBuffY0);\n}\n\nivec2 GetKnobXY(vec2 uv)\n{\n    int x = int(floor(uv.x / KnobSizeTotal));\n    int y = int(floor((GetKnobMatPosY0() - uv.y) / KnobSizeTotal));\n    \n    if(x < 0 || x >= 4 || y < 0 || y >= 4) return ivec2(-1, -1);\n    \n    return ivec2(x, y);\n}\n\nfloat ReadKnobValue(sampler2D stateBuffer, ivec2 xy)\n{\n    return texelFetch(stateBuffer, GetKnobMatStateBuffOrigin() + xy, 0).w;\n}\n\nbool IsKnobUITexel(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0;\n\n    if(uv.x < width+4.0 && uv.y > GetKnobMatPosY1()-4.0 && uv.y < GetKnobMatPosY0() + 48.0+2.0)\n    {\n        return true;\n    }\n\n    return false;\n}\n\nfloat GetKnobUIMask(vec2 uv)\n{\n    float width = KnobSizeTotal * 4.0 + 0.0;\n\n    float minY = GetKnobMatPosY1() - 1.0;\n    float maxY = GetKnobMatPosY0() + 48.0 - 2.0;\n\n    float r = 8.0;\n\n    vec2 p = uv - vec2(width, maxY + minY) * 0.5;\n    vec2 b = vec2(width, maxY - minY) * 0.5 - r;\n    vec2 d = max(abs(p) - b, 0.0);\n    \n    return 1.0 - clamp01((dot(d, d) - r*r)*0.05);\n}\n\nbool IsNumValueUITexel(vec2 uv)\n{\n    if(uv.x < 51.0 && uv.y < 17.0) return true;\n}\n\nKnobState CreateMatKnob(ivec2 xy, bool signed, float n, float colId)\n{\n    float x = float(xy.x);\n    float y = float(xy.y);\n    \n    KnobState knob;\n    knob.p.x = 0.5 * KnobSizeTotal + x * KnobSizeTotal;\n    knob.p.y = 0.5 * KnobSizeTotal + y * KnobSizeTotal;\n    \n    knob.p.y = GetKnobMatPosY0() - knob.p.y;\n\n    knob.r = vec2(KnobOuterRadius, KnobCircleThick);\n    knob.signed = signed;\n    knob.colId = colId;\n\n\tknob.n = n;\n    \n    return knob;\n}\n\nbool GetKnob0(ivec2 xy, out KnobState knob)\n{\n    KnobState knob0;\n    knob0.n = 1.25;\n    knob = knob0;\n    \n    if(xy.x < 0 || xy.x > 3 || \n       xy.y < 0 || xy.y > 3) return false;\n\n    if(ActiveKnobMatId < 0 || ActiveKnobMatId >= KnobMatCount) return false;\n\n    int i = xy.x + xy.y * 4;\n    \n    i += ActiveKnobMatId * KnobMatKnobCount;\n    \n    const bool fals = false;\n    const bool IsSigned[] = bool[]\n    (\n        //========  0  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  1  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        //========  3  ========//\n        fals, fals, fals, fals,// A\n        fals, fals, fals, fals,// B\n        fals, fals, fals, fals,// C\n        fals, fals, fals, fals,// D\n        \n        false\n    );\n    \n    const float DefaultValue[] = float[]\n    (\n        //======  0  ======//\n        0.3, 0.0, 0.0, 0.,// A \n        0.5, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n    \n        //======  1  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n        \n        //======  3  ======//\n        0.0, 0.0, 0.0, 0.0,// A \n        0.0, 0.0, 0.0, 0.0,// B \n        0.0, 0.0, 0.0, 0.0,// C \n        0.0, 0.0, 0.0, 0.0,// D \n       \n        0.0\n    );\n    \n    const float ColId[] = float[]\n    (\n        //======  0  ======//\n        0.0, -.1, -.1, -.1,// A \n        0.0, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n    \n        //======  1  ======//\n        -.1, -.1, -.1, -.1,// A \n        -.1, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n        \n        //======  3  ======//\n        -.1, -.1, -.1, -.1,// A \n        -.1, -.1, -.1, -.1,// B \n        -.1, -.1, -.1, -.1,// C \n        -.1, -.1, -.1, -.1,// D\n        \n        0.0\n    );    \n    \n    knob = CreateMatKnob(xy, IsSigned[i], DefaultValue[i], ColId[i]);\n    \n    return true;\n}\n\n\n// get knob by position id xy\nbool GetKnob(ivec2 xy, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    // fill knob with hardcoded settings\n\tif(!GetKnob0(xy, /*out*/ knob)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n    \n    return true;\n}\n\n// get knob by uv\nbool GetKnob(vec2 uv, sampler2D stateBuffer, bool doInit, out KnobState knob)\n{\n    ivec2 xy = GetKnobXY(uv);\n    \n    // is position id valid\n    if(xy.x == -1 || xy.y == -1) return false;\n    \n    // does knob actually exist\n    if(!GetKnob0(xy, /*out*/ knob)) return false;\n\n    // does uv lie on knob disk\n    if(SqrLen(uv - knob.p) >= Pow2(knob.r.x + KnobPadding)) return false;\n    \n    // fill in knob value stored in state buffer\n    if(!doInit) knob.n = ReadKnobValue(stateBuffer, xy);\n\n    return true;\n}\n\n\nvec3 Knob(vec2 uv, KnobState state)\n{\n    //if(state.colId < 0.0) return vec3(0.0);\n    if(state.colId < 0.0) { state.n = 0.0; state.r.x *= 0.5; state.r *= 1.5; }\n    \n    uv -= state.p;\n    \n    float v = 0.0;\n    \n    float l = length(uv);\n    \n    v = abs(l - (state.r.x - state.r.y)) - state.r.y;\n    \n    float sh = 1.0;\n    sh = clamp01(v * 0.18);\n    sh = 1.0-(1.0-sh)*(1.0-sh);\n    sh = mix(0., 1.0, sh);\n    v = clamp01(v);\n    \n    v = 1.0 - v;\n    float o;\n    {\n        float a = state.n;\n\n        bool tc = state.signed;\n        if(tc) a = a * 0.5 + 0.5;\n        a *= 2.0;\n        bool ac = a > 1.0;\n        float m = clamp01((ac ? uv.x : -uv.x)+0.5);\n        if(ac) a = a - 1.0;\n\n        m = min(m, clamp01((tc ? 1.0 : -1.0) * dot(AngToVec((1.0-a)*Pi), uv)+0.5));\n        if(!tc && ac) m = 1.0-m;\n       \n        o = m;\n    }\n    \n    float r = v;\n    r = v * mix(0.25, 0.95, o);\n\n    if(state.signed && uv.x < 0.0) { r = v * mix(0.06, 0.6, o);}\n    \n    if(state.colId < 0.0) { r *= 0.25; sh = 1.0; }\n    \n    return vec3(r, 1.0 - sh, state.colId);\n}\n\n// https://www.shadertoy.com/view/4tfBzn\nfloat TextSDF(vec2 p, float glyph, sampler2D glyphBuffer)\n{\n    p = abs(p.x - .5) > .5 || abs(p.y - .5) > .5 ? vec2(0.) : p;\n    return 2. * (texture(glyphBuffer, p / 16. + fract(vec2(glyph, 15. - floor(glyph / 16.)) / 16.)).w - 127. / 255.);\n}\n\nvoid ValueText(inout vec4 col, vec2 uv0, float n, sampler2D glyphBuffer)\n{\n    vec2 p = uv0 * 0.5;\n    \n    vec2 scale = vec2(4., 8.);\n    vec2 t = floor(p / scale);   \n\n    if(t.x < 0.0 || t.x > 5.0 || t.y != 0.0) return;\n    if((n == 0.0 || abs(n) == 1.0) && t.x > 1.0) return;\n    if(t.x == 0.0 && n >= 0.0) return;\n    \n\n    float c = 0.0;\n    \n    if(t.x == 0.0) c = 45.0;\n    else if(t.x == 1.0) c = n == 0.0 ? 48.0 : (abs(n) == 1.0 ? 49.0 : 46.0);\n    else\n    c = abs(n) == 1.0 ? 48.0 : 48.0 + mod(floor(abs(n)*1000.0 * exp2((4.0-t.x) * -(log2(10.0)/log2(2.0)))), 10.0);\n\n    p = (p - t * scale) / scale;\n    p.x = (p.x - 0.5) * 0.5 + 0.5;\n\n    if (c == 0.) return;\n    \n    float sdf = TextSDF(p, c, glyphBuffer);\n    \n    sdf = smoothstep(-0.05, 0.05, sdf);\n\n    col.r = (1.0 - sdf);// * 0.999;\n}\n\nfloat KnobMatIdButtonMat(inout vec4 col, vec2 uv)\n{\n    vec2 uv2 = vec2(uv.x, uv.y - GetKnobMatPosY0());\n    \n    float width = KnobSizeTotal * 4.0;\n    float height = 48.0;\n    float ButtonCountX = 4.0;\n    float ButtonCountY = 2.0;\n\n    if(uv2.x < width && uv2.y >= 0.0 && uv2.y < height)\n    {\n        float wi = width / ButtonCountX;\n        float hi = height / ButtonCountY;\n\n        float ix = 0.0;\n        float iy = 1.0;\n\n        ix = floor(uv2.x / wi);\n        uv2.x = (uv2.x / wi - ix) * wi;\n\n        iy = floor(uv2.y / hi);\n        uv2.y = (uv2.y / hi - iy) * hi;\n        iy = float(ButtonCountY) - 1.0 - iy;\n\n        uv2 -= vec2(wi, hi) * 0.5;\n\n        float buttonSizeMod = 2.0;\n        float l = length(uv2) + buttonSizeMod;\n\n        float ll = min(wi, hi) * 0.5;\n\n        float i = ix + iy * ButtonCountX;\n\n        bool isActive = int(i) == ActiveKnobMatId;\n\n        float buttonOpacity = isActive ? 0.9 : 0.2;\n        float shadowOpacity = isActive ? 0.6 : 0.4;\n\n        if(int(i) >= KnobMatCount) { buttonOpacity *= 0.09; shadowOpacity = 0.0; }\n\n        col.rgb = vec3(smoothstep(ll-3.0, ll-4.5, l)       * buttonOpacity , \n                   pow(smoothstep(ll    , ll-4.0, l), 2.0) * shadowOpacity, .0);\n                   \n        return i;\n    }\n    \n    return -1.0;\n}\n\nfloat KnobMatIdButtonMat(vec2 uv)\n{\n    vec4 col;\n    return KnobMatIdButtonMat(col, uv);\n}\n\n\n/*\nvec3 normalize2(vec3 v)//not significantly faster than normalize\n{\n    float l2 = dot(v, v);\n    \n    return v * (1.5 - 0.5 * l2);\n}\n\nvec3 TransformHL2Basis(vec3 x)\n{\n    vec3 hlX = vec3(-1.0/sqrt(6.0), -1.0/sqrt(2.0), 1.0/sqrt(3.0)).xzy;\n    vec3 hlY = vec3(-1.0/sqrt(6.0),  1.0/sqrt(2.0), 1.0/sqrt(3.0)).xzy;\n    vec3 hlZ = vec3(sqrt(2.0/3.0), 0.0, 1.0/sqrt(3.0)).xzy;\n    \n    return x.x*hlX + x.y*hlY + x.z*hlZ;\n}\n\nvec3 Transform(vec2 uv)\n{\n    return uv.x * normalize(vec3(0.5, -1.0, 0.5)) + \n           uv.y * normalize(vec3(1.0, 0.0, -1.0));\n}\n\n\treturn dot(d, (w * w) * (w))*0.785;//norm len(grad)\n\t//return dot(d, (w * w) * (w))*4.73;// norm val\n\t//return dot(d, (w * w) * (w * w))*0.86;//norm len(grad)\n\t//return dot(d, (w * w) * (w * w))*6.725;// norm val\n*/", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsBRr.jpg", "access": "api", "license": "cc0-1.0", "functions": [[272, 272, 306, 306, 360], [361, 361, 395, 395, 449], [451, 451, 482, 482, 532], [533, 533, 564, 564, 657], [659, 659, 687, 687, 713], [714, 714, 742, 742, 769], [2415, 2415, 2439, 2439, 2487], [2488, 2488, 2512, 2512, 2560], [2561, 2561, 2585, 2585, 2633], [2634, 2634, 2658, 2658, 2706], [3956, 3956, 4004, 4004, 4200], [4202, 4202, 4221, 4221, 4592], [4596, 4596, 4704, 4704, 6310], [6313, 6313, 6373, 6373, 7227], [11801, 11801, 12004, 12004, 12951], [12953, 12953, 13170, 13170, 14753]], "test": "untested"}
{"id": "ftBfWm", "name": "Fast FBM", "author": "VPas", "description": "fast fbm", "tags": ["fbm", "fast"], "likes": 5, "viewed": 302, "published": 3, "date": "1652279973", "time_retrieved": "2024-07-30T16:49:17.609959", "image_code": "float noise(vec2 p) {\n  return texture(iChannel0, p*.065).r;\n}\n\nvec3 noise3(vec2 p) {\n  return texture(iChannel0, p*.01).rgb;\n}\n\nmat2 rot=mat2(.6,.8,-.8,.6);\nfloat fbm(vec2 p) {\n  float r;\n  r  = noise(p)*.5000; p = rot * p * 1.99;\n  r += noise(p)*.2500; p = rot * p * 2.01;\n  r += noise(p)*.1250; p = rot * p *2.04;\n  r += noise(p)*.0625;\n  return r/0.9375;\n}\n\nvec3 pFbm(vec2 p){\n  vec3 r;\n  r  = noise3(p)*.5000; p=rot*p*1.99;\n  r += noise3(p)*.2500; p=rot*p*2.01;\n  r += noise3(p)*.1250; p=rot*p*2.04;\n  r += noise3(p)*.0625;\n  return r/0.9375;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 r = iResolution.xy;\n    vec2 uv = fragCoord / min(r.x, r.y) + vec2(.01, .014) * iTime;\n    vec3 pf = pFbm(uv * 20.);\n    float v = 0.2 / fbm(pf.xy + vec2(1.,-1.) * .05 * iTime);\n    float w = 0.4 / fbm(pf.zx);\n    vec3 col = vec3(v*w*w, w*v, w*v);\n    col*=col;\n    col*=2.;\n    fragColor = vec4(col / (1. + col), 1.0);\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftBfWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 62], [64, 64, 85, 85, 127], [158, 158, 177, 177, 360], [362, 362, 380, 380, 549], [552, 552, 608, 608, 939]], "test": "untested"}
{"id": "stSBDw", "name": "Fork Easy Shade wera0071 392", "author": "wera0071", "description": "Forked from Easy Shader 387", "tags": ["zbuffer"], "likes": 0, "viewed": 116, "published": 3, "date": "1652277295", "time_retrieved": "2024-07-30T16:49:18.451709", "image_code": "#define myPi 3.141592654f\n#define Eps 1e-8\n#define maxZ 100.0\n\nconst int n = 5;\nvec3 colVec[n] = vec3[n](vec3(0.6, 0.9, 0.6), vec3(0, 0.5, 0), vec3(0.8, 1, 0.8), vec3(0.5, 1.0, 0.5), vec3(0, 0.7, 0));\nvec3 BGcol = vec3(1, 0.2, 1);\n//float zVec[n] = float[n](3.0, 2.0, 1.0);\n\nint sizes[n] = int[n](3, 5, 4, 3, 10), inds[n] = int[n](0, 3, 8, 12, 15); const int m = 30;\nvec2 polygonsXY[m]; float polygonsZ[m];\n\nvoid initPolygons(out vec2 polygonsXY[m], out float  polygonsZ[m], in float time){\n// 0 -- triangle\n     polygonsXY[0] = vec2(0.5, 0.12); polygonsZ[0] = 0.1; \n    polygonsXY[2] = vec2(0.35, 0.84); polygonsZ[2] = 0.1;\n    polygonsXY[1] = vec2(0.9, 0.4); polygonsZ[1] = 0.1;\n    \n// 1 -- pentagon\n     polygonsXY[3] = vec2(0.27, 0.15); polygonsZ[3] = 0.1;\n    polygonsXY[4] = vec2(0.7, 0.5251); polygonsZ[4] = 0.1;\n    polygonsXY[5] = vec2(0.83, 0.7); polygonsZ[5] = 0.1;\n    polygonsXY[6] = vec2(0.5, 0.74); polygonsZ[6] = 0.1;\n    polygonsXY[7] = vec2(0.31, 0.63); polygonsZ[7] = 0.1;\n    \n// 2 -- rotated square\n    float w = 2.0;\n    vec3 center = vec3(0.25, 0.76, 0.1 + 0.02 * sin(time*w)); float r = 0.4;\n    int i; float j =0.0, phi = myPi/6.0;\n    float ang = 2.0*myPi/4.0; \n    vec3 tmpVec;\n    mat3 rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)) );\n    for (i = 8; i < 12; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j + 1.0;\n    }\n// 3 -- triangle\n    polygonsXY[12] = vec2(0.1, 0.5); polygonsZ[12] = 0.9;\n    polygonsXY[13] = vec2(0.2, 0.4); polygonsZ[13] = 0.5;\n    polygonsXY[14] = tmpVec.xy + center.xy; polygonsZ[14] = 0.1;\n    \n// 4 -- XXXtagon\n    w = 1.5;\n    center = vec3(0.2 + 0.1 * sin(time * w), 0.2 + 0.1 * cos(time), 0.2 + 0.1 * sin(time)); r = 0.4;\n    j = 0.0, phi = myPi/9.0;\n    ang = 2.0*myPi/5.0; \n    tmpVec;\n    rot = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos(phi), sin(phi)), vec3(0.0, -sin(phi), cos(phi)));\n    for (i = 15; i < 25; i++){\n        tmpVec = rot*(r*vec3(cos(j*ang + time), sin(j*ang + time), 0.0)); \n        polygonsXY[i] = tmpVec.xy + center.xy;\n        polygonsZ[i] = tmpVec.z + center.z;\n        j = j + 1.0;\n    }\n}\n\n/*vec2 triang1[3] = vec2[3](vec2(0.0, 0.0),  vec2(1.0, 0.0), vec2(1.0, 1.0));\nvec2 triang2[3] = vec2[3](vec2(0.0, 0.0),  vec2(1.0, 0.0), vec2(0.0, 1.0));\nvec2 triang3[3] = vec2[3](vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(0.5, 1.0));*/\nint leftTurn(in vec2 a, in vec2 b, in vec2 c)\n{\n    float tmp = (c.x - a.x)*(b.y - a.y) - (c.y - a.y)*(b.x - a.x);\n    if (abs(tmp) < Eps) \n        return 0;\n    else \n        return tmp > 0.0 ? 1: -1;\n}\n\n\nbool inPolygon(in int ind0, in int size, in vec2 vert[m], in vec2 p) // vertices in counter clockwise order\n{\n    bool res = leftTurn(vert[ind0 + size-1], vert[ind0], p) <= 0; int i = ind0;\n    while(res && (i < ind0 + size -1))\n    {\n        res = res && (leftTurn(vert[i], vert[i+1], p) <= 0); i++;\n    }\n    return res;\n}\n\nfloat zInPlane(in vec3 a, in vec3 b, in vec3 c, in vec2 p) // z coordinate for (x,y) point of a plane (a-b, c-b)\n{\n    vec3 nrm = cross(a-b, c-b);\n    //float D = - dot(nrm, b);\n    if (abs(nrm.z) < Eps) return a.z;\n    else return (dot(nrm, b) - nrm.x*p.x - nrm.y*p.y)/nrm.z;\n}\n\n\n// vec3 normalize(vec3), vec3 cross(vec3, vec3) are predefined\nbool inTriangle(in vec2 a, in vec2 b, in vec2 c, in vec2 p) // (a, b, c) -- counter clockwise\n{\n    if ((leftTurn(a, b, p) <= 0) && (leftTurn(b, c, p) <= 0) && (leftTurn(c, a, p) <= 0))\n        return true;\n    else return false;\n}\nvoid initColors(float time) {\n    float w = 2.0;\n    vec3 center = vec3(0.7 + 0.2 * sin(iTime * w), 0.5 + 0.2 * cos(time), 0.2 * sin(time));\n     colVec[0] = vec3(sin(time * w), 0.0, 0.5);\n    colVec[4] = vec3(center);\n    colVec[3] = vec3(sin(time * w), 1.0, 0.5);\n    colVec[2] = vec3(cos(time * w), 0.8, 0.4);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    float time = iTime, tmp; //iTime;\n    initPolygons(polygonsXY, polygonsZ, time);\n    initColors(time);\n    vec3 col = BGcol; float z = maxZ; \n    int i;\n     /*if (inTriangle(triang1[0], triang1[1], triang1[2], uv)){\n        z = zVec[0]; col = colVec[0] + 0.4*sin(iTime)*vec3(1.0, 1.0, 99.0); \n    }\n    if (inTriangle(triang2[0], triang2[0], triang2[0], uv) && (zVec[1] < z)){\n        z = zVec[1]; col = colVec[1]+ 0.4*sin(iTime)*vec3(1.0, 1.0, 99.0); \n    }\n    if (inTriangle(triang3[0], triang3[1], triang3[2], uv) && (zVec[2] < z)){\n        z = zVec[2]; col = colVec[2]+ 0.4*sin(iTime)*vec3(1.0, 1.0, 99.0); \n    }*/\n    for (i = 0; i < n; i++){\n        if ( inPolygon(inds[i], sizes[i], polygonsXY, uv) ){\n            tmp = zInPlane(vec3(polygonsXY[inds[i]].x, polygonsXY[inds[i]].y, polygonsZ[inds[i]]), \\\n            vec3(polygonsXY[inds[i]+1].x, polygonsXY[inds[i]+1].y, polygonsZ[inds[i]+1]), \\\n            vec3(polygonsXY[inds[i]+2].x, polygonsXY[inds[i]+2].y, polygonsZ[inds[i]+2]), uv);\n            if (tmp < z){\n                z = tmp; col = colVec[i]; \n            }\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stSBDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[408, 408, 490, 507, 2260], [2262, 2493, 2540, 2540, 2696], [2699, 2699, 2808, 2808, 3023], [3025, 3025, 3139, 3139, 3303], [3306, 3369, 3464, 3464, 3600], [3601, 3601, 3630, 3630, 3915], [3918, 3918, 3975, 4025, 5225]], "test": "untested"}
{"id": "sljfDD", "name": "Infinite 3D Zoom", "author": "Shane", "description": "A standard infinite 3D box zoom variation.", "tags": ["3d", "voronoi", "cube", "zoom", "bump", "infinite"], "likes": 82, "viewed": 1910, "published": 3, "date": "1652275543", "time_retrieved": "2024-07-30T16:49:19.396184", "image_code": "/*\n\n    Infinite 3D Zoom\n    ----------------\n\n\tThis is just a dressed up version of a basic cube zooming animation.\n    The animation portion was pretty straight forward, so took no time at\n    all. However, I spent way too long dressing it up to a stage where I\n    was only mildy satisfied with the result. The original had a nicer \n    reflective pass, but I couldn't afford to use it... You can't win them \n    all, but if you like drab brown-looking one pass scenes, then you'll \n    love this. :D Oh well, post and move on, as they say. :)\n    \n    For those not familiar with the infinite zoom illusion, it's a pretty\n    simple concept: In the 2D sense, you produce a miniscule object then \n    expand its size to some maximum before snapping it back to its original\n    minimum size (the fract funciton does that). On its own, it's not very\n    illusory, however, if you do the same with multiple objects at various \n    stages in the expansion process, your mind gets tricked into believing \n    that a camera is zooming toward the central object -- In reality, the \n    camera is effectively stationary. This particular example is just a 3D \n    extension on the aforementioned with various tweaks.\n    \n    Anyway, there are better zoom examples than this on Shadertoy, so if\n    that kind of thing interests you, search \"infinite zoom\" or something \n    along those lines. I have some 2D zooming animations that I might post\n    at a later date.\n    \n    \n\n\tOther examples:\n    \n    // You can't list zoom examples without referencing this.\n    // It's everywhere these days.\n    Infinite KIFS Zoom - andyalias\n    https://www.shadertoy.com/view/4sS3WV\n    \n    // Golden spiral zoom. Typical simple and stylish example\n    // by IQ.\n    Golden Ratio and Spiral - iq\n    https://www.shadertoy.com/view/fslyW4\n    \n    // One of many of KilledByAPixel's really nice zoom examples.\n    Infinity Matrix - KilledByAPixel\n    https://www.shadertoy.com/view/Md2fRR\n    \n    // Fabrice has a few examples. This is his most recent. \n    infinite zoom in rolling squares - FabriceNeyret2 \n    https://www.shadertoy.com/view/fl2Bzm\n    \n    // Awesome example -- Requires a strong GPU.\n    Bloom [skull] - tdhooper\n    https://www.shadertoy.com/view/WdScDG\n    \n    // Oldschool bump mapped zoom effect, written years ago.\n    Quasi Infinite Zoom Voronoi  - Shane\n\thttps://www.shadertoy.com/view/XlBXWw \n\n*/\n\n// No forced unroll.\n#define ZERO min(0, iFrame)\n\n// Max ray distance.\n#define FAR 20.\n\n\n\n// Scene object ID to separate the mesh object from the terrain.\nint objID;\nvec4 vID;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial by Ryan Geiss.\nvec3 tex3D(sampler2D t, in vec3 p, in vec3 n){ \n    \n    n = max(abs(n) - .2, .001); // max(abs(n), 0.001), etc.\n    //n /= dot(n, vec3(.8)); \n    n /= length(n);\n    \n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return mat3(tx*tx, ty*ty, tz*tz)*n;\n}\n\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    //vec2 w = vec2( sdf, abs(pz) - h );\n  \t//return min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    \n    // Slight rounding. A little nicer, but slower.\n    const float sf = .005;\n    vec2 w = vec2(sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    \n}\n\n\n// IQ's signed box formula.\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  vec2 d = abs(p) - b + sf;\n  return min(max(d.x, d.y), 0.) + length(max(d, 0.)) - sf;\n}\n\n \nvec4 gS;\nmat2 gR;\nfloat map(vec3 p){\n    \n    // Wall.\n    float wall = -p.z + 32.;\n\n    // Render 16 objects expanding from a minimum size to a maximum\n    // one and back again at separate linear intervals. The result is \n    // an infinite zoom illusion.\n    const int N = 16;\n    float L = float(N);\n    float minSize = .001;\n    \n    float d = 1e5;\n    gS = vec4(1e5);\n    \n    // There are probably faster methods out there, but this gets the\n    // job done. Apologies for anyone with slower machines.\n    for(int i = 0; i<N; i++){\n        \n        // N objects spread out at linear time varying intervals.\n        float s = fract((float(i) + iTime)/L);\n        // Adding linear XY rotation for a bit of extra visual interest. \n        // You can leave it out, if you'd prefer the boxes to look more static.\n        mat2 r = rot2(s*5.); \n        \n        // Exponential size increase. Boxes on the outside are larger. When\n        // \"i\" is zero, \"s\" is equal to the minimum size. By the way, you can\n        // increase iteration size in other ways (exp(x) will work too), but\n        // I like doubling each iteration.\n        s = exp2(s*L)*minSize; // exp2(x) = pow(2., x);\n        \n        \n        // Rotate the XY plane.\n        vec2 q = p.xy*r;\n        \n        // Rounded box.\n        float box = sBoxS(q, vec2(s), .2*s*1.);//vec2(sf*sf)//\n        // Circular box option... Otherwise known as a circle. :D\n        // You'd need to make changes to the bump and texturing functions.\n        //float box = length(q) - s; \n\n        // Extrude -- Inner and outer.\n        float di = opExtrusion(box+.0*s, p.z - s, (.25));//sf*sf\n        float di2 = opExtrusion(abs(box + .04*s) - .04*s, p.z - s, (.25 + .025));//sf*sf\n        //di2 += smoothstep(0., .5, cos(box*80./s + .0))*.01*s;\n        di = min(di, di2);\n        \n        // Record the minimum extruded box distance.\n        if(di<d){\n        \n            d = di;\n            gS = vec4(s, q, i);\n            gR = r;\n        \n        }\n    }\n \n    // Overall object ID.\n    vID = vec4(d, wall, 1e5, 1e5);\n    \n    // Combining the wall with the extruded object.\n    return  min(d, wall);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = ZERO; i<80; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001 || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.9; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = ZERO; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... \n    // Not on my slow test machine, anyway.\n    const int maxIterationsShad = 32; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), .0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = ZERO; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .15); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 2., occ = 0.;\n    for( int i = ZERO; i<5; i++ ){\n    \n        float hr = float(i + 1)*.125/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .85;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n    \n}\n\n\n///////\n\n#define STATIC\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) {  \n     \n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    \n    #ifdef STATIC\n    return fract(vec2(262144, 32768)*n); \n    #else\n    // Animated.\n    p = fract(vec2(262144, 32768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*6.2831853 + iTime/2.)*.5 + .5; \n    #endif\n}\n\n\n/*\n// Commutative smooth minimum function. Provided by Tomkh and taken from \n// Alex Evans's (aka Statix) talk: \n// http://media.lolrus.mediamolecule.com/AlexEvans_SIGGRAPH-2015.pdf\n// Credited to Dave Smith @media molecule.\nfloat smin(float a, float b, float r)\n{\n   float f = max(0., 1. - abs(b - a)/r);\n   return min(a, b) - r*.25*f*f;\n}\n*/\n\n/*\n// IQ's polynomial-based smooth minimum function.\nvec3 smin( vec3 a, vec3 b, float k ){\n\n    vec3 h = clamp(.5 + .5*(b - a)/k, 0., 1.);\n    return mix(b, a, h) - k*h*(1. - h);\n}\n*/\n\n// IQ's exponential-based smooth minimum function. Unlike the polynomial-based\n// smooth minimum, this one is associative and commutative.\nfloat sminExp(float a, float b, float k)\n{\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res)/k;\n}\n\n\n// The is a variation on a regular 2-pass Voronoi traversal that produces a Voronoi\n// pattern based on the interior cell point to the nearest cell edge (as opposed\n// to the nearest offset point). It's a slight reworking of Tomkh's example, which\n// in turn, is based on IQ's original example. The links are below:\n//\n// On a side note, I have no idea whether a faster solution is possible, but when I\n// have time, I'm going to try to find one anyway.\n//\n// Voronoi distances - iq\n// https://www.shadertoy.com/view/ldl3W8\n//\n// Here's IQ's well written article that describes the process in more detail.\n// https://iquilezles.org/articles/voronoilines\n//\n// Faster Voronoi Edge Distance - tomkh\n// https://www.shadertoy.com/view/llG3zy\n\nfloat vAng;\n\n\nvec2 cellID; // Individual Voronoi cell IDs.\n\nvec3 Voronoi(in vec2 p){\n    \n    // One of Tomkh's snippets that includes a wrap to deal with\n    // larger numbers, which is pretty cool.\n\n#if 1\n    // Slower, but handles big numbers better.\n    vec2 n = floor(p);\n    p -= n;\n    vec2 h = step(.5, p) - 1.5;\n    n += h; p -= h;\n#else\n    vec2 n = floor(p - 1.);\n    p -= n;\n#endif\n    \n    \n    \n    // Storage for all sixteen hash values. The same set of hash values are\n    // reused in the second pass, and since they're reasonably expensive to\n    // calculate, I figured I'd save them from resuse. However, I could be\n    // violating some kind of GPU architecture rule, so I might be making \n    // things worse... If anyone knows for sure, feel free to let me know.\n    //\n    // I've been informed that saving to an array of vectors is worse.\n    //vec2 svO[3];\n    \n    // Individual Voronoi cell ID. Used for coloring, materials, etc.\n    cellID = vec2(0); // Redundant initialization, but I've done it anyway.\n\n    // As IQ has commented, this is a regular Voronoi pass, so it should be\n    // pretty self explanatory.\n    //\n    // First pass: Regular Voronoi.\n\tvec2 mo, o;\n    \n    // Minimum distance, \"smooth\" distance to the nearest cell edge, regular\n    // distance to the nearest cell edge, and a line distance place holder.\n    float md = 8., md2, lMd = 8., lMd2 = 8., lnDist, d;\n    \n    for( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n    \n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // Saving the hash values for reuse in the next pass. I don't know for sure,\n        // but I've been informed that it's faster to recalculate the had values in\n        // the following pass.\n        //svO[j*3 + i] = o; \n  \n        // Regular squared cell point to nearest node point.\n        d = dot(o, o); \n\n\t\tif( d<md ){\n            \n            md2 = md;\n            md = d;  // Update the minimum distance.\n            // Keep note of the position of the nearest cell point - with respect\n            // to \"p,\" of course. It will be used in the second pass.\n            mo = o; \n            cellID = vec2(i, j) + n; // Record the cell ID also.\n            \n            vAng = atan(o.y, o.x);\n        }\n        else if(d<md2) {\n            md2 = d; \n            \n            \n        }\n       \n    }\n\t}\n    \n\n    // Second pass: Distance to closest border edge. The closest edge will be one of the edges of\n    // the cell containing the closest cell point, so you need to check all surrounding edges of \n    // that cell, hence the second pass... It'd be nice if there were a faster way.\n\tfor( int j = ZERO; j<3; j++ ){\n    for( int i = ZERO; i<3; i++ ){\n        \n        // I've been informed that it's faster to recalculate the hash values, rather than \n        // access an array of saved values.\n        o = vec2(i, j);\n        o += hash22(n + o) - p;\n        // I went through the trouble to save all sixteen expensive hash values in the first \n        // pass in the hope that it'd speed thing up, but due to the evolving nature of \n        // modern architecture that likes everything to be declared locally, I might be making \n        // things worse. Who knows? I miss the times when lookup tables were a good thing. :)\n        // \n        //o = svO[j*3 + i];\n        \n        // Skip the same cell... I found that out the hard way. :D\n        if( dot(o-mo, o-mo)>.00001 ){ \n            \n            // This tiny line is the crux of the whole example, believe it or not. Basically, it's\n            // a bit of simple trigonometry to determine the distance from the cell point to the\n            // cell border line. See IQ's article for a visual representation.\n            lnDist = dot( 0.5*(o+mo), normalize(o-mo));\n            \n            // Abje's addition. Border distance using a smooth minimum. Insightful, and simple.\n            //\n            // On a side note, IQ reminded me that the order in which the polynomial-based smooth\n            // minimum is applied effects the result. However, the exponentional-based smooth\n            // minimum is associative and commutative, so is more correct. In this particular case, \n            // the effects appear to be negligible, so I'm sticking with the cheaper polynomial-based \n            // smooth minimum, but it's something you should keep in mind. By the way, feel free to \n            // uncomment the exponential one and try it out to see if you notice a difference.\n            //\n            // // Polynomial-based smooth minimum.\n            //lMd = smin(lMd, lnDist, .1); \n            //\n            // Exponential-based smooth minimum. By the way, this is here to provide a visual reference \n            // only, and is definitely not the most efficient way to apply it. To see the minor\n            // adjustments necessary, refer to Tomkh's example here: Rounded Voronoi Edges Analysis - \n            // https://www.shadertoy.com/view/MdSfzD\n            lMd = sminExp(lMd, lnDist, 15.); \n            \n            // Minimum regular straight-edged border distance. If you only used this distance,\n            // the web lattice would have sharp edges.\n            lMd2 = min(lMd2, lnDist);\n            \n            \n        }\n\n    }\n    }\n\n    // Return the smoothed and unsmoothed distance. I think they need capping at zero... but \n    // I'm not positive.\n    return max(vec3(lMd, lMd2, md2 - md), 0.);\n}\n//////\n\n// Surface bump function..\nfloat bumpSurf3D(in vec3 p, in vec3 n){\n\n    // Applying a Voronoi pattern.\n    // Globals from the map function.\n    vec4 svS = gS; // Texture sizing factor.\n    mat2 svR = gR; // Rotation matrix.\n\n    p.xy *= svR/svS.x;\n    n.xy *= svR;\n\n    float s = svS.x;\n    p.z -= s*.9;\n\n    float c = 0.;\n\n    vec3 v = Voronoi(p.xy*8.);\n\n    float vor = v.y;\n\n    // Ignore the borders.\n    float sq = sBoxS(p.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n    if(n.z<-.25 && sq<.0) {\n    \n        c = vor;\n    }\n\n    return c*svS.x;\n\n}\n\n\n \n// Standard function-based bump mapping routine: This is the cheaper four tap version. There's\n// a six tap version (samples taken from either side of each axis), but this works well enough.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor){\n    \n    // Larger sample distances give a less defined bump, but can sometimes lessen the aliasing.\n    const vec2 e = vec2(.001, 0);  \n    \n    // This utter mess is to avoid longer compile times. It's kind of \n    // annoying that the compiler can't figure out that it shouldn't\n    // unroll loops containing large blocks of code.\n    mat4x3 p4 = mat4x3(p, p - e.xyy, p - e.yxy, p - e.yyx);\n    \n    vec4 b4;\n    for(int i = ZERO; i<4; i++){\n        b4[i] = bumpSurf3D(p4[i], n);\n        if(n.x>1e5) break; // Fake break to trick the compiler.\n    }\n    \n    // Gradient vector: vec3(df/dx, df/dy, df/dz);\n    vec3 grad = (b4.yzw - b4.x)/e.x; \n   \n    \n    // Six tap version, for comparisson. No discernible visual difference, in a lot of cases.\n    //vec3 grad = vec3(bumpSurf3D(p - e.xyy) - bumpSurf3D(p + e.xyy),\n    //                 bumpSurf3D(p - e.yxy) - bumpSurf3D(p + e.yxy),\n    //                 bumpSurf3D(p - e.yyx) - bumpSurf3D(p + e.yyx))/e.x*.5;\n    \n  \n    // Adjusting the tangent vector so that it's perpendicular to the normal. It's some kind \n    // of orthogonal space fix using the Gram-Schmidt process, or something to that effect.\n    grad -= n*dot(n, grad);          \n         \n    // Applying the gradient vector to the normal. Larger bump factors make things more bumpy.\n    return normalize(n + grad*bumpfactor);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, -.5, -1); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(.03*cos(iTime/2.)*0., .125, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(1, .5, -1);// Put it a bit in front of the camera.\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = .75; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x)); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera for extra motion sickness. :)\n\trd.xy *= rot2( sin(iTime/2.)/16. );\n\trd.xz *= rot2( sin(iTime)/32. );\n\n    \n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n  \n    // Global scaling and rotation matrix.\n    vec4 svS = gS;\n    mat2 svR = gR;\n    \n   \n \n    // Obtaining the object ID.\n    objID = vID[0]<vID[1]? 0 : 1;\n    /*\n    objID = 0;\n    float obD = vID[0];\n    for(int i = 0; i<4; i++){ \n        if(vID[i]<obD){ obD = vID[i]; objID = i; }\n    }\n    */\n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n        vec3 sn0 = sn; // Normal with no bump.\n        \n        if(objID==0) sn = doBumpMap(sp, sn, .5);///(1. + t/FAR*1.)\n        \n        \n            \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 8.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n         \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 5.);\n        \n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.2, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n          \n        // Obtaining the texel color. \n\t    vec3 texCol;   \n\n        // Object coloring.   \n        \n        if(objID==0){ // The extruded rounded boxes.\n            \n            // Coordinatges.\n            vec3 txP = sp;\n            vec3 txN = sn;\n            \n            // XY rotation and scaling.\n            txP.xy *= svR/svS.x;\n            txN.xy *= svR;\n            \n            //txP.xy -= hash22(vec2(svS.w, svS.w*57.));\n            float s = pow(svS.x, 1.);\n            txP.z -= s*.9;// - hash21(vec2(svS.w, svS.w*113.));//See distance function.\n\n \n             \n            // Texture.\n            vec3 tx = tex3D(iChannel0, txP, txN);\n            texCol = .05 + tx*1.5;\n            \n            // Alternative coloring.\n            //texCol = mix(texCol, vec3(dot(texCol, vec3(.299, .587, .114))), mod(svS.w, 2.)*.35);\n            // No texture.\n            //texCol = vec3(.6);\n \n            \n            \n            // Voronoi pattern.\n            vec3 v = Voronoi(txP.xy*vec2(8));\n\n            float vor = v.y;\n            float sq = sBoxS(txP.xy, vec2(1. - .08), .2/1.6*1.); // See \"map\" function.\n            if(sn0.z<-.5 && sq<.0) {\n            \n                // Greyscale toning.\n                vec3 svCol = texCol;\n                float gr = dot(texCol, vec3(.299, .587, .114));\n                texCol = mix(texCol, vec3(gr), .15);\n                \n                // Color application.\n                //vec3 iCol = (.5 + .45*cos(6.2831*svS.w/8. + vec3(0, 1, 2)*1.))*3.;\n                vec3 iCol = vec3(2);\n                vec3 iCol2 = (iCol + vec3(.1))*2.;\n                texCol = mix(texCol*iCol, texCol*.25, 1. - smoothstep(0., .1, vor - .2));\n                texCol = mix(texCol, svCol*iCol2, 1. - smoothstep(0., .04, abs(vor - .2 + .03) - .03));\n                texCol = mix(texCol, svCol*iCol2*0., 1. - smoothstep(0., .04, abs(vor) - .01));\n      \n           }\n           else {\n               \n               // Darker borders.\n               texCol *= .5;\n               // Lightening the edges.\n               if(sn0.z<-.25){\n                   texCol = mix(texCol, texCol*3., 1. - smoothstep(0., .005, -(abs(sq - .04) - .03)));\n               }\n           }\n \n            \n        }\n        else { //  Wall.\n            \n            texCol = vec3(0);\n        }\n\n       \n        \n        // Combining the above terms to procude the final color.\n        col = texCol*(diff*sh + .2 + vec3(.5, .7, 1)*spec*sh*1.);\n        \n        // Fake Fresnel reflections.\n        vec3 refl = reflect(rd, sn);\n        vec3 refTex = texture(iChannel1, refl).xyz; refTex *= refTex;\n        col = mix(col, (col + .25)*refTex*(sh + .2)*4., mix(.05, .35, fre));//*refTex*sh;\n    \n\n        // Shading.\n        col *= ao*atten;\n       \n\t\n\t}\n    \n    // Background fog.\n    col = mix(col, vec3(.025, .015, .01), smoothstep(0., .99, t/FAR));\n    \n    \n    // Rought gamma correction.\n\tfragColor = vec4(pow(max(col, 0.), vec3(1./2.2)), 1);\n\t\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2591, 2624, 2646, 2646, 2704], [2707, 2735, 2756, 2756, 2819], [2821, 2901, 2947, 2947, 3504], [3507, 3534, 3591, 3752, 3888], [3891, 3919, 3966, 3966, 4056], [6218, 6239, 6275, 6324, 6785], [7597, 7788, 7840, 7965, 9274], [9277, 9429, 9465, 9465, 9719], [9747, 9769, 9790, 10145, 10680], [11213, 11352, 11394, 11394, 11459], [12261, 12261, 12285, 12400, 17654], [17663, 17690, 17729, 17803, 18226], [18231, 18422, 18477, 18578, 19830], [19832, 19832, 19888, 19921, 26246]], "test": "untested"}
{"id": "ft2GRG", "name": "Input Error", "author": "byt3_m3chanic", "description": "Taking something I've been messin with a little further.. ", "tags": ["truchetcubemapdemo"], "likes": 27, "viewed": 395, "published": 3, "date": "1652271637", "time_retrieved": "2024-07-30T16:49:20.381549", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    [Input Error] 5/11/22\n    created with love by your friendly @byt3_m3chanic\n\n*/\n\n#define PI  3.14159265359\n\nvec2 curvature = vec2(15.);\nvec2 remapUV(vec2 uv) {\n    uv = uv * 2. -1.;\n    vec2 offset = abs(uv.yx) / vec2(curvature.x, curvature.y);\n    uv = uv + uv * offset * offset;\n    uv = uv * .5 + .5;\n    return uv;\n}\n\nvec4 scanLine(float uv, float resolution, float opacity) {\n     float intensity = sin(uv * resolution * PI * 2.);\n     intensity = ((.5 * intensity) + .5) * .9 + .1;\n     return vec4(vec3(pow(intensity, opacity)), 1.);\n}\n\nvec4 vignette(vec2 uv, vec2 resolution, float opacity) {\n    float intensity = uv.x * uv.y * (1. - uv.x) * (1. - uv.y);\n    return vec4(vec3(clamp(pow((resolution.x / 4.) * intensity, opacity), 0.0, 1.)), 1.);\n}\n\nvec2 scanLineOpacity = vec2(.35);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    uv=(uv*1.05)-vec2(.025,.025);\n    vec2 vuv = remapUV(uv);\n    \n    vec4 baseColor = texture(iChannel0, vuv);\n\n    baseColor *= vignette(vuv, iResolution.xy, .75);\n    baseColor *= scanLine(vuv.x, iResolution.y*.85, scanLineOpacity.x);\n    baseColor *= scanLine(vuv.y, iResolution.x*.85, scanLineOpacity.y);\n\n    if (vuv.x < 0.0 || vuv.y < 0.0 || vuv.x > 1.0 || vuv.y > 1.0){\n        baseColor = vec4(vec3(.0),0);\n    }\n   \n    fragColor = baseColor;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    [Input Error] 5/11/22\n    created with love by your friendly @byt3_m3chanic\n\n*/\n\n#define R   iResolution\n#define M   iMouse\n#define T   iTime\n#define PI  3.14159265359\n#define PI2 6.28318530718\n\n#define MAX_DIST    100.\n#define MIN_DIST    .001\n\nfloat hash21(vec2 p){ return fract(sin(dot(p,vec2(26.34,45.32)))*4324.23); }\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n// @gaz\nfloat zag(vec3 p, float s) {\n    p = abs(p)-s;\n    if (p.x < p.z) p.xz = p.zx;\n    if (p.y < p.z) p.yz = p.zy;\n    if (p.x < p.y) p.xy = p.yx;\n    return dot(p,normalize(vec3(s*1.,s,1.5)))-.15;\n    //return dot(p,normalize(vec3(s*.45,s,.0)));\n}\n//@iq\nfloat box( vec3 p, vec3 b ){\n  vec3 q = abs(p) - b;\n  return length(max(q,0.)) + min(max(q.x,max(q.y,q.z)),.0);\n}\n\nvec3 hit=vec3(0),hitPoint=vec3(0);\nfloat mtime = 0.,time = 0.,glow = 0.;\nmat2 turn,r90,r45;\n\nvec2 map(vec3 pos, float sg)\n{\n    vec2 res = vec2(1e5,0.);\n    vec3 dp = pos-vec3(0,1.25,1);\n    \n    dp.yx*=turn;\n    dp.zx*=turn;\n\n    float d1 = box(dp,vec3(1.75));//\n    float d2 = d1;\n    d1 = max(d1,-zag(dp,.65));\n\n    if(d1<res.x){\n        res = vec2(d1,d2<d1?3.:2.);\n        hit=dp;\n    }\n\n    float m1 = length(dp)-.25;\n    if(m1<res.x){\n        res = vec2(m1,4.);\n        hit=dp;\n    }\n    if(sg>0.){\n        //glow += smoothstep(.1,.25,.0025/(.0105+m1*m1*m1));\n       glow += smoothstep(.01,.5,.025/(.0015+m1*m1));\n    }\n    \n    float flr = pos.y+3.;\n    if(flr<res.x){\n        res=vec2(flr,1.);\n    \thit=pos;\n    }\n    \n    return res;\n}\n\nvec2 marcher(vec3 ro, vec3 rd, int maxsteps, float sg){\n\tfloat d = 0.;\n    float m = 0.;\n    for(int i=0;i<maxsteps;i++){\n    \tvec2 ray = map(ro + rd * d, sg);\n        if(ray.x<MIN_DIST*d||d>MAX_DIST) break;\n        d += i<32 ? ray.x *.5 : ray.x;\n        m  = ray.y;\n    }\n\treturn vec2(d,m);\n}\n\nvec3 normal(vec3 p, float t)\n{\n    float e = MIN_DIST*t;\n    vec2 h =vec2(1,-1)*.5773;\n    vec3 n = h.xyy * map(p+h.xyy*e,0.).x+\n             h.yyx * map(p+h.yyx*e,0.).x+\n             h.yxy * map(p+h.yxy*e,0.).x+\n             h.xxx * map(p+h.xxx*e,0.).x;\n    return normalize(n);\n}\n\nvec3 truchet(vec2 p) {\n\n    float px = fwidth(length(p)-1.);\n    vec2 grid = fract(p.xy)-.5;\n    vec2 id   = floor(p.xy);\n    \n    float hs = hash21(id);\n    if(hs>.5) grid.x*=-1.;\n    \n    vec3 bc = vec3(.05);\n    vec3 h = vec3(.2); \n    h=clamp(h+.45,vec3(0),vec3(1));\n\n    vec2 d2 = vec2(length(grid-.5), length(grid+.5));\n    vec2 gx = d2.x<d2.y? vec2(grid-.5) : vec2(grid+.5);\n    \n    float circle = length(gx)-.5;\n    float tt = -T*1.2;\n    float l1 = .025+.065*cos(p.x*3.25+tt);\n    float l2 = .085+.065*sin(p.x*3.25+tt);\n    float l3 = .085+.065*sin(p.x*2.25+tt);\n    \n    if(hs>.88){\n     circle = abs(length(gx.x)-.5)-.001;\n    circle = min(circle,abs(length(gx.y)-.5)-.001);\n    }\n    \n    float circle2 = abs(abs(circle)-l1)-(l2);\n    circle2=smoothstep(-px,px,circle2);\n\n    circle=smoothstep(-px,px,\n    abs(abs(abs(circle)-l1)-l2)-l3\n    );\n    \n    vec2 sx = abs(grid)-.5;\n    float cbx = length(sx)-.1;\n    cbx=abs(cbx)-(l3*.75);\n    cbx=smoothstep(px,-px,cbx);\n\n    h = mix(h, bc,circle);\n    h = mix(h, vec3(.2,0,0),min(circle2,circle));\n\n    h = mix(h, vec3(1,0,0),cbx);\n    return h;\n}\n\nvec2 logPolar(vec2 p) {//@mla\n\tp = vec2(log(length(p)), atan(p.y, p.x));\n\treturn p;\n}\n\nvec4 FC = vec4(0.006,0.006,0.006,0.);\n\nvec4 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, bool last, inout float d, vec2 uv) {\n\n    vec3 C = vec3(0);\n    vec2 ray = marcher(ro,rd,192, 1.);\n\n    hitPoint = hit;\n    d = ray.x;\n    float m = ray.y;\n    float alpha = 0.;\n    \n    if(d<MAX_DIST)\n    {\n        vec3 p = ro + rd * d;\n        vec3 n = normal(p,d);\n        vec3 lpos =vec3(2,8,5);\n        vec3 l = normalize(lpos-p);\n        \n        vec3 h = vec3(.5);\n        vec3 hp = hitPoint;\n\n        float diff = clamp(dot(n,l),0.,1.);\n\n        float shdw = 1.0;\n        for( float t=.01; t < 18.; )\n        {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = 0.; break; }\n            shdw = min(shdw, 24.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>42. ) break;\n        }\n        \n        diff = mix(diff,diff*shdw,.65);\n        \n        vec3 view = normalize(p - ro);\n        vec3 ret = reflect(normalize(lpos), n);\n        float spec =  0.5 * pow(max(dot(view, ret), 0.),24.);\n\n        if(m==1.){\n            vec2 uv =hitPoint.xz;\n            uv=logPolar(uv)*3.5;\n            \n            uv.x-=T*1.02;\n            h = truchet(uv);\n            C = (diff*h);\n            ref = vec3(1);\n        }\n        \n        if(m==2.){\n            h = vec3(0.01);\n            C = (diff*h)+spec;\n            ref = vec3(.25);\n        }\n        if(m==3.){\n            h = vec3(1,0,0);\n            C = (diff*h)+spec;\n            ref = h;\n        }\n        if(m==4.){\n            h = vec3(.5);\n            C = (diff*h)+spec;\n            ref = h;\n        }\n        ro = p+n*.01;\n        rd = reflect(rd,n);\n    } \n\n    float glowMask = clamp(glow,.0,1.);\n    C = mix(C,vec3(glow),glowMask);\n    return vec4(C,alpha);\n}\n\nvoid mainImage( out vec4 O, in vec2 F )\n{   \n    turn = rot(T*15.*PI/180.);\n    r45 = rot(.78);\n    r90 = rot(1.5707);\n    vec2 uv = (2.*F.xy-R.xy)/max(R.x,R.y);\n    vec3 ro = vec3(0,.05,10.5);\n    vec3 rd = normalize(vec3(uv,-1));\n\n    //mouse\n    float y = M.xy == vec2(0) ? 0. : -(M.x/R.x * 1. - .5) * PI;\n\n    mat2 rx = rot(.6);\n    mat2 ry = rot(y);\n    \n    ro.yz *= rx;\n    rd.yz *= rx;\n    ro.xz *= ry;\n    rd.xz *= ry;\n    \n    vec3 C = vec3(0);\n    vec3 ref=vec3(0), fil=vec3(1);\n    float d =0.;\n    float numBounces = 2.;\n    for(float i=0.; i<numBounces; i++) {\n        vec4 pass = render(ro, rd, ref, i==numBounces-1., d, uv);\n        C += pass.rgb*fil;\n        fil*=ref;\n        // first bounce - get fog layer\n        if(i==0.) FC = vec4(FC.rgb,exp(-.000015*d*d*d));\n    }\n\n    //layer fog in   \n    C = mix(C,FC.rgb,1.-FC.w);\n    C = clamp(C,vec3(0),vec3(1));\n    // gamma\n    C = pow(C, vec3(.4545));\n    O = vec4(C,1.0);\n}\n\n\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2GRG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[234, 234, 257, 257, 418], [420, 420, 478, 478, 640], [642, 642, 698, 698, 853], [890, 890, 947, 947, 1445]], "test": "untested"}
{"id": "7l2fWW", "name": " - Late night cubi", "author": "totetmatt", "description": "2.30 am creativity fart :) ", "tags": ["cube"], "likes": 31, "viewed": 596, "published": 3, "date": "1652256986", "time_retrieved": "2024-07-30T16:49:21.217315", "image_code": "vec3 erot(vec3 p,vec3 ax,float t){\n    return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);\n }\nfloat box3(vec3 p,vec3 b){\n  vec3 q = abs(p)-b;\n  return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nvec2 sdf(vec3 p){\n\n  vec2 h;\n  h.x = 100.;\n  vec4 pp = vec4(p,1.);\n  pp*=.5;\n  \n  for(float i=0.;i<6.;i++){\n    \n      pp *=1.3;\n       pp.xyz = erot(pp.xyz,normalize(vec3(sin(iTime*.1+i*pp.a),.1+cos(pp.a),.2)),i+iTime*.1);\n     h.x = min((length(pp.xy)-.01)/pp.a,h.x);\n    h.x = min((length(pp.xz)-.01)/pp.a,h.x);\n    h.x = min((length(pp.yz)-.01)/pp.a,h.x);\n      h.x = min(h.x,abs(box3(pp.xyz,vec3(1.75)/pp.a)/pp.a));\n  }\n  h.y = 1.;\n  return h;\n}\nfloat hash31( vec3 p ) {\n\tfloat h = dot(p,vec3(17, 1527, 113));\t\n    return fract(sin(h)*43758.5453123);\n}\n#define q(s) s*sdf(p+s).x\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(.1);\n  vec3 ro = vec3(0.,0.,-7.);\n  \n  vec3 rt = vec3(0,0.,0);\n \n  \n  vec3 rd = normalize(vec3(uv,1.-.8*sqrt(length(uv))));\n  vec3 rp = ro;\n  \n  float dd = 0.;\n  vec3 acc = vec3(0.);\n  for(float i=0.;i<128.;i++){\n    \n      vec2 d = sdf(rp);\n      acc +=vec3(.5,sin(length(rp*2.))*.5+.5,cos(length(rp*2.))*.5+.5)*exp(-abs(d.x))/(160.+clamp(asin(cos(length(rp)-iTime*4.-hash31(floor(rp*2.)/2.))),-1.,1.)*130.);\n      d.x = max(.001,abs(d.x));\n      dd+=d.x ;\n      if(dd>60.) break;\n      rp+=rd*d.x;\n    \n  }\n\n    // Output to screen\n    fragColor = vec4(col+acc,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2fWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 95], [96, 96, 122, 122, 209], [210, 210, 227, 227, 660], [661, 661, 685, 685, 767], [794, 794, 851, 901, 1549]], "test": "untested"}
{"id": "sljBWD", "name": "basic desert", "author": "jorge2017a2", "description": "basic desert", "tags": ["basicdesert"], "likes": 17, "viewed": 298, "published": 3, "date": "1652234294", "time_retrieved": "2024-07-30T16:49:22.204675", "image_code": "//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//basic desert---10-may-2022\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\n///----------Operacion de Distancia--------\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n///------------------------------------\n// object transformation\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nvec2 rotatev2(vec2 p, float ang)\n{   float c = cos(ang); float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat sdVesica(vec2 p, float r, float d)\n{   p = abs(p);\n    float b = sqrt(r*r-d*d);\n    return ((p.y-b)*d>p.x*b) ? length(p-vec2(0.0,b)): length(p-vec2(-d,0.0))-r;\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0); vec3 p0=p;\n    //ref shane\n    //https://www.shadertoy.com/view/Xs33Df\n    float tx = textureLod(iChannel2, p.xz/8. + p.xy/80., 0.).x;\n    vec3 q = p*0.5;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    \n    float planeDist1 = p.y-1.0+h*2.0;\n    res =opU2(res, vec2(planeDist1,37.0));\n    \n    p= rotate_z(p, radians(-25.0));\n    float d1= sdBox(p-vec3(-11.0,10.0,.0), vec3(2.0,25.0,5.0) );\n    float d2= sdBox(p-vec3(11.0,10.0,0.0), vec3(2.0,25.0,5.0) );\n    p.y-=5.0;\n    vec2 pnew2=rotatev2(p.xy-vec2(0.0,10.0), radians(90.0));\n    \n    float d3a= sdVesica(pnew2, 10., 5.0);\n    float d3b= sdVesica(pnew2, 10., 6.0);\n    \n    float d4a= sdBox(p, vec3(15.0,20.0,2.0) );\n    float d4b= sdBox(p, vec3(15.0,20.0,2.5) );\n    float d5a= sdCylinderXY(p-vec3(0.0,10.0,0.), vec2(2.5,3.0) );\n    float d5b= sdCylinderXY(p-vec3(0.0,10.0,0.), vec2(2.0,4.5) );\n    \n    d4a=Intersect(d3a,d4a);\n    d4b=Intersect(d3b,d4b);\n    float dif1=Difference(d5a,d5b);\n    res =opU2(res, vec2(d1+h*.8,100.0));\n    res =opU2(res, vec2(d2+h*0.5,100.0));\n    res =opU2(res, vec2(d4a,100.0));\n    res =opU2(res, vec2(d4b,101.0));\n    res =opU2(res, vec2(dif1,100.0));\n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.0; }\n\tif (i==101 ) { return tex3D(iChannel0, p/32., nor)*vec3(1.0,2.0,1.0); }\n\t\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8), 1.0 - rd.y);\n    // float d = pow(rd.z+0.3,2.)*pow(rd.z*0.5+0.5,1.)/pow(1.3,2.)*0.9+0.1;\n    //return sky*d;\n    return sky;\n    \n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n\n     if(id_color==37) { colobj= mix( vec3(0.5,0.5,0.0), vec3(1.0, 0.82, 0.15),0.5 );  return colobj; }\n     \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n    }\n    else if(hit.x>MAX_DIST)\n    col= render_sky_color(rd);\n   return col;\n}\n\n\nRay RotarEnCirculo(vec3 ro,vec3 rd)\n{\n   float r=27.0;\n   float veltime=20.0;  \n    float tt = radians( -iTime*veltime);\n\n    vec3  pos=vec3(0.0,2.5,30.0);\n    vec3 rotation1 =pos+ vec3(r*sin(tt), 0.0, r*cos(tt));\n    ro +=rotation1;   \n    rd=rotate_y( vec3(-rd.x,rd.y,-rd.z), tt);\n    return  Ray(ro,rd);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    t=mod(iTime*1.0,360.0);\n \tlight_pos1= vec3(-10.0, 120.0, -25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(10.0, 20.0, -30.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,7.0,-35.0);\n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   Ray ry= RotarEnCirculo(ro,rd);\n   ro=ry.ro;\n   rd=ry.rd;\n   \n    //light_pos1+=ro;\n    //light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\nstruct Ray\n{   vec3 ro; // origin\n    vec3 rd; // direction\n};\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n\n", "sound_code": "\n\nstruct Note {\n    // in Hz, see \"common\" tab\n    float frequency;\n    // offset - time in seconds when to start playing note\n    float offset;\n    // duration of a note (1/4, 1/8, ...), see \"common\" tab\n    float duration;\n};\n\n\n\n\n\n//version D \n////Octava #1\n//--fin--\n////Octava #2\n const float A0 =27.5;  //1\n const float A_0 =29.14;  //2\n const float B0 =30.87;  //3\n//--fin--\n////Octava #3\n const float C1 =32.7;  //4\n const float C_1 =34.65;  //5\n const float D1 =36.71;  //6\n const float D_1 =38.89;  //7\n const float E1 =41.2;  //8\n const float F1 =43.65;  //9\n const float F_1 =46.25;  //10\n const float G1 =49.0;  //11\n const float G_1 =51.91;  //12\n const float A1 =55.;  //13\n const float A_1 =58.27;  //14\n const float B1 =61.74;  //15\n//--fin--\n////Octava #4\n const float C2 =65.41;  //16\n const float C_2 =69.3;  //17\n const float D2 =73.42;  //18\n const float D_2 =77.78;  //19\n const float E2 =82.41;  //20\n const float F2 =87.31;  //21\n const float F_2 =92.5;  //22\n const float G2 =98.;  //23\n const float G_2 =103.83;  //24\n const float A2 =110.;  //25\n const float A_2 =116.54;  //26\n const float B2 =123.47;  //27\n//--fin--\n////Octava #5\n const float C3 =130.81;  //28\n const float C_3 =138.59;  //29\n const float D3 =146.83;  //30\n const float D_3 =155.56;  //31\n const float E3 =164.81;  //32\n const float F3 =174.61;  //33\n const float F_3 =185.;  //34\n const float G3 =196.;  //35\n const float G_3 =207.65;  //36\n const float A3 =220.;  //37\n const float A_3 =233.08;  //38\n const float B3 =246.94;  //39\n//--fin--\n////Octava #6\n const float C4 =261.63;  //40\n const float C_4 =277.18;  //41\n const float D4 =293.66;  //42\n const float D_4 =311.13;  //43\n const float E4 =329.63;  //44\n const float F4 =349.23;  //45\n const float F_4 =369.99;  //46\n const float G4 =392.;  //47\n const float G_4 =415.3;  //48\n const float A4 =440.;  //49\n const float A_4 =466.16;  //50\n const float B4 =493.88;  //51\n//--fin--\n////Octava #7\n const float C5 =523.25;  //52\n const float C_5 =554.37;  //53\n const float D5 =587.33;  //54\n const float D_5 =622.25;  //55\n const float E5 =659.26;  //56\n const float F5 =698.46;  //57\n const float F_5 =739.99;  //58\n const float G5 =783.99;  //59\n const float G_5 =830.61;  //60\n const float A5 =880.;  //61\n const float A_5 =932.33;  //62\n const float B5 =987.77;  //63\n//--fin--\n////Octava #8\n const float C6 =1046.5;  //64\n const float C_6 =1108.73;  //65\n const float D6 =1174.66;  //66\n const float D_6 =1244.51;  //67\n const float E6 =1318.51;  //68\n const float F6 =1396.91;  //69\n const float F_6 =1479.98;  //70\n const float G6 =1567.98;  //71\n const float G_6 =1661.22;  //72\n const float A6 =1760.;  //73\n const float A_6 =1864.66;  //74\n const float B6 =1975.53;  //75\n//--fin--\n////Octava #9\n const float C7 =2093.;  //76\n const float C_7 =2217.46;  //77\n const float D7 =2349.32;  //78\n const float D_7 =2489.02;  //79\n const float E7 =2637.02;  //80\n const float F7 =2793.83;  //81\n const float F_7 =2959.96;  //82\n const float G7 =3135.96;  //83\n const float G_7 =3322.44;  //84\n const float A7 =3520.;  //85\n const float A_7 =3729.31;  //86\n const float B7 =3951.07;  //87\n//--fin--\n////Octava #10\n const float C8 =4186.01;  //88\n const float C_8 =4434.92;  //89\n const float D8 =4698.64;  //90\n const float D_8 =4978.03;  //91\n const float E8 =5274.04;  //92\n const float F8 =5587.65;  //93\n const float F_8 =5919.91;  //94\n const float G8 =6271.93;  //95\n const float G_8 =6644.88;  //96\n const float A8 =7040.;  //97\n const float A_8 =7458.62;  //98\n const float B8 =7902.13;  //99\n//--fin--\n\n\n// Durations\nconst float WHOLE_NOTE = 1.0;\nconst float HALF_NOTE = 1.0/2.0;\nconst float _4_NOTE = 1.0/4.0;\nconst float _8_NOTE = 1.0/8.0;\nconst float _16_NOTE = 1.0/16.0;\nconst float _32_NOTE = 1.0/32.0;\nconst float DOUBLE_NOTE = 2.0;\n\n//octava\nconst float _0oct8=0.0/8.0;\nconst float _1oct8=1.0/8.0;\nconst float _2oct8=2.0/8.0;\nconst float _3oct8=3.0/8.0;\nconst float _4oct8=4.0/8.0;\nconst float _5oct8=5.0/8.0;\nconst float _6oct8=6.0/8.0;\nconst float _7oct8=7.0/8.0;\nconst float _8oct8=8.0/8.0;\n\nconst float _1cua4=1.0/4.0;\nconst float _2cua4=2.0/4.0;\nconst float _3cua4=3.0/4.0;\nconst float _4cua4=4.0/4.0;\n\nconst float _1med2=1.0/2.0;\n\nconst float _t1=1.0;\nconst float _t2=2.0;\nconst float _t3=3.0;\nconst float _t4=4.0;\nconst float _t5=5.0;\n\nconst float _1hex16=1.0/16.0;\nconst float _2hex16=2.0/16.0;\nconst float _3hex16=3.0/16.0;\nconst float _4hex16=4.0/16.0;\n\nconst Note[] notes = Note[] (\nNote(C4,0.0,0.25),\nNote(F2,1./4.,_7oct8),\nNote(A2,1./4.,_7oct8),\nNote(C3,1./4.,_7oct8),\nNote(A3,1./4.,_1med2),\nNote(A3,5./8.,_1oct8),\nNote(C4,6./8.,_1oct8),\nNote(D4,7./8.,_1oct8),\n\nNote(E2,_t1,_7oct8),\nNote(G2,_t1,_7oct8),\nNote(C3,_t1,_7oct8),\nNote(G3,_t1,_5oct8),\nNote(C3,_t1+_6oct8,_1oct8),\nNote(A3,_t1+_7oct8,_1oct8),\n\n\nNote(E2,_t2,_7oct8),\nNote(G2,_t2,_7oct8),\nNote(C3,_t2,_7oct8),\nNote(A_3,_t2,_2oct8),\nNote(F4,_t2+_2oct8,_2oct8),\nNote(F4,_t2+_5oct8,_1oct8),\nNote(E4,_t2+_6oct8,_1oct8),\nNote(C4,_t2+_7oct8,_1oct8),\n\nNote(F2,_t3,_7oct8),\nNote(A2,_t3,_7oct8),\nNote(C3,_t3,_7oct8),\nNote(A3,_t3+_2oct8,_4oct8),\nNote(A_3,_t3+_3hex16,_1hex16),\nNote(C4,_t3+_2hex16,_1hex16),\nNote(D4,_t3,_1oct8),\nNote(C4,_t3+_7oct8,_1oct8),\n\n\nNote(F2, _t4,_7oct8),\nNote(A_2,_t4,_7oct8),\nNote(D3,_t4,_7oct8),\nNote(D4,_t4+0.,_3hex16),\nNote(D4,_t4+_1oct8,_1oct8),\nNote(D4,_t4+_3oct8,_1oct8),\nNote(G4,_t4+_3oct8+_1hex16,_1hex16),\nNote(F4,_t4+_3oct8+_2hex16,_1hex16),\nNote(E4,_t4,_4oct8),\nNote(F4,_t4+_5oct8,_1hex16),\nNote(D4,_t4,_1oct8)\n\n);\n\nfloat Weight( float x )\n{  if( x < 0.0 )x = - x;\n\tif( x < 1.0 )return (1.0 - 2.0*x*x + x*x*x) ;\n\tif( x < 2.0 )return (4.0 - 8.*x + 5.*x*x - x*x*x) ;\nreturn 0.0 ;\n}\n\n\nfloat saw(float t, float note, float octave)\n{   return fract(t*note*exp2(octave-1.))-0.5; }\n\n\nvec2 noteFreq(Note note, float time) \n{\n    float octava=3.0;\n    float n1=saw(time,note.frequency, octava)* exp(-1.0/note.duration * (time - note.offset));  ///ORIGINAL\n    float t=time;\n    n1=Weight(n1)*n1;    \n    return vec2(n1);\n}\n\nvec2 mainSound( in int samp,float time) \n{   vec2 result;\n    float tt=sin(time*0.25);\n    float ftime= mod(time*0.5, 6.0);\n    for (int i = 0; i < notes.length(); i++) {\n        Note note = notes[i];\n        float x = float(i) * 1.0;\n        if (ftime > note.offset) \n        { result += noteFreq(note, ftime);  }\n    }\n    return result*0.35;\n}", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljBWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 523, 523, 607], [608, 608, 647, 647, 742], [744, 788, 832, 832, 859], [860, 860, 900, 900, 927], [928, 928, 973, 973, 1001], [1002, 1002, 1038, 1038, 1083], [1084, 1149, 1183, 1183, 1279], [1280, 1280, 1314, 1314, 1405], [1406, 1406, 1440, 1440, 1531], [1533, 1533, 1567, 1567, 1658], [1660, 1660, 1702, 1702, 1827], [1829, 1829, 1854, 1854, 3096], [3098, 3098, 3122, 3122, 3284], [3286, 3286, 3334, 3334, 3613], [3616, 3616, 3660, 3660, 3981], [3983, 3983, 4020, 4020, 4277], [4279, 4279, 4369, 4369, 5329], [5331, 5331, 5380, 5380, 5533], [5535, 5535, 5567, 5567, 5868], [5870, 5870, 5940, 5940, 6148], [6150, 6150, 6177, 6177, 6266], [6268, 6268, 6326, 6326, 6374], [6376, 6376, 6399, 6399, 6511], [6513, 6513, 6544, 6544, 7164], [7167, 7167, 7204, 7204, 7475], [7479, 7479, 7536, 7536, 8032]], "test": "untested"}
{"id": "sl2BWh", "name": "fun with FABRIK", "author": "ArmandB", "description": "forwards and backwards reaching inverse kinematics\nhttp://andreasaristidou.com/FABRIK.html\n\nmess around with the parameters in the common tab", "tags": ["inversekinematics"], "likes": 6, "viewed": 238, "published": 3, "date": "1652230788", "time_retrieved": "2024-07-30T16:49:23.039443", "image_code": "///////////////////////////////////////\n//Go to Common tab to change parameters\n///////////////////////////////////////\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = getUV(iResolution.xy, fragCoord);\n    float pxunit = 1.0/iResolution.y; //a pixel in uv coordinates\n    \n    float d = 999.0; //distance to line segments\n    float n = 999.0; //distance to nodes\n\n    //read out segment data\n    for (int i = segments-1; i >= 0; i--){\n        vec2 s = texelFetch( iChannel0, ivec2(i,0),0).xy;\n        vec2 e = texelFetch( iChannel0, ivec2(i,0),0).zw;\n        d = min(d, sdfLine(s, e, width, uv));\n        n = min(n, distance(uv, e));\n        if (i == 0){\n            n = min(n, distance(uv, s))-0.01;\n        }\n    }\n    vec3 col = background_col;\n    if (show_sdf){\n        col = vec3(sin(d*100.0)/4.0 + 0.8 - d);\n    } else {\n        if (show_particles){\n            float p = 0.0;\n            if (do_current){\n                p = hash(floor((uv - current*float(iFrame))*80.0));\n            } else {\n                p = abs(mod(iTime/400.0,1.0)-hash(floor(uv*80.0)));\n            }\n            col = mix(particle_col, col, smoothstep(0.0,0.005,p));\n        }\n        col = mix(worm_col, col, smoothstep(0.0,pxunit*2.0,d));\n    }\n    if (show_nodes){\n        col = mix(segment_col, col, smoothstep(0.0,pxunit,d+width));\n        col = mix(node_col, col, smoothstep(0.0,pxunit,n));\n        col = mix(worm_col, col, smoothstep(0.0,pxunit,n+pxunit));\n        vec2 head = texelFetch( iChannel0, ivec2(segments-1,0),0).zw;\n        col = mix(node_col, col, smoothstep(0.0,pxunit,abs(distance(uv,head)-0.02)));\n     }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 reach(vec2 s, vec2 e){\n    vec2 d = s-e;\n    if (d == vec2(0)){ //fixes case where the start and end are the same (beginning of sim)\n        d = vec2(0.0001);\n    }\n    return normalize(d)*segmentLength + e;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = vec2(0);\n    vec2 e = vec2(0);\n    vec4[segments] segs;\n\n    if (int(fragCoord.x) < segments && int(fragCoord.y) == 0){\n        //read data\n        for (int i = 0; i < segments; i++){\n            segs[i] = texelFetch( iChannel0, ivec2(i,0),0);\n            if (do_current){\n                segs[i] += vec4(current,current);\n            }\n        }\n        if (dragable_nodes){ //dragable node mode\n            bool node_clicked = texelFetch( iChannel0, ivec2(0,1),0).z == 1.0;\n            int clicked = int(texelFetch( iChannel0, ivec2(0,1),0).w);\n            if (node_clicked && clicked != -1){\n                //loop from clicked up\n                //loop from clicked down\n                for (int i = clicked; i < segments; i++){\n                    vec2 mc = getUV(iResolution.xy, iMouse.xy);\n                    if (i == clicked){\n                       segs[i].xy = mc;\n                    } else {\n                       segs[i].xy = segs[i-1].zw;\n                    }\n                    segs[i].zw = reach(segs[i].zw, segs[i].xy);\n                }\n                for (int i = clicked-1; i >=0; i--){\n                    vec2 mc = getUV(iResolution.xy, iMouse.xy);\n                    if (i == clicked-1){\n                       segs[i].zw = mc;\n                    } else {\n                       segs[i].zw = segs[i+1].xy;\n                    }\n                    segs[i].xy = reach(segs[i].xy, segs[i].zw);\n                }\n            }\n        } else { //basic\n            for (int i = segments-1; i >=0; i--){\n                if (i == segments-1){\n                    segs[i].zw = texelFetch( iChannel0, ivec2(0,1),0).xy;\n                } else {\n                    segs[i].zw = segs[i+1].xy;\n                }\n                segs[i].xy = reach(segs[i].xy, segs[i].zw);\n            }\n        }\n        if (is_anchored){ //anchored mode\n            for (int i = 0; i < segments; i++){\n                if (i == 0){\n                    segs[i].xy = anchor;\n                } else {\n                    segs[i].xy = segs[i-1].zw;\n                }\n                segs[i].zw = reach(segs[i].zw, segs[i].xy);\n            }\n        }\n        //write this segment's data\n        s = segs[int(fragCoord.x)].xy;\n        e = segs[int(fragCoord.x)].zw;\n    }\n    \n    if (floor(fragCoord) == vec2(0,1)){\n        //mouse position\n        vec2 m = getUV(iResolution.xy, iMouse.xy);\n        if (followMouse){\n            vec2 p = texelFetch( iChannel0, ivec2(0,1),0).xy;\n            vec2 d = m-p;\n            s = (length(d) < speed ? d : normalize(d)*speed) + p;\n        } else {\n            s = m;\n        }\n        \n        //sets clicked segment\n        if (iMouse.z > 0.0 && dragable_nodes){\n            e.x = 1.0;\n            e.y = texelFetch( iChannel0, ivec2(0,1),0).w;\n            if (e.y == -1.0){\n                float mindist = 999.0;\n                for (int i = 0; i <= segments; i++){\n                    vec2 mc = getUV(iResolution.xy, abs(iMouse.zw));\n                    vec2 p = vec2(0);\n                    if (i < segments){\n                        p = texelFetch( iChannel0, ivec2(i,0),0).xy;\n                    } else {\n                        p = texelFetch( iChannel0, ivec2(i-1,0),0).zw;\n                    }\n                    float d = distance(mc,p);\n                    if (d <= 0.02 && d < mindist){\n                        e.y = float(i);\n                    }\n                }\n            }\n        } else {\n            e.y = -1.0;\n        }\n    }\n    fragColor = vec4(s,e);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//if true, chain will follow mouse at given speed. if false, chain will be attached to mouse\nconst bool followMouse = false; \n//chain is bounded to the anchor point\nconst bool is_anchored = false;\n//chain is dragged by current\nconst bool do_current = true;\n//chain nodes can be individually clicked and dragged (will disable following)\nconst bool dragable_nodes = false;\n\nconst int segments = 5;\nconst float segmentLength = 0.05;\nconst float width = 0.05;\nconst float speed = 0.01;\nconst vec2 current = vec2(0,-0.01);\nconst vec2 anchor = vec2(0,1);\n\n//show the vertices of the line segments (best used with dragable nodes)\nconst bool show_nodes = true;\n//shows particles that move downwards with current\nconst bool show_particles = true;\n//shows sdf of chain\nconst bool show_sdf = false;\n//shows target in follow mode\nconst bool show_target = true;\n\nconst vec3 worm_col = vec3(1);\nconst vec3 node_col = vec3(1,0.5,0);\nconst vec3 background_col = vec3(0,0.25,0.5);\nconst vec3 particle_col = vec3(0,0.5,1);\nconst vec3 segment_col = vec3(0);\nconst vec3 target_col = vec3(1,0,0);\n\nfloat hash(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sdfLine(vec2 a, vec2 b, float r, vec2 p){\n    vec2 ab = b - a;\n    float t = dot(p - a, ab) / dot(ab, ab);\n    vec2 p2 = a + clamp(t,0.0,1.0) * ab;\n    return length(p - p2) - r;\n}\n\nvec2 getUV( vec2 res, vec2 coord ){\n    vec2 uv = coord/res;\n    uv.x = (uv.x-0.5) * (res.x/res.y);\n    return uv;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2BWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 179, 179, 1673]], "test": "untested"}
{"id": "sljBWW", "name": "Sphere of cubes multisampled", "author": "Ptyonic", "description": "Added Multisampling\n\nSee https://youtu.be/A2IAyXc0LuE and https://youtu.be/yrDbD90HXyo for videos on why there appear to be circles all over the sphere.\n\nDerived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4", "tags": ["raytracing"], "likes": 4, "viewed": 321, "published": 3, "date": "1652226332", "time_retrieved": "2024-07-30T16:49:23.797416", "image_code": "// derived from BrunoLevy's RayTracing tutorial - step 1, shadertoy.com/view/wdfXR4\n\n// added \"msaa\" to shadertoy.com/view/7ds3zB#\n \nstruct Camera {\n    vec3 Obs;\n    vec3 View;\n    vec3 Up;\n    vec3 Horiz;\n    float H;\n    float W;\n    float z;\n};\n\nstruct Ray {\n    vec3 Origin;\n    vec3 Dir;\n};\n\nCamera camera(in vec3 Obs, in vec3 LookAt, in float aperture) {\n   Camera C;\n   C.Obs = Obs;\n   C.View = normalize(LookAt - Obs);\n   C.Horiz = normalize(cross(vec3(0.0, 0.0, 1.0), C.View));\n   C.Up = cross(C.View, C.Horiz);\n   C.W = float(iResolution.x);\n   C.H = float(iResolution.y);\n   C.z = (C.H/2.0) / tan((aperture * 3.1415 / 180.0) / 2.0);\n   return C;\n}\n\nRay launch(in Camera C, in vec2 XY) {\n   return Ray(\n      C.Obs,\n      C.z*C.View+(XY.x-C.W/2.0)*C.Horiz+(XY.y-C.H/2.0)*C.Up \n   );\n}\n\nstruct Sphere {\n   vec3 Center;\n   float R;\n};\n\nbool intersect_sphere(in Ray R, in Sphere S, out float t, out float t2) {\n   vec3 CO = R.Origin - S.Center;\n   float a = dot(R.Dir, R.Dir);\n   float b = 2.0*dot(R.Dir, CO);\n   float c = dot(CO, CO) - S.R*S.R;\n   float delta = b*b - 4.0*a*c;\n   if(delta < 0.0) {\n      return false;\n   }\n   t = (-b-sqrt(delta)) / (2.0*a);\n   t2 = (-b+sqrt(delta)) / (2.0*a);\n   return true;\n}\n\nbool step_forward(in Ray R, inout float t, inout vec3 roundpoint, out int coord, in float max_t, in float cubeWidth, in float cubesRad){\n    vec3 point = R.Origin + t*R.Dir;\n    vec3 signDir = sign(R.Dir);\n    /// solve for param: point + param*Dir = roundpoint + 0.5*(signDir)*cubeWidth component by component\n    vec3 params = (roundpoint - point + 0.5*signDir*cubeWidth)/R.Dir;\n\n    // find out which wall we hit next\n    if(params.x < params.y){\n        if(params.x < params.z){ coord = 0;}\n        else{ coord = 2;}\n    }\n    else{\n        if(params.y < params.z){ coord = 1;}\n        else{ coord = 2;}\n    }\n    \n    t += params[coord];\n    vec3 move = vec3(0.0,0.0,0.0);\n    move[coord] += cubeWidth;\n    roundpoint += signDir*move;\n\n    if(length(roundpoint) < cubesRad){ \n        roundpoint -= signDir*move; // take a step back to the cube before we hit the solid cube\n        return false; } // we hit a cube \n    if(t > max_t){ coord = 3; \n        return false;\n    }  // meaning that we were tangent to the sphere of cubes and didnt hit anything\n \n    return true; // keep going\n}\n\nfloat mysmoothstep(in float x){\n    float t = clamp(x, 0.0, 1.0);\n    t = 1.0 - pow((1.0 - t),1.5); \n    return t * t * (3.0 - 2.0 * t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   float time = float(100 + iFrame)/100.0;\n   float cubeWidth = 1.0/time;  \n   //float cubeWidth = 0.2;\n   float sphereRad = 1.0;\n   float cubesRad = sphereRad - cubeWidth*0.5*sqrt(3.0); // cube with center within this rad is contained in sphere\n \n   vec3 red = vec3(1.0,0.0,0.0);\n   vec3 green = vec3(0.0,1.0,0.0);\n   vec3 blue = vec3(0.0,0.0,1.0);\n   \n   float beta = 3.14159 / 4.0 + 0.2; // * time; // * time;\n   float s = sin(beta);\n   float c = cos(beta); \n\n   // Initialize the Camera \n   Camera C = camera(\n       vec3(2.0*c, 2.0*s, 1.5),\n       vec3(0.0),\n       50.0       \n   );\n   \n   Sphere S = Sphere(vec3(0.0), sphereRad);\n\n   fragColor = vec4(0.0);\n   \n   int MULTISAMPLE = 16;\n   for (int yOff = 0; yOff < MULTISAMPLE; yOff++) {\n       for (int xOff = 0; xOff < MULTISAMPLE; xOff++) {\n           Ray R = launch(C, fragCoord + (vec2(xOff, yOff) / float(MULTISAMPLE)));\n\n           float t;\n           float max_t;\n           int coord;\n\n           vec3 col = vec3(0.0);\n           if(intersect_sphere(R,S,t,max_t)) {\n              vec3 point = R.Origin + t*R.Dir;\n              vec3 roundpoint = round(point/cubeWidth)*cubeWidth;\n\n              bool cont = true;\n              for(int i = 0; i <= 50; i++) { \n                  cont = step_forward(R, t, roundpoint, coord, max_t, cubeWidth, cubesRad);\n                  if(cont == false){break;}\n              }\n              if(coord <= 2) { // hit a solid cube\n                  col[coord] = 1.0;\n\n                  vec3 point = R.Origin + t*R.Dir;\n                  vec3 signOctant = -sign(point);\n                  point -= roundpoint; // now relative to the cube center we just hit\n                  point *= signOctant; // now moving in the positive direction sends us to potential solid cubes\n                  point /= cubeWidth; // now in (-0.5,0.5)^2\n\n                  float brightness = 1.0;\n                  float d = 0.3; // ambient occlusion darkness amount\n\n                  vec3 move1 = vec3(0.0,0.0,0.0);\n                  move1[(coord + 1) % 3] += cubeWidth;\n                  vec3 neighbour1 = signOctant*roundpoint + move1;\n                  vec3 move2 = vec3(0.0,0.0,0.0);\n                  move2[(coord + 2) % 3] += cubeWidth;\n                  vec3 neighbour2 = signOctant*roundpoint + move2;\n                  vec3 move3 = move1 + move2;\n                  vec3 neighbour3 = signOctant*roundpoint + move3;\n                  bool n1solid = (length(neighbour1) < cubesRad);\n                  bool n2solid = (length(neighbour2) < cubesRad);\n                  bool n3solid = (length(neighbour3) < cubesRad);\n\n                  if(n1solid){\n                      brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 1) % 3]);\n                  }\n                  if(n2solid){\n                      brightness *= (1.0 - d) + d*mysmoothstep(0.5 - point[(coord + 2) % 3]);\n                  }\n\n                  if(n3solid && (!n1solid && !n2solid)){\n                      float s1 = mysmoothstep(0.5 - point[(coord + 1) % 3]);\n                      float s2 = mysmoothstep(0.5 - point[(coord + 2) % 3]);\n                      float foo = 1.0 - (1.0 - s1)*(1.0 - s2);\n                      brightness *= (1.0 - d) + d*foo;\n                  }\n\n                  col *= brightness;          \n                  fragColor += vec4(col, 1.0);\n              } else {\n                  fragColor += vec4(0.5, 0.5, 0.5, 1.0);\n              }\n           } else {\n               fragColor += vec4(0.5, 0.5, 0.5, 1.0);\n           }\n        }\n    }\n    fragColor /= fragColor.a;\n}\n \n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sljBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[298, 298, 361, 361, 659], [661, 661, 698, 698, 795], [845, 845, 918, 918, 1220], [1222, 1222, 1358, 1358, 2314], [2316, 2316, 2347, 2347, 2454], [2456, 2456, 2513, 2513, 6074]], "test": "untested"}
{"id": "NtjBWW", "name": "Superellipse Derivative", "author": "cra_manning_w", "description": "Worked out on paper the derivative of the superellipse.\n\nMost parameters are controlled by time, two are controlled by mouse position.\n\nSeems to have a bug in some cases when m=0, I'm not sure why yet.", "tags": ["2d", "derivative", "superellipse"], "likes": 3, "viewed": 476, "published": 3, "date": "1652216004", "time_retrieved": "2024-07-30T16:49:24.600272", "image_code": "\n//Provides more information.\n//Set to 'false' for a simpler, nicer display.\n#define VISUALIZE_NORMALS true\n\n\n//Utilities:\n#define INV_LERP(a, b, x) ((x - a) / (b - a))\n#define OSCILLATE_T(x) (0.5 + (0.5 * -cos(x * 3.14159265 * 2.0)))\n#define SATURATE(x) (clamp(x, 0.0, 1.0))\n#define SHARPEN(x) smoothstep(0.0, 1.0, x)\n#define SIGN1(x) (((x) >= 0.0) ? 1.0 : -1.0)\nvec2 getPerpendicularRight(vec2 dir)\n{\n    //OpenGL's screen is left-handed.\n    return vec2(dir.y, -dir.x);\n}\n\n\n//Reference: https://mathworld.wolfram.com/Superellipse.html\n\n//Provide a custom function on the angle (which is between -Pi and Pi)\n//    before it's plugged into the \"cos\" and \"sin\" terms,\n//    to get more interesting shapes.\nvoid ellipseAngleModification(float theta, out vec2 newTheta, out vec2 derivative)\n{\n    newTheta = vec2(theta);\n    derivative = vec2(1.0);\n}\n\nstruct SuperEllipse\n{\n    float radiusScale;\n    \n    //My attempt to give intuitive names to the parameters:\n    \n    ivec2 nPeaks; // Half of 'm', different values per axis.\n                  //   (multiples of 2 are the only 'm' values with continuous results)\n    float peakSharpness; // 'n1'\n    \n    vec2 subPeakSizes; // 'a' and 'b'\n    vec2 subPeakSharpness; // 'n2' and 'n3'\n};\nstruct SE_Surface\n{\n    float radius, derivative;\n    vec2 tangent, normal;\n};\n\n//Finds the radius, derivative, and tangent/normal of a superellipse,\n//    given the position/angle around it.\n//Tangent/normal calculation assumes left-handed coordinates\n//    (like the ShaderToy screen), and the Theta angle increasing counter-clockwise.\nSE_Surface getEllipseSurface(SuperEllipse ellipse, vec2 surfaceDir, float theta)\n{\n    //Extract the parameter names used in the original math.\n    vec2 m = vec2(ellipse.nPeaks * 2),\n         ab = ellipse.subPeakSizes,\n         n23 = ellipse.subPeakSharpness;\n    float n1 = ellipse.peakSharpness;\n\n          \n    vec2 theta1, theta1Derivative;\n    ellipseAngleModification(theta, theta1, theta1Derivative);\n\n    //First calculate the layers of values from the original function.\n    vec2 multiplier = (m / 4.0),\n         r1 = multiplier * theta1,\n         trigR1 = vec2(cos(r1.x), sin(r1.y)),\n         trigSign = vec2(SIGN1(trigR1.x), SIGN1(trigR1.y)), //Replaces abs()\n         r2 = trigR1 * trigSign / ab,\n         r3 = pow(r2, n23);\n    float r = ellipse.radiusScale * pow(r3.x + r3.y, -1.0 / n1);\n    \n    //Next, calculate the derivatives of those layers\n    //    by applying the chain rule multiple times.\n    vec2 rDeriv1 = multiplier * theta1Derivative,\n         rDeriv2 = vec2(-sin(r1.x), cos(r1.y))\n                     * rDeriv1 * trigSign / ab,\n         rDeriv3 = n23 * rDeriv2\n                     * pow(r2, n23- 1.0);\n    float rDeriv = ellipse.radiusScale * (-1.0 / n1)\n                   * (rDeriv3.x + rDeriv3.y)\n                   * pow(r3.x + r3.y, -(1.0 + (1.0 / n1)));\n         \n\n    //Use the derivative to find the tangent line on this part of the surface.\n    //Remember that derivative is \"rise / run\", a.k.a. \"y\"/\"x\".\n    //On the surface, \"rise\" is the outward surface direction,\n    //    and \"run\" is the positive angle direction.\n    vec2 leftward = -getPerpendicularRight(surfaceDir);\n    vec2 tangentRise = surfaceDir * rDeriv / ellipse.radiusScale,\n         tangentRun = leftward * 1.0,\n         tangent = normalize(tangentRise + tangentRun);\n         \n    vec2 normal = getPerpendicularRight(tangent);\n    \n    return SE_Surface(r, rDeriv, tangent, normal);\n}\n\n\nfloat distToLine(vec2 lineStart, vec2 lineDir, vec2 point, bool isRay)\n{\n    float t = dot(point - lineStart, lineDir);\n    if (isRay)\n        t = max(0.0, t);\n    vec2 closestLinePoint = lineStart + (lineDir * t);\n    \n    return distance(point, closestLinePoint);\n}\n\n//Give a pixel and a specific point on an ellipse's surface,\n//    returns a color value used to visualize that suface's derivative.\nvec3 vizSurfaceDerivative(vec2 pixelPos, float vizTheta, SuperEllipse ellipse)\n{\n    vec2 towardsSurface = vec2(cos(vizTheta), sin(vizTheta));\n    \n    SE_Surface surface =  getEllipseSurface(ellipse, towardsSurface, vizTheta);\n    vec2 surfacePos = towardsSurface * surface.radius;\n             \n    //Draw a red tangent line, blue normal line,\n    //    dotted yellow \"surface dir\" line,\n    //    and a green dot at the surface point.\n    float lineTangent = distToLine(surfacePos, surface.tangent, pixelPos, true),\n          lineNormal = distToLine(surfacePos, surface.normal, pixelPos, true),\n          lineSurface = distToLine(surfacePos, towardsSurface, pixelPos, false);\n    #define LINE_NARROWNESS 180.0\n    vec3 tangentColor = vec3(1, 0, 0) *\n                        pow(1.0 - SATURATE(lineTangent),\n                            LINE_NARROWNESS),\n         normalColor = vec3(0, 0, 1) *\n                       pow(1.0 - SATURATE(lineNormal),\n                           LINE_NARROWNESS),\n         surfaceDirColor = vec3(1, 1, 0) *\n                           SHARPEN(mix(0.0, 1.0,\n                               OSCILLATE_T(dot(towardsSurface,\n                                               pixelPos - surfacePos)\n                                             * 20.0))) *\n                           pow(1.0 - SATURATE(lineSurface),\n                               LINE_NARROWNESS),\n         surfaceColor = vec3(0, 1, 0) *\n                        step(SATURATE(distance(pixelPos, surfacePos)),\n                             0.01);\n    vec3 drawColor = tangentColor + normalColor + surfaceDirColor + surfaceColor;\n    \n    //Display the derivative value as text.\n    vec2 TEXT_SIZE = vec2(0.2, 0.1);\n    vec3 textColor = vec3(0.2, 1, 0.1) *\n                     PrintValue(-0.5 * TEXT_SIZE, pixelPos,\n                                TEXT_SIZE,\n                                surface.derivative,\n                                2.0, 3.0);\n    \n    return SATURATE(drawColor + textColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.a = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //Correct for aspect ratio, but leave the center of the screen at {0.5, 0.5}.\n    float aspect = iResolution.x / iResolution.y,\n          aspectOffset = (aspect - 1.0) / 2.0;\n    uv.x = (uv.x * aspect) - aspectOffset;\n    \n    //Compute the polar coordinates.\n    vec2 shapeCenter = vec2(0.5);\n    vec2 pos = uv - shapeCenter,\n         towardsSurface = normalize(pos);\n    float theta = atan(pos.y, pos.x),\n          radius = length(pos);\n          \n    //DEBUG: visualize angle.\n    fragColor.rgb = vec3((theta + 3.1415927) / (2.0 * 3.1415927));\n    //return;\n          \n    //Compute the superellipse parameters.\n    vec2 mouseUV = iMouse.xy / iResolution.xy;\n    float time = iTime;\n    //TODO: Modify these parameters to make the thumbnail preview more interesting.\n    //  [this didn't do anything, I'm not sure how to fix this]\n    if (false && iMouse.xy == vec2(0))\n    {\n        mouseUV = vec2(0.5);\n        time = 34.3421;\n    }\n    SuperEllipse ellipse = SuperEllipse(0.25,\n                                        ivec2(mix(vec2(1.0), vec2(8.999), mouseUV)),\n                                        mix(2.0, 8.0, OSCILLATE_T(time / 2.65)),\n                                        vec2(mix(0.75, 3.0, OSCILLATE_T(time / 3.5)),\n                                             mix(0.75, 3.0, OSCILLATE_T(time / 7.0))),\n                                        vec2(mix(0.4, 4.5, OSCILLATE_T(time / 4.25)),\n                                             mix(0.4, 4.5, OSCILLATE_T(time / 8.5))));\n                                             \n    //Compute the superellipse data at this point.\n    SE_Surface elSurface = getEllipseSurface(ellipse, towardsSurface, theta);\n    vec2 surfacePos = shapeCenter + (towardsSurface * elSurface.radius);\n          \n    //Pick a color.\n    float displayDerivative = SATURATE(INV_LERP(0.0, 0.82, abs(elSurface.derivative))),\n          radiusT = radius / elSurface.radius;\n    vec3 backgroundColor = vec3(0),\n         shapeColor = VISUALIZE_NORMALS ?\n                          mix(vec3(0.7),\n                              vec3(0.2, 0.2, 0.8),\n                              displayDerivative * pow(SATURATE(radiusT), 2.0)) :\n                          mix(vec3(1),\n                              vec3(0.7, 0.7, 1),\n                              displayDerivative * pow(SATURATE(radiusT), 5.0)),\n         edgeColor = vec3(\n             //Red-Green visualizes the signed normal.\n             SATURATE(elSurface.normal),\n             //Blue visualizes the derivative.\n             //Only show it in places where the normal is black,\n             //    otherwise the normal is difficult to interpret.\n             pow(displayDerivative, 0.375)\n              * step(elSurface.normal.x, 0.0)\n              * step(elSurface.normal.y, 0.0)\n         );\n    float edgeThickness = 0.01;\n    if (abs(radius - elSurface.radius) < edgeThickness)\n        fragColor.rgb = edgeColor;\n    else if (radius < elSurface.radius)\n        fragColor.rgb = shapeColor;\n    else\n        fragColor.rgb = backgroundColor;\n        \n    //Visualize a specific surface normal.\n    if (VISUALIZE_NORMALS)\n    {\n        float thetaToExamine = fract(iTime * 0.1)\n                                 * 3.14159265 * 2.0;\n        fragColor.rgb += vizSurfaceDerivative(pos, thetaToExamine, ellipse);\n    }\n}", "image_inputs": [], "common_code": "// Prints numbers\n\n// Original version: https://www.shadertoy.com/view/4sBSWW\n\n// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Note that the values printed are not always accurate!\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\n\n// Improved version\n//\n// Most important change is dropping everything left of the decimal point ASAP \n// when printing the fractional digits. This is done to bring the magnitule down\n// for the following division and modulo.\n//\n// Another change is to replace the logarithm with a power-of-ten value \n// calculation that is needed later anyway.\n// This change is optional, either one works.\nfloat PrintValue(vec2 textPos, vec2 pixelPos, vec2 fontSize, float value,\n\t\tfloat digits, float decimals) {\n\tvec2 charCoord = (textPos - pixelPos) / fontSize;\n\tif(charCoord.y < 0.0 || charCoord.y >= 1.0) return 0.0;\n    charCoord.x = 1.0 - charCoord.x;\n    charCoord.y = 1.0 - charCoord.y;\n    charCoord = vec2(charCoord.x, charCoord.y);\n\tfloat bits = 0.0;\n\tfloat digitIndex1 = digits - floor(charCoord.x)+ 1.0;\n\tif(- digitIndex1 <= decimals) {\n\t\tfloat pow1 = pow(10.0, digitIndex1);\n\t\tfloat absValue = abs(value);\n\t\tfloat pivot = max(absValue, 1.5) * 10.0;\n\t\tif(pivot < pow1) {\n\t\t\tif(value < 0.0 && pivot >= pow1 * 0.1) bits = 1792.0;\n\t\t} else if(digitIndex1 == 0.0) {\n\t\t\tif(decimals > 0.0) bits = 2.0;\n\t\t} else {\n\t\t\tvalue = digitIndex1 < 0.0 ? fract(absValue) : absValue * 10.0;\n\t\t\tbits = DigitBin(int (mod(value / pow1, 10.0)));\n\t\t}\n\t}\n\treturn floor(mod(bits / pow(2.0, floor(fract(charCoord.x) * 4.0) + floor(charCoord.y * 5.0) * 4.0), 2.0));\n}\n// ---- 8< -------- 8< -------- 8< -------- 8< ----", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtjBWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[364, 364, 402, 440, 474], [539, 706, 790, 790, 848], [1317, 1575, 1657, 1718, 3470], [3473, 3473, 3545, 3545, 3740], [3742, 3875, 3955, 3955, 5865], [5867, 5867, 5924, 5924, 9301]], "test": "untested"}
{"id": "ft2BWD", "name": "Pew pew pew ball", "author": "Zavie", "description": "Just a shader live coding training session.", "tags": ["livecoding"], "likes": 13, "viewed": 330, "published": 3, "date": "1652215594", "time_retrieved": "2024-07-30T16:49:25.405118", "image_code": "float pi = acos(-1.);\n\nfloat hash(vec2 co)\n{\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat shapy(float x)\n{\n    float cut = 0.98;\n    float x1 = clamp(x/cut,0., 1.);\n    float x2 = 1.-clamp((x-cut)/(1.-cut),0., 1.);\n    float tail = exp(-8.*(1.-x1));\n    float head = 1.-exp(-5.*x2);\n    return mix(tail,head,smoothstep(cut-0.05, cut+0.05, x));\n}\n\nfloat shapy2(float x, float k, float t)\n{\n    float a = fract(k*x);\n    float cut = fract(t*k);\n    return smoothstep(cut, cut, a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.x * 2. - vec2(1., iResolution.y/iResolution.x);\n    \n    float t = iTime;\n\n    float angle = atan(uv.y, uv.x);\n    float a = angle / pi *0.5+0.5;\n\n    float rays = 160.;\n    float offset = hash(vec2(floor(a*rays)*rays))*5.;\n    vec2 c = vec2(0.);\n    vec2 dv = uv - c;\n    float d1 = abs(dv.x) + abs(dv.y);\n    float d2 = length(dv);\n    float d = mix(d1, d2, mix(-1., 1.2, smoothstep(0., 1.,abs(fract(t/16.) * 2. - 1.))));\n    d = -exp(-16.*d);\n    vec3 p1 = vec3(shapy(fract(d*10.-1.*t+offset)));\n\n\n    float c2 = shapy2(a, 2., t/11.);\n    float c4 = shapy2(a, 4., t/12.);\n    float c8 = shapy2(a, 8., t/13.);\n    vec3 color = p1*vec3(vec3(1., 0.2, 0.8)*c2 + vec3(0.8, 1., 0.2)*c4 + vec3(0.2, 0.8, 1.)*c8);\n\n    float glow = clamp(exp(-10.*d2-0.8)*10.,0., 1.);\n    color += glow * vec3(1., 0.9, 0.);\n    float disc = smoothstep(0.14, 0.15, d2);\n    color *= disc;\n\n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ft2BWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 114], [116, 116, 138, 138, 377], [379, 379, 420, 420, 512], [514, 514, 571, 571, 1509]], "test": "untested"}
{"id": "ftjfWW", "name": "Sin Interference ", "author": "natet", "description": "Sin wave interference based around the distances between points and pixels", "tags": ["waves", "ripples", "sin", "interference"], "likes": 1, "viewed": 200, "published": 3, "date": "1652209880", "time_retrieved": "2024-07-30T16:49:26.157107", "image_code": "float map(float value, float min1, float max1, float min2, float max2) {\n  return min2 + (value - min1) * (max2 - min2) / (max1 - min1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 centre = iResolution.xy*0.5;\n    float distCentre = distance(fragCoord.xy,centre);\n    float dCSin = sin(distCentre*0.05);\n    \n    vec2 anim = vec2(map(sin(iTime),-1.0,1.0,0.0,iResolution.x),map(sin(iTime*2.0),-1.0,1.0,0.0,iResolution.y));\n    //float distMouse = distance(fragCoord.xy,iMouse.xy);\n    float distMouse = distance(fragCoord.xy,anim);\n    float dMSin = sin(distMouse*0.05);\n    \n    float greycol = (((dMSin * dCSin) + 1.0) * 0.5);\n    \n    fragColor = vec4(greycol,greycol,greycol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjfWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 72, 72, 138], [140, 140, 197, 197, 716]], "test": "untested"}
{"id": "fljfWR", "name": "FlightControlCenter", "author": "stephenl7797", "description": "hi", "tags": ["lines", "particles"], "likes": 12, "viewed": 463, "published": 3, "date": "1652208727", "time_retrieved": "2024-07-30T16:49:27.169400", "image_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    fragColor = IC0(ivec2(fragCoord));\n\n// Show tracked particles / voro cells\n#if 0\n    fragColor *= .5;\n    \n    ivec2 top0 = unhashXY(int(IC2(ivec2(fragCoord)).x),IR);\n    ivec2 top1 = unhashXY(int(IC2(ivec2(fragCoord)).y),IR);\n    ivec2 top2 = unhashXY(int(IC2(ivec2(fragCoord)).z),IR);\n    ivec2 top3 = unhashXY(int(IC2(ivec2(fragCoord)).w),IR);\n    //fragColor.rg = vec2(top) / R;\n    float d = 320.;\n    fragColor.r += float(top0.x) / d;\n    fragColor.g += float(top1.x) / d;\n    fragColor.b += float(top2.x) / d;\n    fragColor.a = 1.;\n#endif\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define R iResolution.xy\n#define IR ivec2(iResolution.xy)\n#define C0(uv) texture(iChannel0, (uv))\n#define C1(uv) texture(iChannel1, (uv))\n#define IC0(p) texelFetch(iChannel0, (p), 0)\n#define IC1(p) texelFetch(iChannel1, (p), 0)\n#define IC2(p) texelFetch(iChannel2, (p), 0)\n\n\n// Version 1: First try, encoded each particle position at that time\n// Version 2: encode prev+next site as integer, as well as phase.\n// Version 3: same, but use particle tracking/search instead of exhaustive loop each frame.\n\n// In version 2: Looping over >100 particles resulted in under 30fps on my laptop,\n// so for version 3, use particle tracking.\n\n//#define VERSION 1\n#define VERSION 2\n#define SIZE 8\n#define SIZEf 8.\n// How many particles to search for each frame. Higher = faster convergence but slower.\n#define NEW_SAMPLES 8\n\nfloat rand11(float x) { return fract(337.1*sin(x*22.13+11.2)); }\nvec2 rand22(vec2 p) { return fract(vec2(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13) )); }\nvec3 rand23(vec2 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13) )); }\nvec3 rand33(vec3 p) { return fract(vec3(\n    337.1*sin(22.3+27.31*p.y+p.x*22.13+p.z*19.2),\n    437.1*sin(1.7+22.31*p.y+p.x*29.13+p.z*10.3),\n    407.1*sin(111.7+12.31*p.y+p.x*19.13+p.z*8.2) )); }\n\nfloat distanceToLine(vec3 p1, vec3 p2, vec3 q) {\n    return length(cross(q-p1, q-p2)) / length(p1-p2);\n}\n\nconst float CAM_DIST = 4.;\nconst float FOCAL_COEFF = 1.60;\n\n\nfloat xsect_sphere(vec3 ro, vec3 rd, float radius) {\n    float a = dot(rd,rd);\n    float b = 2. * dot(rd,ro);\n    float c = dot(ro,ro) - radius;\n    float discrim = b*b - 4.*a*c;\n    if (discrim < 0.) return 0.;\n    float t1 = -b + sqrt(b*b - 4.*a*c);\n    float t2 = -b - sqrt(b*b - 4.*a*c);\n    return min(t1,t2) / 2.*a;\n}\n\nvec2 randVor22(vec2 g, float iTime) {\n//g += iTime * .00001;\n//float a = sin(iTime)*.5+.5;\nconst float a = 1.0;\nreturn rand22(g) * a + .5 - .5 * a;\n}\n\nvec3 site(vec2 pp, float t) {\n    vec2 g = floor(pp);\n    vec2 a = (g+randVor22(g, t)).xy * 3.141 / SIZEf * .5;\n    return normalize(vec3(sin(a.y)*cos(a.x), sin(a.y)*sin(a.x), cos(a.y))).xzy;\n}\nvec3 isite(int i, float t) {\n    vec2 p = vec2(i % SIZE, i / SIZE);\n    vec2 pp = vec2(p.x,p.y) * 2. - SIZEf * .5;\n    return site(pp, t);\n}\nvec3 partAtPhase(vec4 samp, float t) {\n    vec3 a = isite(int(samp.x+.1), t);\n    vec3 b = isite(int(samp.y+.1), t);\n    float phase = samp.z;\n    float amp = fract(samp.w*9999.77) * .2 + .1;\n    vec3 part = normalize((1.-phase)*a + phase*b) * (1.0 + amp*(1.0-pow(cos(phase*3.141),2.)));\n    return part;\n}\n\nvec2 proj(vec3 p, vec2 focal, float tt) {\n    return p.xy * focal / (p.z + tt);\n}\n\n\n\nfloat hashXY(ivec2 xy, ivec2 ir) {\n    return float(xy.y * ir.x + xy.x);\n}\nivec2 unhashXY(int h, ivec2 ir) {\n    return ivec2(h%ir.x, h/ir.x);\n}\n\n\n\n    \n//float smoo(float v) { return v*v*(3.-2.*v); }\nfloat smoo(float v) { return v; }\nvec3 noise33(vec3 x) {\n    vec3 o = vec3(0.);\n    vec3 fx = floor(x);\n    vec3 lx = fract(x);\n    for (int i=0; i<8; i++) {\n        float dx = (i  ) % 2 == 0 ? 1. : 0.;\n        float dy = (i/2) % 2 == 0 ? 1. : 0.;\n        float dz = (i/4) % 2 == 0 ? 1. : 0.;\n        vec3 v  = rand33(fx + vec3(dx,dy,dz));\n        vec3 d = vec3(dx,dy,dz) * 2. * lx + 1. - lx - vec3(dx,dy,dz);\n        o += smoo(d.x)*smoo(d.y)*smoo(d.z)*v;\n    }\n    return o;\n}", "buffer_b_code": "// Particle Sim\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    if (iFrame == 0) { fragColor = vec4(0.); return; }\n    \n    vec4 old = IC0(ivec2(fragCoord));\n    vec4 new = old;\n    \n    float TS = (fragCoord.x * 2. / R.x + 2.) / 24.;\n    float AMP = rand11(fragCoord.x * .97) * .2 + .1;\n    \n    /*\n    if (new.a == 0. || new.a >= 1.0) {\n        // Random init\n        new = vec4(rand33(vec3(fragCoord+iTime*.3336, iTime+float(iFrame)))*2.-1., 0.00001);\n        new.rgb = normalize(new.rgb);\n    } else {\n        // Move particle along path\n        new.a += (fragCoord.x * 2. / R.x + 1.) / 60.;\n        \n        vec3 a = normalize(rand33(vec3(fragCoord+iTime*.3336, iTime+float(iFrame)))*2.-1.);\n        vec3 b = normalize(rand33(vec3(fragCoord+iTime*.3336, iTime+float(iFrame)))*2.-1.);\n    }\n    */\n    \n    #if VERSION == 1\n    float period = floor(iTime * TS);\n    float phase  = fract(iTime * TS);\n    \n    vec3 a = normalize(rand33(vec3(fragCoord,0.)+vec3(period))*2.-1.);\n    vec3 b = normalize(rand33(vec3(fragCoord,0.)+vec3(period+1.))*2.-1.);\n    new.rgb = normalize((1.-phase)*a + phase*b) * (1.0 + AMP*(1.0-pow(cos(phase*3.141),2.)));\n    \n    #elif VERSION == 2 || VERSION == 3\n    \n    // row 0: i | j | phase | timeScale\n    // i,j encode xy integer location.\n    // Which is then further transformed by the site function.\n    \n    float S = 2.0 * pow(SIZEf,2.) + .99;\n    if (iFrame <= 1) {\n        new.z = fragCoord.x/R.x;\n        new.y = floor(rand11(fragCoord.x + iTime*9.333 + 11.9) * S );\n        new.x = floor(rand11(fragCoord.x + iTime*9.333) * S );\n        new.w = ((float(fragCoord.x) / R.x) + 1.) / 320.;\n    } else if (new.z > 1.0) {\n        new.z = 0.;\n        new.x = new.y;\n        int i = int(old.y + .1);\n        vec2 p = vec2(i % SIZE, i / SIZE) * 2. - 1.;\n        vec2 pp = p + (rand22(vec2(fragCoord.x,fragCoord.x*2.3)+iTime) * 2. - 1.) * 2.;\n        new.y = floor(rand11(fragCoord.x + iTime*7.333) * S);\n        //new.y = new.x + 1.0;\n        new.w = ((float(fragCoord.x) / R.x) + 1.) / 320.;\n    } else new.z += ((float(fragCoord.x) / R.x) + 1.) / 320.;\n    \n    #endif\n    \n    //new.xy = vec2(floor(fragCoord.x/200.));\n    \n    fragColor = new;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "// Main scene + time averaging\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col = vec3(.003,.001,.02);\n    float tt = iTime / 33.0;\n    //tt = 0.;\n    \n    vec3 scol = vec3(0.);\n    \n    mat3 RR = mat3(1.);\n    RR[0] = vec3(cos(tt), 0., sin(tt));\n    RR[2] = vec3(sin(tt), 0., -cos(tt));\n    \n    vec2 fuv = vec2(fragCoord-R.xy*.5)/R.y;\n    /*\n    vec3 ro = CAM_DIST * vec3(sin(tt), 0., -cos(tt));\n    vec3 rd_ = normalize(vec3((fragCoord-R.xy*.5)/R.y, FOCAL_COEFF));\n    vec3 rd = vec3(rd_.x*cos(tt)-sin(tt)*rd_.z, rd_.y,\n                   rd_.x*sin(tt)+rd_.z*cos(tt));\n                   */\n    vec3 ro = CAM_DIST * RR * vec3(0.,0.,-1.);\n    vec3 rd = transpose(RR) * normalize(vec3((fragCoord-R.xy*.5)/R.y, FOCAL_COEFF));\n                   \n    // Intersect sphere\n    float t = xsect_sphere(ro,rd, 1.);\n    vec3 p = (ro + t * rd).xyz;\n    if (t != 0.) {\n        scol = vec3(.04,.11,.21) * (1.+length(fuv)) * 4.;\n        scol.g *= .8 + .3 * sin(p.y*3.+iTime);\n        scol.r *= .5 + 1.5 * sin(p.x*5.+iTime);\n        \n        float lat = acos(p.y/length(p));\n        float lng = atan(p.z,p.x);\n        \n        // Do quad pattern\n        float y = lat * SIZEf / 3.141 * 2.;\n        float x = lng * SIZEf / 3.141 * 2.;\n        vec2 pp = vec2(x,y);\n        vec2 g = floor(pp);\n        vec2 a = g+randVor22(g,iTime);\n        float acc = 0.;\n        for (int i=0; i<4; i++) {\n            vec2 dd = vec2((i==0)?-1.:(i==1)?1.0:0.,(i==2)?-1.:(i==3)?1.0:0.);\n            vec2 aa = g+dd + randVor22(g+dd,iTime);\n            float d = distanceToLine(vec3(a,1.), vec3(aa,1.), vec3(pp,1.));\n            if (dot(a-pp,aa-pp) < 0.)\n                acc = max(acc, .09 / (.1+d));\n        }\n        //if (acc < 1.) scol *= 0.;\n        scol *= exp(acc*5.-5.);\n        \n        //cc *= (1.0 - abs(sin(lng*30.)) * abs(sin(lat*30.))) * 2.1;\n        col += scol;\n    }\n    \n    \n    // Render particles\n    #if VERSION == 1\n    vec3 cc = vec3(0.);\n    float dampen = 0.;\n    int N = IR.x / 4;\n    for (int i=0; i<N; i++) {\n        vec3 c = vec3(0.);\n        vec4 part4 = IC0(ivec2(i,0));\n        vec3 part = RR * part4.xyz;\n        vec2 ppart = FOCAL_COEFF * part.xy / (part.z + CAM_DIST);\n        float d = length(ppart - fuv);\n        \n        dampen += .005 / (.0001+d);\n        if (d > .01) d = 999.;\n        c.g += .002/(d+.0002);\n        if (d > .01) d = 999.;\n        c.b += .004/(d+.0002);\n        float AMP = float(i) / float(N);\n        cc += c * AMP;\n        \n        if (t != 0.) {\n            float sd = sqrt(pow(clamp(length(p-part4.xyz) - .03,0.,999.),2.));\n            vec3 c = (scol) * 15.0;\n            col += exp(-sd*100.) * c;\n        }\n    }\n    //col *= 1./dampen;\n    col += cc;\n\n\n    vec4 old = IC1(ivec2(fragCoord));\n    float ALPHA = .2;\n    col = col * ALPHA + (1.-ALPHA) * old.rgb;\n    fragColor = vec4(col,1.0);\n    \n    #elif VERSION == 2\n    \n    vec3 cc = vec3(0.);\n    float dampen = 0.;\n    /*\n    int N = IR.x / 10;\n    //N = 32;\n    //N=64;\n    for (int i=0; i<N; i++) {\n        float AMP = .5 * float(i) / float(N);\n        vec4 samp = IC0(ivec2(i,0));\n    */\n    ivec4 pidxs = ivec4(IC2(ivec2(fragCoord)));\n    for (int i=0; i<4; i++) {\n        float AMP = .5;\n        \n        //ivec2 pidx = ivec2(IC2(unhashXY(int(pidxs[i]),IR)));\n        ivec2 pidx = unhashXY(pidxs[i],IR);\n        //pidx = ivec2(1,0);\n        //pidx.x = 0;\n        vec4 samp = IC0(pidx);\n\n        \n        vec3 c = vec3(0.);\n        \n        vec3 part_ = partAtPhase(samp, iTime);\n        vec3 part = RR * part_;\n        //vec2 ppart = FOCAL_COEFF * part.xy / (part.z + CAM_DIST);\n        vec2 ppart = proj(part,vec2(FOCAL_COEFF),CAM_DIST);\n        \n        \n        // version a: use 2d projected distance to shade particle\n        if (false) {\n            float d = length(ppart - fuv);\n            float far_mult = 1.-smoothstep(CAM_DIST-1., CAM_DIST+.5, part.z + CAM_DIST);\n            //c.b += .001/(d+.00001);\n            c.b += exp(-clamp(d,.001,999.)*200.) * far_mult;\n            c.g += exp(-clamp(d,.002,999.)*300.) * far_mult;        \n            cc += c;\n        }\n        \n        // version b: use 2d distance to line to shade particle.\n        //            line direction comes from instantaneous velocity, after projecting\n        else {\n            float phase = samp.z;\n            float phasePrev = phase - samp.w * 1.;\n            samp.z = phasePrev;\n            vec3 prevPart = RR * partAtPhase(samp, iTime);\n\n            //vec2 prevPpart = FOCAL_COEFF * prevPart.xy / (prevPart.z + CAM_DIST);\n            vec2 prevPpart = proj(prevPart,vec2(FOCAL_COEFF),CAM_DIST);\n            //vec3 line = cross(vec3(ppart,1.), vec3(prevPpart,1.));\n            float ld = distanceToLine(vec3(ppart,1.), vec3(prevPpart,1.), vec3(fuv,1.));\n            float d = length(ppart-fuv);\n            float dd = ld * (1.0 / (.001+d));\n\n            float lineLength = .5 - abs(phase-.5) + .1; // goes .1 -> .6 -> .1\n            // There's two factors: one for line distance and one for radial distance.\n            float cs = 2.* exp(-ld*600.) * exp(-d*25. / lineLength); \n            c = vec3(.4 - fract(samp.w*777.773)*.4, .2, .99);\n            //c.r += exp(-d*50.);\n            float far_mult = 1.-smoothstep(CAM_DIST-1., CAM_DIST+.5, part.z + CAM_DIST);\n            //far_mult = 10.;\n            cc += c * cs * far_mult;\n        }\n        \n        \n        // Boost at projected point on sphere\n        if (t != 0.) {\n            float sd = sqrt(pow(clamp(length(p-part_.xyz) - .03,0.,999.),2.));\n            vec3 c = (scol) * 5.0;\n            col += exp(-sd*19.) * c;\n        }\n    }\n    col += cc;\n    \n    vec4 old = IC1(ivec2(fragCoord));\n    col.rgb = old.rgb * .95 + .05 * col.rgb;\n    col.rgb += length(fuv.xy) * vec3(.1,.0,.1) * .06;\n    col.rgb += length(fuv.xy+vec2(.5,.2)) * vec3(.001,.3,.52) * abs(fract(iTime*.1)-.5) * .03;\n    col.rgb -= col.rgb * rand23(fuv.xy) * .02;\n    fragColor = vec4(col,1.);\n    \n    \n    #endif\n\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Particle Tracking.\n// Each pixel tracks the four nearest particles to it, when particles projected.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n\n    vec4 ds = vec4(9999.);\n    \n    float tt = iTime / 33.0;\n    mat3 RR = mat3(1.);\n    RR[0] = vec3(cos(tt), 0., sin(tt));\n    RR[2] = vec3(sin(tt), 0., -cos(tt));\n    \n    const float f = FOCAL_COEFF;\n    vec2 fuv = vec2(fragCoord-R.xy*.5)/R.y;\n    \n    vec4 old = IC0(ivec2(fragCoord));\n    vec4 new = old;\n    ivec2 meXY = ivec2(fragCoord);\n    const bool oneRow = true;\n    \n    for (int j=0; j<4; j++) {\n        ds[j] = length(proj(RR*partAtPhase(IC1(unhashXY(int(old[j]),IR)),iTime).xyz,vec2(f),CAM_DIST) - fuv);\n    }\n    \n    // Sample neighbours\n    \n    for (int j=0; j<4; j++) {\n        ivec2 nnXY = (meXY + ivec2((j==0)?-1:(j==1)?1:0, (j==2)?-1:(j==3)?1:0));\n        ivec2 nXY = unhashXY(int(IC0(nnXY).x),IR);\n        \n        if (oneRow) nXY.y = 0;\n        vec3 part = RR*partAtPhase(IC1(nXY),iTime);\n        if (part.z > 0.) continue; // Discard if behind\n        float d = length(proj(part,vec2(f),CAM_DIST) - fuv);\n        \n        \n        if (d <= ds[0]) {\n            if (d<ds[0]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            ds[2] = ds[1]; new[2] = new[1];\n            ds[1] = ds[0]; new[1] = new[0];\n            }\n            ds[0] = d;\n            new[0] = hashXY(nXY, IR);\n        } else if (d <= ds[1]) {\n            if (d<ds[1]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            ds[2] = ds[1]; new[2] = new[1];\n            }\n            ds[1] = d;\n            new[1] = hashXY(nXY, IR);\n        } else if (d <= ds[2]) {\n            if (d<ds[2]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            }\n            ds[2] = d;\n            new[2] = hashXY(nXY, IR);\n        } else if (d <= ds[3]) {\n            ds[3] = d;\n            new[3] = hashXY(nXY, IR);\n        }\n        /*\n        for (int k=0; k<4; k++) {\n            if (d < ds[k]) {\n                for (int l=3; l>k; l--) ds[l] = ds[l-1], new[l] = new[l-1];\n                ds[k] = d;\n                new[k] = hashXY(nXY,IR);\n                break;\n            }\n        }*/\n    }\n    \n    // Sample random\n\n    vec2 size = R.xy;\n    size.y = 1.;\n    //size.x = 12.;\n    size.x = min(R.x,320.); // This controls max particles.\n    for (int i=0; i<NEW_SAMPLES; i++) {\n        ivec2 nXY = ivec2(rand22(iTime*.0111117+fragCoord) * size);\n        \n        if (oneRow) nXY.y = 0;\n        vec3 part = RR*partAtPhase(IC1(nXY),iTime);\n        if (part.z > 0.) continue; // Discard if behind\n        float d = length(proj(part,vec2(f),CAM_DIST) - fuv);\n        \n        if (d <= ds[0]) {\n            if (d<ds[0]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            ds[2] = ds[1]; new[2] = new[1];\n            ds[1] = ds[0]; new[1] = new[0];\n            }\n            ds[0] = d;\n            new[0] = hashXY(nXY, IR);\n        } else if (d <= ds[1]) {\n            if (d<ds[1]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            ds[2] = ds[1]; new[2] = new[1];\n            ds[1] = d;\n            }\n            new[1] = hashXY(nXY, IR);\n        } else if (d <= ds[2]) {\n            if (d<ds[2]) {\n            ds[3] = ds[2]; new[3] = new[2];\n            }\n            ds[2] = d;\n            new[2] = hashXY(nXY, IR);\n        } else if (d <= ds[3]) {\n            ds[3] = d;\n            new[3] = hashXY(nXY, IR);\n        }\n        /*\n        for (int k=0; k<4; k++) {\n            if (d < ds[k]) {\n                for (int l=3; l>k; l--) ds[l] = ds[l-1], new[l] = new[l-1];\n                ds[k] = d;\n                new[k] = hashXY(nXY,IR);\n                break;\n            }\n        }*/\n    }\n    \n    fragColor = new;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 3, 60, 60, 615]], "test": "untested"}
{"id": "slBfWD", "name": "Sine Dunes", "author": "VPaltoDance", "description": "Dune-like waves (i believe)", "tags": ["wave", "sine", "dune"], "likes": 7, "viewed": 366, "published": 3, "date": "1652204090", "time_retrieved": "2024-07-30T16:49:27.956297", "image_code": "#define COORDS_SCALE 10.0\n\n#define OFFSET 0.7\n#define WAVE_OFFSET 0.6\n#define SCALE 0.3\n#define WAVE_SCALE 0.4\n\n#define WAVE_FREQ 2.0\n#define WAVE_SPEED 0.5\n\n#define NEAR_COLOR vec3(0.75, 0.65, 0.3)\n#define FAR_COLOR vec3(0.55, 0.33, 0.1)\n#define TIME_SCALE 0.05\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 coords = uv * COORDS_SCALE;\n    float var = coords.x + coords.y + WAVE_SPEED * iTime + WAVE_OFFSET + WAVE_SCALE * sin(coords.x + WAVE_FREQ * iTime);\n    \n    float coeff = OFFSET + SCALE * smoothstep(0.0, 1.0, fract(var)) \n                         - SCALE * smoothstep(0.97, 1.0, fract(var)); // anti-aliasing\n    \n    vec3 res = mix(NEAR_COLOR, FAR_COLOR, uv.x + uv.y) * coeff;\n    \n    fragColor = vec4(res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 321, 371, 839]], "test": "untested"}
{"id": "7l2BWh", "name": "SUesque Dynamics", "author": "graygoose", "description": "Check Common for settings. \n\nBufferB is for postfx.\n", "tags": ["field"], "likes": 3, "viewed": 252, "published": 3, "date": "1652192665", "time_retrieved": "2024-07-30T16:49:28.874840", "image_code": "#ifndef POSTPROCESS\n#define CHANNEL iChannel0\n#else\n#define CHANNEL iChannel2\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = texture(CHANNEL, fragCoord.xy/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Scene\n#define SRC_SIZE .005\n#define SOURCE(p, o, r, col) length(o - p) < r ? col : vec4(0.);\nvoid init_scene(in vec2 uv, inout vec4 col) {\n    col += SOURCE(uv, vec2(.33, .33), SRC_SIZE, vec4(1., 0., 0., 0.));\n    col += SOURCE(uv, vec2(.5, .75), SRC_SIZE,vec4(0., 1., 0., 0.));\n    col += SOURCE(uv, vec2(.66, .33), SRC_SIZE, vec4(0., 0., 1., 0.));\n}\n\n\n\n    //// Field Parameters\n#ifdef MOUSE\n#define MU sin(iMouse.x/iResolution.x)\n#define RHO cos(iMouse.y/iResolution.y)\n#define DECAY .99\n#define S1 vec4(cos(iMouse.x/iResolution.y), sin(iMouse.y/iResolution.y), (iMouse.x-iMouse.y)/max(iResolution.x,iResolution.y), 0.)\n#define S2 vec4(iMouse.x/iResolution.y, iMouse.y/iResolution.y, (iMouse.y-iMouse.x)/max(iResolution.x,iResolution.y), 0.).yzxw\n#define S3 vec4(iMouse.x/iResolution.y, iMouse.y/iResolution.y, (iMouse.y-iMouse.x)/max(iResolution.x,iResolution.y), 0.).yzxw\n#else\n#ifdef SPONTANEOUS\n// Spontaneous used CHG+ACHG and only S1,S2\n#define S1 vec4(.87)\n#define S2 (vec4(1.)-S1)\n#define MU 0.85\n#define RHO 1.1\n#define DECAY 0.9815\n#else\n// S1|2|3=.87|.13|.13 -> {1: MU 0.33 RHO 1.0 DECAY 0.9643, 2: MU 0.33 RHO 1.12, DECAY .9812 }\n#define MU 0.33\n#define RHO 1.12\n#define DECAY 0.9812\n#define S1 vec4(.87, .87, .87, 0.)\n#define S2 vec4(.13, .13, .13, 0.)\n#define S3 vec4(.13, .13, .13, 0.)\n#endif\n#endif\n\n\n\n    //// Field Definition\n#define OP(a, b, c)    ((a * cos(b)) + (a * sin(c)))\n#define OPBAR(a, b, c) ((a * sin(b)) + (a * cos(c)))\n\n#define BR OP(b, r, g)\n#define RG OP(r, g, b)\n#define GB OP(g, b, r)\n#define BRbar OPBAR(r, b, g)\n#define RGbar OPBAR(g, r, b)\n#define GBbar OPBAR(b, g, r)\n\n#define P1 BR - (RG * MU)\n#define P2 RG - (GB * MU)\n#define P3 GB - (BR * MU)\n#define AP1 BRbar + (RGbar * MU)\n#define AP2 RGbar + (GBbar * MU)\n#define AP3 GBbar + (BRbar * MU)\n\n#ifdef SPONTANEOUS\n#define _CHG (vec4( P1,  P2,  P3, 0.).zxyw * S1)\n#define ACHG (vec4(AP1, AP2, AP3, 0.).zxyw * S2)\n#define CHG (_CHG + ACHG)\n#else\n#define PHI 1.0\n#define BRCHG (vec4(P1,  P2,  P3, 0.).zxyw * S1 * PHI)\n#define RGCHG (vec4(P1,  P2,  P3, 0.).xyzw * S2 * PHI)\n#define GBCHG (vec4(P1,  P2,  P3, 0.).yzxw * S3 * PHI)\n#define CHG (BRCHG + RGCHG + GBCHG)\n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    int cFrame;\n    vec4 col = texelFetch(iChannel0, ivec2(P), 0);\n\n    // Field Pass - Physics\n    vec4 lap = kfilter(P, iChannel0, RES, LAPLACIAN);\n    col += lap * RHO;\n    \n    float r = col.x, g = col.y, b = col.z;\n    col += CHG;\n    \n    \n    // Init (Post field so we don't get visual noise while the mouse is held.) \n    #ifdef DRAW\n    if (sign(iMouse.z) == 1. ) {\n        col += SOURCE(UV, iMouse.xy/iResolution.xy, 0.01, vec4(abs(cos(sin(iTime))), abs(cos(iTime)), abs(sin(iTime)), 0.));\n    }\n    #endif\n    \n    #ifndef MOUSE\n    if (sign(iMouse.z) == 1.) {\n        cFrame = iFrame;\n        #ifndef DRAW\n        col = vec4(0.);\n        #endif\n    } \n    #else\n    if (iFrame == 0) { cFrame = iFrame; }\n    #endif\n    if (iFrame - cFrame < 100) init_scene(UV, col);\n    \n  \n    fragColor = col * DECAY;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//#define DRAW\n//#define MOUSE\n//#define SPONTANEOUS\n//#define POSTPROCESS\n\n\n\n// Utilities\n    // macros\n#define RES iResolution.xy\n#define P fragCoord.xy\n#define UV (fragCoord.xy/iResolution.xy)\n\n    // math\nfloat c_sum(vec4 v) { return v.x + v.y + v.z + v.w; }\nfloat c_magsqrd(vec2 c) { return c.x * c.x + c.y * c.y; }\n\n    // screen\nvec2 wrap(in vec2 p, vec2 res) {\n    if (p.x > res.x) p.x = mod(p.x, res.x);\n    else if (p.x < 0.) p.x = res.x + p.x;\n    \n    if (p.y > res.y) p.y = mod(p.y, res.y);\n    else if (p.y < 0.) p.y = res.y + p.y;\n    \n    return p;\n}\n    // input\n\n    // drawing\nvec4 draw_point(inout vec4 col, vec2 pos, vec2 pt, float r){\n    return c_magsqrd(pos - pt) < r ? vec4(1) : col;\n}\n\n\n\n// Math\n#define GAUSSIAN vec3(.204, .124, .075)\n#define LAPLACIAN vec3(-1., .2, 0.05)\nvec4 kfilter(in vec2 pos, in sampler2D channel, in vec2 reso, in vec3 kernel) {\n    vec4 sum = vec4(0.);\n    \n    for(int i=-1; i<=1; i++) {\n        for(int j=-1; j<=1; j++) {\n            float weight = (i==0 && j==0) ? kernel[0] : (abs(i-j) == 1 ? kernel[1] : kernel[2]);\n            sum += weight * texelFetch(channel, ivec2(wrap(pos + vec2(i, j), reso)), 0);\n        }\n    }\n    \n    return sum;\n}", "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    #ifdef POSTPROCESS\n    vec4 col = texelFetch(iChannel0, ivec2(P), 0); // Buffer A\n    vec4 lap = kfilter(P, iChannel0, RES, LAPLACIAN);\n    vec4 avg = (kfilter(P, iChannel0, RES, GAUSSIAN) + kfilter(P, iChannel1, RES, GAUSSIAN))*0.5 ;\n    float n = c_sum(abs(lap));\n    \n    #ifndef SPONTANEOUS\n    col += 0.25*avg+0.5*n;\n    col = (col * .75) + (texelFetch(iChannel1, ivec2(P), 0) * 2.5); // Buffer \n    col *= 0.25;\n    #endif\n    \n    fragColor = col;  \n    #endif\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #ifdef POSTPROCESS\n    vec4 col = texelFetch(iChannel0, ivec2(P), 0);\n    vec4 avg = (kfilter(P, iChannel0, RES, GAUSSIAN) + kfilter(P, iChannel1, RES, GAUSSIAN) + kfilter(P, iChannel2, RES, GAUSSIAN))*0.33 ;\n    vec4 lap = (kfilter(P, iChannel0, RES, LAPLACIAN) + kfilter(P, iChannel1, RES, LAPLACIAN) + kfilter(P, iChannel2, RES, LAPLACIAN))*0.33 ;\n    \n    col *= lap*0.05;\n    col = max(max(avg, col), lap);\n    fragColor += (col+avg)*0.5;\n    #endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2BWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 86, 143, 143, 212]], "test": "untested"}
{"id": "flSfWD", "name": "Mandelbrot Set Orbits", "author": "Fraktoler", "description": "Orbits of the Mandelbrot fractal (z = z^d + c)\nHold the mouse in the canvas to calculate the orbit of c corresponding to the mouse (White).", "tags": ["fractal", "mandelbrot", "orbit", "complex"], "likes": 1, "viewed": 217, "published": 3, "date": "1652191872", "time_retrieved": "2024-07-30T16:49:29.686670", "image_code": "#define MAX_ITER 256\n#define BAILOUT 16.\n#define THICKNESS 6.0e-7\nconst int orbitIters = 32;\nvec3 HSLtoRGB(vec3 hsl) {\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nfloat sdfSegment(vec2 p, vec2 a, vec2 b) {\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float t = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return mag2(pa - t * ba);\n}\n\nvec2 pixelToComplex(float zoom, vec2 center, vec2 pixel) {\n    return zoom * (pixel - 0.5 * iResolution.xy) / iResolution.x + center;\n}\n\nvec2 f(vec2 z, vec2 c, float exponent) {\n    return power(z, exponent) + c; \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 5.0;\n    vec2 center = vec2(0.0);\n    vec2 uv = pixelToComplex(zoom, center, fragCoord);\n    vec3 col;\n    float exponent = iTime * 0.02 + 2.0;\n    float r;\n    bool b = true;\n    int k = 0;\n    vec2 c = pixelToComplex(zoom, center, iMouse.xy);\n    vec2 z = c;\n    while (k < orbitIters) {\n        r = dot(z, z);\n        if (r > BAILOUT * 2.0) break;\n        vec2 oldz = z;\n        z = f(z, c, exponent);\n        k++;\n        if (sdfSegment(uv, z, oldz) < THICKNESS * zoom * zoom) {\n            col = vec3(1.0);\n            b = !b;\n            break;\n        }\n    }\n    if (b) {\n        c = uv, z = c;\n        k = 0;\n        while (k < MAX_ITER) {\n            r = dot(z, z);\n            if (r > BAILOUT) break;\n            z = f(z, c, exponent);\n            k++;\n        }\n        if (k == MAX_ITER) {\n            col = vec3(0.0);\n        } else {\n            float invln = 1.0 / log(exponent);\n            float lnlnb = log(log(BAILOUT));\n            float u = 5.0 * log(float(k) + invln*lnlnb - invln*log(0.5 * log(r))) - 5.0;\n            col = HSLtoRGB(vec3(mod(10.0 * u, 360.0), 1.0, (sin(u) + 1.2) * 0.4));\n        }\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "/*\nComplex functions\n\n mag(z) = |z|\n mag2(z) = |z|^2\n arg(z) = atan2(z.y, z.x)\n conj(z) = (z.x, -z.y)\n flip(z) = (-z.x, z.y)\n swap(z) = z.yx\n rabs(z) = (abs(z.x), z.y)\n iabs(z) = (z.x, abs(z.y))\n cis(x) = (cos(x), sin(x))\n mul(z, w) = z * w (Complex multiplication)\n mulI(z) = i * z\n div(z, w) = z / w (Complex division)\n recip(z) = 1 / z (Complex reciprocal)\n sqr(z) = z^2\n cube(z) = z^3\n power4(z) = z^4\n power5(z) = z^5\n power(z, x) = z^x (Complex exponentiation)\n powervec2(z, w) = z^w (Principal complex exponentiation)\n sqrtp(z) = sqrt(z) (Principal square root)\n powexp(z) = e^z (Complex exponential)\n ln(z) = log(z) (Complex logarithm)\n logb(z, w) = log(z) / log(w)\n sine(z) = sin(z) (Trig functions)\n cosine(z) = cos(z)\n tangent(z) = tan(z)\n cot(z) = 1 / tan(z)\n sec(z) = 1 / cos(z)\n csc(z) = 1 / sin(z)\n arcsin(z) = asin(z) (Inverse trig functions)\n arccos(z) = acos(z)\n arctan(z) = atan(z)\n arccot(z) = pi/2 - atan(z)\n arcsec(z) = acos(1 / z)\n arccsc(z) = asin(1 / z)\n sinhyp(z) = sinh(z) (Hyperbolic functions)\n coshyp(z) = cosh(z)\n tanhyp(z) = tanh(z)\n coth(z) = 1 / tanh(z)\n sech(z) = 1 / cosh(z)\n csch(z) = 1 / sinh(z)\n arcsinh(z) = asinh(z) (Inverse hyperbolic functions)\n arccosh(z) = acosh(z)\n arctanh(z) = atanh(z)\n arccoth(z) = acoth(z)\n arcsech(z) = asech(z)\n arccsch(z) = acsch(z)\n linear(z, a, b) = a * z + b\n quadratic(z, a, b, c) = a * z^2 + b * z + c\n cubic(z, a, b, c, d) = a * z^3 + b * z^2 + c * z + d\n linearroot(a, b) = -b / a (Solution of a * z + b = 0)\n*/\nconst vec2 one = vec2(1., 0.);\nconst vec2 i = vec2(0., 1.);\nconst float pi = 3.14159265358979;\nconst float e = 2.718281828459045;\n\nfloat mag(vec2 z) {\n    return length(z);\n}\n\nfloat mag2(vec2 z) {\n    return dot(z, z);\n}\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 conj(vec2 z) {\n    return vec2(z.x, -z.y);\n}\n\nvec2 flip(vec2 z) {\n    return vec2(-z.x, z.y);\n}\n\nvec2 swap(vec2 z) {\n    return z.yx;\n}\n\nvec2 rabs(vec2 z) {\n    return vec2(abs(z.x), z.y);\n}\n\nvec2 iabs(vec2 z) {\n    return vec2(z.x, abs(z.y));\n}\n\nvec2 cis(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nvec2 mul(vec2 z, vec2 w) {\n    return z.x * w + z.y * vec2(-w.y, w.x);\n}\n\nvec2 mulI(vec2 z) {\n    return vec2(-z.y, z.x);\n}\n\nvec2 div(vec2 z, vec2 w) {\n    return (w.x * z + w.y * vec2(z.y, -z.x)) / mag2(w);\n}\n\nvec2 recip(vec2 z) {\n    return conj(z) / mag2(z);\n}\n\nvec2 sqr(vec2 z) {\n    return z.x * z + z.y * vec2(-z.y, z.x);\n}\n\nvec2 cube(vec2 z) {\n    vec2 z2 = z * z;\n    return z * vec2(z2.x - 3. * z2.y, 3. * z2.x - z2.y);\n}\n\nvec2 power4(vec2 z) {\n    return sqr(sqr(z));\n}\n\nvec2 power5(vec2 z) {\n    vec2 z2 = z * z;\n    vec2 z4 = z2 * z2;\n    return z * (z4 + 5. * z4.yx - 10. * z2.x * z2.y);\n}\n\nvec2 power(vec2 z, float p) {\n    return pow(mag2(z), p * .5) * cis(p * arg(z));\n}\n\nvec2 powervec2(vec2 z, vec2 w) {\n    float argz = arg(z);\n    float lnr = .5 * log(mag2(z));\n    return exp(dot(w, vec2(lnr, -argz))) * cis(dot(w, vec2(argz, lnr)));\n}\n\nvec2 sqrtp(vec2 z) {\n    float r = mag(z);\n    return vec2(1., sign(z.y)) * sqrt(.5 * vec2(r + z.x, r - z.x));\n}\n\nvec2 powexp(vec2 z) {\n    return exp(z.x) * cis(z.y);\n}\n\nvec2 ln(vec2 z) {\n    return vec2(log(mag2(z)) * .5, arg(z));\n}\n\nvec2 logb(vec2 z, vec2 b) {\n    return div(ln(z), ln(b));\n}\n\nvec2 sine(vec2 z) {\n    return vec2(sin(z.x) * cosh(z.y), cos(z.x) * sinh(z.y));\n}\n\nvec2 cosine(vec2 z) {\n    return vec2(cos(z.x) * cosh(z.y), -sin(z.x) * sinh(z.y));\n}\n\nvec2 sub_tan(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(squ_exp - one, mulI(squ_exp + one));\n}\n\nvec2 tangent(vec2 z) {\n    if (z.y < -21.) {\n        return conj(sub_tan(conj(z)));\n    } else {\n        return sub_tan(z);\n    }\n}\n\nvec2 sub_cot(vec2 z) {\n    vec2 squ_exp = powexp(mulI(z + z));\n    return div(mulI(squ_exp + one), squ_exp - one);\n}\n\nvec2 cot(vec2 z) {\n    if (z.y < -21.) {\n        return conj(sub_cot(conj(z)));\n    } else {\n        return sub_cot(z);\n    }\n}\n\nvec2 sec(vec2 z) {\n    return recip(cosine(z));\n}\n\nvec2 csc(vec2 z) {\n    return recip(sine(z));\n}\n\nvec2 arcsin(vec2 z) {\n    return mulI(ln(sqrtp(one - sqr(z)) - mulI(z)));\n}\n\nvec2 arccos(vec2 z) {\n    return -mulI(ln(mulI(sqrtp(one - sqr(z))) + z));\n}\n\nvec2 arctan(vec2 z) {\n    return -0.5 * mulI(ln(div(i - z, i + z)));\n}\n\nvec2 arccot(vec2 z) {\n    return -0.5 * mulI(ln(div(z + i, z - i)));\n}\n\nvec2 arcsec(vec2 z) {\n    return arccos(recip(z));\n}\n\nvec2 arccsc(vec2 z) {\n    return arcsin(recip(z));\n}\n\nvec2 sinhyp(vec2 z) {\n    return vec2(sinh(z.x) * cos(z.y), cosh(z.x) * sin(z.y));\n}\n\nvec2 coshyp(vec2 z) {\n    return vec2(cosh(z.x) * cos(z.y), sinh(z.x) * sin(z.y));\n}\n\nvec2 sub_tanh(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp - one, squ_exp + one);\n}\n\nvec2 tanhyp(vec2 z) {\n    if (z.x > 21.) {\n        return flip(sub_tanh(flip(z)));\n    } else {\n        return sub_tanh(z);\n    }\n}\n\nvec2 sub_coth(vec2 z) {\n    vec2 squ_exp = powexp(z + z);\n    return div(squ_exp + one, squ_exp - one);\n}\n\nvec2 coth(vec2 z) {\n    if (z.x > 21.) {\n        return flip(sub_coth(flip(z)));\n    } else {\n        return sub_coth(z);\n    }\n}\n\nvec2 sech(vec2 z) {\n    return recip(coshyp(z));\n}\n\nvec2 csch(vec2 z) {\n    return recip(sinhyp(z));\n}\n\nvec2 arcsinh(vec2 z) {\n    return ln(z + sqrtp(sqr(z) + one));\n}\n\nvec2 arccosh(vec2 z) {\n    return ln(z + mul(sqrtp(z + one), sqrtp(z - one)));\n}\n\nvec2 arctanh(vec2 z) {\n    return 0.5 * ln(div(one + z, one - z));\n}\n\nvec2 arccoth(vec2 z) {\n    return 0.5 * ln(div(z + one, z - one));\n}\n\nvec2 arcsech(vec2 z) {\n    return arccosh(recip(z));\n}\n\nvec2 arccsch(vec2 z) {\n    return arcsinh(recip(z));\n}\n\nvec2 linear(vec2 z, vec2 a, vec2 b) {\n    return mul(z, a) + b;\n}\n\nvec2 quadratic(vec2 z, vec2 a, vec2 b, vec2 c) {\n    return mul(z, mul(z, a) + b) + c;\n}\n\nvec2 cubic(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return mul(z, mul(z, mul(z, a) + b) + c) + d;\n}\n\nvec2 linearroot(vec2 a, vec2 b) {\n    return div(-b, a);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSfWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 118, 118, 822], [824, 824, 866, 866, 994], [996, 996, 1054, 1054, 1131], [1133, 1133, 1173, 1173, 1211], [1213, 1213, 1270, 1270, 2449]], "test": "untested"}
{"id": "NlSfDD", "name": "teacup attraction", "author": "yasuo", "description": "teacup attraction", "tags": ["teacup"], "likes": 6, "viewed": 193, "published": 3, "date": "1652189506", "time_retrieved": "2024-07-30T16:49:30.438659", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define USE_MOUSE 0\n#define MAX_STEPS 256\n#define MAX_DIST 128.\n#define SURF_DIST .001\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t )\n{\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat hash(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat randomTeaCups(vec3 p, float m){\n    vec3 prevP = p;\n    vec2 id = floor(p.xz/m);\n  \n    p.xz = mod(p.xz,m)-m*0.5;\n    \n    float time = iTime*0.0;\n    \n    float h = 1.0+clamp(hash(id), .1, .7)*3.1415*2.3;\n    p.y-=h-1.5;\n    \n    float size = 3.0;\n    float d = sdBox(p,vec3(h*0.03, h ,h*0.03));\n    \n    float dir = 1.0;\n    float n = hash(id);\n    if(n<0.5)dir = -1.0;\n    \n    p.xz *= Rot(radians(45.0+n*20.0+iTime*100.0*dir));\n    float d2 = sdCutHollowSphere(p-vec3(h*0.25+3.0,-h+size*1.7,0.0),size*1.7,0.1,0.01);\n    \n    p-=vec3(h*0.25+3.0,-h+size*0.8,0.0);\n    float d3 = sdCutHollowSphere(p,size*0.8,0.5,0.05);\n    float maskD3 = sdCutHollowSphere(p,size*0.6,0.5,0.6);\n    p.y*=0.8;\n    p.xy*=Rot(radians(90.0));\n    float d4 = sdTorus(p-vec3(0.0,0.6,size-0.3),vec2(0.5,0.15));\n    d4 = max(-maskD3,d4);\n    p = prevP;\n    d2 = max(p.y+0.5,d2);\n    d = min(d,d2);\n    d = min(d,d3);\n    d = min(d,d4);\n    return d*0.4;\n}\n\nvec2 GetDist(vec3 p) {\n\n    vec3 prevP = p;\n    \n    p = prevP;\n\n    p.z+=iTime*5.0;\n    p.y+=5.0;\n\n    float d = randomTeaCups(p,16.0);\n\n    p = prevP;\n    \n    vec2 model = vec2(d*0.6,MATERIAL);\n    vec2 model2 = vec2(p.y+6.5,MATERIAL1);\n    \n    //return model;\n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(10,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    vec3 prevP = p;\n    if(mat == MATERIAL){\n        vec3 c = vec3(0.9);\n        p.x+=iTime*2.0;\n        c+=hash(p.xz*50.0)*0.3;\n        p = prevP;\n        col = diffuseMaterial(n,rd,p,c);\n    } else if(mat == MATERIAL1){\n        p.z+=iTime*5.0;\n        p.xz*=0.1;\n        vec2 c = vec2(mod(floor(p.x)+floor(p.z),2.0));\n        vec3 c2 = vec3(c.x,c.x,c.y);\n        p.x+=iTime*2.0;\n        c2+=hash(p.xz*50.0)*0.3;\n        p = prevP;\n        col = diffuseMaterial(n,rd,p,c2);\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 5.0, -5.);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(20.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,3,0), 0.8);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(0.3);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n\n        col *= exp( -0.00001*d.x*d.x );//fog\n    } else {\n        uv.x+=iTime*2.0;\n        col+=hash(uv*100.0)*0.1;\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n    \n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSfDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[425, 425, 461, 461, 503], [505, 563, 594, 594, 681], [683, 741, 803, 865, 1071], [1073, 1131, 1164, 1164, 1229], [1231, 1231, 1251, 1251, 1323], [1325, 1325, 1362, 1362, 2262], [2264, 2264, 2286, 2286, 2564], [2566, 2566, 2624, 2624, 2891], [2893, 2893, 2917, 2917, 3118], [3120, 3120, 3162, 3162, 3357], [3359, 3400, 3449, 3449, 3743], [3745, 3745, 3802, 3802, 4416], [4418, 4418, 4477, 4477, 4976], [4978, 4978, 5035, 5035, 5887]], "test": "untested"}
{"id": "flSBDD", "name": "Moving Chess Board", "author": "lequal", "description": "A brown and white chess board", "tags": ["background", "chess", "board"], "likes": 0, "viewed": 166, "published": 3, "date": "1652186649", "time_retrieved": "2024-07-30T16:49:31.249491", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    float SPEED = 50.0;\n    float ZOOM = 0.6;\n    vec4 COLOR_DARK = vec4(46./255., 37./255., 30./255., 1.0);\n    vec4 COLOR_LIGHT = vec4(237./255., 218./255., 202./255., 1.0);\n    \n    \n    float offset = iTime * SPEED / 100.0;\n    \n    vec2 position = vec2(int(fragCoord.x/ZOOM/100.0 + offset), int((iResolution.y - fragCoord.y)/ZOOM/100.0 + offset));\n    \n    \n    if (int(position.x) % 2 == int(position.y) % 2) {\n        fragColor = COLOR_DARK;\n    } else {\n        fragColor = COLOR_LIGHT;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSBDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 561]], "test": "untested"}
{"id": "7ljBD1", "name": "Spline testbed", "author": "Suslik", "description": "A simple spline test", "tags": ["catmullrom"], "likes": 3, "viewed": 265, "published": 3, "date": "1652169389", "time_retrieved": "2024-07-30T16:49:32.114180", "image_code": "vec2 Interp(vec2 p0, vec2 p1, float ratio)\n{\n    return mix(p0, p1, ratio);\n}\n\nvec2 lerp(vec2 p0, vec2 p1, float t0, float t1, float param)\n{\n  float inv_range = 1.0f / (t1 - t0);\n  return p0 * (t1 - param) * inv_range + p1 * (param - t0) * inv_range;\n}\n\n//https://en.wikipedia.org/wiki/Centripetal_Catmull%E2%80%93Rom_spline\nvec2 CatmullRom(vec2 p0, vec2 p1, vec2 p2, vec2 p3, vec4 t, float param)\n{\n  vec2 a0 = lerp(p0, p1, t[0], t[1], param);\n  vec2 a1 = lerp(p1, p2, t[1], t[2], param);\n  vec2 a2 = lerp(p2, p3, t[2], t[3], param);\n  \n  vec2 b0 = lerp(a0, a1, t[0], t[2], param);\n  vec2 b1 = lerp(a1, a2, t[1], t[3], param);\n  \n  return lerp(b0, b1, t[1], t[2], param);\n}\n\n//http://www.jcgt.org/published/0009/03/02/paper.pdf\nuvec3 hash33UintPcg(uvec3 v)\n{\n\tv = v * 1664525u + 1013904223u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\t//v += v.yzx * v.zxy; //swizzled notation is not exactly the same because components depend on each other, but works too\n\n\tv ^= v >> 16u;\n\tv.x += v.y*v.z; v.y += v.z*v.x; v.z += v.x*v.y;\n\t//v += v.yzx * v.zxy;\n\treturn v;\n}\n\n//this jitters on my machine for some reason\nvec3 hash33( vec3 p )\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn fract(sin(p)*43758.5453123);\n}\n\nvec3 hash33Stable(vec3 val)\n{\n\tuvec3 seed_uvec3 = floatBitsToUint(val);\n\tuvec3 hash_uvec3 = hash33UintPcg(seed_uvec3);\n\treturn vec3(hash_uvec3) * (1.0f / float(~0u));\n}\n\nfloat GetSplineParamDelta(vec2 p0, vec2 p1, float alpha)\n{\n    return pow(length(p0 - p1), alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixel_pos = fragCoord.xy;\n    \n    vec3 col = vec3(0.0f);\n    vec2 p[4];\n    p[0] = vec2(100.0f, 100.0f);\n    p[1] = vec2(500.0f, 100.0f);\n    p[2] = vec2(550.0f, 200.0f);\n    p[3] = vec2(150.0f, 300.0f);\n    vec2 size = iResolution.xy;\n    \n    float alpha = float(iMouse.x) / float(iResolution.x);//sin(iTime) * 0.5f + 0.5f;\n    \n    vec4 t;\n    t[0] = 0.0f;\n    for(int i = 1; i < 4; i++)\n    {\n        t[i] = t[i - 1] + GetSplineParamDelta(p[i - 1], p[i], alpha);\n    }\n    \n    if(length(pixel_pos - p[1]) < 20.0f)\n      col += vec3(0.5f, 0.0f, 0.0f);\n    for(int i = 0; i < 10; i++)\n    {\n        for(float ratio = 0.0f; ratio < 1.0f; ratio += 0.01f)\n        {\n            vec2 p = CatmullRom(p[0], p[1], p[2], p[3], vec4(t[0], t[1], t[2], t[3]), mix(t[1], t[2], ratio));\n\n            if(length(pixel_pos - p) < 10.0f)\n                col += vec3(0.1f, 0.1f, 0.1f);\n        }\n        if(length(pixel_pos - p[2]) < 20.0f)\n            col += vec3(0.5f, 0.0f, 0.0f);\n\n        p[0] = p[1];\n        p[1] = p[2];\n        p[2] = p[3];\n        t[0] = t[1];\n        t[1] = t[2];\n        t[2] = t[3];\n        p[3] = hash33Stable(vec3(i, 0.0f, 0.0f)).xy * size;\n        t[3] = t[2] + GetSplineParamDelta(p[2], p[3], alpha);\n    }\n        \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    // Output to screen\n    fragColor = vec4(pow(col, vec3(1.0f / 2.2f)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7ljBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 77], [79, 79, 141, 141, 253], [255, 326, 400, 400, 675], [677, 730, 760, 760, 1066], [1068, 1113, 1136, 1136, 1294], [1296, 1296, 1325, 1325, 1464], [1466, 1466, 1524, 1524, 1566], [1568, 1568, 1625, 1625, 3072]], "test": "untested"}
{"id": "ftjBDh", "name": "Abstract Patterns #6", "author": "leon", "description": "more gyroid experiments", "tags": ["noise", "abstract", "gyroid"], "likes": 40, "viewed": 905, "published": 3, "date": "1652126598", "time_retrieved": "2024-07-30T16:49:32.868164", "image_code": "\n// Abstract Patterns #6 by Leon Denise 2022/05/09\n\n// Inspired by Martijn Steinrucken \"Math Zoo - Alien Orb\"\n// https://www.youtube.com/watch?v=b0AayhCO7s8\n// https://www.shadertoy.com/view/tlcXWX\n\n// Using code from Martijn Steinrucken, Dave Hoskins,\n// Inigo Quilez, Antoine Zanuttini and many more\n\nconst float scale = 5.;\nconst float shell = .3;\nconst float carve = .3;\nconst float falloff = 1.8;\nconst float blend = .02;\n\n// signed distance function\nfloat map(vec3 p)\n{\n    vec3 pp = p;\n    float d = 100.;\n    float a = 1.;\n    \n    // gyroid multi scale pattern\n    for (float i = 0.; i < 3.; ++i)\n    {\n        p = pp * scale / a;\n        p.z -= iTime * a;\n        d = smin(d, abs(dot(sin(p),cos(p.yzx))/scale*a), blend);\n        a /= falloff;\n    }\n    \n    // invert volume\n    d = -d;\n    \n    // ripple surface\n    d += sin(p.z*10.+iTime*20.)*0.002;\n    \n    // substract sphere\n    d = smin(d, -(length(pp)-shell), -carve);\n    \n    return d;\n}\n\n// NuSan\n// https://www.shadertoy.com/view/3sBGzV\nvec3 getNormal (vec3 pos)\n{\n    vec2 noff = vec2(0.001,0);\n    return normalize(map(pos)-vec3(map(pos-noff.xyy), map(pos-noff.yxy), map(pos-noff.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n    vec2 uv = (fragCoord.xy - iResolution.xy / 2.)/iResolution.y;\n    float dither = hash12(fragCoord);\n    vec3 ray = normalize(vec3(uv, -0.5));\n    vec3 pos = vec3(0);\n\n    // raymarching\n    float index = 0.;\n    const float count = 17.;\n    for (index = count; index > 0.; --index)\n    {\n        float dist = map(pos);\n        if (dist < .001) break;\n        dist *= .9+.1*dither;\n        pos += ray*dist;\n    }\n\n    // coloring\n    vec3 normal = getNormal(pos);\n    vec3 color = .5+.2*normal;\n    float backLight = dot(normal, vec3(0,0,-1))*.5+.5;\n    float bottomLight = dot(normal, vec3(0,-1,0))*.5+.5;\n    vec3 tint = .9*cos(vec3(1,2,3)+pos.z*18.-iTime);\n    color += vec3(1,-.5,-.5)*backLight;\n    color += tint * bottomLight;\n    color *= index/count;\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "\n// Inigo Quilez\n// https://iquilezles.org/articles/distfunctions/\nfloat smin(float d1, float d2, float k)\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\n// Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftjBDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[428, 456, 475, 475, 958], [960, 1010, 1037, 1037, 1164], [1166, 1166, 1223, 1242, 2040]], "test": "untested"}
{"id": "st2BRW", "name": "Erosion Landscape V2", "author": "Dragonpeak", "description": "Space to Reset terrain, One(1) to view terrain and particles, Two(2) to toggle erosion on and off.\nBased on a previous shader of mine, reworked to use reintegration tracking(https://michaelmoroz.github.io/Reintegration-Tracking/) for erosion.", "tags": ["procedural", "raymarching", "simulation", "clouds", "landscape", "volumetrics", "erosion"], "likes": 8, "viewed": 410, "published": 3, "date": "1652121987", "time_retrieved": "2024-07-30T16:49:33.815630", "image_code": "// When focused on the shader window, space to reset terrain, One(1) to view terrain and particles, Two(2) to toggle erosion on and off.\n//Based on a previous shader of mine, reworked to use reintegration tracking(https://michaelmoroz.github.io/Reintegration-Tracking/) for erosion.\n\n// a quick dof, doesn't quite work on the clouds but it is good enough\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    if(data.w >=FAR)\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        //col = data.xyz;\n        float focus = abs(data.w-FOCUS_DIST)/FAR*BLUR_MUL;\n        float tot = 0.;\n        int blur_size = int(focus+1.)*2;\n        for(int x = -blur_size; x < blur_size; x++)\n        {\n\n            float w = Gaussian(float(x), 1., 0., focus);\n            tot+=w;\n            col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(0,x),0).xyz*w;\n        }\n        col/=tot;\n    }\n    \n    col*=vec3(0.690,0.765,0.812)*.8;\n    //col = vec3(focus); \n    if(texelFetch(iChannel3, ivec2(49,2),0).x>0.)col = texture(iChannel1, fragCoord/iResolution.xy).www*.5 +  texture(iChannel2, fragCoord/iResolution.xy).zzz*vec3(100,0,0);\n    fragColor = vec4(pow(col, vec3(1./2.2)),1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//terrain\nconst vec2 OFF = vec2(.1, 0.3);\nconst float BLUR_AMT = .1;\n\nconst vec2 NRM_EPS = vec2(.1,0.);\nconst float NRM_SOFT = .002;\nconst int OCT = 16;\n\n\n\n\nfloat GetTerrain(vec2 p)\n{\n    float data = 0.;\n    if(iFrame < 5 || IsSpaceDown(iChannel3))\n    {\n        p/=iResolution.xy;\n        p += OFF;\n        float s = 2.5;\n        float a = .5;\n        \n        for(int i = 0; i < OCT; i++)\n        {\n            data += abs(Noise2D((p+vec2(float(i)*7.8936345, float(i)*-13.73467))*s)*a-a/2.)/2.*.7+\n            Noise2D((p-17.+vec2(float(i)*7.8936345, float(i)*-13.73467))*s)*a*.3;\n            s*= 1.7;\n            a*= .5;\n        }\n       \n        data = pow(1.-data, 7.8)*1.8* mix(1., .4, pow(length((p-OFF-.5)*.8), .7))-.08;\n    }\n    else\n    {\n        data = texture(iChannel1, p/iResolution.xy).w;\n    }\n    \n    return data;\n}\n\nvec3 GetTerrainNrm(vec2 uv)\n{ \n    vec3 nrm = vec3(0.);\n    nrm.x = -(GetTerrain(uv+NRM_EPS) - GetTerrain(uv-NRM_EPS));\n    nrm.y = -(GetTerrain(uv+NRM_EPS.yx) - GetTerrain(uv-NRM_EPS.yx));\n    nrm.z = NRM_EPS.x*NRM_SOFT;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float f = GetTerrain(fragCoord);\n    vec4 data = texture(iChannel2, fragCoord/iResolution.xy);\n    f-= mix(.6, 1., Noise2D(fragCoord/iResolution.xy*80.))*iResolution.x*.0000000005*(length(data.xy)-90.)*float(texelFetch(iChannel3, ivec2(50, 2),0).x<=0.);\n    \n\n    f = clamp(f,0.,1.);\n    fragColor = vec4(GetTerrainNrm(fragCoord),f);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\nconst float WATER_HEIGHT = .02;\nconst float FOCUS_DIST = 2.3;\nconst float BLUR_MUL = 6.;\n\n\nconst vec2 WIND = vec2(.06, .1);\nconst float FAR = 5.;\nuvec2 pcg2d(uvec2 v)\n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    v.x += v.y * 1664525u;\n    v.y += v.x * 1664525u;\n\n    v = v ^ (v>>16u);\n\n    return v;\n}\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec2 Rand2D(vec2 v)\n{\n    return vec2(pcg2d(uvec2(v)))/float(0xffffffffu);\n}\nvec3 Rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat Noise2D(vec2 p)\n{\n    vec2 ap = abs(p);\n    vec2 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand2D(ap).x;\n    float b = Rand2D(ap+vec2(1,0)).x;\n    float c = Rand2D(ap+vec2(0,1)).x;\n    float d = Rand2D(ap+vec2(1)).x;\n\n    float v = mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y);\n    \n\n    \n\n    return v;\n}\nfloat Noise3D(vec3 p)\n{\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand3D(ap).x;\n    float b = Rand3D(ap+vec3(1,0,0)).x;\n    float c = Rand3D(ap+vec3(0,1,0)).x;\n    float d = Rand3D(ap+vec3(1,1,0)).x;\n    \n    float e = Rand3D(ap+vec3(0,0,1)).x;\n    float f = Rand3D(ap+vec3(1,0,1)).x;\n    float g = Rand3D(ap+vec3(0,1,1)).x;\n    float h = Rand3D(ap+vec3(1,1,1)).x;\n\n    float v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n\n    \n\n    return v;\n}\n\n\n\nbool IsSpaceDown(sampler2D key)\n{\n    return texelFetch(key, ivec2(32,0),0).x>0.;\n}\n\nfloat Gaussian(float x, float a, float b, float c)\n{\n    return a*exp(-(pow(x-b,2.)/pow(2.*c,2.)));\n}", "buffer_b_code": "//particles https://michaelmoroz.github.io/Reintegration-Tracking/\nconst int AREA = 5;\nfloat SIZE = .0005;\nconst float FRICTION = .98;\nconst float SPEED = .3;\nconst float ERR_STR =.000007;\nbool BBOX_intersect(vec4 a, vec4 b)\n{\n     return !(b.x > a.z\n        || b.z < a.x\n        || b.y > a.w\n        || b.w < a.y);\n}\nvec4 BBOX_overlap(vec4 a, vec4 b)\n{\n    vec4 r = vec4(0);\n    r.xy = max(a.xy,b.xy);\n    r.zw = min(a.zw,b.zw);\n    if(r.x > r.z || r.y > r.w)return vec4(-1);\n    return r;\n}\n\nfloat BBOX_size(vec4 bbox)\n{\n    return max((bbox.x-bbox.z)*(bbox.y-bbox.w),0.);\n}\nfloat BBOX_percent(vec4 a, vec4 b)\n{\n    return BBOX_size(a)/BBOX_size(b);\n}\n \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    SIZE*=iResolution.x;\n    fragColor = vec4(0);\n    \n    if(!(iFrame < 5 || IsSpaceDown(iChannel2)))\n    {\n        vec4 bbox = vec4(fragCoord-.5, fragCoord+.5);\n        for(int x = -AREA; x < AREA; x++)\n        {\n            for(int y = -AREA; y < AREA; y++)\n            {\n                vec2 pos = fragCoord+vec2(x,y);\n\n                vec4 data = texture(iChannel0, pos/iResolution.xy);\n                pos += data.xy*0.01;\n           \n                \n              \n                \n                vec4 prbox = vec4(pos-SIZE,pos+SIZE);\n                if(BBOX_intersect(bbox,prbox))\n                {\n                    vec4 overlap = BBOX_overlap(prbox, bbox);\n                    float amt = BBOX_percent(overlap, prbox);\n\n                    \n                    fragColor += data*amt;\n                }\n           \n                \n            }\n        }\n    \n       \n    }\n    vec4 data = texelFetch(iChannel1, ivec2(fragCoord), 0); \n    if(Rand2D((fragCoord*iTime*100000.3261*iTimeDelta)).x>.9 && data.w > WATER_HEIGHT)\n    {\n        fragColor.xy += normalize(Rand2D((fragCoord+iTime*12.3261*iTimeDelta))*2.-1.)*50.;\n        fragColor.z += Rand2D((fragCoord*iTime*300000.3261*iTimeDelta)).x*.005;\n \n    }\n    if(fragColor.z != 0.)\n    {\n        \n        vec2 vel = vec2(0);\n        vel += normalize(Rand2D((fragCoord*14124.*iTime*12.3261*iTimeDelta))*2.-1.)*50.;\n        \n        vel += data.xy*10.;\n        //vel += vec2(0,-5.);\n        vel *=SPEED;\n        fragColor.xy += vel;\n        fragColor.z+=ERR_STR*length(fragColor.xy)-.0005;\n        \n        //fragColor.xy/=fragColor.z;\n        fragColor.xy*=FRICTION;\n        fragColor.z*=.99;\n        //fragColor.xy = normalize(fragColor.xy);\n        //fragColor *= (data.w < WATER_HEIGHT) ? vec4(vec2(0.95), .99, 1.) : vec4(1.);\n        \n        \n        \n       \n        \n    }\n   \n\n    \n}", "buffer_b_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//rendering\nvec3 CAMERA_POS = vec3(-1.5, -1.5, 1.);\nconst vec3 CAMERA_LOOK = vec3(0.,0.,0.);\n\n\nconst float EPS = .01;\nconst float SHADOW_EPS = .03;\nconst float STEP_SIZE = .002;\nconst float SHADOW_STEP = .05;\nvec3 SUN_DIR = normalize(vec3(.3, .5, .2));\nconst vec3 SUN_COL = vec3(1,.7,.4)*2.5;\nconst vec3 AMBIENT = vec3(.3,.35,.53)*.3;\n\nconst vec2 W_NRM_EPS = vec2(.001,0.);\n\nconst float CLOUDS_STEP = .01;\nconst int CLOUD_OCT = 6;\nconst float CLOUD_SCALE = .0016;\nconst float CLOUD_LIGHT_STEP = .04;\nconst float CLOUD_LIGHT_FAR = .1;\n\nconst int TERRAIN_BUMP_OCT = 4;\n\nconst vec2 T_NRM_EPS = vec2(.0017,0.);\nstruct Ray\n{\n    vec3 origin;\n    vec3 dir;\n};\nRay ConstructViewRay(vec2 screen_pos, vec3 pos, vec3 look_dir, vec3 up, float len)\n{\n    Ray r = Ray(pos, vec3(0));\n    \n    vec3 side = cross(up, look_dir);\n    vec3 cam_up = cross(look_dir,side);\n    \n    r.dir = normalize(side*screen_pos.x+cam_up*screen_pos.y+look_dir*len);\n    \n    return r;\n}\n\nvec2 RayBoxIntersect( Ray r, vec3 boxSize, out vec3 outNormal ) \n{\n    //from https://iquilezles.org/articles/intersectors\n    vec3 m = 1.0/r.dir; // can precompute if traversing a set of aligned boxes\n    vec3 n = m*r.origin;   // can precompute if traversing a set of aligned boxes\n    vec3 k = abs(m)*boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    if( tN>tF || tF<0.0) return vec2(FAR); // no intersection\n    outNormal = -sign(r.dir)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n    return vec2( tN, tF );\n}\n\nvec4 GetTerrain(vec2 p)\n{\n    if(p.x > 1. || p.y > 1.|| p.x < -1.|| p.y < -1.) return vec4(0,0,1,0);\n    vec4 data = texture(iChannel0, (p+vec2(1.01))*.47);\n    return data;\n}\n\nvec4 MarchTerrain(Ray r, float dist, float far)\n{\n    vec4 data = vec4(0);\n    while(dist < far)\n    {\n        vec3 p = r.origin+r.dir*dist;\n        data = GetTerrain(p.xy);\n        if(p.z < data.w+EPS)return vec4(data.xyz, dist-STEP_SIZE/2.);\n        dist += STEP_SIZE*(Rand3D(p+iTime).x+.5);\n    }\n    return vec4(data.xyz, FAR);\n}\nfloat MarchShadows(Ray ray, float k)\n{\n    float r = 1.;\n    float dep = 0.001+SHADOW_EPS;\n    while(dep < FAR)\n    {\n        vec3 p = ray.origin+ray.dir*dep;\n        vec4 data = GetTerrain(p.xy);\n        //if(p.z < dist+SHADOW_EPS) 0.;\n        \n        r = min(r, k*(p.z-data.w)/dep);\n        dep += SHADOW_STEP;\n    }\n    return r;\n}\n\n\nfloat CloudDens(vec3 p)\n{\n   float s = 2.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < CLOUD_OCT; i++)\n   {\n       data += Noise3D(((p+vec3(float(i)*7.8936345, float(i)*-13.73467, float(i)*-36.71261))*s)+vec3(WIND,0.)*iTime)*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   data = min(max(data-.7, 0.)*4., 1.);\n   \n   float h = max(1.-max(abs(p.z-.4)+4.93, 0.)*.2, 0.);\n   \n   return max(data*h*50.,0.);\n       \n}\n\nvec3 MarchCloudLight(Ray r)\n{\n    float dep = 0.;\n    float dens = 0.;\n    while(dep < CLOUD_LIGHT_FAR)\n    {\n        vec3 pos = r.origin+r.dir*dep;\n        dens += CloudDens(pos)*8.;\n        dep += CLOUD_LIGHT_STEP;\n    }\n    return (vec3(exp(-(dens)))*SUN_COL*1.2+AMBIENT*.1)*vec3(.85,.87,1.3)*1.6;\n}\n\nvec4 MarchClouds(Ray r, float mi, float ma)\n{\n    float dep = mi;\n    float trans = 1.;\n    vec3 light = vec3(0.);\n    while(dep < ma)\n    {\n        vec3 pos = r.origin+r.dir*dep;\n        float cd = CloudDens(pos);\n        dep += CLOUDS_STEP;\n        if(cd>.01)\n        {\n            light += MarchCloudLight(Ray(pos, SUN_DIR))*cd*trans;\n            trans *= exp(-cd);\n        }\n    }\n    return vec4(light, trans);\n}\n\n\n\nfloat TerrainBump(vec2 p)\n{\n   float s = 60.;\n   float a = .5;\n   float data = 0.;\n   for(int i = 0; i < TERRAIN_BUMP_OCT; i++)\n   {\n       data += Noise2D(((p.xy+vec2(float(i)*7.8936345, float(i)*-13.73467))*s))*a;\n       s*= 1.8;\n       a*= .6;\n   }\n   return data;\n}\n\nvec3 TerrainBumpNrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(TerrainBump(p+T_NRM_EPS) - TerrainBump(p-T_NRM_EPS));\n    nrm.y = -(TerrainBump(p+T_NRM_EPS.yx) - TerrainBump(p-T_NRM_EPS.yx));\n    nrm.z = .8;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\n\nfloat GetAO(vec2 p)\n{\n    vec2 t = vec2(EPS*3., 0);\n    float ao = 0.;\n    \n    float b = GetTerrain(p).w;\n    \n    float x = (GetTerrain(p+t).w+GetTerrain(p-t).w+GetTerrain(p+t.yx).w+GetTerrain(p-t.yx).w)/4.;\n    \n    ao += b-x;\n    \n    return ao*16.+.4;\n}\n\nvec3 TextureTerrain(vec3 p, vec3 nrm, bool is_edge)\n{\n    vec3 col = vec3(0.);\n    vec3 stone = vec3(.6);\n    vec3 grass = vec3(.4, .6, .4);\n    vec3 snow = vec3(1.1, 1.1, 1.2)*4.;\n\n    float stone_mask = min(max((nrm.z-.75), 0.)*8.*smoothstep(0.12, .8, Noise3D(p*40.)), 1.);\n    float snow_mask = min(max((p.z-.2)*Noise3D(p*30.), 0.)*64., 1.);\n    \n    vec3 ground = mix(grass, snow, snow_mask);\n    \n    col = mix(stone, ground, stone_mask)*mix(.6, 1., Noise3D(p*20.+41.));\n\n    \n    return col;\n}\n\nfloat CloudShadow(vec3 p)\n{\n    return 1.-CloudDens(p+SUN_DIR*max(dot(vec3(0,0,.4)-p, vec3(0,0,-1))/dot(SUN_DIR, vec3(0,0,-1)), 0.));\n}\n\nvec3 ShadeTerrain(vec3 p, vec3 nrm, vec3 dir, float dist, bool is_edge)\n{\n\n    vec3 col = TextureTerrain(p,nrm,is_edge);\n    float sun = clamp(dot(SUN_DIR, nrm), 0.,1.);\n    vec3 r = reflect(dir, nrm);\n    vec3 ref = vec3(min(max((dot(r, SUN_DIR)-.85), 0.)*4., 1.));\n    if(!is_edge)\n    {\n        float shadow = clamp(MarchShadows(Ray(p, SUN_DIR), 10.),0.,1.);\n        shadow *= clamp(CloudShadow(p)*2.3-1.3,0.,1.);\n\n        sun *= shadow;\n        ref *= shadow;\n        //return vec3(shadow);\n\n    }\n    vec3 light = SUN_COL*sun;\n    light += AMBIENT;\n    light += ref;\n    light += vec3(.2, .2, .1)*max(dot(-SUN_DIR, nrm),0.);\n    \n    if(!is_edge)\n    {\n        float ao = GetAO(p.xy);\n\n        light *= ao;\n    }\n    \n  \n    col *= light;\n    //col = nrm;\n    //col = vec3(shadow);\n   \n    return col;\n}\n\nvec3 DrawFog(vec3 p, float d, bool is_edge)\n{\n    if(is_edge)return vec3(0);\n    d /= FAR;\n    d = exp(d);\n    float z = 1.-min(max(p.z-.03, 0.)*5., 1.);\n    z *= d;\n    return vec3(.7, .7, .9)*z*.2;\n}\n\nvec3 ShadeSky(vec3 d)\n{\n    vec3 col = mix(vec3(.8,.8, 1.), vec3(.025, .05, .7)*.8, clamp(d.z+.4, 0., 1.));\n    \n    \n    col += SUN_COL*max(1.-max(distance(SUN_DIR, d)+.9, 0.), 0.)*10.;\n    \n    return col;\n}\n\nfloat WaterHeight(vec2 p)\n{\n    return Noise2D((p*100.2+144.)+WIND*iTime);\n}\n\nvec3 WaterNrm(vec2 p)\n{\n    vec3 nrm = vec3(0.);\n    nrm.x = -(WaterHeight(p+W_NRM_EPS) - WaterHeight(p-W_NRM_EPS));\n    nrm.y = -(WaterHeight(p+W_NRM_EPS.yx) - WaterHeight(p-W_NRM_EPS.yx));\n    nrm.z = .5;\n    nrm = normalize(nrm);\n    \n    return nrm;\n}\n\nvec3 Fresnel(float cosTheta, vec3 F0)\n{\n    //from https://learnopengl.com/PBR/Theory\n    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 ShadeWater(vec3 dir, float d, float wd, vec3 nrm)\n{\n    nrm = normalize(nrm+WaterNrm((CAMERA_POS+dir*wd).xy));\n    float h = GetTerrain((CAMERA_POS+dir*wd).xy).w/WATER_HEIGHT*2.;\n    float fr = Fresnel(dot(dir, nrm), vec3(1.055)).x;//Fresnel\n    vec3 sky = ShadeSky(reflect(dir, nrm));\n\n    return vec3(sky*fr*.5+h*.4);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n\n    SUN_DIR.x = sin(iTime*.1-.8);\n    SUN_DIR.y = cos(iTime*.1-.8);\n    SUN_DIR = normalize(SUN_DIR);\n    CAMERA_POS.y = sin(iTime*0.2)*2.5;\n    CAMERA_POS.x = cos(iTime*0.2)*2.5;\n\n    vec2 screen_pos = fragCoord.xy/iResolution.y*2.-1.-vec2(iResolution.x/iResolution.y/2.,0);\n\n    \n    Ray view_ray = ConstructViewRay(screen_pos, CAMERA_POS, normalize(-CAMERA_POS), vec3(0,0,1), 2.);\n\n    vec3 b_nrm;\n    vec3 box_s = vec3(1,1,FAR);\n    vec2 b_dist = RayBoxIntersect(view_ray, box_s, b_nrm);\n    col = ShadeSky(view_ray.dir);\n    vec4 data = vec4(0,0,0,FAR);\n    if(b_dist.x<FAR)\n    {\n\n        data = MarchTerrain(view_ray, b_dist.x, b_dist.y);\n        if(data.w <= b_dist.x+EPS) data = vec4(b_nrm, b_dist.x);\n        data.w = min(data.w, b_dist.y);\n        vec3 pos = CAMERA_POS+view_ray.dir*data.w;\n\n        bool is_edge = data.w <= b_dist.x;\n        vec3 WaterNrm;\n        vec2 water_d = RayBoxIntersect(view_ray, vec3(box_s.xy, WATER_HEIGHT), WaterNrm);\n        //if(is_edge) data.xyz = b_nrm;\n        if(data.w < b_dist.y)\n        {\n             if(!is_edge)data.xyz = normalize(data.xyz+TerrainBumpNrm(pos.xy));\n             col = ShadeTerrain(pos, data.xyz, view_ray.dir, data.w,is_edge);\n             col *= (is_edge) ? max(min(pos.z*.3+.1, 1.), 0.)+.01 : 1.;\n\n             //col = data.xyz;\n        }\n        if(water_d.x < data.w)\n        {\n\n            col += ShadeWater(view_ray.dir, data.w, water_d.x, WaterNrm);\n            data.w = water_d.x;\n        }\n        vec3 ndump;\n        col += DrawFog(pos, data.w,is_edge);\n        vec2 cbox = RayBoxIntersect(Ray(CAMERA_POS-vec3(0.,0.,.4), view_ray.dir), vec3(box_s.xy, .1),ndump);\n        if(cbox.x < FAR)\n        {\n            vec4 cld = MarchClouds(Ray(CAMERA_POS, view_ray.dir+vec3(vec2(pcg2d(uvec2(fragCoord)+uint(iFrame)))/float(0xffffffffu)*.002, 0.)), cbox.x+.01, min(data.w, cbox.y));\n            data.w = mix(data.w, cbox.x, 1.-cld.w);\n            col = mix(cld.rgb, col, cld.w);\n            //col = vec3(1.);\n        }\n\n        //col = vec3(cld.rgb);\n\n    }\n    \n    //col = vec3(CloudDens(vec3(fragCoord/iResolution.xy*3., 1.)));\n    \n    //col = vec3(Noise2D(fragCoord/iResolution.xy*80.));\n    // Output to screen\n    fragColor = vec4(col, data.w);\n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 col = vec3(0.);\n    vec4 data = texelFetch(iChannel0, ivec2(fragCoord),0);\n    if(data.w >=FAR)\n    {\n        col = data.xyz;\n    }\n    else\n    {\n        //col = data.xyz;\n        float focus = abs(data.w-FOCUS_DIST)/FAR*BLUR_MUL;\n        float tot = 0.;\n        int blur_size = int(focus+1.)*2;\n        for(int x = -blur_size; x < blur_size; x++)\n        {\n\n            float w = Gaussian(float(x), 1., 0., focus);\n            tot+=w;\n            col += texelFetch(iChannel0, ivec2(fragCoord)+ivec2(x,0),0).xyz*w;\n        }\n        col/=tot;\n    }\n\n    fragColor = vec4(col,data.w);\n}", "buffer_d_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2BRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[358, 358, 415, 415, 1268]], "test": "untested"}
{"id": "NljfDz", "name": "ray sample test thing", "author": "SnoopethDuckDuck", "description": "very messy, playing about with random stuff", "tags": ["e"], "likes": 5, "viewed": 217, "published": 3, "date": "1652117181", "time_retrieved": "2024-07-30T16:49:34.696276", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0. * iResolution.xy) / iResolution.xy;\n\n    vec3 col = texelFetch(iChannel0, ivec2(fragCoord.xy), 0).rgb;\n\n    float of = 2.;// + 3. * cos(length(col) * 0. + uv.x * 2. + iTime);\n   // of = mix(2., of, 0.5 + 0.5 * thc(4., iTime));\n\n    vec3 t = texelFetch(iChannel0, ivec2(fragCoord - vec2(0,of)), 0).rgb;\n    vec3 b = texelFetch(iChannel0, ivec2(fragCoord + vec2(0,of)), 0).rgb;\n    vec3 l = texelFetch(iChannel0, ivec2(fragCoord - vec2(of,0)), 0).rgb;\n    vec3 r = texelFetch(iChannel0, ivec2(fragCoord + vec2(of,0)), 0).rgb;\n\n    float k = 2.;\n    vec3 col2 = abs((1.-smoothstep(-k, k, -(abs(l-r) + abs(t-b)) + vec3(0.5))));\n    \n    float k2 = 1.5 / iResolution.x;\n    col = mix(col, col2, smoothstep(-k2, k2, -uv.x + 0.5));\n    \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "buffer_a_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define DIST_SCALE 0.9\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 3.;\n    float t = 0.15 * iTime;\n    vec3 ro = vec3(r * cos(t), 0, r * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    p.xz += vec2(0.02,0.3) * iTime;\n    \n    float sc = 0.8;\n    vec3 ip = floor(sc * p) + 0.5;\n    vec3 fp = sc * p - ip;   \n\n    float h1 = h21(ip.xz);\n    float h2 = h21(ip.yz);\n       \n    fp.xy *= Rot(0.25 * iTime + 2. * pi * h1);\n    fp.yz *= Rot(0.25 * iTime + 2. * pi * h2);\n    float r1 = 0.35 * h2;\n    float r2 = max(0.02, 0.3 - r1);\n    float d1 = length(fp.xz)-r1;\n    float d2 = length(vec2(d1,fp.y))-r2;\n\n    return DIST_SCALE * d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetSample(vec3 p) {\n\tfloat d = GetDist(p);\n    vec3 n = GetNormal(p);\n    \n    float s = 0.;\n    vec2 e = vec2(0.5,0);\n\n    float sc = 0.5;\n    float a = n.x, b = n.y, c = n.z;\n    s += GetDist(p - sc * n.xyz);\n    s += GetDist(p + sc * n.xyz);\n\n    s *= 0.5 / DIST_SCALE;\n   \n   float k = 0.5;\n   // s = smoothstep(-k,k,s);\n    \n    return s - d;\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        d += mix(4., GetSample(p), 0.5 + 0.5 * thc(400000., 10. * p.y - 0.5 * iTime));\n        vec3 q = ro + rd * d;\n        vec3 n = GetNormal(q);\n        vec3 r = reflect(rd, n);    \n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        //col *= 0.5 + 0.5 * n;\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(d * 0.5 + 0.25 * p.y + 0.15 * iTime, e, e, e, vec3(0,1,2)/3.);\n        col *= col2;\n        \n        float fres = 0.5 * exp(abs(dot(rd,n)));//pow(1. + dot(rd, n), 5.);\n        col = mix(col, col2, fres);\n\n    }\n    \n    float mx = clamp(exp(4.-1. * length(p)),0.,1.);\n    col = mix(vec3(1.,0.75,0.5), col, mx);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 850]], "test": "untested"}
{"id": "flBfD1", "name": "Revenge of Kenneth", "author": "eiffie", "description": "Glitch art on some architectures. Best viewed full screen.", "tags": ["dct"], "likes": 8, "viewed": 382, "published": 3, "date": "1652105661", "time_retrieved": "2024-07-30T16:49:35.507108", "image_code": "//Revenge of Kenneth by eiffie (glitch art + fast >20x DCT decompression)\n#define siz vec2(128,160)\nint ken[]=int[320](\n460180184,460180184,460179672,343054601,38316189,458078949,324123365,172870372, \n325958435,326220002,326220576,460180184,460180184,460180184,460180184,460180184, \n460180184,460180184,459945808,458303701,458345254,458083110,460179685,458341093, \n728619811,460438242,460438304,460176160,460180184,460180184,460180184,460180184, \n460180184,460180184,460175745,460175582,460409574,455989533,441600222,309176549, \n191736555,325667617,458078369,460442400,460180184,460180184,460180184,460180184, \n460180184,460180184,324122561,460179686,477247711,189901550,476924189,707681054, \n311540013,55429930,460179681,458341088,460180184,458078936,460176160,460180184, \n460180184,460180184,460179329,458082021,460179615,476953319,610589603,323860118, \n191187749,745646891,860732192,460180184,460180184,460176208,460176232,460180184, \n460180184,460180184,460179393,460175133,594397407,460442343,457357291,701016277, \n166840557,233716521,59882200,325958432,460180184,460408600,458345248,460180184, \n460180184,460180184,460437953,460441958,460175583,458078951,293415276,208595670, \n189905639,425040629,342216473,460176160,460180184,460175640,458082592,460180184, \n460180184,442964305,846465364,342735078,460441823,460180191,340671151,547109219, \n441382621,712396446,79244074,342997792,460180184,460180184,460180184,460180184, \n460180184,57747460,879834398,325962022,476956895,326224607,594397927,460208869, \n226276827,1133270,441272636,460442400,460180184,460180184,460180184,460180184, \n459416976,339007141,362732181,594393886,460175583,460176103,728611622,577354525, \n338536671,307047086,613788339,460442400,460180184,460180184,326219992,460180184, \n458340801,326742140,441602077,324127446,460180191,460180191,594426599,949295846, \n392231261,575817895,574965948,460176152,460180184,460438232,460143328,460180184, \n323866441,493570077,692360733,611175190,460442343,611432671,460180191,457763061, \n208821033,613013636,460699900,460176160,460179672,208484568,594397912,460180184, \n457821001,461757636,457824365,326224661,458078951,308894438,93452636,958061434, \n459918040,329922434,609335926,309443872,460180184,342775520,460180184,460180184, \n443893528,296442635,591739108,441572053,457595678,609306414,542509349,1026857194, \n288008530,543758677,728352956,290009187,71912225,439466720,460179672,460180184, \n460180184,460380098,575819116,459916571,441830613,476761317,466639651,234072410, \n268445341,575494501,460181299,474858578,458344681,460180184,460180184,460180184, \n460180184,460674896,443403043,594889499,38619349,456276198,592295718,997276389, \n158194909,594396515,458378019,459884122,594659617,460176160,460180184,460180184, \n460180184,460179672,460473938,208521947,609343708,443669212,743816412,877512931, \n310752483,594393947,743820506,326223586,460442337,460176160,460180184,460180184, \n460180184,460180184,476405001,324094747,456022683,611175130,206690523,592337251, \n712104739,745922266,592268002,458344161,460180256,460442392,460180184,460180184, \n460180184,460180184,443894040,592599265,592268057,323865313,292149473,728619225, \n443402529,323574489,323868896,460179680,460180184,460180184,460180184,460180184, \n460180184,460180184,460180184,460442392,460441880,342739160,307088096,460180192, \n460180184,460180184,460179672,460180184,460180184,460180184,460180184,460180184);\nfloat mn[10]=float[](0.,-.827,-.399,-.278,-.652,-.334,-.154,-.342,-.16,-.123);\nfloat mx[10]=float[](3.984,.859,.414,.166,.639,.451,.165,.532,.213,.171);\n#define D(i) (float((k>>(i*3))%8)*(mx[i]-mn[i])/7.+mn[i])\nvec4 loadImage(vec2 p){\n  p=floor(p);\n  vec2 pk=(mod(p,vec2(8))+vec2(.5))*3.14159/8.;\n  ivec2 p8=ivec2(floor(p/8.));\n  int k=ken[p8.y*16+p8.x];\n  if(k==460180184)return vec4(0);\n  vec2 cs=cos(pk);\n  float c=D(0)*.25+D(1)*.5*cs.x+D(2)*.5*cos(2.*pk.x)+D(3)*.5*cos(3.*pk.x)\n   +D(4)*.5*cs.y+D(5)*cs.x*cs.y+D(6)*cos(2.*pk.x)*cs.y+D(7)*.5*cos(2.*pk.y)\n   +D(8)*cs.x*cos(2.*pk.y)+D(9)*.5*cos(3.*pk.y);\n  return vec4(c);\n}\nvec2 df[4]=vec2[](vec2(62,100),vec2(55,120),vec2(55,45),vec2(80,45));\nvec2 deform(vec2 U){\n  vec2 h=floor(U/siz);int i=int(floor(h.x+h.y*4.+(iTime+h.x*h.y)/8.));\n  vec2 p=df[i%4],v=vec2(3,6)*sin(max(0.,sin(iTime*.2+h.x+h.y*4.)*12.-6.));\n  if((i%8)>3)v=vec2(v.y,-v.x);\n  U=mod(U,siz);\n  float d=length(U-p);\n  return mix(U+v,U,clamp(d*.1,0.,1.));\n}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=loadImage(mod(deform(U),siz));\n  float f=sin(iTime);\n  f=sin(f+sin(f*.7+sin(f*.3+sin(f*.25+iTime)+iTime*.3)));\n  f=floor(f*13.3);\n  vec2 v=mod(vec2(f,f),floor(iResolution.xy/siz));\n  v-=floor(U/siz);\n  if(v.x==0. || v.y==0.)O.b=.0;if(v.x==0. && v.y==0.)O.g=.0;\n}", "image_inputs": [], "sound_code": "vec2 mainSound( int samp, float time )\n{\n  float f=sin(time);\n  f=sin(f+sin(f*.7+sin(f*.3+sin(f*.25+time)+time*.3)));\n  f=fract(f*13.3);\n  return vec2(f);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBfD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3602, 3602, 3625, 3625, 4017], [4088, 4088, 4108, 4108, 4365], [4366, 4366, 4404, 4404, 4671]], "test": "untested"}
{"id": "NtBBD1", "name": "N-Fold Burning Ship", "author": "Fraktoler", "description": "N-Fold Burning Ship is the Burning Ship fractal generalized the number of folds. The Perpendicular Burning Ship has 1 fold, normal Burning Ship has 2 folds and so on.", "tags": ["fractal", "mandelbrot", "iteration", "burningship"], "likes": 4, "viewed": 273, "published": 3, "date": "1652103946", "time_retrieved": "2024-07-30T16:49:36.298991", "image_code": "#define PI 3.1415926535897932\n#define TWO_PI 6.2831853071795865\n\nvec3 HSLtoRGB(vec3 hsl) {\n    float chroma = hsl.y * (1.0 - abs(2.0 * hsl.z - 1.0));\n    float h_prime = hsl.x / 60.0;\n    float x = chroma * (1.0 - abs(mod(h_prime, 2.0) - 1.0));\n    vec3 rgb;\n    if (0.0 <= h_prime && h_prime < 1.0) {\n        rgb = vec3(chroma, x, 0.0);\n    } else if (1.0 <= h_prime && h_prime < 2.0) {\n        rgb = vec3(x, chroma, 0.0);\n    } else if (2.0 <= h_prime && h_prime < 3.0) {\n        rgb = vec3(0.0, chroma, x);\n    } else if (3.0 <= h_prime && h_prime < 4.0) {\n        rgb = vec3(0.0, x, chroma);\n    } else if (4.0 <= h_prime && h_prime < 5.0) {\n        rgb = vec3(x, 0.0, chroma);\n    } else {\n        rgb = vec3(chroma, 0.0, x);\n    }\n    float m = hsl.z - 0.5 * chroma;\n    return rgb + m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float zoom = 3.0;\n    vec2 center = vec2(0.0);\n    vec2 c = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.x * zoom + center;\n    vec2 z = c;\n    float folds = iTime * 0.2 + 1.0;\n    float r = dot(z, z);\n    float theta;\n    float iter = 0.0;\n    const float max_iter = 256.0;\n    while (iter < max_iter) {\n        if (r > 4.0) {\n            break;\n        }\n        //Convert to polar form to minimize the usage of cos(), sin(),...\n        //Multiply and divide by the number of folds to get Burning Ship folds.\n        theta = atan(z.y, z.x) * folds; \n        //Calculate arg = atan(tan(arg)) to get arg in range (-pi, pi].\n        //Trick: atan(tan(x)) = mod(x-pi/2,pi)-pi/2 when x not equal to pi/2+pi*n\n        //Taking the abs of the argument is the same as taking the abs of imaginary component.\n        theta = abs(mod(theta - PI, TWO_PI) - PI) / folds;\n        theta += theta;\n        z = r * vec2(cos(theta), sin(theta)) + c;\n        r = dot(z, z);\n        iter += 1.0;\n    }\n\n    if (iter >= max_iter) {\n        fragColor = vec4(vec3(0.0), 1.0);\n    } else {\n        vec3 col = HSLtoRGB(vec3(mod(iter * 4.0, 360.0), 1.0, 0.5));\n        fragColor = vec4(col, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBBD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 90, 90, 794], [796, 796, 853, 853, 2045]], "test": "untested"}
{"id": "fl2Bzm", "name": "infinite zoom in rolling squares", "author": "FabriceNeyret2", "description": "2D version of reference: https://www.facebook.com/gianni.sarcone/videos/799221661057267/\n\ntoo bad we have to compute twice the same thing ( direct and reverse ) to draw vs get the camera target the center.\nWIP: try to zoom 4x faster", "tags": ["2d", "short", "reproduction"], "likes": 27, "viewed": 447, "published": 3, "date": "1652086123", "time_retrieved": "2024-07-30T16:49:37.096857", "image_code": "#define rot(a) mat2(cos(a+vec4(0,pi/2.,-pi/2.,0)))\n\nvoid mainImage( out vec4 O, vec2 u )\n{ \n    float d = 9., r = 2./5., Z = 4.*(2.-.8*r),                // r: margin Z: fractal scale\n         pi = 3.1415927, l=1., N = 8.,                        // N : fractal depth\n          z = 1., a = pow(3.,z)-1.,                           // z = speed of zoom\n          T = fract(iTime/30./z/z), t = 2.*pi*log(1.+a*T)/log(1.+a);// [0,2pi] with speed slowing as we zoom, so as to loop\n    vec2  R = iResolution.xy, D,\n          U = ( 2.*u - R ) / R.y / Z, A;\n // if (u.x<10.) { O = vec4(u.y/R.y < t/(2.*pi),0,0,0); return; }   // test cycle\n    \n    // --- follow target location ( to offset camera there )\n    vec2 P = vec2(0),L, D0 = vec2(1,0); D=D0;\n    for(float i=0.; i<N; i++) {\n        D  = D0 *=  rot(-t);                                  // rotate    \n        if (sin(t)<0.) D=-D;                                  // frame change after each corner\n        if (cos(t)*sin(t)<0.) D = vec2(-D.y,D.x); \n        P -= (1.-r)*vec2(-D.y,D.x)/l;                         // offset\n        t *= 3.;   l *= Z;                                    // zoom\n        P += 2.*floor( mod(t*2./pi,3.) - 1. ) *D/l;           // cyclod-translate cube\n        L = 1.41* cos( mod(t, pi/2.) + pi/4. + vec2(0,pi/2.) )/l;\n        P -= L.x*D +L.y*vec2(-D.y,D.x);\n     }\n    t /= pow(3.,N);                                           // restore t\n    \n    // --- zoom and center on target\n // U *= pow(Z,-z*T);\n    U *= pow(Z,-z*t/(2.*pi));\n    U += P;\n\n    // --- implicit draw of squares\n    for(float i=0.; i<N; i++) {\n        U *= rot(t);                                          // rotate\n        A = abs(U); d = min(d, abs( max(A.x,A.y) -1.+r/2. )); // draw square\n                                                              // --- iterate:\n        D = vec2(1,0); a=0.;                                  // frame change after each corner\n        if (sin(t)<0.) D=-D, a-=2.;\n        if (cos(t)*sin(t)<0.) D = vec2(-D.y,D.x), a--;\n        \n        U += (1.-r)*vec2(-D.y,D.x), U *= Z;                   // offset & zoom\n        t *= 3.;                                              // smaller is faster\n        U -= 2.*floor( mod(t*2./pi,3.) - 1. ) *D;             // cyclod-translate cube\n        U += 1.41* cos( mod(t, pi/2.) + pi/4. + vec2(0,pi/2.) +pi/2.*a );\n    }\n    \n   O = vec4( smoothstep( .8,-.8, (d-r/2.)/fwidth(d) )); // draw\n   \n //O +=  smoothstep( .8,-.8, R.y*length( (2.*u-R)/R.y -P) - 6.)*vec4(1,-1,-1,0);\n //O +=  smoothstep( .8,-.8, R.y*length( 2.*u - R ) / R.y - 6.)*vec4(1,-1,-1,0);\n}\n\n\n\n\n\n\n\n/** // --- naive version with 1/4 turn modulo \n\n#define rot(a) mat2(cos(a+vec4(0,1.57,-1.57,0)))\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( 2.*u - R ) / R.y, A;\n    float d = 9., r = 2./5.,  t = iTime/3.;  \n    \n    for(int i=0; i<3; i++) {\n        t = mod(t,1.57);\n        U *= rot(t);                                     // rotate\n        A = abs(U); d = min(d, abs( max(A.x,A.y) -1.+r/2. )); // draw square\n\n        U.y += 1.-r, U*= 4.*(2.-.8*r);                   // iterate: offset & zoom\n        t *= 3.;\n        U.x -= 2.*floor(t/1.57)-2.;                      // displace cube\n        U += 1.41* cos( mod(t, 1.57) + .7854 + vec2(0,1.57) );\n    }\n    \n    O = vec4( smoothstep( .8,-.8, (d-r/2.)/fwidth(d) )); // draw\n}\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2Bzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[52, 52, 90, 90, 2581]], "test": "untested"}
{"id": "Nt2BDz", "name": "prayer plant leaf", "author": "ufffd", "description": "had this one in mind for a long time\nbased on: https://i.pinimg.com/originals/0c/36/62/0c3662f99edb3113d88e9a5302656a77.jpg", "tags": ["leaf", "photorecreation"], "likes": 6, "viewed": 262, "published": 3, "date": "1652055339", "time_retrieved": "2024-07-30T16:49:37.890735", "image_code": "#define DEBUG_LEAFMASK false\n#define DEBUG_MAINVEIN false\n#define DEBUG_VEINS false\n#define DEBUG_DARKLEAF false\n#define DEBUG_LIGHTLEAF false\n#define DEBUG_PALETTE false\n\n#define SS(a,b,c) smoothstep(a-b,a+b,c)\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nvec3 rgb2hsv(vec3 c){\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    st += iTime*0.5;\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid clamp01(inout float a){\n    a = clamp(a,0.,1.);\n}\n\nvec2 toPolar(vec2 decart) {\n    float alpha = atan(decart.x, decart.y);\n    float R = length(decart);\n    return vec2(alpha, R);\n}\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 blend(vec3 a, vec3 b, float x) {\n    vec3 colmix = mix(a,b,x); // basic mix\n    a = rgb2hsv(a);\n    b = rgb2hsv(b);\n    vec3 hsvmix = mix(a,b,x);\n    hsvmix.r = rgb2hsv(colmix).r;\n    vec3 col = hsv2rgb(hsvmix);\n    col = colmix;\n    return col;\n}\n\nconst vec3 leaf1 = vec3(21, 41, 15)/255.; // #12260b rgb(18, 38, 11) // darkleaf\nconst vec3 leaf2 = vec3(37, 75, 33)/255.; // #456d4a rgb(69, 109, 74) // leaf\nconst vec3 leaf3 = vec3(91, 169, 45)/255.; // #7dc44d rgb(125, 196, 77) // lightlead\nconst vec3 vein1 = vec3(210, 95, 120)/255.; // #ea7c97 rgb(234, 124, 151) // veins\n\nvec4 drawLeaf(in vec2 uv, in float seed, in bool darkleafmode, in float lightleafsize, in float age) {\n    \n    float veinfreq = age;\n\n    vec3 col = vec3(0.0);\n    vec2 uvc = (uv*2. - 1.)*iResolution.xy/iResolution.y;\n    uvc += noise(uvc*2.+seed)*0.07;\n    uvc += noise(uvc*20.+seed)*0.007;\n    \n    uv -= .5;\n    uv *= rot(3.*uv.y*uv.x*length(uvc-vec2(0.,0.2)));\n    uv.y -= uv.x*uv.x;\n    uv += .5;\n    \n    vec2 px = 1./iResolution.xy;\n    \n    px = vec2(0.00125,0.002);\n    \n    /*\n    uv.x -= 0.5;\n    uv.y -= 0.2;\n    uv = toPolar(uv);\n    uv.x += 0.5;\n    */\n    \n    float leafshape = length( uvc * vec2(1.+uv.y*0.2,0.9));\n    float leafmask = 1.-SS(0.85,px.y*2.,leafshape);\n    float leafmasksoft = 1.-SS(0.75,px.y*40.,leafshape);\n    \n    float mainvein = cubicPulse(0.5,px.x*6.,uv.x)*2.; // horizontal center\n    mainvein *= uv.y*2.;\n    mainvein -= 3.*SS(0.8,0.2,uv.y);\n    clamp01(mainvein);\n    mainvein = SS(0.5,0.1,mainvein);\n    \n    vec2 vuv = uv; // veins uv\n    vuv.y -= cubicPulse(0.5,0.01,vuv.x)*0.01;\n    vuv.y += 2.*(1.-vuv.y)*abs(vuv.x-0.5);\n    vuv.y += abs(vuv.x-0.5);\n    vuv.y += noise(vuv.yy*5.+seed)*0.06; // slightly random vertical spacing\n\n    if (vuv.x>0.5) vuv.y += 1./veinfreq;\n    if (fract(seed*99999.99)<0.6 && vuv.x>0.5) vuv.y -= 4./veinfreq;\n\n    // veins\n    float veins = 0.; // horizontal center\n    veins += cubicPulse(0.,px.y*140.,sin(vuv.y*veinfreq*0.5));\n    veins *= leafmasksoft;\n    clamp01(veins);\n    // veins2\n    float veins2 = 0.; // horizontal center\n    veins2 += cubicPulse(0.,px.y*200.,sin(vuv.y*veinfreq));\n    veins2 *= cubicPulse(0.5,px.x*60.,uv.x);\n    clamp01(veins2);\n    \n    veins2 *= 1.-uv.y*uv.y;\n    veins2 = SS(0.5,0.3,veins2);\n    veins2 *= leafmasksoft;\n    \n    // lightveins\n    float lightveins = 0.; // horizontal center\n    lightveins += cubicPulse(0.,px.y*180.,sin(vuv.y*veinfreq*2.));\n    // lightleaf += lightveins;\n    clamp01(veins);\n    lightveins *= leafmasksoft;\n    \n    veins = max(veins,veins2);\n    veins = max(veins,mainvein);\n    \n    // light leaf\n    vec2 lluv = mix(vuv,uv,0.5);\n    lluv.x *= 1.+sin(vuv.y*veinfreq*0.5)*0.02*(1.-abs(uv.y-0.5)*2.);\n    float lightleaf = cubicPulse(0.5,px.x*40.*lightleafsize*5.,lluv.x)*3.; // horizontal center\n    lightleaf *= lluv.y; // trim bot\n    lightleaf *= 1.2-lluv.y; // trim top\n    lightleaf *= 4.; // sharpen\n    lightleaf *= 0.9+noise(lluv*5.+seed)*2.; // wiggle\n    lightleaf *= 0.9+noise(lluv*200.+seed)*.5; // high freq wiggle\n    lightleaf *= 1.7-sin(lluv.y*60.);// swoops\n    lightleaf += cubicPulse(0.5,.025,lluv.x)*3.; // make sure middle exists at least a bit\n    clamp01(lightleaf);\n    lightleaf = SS(0.85,0.2,lightleaf);\n    // lightleaf -= 1.-SS(0.2,0.1,uv.y);\n    \n    float darkleaf = cubicPulse(0.5,px.x*120.,uv.x)*3.; // horizontal center\n    darkleaf *= uv.y; // trim bot\n    darkleaf *= 1.2-uv.y; // trim top\n    darkleaf *= 2.5; // sharpen\n    darkleaf *= 0.9+noise(uv*7.+seed); // wiggle\n    darkleaf *= 0.9+noise(uv*12.+seed)*.5; // high freq wiggle\n    clamp01(darkleaf);\n    darkleaf = SS(0.4,0.3-0.31*noise(uv*3.+seed),darkleaf);\n    \n    col = leaf2; // base col\n    if (darkleafmode) col = leaf1;\n    col = blend(col,leaf1,darkleaf*leafmasksoft*leafmasksoft); // darkleaf\n    col = blend(col,leaf3,lightleaf*(1.-SS(0.77,0.15,length(uvc-vec2(0.,0.04))))); // lightleaf\n    col *= 1.+lightveins*leaf2; // lightveins\n    col = blend(col,vein1,veins); // veins\n    \n    // hsv adjustments\n    float colnoise = noise(uvc*1.+seed) * noise(uvc*3.+seed);\n    vec3 hsv = rgb2hsv(col);\n    // hsv.r += sin(iTime*col.r+colnoise*10.)*0.05; // shift colors over time to show variations\n    hsv.g -= 0.3*lightveins*lightleaf*(1.-veins); // desaturate light veins\n    hsv.b -= 0.1*lightveins*lightleaf*(1.-veins); // darken light veins\n    hsv.b -= 0.03*lightveins*darkleaf*(1.-veins); // darken light veins\n    hsv.g += sin(iTime+hsv.r+colnoise)*0.1 + 0.66 - uv.y; // vertical sat shift\n    hsv.b *= colnoise*0.2+0.9;\n    col = hsv2rgb(hsv);\n    \n    // mask\n    col *= leafmask;\n    \n    // DA BUGS\n    if (DEBUG_LEAFMASK) col=vec3(leafmask); \n    \n    if (DEBUG_MAINVEIN) col=vec3(mainvein); \n    if (DEBUG_VEINS) col=vec3(veins); \n    if (DEBUG_DARKLEAF) col=vec3(darkleaf); \n    if (DEBUG_LIGHTLEAF) col=vec3(lightleaf); \n    if (DEBUG_PALETTE) {\n        col=vein1;\n        if (uv.x<0.75) col=leaf3;\n        if (uv.x<0.5) col=leaf2;\n        if (uv.x<0.25) col=leaf1;\n    }\n    float alpha = SS(0.5,0.1,leafmask);\n    return vec4(col,alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*1.1;\n    vec2 uvc = ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    \n    // leaf4 botleft\n    float leaf4age = 40.+sin(iTime);\n    vec2 leaf4pos = uv;\n    leaf4pos -= 0.5;\n    leaf4pos *= 2.;\n    leaf4pos *= iResolution.xy/iResolution.y;\n    leaf4pos *= rot(-.5);\n    leaf4pos /= iResolution.xy/iResolution.y;\n    leaf4pos += 0.5;\n    leaf4pos.x += 0.2;\n    leaf4pos.y += 0.8;\n    leaf4pos.x += sin(leaf4pos.y*2.+.1)*.1;\n    leaf4pos.x *= 1.2;\n    vec4 leaf4 = drawLeaf(leaf4pos, 3., false, 0.25, leaf4age);\n    col = leaf4.rgb;\n    // leaf3 topleft\n    vec2 leaf3pos = uv*1.3;\n    leaf3pos -= 0.5;\n    leaf3pos *= iResolution.xy/iResolution.y;\n    leaf3pos *= rot(-2.);\n    leaf3pos /= iResolution.xy/iResolution.y;\n    leaf3pos += 0.5;\n    leaf3pos.x += 0.01;\n    leaf3pos.y += 0.6;\n    leaf3pos.x += sin(leaf3pos.y*2.+.1)*.1;\n    leaf3pos.x *= 1.2;\n    vec4 leaf3 = drawLeaf(leaf3pos, -20., true, 0.15, 40.);\n    col += leaf3.rgb;\n    // leaf2 right\n    vec2 leaf2pos = uv;\n    leaf2pos -= 0.5;\n    leaf2pos *= iResolution.xy/iResolution.y;\n    leaf2pos *= rot(0.6);\n    leaf2pos /= iResolution.xy/iResolution.y;\n    leaf2pos += 0.5;\n    leaf2pos.x -= 0.25;\n    leaf2pos.y += 0.15;\n    leaf2pos.x += sin(leaf2pos.y*2.+.1)*-.1;\n    leaf2pos.x *= 1.2;\n    vec4 leaf2 = drawLeaf(leaf2pos, 80., true, 0.0, 50.);\n    col += leaf2.rgb;\n    // leaf1 front\n    vec4 leaf1 = drawLeaf(uv, 20., false, 0.2, 53.);\n    col = mix(col,leaf1.rgb,leaf1.a);\n    \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2BDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[257, 316, 337, 337, 506], [507, 507, 528, 528, 859], [862, 862, 884, 884, 1023], [1025, 1110, 1132, 1132, 1557], [1559, 1559, 1587, 1587, 1613], [1615, 1615, 1642, 1642, 1745], [1747, 1747, 1794, 1794, 1888], [1890, 1890, 1927, 1927, 2142], [2472, 2472, 2574, 2574, 6975], [6977, 6977, 7034, 7034, 8636]], "test": "untested"}
{"id": "fdBXzy", "name": "2D varying reaction-diffusion", "author": "NBickford", "description": "Writing a Gray-Scott reaction-diffusion shader, since I've never written one before! Reaction-diffusion parameters vary over the screen and are scaled to crop out most of the uninteresting regions. Click and drag to scroll through parameters.", "tags": ["reactiondiffusion"], "likes": 13, "viewed": 470, "published": 3, "date": "1652038405", "time_retrieved": "2024-07-30T16:49:38.761407", "image_code": "#define MAXZ (100.0/iResolution.x)\n\nfloat heightAtLod(vec2 uv, float lod){\n    return MAXZ*textureLod(iChannel0, uv, lod).g;\n}\n\n#define NSTEPS 32\nfloat visibleAmt(vec3 o, vec3 d){\n  // Determine the t at which o + d t reaches the z=MAXZ plane\n  float tMax = (MAXZ-o.z)/d.z;\n  // Difference in t between sample points - note that we sample at halves:\n  float dt = tMax/float(NSTEPS);\n  \n  float amt = 1.0;\n  for(int i = 0; i < NSTEPS; i++){\n    float t = (float(i) + 0.5)*dt;\n    vec3 p = o + d*t;\n    float height = heightAtLod(p.xy, 4.0+log2(t));\n    \n    float insideness = height - p.z; // >spreadZ -> 0, -spreadZ -> 1\n    float spreadZ = 0.2 * t;\n    amt = min(amt, 0.5 - 0.5*insideness/spreadZ);\n  }\n  \n  return max(0.0, amt);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Get the height at the pixel\n    float z = heightAtLod(uv, 0.0);\n    vec3 origin = vec3(uv, z);\n    \n    vec3 visibility = vec3(0.0);\n    float aspect = iResolution.x/iResolution.y;\n    vec3 L0 = normalize(vec3(normalize(vec2(0.866, 0.5*aspect)), 1.0));\n    vec3 L1 = normalize(vec3(normalize(vec2(-0.866, 0.5*aspect)), 1.0));\n    vec3 L2 = normalize(vec3(0.0, -1.0, 1.0));\n    visibility.r = visibleAmt(origin, L0);\n    visibility.g = visibleAmt(origin, L1);\n    visibility.b = visibleAmt(origin, L2);\n    \n    // Estimate local curvature for an AO look\n    float gaussianZEst = 0.25*z + 0.25*heightAtLod(uv, 2.0) + 0.2*heightAtLod(uv, 4.0) + 0.15*heightAtLod(uv, 6.0) + 0.1*heightAtLod(uv, 8.0);\n    float aoEst = clamp(1.0 + 3.0*(z - gaussianZEst)/MAXZ, 0.0, 1.0);\n    \n    // Estimate normal for some specularity\n    vec3 drez = vec3(1.0/iResolution.xy, 0.0);\n    vec3 n = vec3(-(heightAtLod(uv+drez.xz, 0.0)-z)*iResolution.x, -(heightAtLod(uv+drez.zy, 0.0)-z)*iResolution.y, 1.0);\n    n = normalize(n);\n    \n    vec3 diffuse = max(vec3(dot(n, L0), dot(n, L1), dot(n, L2)), vec3(0.0)) * aoEst * visibility;\n    \n    vec3 halfVec = normalize(n+vec3(0.,0.,1.));\n    vec3 spec = max(vec3(dot(halfVec, L0), dot(halfVec, L1), dot(halfVec, L2)), vec3(0.0));\n    spec = 17.0 * pow(spec, vec3(128.0)) * visibility;\n    \n    vec3 col = mix(diffuse, spec, 0.05);\n    \n    // Output to screen\n    fragColor = vec4(pow(col * aoEst, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float stepAndOutputRNGFloat(inout uint rngState)\n{\n  // Condensed version of pcg_output_rxs_m_xs_32_32, with simple conversion to floating-point [0,1].\n  rngState  = rngState * 747796405u + 1u;\n  uint word = ((rngState >> ((rngState >> 28) + 4u)) ^ rngState) * 277803737u;\n  word      = (word >> 22) ^ word;\n  return float(word) / 4294967295.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    if(iFrame == 0){\n        // Reinitialize\n        uint rngState = (uint(iFrame) << 20) + (uint(fragCoord.x/16.) << 10) + uint(fragCoord.y/16.);\n        fragColor = vec4(stepAndOutputRNGFloat(rngState), uv.x*stepAndOutputRNGFloat(rngState), 0.0f, 0.0f);\n        return;\n    }\n    \n    ivec2 iFC = ivec2(fragCoord);\n    vec2 ab = texelFetch(iChannel0, iFC, 0).rg;\n    float weights[] = float[9](0.05, 0.2, 0.05,\n                        0.2, -1.0, 0.2,\n                        0.05, 0.2, 0.05);\n    vec2 laplacian = ab * weights[4];\n    for(int y = -1; y <= 1; y++){\n        for(int x = -1; x <= 1; x++){\n            if(x == 0 && y == 0) continue;\n            laplacian += weights[3*y+x+4] * texelFetch(iChannel0, iFC + ivec2(x, y), 0).rg;\n        }\n    }\n    \n    if(iMouse.z > 0.0f){\n        uv = iMouse.xy / iResolution.xy;\n    }\n    \n    float high = mix(0.4+0.3*(1.0-pow(1.0-uv.x,3.0)), 0.9-(0.9-0.57)*uv.x, 1.0-pow(1.0-uv.x, 2.0));\n    float low = mix(0.2*(1.0-pow(1.0-uv.x,3.0)), 0.74-(0.74-0.54)*uv.x, 1.0-pow(1.0-uv.x, 3.8));\n    float f = 0.1 * uv.x;\n    float k = 0.1 * mix(low, high, uv.y);\n    \n    float dt = 0.9;\n    \n    // Update A and B\n    ab = ab + dt*(\n        vec2(1.0, 0.5)*laplacian\n        + vec2(-1.0, 1.0) * ab.x * ab.y * ab.y\n        + vec2(f*(1.0-ab.x), -(k+f)*ab.y));\n        \n    ab = clamp(ab, vec2(0.0), vec2(1.0));\n    \n    fragColor = vec4(ab, 0.0, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fdBXzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 74, 74, 126], [735, 735, 792, 842, 2341]], "test": "untested"}
{"id": "Nl2BWR", "name": "circle_spots", "author": "beetom", "description": "sdf study", "tags": ["sdf2d"], "likes": 0, "viewed": 176, "published": 3, "date": "1652033440", "time_retrieved": "2024-07-30T16:49:39.645044", "image_code": "#define RADIUS 0.025\n#define SPACING 0.001\n\nfloat circlei(vec2 po, vec2 pi, float r)\n{\n    return max(r - length(pi - po), .0);\n}\n\nfloat map(vec2 po, vec2 pm)\n{\n    float d = .0;\n    d += circlei(po, pm, RADIUS);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 sp = vec2((abs(mod(p.x, RADIUS * 2.0 + SPACING * 2.0)) - RADIUS - SPACING), p.y);\n    vec2 uv = fragCoord/iResolution.xy;\n    float d = map(sp, vec2(0.0,0.0)) / 0.05;\n    //d = smoothstep(0.0, 0.05, d);\n    vec3 col = vec3(.0);\n    \n    vec2 sp2 = vec2((abs(mod(p.x, 0.25)) - 0.125) / 0.25, p.y / 0.2);\n    \n    \n    col += vec3(d, d, d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nl2BWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 86, 86, 129], [131, 131, 160, 160, 228], [230, 230, 287, 287, 762]], "test": "untested"}
{"id": "slBfWR", "name": "Simple light test", "author": "SnoopethDuckDuck", "description": "Inspired by this post: https://www.shadertoy.com/view/stBfz1\n(copied and edited the lighting bit)", "tags": ["e"], "likes": 0, "viewed": 228, "published": 3, "date": "1652013605", "time_retrieved": "2024-07-30T16:49:40.514719", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nvec3 getLp(vec3 p) {\n    float mx = 0.5 + 0.5 * ths(5., 0.1 * p.y - 0.45 * iTime);\n    return mix(1.42, 1.2, mx) * vec3(thc(4.,iTime), \n                                     cos(4. * mx * log(1. + abs(p.y)) + 0.4 * iTime), \n                                     ths(4.,iTime));\n}\n\nfloat GetDist(vec3 p) {\n    vec3 lp = getLp(p);\n    float d2 =   length(p - lp) - 0.1;\n    d2 = min(d2, length(p + lp) - 0.1);\n    \n    p.xy *= Rot(0.2 * iTime);\n    p.yz *= Rot(0.3 * iTime);\n    float d = sdBox(p, vec3(0.65)) - 0.25;\n       \n    return min(d, 0.3 * d2);\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n\n        vec3 lp = getLp(p);\n        vec3 nlp = normalize(lp);\n        \n        float mx = 0.5 + 0.5 * ths(5., 0.1 * p.y - 0.45 * iTime);\n        float sc = mix(0.2, -0.5, mx);\n\n        vec3 dif = vec3(dot(n, normalize(lp - sc * nlp - p)),\n                        dot(n, normalize(lp            - p)),\n                        dot(n, normalize(lp + sc * nlp - p)));\n        \n        vec3 dif2 = vec3(dot(n, normalize(-lp - sc * nlp - p)),\n                         dot(n, normalize(-lp            - p)),\n                         dot(n, normalize(-lp + sc * nlp - p)));\n                         \n        dif = 0.5 + 0.5 * max(dif, dif2);\n        //dif *= 6. / (dot(lp-p,lp-p)+0.);\n        //dif *= 10. * exp(-1.4 * length(lp-p));\n        \n        //dif = clamp(dif, 0., 1.);\n        dif = pow(dif, vec3(3.));\n        \n        if (length(lp-p) < 0.11 || length(lp+p) < 0.11)\n            dif = vec3(1); vec3(1.-mx);\n        \n        dif *= exp(-1.5 * dIn);\n        col = vec3(dif);\n\n    }\n    col += 0.015;\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slBfWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 716], [718, 718, 738, 738, 995], [997, 997, 1020, 1020, 1270], [1272, 1272, 1315, 1315, 1622], [1624, 1624, 1648, 1648, 1838], [1840, 1840, 1890, 1890, 2081], [2083, 2083, 2140, 2140, 3704]], "test": "untested"}
{"id": "NlSfDz", "name": "Kurzgesagt birb", "author": "cmzw", "description": "based on the birds as found in [url]https://kurzgesagt.org/patreon-2/[/url]", "tags": ["2d", "kurzgesagt"], "likes": 17, "viewed": 477, "published": 3, "date": "1652006657", "time_retrieved": "2024-07-30T16:49:41.424287", "image_code": "float cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat sdCircle( vec2 p, float r ) {return length(p) - r;}\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdUnevenCapsule( in vec2 p, in vec2 pa, in vec2 pb, in float ra, in float rb )\n{\n    p  -= pa;\n    pb -= pa;\n    float h = dot(pb,pb);\n    vec2  q = vec2( dot(p,vec2(pb.y,-pb.x)), dot(p,pb) )/h;\n    \n    q.x = abs(q.x);\n    \n    float b = ra-rb;\n    vec2  c = vec2(sqrt(h-b*b),b);\n    \n    float k = cro(c,q);\n    float m = dot(c,q);\n    float n = dot(q,q);\n    \n         if( k < 0.0 ) return sqrt(h*(n            )) - ra;\n    else if( k > c.x ) return sqrt(h*(n+1.0-2.0*q.y)) - rb;\n                       return m                       - ra;\n}\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\nfloat st(in float d) { return smoothstep(0.006,0.,d); }\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 p = (2.*I - iResolution.xy) / iResolution.y;\n    vec3 col; vec2 z; p *= 1.2; p -= vec2(0,.06);\n    col = smoothstep(1.5,0.,sdCircle(p,.9))*vec3(.01,.1,0.3);\n    \n    z = p+vec2(-.2,.15);\n    col = mix(col,vec3(2.,.4,.0),st(sdSegment(z,vec2(-.09,-.8),vec2(0.09))-.04));\n    col = mix(col,vec3(2.,.4,.0),st(sdSegment(z,vec2(-.2,-.8),vec2(0.1,-.8))-.04));\n\n    z = p+vec2(.12,.15);\n    col = mix(col,vec3(2.,.8,.0),st(sdSegment(z,vec2(-.05,-.8),vec2(0))-.04));\n    col = mix(col,vec3(2.,.8,.0),st(sdSegment(z,vec2(-.2,-.8),vec2(0.1,-.8))-.04));\n    \n    z = p - vec2(.101,-.28);\n    col = mix(col,vec3(.1,.8,.0),st(sdCircle(z+vec2(.25,.3),.15)));\n    col = mix(col,vec3(.05,.5,.0),st(sdCircle(z+vec2(-.05,.31),.15)));\n    col = mix(col,vec3(.05,.5,.0),st(sdUnevenCapsule(z,vec2(-.89,.34),vec2(-.7,.15),.0,.1)-.06));\n    col = mix(col,vec3(.1,.8,.0),st(min(sdSegment(z,vec2(0),vec2(0.,.7))-.4,sdSegment(z,vec2(0),vec2(-.5,.0))-.4)));\n    \n    z = p - vec2(-.146,-.24);\n    col = mix(col,vec3(.1,.8,.0),st(sdUnevenCapsule(z,vec2(-.8,.19),vec2(-.5,.07),.0,.1)-.06));\n   \n    z = p - vec2(.35,.45);\n    col = mix(col,vec3(2.,.5,.0),st(sdSegment(z,vec2(.3,.067),vec2(0))-.08));\n    \n    z = p - vec2(0.04,.45);\n    col = mix(col,vec3(3.),st(max(sdCircle(z,.13),.02-sdCircle(z+vec2(0,.25),.4)-.2)));\n    \n    z += vec2(0.05,-.04);\n    col = mix(col,vec3(.05,.5,.0),st(sdUnevenCapsule(z,vec2(-.05,-.85),vec2(-.55,-1.2),.2,.0)-.07));    \n\n    O = vec4(aces_tonemap(col),0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSfDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 62], [64, 64, 116, 116, 239], [241, 241, 276, 276, 298], [300, 300, 337, 337, 417], [419, 419, 505, 505, 969], [971, 971, 1001, 1001, 1448], [1450, 1450, 1472, 1472, 1505], [1507, 1507, 1548, 1548, 3022]], "test": "untested"}
{"id": "NtBfWz", "name": "Ray marching hype", "author": "tovaris", "description": "I am learning how to do a ray marching here", "tags": ["raymarching"], "likes": 0, "viewed": 177, "published": 3, "date": "1651994088", "time_retrieved": "2024-07-30T16:49:42.244095", "image_code": "\nstruct Sphere {\n   vec3 center;\n   float radius;\n   vec3 color;\n};\n\n\nstruct LineSegment {\n    vec3 pos;\n    vec3 dir;\n    float thickness;\n};\n\nconst vec3 noHit = vec3(-1.0, -1.0, -1.0);\n\nfloat dToSphere(in vec3 p, Sphere s) {\n   return length(p - s.center) - s.radius;\n}\n\nfloat dToLineSegment(in vec3 p, LineSegment l) {\n   vec3 d = l.dir;\n   vec3 o = l.pos;\n   float w = l.thickness;\n   float t = (p.x * d.x - o.x * d.x +\n              p.y * d.y - o.y * d.y +\n              p.z * d.z - o.z * d.z) / (d.x * d.x + d.y * d.y + d.z * d.z);\n  \n   float dst = 10000.f;\n  \n   if (t > 1.0) {\n       dst = length(p - (o + d)) - w * (1.0 / t);\n   } else if (t < 0.0) {\n       dst = length(p - o) - w;\n   }\n   else {\n       dst = length(p - (o + d * t)) - w * (-1.0 / t);\n   }\n   \n   \n   return dst;\n}\n\nfloat dToScene(in vec3 p) {\n    \n    float d;\n    \n    float displacement = sin(3.0 * p.x) * 0.25 + sin(4.0 * p.y) * 0.4;\n    d = dToSphere(p, Sphere(vec3(-2.5, -1.0, 0.0), 1.0, vec3(1.0))) + displacement;\n    \n    d = min(d, dToLineSegment(p, LineSegment(vec3(0.0, -3.0, 0.0), vec3(0.0, 2.0, 0.0), 0.5)));\n    \n    return d;\n\n}\n\nvec3 sceneNormal(in vec3 p) {\n    const vec3 small_step = vec3(0.001, 0.0, 0.0);\n\n    float gradient_x = dToScene(p + small_step.xyy) - dToScene(p - small_step.xyy);\n    float gradient_y = dToScene(p + small_step.yxy) - dToScene(p - small_step.yxy);\n    float gradient_z = dToScene(p + small_step.yyx) - dToScene(p - small_step.yyx);\n\n    vec3 normal = vec3(gradient_x, gradient_y, gradient_z);\n\n    return normalize(normal);\n}\n\nvec3 march_ray(in vec3 start, in vec3 dir) {\n   \n   const int MAX_STEPS = 64;\n   const float FAR_CLIP_PLANE = 1000.0;\n   const float MIN_DIST_TO_HIT = 0.0001;\n   vec3 light_position = vec3(2.0, -5.0, 3.0);\n   vec3 cToLight = normalize(light_position - start);\n   \n   dir = dir / length(dir);\n   float acc_distance = 0.0;\n   float d = FAR_CLIP_PLANE;\n   \n   float backColorValue = max(0.0, dot(dir, cToLight));\n   vec3 backColor = backColorValue * vec3(0.3568627450980392, 0.5372549019607843, 0.8313725490196079);\n   vec3 ray = noHit;\n   \n   for (int i = 0; i < MAX_STEPS; ++i) {\n       vec3 p = dir * acc_distance + start;\n       \n       float d = min(d, dToScene(p));\n       \n       if (d <= MIN_DIST_TO_HIT) {\n           \n           vec3 direction_to_light = normalize(p - light_position);\n           vec3 normal = sceneNormal(p);\n\n           float diffuse_intensity = max(0.0, dot(normal, direction_to_light));\n\n        \n           return vec3(1.0, 0.0, 1.0) * diffuse_intensity;\n       }\n       \n       acc_distance += d;\n       \n       if (acc_distance > FAR_CLIP_PLANE) {\n           break;\n       }\n   }\n   \n    \n   return backColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.x * 2.0 - 1.0;\n    \n    vec3 camera = vec3(0.0, 0.0, -5.0);\n    \n    vec3 direction = vec3(uv, 1.0);\n    vec3 ray = march_ray(camera, direction);\n  \n    fragColor = vec4(ray, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtBfWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 188, 226, 226, 271], [273, 273, 321, 321, 792], [794, 794, 821, 821, 1122], [1124, 1124, 1153, 1153, 1551], [1553, 1553, 1597, 1597, 2694], [2696, 2696, 2753, 2804, 3023]], "test": "untested"}
{"id": "flBBDR", "name": "bricks outside the coffee shop", "author": "ufffd", "description": "trying to emulate my view from the coffee shop. march 7 2022", "tags": ["photorecreation"], "likes": 1, "viewed": 138, "published": 3, "date": "1651980353", "time_retrieved": "2024-07-30T16:49:43.114767", "image_code": "#define PI 3.141592653589793\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n\nfloat clamp01(in float a){\n    return clamp(a,0.,1.);\n}\n\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nconst float angle1 = 1. / float(4) * PI * 2.;\nconst float angle2 = PI * 0.5 - angle1 / 2.;\n\n#define rot(a) mat2(cos(a+vec4(0,11,33,0)))\n\nfloat hexSDF(in vec2 position) {\n    position /= vec2(sqrt(3.0), 1.5); // magic numbers\n    position.y -= 0.5;\n    position.x -= fract(floor(position.y) * 0.5);\n    position = abs(fract(position) - 0.5);\n    return abs(1. - max(position.x * tan(angle2) * 1.15 + position.y, position.x)) * sqrt(3.) * 0.5; // magic numbers\n}\n\nfloat drawHex(in vec2 position, in float size) {\n    // position *= vec2(hexH,hexW)/hexH;\n    float sdf = hexSDF(position);\n    if (position.x < -0.5) sdf = 0.;\n    if (position.x > 0.5) sdf = 0.;\n    if (position.y < -0.5) sdf = 0.;\n    if (position.y > 0.5) sdf = 0.;\n    return smoothstep(size-0.002,size+0.002,sdf);\n}\n  \nfloat lineSDF( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat drawLine(in vec2 p, in vec2 a, in vec2 b, in float lt) {\n    return 1.-smoothstep(0.0,lt,lineSDF(p, a, b));\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat drawSq(in vec2 uv, in float size) {\n    vec2 px = 1./iResolution.xy;\n    float sq = 0.;\n    float sqsize = size;\n    float sqedge1 = 0.5 - sqsize;\n    float sqedge2 = 0.5 + sqsize;\n    sq += smoothstep(sqedge1,sqedge1+px.x,uv.x);\n    sq -= smoothstep(sqedge2,sqedge2+px.x,uv.x);\n    sq *= smoothstep(sqedge1,sqedge1+px.x,uv.y);\n    sq -= smoothstep(sqedge2,sqedge2+px.x,uv.y);\n    \n    sq = clamp(sq,0.,1.);\n    \n    return sq;\n}\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdOrientedBox( in vec2 p, in vec2 a, in vec2 b, float th )\n{\n    float l = length(b-a);\n    vec2  d = (b-a)/l;\n    vec2  q = (p-(a+b)*0.5);\n          q = mat2(d.x,-d.y,d.y,d.x)*q;\n          q = abs(q)-vec2(l,th)*0.5;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);    \n}\n\nvec3 brickworkPattern(in vec2 uv, in float scale) {\n    float linew = 0.02;\n\n    vec3 col = vec3(0.);\n    \n    col.b = drawSq(uv, 0.225);\n    col.g = drawSq(uv,0.225+linew) - col.r;\n    \n    float x = 0.;\n    vec2 xuv = abs(uv-.5)-0.225;\n    x += drawLine(xuv,vec2(0.),vec2(0.275),linew);\n    x += drawLine(xuv,vec2(0.,0.275),vec2(0.275,0.),linew);\n    col.g = max(col.g,x);\n    \n    col.g += drawLine(uv,vec2(0.275,0.),vec2(1.-0.275,0.),linew ); // bot\n    col.g += drawLine(uv,vec2(0.275,1.),vec2(1.-0.275,1.),linew); // top\n    col.g += drawLine(uv,vec2(0.,0.275),vec2(0.,1.-0.275),linew); // left\n    col.g += drawLine(uv,vec2(1.,0.275),vec2(1.,1.-0.275),linew); // right\n    \n    col.r = 1. - col.b - col.g;\n    col.g = 0.;\n    \n    \n    col += col.b;\n    col += col.r;\n    col *= 0.3;\n    \n    vec3 hsv = rgb2hsv(col);\n    hsv.g *= 1.-col.b;\n    hsv.g *= 0.8;\n    // hsv.b -= 0.1;\n    col = hsv2rgb(hsv);\n    \n    return col;\n}\n\nfloat map(in vec3 p) {\n    float d;\n    float plane = dot(p,vec3(0.,1.,0.));\n    d = plane;\n    //float sphere = length(p)-0.5;\n    //d = min(d,sphere);\n    return d;\n}\n\nvec3 getNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ) );\n}\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n// Gradient Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/XdXGW8\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ),\n                     dot( random2(i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ),\n                     dot( random2(i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.);\n    \n    /*\n    uv.x *= (2.+uv.y)*0.5;\n    uv.y = uv.y;\n   \n    vec2 tuv = fract(uv*4.);\n    \n    col = brickworkPattern(tuv,1.);\n    */ \n    \n    \n    vec3 ro = vec3(0.,3.,-3.);\n    vec3 rd = normalize(vec3(uv.x,uv.y,1.));\n    \n    rd.yz *= rot(-0.9);\n    \n    vec3 p;    \n    bool hit = false;\n    float d = 0.;\n    \n    for (int i=0; i<MAX_STEPS && !hit && d < MAX_DIST; i++) {\n        p = ro + rd * d;\n        float dd = map(p);\n        if (dd < 0.001) hit=true;\n        d += dd;\n    }\n    \n    vec3 n = getNormal(p);\n    \n    col = n; \n    \n    vec2 tuv = fract(p.xz*1.);\n    vec3 pat = brickworkPattern(tuv,1.);\n    col = pat;\n    \n    col *= 0.1+texture(iChannel1,rot(0.34)*p.xz+0.4).rgb; // organic texture\n    \n    if (pat.b > 0.5) col = (col+0.2) * 0.5;\n    \n    float noise1 = texture(iChannel0,rot(0.9)*p.xz+0.1).r;\n    float noise2 = texture(iChannel0,rot(2.)*p.xz*0.9+0.1).r;\n    float noise3 = texture(iChannel0,rot(4.)*p.xz*0.8+0.1).r;\n    noise1 = smoothstep(0.94,0.95,noise1);\n    noise2 = smoothstep(0.94,0.95,noise2);\n    noise3 = smoothstep(0.85,0.9,noise3);\n    col += col*noise1*2.; // pebbles\n    col += col*noise2*2.; // more pebbles\n    col -= col*noise3*0.5; // dark pebbles\n   \n    float bignoise1 = 1.-noise(p.xz*1.);\n    bignoise1 *= bignoise1;\n    bignoise1 = clamp01(bignoise1);\n    // bignoise1 *= 0.5;\n    float bignoise2 = 1.-noise(p.xz*1. + 30.);\n    bignoise2 *= bignoise2;\n    bignoise2 = clamp01(bignoise2);\n    // bignoise2 *= 0.5;\n    // col *= 0.9+0.1*bignoise;\n    \n    // col = vec3(bignoise1);\n    \n    col -= smoothstep(0.5,0.5,pat.rrr) * bignoise1 * 0.09;\n    col -= smoothstep(0.5,0.5,pat.bbb) * bignoise2 * 0.09;\n    \n    col += (col+0.5)*smoothstep(0.,0.1,noise(p.xz)*0.5-noise(p.xz*50.))*0.2;\n    \n    // col *= 1.3-col.b;\n    \n    // return\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flBBDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 100, 100, 129], [131, 190, 212, 212, 543], [544, 603, 625, 625, 794], [933, 933, 965, 965, 1256], [1258, 1258, 1306, 1347, 1579], [1583, 1583, 1633, 1633, 1756], [1758, 1758, 1820, 1820, 1873], [1875, 1875, 1914, 1914, 2005], [2007, 2007, 2048, 2048, 2442], [2443, 2443, 2480, 2480, 2560], [2561, 2561, 2627, 2627, 2844], [2846, 2846, 2897, 2897, 3779], [3781, 3781, 3803, 3803, 3949], [3951, 3951, 3982, 3982, 4216], [4218, 4218, 4240, 4240, 4379], [4381, 4466, 4488, 4488, 4892], [4894, 4894, 4951, 5001, 6943]], "test": "untested"}
{"id": "fljfRm", "name": "Mobius transformation revealed", "author": "neozhaoliang", "description": "A recreation of the video: https://www-users.cse.umn.edu/~arnold/moebius/", "tags": ["3d", "mobius"], "likes": 23, "viewed": 1362, "published": 3, "date": "1651976315", "time_retrieved": "2024-07-30T16:49:43.940559", "image_code": "/*\nThis animation shows that Mobius transformations are rigid motions\nof \"admissible\" spheres in the upper half-space.\n\nA sphere is called admissible if its highest point is above the xy-plane.\n\nThe procedure involves four steps:\n\n1. Map the complex plane (xy) to the sphere using inverse\n   stereographic projection.\n   \n2. Translate and rotate the sphere, but keeping it admissible..\n\n3. Map the sphere back to the complex plane using stereographic projection, \n   with the north pole being the highest point of the sphere.\n\n4. Combine steps 1-3 to get a Mobius transformation of the complex plane.\n   All Mobius transformations can be obtained this way.\n   \n\nIn this process,\n\n1. moving the sphere in the xy-plane is a translation of the complex plane.\n\n2. moving it along the z-axis is a scaling of the complex plane.\n\n3. rotating it in the xy-plane is a rotation of the complex plane.\n\n4. rotating 180 degress about the x-axis is the inverse map z -> 1/z.\n\n\nFor a given Mobius transformation M and a chosen initial position\nof the sphere, the rigid motion that gives M is unique.\n*/\n\n#define PI            3.141592654\n#define TAU           (2.0*PI)\n#define ROT(a)        mat2(cos(a), sin(a), -sin(a), cos(a))\n#define PCOS(x)       (0.5 + 0.5*cos(x))\n#define DOT2(x)       dot(x, x)\n#define TIME          iTime\n#define Y             vec3(0, 1, 0)\n#define NPOLE(sph)    (sph.xyz + sph.w * Y)\n#define PLANE         vec4(0, 1, 0, 1.5)\n#define aa            (2.0/iResolution.y)\n\nconst vec4 hsv2rgb_K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);\n#define HSV2RGB(c)  (c.z * mix(hsv2rgb_K.xxx, clamp(abs(fract(c.xxx + hsv2rgb_K.xyz) * 6.0 - hsv2rgb_K.www) - hsv2rgb_K.xxx, 0.0, 1.0), c.y))\n\nconst float grid_max     = 3.0;\nconst float grid_size    = 0.5;\nconst vec3  light_pos    = vec3(3, 4, 3);\nconst vec3  light_dir    = normalize(light_pos);\nconst vec3  sky0_color   = HSV2RGB(vec3(0.0, 0.65, 0.95)); \nconst vec3  sky1_color   = HSV2RGB(vec3(0.6, 0.5, 0.5));\nconst vec3  grid_color   = HSV2RGB(vec3(0.6, 0.6, 1.0)); \nconst vec3  light_color  = 12.0*HSV2RGB(vec3(0.6, 0.5, 1.0));\nconst vec3  plane_color  = HSV2RGB(vec3(0.7, 0.125, 1.0/32.0)); \n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvec2 mod2(inout vec2 p, vec2 size) {\n    vec2 id = floor(p / size);\n    p = mod(p + size*0.5, size) - size*0.5;\n    return id;\n}\n\nfloat rayPlane(vec3 ro, vec3 rd, vec4 p) {\n    return -(dot(ro, p.xyz) + p.w) / dot(rd, p.xyz);\n}\n\nvec2 raySphere(vec3 ro, vec3 rd, vec4 sph) {\n    vec3 oc = ro - sph.xyz;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - sph.w*sph.w;\n    float h = b*b - c;\n    if (h < 0.0) return vec2(-1.0);\n    h = sqrt(h);\n    return vec2(-b - h, -b + h);\n}\n\nfloat hash21(vec2 p) {\n    return fract(sin(dot(p, vec2(12.9898, 58.233))) * 13758.5453);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, vec4 sph, float k) {\n    vec3 oc = ro - sph.xyz;\n    float r2 = sph.w * sph.w;\n    float b = dot(oc, rd);\n    float c = dot(oc, oc) - r2;\n    float h = b * b - c;\n    float d = -sph.w + sqrt(max(0.0, r2 - h));\n    float t = -b - sqrt(max(0.0, h));\n    return (t < 0.0) ? 1.0 : smoothstep(0.0, 1.0, k * d / t);\n}\n\nfloat bounce() {\n    float t = fract(TIME) - 0.5;\n    return 0.25 - t*t;\n}\n\nvec2 path(float t) {\n    const float rad = 0.8;\n    return rad * vec2(cos(t), sin(t));\n}\n\nvoid rot(inout vec3 sp) {\n    sp.xy    *= ROT(TIME*0.3);\n    sp.xz    *= ROT(TIME*0.3);\n}\n\nvec3 diffuse(vec3 pos, vec3 nor) {\n    float ll = DOT2(light_pos - pos);\n    vec3  ld = normalize(light_pos - pos);\n    return light_color * max(dot(nor, ld), 0.0) / ll * 20.;\n}\n\nvec3 restrictColor(vec2 p, vec3 col) {\n    float cond =  step(abs(p.x), grid_max);\n          cond *= step(abs(p.y), grid_max);\n    return mix(plane_color, col, cond);\n}\n\nvec3 planeToSphere(vec3 p, vec4 sph) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(N - p);\n    float t = raySphere(p, rd, sph).x;\n    return p + rd*t;\n}\n\nvec3 sphereToPlane(vec3 p, vec4 sph, vec4 plane) {\n    vec3 N = NPOLE(sph);\n    vec3 rd = normalize(p - N);\n    float t = rayPlane(p, rd, plane);\n    return p + rd*t - sph.xyz;\n}\n\nvec3 computeGridColor(vec3 pos, vec2 pp) {\n    vec2 z = pp;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * TIME + 0.25 * TAU * length(pos.xz));\n    \n    z = pp;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n  = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(TIME) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(id), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.1, 0.09, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 0.5*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n\n    vec3 col = clamp(gcol, -1.0, 1.0);\n\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125)); \n    return col;\n}\n\n\nvec3 renderBackground(vec3 ro, vec3 rd, vec4 sph, float T) {\n    vec3 sky = smoothstep(1.0, 0.0, rd.y) * sky1_color + \n               smoothstep(0.5, 0.0, rd.y) * sky0_color;\n               \n    sky += pow(max(dot(rd, light_dir), 0.0), 800.0)*light_color;\n    if (rd.y >= 0.0)\n        return sky;\n        \n    float ht  = 1.0 + 0.2 * smoothstep(-0.05, 0.1, bounce());\n    float t   = rayPlane(ro, rd, vec4(vec3(0.0, ht, 0.0), 0.5));\n    vec3 pos  = ro + t*rd;\n    vec3 dif  = diffuse(pos, Y);\n    float sha = softShadow(pos, normalize(light_pos - pos), sph, 2.0);\n    dif *= sha;\n    \n    vec3 sp = planeToSphere(pos, sph);\n    sp -= sph.xyz;\n    rot(sp);\n    sp += sph.xyz;\n    vec3 pp = sphereToPlane(sp, sph, PLANE);\n\n    vec3 col = computeGridColor(pos, pp.xz);\n    col = restrictColor(pp.xz, col); \n    col += plane_color * dif;\n    col /= (1.0 + 0.25 * DOT2(pos.xz)); \n    col = mix(sky, col, tanh(500.0/(1.0 + DOT2(pos))));\n    return col;\n}\n\nvec3 renderBall(vec3 ro, vec3 rd, vec4 sph, vec2 st, float T) {\n    vec3 pos  = ro + st.x*rd;\n    vec3 sp   = pos - sph.xyz;\n    vec3 nor  = normalize(sp);\n    vec3 ref  = reflect(rd, nor);\n    vec3 dif  = diffuse(pos, nor);\n    rot(sp);\n    pos       = sp + sph.xyz;\n    vec3 pp   = sphereToPlane(pos, sph, vec4(0, 1, 0, 0.5));\n    vec3 rcol = renderBackground(pos, ref, sph, T);\n    \n    vec2 z = pp.xz;\n    mod2(z, vec2(grid_size));\n    float d1 = smin(abs(z.x), abs(z.y), .05);\n    float gm = PCOS(-TAU * T + 0.25 * TAU * length(pp));\n    \n    z = pp.xz;\n    vec2 id = mod2(z, vec2(grid_size / 6.));\n    float d2 = min(abs(z.x), abs(z.y)) - 0.0125;\n    \n    float n = hash21(id);\n    float n2 = n * 0.3 + .7;\n    if (n < 0.1 * sin(T) + 0.1)\n        n = 1E6;\n    else\n        n = 0.0;\n  \n    vec3 gcol = vec3(0);\n    gcol = mix(gcol, HSV2RGB(vec3(hash21(sin(id * TAU)), 1.0, n2)), vec3(n > 1.0));\n    gcol -= 0.2*vec3(2.0, 1.0, 1.0)*exp(-100.0*max(d2+0.01, 0.0));\n    gcol = mix(gcol, 6.*vec3(0.09, 0.1, 0.125), smoothstep(-aa, aa, -(d2+0.0075)));\n    gcol += 1.*vec3(2.0, 1.0, 1.0)*exp(-900.0*abs(d2-0.00125));\n    vec3 col = clamp(gcol, -1., 1.);\n    gcol = mix(vec3(0.75), 2.0*vec3(3.5, 2.0, 1.25), gm);\n    gcol *= exp(-mix(400.0, 100.0, gm) * max(d1-0.0125, 0.0));\n    gcol *= 0.3;\n    col = mix(col, gcol, smoothstep(-aa, aa, -d1 + 0.0125));\n    col = restrictColor(pp.xz, col);\n    col += rcol * 0.175;\n    return col;\n}\n\nvec3 render(vec2 p, vec2 uv) {\n    vec2 ph = path(TIME * 0.5);\n    vec3 ro = vec3(2.5, 1.0, 0.);\n    ro.xz *= ROT(TIME / 3.);\n    vec3 lookat = vec3(0., 0., 0.);\n    vec3 forward = normalize(lookat - ro);\n    vec3 right = normalize(cross(forward, Y));\n    vec3 up = normalize(cross(right, forward));\n    vec3 rd = normalize(p.x*right + p.y*up + 2.0*forward);\n    vec4 sph = vec4(vec3(0., bounce(), 0.), 0.5);\n    sph.xz += ph;\n    vec2 st = raySphere(ro, rd, sph);\n    if (st.x >= 0.0)\n        return renderBall(ro, rd, sph, st, TIME);\n    else\n        return renderBackground(ro, rd, sph, TIME);\n}\n\nvec3 postprocess(vec3 col, vec2 q) {\n    col = pow(clamp(col, 0.0, 1.0), vec3(1.0/2.2)); \n    col = col*0.6 + 0.4*col*col*(3.0 - 2.0*col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n    col *= 0.5 + 0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.7);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col = render(p, uv);\n\n    //float fi = smoothstep(0.0, 5.0, TIME);\n    //col = mix(vec3(0.0), col, fi);\n\n    col = postprocess(col, uv);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljfRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2137, 2137, 2176, 2176, 2269], [2271, 2271, 2307, 2307, 2399], [2401, 2401, 2443, 2443, 2498], [2500, 2500, 2544, 2544, 2755], [2757, 2757, 2779, 2779, 2848], [2850, 2850, 2905, 2905, 3196], [3198, 3198, 3214, 3214, 3272], [3274, 3274, 3294, 3294, 3362], [3364, 3364, 3389, 3389, 3453], [3455, 3455, 3489, 3489, 3632], [3634, 3634, 3672, 3672, 3802], [3804, 3804, 3842, 3842, 3961], [3963, 3963, 4013, 4013, 4141], [4143, 4143, 4185, 4185, 5168], [5171, 5171, 5231, 5231, 6119], [6121, 6121, 6184, 6184, 7551], [7553, 7553, 7583, 7583, 8151], [8153, 8153, 8189, 8189, 8428], [8430, 8430, 8487, 8487, 8773]], "test": "untested"}
{"id": "NljBRm", "name": "ICE VFX", "author": "rge15", "description": "It's an ice FX playing with polar coordinates, and some value noise pattern with FBM.", "tags": ["noise", "fbm", "vfx", "ice", "polarcoords"], "likes": 3, "viewed": 218, "published": 3, "date": "1651939127", "time_retrieved": "2024-07-30T16:49:44.693546", "image_code": "#define PI 3.1415\n\nfloat N21( in vec2 p)\n{\n    p = 50.*fract( p * PI);\n    p = 50.*fract((p+vec2(0.24342,709.23))/PI);\n\n    return -1. + 2.*fract((p.x*p.y) );\n}\n\nfloat valueNoise( in vec2 p)\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 func = f*f*(3.-2.*f);\n    \n    float a = N21(i + vec2( 0., 0.));\n    float b = N21(i + vec2( 1., 0.));\n    float c = N21(i + vec2( 0., 1.));\n    float d = N21(i + vec2( 1., 1.));\n\n    return a + ( b - a ) * func.x + ( c - a ) * func.y + ( a -b -c +d ) * func.x * func.y; \n\n}\n\nfloat valueFBM( in vec2 p, in float H )\n{\n    float d = 0.;\n    int numOctaves = 2;\n    for(int i = 0; i < numOctaves; i++)\n    {\n        float f = pow(2., float(i));\n        float a = pow(f,-H);\n        d += a*valueNoise(f*p);\n    }\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy)/iResolution.y;\n\n    vec2 p_uv = vec2(atan(uv.x,uv.y), length(uv));\n\n    vec2 ndc = vec2( p_uv.x / 6.283 + 0.5, p_uv.y );\n\n#if 1\n    float x = ndc.x * 8. - iTime*.4;\n    float y = ndc.y;\n    //float y = ndc.y * abs( 1.5 - sin(iTime));\n#else\n    float x = uv.x * 8. - iTime*0.3;\n    float y = uv.y;\n#endif\n\n    //FIRST PART : 1\n    float func12 = min( fract(x*2.+ fract(iTime*0.2)), fract(1.-x*2.5));       \n    \n    float v12 = smoothstep(0.0 ,0.1, func12 - 2. * y + .2 );\n\n    \n    //SECOND PART : 2\n    float func2 = ( pow(cos( PI * x), 3.5 )) * 0.2;\n\n    float v2 = smoothstep(0.0 ,0.1, func2 - 2. * y + .2 );\n\n    //ADDING COLOR\n    vec3 col = exp(v12) * 3.5 * vec3( v12*0.2, v12*0.45, v12*0.65  ) * (length(y));\n    col += (valueFBM(3.*p_uv-iTime,.5)) * exp(v12) * 3.5 * vec3( v12*0.2, v12*0.45, v12*0.65  ) * (length(y));\n    v2 = (valueFBM(6.*p_uv,.5) + 0.5)*v2;\n    col += (v2 * 40.5 * vec3( v12*0.2, v12*0.45, v12*0.65  ) * (length(y)));\n    \n    col += vec3(0.25);\n\n    // Output to screen\n    fragColor = vec4(col,1.);\n    //fragColor = vec4(vec3((valueFBM(6.*p_uv,.5) + 0.5)*v2),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 42, 42, 160], [162, 162, 192, 192, 527], [529, 529, 570, 570, 779], [781, 781, 838, 888, 2033]], "test": "untested"}
{"id": "fslBWS", "name": "far too many squares", "author": "unnick", "description": "", "tags": ["effect"], "likes": 9, "viewed": 278, "published": 3, "date": "1651937844", "time_retrieved": "2024-07-30T16:49:45.445536", "image_code": "#define res iResolution.xy\nconst float tau = 6.283185307179586;\n\nvec2 cossin(float t) {\n    return vec2(cos(t), sin(t));\n}\n\nmat2 rot(float t) {\n    vec2 cs = cossin(t);\n    return mat2(cs.x, -cs.y, cs.y, cs.x);\n}\n\nvoid mainImage(out vec4 col, vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y;\n    int i;\n    for(i = 0; i < 64; i++) {\n        float depth = float(i)+1.-fract(iTime*3.);\n        float z = float(i)+floor(iTime*3.);\n        vec2 op = rot(z*0.2) * (pos * depth * .5 + cossin((iTime*3.-1.)*.2)*2.) + .25;\n        if (fract(op.x) > .5 ^^ fract(op.y) > .5) break;\n    }\n    col = vec4(sqrt( (cos((vec3(0,1,2)/3. + (float(i)+floor(iTime*3.)) * .03) * tau) * .5 + .5) * exp(-(float(i)+1.-fract(iTime*3.))*.2) ),1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fslBWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 87, 87, 122], [124, 124, 143, 143, 212]], "test": "untested"}
{"id": "slSfzm", "name": "Gargantua + Star Nest ", "author": "Beredro", "description": "This is a \"Remix\" of the two great shaders >lstSRS< (@sonicether) and >XlfGRj< (@Kali)\nby Moritz4004\n\nEdit: Tried to reduce the noise", "tags": ["raymarching", "fractal", "space", "bloom", "stars", "blackhole", "hdr", "gargantua", "interstellar"], "likes": 50, "viewed": 2095, "published": 3, "date": "1651926041", "time_retrieved": "2024-07-30T16:49:46.705168", "image_code": "/*----------------------------\nhttps://www.shadertoy.com/view/slSfzm\n\nThis Shader by moritz4004 is a remix of two others:\n    Gargantua With HDR Bloom @sonicether    - https://www.shadertoy.com/view/lstSRS\n    Star Nest by Pablo Roman Andrioli @Kali - https://www.shadertoy.com/view/XlfGRj\n    \nMusic:\nhttps://soundcloud.com/ziad-a-mahmoud/interstellar-main-theme-extra-extended-soundtrack-by-hans-zimmer\n----------------------------*/\n#define iterations 28\n#define formuparam 0.533\n\n#define volsteps 24\n#define stepsize 0.1\n\n#define zoom   0.99700\n#define tile   4.5850\n#define speed  -0.0001 \n\n#define brightness 0.00073\n#define darkmatter 0.100\n#define distfading 0.730\n#define saturation 0.950\n\n\n\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nvec4 cubic(float x)\n{\n    float x2 = x * x;\n    float x3 = x2 * x;\n    vec4 w;\n    w.x =   -x3 + 3.0*x2 - 3.0*x + 1.0;\n    w.y =  3.0*x3 - 6.0*x2       + 4.0;\n    w.z = -3.0*x3 + 3.0*x2 + 3.0*x + 1.0;\n    w.w =  x3;\n    return w / 6.0;\n}\n\nvec4 BicubicTexture(in sampler2D tex, in vec2 coord)\n{\n    vec2 resolution = iResolution.xy;\n\n    coord *= resolution;\n\n    float fx = fract(coord.x);\n    float fy = fract(coord.y);\n    coord.x -= fx;\n    coord.y -= fy;\n\n    fx -= 0.5;\n    fy -= 0.5;\n\n    vec4 xcubic = cubic(fx);\n    vec4 ycubic = cubic(fy);\n\n    vec4 c = vec4(coord.x - 0.5, coord.x + 1.5, coord.y - 0.5, coord.y + 1.5);\n    vec4 s = vec4(xcubic.x + xcubic.y, xcubic.z + xcubic.w, ycubic.x + ycubic.y, ycubic.z + ycubic.w);\n    vec4 offset = c + vec4(xcubic.y, xcubic.w, ycubic.y, ycubic.w) / s;\n\n    vec4 sample0 = texture(tex, vec2(offset.x, offset.z) / resolution);\n    vec4 sample1 = texture(tex, vec2(offset.y, offset.z) / resolution);\n    vec4 sample2 = texture(tex, vec2(offset.x, offset.w) / resolution);\n    vec4 sample3 = texture(tex, vec2(offset.y, offset.w) / resolution);\n\n    float sx = s.x / (s.x + s.y);\n    float sy = s.z / (s.z + s.w);\n\n    return mix( mix(sample3, sample2, sx), mix(sample1, sample0, sx), sy);\n}\n\nvec3 ColorFetch(vec2 coord)\n{\n     return texture(iChannel0, coord).rgb;   \n}\n\nvec3 BloomFetch(vec2 coord)\n{\n     return BicubicTexture(iChannel3, coord).rgb;   \n}\n\nvec3 Grab(vec2 coord, const float octave, const vec2 offset)\n{\n     float scale = exp2(octave);\n    \n    coord /= scale;\n    coord -= offset;\n\n    return BloomFetch(coord);\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n    offset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n     return offset;   \n}\n\nvec3 GetBloom(vec2 coord)\n{\n     vec3 bloom = vec3(0.0);\n    \n    //Reconstruct bloom from multiple blurred images\n    bloom += Grab(coord, 1.0, vec2(CalcOffset(0.0))) * 1.0;\n    bloom += Grab(coord, 2.0, vec2(CalcOffset(1.0))) * 1.5;\n    bloom += Grab(coord, 3.0, vec2(CalcOffset(2.0))) * 1.0;\n    bloom += Grab(coord, 4.0, vec2(CalcOffset(3.0))) * 1.5;\n    bloom += Grab(coord, 5.0, vec2(CalcOffset(4.0))) * 1.8;\n    bloom += Grab(coord, 6.0, vec2(CalcOffset(5.0))) * 1.0;\n    bloom += Grab(coord, 7.0, vec2(CalcOffset(6.0))) * 1.0;\n    bloom += Grab(coord, 8.0, vec2(CalcOffset(7.0))) * 1.0;\n\n    return bloom;\n}\n\nvec3 applyStarSystem(vec2 fragCoord){\n//get coords and direction\n    vec2 uv=fragCoord.xy/iResolution.xy-.5;\n    uv.y*=iResolution.y/iResolution.x;\n    vec3 dir=vec3(uv*zoom,1.);\n    float time=iTime*speed+.25;\n\n    //mouse rotation\n    float a1=0.9250;\n    float a2=.915;\n    mat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n    mat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n    dir.xz*=rot1;\n    dir.xy*=rot2;\n    vec3 from=vec3(1.,.5,0.5);\n    from+=vec3(time*2.,time,-2.);\n    from.xz*=rot1;\n    from.xy*=rot2;\n    \n    //volumetric rendering\n    float s=0.1,fade=1.;\n    vec3 v=vec3(0.);\n    for (int r=0; r<volsteps; r++) {\n        vec3 p=from+s*dir*.5;\n        p = abs(vec3(tile)-mod(p,vec3(tile*2.))); // tiling fold\n        float pa,a=pa=0.;\n        for (int i=0; i<iterations; i++) { \n            p=abs(p)/dot(p,p)-formuparam; // the magic formula\n            a+=abs(length(p)-pa); // absolute sum of average change\n            pa=length(p);\n        }\n        float dm=max(0.,darkmatter-a*a*0.0001); //dark matter\n        a*=a*a; // add contrast\n        if (r>6) fade*=1.-dm; // dark matter, don't render near\n        //v+=vec3(dm,dm*.5,0.);\n        //v+=fade;\n        v+=vec3(s,s*s,s*s*s*s)*a*brightness*fade; // coloring based on distance\n        fade*=distfading; // distance fading\n        s+=stepsize;               \n    }\n    \n    uv = fragCoord.xy / iResolution.xy;\n    vec2 uvForCenter = uv - 0.5; //-0.5 to 0.5\n    uvForCenter.x *= iResolution.x / iResolution.y;\n    \n    float d = length(uvForCenter);\n    float r = 0.65;\n    float c = smoothstep(r, r - 0.325, d);\n    \n    vec3 src = vec3(1., 1., 1.);\n    vec3 dst = vec3(0., 0., 0.);\n    vec3 circle = mix(src, dst, c);\n\n    v *= circle;\n    \n    return mix(vec3(length(v)),v,saturation)*.01; //color adjust\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = ColorFetch(uv);\n  \n    color += GetBloom(uv) * 0.08;\n    \n    color *= 200.0;\n\n    //Tonemapping and color grading\n    color = pow(color, vec3(1.5));\n    color = color / (1.0 + color);\n    color = pow(color, vec3(1.0 / 1.5));\n    \n    \n    color = mix(color, color * color * (3.0 - 2.0 * color), vec3(1.0));\n    color = pow(color, vec3(1.3, 1.20, 1.0));    \n\n\n    color = saturate(color * 1.01);\n    \n    color = pow(color, vec3(0.7 / 2.2));\n\n    color += applyStarSystem(fragCoord);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*  \nMain render. \n\nTemporal AA for a smooth image. Temporal accumulation is disabled while moving the view to prevent ghosting.\n*/\n\n#define ITERATIONS 200          //Increase for less grainy result\n#define TEMPORAL_AA\n\n\nconst vec3 MainColor = vec3(1.0);\n\n//noise code by iq\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return -1.0+2.0*mix( rg.x, rg.y, f.z );\n}\n\nfloat saturate(float x)\n{\n    return clamp(x, 0.0, 1.0);\n}\n\nvec3 saturate(vec3 x)\n{\n    return clamp(x, vec3(0.0), vec3(1.0));\n}\n\nfloat rand(vec2 coord)\n{\n    return saturate(fract(sin(dot(coord, vec2(12.9898, 78.223))) * 43758.5453));\n}\n\nfloat pcurve( float x, float a, float b )\n{\n    float k = pow(a+b,a+b) / (pow(a,a)*pow(b,b));\n    return k * pow( x, a ) * pow( 1.0-x, b );\n}\n\nconst float pi = 3.14159265;\n\nfloat atan2(float y, float x)\n{\n    if (x > 0.0)\n    {\n        return atan(y / x);\n    }\n    else if (x == 0.0)\n    {\n        if (y > 0.0)\n        {\n            return pi / 2.0;\n        }\n        else if (y < 0.0)\n        {\n            return -(pi / 2.0);\n        }\n        else\n        {\n            return 0.0;\n        }\n    }\n    else //(x < 0.0)\n    {\n        if (y >= 0.0)\n        {\n            return atan(y / x) + pi;\n        }\n        else\n        {\n            return atan(y / x) - pi;\n        }\n    }\n}\n\nfloat sdTorus(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz) - t.x, p.y);\n    return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n  return length(p)-r;\n}\n\nvoid Haze(inout vec3 color, vec3 pos, float alpha)\n{\n    vec2 t = vec2(1.0, 0.01);\n\n    float torusDist = length(sdTorus(pos + vec3(0.0, -0.05, 0.0), t));\n\n    float bloomDisc = 1.0 / (pow(torusDist, 1.0) + 0.001);\n    vec3 col = MainColor;\n    bloomDisc *= length(pos) < 0.5 ? 0.0 : 1.0;\n\n    color += col * bloomDisc * (2.9 / float(ITERATIONS)) * (1.0 - alpha * 1.0);\n}\n\nvoid GasDisc(inout vec3 color, inout float alpha, vec3 pos)\n{\n    float discRadius = 3.2;\n    float discWidth = 5.3;\n    float discInner = discRadius - discWidth * 0.5;\n    float discOuter = discRadius + discWidth * 0.5;\n    \n    vec3 origin = vec3(0.0, 0.0, 0.0);\n    float mouseZ = iMouse.y / iResolution.y;\n    vec3 discNormal = normalize(vec3(0.0, 1.0, 0.0));\n    float discThickness = 0.1;\n\n    float distFromCenter = distance(pos, origin);\n    float distFromDisc = dot(discNormal, pos - origin);\n    \n    float radialGradient = 1.0 - saturate((distFromCenter - discInner) / discWidth * 0.5);\n\n    float coverage = pcurve(radialGradient, 4.0, 0.9);\n\n    discThickness *= radialGradient;\n    coverage *= saturate(1.0 - abs(distFromDisc) / discThickness);\n\n    vec3 dustColorLit = MainColor;\n    vec3 dustColorDark = vec3(0.0, 0.0, 0.0);\n\n    float dustGlow = 1.0 / (pow(1.0 - radialGradient, 2.0) * 290.0 + 0.002);\n    vec3 dustColor = dustColorLit * dustGlow * 8.2;\n\n    coverage = saturate(coverage * 0.7);\n\n\n    float fade = pow((abs(distFromCenter - discInner) + 0.4), 4.0) * 0.04;\n    float bloomFactor = 1.0 / (pow(distFromDisc, 2.0) * 40.0 + fade + 0.00002);\n    vec3 b = dustColorLit * pow(bloomFactor, 1.5);\n    \n    b *= mix(vec3(1.7, 1.1, 1.0), vec3(0.5, 0.6, 1.0), vec3(pow(radialGradient, 2.0)));\n    b *= mix(vec3(1.7, 0.5, 0.1), vec3(1.0), vec3(pow(radialGradient, 0.5)));\n\n    dustColor = mix(dustColor, b * 150.0, saturate(1.0 - coverage * 1.0));\n    coverage = saturate(coverage + bloomFactor * bloomFactor * 0.1);\n    \n    if (coverage < 0.01)\n    {\n        return;   \n    }\n    \n    \n    vec3 radialCoords;\n    radialCoords.x = distFromCenter * 1.5 + 0.55;\n    radialCoords.y = atan2(-pos.x, -pos.z) * 1.5;\n    radialCoords.z = distFromDisc * 1.5;\n\n    radialCoords *= 0.95;\n    \n    float speed = 0.06;\n    \n    float noise1 = 1.0;\n    vec3 rc = radialCoords + 0.0;               rc.y += iTime * speed;\n    noise1 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise1 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise1 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise1 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n\n    float noise2 = 2.0;\n    rc = radialCoords + 30.0;\n    noise2 *= noise(rc * 3.0) * 0.5 + 0.5;      rc.y += iTime * speed;\n    noise2 *= noise(rc * 6.0) * 0.5 + 0.5;      rc.y -= iTime * speed;\n    noise2 *= noise(rc * 12.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 24.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n    noise2 *= noise(rc * 48.0) * 0.5 + 0.5;     rc.y += iTime * speed;\n    noise2 *= noise(rc * 92.0) * 0.5 + 0.5;     rc.y -= iTime * speed;\n\n    dustColor *= noise1 * 0.998 + 0.002;\n    coverage *= noise2;\n    \n    radialCoords.y += iTime * speed * 0.5;\n    \n    dustColor *= pow(texture(iChannel1, radialCoords.yx * vec2(0.15, 0.27)).rgb, vec3(2.0)) * 4.0;\n\n    coverage = saturate(coverage * 1200.0 / float(ITERATIONS));\n    dustColor = max(vec3(0.0), dustColor);\n\n    coverage *= pcurve(radialGradient, 4.0, 0.9);\n\n    color = (1.0 - alpha) * dustColor * coverage + color;\n\n    alpha = (1.0 - alpha) * coverage + alpha;\n}\n\n\n\nvec3 rotate(vec3 p, float x, float y, float z)\n{\n    mat3 matx = mat3(1.0, 0.0, 0.0,\n                     0.0, cos(x), sin(x),\n                     0.0, -sin(x), cos(x));\n\n    mat3 maty = mat3(cos(y), 0.0, -sin(y),\n                     0.0, 1.0, 0.0,\n                     sin(y), 0.0, cos(y));\n\n    mat3 matz = mat3(cos(z), sin(z), 0.0,\n                     -sin(z), cos(z), 0.0,\n                     0.0, 0.0, 1.0);\n\n    p = matx * p;\n    p = matz * p;\n    p = maty * p;\n\n    return p;\n}\n\nvoid RotateCamera(inout vec3 eyevec, inout vec3 eyepos)\n{\n    float mousePosY = iMouse.y / iResolution.y;\n    float mousePosX = 0.5;\n\n    vec3 angle = vec3(mousePosY * 0.05 + 0.05, 1.0 + mousePosX * 1.0, -0.45);\n\n    eyevec = rotate(eyevec, angle.x, angle.y, angle.z);\n    eyepos = rotate(eyepos, angle.x, angle.y, angle.z);\n}\n\nvoid WarpSpace(inout vec3 eyevec, inout vec3 raypos)\n{\n    vec3 origin = vec3(0.0, 0.0, 0.0);\n\n    float singularityDist = distance(raypos, origin);\n    float warpFactor = 1.0 / (pow(singularityDist, 2.0) + 0.000001);\n\n    vec3 singularityVector = normalize(origin - raypos);\n    \n    float warpAmount = 5.0;\n\n    eyevec = normalize(eyevec + singularityVector * warpFactor * warpAmount / float(ITERATIONS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float aspect = iResolution.x / iResolution.y;\n\n    vec2 uveye = uv;\n    \n    #ifdef TEMPORAL_AA\n    uveye.x += (rand(uv + sin(iTime * 1.0)) / iResolution.x) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    uveye.y += (rand(uv + 1.0 + sin(iTime * 1.0)) / iResolution.y) * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    #endif\n    \n    vec3 eyevec = normalize(vec3((uveye * 2.0 - 1.0) * vec2(aspect, 1.0), 6.0));\n    vec3 eyepos = vec3(0.0, -0.0, -10.0);\n    \n    vec2 mousepos = vec2(0.5,1.0); //iMouse.xy / iResolution.xy;\n    if (mousepos.x == 0.0)\n    {\n        mousepos.x = 0.35;\n    }\n    eyepos.x += mousepos.x * 3.0 - 1.5;\n    \n    const float far = 15.0;\n\n    RotateCamera(eyevec, eyepos);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float dither = rand(uv \n                        #ifdef TEMPORAL_AA\n                        + sin(iTime * 1.0) * (iMouse.z > 1.0 ? 0.0 : 1.0)\n                        #endif\n                       ) * 2.0;\n\n\n    float alpha = 0.0;\n    vec3 raypos = eyepos + eyevec * dither * far / float(ITERATIONS);\n    for (int i = 0; i < ITERATIONS; i++)\n    {        \n        WarpSpace(eyevec, raypos);\n        raypos += eyevec * far / float(ITERATIONS);\n        GasDisc(color, alpha, raypos);\n        Haze(color, raypos, alpha);\n    }\n    \n    color *= 0.0001;\n\n    \n    #ifdef TEMPORAL_AA\n    const float p = 1.0;\n    vec3 previous = pow(texture(iChannel2, uv).rgb, vec3(1.0 / p));\n    \n    color = pow(color, vec3(1.0 / p));\n    \n    float blendWeight = 0.9 * (iMouse.z > 1.0 ? 0.0 : 1.0);\n    \n    color = mix(color, previous, blendWeight);\n    \n    color = pow(color, vec3(p));\n    #endif\n    \n    fragColor = vec4(saturate(color), 1.0);\n\n}", "buffer_a_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28908, "src": "https://soundcloud.com/ziad-a-mahmoud/interstellar-main-theme-extra-extended-soundtrack-by-hans-zimmer", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "//First bloom pass, mipmap tree thing\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nvec3 Grab1(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = ColorFetch(coord);\n\n    return color;\n}\n\nvec3 Grab4(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 4;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab8(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 8;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec3 Grab16(vec2 coord, const float octave, const vec2 offset)\n{\n \tfloat scale = exp2(octave);\n    \n    coord += offset;\n    coord *= scale;\n\n   \tif (coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0)\n    {\n     \treturn vec3(0.0);   \n    }\n    \n    vec3 color = vec3(0.0);\n    float weights = 0.0;\n    \n    const int oversampling = 16;\n    \n    for (int i = 0; i < oversampling; i++)\n    {    \t    \n        for (int j = 0; j < oversampling; j++)\n        {\n\t\t\tvec2 off = (vec2(i, j) / iResolution.xy + vec2(0.0) / iResolution.xy) * scale / float(oversampling);\n            color += ColorFetch(coord + off);\n            \n\n            weights += 1.0;\n        }\n    }\n    \n    color /= weights;\n    \n    return color;\n}\n\nvec2 CalcOffset(float octave)\n{\n    vec2 offset = vec2(0.0);\n    \n    vec2 padding = vec2(10.0) / iResolution.xy;\n    \n    offset.x = -min(1.0, floor(octave / 3.0)) * (0.25 + padding.x);\n    \n    offset.y = -(1.0 - (1.0 / exp2(octave))) - padding.y * octave;\n\n\toffset.y += min(1.0, floor(octave / 3.0)) * 0.35;\n    \n \treturn offset;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    vec3 color = vec3(0.0);\n    \n    /*\n    Create a mipmap tree thingy with padding to prevent leaking bloom\n   \t\n\tSince there's no mipmaps for the previous buffer and the reduction process has to be done in one pass,\n    oversampling is required for a proper result\n\t*/\n    color += Grab1(uv, 1.0, vec2(0.0,  0.0)   );\n    color += Grab4(uv, 2.0, vec2(CalcOffset(1.0))   );\n    color += Grab8(uv, 3.0, vec2(CalcOffset(2.0))   );\n    color += Grab16(uv, 4.0, vec2(CalcOffset(3.0))   );\n    color += Grab16(uv, 5.0, vec2(CalcOffset(4.0))   );\n    color += Grab16(uv, 6.0, vec2(CalcOffset(5.0))   );\n    color += Grab16(uv, 7.0, vec2(CalcOffset(6.0))   );\n    color += Grab16(uv, 8.0, vec2(CalcOffset(7.0))   );\n\n\n    fragColor = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//Horizontal gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.5, 0.0)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.5, 0.0)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//Vertical gaussian blur leveraging hardware filtering for fewer texture lookups.\n\nvec3 ColorFetch(vec2 coord)\n{\n \treturn texture(iChannel0, coord).rgb;   \n}\n\nfloat weights[5];\nfloat offsets[5];\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    \n    weights[0] = 0.19638062;\n    weights[1] = 0.29675293;\n    weights[2] = 0.09442139;\n    weights[3] = 0.01037598;\n    weights[4] = 0.00025940;\n    \n    offsets[0] = 0.00000000;\n    offsets[1] = 1.41176471;\n    offsets[2] = 3.29411765;\n    offsets[3] = 5.17647059;\n    offsets[4] = 7.05882353;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 color = vec3(0.0);\n    float weightSum = 0.0;\n    \n    if (uv.x < 0.52)\n    {\n        color += ColorFetch(uv) * weights[0];\n        weightSum += weights[0];\n\n        for(int i = 1; i < 5; i++)\n        {\n            vec2 offset = vec2(offsets[i]) / iResolution.xy;\n            color += ColorFetch(uv + offset * vec2(0.0, 0.5)) * weights[i];\n            color += ColorFetch(uv - offset * vec2(0.0, 0.5)) * weights[i];\n            weightSum += weights[i] * 2.0;\n        }\n\n        color /= weightSum;\n    }\n\n    fragColor = vec4(color,1.0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slSfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[702, 702, 725, 725, 770], [772, 772, 793, 793, 1009], [1011, 1011, 1065, 1065, 2011], [2013, 2013, 2042, 2042, 2090], [2092, 2092, 2121, 2121, 2176], [2178, 2178, 2240, 2240, 2352], [2354, 2354, 2385, 2385, 2697], [2699, 2699, 2726, 2726, 3314], [3316, 3316, 3353, 3380, 5102], [5104, 5104, 5161, 5161, 5754]], "test": "untested"}
{"id": "ftSBRw", "name": "Glossy Effect Test 2", "author": "SnoopethDuckDuck", "description": "Sloppy code, looks ok", "tags": ["e"], "likes": 12, "viewed": 339, "published": 3, "date": "1651924765", "time_retrieved": "2024-07-30T16:49:48.166261", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define pi 3.14159\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 4.;\n    float t = 0.2 * iTime;\n\n    vec3 ro = vec3(r * cos(t), 1.5 * cos(0.8 * t), r * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float o = 2. * pi / 3.;\n    //p *= 1. + 0.2 * thc(1., vec3(-o,0,o) + 4. * p.y + iTime);\n\n    float d = length(p) - 1.3 + 0.12 * cos(p.y * 4. - iTime);\n    \n    // unneccesary but i cant find the right value to replace it\n    float val = smoothstep(-0.5, 0.5, -length(p) + 1.15);\n    val = clamp(val, 0., 1.);\n    d -= 0.75 * val;\n   \n    p.xy *= rot(1. * iTime);\n    float r1 = 1.;\n    float r2 = 0.5;\n    float d1 = length(p.xz) - r1;\n    float d2 = length(vec2(p.y, d1)) - r2;\n   \n    d = mix(d, d2, 0.5 + 0.5 * thc(5., 0.25 * iTime));\n   \n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    // was 2.\n    float IOR = 1.2;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        vec3 pIn = p - 20. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit);\n        \n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n       \n        float fres = pow(1. + dot(rd, n), 5.);\n        \n        // Change me\n        float c = 4.; // [0.6,6] is an okay range (<1 is like fresnel)\n        float I = 3.; // anything above 0. lower numbers more intense\n        \n        vec3 n1 = 0.8 * (abs(r) - abs(n));\n        float mx2 = exp(-5. * length(abs(r)-abs(n1)));\n\n        vec3 r2 = c * (abs(r)-abs(n));\n        vec3 n2 = c * (abs(r2)-abs(n));\n        \n        float mx = exp(-I * length(abs(r2)-abs(n2)));\n \n        float cl = 0.5 + 0.25 * dif + max(0.5 * fres, max(mx,mx2));\n\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(0.75 * length(p) - p.y * 0.05 + 0.25 + 0.75 * mx, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        vec3 col3 = pal(0.75 * length(p) - p.y * 0.05 + 0.25 + 1.5 * mx2, e, e, e, 0.5 * vec3(0,1,2)/3.);\n        \n        float c1 = texture(iChannel0, 0.05 * iTime + 3. * p.xy).r;\n        float c2 = texture(iChannel0, 0.05 * iTime + 3. * p.yz).r;\n        float c3 = texture(iChannel0, 0.05 * iTime + 3. * p.zx).r;\n        \n        vec3 n3 = abs(n);\n        float c4 = n3.z * c1 + n3.x * c2 + n3.y * c3;\n        \n        // add (dif + reflections) * base color\n        col = cl * col2;\n\n        // add noise (doesnt do much)\n        col *= 0.72 + 0.35 * c4;\n\n        // mix to second color based on ray distance inside object\n        float mx3 = exp(-0.333 * dIn);\n        //col = cl * col3;\n        col = mix(col, col3, mx3);\n        //col = cl * col3;\n        \n        // add vertical shading (\"light source\" from above)\n        col += 0.2 * n.y + 0.1 * nExit.y;\n        \n        // more color + reflections to match background \n        col += 0.075 * (exp(vec3(abs(rd.x),rd.y,abs(rd.z))) + exp(-r) + 0.1 * exp(r2) - 1.05);\n    } else {    \n        col = 0.5 * exp(vec3(abs(rd.x),rd.y,abs(rd.z)));\n    }\n    \n    //col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSBRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 244, 244, 287], [289, 289, 313, 313, 369], [371, 371, 400, 400, 481], [483, 483, 497, 497, 731], [733, 733, 756, 756, 1318], [1320, 1320, 1363, 1363, 1669], [1671, 1671, 1695, 1695, 1885], [1887, 1887, 1937, 1937, 2128], [2130, 2130, 2187, 2187, 4730]], "test": "untested"}
{"id": "NlSfzm", "name": "camera focusing", "author": "zyc", "description": "camera focusing", "tags": ["focus"], "likes": 1, "viewed": 284, "published": 3, "date": "1651906733", "time_retrieved": "2024-07-30T16:49:48.975099", "image_code": "\nfloat normpdf(in float x, in float sigma)\n{\n\treturn 0.39894*exp(-0.5*x*x/(sigma*sigma))/sigma;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 c = texture(iChannel0, fragCoord.xy / iResolution.xy).rgb;\n\t\n\t\t\n\t\t//declare stuff\n\t\tconst int mSize = 11;\n\t\tconst int kSize = (mSize-1)/2;\n\t\tfloat kernel[mSize];\n\t\tvec3 final_colour = vec3(0.0);\n\t\t\n\t\t//create the 1-D kernel\n\t\tfloat sigma = 8.0 * sin(iTime);\n\t\tfloat Z = 0.0;\n\t\tfor (int j = 0; j <= kSize; ++j)\n\t\t{\n\t\t\tkernel[kSize+j] = kernel[kSize-j] = normpdf(float(j), sigma);\n\t\t}\n\t\t\n\t\t//get the normalization factor (as the gaussian has been clamped)\n\t\tfor (int j = 0; j < mSize; ++j)\n\t\t{\n\t\t\tZ += kernel[j];\n\t\t}\n\t\t\n\t\t//read out the texels\n\t\tfor (int i=-kSize; i <= kSize; ++i)\n\t\t{\n\t\t\tfor (int j=-kSize; j <= kSize; ++j)\n\t\t\t{\n\t\t\t\tfinal_colour += kernel[kSize+j]*kernel[kSize+i]*texture(iChannel0, (fragCoord.xy+vec2(float(i),float(j))) / iResolution.xy).rgb;\n\t\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfragColor = vec4(final_colour/(Z*Z), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSfzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 44, 44, 97], [99, 99, 156, 156, 987]], "test": "untested"}
{"id": "flSBzm", "name": "inner dolly zoom / curve rays", "author": "FabriceNeyret2", "description": "distance-dependant dolly zoom :  zoom changes during the ray-tracing (to enlarge background).\nMouse.y controls the effect.\nkey 1,2: force camera 1 or 2\n\nPress SPACE to stop the anti-banding treatment.", "tags": ["raymarching", "camera", "interpolation", "spacefungus"], "likes": 8, "viewed": 301, "published": 3, "date": "1651902262", "time_retrieved": "2024-07-30T16:49:49.777952", "image_code": "// variant of https://shadertoy.com/view/wlBBWG\n\n#define rot(a)         mat2( cos( a + vec4(0,33,11,0)) )\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.)\n        \n// Space fungus https://www.shadertoy.com/view/lsSBWh\n#define map(q) (                                                     \\\n    t = max( d = length(q) - 9.,                    /* Sphere */     \\\n             abs(a=cos(b=3.*dot(sin(q),p/p)))/9. ), /* EggCarton */  \\\n    t = max( t, 8.5-length(q) ),                    /* inner hole */ \\\n    q.xy = mod(q.xy,10.) -5., t = min(t, e = max( length(q)-1.,-d)), /* spheres grid */ \\\n    t )\n\nvoid mainImage(out vec4 O, vec2 u) {\n     vec2  R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;                      // normalized centered coords\n    \n    float a,b,d,e,l,i,  t = iTime,                    // materials id\n        _t, c = 1., s = .015,                         // color (pseudo-shading), delta per iteration\n          m = iMouse.z > 0. ?  iMouse.y/R.y : .5+.5*sin(iTime ) ; // inner dolly zoom control\n    vec3  D1 = normalize( vec3(U,-2.) ),              // ray direction 1\n          D2 = normalize( vec3(U,-15.) ),             // ray direction 2 (different zoom )\n          p = vec3(0,4,40.), p0, q,D;                 // ray origin, then current point on ray\n#define rot3(D)  D.yz *= rot(1.5); //D.xy*=rot(.1*t); // rotate camera\n    rot3(D1);\n    rot3(D2);                \n    rot3(p);\n    p0 = p;\n    if keyPress(49) D2=D1;                            // key \"1\": force camera 1\n    if keyPress(50) D1=D2;                            // key \"2\": force camera 2\n    for ( l = 0.; c > 0. && t > .01 ; c -= s )        // march scene\n        q = p, _t=t,\n        l += t = map(q),                              // distance to objects\n        i = mix(1.,40./l,m),                          // camera choice interpolation\n     // i = mix(1.,exp(-l/40.),m),                   \n        // l=40  camera D1.  l=infinity  camera D2 if m=1 (fool effect).\n        i = smoothstep(0.,1.,.5+.5*i)*2.-1.,\n        D = mix(D2,D1,i),                             // camera changes with depth\n        p = p0+l*D;                                   // sphere-tracing step\n\n    if ( c > 0. && t>1e-5 && !keyPress(32) ) // --- anti-banding: see  https://www.shadertoy.com/view/wt2fzc\n        c += s * ( 1. - 2.3*t/.01 ),  // pseudo-shading: interpolate between iterations [why this ? + not perfect ]\n        t = min( _t/t*(_t-t), .01 ),  // Taylor series estimation of true distance [ min: because an artifact I don't understand. would be better without ]\n        q = p += t*D, t = map(q);     // go there and reeval, to correct hit point material \n    \n    O = vec4(c);                                      // --- coloring & shading\n    if (c > 0.) t==e \n                ? q = p+t*D+.01*vec3(1,-1,1), d = clamp((map(q)-0.)/.01,0.,1.),// pseudo-diffuse https://iquilezles.org/articles/derivative\n                  O = vec4(c*(.3+.7*d),0,0,0)         // spheres grid\n                :( O.r -= b/30., O.g -= a, O*=O ),    // space fungus\n                O.a = 1.;                             // hit -> opaque\n       else     O -= O;                               // background\n       \n    O = pow( O, vec4(1./2.2) );                       // to sRGB\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flSBzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "ftSBRm", "name": "Coordinate visualization", "author": "fl0a1e", "description": "Coordinate visualization & function image.", "tags": ["2d", "math", "visualization", "net"], "likes": 3, "viewed": 226, "published": 3, "date": "1651898979", "time_retrieved": "2024-07-30T16:49:50.545898", "image_code": "// --------------------------------------------------------\n\n#define S(y,f) smoothstep(f-0.05, f, y)-smoothstep(f, f+.05, y);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv*=8.;\n    \n    vec2 gv = fract(uv)-.5;\n    \n    \n    float y1 = pow(uv.x, -1.);\n    float y2 = pow(uv.x, 2.);        // f(x)=x^2\n    float y3 = pow(uv.x, 3.);        // f(x)=x^3\n    float y4 = sin(uv.x*sin(iTime*0.1)*10.);//noise\n    float y5 = log(uv.x);            // f(x)=ln(x)\n    \n    \n    float m = 0.;\n    m += S(uv.y, y1);\n    m += S(uv.y, y2);\n    m += S(uv.y, y3);\n    m += S(uv.y, y4);\n    m += S(uv.y, y5);\n    \n    \n    vec3 col;\n    col.rg = floor(uv)*.15+0.1;\n    if(gv.x>.48 || gv.y>.48) col=vec3(0.6,0.6,0.6);\n    col += m * vec3(1.,1.,1.);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// --------------------------------------------------------", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftSBRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 184, 184, 870]], "test": "untested"}
{"id": "stBfRz", "name": "PILLAR_GRID", "author": "Yetman", "description": ">>> RENDER  | REPEAT <X, Y> | ROTATION=FUNC(X, Y, TIME) | REPEAT <Z> | PARALLAX", "tags": ["parallax", "shapes"], "likes": 17, "viewed": 379, "published": 3, "date": "1651884143", "time_retrieved": "2024-07-30T16:49:51.350747", "image_code": "#define SPLIT_SIZE 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = vec4(\n        texelFetch(iChannel0, coord - ivec2(SPLIT_SIZE), 0).r,\n        texelFetch(iChannel0, coord                    , 0).g,\n        texelFetch(iChannel0, coord + ivec2(SPLIT_SIZE), 0).b,\n        1.0\n    );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define TILE_SIZE 50.0\n#define ALPHA 0.05\n#define MAX_SCALE 1.75\n#define STEP_COUNT 75\n#define DRIFT_VELOCITY vec2(50.0)\n#define GROOVE_NORMAL vec2(1.0, 1.0)\n#define GROOVE_DEPTH 20.0\n#define GROOVE_WAVELENGTH 7.0\n#define ROT_WAVE_DIR vec2(1.0, 1.0)\n#define ROT_WAVELENGTH 180.0\n#define ROT_WAVE_SPEED 22.5\n#define ROT_PER_WAVE 90.0\n#define ROT_FRACTION 0.2\n\nfloat smooth_staircase(float x, float height, float smoothness){\n    return height * smoothstep(0.0, smoothness, fract(x / height));\n}\n\nfloat layer(in vec2 fragCoord, int level){\n    fragCoord -= iTime * DRIFT_VELOCITY;\n    vec2 tile = floor(fragCoord/TILE_SIZE);\n    vec2 tile_coord = fract(fragCoord/TILE_SIZE) * 2.0 - 1.0;\n    \n    if(level > (STEP_COUNT - int(GROOVE_DEPTH * sin(radians(360.0) / GROOVE_WAVELENGTH * dot(tile, GROOVE_NORMAL))))) \n        return 1.0;\n    \n    float deg = dot(tile, ROT_WAVE_DIR) * 360.0 / ROT_WAVELENGTH + ROT_WAVE_SPEED * iTime;\n    deg = smooth_staircase(deg, ROT_PER_WAVE, ROT_FRACTION);\n    float angle = radians(deg);\n    \n    mat2 rotation = mat2(\n        cos(angle), -sin(angle),\n        sin(angle),  cos(angle)\n    );\n    tile_coord = rotation * tile_coord;\n    \n    float max_norm = max(abs(tile_coord.x), abs(tile_coord.y));\n    float square = smoothstep(0.5 - 2.0 * fwidth(max_norm), 0.5, max_norm);\n    \n    return square;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord -= iResolution.xy  * 0.5;\n    \n    float final = 1.0;\n    \n    float step_size = (MAX_SCALE - 1.0)/float(STEP_COUNT);\n    float scale = MAX_SCALE;\n    \n    for(int level = 1; level < STEP_COUNT; level++){\n        scale -= step_size;\n        vec2 coord = fragCoord * scale;\n        \n        float color = layer(coord, level);\n        \n        final = color * (1.0 - ALPHA) * final + ALPHA * color;\n    }\n    \n    fragColor.rgb = vec3(final);\n    fragColor.a = 1.0;\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stBfRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 79, 79, 347]], "test": "untested"}
{"id": "7tjBRD", "name": "Sheikh1", "author": "smahio", "description": "Enhanced version of audio spectrum.", "tags": ["fft", "visualization", "audio", "audiospectrum"], "likes": 5, "viewed": 496, "published": 3, "date": "1651871096", "time_retrieved": "2024-07-30T16:49:52.245355", "image_code": "\n\nvec4 rectangle(vec4 color, vec4 background, vec4 region, vec2 uv);\nvec4 capsule(vec4 color, vec4 background, vec4 region, vec2 uv);\nvec2 rotate(vec2 point, vec2 center, float angle);\nvec4 bar(vec4 color, vec4 background, vec2 position, vec2 diemensions, vec2 uv);\nvec4 rays(vec4 color, vec4 background, vec2 position, float radius, float rays, float ray_length, sampler2D sound, vec2 uv);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Prepare UV and background\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= aspect;\n    vec4 color = mix(vec4(0.0, 1.0, 0.8, 1.0), vec4(0.0, 0.3, 0.25, 1.0), distance(vec2(aspect/2.0, 0.5), uv));\n    \n    //VISUALIZER PARAMETERS\n    const float RAYS = 96.0; //number of rays //Please, decrease this value if shader is working too slow\n    float RADIUS = 0.4; //max circle radius\n    float RAY_LENGTH = 0.3; //ray's max length //increased by 0.1\n    \n    color = rays(vec4(1.0), color, vec2(aspect/2.0, 1.0/2.0), RADIUS, RAYS, RAY_LENGTH, iChannel0, uv);\n    \n    fragColor = color;\n}\n\nvec4 rays(vec4 color, vec4 background, vec2 position, float radius, float rays, float ray_length, sampler2D sound, vec2 uv)\n{\n    float inside = (1.0 - ray_length) * radius; //empty part of circle\n    float outside = radius - inside; //rest of circle\n    float circle = 2.0*3.14159265359*inside; //circle lenght\n    for(int i = 1; float(i) <= rays; i++)\n    {\n        float len = outside * texture(sound, vec2(float(i)/rays, 0.0)).x; //length of actual ray\n        background = bar(color, background, vec2(position.x, position.y+inside), vec2(circle/(rays*2.0), len), rotate(uv, position, 360.0/rays*float(i))); //Added capsules\n    }\n    return background; //output\n}\n\nvec4 bar(vec4 color, vec4 background, vec2 position, vec2 diemensions, vec2 uv)\n{\n    return capsule(color, background, vec4(position.x, position.y+diemensions.y/2.0, diemensions.x/2.0, diemensions.y/2.0), uv); //Just transform rectangle a little\n}\n\nvec4 capsule(vec4 color, vec4 background,  vec4 region, vec2 uv) //capsule\n{\n    if(uv.x > (region.x-region.z) && uv.x < (region.x+region.z) &&\n       uv.y > (region.y-region.w) && uv.y < (region.y+region.w) || \n       distance(uv, region.xy - vec2(0.0, region.w)) < region.z || \n       distance(uv, region.xy + vec2(0.0, region.w)) < region.z)\n        return color;\n    return background;\n}\n\nvec2 rotate(vec2 point, vec2 center, float angle) //rotating point around the center\n{\n    float s = sin(radians(angle));\n    float c = cos(radians(angle));\n    \n    point.x -= center.x;\n    point.y -= center.y;\n    \n    float x = point.x * c - point.y * s;\n    float y = point.x * s + point.y * c;\n    \n    point.x = x + center.x;\n    point.y = y + center.y;\n    \n    return point;\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 someFunction( vec4 a, float b )\n{\n    return a+b;\n}", "sound_code": "vec2 mainSound( int samp, float time )\n{\n    // A 440 Hz wave that attenuates quickly overt time\n    return vec2( sin(6.2831*440.0*time)*exp(-3.0*time) );\n}", "sound_inputs": [], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0,0.0,1.0,1.0);\n}", "buffer_a_inputs": [], "cube_a_code": "void mainCubemap( out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{\n    // Ray direction as color\n    vec3 col = 0.5 + 0.5*rayDir;\n\n    // Output to cubemap\n    fragColor = vec4(col,1.0);\n}", "cube_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[392, 392, 449, 481, 1091], [1093, 1093, 1218, 1218, 1761], [1763, 1763, 1844, 1844, 2011], [2013, 2013, 2089, 2089, 2404], [2406, 2406, 2492, 2492, 2790]], "test": "untested"}
{"id": "stsBDH", "name": "Testbyme", "author": "abrasaxxx93", "description": "just trying out some things", "tags": ["test"], "likes": 2, "viewed": 224, "published": 3, "date": "1651870894", "time_retrieved": "2024-07-30T16:49:53.048208", "image_code": "#define MAX_DIST 10.\n#define MAX_STEPS 100\n#define HIT_DIST 0.0001\n\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n    return mix(a, b, h) - k*h*(1.0-h);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 hsbColor(float h,float s,float b){\n    clamp(h,0.,1.);\n    clamp(s,0.,1.);\n    clamp(b,0.,1.);\n    \n    float six=6.*h;\n\n    float red;\n    float gre;\n    float blu;\n    if(six<3.){\n        if(six<1.){\n            red=1.;\n            gre=six;\n            blu=0.;\n        }\n        else if(six<2.){\n            red=2.-six;\n            gre=1.;\n            blu=0.;\n        }\n        else{\n            red=0.;\n            gre=1.;\n            blu=six-2.;\n        }\n    }\n    else{\n        if(six<4.){\n            red=0.;\n            gre=4.-six;\n            blu=1.;\n        }\n        else if(six<5.){\n            red=six-4.;\n            gre=0.;\n            blu=1.;\n        }\n        else{\n            red=1.;\n            gre=0.;\n            blu=6.-six;\n        }\n    }\n    red=1.-s*(1.-red);\n    gre=1.-s*(1.-gre);\n    blu=1.-s*(1.-blu);\n\n    red*=b;\n    gre*=b;\n    blu*=b;\n\n    return vec3(red,gre,blu);\n\n}\n\nfloat r(vec2 p){\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat dCuboid(vec3 pos,vec3 s,vec3 p){\n    p-=pos;\n    return length(max(abs(p)-s,0.));\n}\n\nfloat dSphere(vec3 pos,float r,vec3 p){\n    return length(p-pos)-r;\n}\n\nfloat dTriangle(vec3 a, vec3 b, vec3 c ,vec3 p){\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat dCapsule(vec3 a, vec3 b, float r, vec3 p){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat dWing(vec3 pos,float s,vec3 p){\n    float d=dTriangle(pos-vec3(-s/16.,0,0),pos-vec3(s/4.,0,0),pos-vec3(-s/16.,0,-s/1.5),p);\n    d=min(d,dTriangle(pos-vec3(s/8.,0,-s/1.5),pos-vec3(s/4.,0,0),pos-vec3(-s/16.,0,-s/1.5),p));\n    d=min(d,dCapsule(pos-vec3(s/8.,0,-s/1.5),pos-vec3(-s/16.,0,-s/1.5),s/64.,p));\n    return d;\n}\n\nfloat dAirPlane(vec3 pos,float s,vec3 p){\n    p.z=abs(p.z);\n    float d=dCapsule(pos+vec3(s/4.,0,0),pos-vec3(s/4.,0,0),s/16.,p);\n    d=min(d,dWing(pos,s,p));//frontwings\n    d=min(d,2.);\n    return d;\n}\n\nfloat dTerrain(vec3 pos,vec3 p){\n    p-=pos;\n    int o=0;\n    float r=pow(.5,float(o))*.25;\n    float dSpheres=length(p-vec3(0,0,0))-r;\n    return max(dSpheres,dCuboid(vec3(0,.25,0),vec3(.5,.25,.5),p));\n}\n\nfloat sdf(vec3 p){\n    float dCube=dCuboid(vec3(0,0,0),vec3(.5),p);\n    //float dAP=dAirPlane(vec3(0,1.5+.125*sin(iTime),0),1.,p);\n    float dTerr=dTerrain(vec3(0,.5,0),p);\n    return min(dCube,dTerr);\n}\n\nvec3 normal(vec3 p){\n    vec2 h=vec2(0.000001,0.);\n    return normalize(vec3(sdf(p+h.xyy)-sdf(p-h.xyy),sdf(p+h.yxy)-sdf(p-h.yxy),sdf(p+h.yyx)-sdf(p-h.yyx)));\n}\n\nfloat light(vec3 lo,vec3 n,vec3 p){\n    return max(dot(normalize(lo-p),n),0.);\n}\n\nfloat rayMarch(vec3 ro,vec3 rd){\n    float t=0.;\n    float dt=0.;\n    int steps=0;\n    vec3 p=ro;\n    do{\n        t+=dt;\n        p+=dt*rd;\n        dt=sdf(p);\n        steps++;\n    }while(dt>=HIT_DIST&&t<MAX_DIST&&steps<MAX_STEPS);\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(2.*fragCoord/iResolution.yy)-vec2(iResolution.x/iResolution.y,1.);\n    \n    vec3 ro=vec3(2.,2.,2.);\n    float zoom=.5;\n    vec3 lookat=vec3(0.);\n    vec3 rd=normalize(lookat-ro);\n    vec3 right=cross(vec3(0.,1.,0.),rd);\n    vec3 up=cross(rd,right);\n    ro+=(uv.x*right+uv.y*up)/zoom;\n    \n    vec3 col=vec3(0);\n    float d=rayMarch(ro,rd);\n    if(d<MAX_DIST){\n        vec3 p=ro+d*rd;\n        vec3 n=normal(p);\n\n        //point light\n        vec3 lo=vec3(3.,3.,3.);\n        float li=light(lo,n,p);\n\n\n        col=vec3(5.*li/(d*d));\n        //col-=vec3(smoothstep(.45,.5,abs(fract(10.*p.y)-.5)));\n    }\n    fragColor=vec4(col,1.);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsBDH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 108, 108, 199], [201, 201, 226, 226, 245], [247, 247, 286, 286, 1154], [1156, 1156, 1172, 1172, 1241], [1243, 1243, 1281, 1281, 1332], [1334, 1334, 1373, 1373, 1403], [1405, 1405, 1453, 1453, 1950], [1952, 1952, 2000, 2000, 2121], [2123, 2123, 2160, 2160, 2446], [2448, 2448, 2489, 2489, 2650], [2652, 2652, 2684, 2684, 2856], [2858, 2858, 2876, 2876, 3061], [3063, 3063, 3083, 3083, 3222], [3224, 3224, 3259, 3259, 3304], [3306, 3306, 3338, 3338, 3551], [3553, 3553, 3610, 3610, 4263]], "test": "untested"}
{"id": "stjBzW", "name": "Glossy Effect Test 4615", "author": "SnoopethDuckDuck", "description": "Maybe a bit sloppy\n\nYou can get lots of cool effects by fiddling with the exponent in mx.\n\n(any sharp lines you see are from how the shape is constructed, not the glossy effect)\n", "tags": ["e"], "likes": 3, "viewed": 238, "published": 3, "date": "1651870811", "time_retrieved": "2024-07-30T16:49:53.810171", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define pi 3.14159\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 4.;\n    float t = 0.2 * iTime;\n\n    vec3 ro = vec3(r * cos(t), 1.5 * cos(0.8 * t), r * sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = sdBox(p, vec3(0.9)) - 0.1;\n\n    vec3 fr = 0.5 * p - floor(0.5 * p) - 0.5;  \n    float val = exp(-20. * length(fr)) * smoothstep(-0.5, 0.5, -mlength(p) + 1.15);\n    \n    fr = p - floor(p) - 0.5;  \n    val += exp(-10. * length(fr)) * smoothstep(-0.5, 0.5, -mlength(p) + 1.15);\n    \n    val = clamp(val, 0., 1.);\n    \n    d -= 10. * val;\n    \n    return 0.25 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        \n        // Change me\n        float c = 2.5; // [0.6,6] is an okay range (<1 is like fresnel)\n        float I = 4.; // anything above 0. lower numbers more intense\n        \n        // Removing anything here looks interesting too\n        // (or switching the order of r,n)\n        r = c * (abs(r)-abs(n));\n        n = c * (abs(r)-abs(n));\n        \n        float mx = exp(-I * length(abs(r)-abs(n)));\n        \n        float cl = 0.5 + 0.5 * dif + mx;\n\n        vec3 e = vec3(0.5);\n        vec3 col2 = pal(mlength(p) + 0.35, e, e, e, vec3(0,1,2)/3.);\n        \n        col = cl * col2;\n    }\n    \n   \n    // col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stjBzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 88, 154, 154, 197], [199, 199, 223, 223, 279], [281, 281, 310, 310, 391], [393, 393, 407, 407, 641], [643, 643, 666, 666, 1043], [1045, 1045, 1088, 1088, 1394], [1396, 1396, 1420, 1420, 1610], [1612, 1612, 1662, 1662, 1853], [1855, 1855, 1912, 1912, 2992]], "test": "untested"}
{"id": "fljBRW", "name": "Surface Lines", "author": "Dragonpeak", "description": "Just a quick test of using fwidth for isolines and a cool pseudo 3d effect", "tags": ["noise", "isolines", "contourlines"], "likes": 16, "viewed": 353, "published": 3, "date": "1651863266", "time_retrieved": "2024-07-30T16:49:54.561163", "image_code": "//Just a quick test of using fwidth for isolines and a cool pseudo 3d effect\nconst int SLICES = 50;\nconst float SURF = .6;\nconst float WID = 1.1;\n#define t iTime*.1\nuvec3 pcg3d(uvec3 v) \n{\n    //from https://www.shadertoy.com/view/XlGcRh\n    v = v * 1664525u + 1013904223u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    v ^= v >> 16u;\n\n    v.x += v.y*v.z;\n    v.y += v.z*v.x;\n    v.z += v.x*v.y;\n\n    return v;\n}\nvec3 Rand3D(vec3 v)\n{\n    return vec3(pcg3d(uvec3(v)))/float(0xffffffffu);\n}\n\nfloat Noise3D(vec3 p)\n{\n    p+=iDate.z*100.;\n    vec3 ap = abs(p);\n    vec3 fr = fract(ap);\n    fr = fr * fr * (3. - 2. * fr);\n    \n    float a = Rand3D(ap).x;\n    float b = Rand3D(ap+vec3(1,0,0)).x;\n    float c = Rand3D(ap+vec3(0,1,0)).x;\n    float d = Rand3D(ap+vec3(1,1,0)).x;\n    \n    float e = Rand3D(ap+vec3(0,0,1)).x;\n    float f = Rand3D(ap+vec3(1,0,1)).x;\n    float g = Rand3D(ap+vec3(0,1,1)).x;\n    float h = Rand3D(ap+vec3(1,1,1)).x;\n\n    float v = mix(mix(mix(a,b, fr.x),mix(c,d,fr.x), fr.y), mix(mix(e,f, fr.x),mix(g,h,fr.x), fr.y), fr.z);\n    \n\n    \n\n    return v;\n}\n\n\nfloat DrawSlice(vec3 p)\n{\n    p.xy+= vec2(Noise3D(p*5.+5151.51), Noise3D(p*5.-625.83))*.2-.1;\n    float d = Noise3D(vec3(p.xy, p.z*.1)*15.)-Noise3D(p*30.)*.3-Noise3D(p*90.)*.1;\n    d*= smoothstep(0., .3, 1.-length(p.xy)*3.4);\n    return max(-(abs(d-SURF)/fwidth(d)-WID), 0.);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.x-vec2(.5,iResolution.y/iResolution.x/2.))*vec2(1,-3.);\n    \n    float shape = 0.;\n    for(int i = 0; i < SLICES; i++)\n    {\n        float off = float(i)/float(SLICES);\n        vec2 uv2 = vec2(uv.x, uv.y-off+.5);\n        shape += DrawSlice(vec3(mat2(cos(t), -sin(t), sin(t), cos(t))*uv2, off))*min(uv2.y+.6,1.);\n    }\n    \n    vec3 col = mix(vec3(.9), vec3(0.3), clamp(shape, 0., 1.));\n\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fljBRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 188, 237, 432], [433, 433, 454, 454, 509], [511, 511, 534, 534, 1091], [1094, 1094, 1119, 1119, 1371], [1374, 1374, 1431, 1431, 1889]], "test": "untested"}
{"id": "fl2BzW", "name": "Ferrofluid thing 8571", "author": "SnoopethDuckDuck", "description": "Really like the shine on this, its maybe too dark", "tags": ["spooky"], "likes": 5, "viewed": 341, "published": 3, "date": "1651861019", "time_retrieved": "2024-07-30T16:49:55.413883", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n/*\nvec3 test(vec2 uv) {\n   uv *= 4.;\n   uv -= floor(uv);\n   return smoothstep(-0.2, 0.2, -abs(abs(uv.y - uv.x) - uv.x) + 0.2) * vec3(1);\n}\n*/\n\nvec3 test(vec2 uv) {\n   uv *= 4.;\n   float s = exp(-length(uv));\n   return vec3(s);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 14.5;\n    float t = 0.1 * iTime;\n\n    vec3 ro =  vec3(r * cos(t), 2. * cos(5. * t), r * sin(t));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float d = length(p) - 2.125 * sqrt(2.);\n    \n    float c = cos(0.5 * p.y - 0.125 * length(p.xz) + iTime);\n    \n   // d = sabs(p.y) - 0.2 * cos(0.25 * length(p) - iTime);\n    p.xz *= 1. + 0.25 * c;\n    float val = 0.;\n    float m = 0.45;// - 0.4 * cos(0.2 * p.y + iTime);\n    for (float i = 0.; i < 3.; i++) {\n        vec3 fr = m * p - floor(m*p + 0.5);//fract(m*p) - 0.5;\n        \n        val += exp(7.5 * m - m * dot(p,p) - exp(.75 * p.y) - 25. * dot(fr,fr));\n        val = clamp(val, 0., 1.);\n        m *= (2. + c) * sqrt(2.);\n    }\n   \n    d -= mix(20., 400., 0.5 + 0.5 * c) * val;\n    //d -= 1. * smoothstep(-0.5, 0.5, -2. * val + 0.25);\n    \n    float d2 = length(p - getRo()) - 0.5;\n    d = -smin(-d, d2);\n    //d = max(d, length(p) - 2. * dr);\n    \n    return 0.08 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 2.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1);\n        \n        float fres = pow(1. + dot(rd, n), 3.);\n        float v = dot(abs(n), abs(r));\n        vec3 e = vec3(0.5);\n        //col *= pal(n.y, e, e, e, 0.4 * vec3(0,1,2)/3.);\n        //n = n;\n        float sc = 1.5;\n        vec3 c1 = test(sc * (r.xz * 0. - n.xz)).rgb;\n        vec3 c2 = test(sc * (r.yx * 0. - n.yz)).rgb;\n        vec3 c3 = test(sc * (r.zy * 0. - n.zy)).rgb;\n        col= vec3(dif);\n        \n        vec3 q = 1.-abs(p);\n        //p *= (1.-p) * 4.;\n        q = clamp(q, -0.2, 1.);\n        vec3 c = q.z * c1 + q.x * c2 + q.y * c3;\n        col *= 4.*c;\n        vec3 col2 = pal(1.5, c, c, e, 0.5 * vec3(0,1,2)/3.);\n        col *= col2;\n        col = mix(col, vec3(0.01), fres * (1. - exp(3.2 - 1. * length(p))));\n        \n    }\n    col *= 24.;\n   \n    col = clamp(col,0.,1.);\n    vec3 e = vec3(0.5);\n    \n    //col *= 4. * pal(0.125 * p.y + 0.25 * sfloor(4., iTime), e, e, e, 0.5 * vec3(0,1,2)/3.);\n    //col *= 8. * (1. + thc(4., 40. * length(p.xz) + iTime));\n    //if (length(p) > 0.5)\n      //  col = vec3(0);\n    col *= clamp(exp(3.2-1. * length(p)),0.,1.);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define sfloor(a,b) (floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a))\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/fl2BzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 231, 231, 296], [353, 353, 383, 383, 459], [461, 461, 499, 499, 564], [566, 566, 585, 585, 668], [670, 670, 699, 699, 780], [782, 782, 796, 796, 1031], [1033, 1033, 1056, 1056, 1839], [1841, 1841, 1884, 1884, 2191], [2193, 2193, 2217, 2217, 2407], [2409, 2409, 2459, 2459, 2650], [2652, 2652, 2709, 2709, 4537]], "test": "untested"}
{"id": "NljfRD", "name": "multiscale bump", "author": "FabriceNeyret2", "description": "variant of Patterson 2004 \"resolution bumping\".  better seen fullscreen.\nleft:          basic bump  :  globally very flat.\nbottom:    bump(LoD)\ntop right: multiscale bump:  weight of LoD i = (1+i)^m    Mouse.x  : m = -2...2", "tags": ["shading", "bumpmapping", "multiscale", "short"], "likes": 8, "viewed": 323, "published": 3, "date": "1651856039", "time_retrieved": "2024-07-30T16:49:56.209755", "image_code": "// generalizing http://www.shadedrelief.com/bumping/bumping.html\n\n#define T(l)    texture( iChannel0, U, l ).r\n\n#define bump(l) dot( vec2( dFdx(v=T(l)), dFdy(v) ),   /* bump */           \\\n                     cos(iTime+vec2(0,11) )           /* shading(ligth) */ \\\n                   ) * exp2(l)                        /* emulate level resol */\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*u/R; \n    \n    \n    float v, w, s=0., i, c=0.,\n          m = iMouse.z>0. ? 4.*(iMouse.x/R.x-.5) : -2.;\n    \n    if (int(u)==int(R)/2)                 { O=vec4(1,0,0,0); return; } //red separators\n    if (int(u.y)==int(.3*R.y))            { O=vec4(1,0,0,0); return; }\n    if (U.y<.6 &&int(u)%(int(R)/8)==0)    { O=vec4(1,0,0,0); return; }\n    \n    if (U.y<.6) { O = vec4( .5 + 2.*bump(floor(4.*U.x)) ); return; } // bottom: bump(LoD)\n    if (U.x<1.) { O = vec4( .5 + 2.*bump(0.) ); return; }            // left: basic bump\n    \n    for( i=0.; i < 8.; i++) {             // top: multiscale bump.\n        s += w = pow(1.+i,m);\n        c += w * bump(i);\n    }\n    O = vec4( .5 + 2.*c/s );\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "7lSBzD", "name": "sin_sum", "author": "makscee", "description": "random sum of a buch of waves", "tags": ["2d", "waves", "wave", "sin"], "likes": 3, "viewed": 277, "published": 3, "date": "1651844212", "time_retrieved": "2024-07-30T16:49:57.024576", "image_code": "\nfloat rand(int i)\n{\n    return fract(sin(dot(vec2(i,0.) ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec4 alphaBlend(vec4 c1, vec4 c2)\n{\n    return vec4(\n        mix(c1.r, c2.r, c2.a),\n        mix(c1.g, c2.g, c2.a),\n        mix(c1.b, c2.b, c2.a),\n        clamp(max(c1.a, c2.a) + c1.a * c2.a, 0., 1.));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    const float thickness = 2.5;\n    const int sinCount = 20;\n    const int shadowCount = 20;\n\n    const vec3 lineColor = vec3(0.117, 0.564, 1);\n    \n    fragCoord -= iResolution.xy / 2.0;\n    vec2 uv = fragCoord/iResolution.x*20.0;\n    uv = (uv + vec2(500,0)) * vec2(1500, 76);\n\n    float value = 0.;\n    float t = iTime / 150.;\n    const float mixInfl = 0.0009;\n    const float startInfl = 15.;\n    for (int i = 0; i < sinCount; i++)\n    {\n        float rk = mix(rand(int(t) + i) * mixInfl, rand(int(t) + 1 + i) * mixInfl, fract(t));\n        value += sin(uv.x * rk * 1.5) * rand(i + 1) * startInfl;\n    }\n    vec4 col = vec4(0);\n    for (int i = -shadowCount; i <= shadowCount; i++)\n        col = alphaBlend(col, vec4(lineColor, 0.12 * float(abs(value - uv.y) < thickness * float(i) * 15.)));\n\n    fragColor = vec4(0);\n    fragColor = alphaBlend(fragColor, col);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 20, 20, 97], [99, 99, 134, 134, 301], [303, 303, 358, 358, 1225]], "test": "untested"}
{"id": "7lBBRD", "name": "Bauble Space 29", "author": "SnoopethDuckDuck", "description": "Same techniques as forked, fun to play around with", "tags": ["spooky"], "likes": 12, "viewed": 361, "published": 3, "date": "1651843557", "time_retrieved": "2024-07-30T16:49:57.780555", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\nvec3 test2(vec2 uv) {\n    uv -= floor(uv + 0.5);\n    float d = 9. * cos(abs(uv.y) + abs(uv.x) + 2. * cos(length(uv) + 0.25 * 3.14159));  \n    vec3 e = vec3(0.5);   \n    return pal(d, e, e, e, 0.35 * vec3(0,1,2)/3.);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    float r = 7.5;\n    float t = 0.1 * iTime;\n\n    vec3 ro =  vec3(r * cos(t), 1. * cos(0.4 * t), r * sin(t));\n    //ro.yz *= rot(-m.y*3.14+1.);\n    //ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    //p.xz *= rot(p.y - 0.2 * iTime);\n\n    float d = length(p) - 2.;\n    //d = length(p.xz) - 1.- exp(0.4 * sabs(p.y));\n    //float d = sdBox(p, vec3(0.75)) - 1.;\n   //   \n  \n    \n    vec2 rp = getRo().xz - p.xz;\n    float dr = length(rp);\n    //float a = atan(rp.x, rp.y);\n  \n    float val = 0.;\n    float m = 0.45;// - 0.4 * cos(0.2 * p.y + iTime);\n    for (float i = 0.; i < 6.; i++) {\n        vec3 fr = m * p - floor(m*p + 0.5);//fract(m*p) - 0.5;\n        val += exp(4. + 0. * cos(0.2 * p.y + iTime) -val * 16.- 0.15 * m * length(p) - 13. * length(fr));\n        m *= 1.5;\n    }\n    \n    float fo = exp(-0.5 * length(p));\n    d -= 1. * val;\n    \n    float d2 = length(p - getRo()) - 0.5;\n    d = -smin(-d, d2);\n    d = max(d, length(p) - 1. * dr);\n    //d = -smin(d,-d2);\n    return 0.08 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1);\n        \n        float fres = pow(1. + dot(rd, n), 3.);\n        float v = dot(abs(n), abs(r));\n        vec3 e = vec3(0.5);\n        //col *= pal(n.y, e, e, e, 0.4 * vec3(0,1,2)/3.);\n        n = 0.98 + 0.05 * n;;\n        vec3 c1 = test2(n.xz).rgb;\n        vec3 c2 = test2(n.yx).rgb;\n        vec3 c3 = test2(n.zy).rgb;\n        \n        vec3 q = 1.-abs(p);\n        //p *= (1.-p) * 4.;\n        q = clamp(q, -0.2, 1.);\n        vec3 c = q.z * c1 + q.x * c2 + q.y * c3;\n        col *= c;\n        vec3 col2 = pal((1./3.) * sfloor(40., 0.5 * log(length(p)) - 0.8 * iTime), c, c, e, 0.5 * vec3(0,1,2)/3.);\n        col *= col2;\n        col = mix(col, vec3(0.1), fres * (1. - exp(3.2 - 1. * length(p))));\n    }\n    col = clamp(col,0.,1.);\n    //if (length(p) > 0.5)\n      //  col = vec3(0);\n    col *= clamp(exp(3.2-1. * length(p)),0.,1.);\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n#define sfloor(a,b) (floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a))\n\nfloat test(in vec2 uv, float res)\n{\n    uv -= floor(uv) + 0.5;\n\n    float k = 10. / res;\n    float m = 0.25;\n    \n    float d = length(uv);\n    float s = smoothstep(-k, k, -length(uv) + m);\n       \n    for (int i = 0; i < 6; i++) {\n        uv = abs(uv) - m;\n        m *= 0.5;\n        s = max(s, smoothstep(-k, k, -length(uv) + m));\n    }\n    \n    return s;\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lBBRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 89, 89, 285], [342, 342, 372, 372, 448], [450, 450, 488, 488, 553], [555, 555, 574, 574, 657], [659, 659, 688, 688, 769], [771, 771, 785, 785, 1020], [1022, 1022, 1045, 1083, 1843], [1845, 1845, 1888, 1888, 2195], [2197, 2197, 2221, 2221, 2411], [2413, 2413, 2463, 2463, 2654], [2656, 2656, 2713, 2713, 4288]], "test": "untested"}
{"id": "NtSBzD", "name": "Net-2D", "author": "fl0a1e", "description": "net\nrefer to https://www.youtube.com/watch?v=3CycKKJiwis&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=19", "tags": ["2d", "noise"], "likes": 13, "viewed": 516, "published": 3, "date": "1651840383", "time_retrieved": "2024-07-30T16:49:58.618315", "image_code": "// \n// refer to https://www.youtube.com/watch?v=3CycKKJiwis&list=PLGmrMu-IwbguU_nY2egTFmlg691DN7uE5&index=19\n// \n\n\n// return the distance from point uv to the line ab.\nfloat distLine2D(vec2 uv, vec2 a, vec2 b) {\n    vec2 uv_a = uv - a;\n    vec2 ab = b - a;\n    float t = clamp(dot(uv_a, ab)/dot(ab, ab), 0., 1.);  //t is the proportion of projection (line uv_a) to line ab.\n    return length(uv_a - t * ab);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b){\n    float d = distLine2D(p, a, b);\n    float m = smoothstep(0.03, 0.01, d);\n    m *= smoothstep(1.6, 0.0, length(b-a))+smoothstep(0.09, 0.04, abs(length(b-a)-0.75)); // if length(b-a) > 1.5, return 0.\n    return m;\n}\n\n// noise 0~1\n// you can try this function \"fract(cos(x*375.3434134)*0.3245*25.1247)\" in https://graphtoy.com/ to understand it.\nfloat noise21(vec2 p){\n    //p = fract(p * vec2(556.0862, 298.5618));\n    //p += dot(p, p + 25.34);     //cos() in here\n    //return fract(p.x*p.y);\n    float noi = fract(sin(dot(p, vec2(124.4134, 514.43123)))*556.0862);\n    return noi;\n    \n}\n\nvec2 noise22(vec2 p){\n    float n = noise21(p);\n    return vec2(n, noise21(p+n));\n}\n\n\nvec2 getPos(vec2 id, vec2 off){\n    vec2 n = noise22(id+off)*(iTime+16.1616);\n    return off+sin(n)*.4;\n}\n\n\nfloat layer(vec2 uv){\n    vec2 gv = fract(uv)-0.5;//\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y = -1.; y <= 1.; y++){\n        for(float x = -1.; x <= 1.; x++){\n            p[i++] = getPos(id, vec2(x,y));\n        }\n    }\n    \n    \n    float m = 0.;\n    for(int i = 0; i < 9; i++){\n        m += line(gv, p[4], p[i]);\n        \n        // spark\n        vec2 d = (p[i] - gv)*40.;\n        m += (1./dot(d, d))*(sin(p[i].x*10.+iTime*5.)*.5+.5);\n    }\n    m += line(gv, p[1], p[3]);\n    m += line(gv, p[1], p[5]);\n    m += line(gv, p[3], p[7]);\n    m += line(gv, p[5], p[7]);\n    \n    return m;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    \n    uv*=10.;\n    \n    \n    float m = 0.;\n    for(float i = 0. ; i < 1.;i += 1./4.){\n        float z = fract(i+iTime*.3);\n        float size = mix(1.5, .5, z);\n        float fade = smoothstep(0., .2, z);\n        m += layer(uv*size+i*20.) * fade;\n    }\n    \n    \n    vec3 col = vec3(0.);\n    vec3 base = sin(iTime*vec3(.234325, .398579, .53783))*.5+.5;\n    col += vec3(m)*base;\n    col += uv.y*0.08*base;\n    \n    // ----------------------\n    // vec2 gv = fract(uv)-0.5;\n    // col.gb = gv.xy;\n    // if(gv.x>.48|| gv.y>.48)col=vec3(1., 0., .0);\n    // --------------------------------------------\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtSBzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[115, 168, 211, 211, 409], [411, 411, 446, 446, 663], [665, 793, 815, 941, 1036], [1038, 1038, 1059, 1059, 1121], [1124, 1124, 1155, 1155, 1229], [1232, 1232, 1253, 1253, 1852], [1855, 1855, 1912, 1912, 2619]], "test": "untested"}
{"id": "st2fz1", "name": "Radar shader with sound", "author": "pancakespeople", "description": "A radar screen just like in the movies.", "tags": ["grid", "radar"], "likes": 3, "viewed": 309, "published": 3, "date": "1651809693", "time_retrieved": "2024-07-30T16:49:59.441115", "image_code": "mat2 rotate(float angle) {\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, -s, s, c);\n}\n\nfloat ring(float uvRadius, float ringRadius) {\n    return smoothstep(ringRadius - 0.01, ringRadius, uvRadius) * smoothstep(ringRadius + 0.01, ringRadius, uvRadius);\n}\n\nfloat grid(vec2 uv) {\n    if (fract(uv.x * 10.0) < 0.01) return 1.0;\n    if (fract(uv.y * 10.0) < 0.01) return 1.0;\n    return 0.0;\n}\n\nvec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\nfloat circle(vec2 uv, vec2 pos, float radius) {\n    return smoothstep(radius, 0.0, length(uv-pos));\n}\n\nfloat circle2(vec2 uv, vec2 pos, float radius) {\n    return radius*0.1 / length(uv-pos);\n}\n\nfloat randomSin(float t) {\n    return sin(t*0.2352)*sin(t*1.5843)*sin(t*1.2968)+1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    float radius = length(uv);\n    vec3 col = vec3(0.0);\n    float angle = mod(iTime, 3.14159*2.0) - 3.14159;\n    \n    col += ring(radius, 0.1); \n    col += ring(radius, 0.25);\n    col += ring(radius, 0.4);\n    \n    col += smoothstep(0.01, 0.0, uv.x-uv.y) * smoothstep(-0.01, 0.0, uv.x-uv.y);\n    col += smoothstep(0.01, 0.0, -uv.x-uv.y) * smoothstep(-0.01, 0.0, -uv.x-uv.y);\n    \n    col += grid(uv) * smoothstep(0.4, 0.39, radius);\n\n    vec3 radarColor = mix(vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), smoothstep(0.7, 0.8, fract(iTime/10.0)) * smoothstep(1.0, 0.9, fract(iTime/10.0)));\n    col *= radarColor;\n    \n    for (int i = 0; i < 15; i++) {\n        vec2 pos = random2(vec2(i, i))*0.25;\n        float itemAngle = atan(pos.y, -pos.x);\n        float size = (mod(-(angle - itemAngle), 3.14159*2.0)-2.0) / 30.0 * randomSin(float(i)+50.0);\n        \n        if (size > 0.0) {\n            vec3 dotColor = vec3(0.0, 0.5, 1.0);\n            if (randomSin(float(i)) > 1.0) {\n                dotColor = vec3(1.0, 0.0, 0.0);\n            }\n            \n            col += circle2(uv, pos, size) * dotColor;\n        }\n    }\n    \n    uv *= rotate(iTime);\n    \n    if (uv.y > 0.0 && uv.x > 0.0) {\n        col += vec3(smoothstep(radius / 5.0, 0.0, uv.y)) * smoothstep(0.4, 0.39, radius) * radarColor;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "vec2 random2(vec2 st) {\n\tst = vec2(dot(st, vec2(127.1, 311.7)),\n\t\tdot(st, vec2(269.5, 183.3)));\n\treturn -1.0 + 2.0 * fract(sin(st) * 43758.5453123 * 0.7897);\n}\n\nfloat randomSin(float t) {\n    return sin(t*0.2352)*sin(t*1.5843)*sin(t*1.2968)+1.0;\n}\n\nvec2 mainSound( int samp, float time )\n{\n    float angle = mod(time, 3.14159*2.0) - 3.14159;\n    float sound = 0.0;\n    \n    for (int i = 0; i < 15; i++) {\n        vec2 pos = random2(vec2(i, i))*0.25;\n        float itemAngle = atan(pos.y, -pos.x);\n        float objSound = (mod(-(angle - itemAngle)/2.0, 3.14159*2.0));\n        if (objSound > 6.0) //sound = objSound * 5.0; \n        sound = smoothstep(6.0, 7.0, objSound)*15.0;\n    }\n    \n    return vec2( sin(sound*440.0));\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/st2fz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 110], [112, 112, 158, 158, 278], [280, 280, 301, 301, 413], [415, 415, 438, 438, 574], [576, 576, 623, 623, 677], [679, 679, 727, 727, 769], [771, 771, 797, 797, 857], [859, 859, 916, 916, 2311]], "test": "untested"}
{"id": "7l2BRh", "name": "MyFirstRayMarcher", "author": "TheKraai", "description": "wish me luck.\n\nv2: added smoothTexture", "tags": ["raymarching", "metaballs", "reflections"], "likes": 6, "viewed": 312, "published": 3, "date": "1651793841", "time_retrieved": "2024-07-30T16:50:00.226017", "image_code": "// yes, I know things like Camera Matrices and Quaternions exist..\n// but this is just how the math lives in my head..\n\nconst float CAM_FOV = 2.0;        // field of view\nconst vec3 CAM_POS = vec3(0);     // coordinates of camera\nconst vec3 CAM_DIR = vec3(0,0,-1); // unit vector pointing in cam direction\nconst vec3 CAM_UP  = vec3(0,1,0); // unit vector pointing up\nconst vec3 CAM_RIGHT = cross(CAM_DIR, CAM_UP);\n\nfloat sceneSDF( vec3 pos ) {\n   float sdf = 1e10;\n\n   //sdf = min(sdf, sphereSDF(pos, vec3(0,0,-10), 4.));\n   //sdf = min(sdf, sphereSDF(pos, vec3(3,0,-5), 1.));\n   \n   const int balls = 12;\n   for (int i=0; i<balls; i++) {\n       float seed = mod(float(i)/float(balls) + 0.003 * iTime, 6.28318);\n       vec2 seedvec = 0.4 * vec2(cos(seed), sin(seed)) + vec2(0.5);\n       //vec3 r = texture(iChannel0, seedvec).xyz; // very choppy on slow speeds!\n       vec3 r = smoothTexture(iChannel0, iChannelResolution[0].xy, seedvec).xyz;\n       r.x = mix(-8.,8.,r.x);\n       r.y = mix(-8.,8.,r.y);\n       r.z = -mix(5.,20.,r.z);\n       sdf = smin(sdf, sphereSDF(pos, r, 1.5), 2.);\n   }\n\n   return sdf;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n\n\n    // CALCULATE DIRECTION OF RAY\n\n    vec2 angle_offset = CAM_FOV * (fragCoord - iResolution.xy / 2.) / iResolution.xx; \n    vec3 ray  = CAM_DIR;\n         ray += angle_offset.x * CAM_RIGHT;\n         ray += angle_offset.y * CAM_UP;\n    ray = normalize(ray);\n    \n    \n    vec3 pos = CAM_POS;\n    vec3 normal;\n    fragColor = vec4(0,0,0,1);\n    \n    float part = 1.;\n\n\n    for (int i=0; i<40; i++) {\n\n        // MARCH FORWARD\n        float dist = sceneSDF(pos);\n        pos += ray * dist;\n\n        if (dist < 0.01) {\n            // GET NORMAL\n\n            vec2 eps = vec2(0.01,0);\n\n            normal.x = sceneSDF( pos + eps.xyy ) - sceneSDF( pos - eps.xyy );\n            normal.y = sceneSDF( pos + eps.yxy ) - sceneSDF( pos - eps.yxy );\n            normal.z = sceneSDF( pos + eps.yyx ) - sceneSDF( pos - eps.yyx );\n            normal = normalize(normal);\n\n            // REFLECT\n\n            vec3 color = (normal + 1.) / 2.;\n            // color = texture(iChannel1, color.xy).xyz; // use your camera!\n            fragColor.rgb += part * color;\n\n            ray = reflect(ray, normal);\n            pos += 0.02 * ray;\n            \n            part *= 0.3;\n        }\n    }\n}", "image_inputs": [{"id": 16, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float sphereSDF( vec3 pos, vec3 center, float radius )\n{\n    return length(center - pos) - radius;\n}\n\n// this function is from https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\n// like 'texture', but with my own interpolation filter based on smoothstep.\nvec4 smoothTexture(sampler2D channel, vec2 res, vec2 pos) {\n  ivec2 ipos = ivec2(pos * res - vec2(.5));\n  vec4 tl = texelFetch(channel, ipos + ivec2(0,0), 0);\n  vec4 tr = texelFetch(channel, ipos + ivec2(1,0), 0);\n  vec4 bl = texelFetch(channel, ipos + ivec2(0,1), 0);\n  vec4 br = texelFetch(channel, ipos + ivec2(1,1), 0);\n  vec2 d = smoothstep(0., 1., fract(pos * res - vec2(.5)));\n  vec4 a = mix(tl, tr, d.x);\n  vec4 b = mix(bl, br, d.x);\n  vec4 c = mix(a, b, d.y);\n  return c;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2BRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[415, 415, 443, 443, 1108], [1110, 1110, 1167, 1204, 2343]], "test": "untested"}
{"id": "NljfRh", "name": "Squares All Sliding About", "author": "DJDoomz", "description": "Funky little effect. Mess with the params in Buffer A\nHigh number of squares + fast wiggle time gives a cool watery effect.\n\n#define SQUARES 45.0\n#define WIGGLE 45.0", "tags": ["2d", "texture", "feedback"], "likes": 5, "viewed": 404, "published": 3, "date": "1651772313", "time_retrieved": "2024-07-30T16:50:01.360983", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    fragColor = texture(iChannel0, fragCoord/iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define SQUARES 14.0\n#define WIGGLE 24.\n#define SPEED 1.4\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\nvoid mainImage( out vec4 O, in vec2 u )\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = u/iResolution.xy;\n    \n    vec2 a = hash22(floor(uv*SQUARES) + floor(WIGGLE*iTime))-.5;\n    a *= SPEED;\n    \n    if (u==R-.5) { O.a = iChannelResolution[1].x; return; }\n    if ( iFrame <= 60 || texture(iChannel1, 1.-.5/R, 0. ).a == 0. ) {\n        O = texture(iChannel1, uv);\n    }\n    else\n    {\n        O = texture(iChannel0, uv+a/R.xy);\n    }\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NljfRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 171]], "test": "untested"}
{"id": "7lSBz1", "name": "Death Cheese", "author": "SnoopethDuckDuck", "description": "a few artifacts from overstepping, cant seem to get rid of", "tags": ["spooky"], "likes": 16, "viewed": 312, "published": 3, "date": "1651770418", "time_retrieved": "2024-07-30T16:50:02.129927", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= rot(-m.y*3.14+1.);\n    ro.xz *= rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    //p.xz *= rot(p.y - 0.2 * iTime);\n\n    float d = length(p) - 2.;\n    //d = length(p.xz) - 2.;\n    //float d = sdBox(p, vec3(0.75)) - 1.;\n   //   \n    float sc = 12.;\n    \n    float val = 0.;\n    float m = 0.45;\n    for (float i = 0.; i < 10.; i++) {\n        val += exp(-(0.2) * m * length(p) -sc * length(fract(m*p)-0.5));\n        m *= 1.5;\n    }\n    \n    float fo = exp(-0.5 * length(p));\n    d += 10. * val;\n    //d = -smin(d,-d2);\n    return 0.08 * d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    if(d<MAX_DIST) {\n        vec3 p = ro + rd * d;\n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(1);\n        \n        float fres = pow(1. + dot(rd, n), 3.);\n        float v = dot(abs(n), abs(r));\n        vec3 e = vec3(0.5);\n        //col *= pal(n.y, e, e, e, 0.4 * vec3(0,1,2)/3.);\n        n *= 0.5;\n        vec3 c1 = texture(iChannel0, n.xy).rgb;\n        vec3 c2 = texture(iChannel0, n.yz).rgb;\n        vec3 c3 = texture(iChannel0, n.zx).rgb;\n        p = 1.-abs(p);\n        vec3 c = p.z * c1 + p.x * c2 + p.y * c3;\n        col *= c * 2.;\n        c *= 1.5;\n        vec3 col2 = pal(0.15, c, c, e, 0.5 * vec3(0,1,2)/3.);\n        col *= col2;\n        col = mix(col, vec3(0.4 * col2), fres);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\nfloat test(in vec2 uv, float res)\n{\n    uv -= floor(uv) + 0.5;\n\n    float k = 10. / res;\n    float m = 0.25;\n    \n    float d = length(uv);\n    float s = smoothstep(-k, k, -length(uv) + m);\n       \n    for (int i = 0; i < 6; i++) {\n        uv = abs(uv) - m;\n        m *= 0.5;\n        s = max(s, smoothstep(-k, k, -length(uv) + m));\n    }\n    \n    return s;\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lSBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 716], [718, 718, 741, 779, 1202], [1204, 1204, 1247, 1247, 1554], [1556, 1556, 1580, 1580, 1770], [1772, 1772, 1822, 1822, 2013], [2015, 2015, 2072, 2072, 3413]], "test": "untested"}
{"id": "7tBBRh", "name": "little exploders", "author": "eiffie", "description": "little exploding things", "tags": ["simulation"], "likes": 20, "viewed": 519, "published": 3, "date": "1651758658", "time_retrieved": "2024-07-30T16:50:02.894881", "image_code": "float BG(vec2 u){u=sin(u+sin(u.yx+iTime*.1));return (u.x*u.y+u.x+u.y)*.025+0.05;}\nvec4 cmap(float a){a=clamp(a,0.,2.325);return a*abs(vec4(sin(a),sin(a+.4),sin(a+1.2),1.));}\nvoid mainImage(out vec4 O, in vec2 U){\n  O=U.y>1.?cmap(BG(U*0.01)+BG(U.yx*0.03)*.2+texture(iChannel0,U/iResolution.xy).r):vec4(0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define MASSES 512\nfloat dot2(vec2 x){return dot(x,x);}\nvoid mainImage(out vec4 O, in vec2 U){\n  int M=min(MASSES,int(iResolution.x)),X=int(floor(U.x));\n  O=texture(iChannel0,U/iResolution.xy);\n  bool bLogic=(U.y<1. && X<MASSES);\n  if(iFrame<2)O=vec4(bLogic?vec2(cos(U.x),sin(U.x+1.))*100.:vec2(0),0.,0.);\n  U-=iResolution.xy*.5;\n  float d=100.;\n  for(int i=0;i<M;i++){\n    vec4 v=texture(iChannel0,vec2(float(i)+.5,.5)/iResolution.xy);\n    if(bLogic){\n      if(i!=X){\n        vec2 dlt=v.xy-O.xy;\n        float d2=dot2(dlt),m=min(1.,.96+dot2(v.zw-O.zw)*0.0001+d2*0.0001);\n        O.zw=O.zw*m+sign(dlt)/max(1.,d2);\n      }\n    }else d=min(d,dot2(U-v.xy));\n  }\n  if(bLogic){O.xy+=O.zw;O.zw/=(.998+.002*dot2(O.zw));}\n  else O.r=O.r*.9+.3*smoothstep(3.,0.,d);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "int N[8]=int[8](-1,-5,0,0,0,-5,4,7);\nfloat I(int n, float t, float d){\n  int n2=(n+48)%12;float e=1.+sin(float(n))*.2-t*t*.5;\n  if((n2==1)||(n2==4)||(n2==6)||(n2==8)||(n2==11))return 0.;//dorian\n  return pow(fract(t*50.*pow(2.,float(n)/(12.-e*e*.05))),.5+t*t*d)*e;\n}\nvec2 Sound(float time){\n  float tim=time*7.,b=floor(tim),b3=fract(tim/8.),b2=fract(tim/2.),b1=fract(tim);\n  int n3=N[(int(b/128.)*2)%8]+N[int(b/8.)%8];\n  int n2=n3+N[int(b/2.)%8],n=n2+N[int(b)%8];\n  return vec2(I(n,b1,200.)*.65-I(n2+3,b2*1.005,30.)*.75,\n   -I(n+5,b1*1.007,200.)*.5+I(n2,b2,20.)*.75-I(n3,b3*1.001,20.));\n}\nvec2 mainSound(int samp, float time){\n  return Sound(time)*.1+Sound(time-.075).yx*.08-Sound(time-.15)*0.05;\n}", "sound_inputs": [], "common_code": "", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBBRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 17, 17, 81], [82, 82, 101, 101, 173], [174, 174, 212, 212, 306]], "test": "untested"}
{"id": "NlSBz1", "name": "Moon Rock 3000", "author": "SnoopethDuckDuck", "description": "messy code iurhoigeirgoowiefjwpg", "tags": ["e"], "likes": 5, "viewed": 323, "published": 3, "date": "1651754325", "time_retrieved": "2024-07-30T16:50:03.754582", "image_code": "#define MAX_STEPS 400\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax, p)*ax, p, cos(ro)) + cross(ax,p)*sin(ro);\n}\n\nvec3 face(vec3 p) {\n     vec3 a = abs(p);\n     return step(a.yzx, a.xyz)*step(a.zxy, a.xyz)*sign(p);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nvec3 getRo() {\n    vec2 m = iMouse.xy/iResolution.xy;\n    float r = 3.;\n    float t = 0.2 * iTime;\n    vec3 ro = vec3(r * cos(t), 2, r * cos(t) + sin(t));\n    //ro.yz *= Rot(-m.y*3.14+1.);\n    //ro.xz *= Rot(-m.x*6.2831);\n    return ro;\n}\n\nfloat GetDist(vec3 p) {\n    float sc = 0.125;\n    \n    //p.xz *= Rot(.5 * length(p.xz) - 0.1 * iTime);\n    float c1 = test(sc * p.xy, iResolution.y);\n    float c2 = test(sc * p.yz, iResolution.y);\n    float c3 = test(sc * p.zx, iResolution.y);\n\n    p.y += 0.05 * cos(atan(p.x, p.z) + iTime);\n  \n    float r1 = 1.;\n    float r2 = 1.;\n    float d1 = length(p.xz) - r1;\n    float d2 = length(vec2(d1,p.y)) - r2;\n    //d2 = length(p) - 1.5;\n     d2 += (0.5 + 0.5 * thc(4., iTime/3.)) * 0.5 * max(max(c1,c2), c3);\n    return 0.15 * d2;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, float z) {\n\t\n    float dO=0.;\n    float s = sign(z);\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        if (s != sign(dS)) { z *= 0.5; s = sign(dS); }\n        if(abs(dS)<SURF_DIST || dO>MAX_DIST) break;\n        dO += dS*z; \n    }\n    \n    return min(dO, MAX_DIST);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = getRo();\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.5);\n    vec3 col = vec3(0);\n   \n    float d = RayMarch(ro, rd, 1.);\n\n    float IOR = 1.05;\n    vec3 p = ro + rd * d;\n    if(d<MAX_DIST) {\n        \n        vec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n\n        vec3 pIn = p - 4. * SURF_DIST * n;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        float dIn = RayMarch(pIn, rdIn, -1.);\n        \n        vec3 pExit = pIn + dIn * rdIn;\n        vec3 nExit = -GetNormal(pExit); // *-1.; ?\n\n        float dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n        col = vec3(dif);\n        \n        float sc = 0.5;\n        float c1 = test(sc * p.xy, iResolution.y);\n        float c2 = test(sc * p.yz, iResolution.y);\n        float c3 = test(sc * p.zx, iResolution.y);\n\n        vec3 c4 = texture(iChannel1, sc + sc * p.xy).rgb;\n        vec3 c5 = texture(iChannel1, sc + sc * p.yz).rgb;\n        vec3 c6 = texture(iChannel1, sc + sc * p.zx).rgb;\n\n        float fres = pow(clamp(1. + dot(rd, n),0.,1.), 1.);\n        //col += fres;\n        \n        vec3 an = abs(n);\n        vec3 c = vec3(c1 * n.z + c2 * n.x + c3 * n.y);\n        vec3 cc = c4 * n.z + c5 * n.x + c6 * n.y;\n        \n        //col = c;\n        col = mix(col * cc, c, cc * fres);\n        //col *= n.y;\n        \n        vec3 e = vec3(0.5);\n        col += exp(0.5-8. * abs(cos(12. * log(length(p.xz)) - iTime)))\n            * pal(max(max(c1,c2),c3) - c1 * c2 * c3, e, e, e, 0.55 * vec3(0,1,2)/3.);\n        \n        //col = c;\n    }\n    col = mix(col, vec3(1), exp(-10. * length(p.xz)));\n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define pi 3.14159\n\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define ths(a,b) tanh(a*sin(b))/tanh(a)\n#define sabs(x) sqrt(x*x+1e-2)\n//#define sabs(x, k) sqrt(x*x+k)-0.1\n\n#define Rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat test(in vec2 uv, float res)\n{\n    uv -= floor(uv) + 0.5;\n\n    float k = 10. / res;\n    float m = 0.25;\n    \n    float d = length(uv);\n    float s = smoothstep(-k, k, -length(uv) + m);\n       \n    for (int i = 0; i < 6; i++) {\n        uv = abs(uv) - m;\n        m *= 0.5;\n        s = max(s, smoothstep(-k, k, -length(uv) + m));\n    }\n    \n    return s;\n}\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\nfloat cc(float a, float b) {\n    float f = thc(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nfloat cs(float a, float b) {\n    float f = ths(a, b);\n    return sign(f) * pow(abs(f), 0.25);\n}\n\nvec3 pal(in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nfloat h21(vec2 a) {\n    return fract(sin(dot(a.xy, vec2(12.9898, 78.233))) * 43758.5453123);\n}\n\nfloat mlength(vec2 uv) {\n    return max(abs(uv.x), abs(uv.y));\n}\n\nfloat mlength(vec3 uv) {\n    return max(max(abs(uv.x), abs(uv.y)), abs(uv.z));\n}\n\nfloat smin(float a, float b) {\n    float k = 0.12;\n    float h = clamp(0.5 + 0.5 * (b-a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlSBz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 153, 153, 229], [231, 231, 269, 269, 334], [336, 336, 355, 355, 438], [440, 440, 469, 469, 550], [552, 552, 566, 566, 790], [792, 792, 815, 815, 1324], [1326, 1326, 1369, 1369, 1676], [1678, 1678, 1702, 1702, 1892], [1894, 1894, 1944, 1944, 2135], [2137, 2137, 2194, 2194, 3906]], "test": "untested"}
{"id": "Nt2BzR", "name": "Color Bubbler", "author": "VPaltoDance", "description": "More colorful bubbles", "tags": ["circles", "color", "bubbles"], "likes": 25, "viewed": 727, "published": 3, "date": "1651750027", "time_retrieved": "2024-07-30T16:50:04.797793", "image_code": "#define RADIUS 0.2\n#define SMOOTH_BOORDER 0.01\n#define PI   3.1415926\n#define PId2 1.5707963\n#define PI2  6.2831853\n#define NUMCIRCLES 86\n#define TIME_SCALE 2.0\n\n\nvec2 random( float x, float y )\n{\n    vec2 K1 = vec2(\n        23.14069263277926, // e^pi (Gelfond's constant)\n         2.665144142690225 // 2^sqrt(2) (GelfondSchneider constant)\n    );\n    return abs(fract( vec2(cos( x * K1.x), sin( y * K1.y + 166.6))));\n}\n\nvec2 generateRandomShift(float xSeed, float ySeed, float time, vec2 ratio)\n{\n    return (2.0 *random(ceil(time/PI2) + xSeed, ceil(time/PI2) + ySeed) - 1.0) * ratio;\n}\n\nfloat sinWave01(float time)\n{\n    return 0.5 + 0.5 * sin(time - PId2);\n}\n\nfloat calculateCircle(vec2 uv, float r, float blur)\n{\n    float dist = length(uv);\n    return smoothstep(r + blur, r, dist); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy)/ iResolution.y;\n    \n    vec2 ratio = iResolution.xy/ iResolution.y;\n        \n    float col;\n    for(int i = 0; i < NUMCIRCLES; ++i)\n    {\n        float timeShift = 2.0*float(i);\n        float time = TIME_SCALE*(iTime + timeShift);\n        vec2 shift =  generateRandomShift(2.0*float(i), float(i + 56), time, ratio);\n        col += calculateCircle(uv - shift, RADIUS * sinWave01(time), SMOOTH_BOORDER) * \n                              (1.0 - sinWave01(time)); \n    }\n    \n    vec3 sincol = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //fragColor = vec4(uv, 0.0, 1.0);\n    fragColor = vec4(sincol * (clamp(col, 0.0, 1.0)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2BzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[163, 163, 196, 196, 427], [429, 429, 505, 505, 595], [597, 597, 626, 626, 669], [671, 671, 724, 724, 798], [800, 800, 857, 857, 1545]], "test": "untested"}
{"id": "7l2Bzz", "name": "Retro GB", "author": "quentopp", "description": "Fragment shader that pixelates and solarizes images or videos and makes them monochrome with a tint", "tags": ["retro", "pixel", "gameboy"], "likes": 7, "viewed": 308, "published": 3, "date": "1651741743", "time_retrieved": "2024-07-30T16:50:05.802108", "image_code": "#define VERSION 0\n\nfloat pixelSize = 8.;\nfloat gradations = 8.;\nvec4 tint = vec4(0.8,1,0.8,1);\n\n/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (VERSION == 0) {\n        // Normalized pixel coordinates (from 0 to 1)\n        vec2 uv = floor(fragCoord / pixelSize) * pixelSize / iResolution.xy;\n\n        // Time varying pixel color\n        vec4 col = pow(texture(iChannel0, uv), 2.2);\n    \n        // 0.299 R + 0.587 G + 0.114 B\n        float lum = (0.299*col.x + 0.587*col.y + 0.114*col.z);\n        float adjustedLum = floor(lum * gradations) / gradations; \n    \n        // Output to screen\n        fragColor = pow(vec4(1, 1, 1, 1) * adjustedLum * tint, 1.0/2.2);\n    } else {\n        fragCoord = floor(fragCoord / pixelSize) * pixelSize / iResolution.xy;\n        fragColor = tint * floor( dot( texture(iChannel0, fragCoord), vec4( 0.299, 0.587, 0.114, 0) ) * gradations) / gradations;\n    }\n}\n*/\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U = floor(U / 8.) * 8. / iResolution.xy;\n    O = vec4(.8,1,.8,1)\n      * round( dot( texture(iChannel0, U),vec4(.2126,.7152,.0722,0) ) * 8.) / 8.;\n}", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7l2Bzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[916, 916, 954, 954, 1107]], "test": "untested"}
{"id": "sl2fRz", "name": "Eco website shader", "author": "sebastianstrand", "description": "Taken from shader ID lltBWM", "tags": ["lines"], "likes": 3, "viewed": 156, "published": 3, "date": "1651740960", "time_retrieved": "2024-07-30T16:50:06.564071", "image_code": "float wave(float x, float y) \n{\n    return sin(10.0*x+10.0*y) / 5.0 +\n           sin(20.0*x+15.0*y) / 3.0 +\n           sin(4.0*x+10.0*y) / -4.0 +\n           sin(y) / 2.0 +\n           sin(x*x*y*20.0) + \n           sin(x * 20.0 + 4.0) / 5.0 +\n           sin(y * 30.0) / 5.0 + \n    \t   sin(x) / 4.0; \n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float z = wave(uv.x, uv.y) + 2.0;\n    \n    \n    z *= 4.0 * sin(1.57 + iTime / 5.0);\n    float d = fract(z);\n    if(mod(z, 2.0) > 1.) d = 1.-d;\n     \n\n    d = d/fwidth(z);\n    fragColor = vec4(d);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2fRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 304], [306, 306, 363, 413, 657]], "test": "untested"}
{"id": "sl2BRz", "name": "spiral geometric aliasing", "author": "FabriceNeyret2", "description": "reference: https://www.facebook.com/gianni.sarcone/videos/697768187911680/", "tags": ["short", "reproduction"], "likes": 23, "viewed": 350, "published": 3, "date": "1651738898", "time_retrieved": "2024-07-30T16:50:07.372908", "image_code": "float line(vec2 p, vec2 a,vec2 b) { \n    p -= a, b -= a;\n    return length(p - b * clamp(dot(p, b) / dot(b, b), 0., 1.) );\n}\n#define S(v)  smoothstep( 54./R.y,0., v )           // antialiasing\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, A,B=R-R,\n          U = 18.*( 2.*u - R ) / R.y;\n    O-=O;\n    for( float a=-1.; ++a<18.; B=A )\n        A = a * cos( a*iTime/5. + vec2(0,11) ),     // dot location\n        O +=  S( line(U,A,B) )                      // lines\n            + S( length(A-U) -.3 )                  // dots\n            + S( abs(length(U)-a) ) /3. ;           // rings\n\n\n}\n\n\n \n\n\n/* --- 363 chars\n\n#define r(l) (l) * cos( (l)*iTime/5. + vec2(0,11) ) // dot location\n\n    for( float a=0.; a<18.; a++ )\n        O +=  S( line(U,r(a),r(a-1.)) )*step(1.,a)  // lines\n            + S( length(r(a)-U) -.3 )               // dots\n            + S( abs(length(U)-a) ) /3. ;           // rings\n \n} \n \n \n \n \n \n \n \n \n \n \n \n/*    // --- loopless attempt, but lines do require some loop ! \n\n   float l = length(U), a = floor(l), n = fract(l+.5)-.5;\n    vec2 A = r(a),\n         B = r(a+1.);\n    O = vec4( l < 18.5 ? S( line(U,A,B) )\n                       + S(abs(n))/3. \n                       + S( length(A-U)-.3)+ S ( length(B-U)-.3) : 0. );\n}\n/**/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2BRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 124], [194, 194, 232, 232, 610]], "test": "untested"}
{"id": "7tjBzR", "name": "Fork Color proc Maadahmed 607", "author": "Maadahmed", "description": "I really don't know what it is...", "tags": ["sdf", "glow"], "likes": 3, "viewed": 190, "published": 3, "date": "1651728614", "time_retrieved": "2024-07-30T16:50:08.211665", "image_code": "float vmax(vec2 v) {return max(v.x, v.y);}\nfloat fBox2(vec2 p, vec2 b) {return vmax(abs(p)-b);}\n\nmat2 rot(float a) {float s=sin(a), c=cos(a); return mat2(c,s,-s,c);}\nfloat wf1(vec2 p){return sin(p.x) + cos(p.y);}\n\nfloat cappedCylinder(vec3 p, float h, float r){\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 gl = vec3(0.);\nfloat gl1 = 0.;\nvec3 gl2 = vec3(0.);\n\nvec3 map(vec3 p) {\n    vec3 r = vec3(0.);\n    vec3 d = vec3(0.);\n    p.xz *= rot(iTime * .5);\n    vec3 m = p;\n    p.xz *= rot(sin(-p.y * .5) * 1.1);\n    p.xz = abs(p.zx)-vec2(.8);\n    float i = sin(p.y * 3. + iTime * 10.) * .5 + .5;\n    float b = cappedCylinder(p,  5.5 , ((i - .5) * 2. * .3) * cos(p.y * .2));\n    gl += (.0004/(.01+b*b)) * mix(vec3(1.,0.,1.), vec3(1.,1.,0.), p.y);\n    r.x = max(cappedCylinder(p, 2., .3 + .2 * i), -cappedCylinder(p, 3., .2 + .25 * i));\n    p.xz *= rot(p.y * 3. + iTime * 2.);\n    vec3 q = p;\n    q.xz *= rot(3.14/2.);\n    if (fBox2(p.xy, vec2(.2, 10.)) < 0.) r.yz = vec2(3.,0.); \n    else if (fBox2(q.xy, vec2(.2, 10.)) < 0.) r.yz = vec2(4., 0.);\n    else r.yz = vec2(1.);\n    gl1 += (.000001/(.000001+pow(r.x+.003, 2.)));\n    d.x = min(r.x, cappedCylinder(p, 8.5 , (.25 + (i - .5) * 2. * .15) * cos(p.y * .2)));\n    d.y = 2.;\n    if (r.x > d.x) r = d;\n    p = m;\n    d.x = length(p) - .45 - .1 * (sin(iTime * 10.) * .5 + .5);\n    gl2 += (.0006/(.01+d.x*d.x)) * mix(vec3(1.,0.,1.), vec3(1.,1.,0.), m.y);\n    if (r.x > d.x) r = d;\n    p = m;\n    if (p.y > 0.) p.xz *= rot(.3);\n    p = abs(p);\n    p.zx *= rot(-3.14/4.);\n    p.xy *= rot(-3.14/4.);\n    p.y -= 1.;\n    q = p;\n    p.yx *= rot( sin(p.y * 3.14) * .3 );\n    d.x =  cappedCylinder(p, 1. , (.06 + (i - .5) * 2. * .04));\n    p = q; p.y -= 1.;\n    d.x = min(d.x, length(p) - .15 - .05 * (sin(iTime * 10. + 1.5) * .5 + .5));\n    gl2 += (.0003/(.01+d.x*d.x)) * mix(vec3(1.,0.,1.), vec3(1.,1.,0.), -m.y);\n    d.y = 2.;\n    if (r.x > d.x) r = d;\n    return r;\n}\n\nconst vec2 e = vec2(.00035, -.00035);\nvec3 norm(vec3 po) {\n        return normalize(e.yyx*map(po+e.yyx).x + e.yxy*map(po+e.yxy).x +\n                         e.xyy*map(po+e.xyy).x + e.xxx*map(po+e.xxx).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec3 ro = vec3(0.,3.,-6.),\n         rd = normalize(vec3(uv,1.)),\n         p, h;\n    rd.yz *= rot(-.4);\n    float t = 0.;\n    for(int i = 0; i < 120; i++) {\n         p = ro + rd * t;\n         h = map(p);\n         if (h.x<.0001||t>40.) {\n             if (h.z == 1.) h.x = abs(h.x) + .0001;\n             else break;\n         };\n         t += h.x * .7;\n    }\n    vec3 ld = vec3(0., 1.,0.);\n    vec3 ld1 = vec3(3., 3., 0.);\n    ld1.xz *= rot(iTime * .3); \n    vec3 col = vec3(.1);\n    if (h.x<.0001) {\n        if (h.y == 1.) col = vec3(.1, .3, .2);\n        if (h.y == 2.) col = vec3(.7,.7,.3);\n        if (h.y == 3.) col = vec3(.5, .9, .5);\n        if (h.y == 4.) col = vec3(.5, .5, .9);\n    }\n    col = mix(col, vec3(.1, .3, .2), clamp(gl1,0.,1.));\n    col += gl;\n    col += gl2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tjBzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 42], [43, 43, 72, 72, 95], [97, 97, 116, 116, 165], [166, 166, 184, 184, 212], [214, 214, 261, 261, 373], [433, 433, 451, 451, 1981], [2021, 2021, 2041, 2041, 2189], [2191, 2191, 2248, 2248, 3126]], "test": "untested"}
{"id": "Nt2fzz", "name": "blur tests", "author": "vinvinvin", "description": "it is so", "tags": ["hmmm"], "likes": 0, "viewed": 214, "published": 3, "date": "1651727560", "time_retrieved": "2024-07-30T16:50:09.152151", "image_code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n\n    return nUv;\n    \n} \n\nfloat sat( float t )\n{\n\treturn clamp( t, 0.0, 1.0 );\n}\n\nfloat linterp( float t ) {\n\treturn sat( 1.0 - abs( 2.0*t - 1.0 ) );\n}\n\nfloat remap( float t, float a, float b ) {\n\treturn sat( (t - a) / (b - a) );\n}\n\nvec2 barrelDistortion(vec2 coord, float amt) {\n\tvec2 cc = coord - 0.5;\n\tfloat dist = dot(cc, cc);\n\treturn coord + cc * dist * amt;\n}\n\nvec4 spectrum_offset( float t ) {\n\tvec4 ret;\n\tfloat lo = step(t,0.5);\n\tfloat hi = 1.0-lo;\n\tfloat w = linterp( remap( t, 1.0/6.0, 5.0/6.0 ) );\n\tret = vec4(lo,1.0,hi, 1.) * vec4(1.0-w, w, 1.0-w, 1.);\n\n\treturn pow( ret, vec4(1.0/2.2) );\n}\n\n//Vignette parameters:\n\n//Inner radius\n#define inner .5\n//Outer radius\n#define outer 1.2\n//Vignette strength/intensity\n#define strength .3\n//Vignette roundness, higher = smoother, lower = sharper\n#define curvature .9\n//=============//\n // Final Blend //\n//=============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 uv = coord / iResolution.xy;\n    \n    vec4 original = texture(iChannel0, uv);\n    \n    uv = scale_uv(uv, vec2(RENDER_SCALE), vec2(0.5));\n    // vec4 blurred = texture(iChannel1, uv);\n    // blurred = pow(blurred, vec4(1.0 / GAMMA));\n        \n    float k = DISTORT_AMOUNT;\n    float kcube = 0.0;\n    \n    // float offset = .1 * sin( iTime * .5 );\n    \n    uv = ((uv - 0.5) * (1.0 - (ZOOM_AMOUNT))) + 0.5;\n    vec4 blurred = texture( iChannel1, computeDistortedUV( uv, k, kcube ) );\n        \n    const int num_iter = 12;\n    const float reci_num_iter_f = 1.0 / float(num_iter);\n    // We want to tone down the chromatic abberation on higher resolutions\n    float max_distort = 0.15 * TO_1_AMOUNT * (1120.0 / iResolution.x);\n    \n\tvec4 sumcol = vec4(0.0);\n\tvec4 sumw = vec4(0.0);\t\n\tfor ( int i=0; i<num_iter;++i )\n\t{\n\t\tfloat t = float(i) * reci_num_iter_f;\n\t\tvec4 w = spectrum_offset(t);\n\t\tsumw += w;\n\t\t// sumcol += w * texture( iChannel0, uv );\n        sumcol += w * texture( iChannel1, barrelDistortion(computeDistortedUV( uv, k, kcube ), .6 * max_distort*t ));\n\t}\t\n\tblurred = sumcol / sumw;\n    // blurred = pow(blurred, vec4(1.0 / (ADJUSTED_GAMMA * 2.5)));\n    blurred = pow(blurred, vec4(1.0 / ADJUSTED_GAMMA));\n    \n    color = mix(original, blurred, 1.0);\n\n    \n        \n    //Calculate edge curvature\n    vec2 curve = pow(abs(uv*2.-1.),vec2(1./curvature));\n    //Compute distance to edge\n    float edge = pow(length(curve),curvature);\n    //Compute vignette gradient and intensity\n    float vignette = 1.-strength*(TO_1_AMOUNT)*smoothstep(inner,outer,edge);\n    \n    //Add vignette to the resulting texture\n    color.rgb *= vignette;\n    //color = texture(iChannel2, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    Doom 2016 does a fast real-time Bokeh\n    where the half-resolution framebuffer\n    is blurred with a circular average\n    (tapped fragments in a circular pattern,\n    no Gaussian used) and then a second blur\n    is performed where the colours are\n    blended with a colour \"max\" operation\n    (brightest RGB components kept).\n*/\n\n  //========//\n // Macros //\n//========//\n\n#define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 5.0 : 1.8)\n#define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.0 : 0.0)\n#define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.05 : 0.05)\n#define TO_1_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.0)\n// #define BLUR_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.8 : 1.8)\n// #define DISTORT_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 1.0 : 1.2)\n// #define ZOOM_AMOUNT (iMouse.z > 0.0 ? (iMouse.x / iResolution.x) * 0.25 : 0.25)\n\n  //===========//\n // Constants //\n//===========//\n\nconst float PI = 3.14159;\nconst float GAMMA = 3.5;\n\n//#define ADJUSTED_GAMMA (iMouse.z > 0.0 ? GAMMA * (1.0 - (pow((iMouse.x / iResolution.x), 0.5) * 0.4)) : GAMMA)\n#define ADJUSTED_GAMMA GAMMA\n// We adjust the gamma on pass \nconst float PASS_2_GAMMA_DENOM = 0.2;\n// Make the effect of larger side swirls decrease with increased size\n#define SWIRL_SIZE_EXP (-0.9 * pow(max((3.0 - BLUR_AMOUNT) / 3.0, 0.0), 1.5))\n\n\nconst float RENDER_SCALE = 0.9;\n//const float BLUR_AMOUNT = 1.0;\n\nconst int BOX_BLUR_SAMPLES = 1;\nconst float BOKEH_ASPECT_RATIO = 1.25;\nconst vec2 BOX_BLUR_SCALE = vec2(2);\nconst vec2 BOX_BLUR_OFFSET = float(BOX_BLUR_SAMPLES / 2) * BOX_BLUR_SCALE;\nconst float BOX_BLUR_ACCUM = 1.0 / float(BOX_BLUR_SAMPLES);\n\n  //===========//\n // Functions //\n//===========//\n\nvec2 scale_uv(vec2 uv, vec2 scale, vec2 center) {\n    return (uv - center) * scale + center;\n}\n\nvec4 box_blur(sampler2D sp, vec2 uv, vec2 dir) {\n\tvec4 result = vec4(0.0);\n    uv -= dir * BOX_BLUR_OFFSET;\n    \n    for (int i = 0; i < BOX_BLUR_SAMPLES; ++i) {\n        result += texture(sp, uv);\n        uv += dir * BOX_BLUR_SCALE;\n    }\n    result *= vec4(BOX_BLUR_ACCUM);\n    \n    return result;\n}\n\n", "buffer_a_code": "vec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n    nUv.y = 1. - nUv.y;\n \n    return nUv; \n}\n\n\n //===============//\n // Preprocessing //\n//===============//\n\nvoid mainImage(out vec4 color, vec2 coord) {\n\tvec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    uv = scale_uv(uv, vec2(1.0 / RENDER_SCALE), vec2(0.5));\n    \n\tcolor = texture( iChannel0, uv );\n    \n    // vec2 uv=(gl_FragCoord.xy/resolution.xy*.5)+.25;\n\n    \n    // vinhowe: threshold some highlights. a lot of this is just guessing and trying things.\n    \n    float luminance = 0.2126*color.r + 0.7152*color.g + 0.0722*color.b;\n    if (luminance > 0.8) {\n        color = mix(color, pow(color, 1.0 / vec4(1.4)), min(BLUR_AMOUNT / 0.8, 1.0));\n    }\n    color = pow(color, vec4(ADJUSTED_GAMMA));\n    \n   \n\n    // float mixValue = ZOOM_AMOUNT;\n    // color.rgb *= max(1.0 - mixValue, 0.0);\n    // color.rgb += vec3(0.1, 0.1, 0.1) * mixValue;\n    // color.rgb = min((color.rgb * (1.0 + (ZOOM_AMOUNT * 30.0))) + (ZOOM_AMOUNT * 0.1), vec3(1.0, 1.0, 1.0));\n    // color.rgb = mix(color.rgb, vec3(0.05, 0.05, 1.0), max(min(((0.5-uv.y) + 0.5)*ZOOM_AMOUNT, 1.0), 0.0));\n    // color.b *= 1.0 + (ZOOM_AMOUNT * 1.0);\n    // color.rgb += vec3(0.05, 0.05, 0.06) * ZOOM_AMOUNT;\n}\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "  //=================//\n // First Blur Pass //\n//=================//\n\nconst vec2 OFFSETS[] = vec2[](\n    vec2(0.0, 0.0),\n    vec2(1.5, 0.0),\n    vec2(0.46, 1.43),\n    vec2(-1.21, 0.88),\n    vec2(-1.21, -0.88),\n    vec2(0.46, -1.43),\n    vec2(3.0, 0.0),\n    vec2(2.43, 1.76),\n    vec2(0.93, 2.85),\n    vec2(-0.93, 2.85),\n    vec2(-2.43, 1.76),\n    vec2(-3.0, 0.0),\n    vec2(-2.43, -1.76),\n    vec2(-0.93, -2.85),\n    vec2(0.93, -2.85),\n    vec2(2.43, -1.76)\n);\n\nvec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n \n    return nUv; \n}\n\nconst float SCALE = 1.0;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //color = box_blur(iChannel0,BOKEH ASPECT_RATIO, 1/BOKEH ASPECT_RATIO) uv, vec2(ps.x, 0));\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        // Make bokeh near the edges thinner\n        vec2 offsetWithRatio = OFFSETS[i] * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        vec2 offset = offsetWithRatio * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);\n        \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - abs(offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\n        float normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);\n        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        // vec2 adjustedOffset = mix(offset, vec2(cos(newAngle), sin(newAngle))*offsetLength, distortedLength*0.1);\n        \n        // adjustedOffset = offset;\n\n        color += texture(iChannel0, (coord + offset * SCALE * BLUR_AMOUNT * pow((1.0 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n    }\n\tcolor /= float(OFFSETS.length());\n   \n    color = pow(color, vec4(ADJUSTED_GAMMA*PASS_2_GAMMA_DENOM));\n    color.a = 1.0;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "  //=================//\n // Second Blur Pass //\n//=================//\n\nconst vec2 OFFSETS[] = vec2[](    \n    vec2(0.0, 0.0),\n    vec2(0.5, 0.0),\n    vec2(0.15, 0.48),\n    vec2(-0.4, 0.29),\n    vec2(-0.4, -0.29),\n    vec2(0.15, -0.48),\n    vec2(1.0, 0.0),\n    vec2(0.81, 0.59),\n    vec2(0.31, 0.95),\n    vec2(-0.31, 0.95),\n    vec2(-0.81, 0.59),\n    vec2(-1.0, 0.0),\n    vec2(-0.81, -0.59),\n    vec2(-0.31, -0.95),\n    vec2(0.31, -0.95),\n    vec2(0.81, -0.59)\n);\nvec2 computeDistortedUV( vec2 uv, float k, float kcube ){\n    \n    vec2 t = uv - .5;\n    float r2 = t.x * t.x + t.y * t.y;\n\tfloat f = 0.;\n    \n    if( kcube == 0.0){\n        f = 1. + r2 * k;\n    }else{\n        f = 1. + r2 * ( k + kcube * sqrt( r2 ) );\n    }\n    \n    vec2 nUv = f * t + .5;\n \n    return nUv; \n}\n\nconst float SCALE = 0.8;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //color = box_blur(iChannel0, uv, vec2(ps.x, 0));\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        // Make bokeh near the edges thinner\n        vec2 offsetWithRatio = OFFSETS[i] * vec2(1.0/BOKEH_ASPECT_RATIO, BOKEH_ASPECT_RATIO);\n        vec2 offset = offsetWithRatio * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);   \n       \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - (offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\nfloat normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        // vec2 adjustedOffset = mix(offset, vec2(cos(newAngle), sin(newAngle))*offsetLength, distortedLength*0.1);\n        \n        // adjustedOffset = offset;\n\n        color += texture(iChannel0, (coord + adjustedOffset * SCALE * BLUR_AMOUNT * pow((1.01 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP)) * ps);\n    }\n\tcolor /= float(OFFSETS.length());\n   \t\n    color.a = 1.0;\n}\n", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "  //==================//\n // Third Blur Pass //\n//==================//\n\nconst vec2 OFFSETS[] = vec2[](\n\tvec2(0, 2.2),\n    vec2(0, -2.2),\n    \n    vec2(0, 1.5),\n    vec2(0, -1.5),\n    \n    vec2(0, 0.9),\n    vec2(0, -0.9),\n    \n    vec2(0.4, 1.35),\n    vec2(-0.4, 1.35),   \n    vec2(0.4, -1.35),\n    vec2(-0.4, -1.35),\n    \n    vec2(0.8, 1.5),\n    vec2(-0.8, 1.5),   \n    vec2(0.8, -1.5),\n    vec2(-0.8, -1.5),\n    \n    vec2(0.6, 2),\n    vec2(-0.6, 2),\n    vec2(0.6, -2),\n    vec2(-0.6, -2),\n    \n\tvec2(1, 1),\n    vec2(-1, 1),\n    vec2(1, -1),\n    vec2(-1, -1),\n    \n    vec2(0.35, 0.6),\n    vec2(-0.35, 0.6),\n    vec2(0.35, -0.6),\n    vec2(-0.35, -0.6),\n    \n    vec2(0.7, 0.7),\n    vec2(-0.7, 0.7),\n    vec2(0.7, -0.7),\n    vec2(-0.7, -0.7),\n    \n    vec2(-1.1, 0.4),\n    vec2(1.1, 0.4),\n    vec2(-1.1, -0.4),\n    vec2(1.1, -0.4),\n    \n    vec2(-1.1, 0),\n    vec2(1.1, 0),\n    \n    vec2(-0.8, 0),\n    vec2(0.8, 0),\n    \n    vec2(-0.4, 0),\n    vec2(0.4, 0)\n);\n\nconst float SCALE = 1.0;\n\nvoid mainImage(out vec4 color, vec2 coord) {\n    vec2 ps = vec2(1) / iResolution.xy;\n    vec2 uv = coord * ps;\n    \n    //coord = scale_uv(coord, vec2(0.5), iResolution.xy * 0.5);\n    \n    color = vec4(0);\n    \n    for (int i = 0; i < OFFSETS.length(); ++i) {\n        vec2 c = coord;\n        vec2 offset = OFFSETS[i] * vec2(0.8*(pow(1.0 - (abs((uv.x) - 0.5) / 0.5), 0.5)) + 0.2, 1.0);   \n        float offsetLength = length(offset);\n        float offsetAngle = atan(offset.y, offset.x);\n        // Adding the offset here rounds things off a little bit\n        vec2 centerVec = (uv - (offset * ps * 4.0)) - 0.5;\n        float centerAngle = atan(centerVec.y, centerVec.x);\n\n        float centerDist = length(centerVec);\n        // float newAngle = (PI / 2.0) -offsetAngle - distortedOffsetAngle;\n        float newAngle = offsetAngle + centerAngle;\n        if (uv.x < 0.5) {\n            newAngle -= PI;\n        }\n        \n        // Bad approx for now\n        //float normalizedCenterDist = length(centerVec / ((iResolution.xy / length(iResolution)) * vec2(1.0, 0.8)));\n        float normalizedCenterDist = pow(abs(centerVec.x), 1.5) + pow(abs(centerVec.y), 9.0);        \n        // https://gist.github.com/shaunlebron/8832585\n        float maxAngle = PI * 2.0;\n        float da = mod((newAngle - offsetAngle), maxAngle);\n        float minLength = mod(2.0*da, maxAngle) - da;\n\n        //float interpAngle = ((minLength) * 1.0);\n        float interpAngle = offsetAngle + minLength * normalizedCenterDist * 2.0;\n        vec2 adjustedOffset = vec2(cos(interpAngle), sin(interpAngle)) * offsetLength;\n        c += adjustedOffset * SCALE * BLUR_AMOUNT * pow((1.01 - normalizedCenterDist/0.5), SWIRL_SIZE_EXP);\n        c *= ps;\n        color = max(color, pow(texture(iChannel0, c), vec4(1.0/(ADJUSTED_GAMMA*PASS_2_GAMMA_DENOM))));\n    }\n    \n    color.a = 1.0;\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Nt2fzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 313], [316, 316, 338, 338, 370], [372, 372, 398, 398, 441], [443, 443, 485, 485, 521], [523, 523, 569, 569, 655], [657, 657, 690, 690, 892], [1167, 1167, 1211, 1211, 2896]], "test": "untested"}
{"id": "sl2BRR", "name": "ErfStep", "author": "TinyTexel", "description": "Smoothstep build using the error function and its inverse.\nApproximates the common polynomial smoothsteps (+ their inverses) quite well.\nThe 1st derivative at x = 1/2 equals the sharpness parameter s.", "tags": ["smoothstep"], "likes": 9, "viewed": 319, "published": 3, "date": "1651726292", "time_retrieved": "2024-07-30T16:50:09.910124", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n    Smoothstep build using the error function and its inverse.\n    Approximates the common polynomial smoothsteps (+ their inverses) quite well.\n    The 1st derivative at x = 1/2 equals the sharpness parameter s.\n    ErfStep(x, s) = Erf( InverseErf(x*2-1)*s )/2+1/2\n    ErfStep(ErfStep(x, s), 1/s) = x\n    \n    red:   ErfStep\n    blue:  inverse ErfStep\n    black: Smoothsteps\n*/\n\n\nfloat Smoothstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return x*x * (x * -2.0 + 3.0);\n}\n\nfloat Smootherstep(float x)\n{\n    x = clamp(x, 0.0, 1.0);\n    \n    return x*x*x * (x * (x * 6.0 - 15.0) + 10.0);\n}\n\n\n// https://en.wikipedia.org/wiki/Error_function#Approximation_with_elementary_functions\nfloat Erf(float x)\n{\n\tbool neg = x < 0.0;\n    \n    const float a = 0.147;\n    const float b = 1.27324;//4.0/Pi\n    \n    float xx = x*x;\n    float xxa = xx*a;\n    float y = sqrt(1.0 - exp(-xx * (xxa + b) / (xxa + 1.0)));\n    \n    return neg ? -y : y;\n}\n\nfloat ErfI(float x)\n{\n\tbool neg = x < 0.0;\n\n    const float a = 6.802721;// 1.0/0.147\n    const float b = 4.330747;// 2.0 / Pi * a\n    \n    float u = log(1.0 - x*x);\n    float c = u * 0.5 + b;\n    \n    float y = sqrt(sqrt(c*c - u*a) - c);\n    \n    return neg ? -y : y;\n}\n\n\nfloat ErfStep(float x, float s)\n{\n    if(x <= 0.0) return 0.0;\n    if(x >= 1.0) return 1.0;\n    \n    return Erf(ErfI(x * 2.0 - 1.0) * s) * 0.5 + 0.5;\n}\n\n\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += .0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.125;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.25+0.0375;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    // sharpness parameter for the non-hardcoded erfstep curve\n    float s = min(mix(-0.125, 1.125, iMouse.x / iResolution.x), 1.0);\n    \n    if(s < 0.0)\n    s = (sin(iTime * 0.25) + 1.0) * 3.0 + 1.0;\n    else\n    s = 1.0 + s * 8.0;\n    \n    // inverse erfsteps (blue)\n   #if 1\n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(  3.0/ 2.0)) -tex.y, 1.0)); \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/( 15.0/ 8.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(  9.0/ 4.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/( 45.0/16.0)) -tex.y, 1.0));            \n    col = mix(col, vec3(0.5, 0.75, 1.0), Graph(ErfStep(tex.x, 1.0/(225.0/64.0)) -tex.y, 1.0));\n   #endif\n    col = mix(col, vec3(0.1, 0.25, 1.0), Graph(ErfStep(tex.x, 1.0/s) -tex.y, 0.5));      \n\n    // erfsteps (red)\n   #if 1\n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,   3.0/ 2.0) -tex.y, 1.5)); \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,  15.0/ 8.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,   9.0/ 4.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x,  45.0/16.0) -tex.y, 1.5));            \n    col = mix(col, vec3(1.0, 0.5, 0.5), Graph(ErfStep(tex.x, 225.0/64.0) -tex.y, 1.5));\n   #endif\n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(ErfStep(tex.x, s) -tex.y, 0.5));        \n\n    // polynomial smoothsteps (thin + black)\n   #if 1\n    col = mix(col, vec3(0.1), Graph(Smoothstep(tex.x) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(tex.x) -tex.y, -0.25)); \n    col = mix(col, vec3(0.1), Graph(Smoothstep(Smoothstep(tex.x)) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(Smoothstep(tex.x)) -tex.y, -0.25));  \n    col = mix(col, vec3(0.1), Graph(Smootherstep(Smootherstep(tex.x)) -tex.y, -0.25));  \n   #endif\n   \n    #if 1\n    {\n        vec2 s = (uv0/iResolution.xy*2.0-1.0);\n        s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n        col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    }\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define Frame float(iFrame)\n#define Time iTime\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sl2BRR.jpg", "access": "api", "license": "cc0-1.0", "functions": [[454, 454, 481, 481, 551], [553, 553, 582, 582, 667], [670, 758, 778, 778, 1009], [1011, 1011, 1032, 1032, 1281], [1284, 1284, 1317, 1317, 1435], [1439, 1439, 1487, 1487, 4095]], "test": "untested"}
{"id": "7tBfzz", "name": "Fast SDF Terrain", "author": "zesterer", "description": "Terrain raymarching, but with a few special techniques that radically improve performance and reduce artifacts, particularly at glancing angles.", "tags": ["ray", "terrain", "sdf", "march"], "likes": 11, "viewed": 843, "published": 3, "date": "1651705617", "time_retrieved": "2024-07-30T16:50:10.659122", "image_code": "#define DEBUG false\n#define CAMERA_CONTROL false\n\nconst float PLANCK = 0.01;\n\nvec4 sdf_union(vec4 a, vec4 b) {\n    return a.w < b.w ? a : b;\n}\n\nfloat sdf(vec3 pos) {\n    float height = (\n        texture(iChannel1, pos.xy * 0.002).x +\n        texture(iChannel1, pos.xy * 0.02).x * 0.1 +\n        texture(iChannel1, pos.xy * 0.1).x * 0.03\n    ) * 30.0;\n    float ao = min(pow(texture(iChannel1, pos.xy * 0.02).x * 2.0, 1.5), 1.0);\n    \n    return pos.z - height;\n}\n\nvec3 sdf_col(vec3 pos, vec3 norm) {\n    float ao = min(texture(iChannel1, pos.xy * 0.1).x * 2.0, 1.0);\n    return ao\n        * mix(vec3(1.0, 0.5, 0.2), vec3(0, 1, 0), clamp((-norm.z - 0.5) * 2.0, 0.0, 1.0));\n}\n\nvec3 sdf_norm(vec3 pos) {\n    const float NORM_PLANCK = PLANCK * 5.0;\n    float d000 = sdf(pos);\n    float d100 = sdf(pos + vec3(NORM_PLANCK, 0.0, 0.0));\n    float d010 = sdf(pos + vec3(0.0, NORM_PLANCK, 0.0));\n    float d001 = sdf(pos + vec3(0.0, 0.0, NORM_PLANCK));\n    \n    return normalize(d000 - vec3(d100, d010, d001));\n}\n\nconst int MAX_ITER = 256;\n\nfloat march(vec3 pos, vec3 dir, out bool hit, out int i, out float min_d) {\n    // Always jump at least this far, massively speeding up glancing rays\n    // This comes at the cost of resolving surface details, but we can hack this parameter with distance to reduce this\n    const float MIN_JUMP = PLANCK * 10.0;\n    const float MIN_JUMP_FACTOR = 0.003;\n\n    // Remember the surface we got closest to during march and use that *as* the surface\n    min_d = 100000.0;\n    float min_t = 0.0;\n    \n    float t = 0.0;\n    for (i = 0; i < MAX_ITER; i ++) {\n        float d = sdf(pos + dir * t);\n        \n        if (abs(d) < PLANCK * t * 0.1) {\n            hit = true;\n            return t;\n        } else if (d < min_d) {\n            min_d = d;\n            min_t = t;\n        } else if (t > 2000.0) {\n            hit = false;\n            return 10000.0;\n        }\n        \n        t += d * (0.4 + t * MIN_JUMP_FACTOR + MIN_JUMP);\n    }\n    \n    hit = true;\n    return min_t;\n}\n\nvec3 ray_dir(vec3 z_up, vec3 dir, float fov, float aspect, vec2 uv) {\n    vec3 right = normalize(cross(z_up, dir));\n    vec3 up = cross(dir, right);\n    return normalize(dir + right * uv.x * aspect * fov + up * uv.y * fov);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    vec3 origin = vec3(0, 0, 25);\n    vec2 angle = (iMouse.xy/iResolution.xy * 2.0 - vec2(1.0, 0.5)) * vec2(-5, -2.5) - vec2(0, 5);\n    vec2 ldir = vec2(sin(angle.x), cos(angle.x));\n    vec3 cpos = vec3(ldir * max(cos(angle.y), 0.01), sin(angle.y)) * 50.0 + origin;\n    \n    if (!CAMERA_CONTROL) {\n        cpos.xy = vec2(sin(iTime), cos(iTime * 1.5)) * 50.0 + 20.0;\n    }\n    \n    vec3 cdir = normalize(origin - cpos);\n    \n    vec3 dir = ray_dir(vec3(0, 0, 1), cdir, 0.8, 1.5, uv);\n    \n    float sun_angle = iTime * 0.2 * 0.0 + 3.3;\n    vec3 sun_dir = normalize(vec3(0, cos(sun_angle), sin(sun_angle)));\n    vec3 sky = vec3(0.5, 0.5, 1.0);\n    \n    bool hit;\n    int n;\n    float min_d;\n    float t = march(cpos, dir, hit, n, min_d);\n    vec3 pos = cpos + dir * t;\n    \n    vec3 col = sky;\n    if (hit) {\n        vec3 norm = sdf_norm(pos);\n        vec3 surf = sdf_col(pos, norm);\n        float specular = pow(max(0.0, dot(reflect(dir, norm), -sun_dir)), 5.0);\n        \n        bool _hit;\n        int _n;\n        float _min_d;\n        float shadow = clamp((march(pos - norm * 0.3, -sun_dir, _hit, _n, _min_d) - 100.0), 0.0, 1.0);\n        \n        float occlusion = min(max(dot(sun_dir, norm), 0.0), shadow);\n        col = surf * ((1.0 + specular) * occlusion * 0.85 + 0.15);\n    }\n    col = mix(sky, col, min(1.0 / exp(0.002 * t), 1.0));\n    \n    if (DEBUG && iMouse.z > 0.0) {\n        col = vec3(float(n) / float(MAX_ITER), min_d, 0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tBfzz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 110, 110, 142], [144, 144, 165, 165, 461], [463, 463, 498, 498, 672], [674, 674, 699, 699, 1001], [1030, 1030, 1105, 1299, 2000], [2002, 2002, 2071, 2071, 2227], [2229, 2229, 2286, 2286, 3821]], "test": "untested"}
{"id": "7tsfDs", "name": "Fractional Laplacian & Gradient", "author": "FabriceNeyret2", "description": "WIP   -  left to right: gradient, fractional gradient, fractional Laplacian, Laplacian\nmouse.y controls fractional derivative order\nhttps://en.wikipedia.org/wiki/Fractional_Laplacian\nhttps://en.wikipedia.org/wiki/Fractional_calculus", "tags": ["fractionalcalculus"], "likes": 13, "viewed": 596, "published": 3, "date": "1651686585", "time_retrieved": "2024-07-30T16:50:11.403133", "image_code": "// Disclaimer: I'm just experimenting something I didn't know 10 minutes ago.\n// don't trust anything ! ( correctness & discretization ). :-)\n// For a start, proper normalization is required, but it needs the gamma() function.\n// Then the integration near the poles should surely be thinner.\n// long term aim: http://www.mountaincartography.org/activities/workshops/banff_canada/papers/brown.pdf\n\n#define ch iChannel0\n#define T(u) texelFetch(ch, ivec2(u)%textureSize(ch,0), 0 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy, D = vec2(1,0),\n         U = ( 2.*u - R ) / R.y;\n         \n    float t = 0., m = 0., w, p = 2.*iMouse.y/R.y;\n    int N,k;\n    O-=O;\n    \n    if (U.x > 1.) {                         // --- Laplacian\n        O = T(u+D)+T(u-D)+T(u+D.yx)+T(u-D.yx) - 4.*T(u);\n        t=1.; m = .2;\n    }\n    else if (U.x > 0.) {                    // --- Fractional Laplacian\n        for ( N=21,k=0; k < N*N; k++ ) {\n            D = vec2(k%N,k/N) -float(N-1)/2.;\n            if (D==vec2(0)) continue;\n            t += w = 1./ pow( length(D), 2. + 2.*p );\n            O += w* ( T(u)-T(u+D) );\n            m = max(m, abs( (T(u)-T(u+D)).x ) );\n          }\n        m = .07;\n    }\n    else if (U.x < -1.) {                    // --- Gradient\n        O = vec4( T(u+D).x - T(u).x, T(u+D.yx).x - T(u).x, 0,0 );\n        t=1.; m = .07;\n    }\n    else {                                  // --- Fractional Gradient\n        for ( N=51,k=1; k < N; k++ ) {   // N should be larger, but lack of normalization \n            D = vec2(-k,0);\n            if (D==vec2(0)) continue;\n            t += w = 1./ pow( length(D), p );\n            O += w* vec4( T(u+D).x, T(u+D.yx).x, 0,0 );\n            m = max(m, abs( (T(u+D)).x ) );\n        }\n        O.x = dFdx(O.x);  O.y = dFdy(O.y);\n        m = .07;\n     // O = vec4( dot(O,vec4(.7,.7,0,0)) );\n    }\n    \n    O = .5 + O/t/m;\n}\n", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[479, 479, 517, 517, 1877]], "test": "untested"}
{"id": "7llBWs", "name": "Golden Hour", "author": "zesterer", "description": "Playing around with DDA raymarching.", "tags": ["raymarch", "sky", "city", "scene", "dusk"], "likes": 11, "viewed": 440, "published": 3, "date": "1651679683", "time_retrieved": "2024-07-30T16:50:12.143154", "image_code": "vec3 ray_dir(vec3 z_up, vec3 dir, float fov, float aspect, vec2 uv) {\n    vec3 right = normalize(cross(z_up, dir));\n    vec3 up = cross(dir, right);\n    return normalize(dir + right * uv.x * aspect * fov + up * uv.y * fov);\n}\n\nfloat hash(ivec2 p) {\n    ivec2 q = p * ivec2(1317301, 1712759);\n    return fract(float((q.x ^ q.y)) * 0.0001);\n}\n\nfloat vmin(vec3 v) {\n\treturn min(min(v.x, v.y), v.z);\n}\n\nfloat base_at(vec2 p) {\n    return (sin(p.x * 0.1) + sin(p.y * 0.1) - 1.0) * 2.0;\n}\n\nconst float WATER_LEVEL = -5.0;\n\n// 0 = building\n// 1 = park\n// 2 = crossroad\n// 3 = hroad\n// 4 = vroad\n// 5 = water\nfloat height_at(vec2 p, out int kind) {\n    float base = base_at(floor(p));\n    if (base < WATER_LEVEL) {\n        kind = 5;\n        return WATER_LEVEL;\n    } else if (base < WATER_LEVEL + 0.5) {\n        kind = 1;\n        return WATER_LEVEL + 0.05;\n    }\n    ivec2 grid = ivec2(p);\n    if (grid.x % 4 == 0) {\n        if (grid.y % 4 == 0) {\n            kind = 2;\n            return base + 0.1;\n        } else {\n            kind = 4;\n            return base;\n        }\n    } else if (grid.y % 4 == 0) {\n        kind = 3;\n        return base;\n    }\n    float grass = hash(ivec2(floor(p) * 0.2));\n    if (grass > 0.85) {\n        kind = 1;\n        return base;\n    }\n    kind = 0;\n    return floor(base + 1.0 + pow(hash(ivec2(p)), 8.0) * 5.0);\n}\n\nconst float PLANCK = 0.01;\nconst vec3 SKY_COLOR = vec3(0.1, 0.1, 0.3);\nconst vec3 SUN_DIR = normalize(vec3(-1, 0.5, -0.5));\n\nvec3 grass_at(vec2 pos) {\n    pos += sin(pos.yx * 3.0) * 0.3;\n    if (fract(pos.x * 0.3) < 0.03 || fract(pos.y * 0.3) < 0.03) return vec3(1, 0.8, 0);\n    return vec3(0.5, 1, 0) * (0.5 + hash(ivec2(floor(pos * 40.0))) * 0.5);\n}\n\nfloat wheight(vec2 pos) {\n    return dot(sin(pos.yx * 30.0 + iTime * 3.0 + sin(pos.xy * 10.0 + iTime) * 2.0), vec2(1))\n        + dot(sin(pos.yx * 30.0 - iTime * 3.0 + sin(pos.xy * 10.0 - iTime) * 2.0), vec2(1));\n}\n\nvec4 roof_col(vec2 p, vec2 pos, float h, int kind, inout vec3 norm, inout float spec) {\n    float base = base_at(floor(pos));\n    if (kind == 5) {\n        float h00 = wheight(pos + vec2(0.0, 0.0) * 0.001);\n        float h10 = wheight(pos + vec2(1.0, 0.0) * 0.001);\n        float h01 = wheight(pos + vec2(0.0, 1.0) * 0.001);\n        \n        norm = normalize(vec3(\n            (h10 - h00) / 0.3,\n            (h01 - h00) / 0.3,\n            1.0\n        ));\n        spec = 100.0;\n        return vec4(vec3(0.1, 0.6, 1), 0.0);\n    }\n    if (kind == 1) {\n        return vec4(grass_at(pos), 0.0);\n    }\n    if ((kind == 2 || kind == 4)) {\n        float car = fract(p.y + iTime * 0.6 * -sign(p.x - 0.5));\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.15 && car < 0.2) {\n            float c = sign(p.x - 0.5) < 0.0 ? (car / 0.2) : (1.0 - car / 0.2);\n            if (c < 0.1 && abs(fract(p.x * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 1, 0.5), 4.0);\n            if (c > 0.9 && abs(fract(p.x * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 0, 0), 4.0);\n            return vec4(vec3(1, 0.2, 0.2), 0.0);\n        };\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.05) {\n            if (fract(p.y * 6.0) < 0.5) return vec4(vec3(1), 0.0);\n        }\n        if (abs(fract(p.x * 2.0) - 0.5) < 0.35) {\n            return vec4(vec3(0.2), 0.0);\n        }\n    }\n    if ((kind == 2 || kind == 3)) {\n        float car = fract(p.x + iTime * 0.6 * -sign(p.y - 0.5));\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.15 && car < 0.2) {\n            float c = sign(p.y - 0.5) < 0.0 ? (car / 0.2) : (1.0 - car / 0.2);\n            if (c < 0.1 && abs(fract(p.y * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 1, 0.5), 4.0);\n            if (c > 0.9 && abs(fract(p.y * 2.0) - 0.5) > 0.05) return vec4(vec3(1, 0, 0), 4.0);\n            return vec4(vec3(1, 0.2, 0.2), 0.0);\n        };\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.05) {\n            if (fract(p.x * 6.0) < 0.5) return vec4(vec3(1), 0.0);\n        }\n        if (abs(fract(p.y * 2.0) - 0.5) < 0.35) {\n            return vec4(vec3(0.2), 0.0);\n        }\n    }\n    if (h - base > 2.5) {\n        p -= 0.5;\n        p = abs(p);\n        if ((length(p) > 0.3 && length(p) < 0.35) || (p.x < 0.15 && p.y < 0.05) || (p.x < 0.15 && p.x > 0.1 && p.y < 0.2)) {\n            return vec4(vec3(2), 0.0);\n        }\n    }\n    \n    return vec4(vec3(0.5) * (0.4 + hash(ivec2(floor(p * 10.0))) * 0.6), 0.0);\n}\n\nvec4 wall_col(vec2 p, vec3 pos, float h, int kind, inout vec3 norm) {\n    if (kind == 1) {\n        norm = vec3(0, 0, 1);\n        return vec4(grass_at(pos.xy), 0.0);\n    }\n    if (kind == 2 || kind == 3 || kind == 4) {\n        norm = vec3(0, 0, 1);\n        return vec4(vec3(0.3), 0.0);\n    }\n    //if (kind != 0) {\n    //    return vec4(roof_col(fract(pos.xy), pos.xy, h, kind), 0.0);\n    //}\n    if (fract(p.x * 7.5) > 0.5) {\n        vec2 wpos = p * vec2(7.5, 6.0) + floor(vec2(0.0, h * 50.0 + pos.x + pos.y));\n        if (abs(fract(wpos.x) - 0.75) < 0.15 && abs(fract(wpos.y) - 0.5) < 0.2) {\n            return vec4(vec3(1, 0.9, 0.4), max(0.0, hash(ivec2(wpos)) * 2.0) - 0.5);\n        }\n        return vec4(vec3(0.5), 0.0);\n    }\n    return vec4(vec3(0.3), 0.0);\n}\n\n// (color, t)\nvec4 march(vec3 dir, int iter, inout vec3 pos, out bool hit, out vec3 norm, out float t, inout float spec) {\n    spec = 20.0;\n    vec2 dir2d = normalize(dir.xy);\n    float invlen = 1.0 / length(dir.xy);\n    t = 0.0;\n    for (int i = 0; i < iter; i ++) {\n        vec2 deltas = (step(vec2(0), dir2d.xy) - fract(pos.xy)) / dir2d.xy;\n        float jmp = max(min(deltas.x, deltas.y) * invlen, PLANCK);\n        \n        int kind;\n        float h = height_at(pos.xy, kind);\n        float col_dist = (pos.z - h) / -dir.z;\n        vec3 col_pos = pos + dir * col_dist;\n        if (ivec2(floor(col_pos.xy)) == ivec2(floor(pos.xy)) && col_dist > 0.0 && dir.z < 0.0) {\n            hit = true;\n            norm = vec3(0, 0, 1);\n            t += col_dist;\n            pos = col_pos;\n            return roof_col(fract(col_pos.xy), col_pos.xy, h, kind, norm, spec);\n        } else if (pos.z < h) {\n            hit = true;\n            if (abs(round(pos).x - pos.x) < PLANCK) {\n                norm = vec3(-sign(dir.x), 0.0, 0.0);\n                return wall_col(vec2(fract(pos.y), pos.z - h), pos, h, kind, norm);\n            } else {\n                norm = vec3(0.0, -sign(dir.y), 0.0);\n                return wall_col(vec2(fract(pos.x), pos.z - h), pos, h, kind, norm);\n            }\n        }\n        \n        t += jmp;\n        pos += dir * jmp;\n    }\n    hit = false;\n    return vec4(vec3(0.0), 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    \n    vec3 cam_dir = vec3(0, 1, 0);\n    vec3 cam_pos = vec3(0, 1.0 + iTime, 5);\n    \n    cam_dir.xy = vec2(sin(iTime * 0.2), cos(iTime * 0.15)) * 40.0 + 20.5;\n    cam_dir.z = sin(iTime * 0.53) * 20.0 - 16.0;\n    cam_dir = normalize(cam_dir);\n    cam_pos.xy = vec2(sin(iTime * 0.05), cos(iTime * 0.1)) * 50.0 + 100.0;\n    cam_pos.z = max(5.0 + base_at(cam_pos.xy), WATER_LEVEL + 0.1);\n\n    vec3 dir = ray_dir(vec3(0, 0, 1), cam_dir, 0.8, 1.5, uv);\n    \n    bool hit;\n    vec3 norm;\n    float t;\n    float spec;\n    vec4 surf = march(dir, 250, cam_pos, hit, norm, t, spec);\n    \n    vec3 sky_color = mix(\n        vec3(0.7, 0.3, 0.0),\n        vec3(0, 0.1, 0.3),\n        pow(max(dir.z + 0.2, 0.0), 0.9)\n    );\n    vec3 sun_col = vec3(0.7, 0.5, 0.5);\n    \n    vec3 col;\n    if (hit) {\n        float shadow_t;\n        vec3 _norm;\n        float _spec;\n        cam_pos += norm * 0.1;\n        march(-SUN_DIR, 50, cam_pos, hit, _norm, shadow_t, _spec);\n    \n        float unmist = min(1.0 / exp(t * 0.03), 1.0);\n        float lambert = max(dot(-SUN_DIR, norm), 0.0);\n        float shadow = shadow_t > 25.0 ? 1.0 : 0.0;\n        float specular = pow(max(dot(-SUN_DIR, reflect(norm, -dir)), 0.0), spec) * spec * 0.05;\n        vec3 light = surf.rgb * (((lambert + specular) * shadow + 0.1) * sun_col + surf.w * unmist);\n        col = mix(sky_color, light, unmist);\n    } else {\n        col = sky_color\n            + max(0.0, 1.0 - dot(abs(fract(normalize(dir + sin(dir.zxy * 5.0) * 0.1) * 30.0) - 0.5), vec3(1)) * 8.0)\n            + sun_col * pow(max(dot(dir, -SUN_DIR), 0.0), 300.0) * 2.0;\n    }\n\n    // Output to screen\n    fragColor = vec4(col * min(iTime * 0.3, 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 225], [227, 227, 248, 248, 340], [342, 342, 362, 362, 397], [399, 399, 422, 422, 482], [517, 601, 640, 640, 1340], [1467, 1467, 1492, 1492, 1693], [1695, 1695, 1720, 1720, 1908], [1910, 1910, 1997, 1997, 4295], [4297, 4297, 4366, 4366, 5062], [5064, 5078, 5186, 5186, 6466], [6468, 6468, 6525, 6525, 8245]], "test": "untested"}
{"id": "7lsBDl", "name": "foggy depth map", "author": "FabriceNeyret2", "description": "very basic fog model in mountains valleys (seen from top).\n\nMouse.y = fog max height  \nMouse.x = optical depth ( inverse density )", "tags": ["terrain", "fog", "map", "cartography"], "likes": 5, "viewed": 444, "published": 3, "date": "1651677244", "time_retrieved": "2024-07-30T16:50:12.909106", "image_code": "#define T(U,l)    textureLod( iChannel0, U +.2, l ).r // terrain\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = u/R,\n         M = iMouse.z<=0. ? vec2(.5,.7) : iMouse.xy/R*vec2(2,1);\n\n    float h = T(U,0.),                     // heigth map\n          f = exp(-max(0.,(M.y-h)/M.x)),   // fog transparency\n                // M.y = fog max height  M.x = optical depth\n          c =  ( 1. + 300.*(h-T(U,1.)) )   // terrain texture\n             * (.2+h);                     // + ambient occlusion\n\n    O = c*vec4(1,.6,.4,0);                 // terrain color\n    O = mix( vec4(.6,.8,1,0), O, f );      // mix with fog (ultra-basic model)\n\n    O = sqrt(O);                           // to sRGB\n}", "image_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7lsBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 104, 104, 723]], "test": "untested"}
{"id": "stlBDl", "name": " - Truchsine", "author": "totetmatt", "description": "Truchsine", "tags": ["sin", "truchet"], "likes": 18, "viewed": 293, "published": 3, "date": "1651676696", "time_retrieved": "2024-07-30T16:50:13.661095", "image_code": "/*\n    Heavy inspiration from Flopine, Kamoshika and 0b5vr. Greets & thanks to them ! \n*/\nfloat fsnoise(vec2 c){\n    return fract(sin(dot(c, vec2(12.9898, 78.233))) * 43758.5453);\n}\nvec3 rot(vec3 p,vec3 ax,float t){\n    return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);\n}\nfloat box(vec3 p,vec3 b){\n    vec3 q = abs(p)-b;\n    return length(max(vec3(0.),q))+min(0.,max(q.x,max(q.y,q.z)));\n}\nfloat box2(vec2 p,vec2 b){\n    vec2 q = abs(p)-b;\n    return length(max(vec2(0.),q))+min(0.,max(q.x,q.y));\n}\nvec2 sdf(vec3 p){\n    p = rot(p,normalize(vec3(-sqrt(4.),sqrt(2.),0.)),-.785/2.);\n    p.z +=iTime;\n    float gy = dot(asin(sin(p*3.)),asin(cos(p*7.)))*.1;\n    vec3 hp=p,tp=p;\n\n    vec2 h;\n    vec2 I = ceil(hp.xz);\n    hp.xz -=I-.5;\n    hp.y = abs(hp.y);\n    hp.z *= fsnoise(I)<.5 ? -1.:1.;\n    hp.z *=sign(p.y);\n    hp.xz +=hp.z > -hp.x ? -.5:.5;\n\n    vec2 q=vec2(length(hp.xz)-.5,hp.y);\n    h.x = abs(box2(q,vec2(.05)));\n    h.y = 1.;\n    \n    vec2 t;\n \n    tp.y +=clamp(asin(sin(tp.z*3.1415-.95)),-.75,.75)*.25;\n    tp.x = mod(tp.x,2.)-1.;\n    t = vec2(.9*box2(tp.xy+gy*.1,vec2(.05-abs(gy)*.2)),2.); \n \n  \n\n    \n    h = t.x < h.x  ? t:h;\n    return h;\n}\n#define q(s) s*sdf(p+s).x\nvec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(uv*5.,-10.);\n    vec3 rp = ro;\n    vec3 light = vec3(1.,2.,-3);\n    vec3 rd = normalize(vec3(0,0,1.));\n    vec3 col  = vec3(0.1);\n    float dd = 0.;\n    vec3 acc = vec3(0.);\n    for(float i=0.;i<64.;i++){\n        vec2 d = sdf(rp);\n        if(d.y ==2. && d.x <.5){\n            float act = step(.5,sin(rp.z-iTime));\n               if(act==0.) {\n                    rp+=rd*.1;\n                    continue;\n               }\n                acc += vec3(cos(rp.z+rp.x)*.5+.5,.1,sin(rp.z)*.5+.5)*act*exp(fract(iTime+floor(rp.z)*.5)*-abs(d.x)*i*i)/20.;\n                d.x = max(act > 0. ? .0005:d.x,abs(d.x));\n                \n            \n        }\n        dd+=d.x;\n        if(dd>50.) break;\n        rp +=rd*d.x;\n        if(d.x<.0001 && d.y == 1.){\n            vec3 n = norm(rp,.001);\n            vec3 n2 = norm(rp,.005);\n            float dif = max(0.,dot(normalize(light),n));\n            float qq = length(n-n2);\n            if(d.y == 1.){\n                col = dif*vec3(.1)+vec3(.1,.5,1.1)*dif*smoothstep(.1,0.35,qq);\n            } else {\n                col = dif*vec3(1.);\n            \n            }\n            break;\n        }\n    \n    }\n    fragColor = vec4(col+sqrt(acc),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 90, 112, 112, 181], [182, 182, 215, 215, 275], [276, 276, 301, 301, 392], [393, 393, 419, 419, 501], [502, 502, 519, 519, 1157], [1184, 1184, 1211, 1211, 1286], [1288, 1288, 1345, 1345, 2618]], "test": "untested"}
{"id": "7tlBDl", "name": "Tiny speaker with sound", "author": "yasuo", "description": "I just wanted to try something new that I've never done before.", "tags": ["speaker"], "likes": 11, "viewed": 318, "published": 3, "date": "1651675504", "time_retrieved": "2024-07-30T16:50:14.409095", "image_code": "#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define PI 3.1415\n#define PI_2 PI*2.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n\n    vec3 col = vec3(1.0);\n    \n    p*=Rot(radians(37.0));\n    float d = B(p-vec2(0.7,0.0),vec2(0.7,0.25));\n    col = mix(col,vec3(0.9),S(d,0.0));\n    p = prevP;\n    d = B(p,vec2(0.15,0.2));\n    col = mix(col,vec3(0.2,0.3,0.5),S(d,0.0));\n    d = B(p-vec2(0.0,-0.21),vec2(0.12,0.01));\n    col = mix(col,vec3(0.3),S(d,0.0));\n    \n    d = length(p-vec2(0.0,0.06))-0.06;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = length(p-vec2(0.0,0.06))-0.05;\n    col = mix(col,vec3(0.4),S(d,0.0));\n    d = length(p-vec2(0.0,0.06))-0.03;\n    col = mix(col,vec3(0.2),S(d,0.0));\n        \n    d = length(p-vec2(0.0,-0.1))-0.08;\n    col = mix(col,vec3(1.0),S(d,0.0));\n    d = length(p-vec2(0.0,-0.1))-0.07;\n    col = mix(col,vec3(0.4),S(d,0.0));\n    d = length(p-vec2(0.0,-0.1))-0.05;\n    col = mix(col,vec3(0.2),S(d,0.0));\n    d = length(p-vec2(0.0,-0.1))-0.02;\n    col = mix(col,vec3(0.5,0.0,0.0),S(d,0.0));\n    \n    p.x = abs(p.x)-0.11;\n    d = length(p-vec2(0.0,-0.15))-0.02;\n    col = mix(col,vec3(0.5),S(d,0.0));\n    \n    p = prevP;\n    d = B(p-vec2(0.0,0.16),vec2(0.06,0.02));\n    col = mix(col,vec3(0.5),S(d,0.0));\n    \n    d = length(p-vec2(0.0,0.16))-0.01;\n    col = mix(col,vec3(0.9),S(d,0.0));\n    p.x = abs(p.x)-0.035;\n    d = length(p-vec2(0.0,0.16))-0.01;\n    col = mix(col,vec3(0.9),S(d,0.0));\n    \n    // react with sound\n    p = prevP;\n    float wave = fract(cos(2.*iTime*6.0)*sin(iTime*0.3));\n    d = length(p-vec2(0.0,-0.1))-clamp(wave*0.1,0.02,0.09);\n    col = mix(col,vec3(0.8),S(abs(d)-0.002,0.0));\n    \n    wave = fract(sin(2.*iTime*6.0)*cos(iTime*0.2));\n    d = length(p-vec2(0.0,0.06))-clamp(wave*0.1,0.02,0.07);\n    col = mix(col,vec3(0.8),S(abs(d)-0.002,0.0));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "sound_code": "#define PI 3.1415\n#define PI_2 PI*2.0\nconst float C = 261.63;\nconst float D = 293.66;\nconst float E = 329.63;\nconst float F = 349.23;\nconst float G = 392.00;\nconst float A = 440.00;\nconst float B = 493.88;\nconst float C2 = 523.25;\n\nvec2 mainSound( in int samp,float time) {\n    float t = fract(time*6.0);\n\n    float wave = fract(cos(2.*time)*sin(time*0.3));\n    float wave2 = fract(sin(2.*time)*cos(time*0.2));\n    vec2 result = vec2(sin(PI_2 * wave*E * t) * exp(-30.0 * t));\n    result += vec2(sin(PI_2 * wave2*B * t) * exp(-50.0 * t));\n\n    float volume = 0.03;    \n    return result*volume;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlBDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 243, 300, 300, 2087]], "test": "untested"}
{"id": "NtsBDs", "name": "Time Equation Test 16327", "author": "SnoopethDuckDuck", "description": "Replacing white ball with a softer/elastic bounce would be nice. The code is a bite crude.\n\nEquations:\nhttps://www.desmos.com/calculator/zmlydpd77c", "tags": ["e"], "likes": 1, "viewed": 174, "published": 3, "date": "1651671548", "time_retrieved": "2024-07-30T16:50:15.159090", "image_code": "#define pi 3.14159\n\nfloat sfloor(float a, float b) {\n    return floor(b) + 0.5 + 0.5 * tanh(a * (fract(b) - 0.5)) / tanh(0.5 * a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n      \n    float r = 0.04;\n    float or = 0.49 - r;\n\n    // sfloor time\n    float t = 0.5 * pi * sfloor(5., 0.5 * iTime);\n    vec2 p = or * vec2(cos(t), sin(t));  \n    float d = length(uv - p);\n    float s = step(d, r);\n    \n    // Ordinary time\n    float t2 = 0.25 * pi * iTime;\n    vec2 p2 = (or-2.*r) * vec2(cos(t2), sin(t2));  \n    float d2 = length(uv - p2);\n    float s2 = step(d2, r);\n    \n    // Squareroot two sfloor times\n    float t3 = 0.5 * pi * sfloor(50., 0.5 * iTime);\n    float t4 = 0.5 * pi * sfloor(10., 0.5 * iTime);\n    t3 = sqrt(0.5 * (t3 * t3 + t4 * t4));\n    vec2 p3 = (or-4.*r) * vec2(cos(t3),sin(t3));\n    float d3 = length(uv - p3);\n    float s3 = step(d3, r);   \n    \n    // sfloor + bounce\n    float f = 2. * fract(0.5*iTime) - 1.;\n    t4 -= (pi/2.) * pow(f, 8.);\n    vec2 p4 = (or-6.*r) * vec2(cos(t4),sin(t4));\n    float d4 = length(uv - p4);\n    float s4 = step(d4, r);\n      \n    vec3 col = vec3(s,s2,s3) + s4;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsBDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 52, 52, 132], [134, 134, 191, 191, 1238]], "test": "untested"}
{"id": "slScDy", "name": "Real atmosphere/sky scattering", "author": "blackholes", "description": "The code is come from:\nhttps://www.shadertoy.com/view/NtfGWN", "tags": ["sunset", "sun", "light", "sky", "effect", "glass", "sunlight", "shader", "atmosphere", "sunrise", "atmospheric", "grassland", "meadow", "lawn", "meadowland"], "likes": 5, "viewed": 400, "published": 3, "date": "1651664643", "time_retrieved": "2024-07-30T16:50:15.906093", "image_code": "float CAMERA_HEIGHT = 4.0; // meters\n    float sightdistance = 0.2;//meters\n\nconst int INTEGRATION_STEPS = 16;\n\n// Constants\n\nconst float PI = 3.141592653589793;\nconst float time_speed=10000.0;\n// in seconds\nconst float INF = 1e10;//1.0 / 0.0;\nconst float rotation_of_earth=86164.09;\nconst float revolution_of_earth=31558152.96;\nfloat time(){ return time_speed*iTime/rotation_of_earth-0.015;}\nfloat day_time(){return time()-time_speed*iTime/revolution_of_earth;}\nfloat brightness(){return 1.0+9.5*(1.0-smoothstep(-1.0/18.0,0.0,day_time()-floor(day_time()))+smoothstep(0.5,0.5+1.0/18.0,day_time()-floor(day_time()))-smoothstep(1.0-1.0/18.0,1.0,day_time()-floor(day_time())));}\nconst float beta =PI/6.0;\nconst vec2 EMPTY_INTERVAL = vec2(INF, -INF); // interval [a,b] represented as vec2(a, b)\n\nconst float EARTH_RADIUS = 6372000.0; // meters\nconst float ATMOSPHERE_HEIGHT = 100000.0; // meters\n vec3 camera_position(){return vec3(0.0, 0.0, EARTH_RADIUS + CAMERA_HEIGHT);}\nconst vec3 SUN_EMISSION = vec3(1.0);\nconst vec3 SUN_COLOR = vec3(1,1.06,1.034);\nconst vec3 EARTH_COLOR = vec3(0.10,0.19,0.29);\n\n// Scattering & absorption settings (try to set some to zero to see how important each of them is)\n\nconst vec3 RAYLEIGH_SCATTERING = vec3(5.802, 13.558, 33.1) * 6.8e-7;\nconst vec3 RAYLEIGH_EXTINSION = RAYLEIGH_SCATTERING;\n\nconst vec3 MIE_ABSOPTION = vec3(4.4) * 9.5e-6;\nconst vec3 MIE_SCATTERING = vec3(2.1) * 1e-5/1.5;\nconst vec3 MIE_EXTINSION = MIE_ABSOPTION + MIE_SCATTERING;\n\nconst vec3 OZONE_ABSORPTION = vec3(0.650, 1.881, 0.085) * 0.405e-6;\nconst vec3 OZONE_EXTINSION = OZONE_ABSORPTION;\n\nfloat rayleigh_density(float height)\n{\n    return exp(- height / 7994.0);\n}\n\nfloat mie_density(float height)\n{\n    return exp(- height / 1200.0);\n}\n\nfloat ozone_density(float height)\n{\n    return max(0.0, 1.0 - abs(height - 25000.0) / 15000.0);\n}\n\nfloat rayleigh_phase(float c)\n{\n    return (1.0 + c * c) * (3.0 / 16.0 / PI);\n}\n\nfloat mie_phase(float c)\n{\n    float g = 0.76;\n    return (3.0 / 8.0 / PI) * (1.0 - g * g) * (1.0 + c * c) / (2.0 + g * g) / pow(1.0 + g * g - 2.0 * g * c, 1.5);\n}\n\n// Math helpers\n\nvec2 interval_intersection(vec2 i1, vec2 i2)\n{\n    return vec2(max(i1.x, i2.x), min(i1.y, i2.y));\n}\n\nbool empty(vec2 i)\n{\n    return i.x > i.y;\n}\n\nvec2 solve_quadratic(float a, float b, float c)\n{\n    float D = b * b - 4.0 * a * c;\n    if (D < 0.0)\n        return vec2(INF, INF);\n    D = sqrt(D);\n        \n    float x1, x2;\n    if (b >= 0.0)\n    {\n        x1 = (- b - D) / 2.0 / a;\n        x2 = 2.0 * c / (- b - D);\n    }\n    else\n    {\n        x1 = 2.0 * c / (- b + D);\n        x2 = (- b + D) / 2.0 / a;\n    }\n    \n    if (x1 < x2)\n        return vec2(x1, x2);\n    return vec2(x2, x1);\n}\n\n// Raycast\nmat3 spinxyz(int axis,float angle,mat3 XYZ)\n{\n    vec3 X,Y,Z;\n\n\tif(axis==1)\n\t{\n\t   X = XYZ[0];\n       Y = XYZ[1];\n       Z = XYZ[2];\n\t}\n\tif(axis==2)\n\t{\n\t   X = XYZ[1];\n       Y = XYZ[2];\n       Z = XYZ[0];\n\t}\t\n    if(axis==3)\n\t{\n       X = XYZ[2];\n       Y = XYZ[0];\n       Z = XYZ[1];\n\t}\n\tZ = Z * cos(angle) + Y * sin(angle);\n    Y = cross(Z, X);\n\tif(axis==1)\n\treturn mat3(X,Y,Z);\n\tif(axis==2)\n\treturn mat3(Z,X,Y);\n\tif(axis==3)\n\treturn mat3(Y,Z,X);\n}\nvec3 transformxyz(vec3 xyz,mat3 XYZ)\n{\n    float nx=XYZ[0].x*xyz.x+XYZ[0].y*xyz.y+XYZ[0].z*xyz.z;\n\tfloat ny=XYZ[1].x*xyz.x+XYZ[1].y*xyz.y+XYZ[1].z*xyz.z;\n\tfloat nz=XYZ[2].x*xyz.x+XYZ[2].y*xyz.y+XYZ[2].z*xyz.z;\n\treturn vec3(nx,ny,nz);\n}\nvec2 sphere_raycast(vec3 ray_origin, vec3 ray_direction, float radius)\n{\n//    |o + td| = r\n//    o^2 + 2t do + t^2 d^2 = r^2\n    float a = 1.0;\n    float b = dot(ray_direction, ray_origin) * 2.0;\n    float c = dot(ray_origin, ray_origin) - radius * radius;\n        \n    vec2 t = solve_quadratic(a, b, c);        \n    if (t == vec2(INF, INF))\n        return EMPTY_INTERVAL;\n    return interval_intersection(t, vec2(0.0, INF));\n}\n\nvec2 atmosphere_raycast(vec3 ray_origin, vec3 ray_direction)\n{\n    vec2 i = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 ip = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n    if (!empty(ip))\n        i = interval_intersection(i, vec2(-INF, ip.x));\n    return i;\n}\n\n// Main raymarching\n\nvec3 transmittance(vec3 origin, vec3 direction, float tmax, int steps)\n{\n    vec3 log_result = vec3(0.0);\n    float dt = tmax / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt;\n        vec3 p = origin + t * direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        log_result += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        log_result += MIE_EXTINSION * mie_density(h) * dt;\n        log_result += OZONE_EXTINSION * ozone_density(h) * dt;\n    }\n    return exp(- log_result);\n}\n\nvec3 sky_color(vec3 ray_origin, vec3 ray_direction, vec3 sun_direction, int steps)\n{\n    vec3 background = vec3(0.0);\n    vec3 stars= vec3(0);\n\tvec3 sun = vec3(0);\n    vec2 interval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n    vec2 uv;\n    vec2 pinterval = sphere_raycast(ray_origin, ray_direction, EARTH_RADIUS);\n\tmat3 n0=spinxyz(1,PI/2.0-beta,mat3(1,0,0,0,1,0,0,0,1));\n\tmat3 n=spinxyz(3,2.0*PI*time(),n0);\n\tmat3 n1=spinxyz(3,2.0*PI*day_time(),n0);\n\tvec3 skyn=transformxyz(ray_direction,n);\n\tvec3 sunn=transformxyz(ray_direction,n1);\n    \t\t\t\t float ay2 = asin(skyn.z);\n     float ax2=asin(skyn.x / cos(asin(skyn.z)));\n\t\t\t if (skyn.y < 0.0) ax2 = 3.0 * PI / 2.0 + ax2;\n\t\t\t else ax2 = PI / 2.0 - ax2;\n\t\t\t uv.x=1.0-ax2/PI/2.0;\n\t\t\t uv.y=1.0-(ay2+PI/2.0)/PI;\n stars = texture( iChannel0, uv ).xyz;\n if(stars.b>0.8)stars=exp(2.15*(stars.r+stars.g+stars.b))*stars/2.8;\n if(sunn.x>0.9999891)sun = vec3(1);\n else sun=sun;\n    if (!empty(pinterval))\n    {\n        vec3 n = normalize(ray_origin + ray_direction * pinterval.x);\n\t\t\t\tvec3 earthcolor=transformxyz(n,n0);\n    float ay = asin(earthcolor.z);\n     float ax=asin(earthcolor.x / cos(asin(earthcolor.z)));\n\t\t\t if (earthcolor.y < 0.0) ax = 3.0 * PI / 2.0 + ax;\n\t\t\t else ax = PI / 2.0 - ax;\n\t\t\t uv.x=ax/PI/2.0;\n\t\t\t uv.y=0.5-ay/PI;\n\tvec3 col4 = texture( iChannel1, uv ).xyz;\n        background = 0.017* max(0.0, dot(n, sun_direction))*col4;\n\t\tstars=sun=vec3(0);\n        interval = interval_intersection(interval, vec2(-INF, pinterval.x));\n    }\n    \n    \n    vec3 result = vec3(0.0);\n\n    vec3 tcoeff = vec3(0.0);\n    \n    float dt = (interval.y - interval.x) / float(steps);\n    for (int i = 0; i < steps; ++i)\n    {\n        float t = (float(i) + 0.5) * dt + interval.x;\n        vec3 p = ray_origin + t * ray_direction;\n        float h = length(p) - EARTH_RADIUS;\n        \n        // Instead of calling transmittance(p, -ray_direction, t, steps) to\n        // compute how much scattered light actually reachs the camera (as opposed\n        // to being absorbed or scattered again), we make use of the raymarching\n        // and compute transmittance on the go. The actuall transmittance factor\n        // is exp(-tcoeff) * dt\n        \n        tcoeff += RAYLEIGH_EXTINSION * rayleigh_density(h) * dt;\n        tcoeff += MIE_EXTINSION * mie_density(h) * dt;\n        tcoeff += OZONE_EXTINSION * ozone_density(h) * dt;\n        \n        vec2 it = sphere_raycast(p, sun_direction, EARTH_RADIUS);\n        \n        vec3 emitter = vec3(0.0);\n        if (!empty(it))\n            emitter = EARTH_COLOR;\n        else\n        {\n            it = sphere_raycast(p, sun_direction, EARTH_RADIUS + ATMOSPHERE_HEIGHT);\n        \n            if (!empty(it))\n                emitter = SUN_EMISSION* rayleigh_density(h);\n        }\n            \n        vec3 incoming = transmittance(p + it.x * sun_direction, sun_direction, it.y - it.x, steps) * SUN_EMISSION;\n        \n        float c = dot(-sun_direction, -ray_direction);\n        \n        vec3 scatter = vec3(0.0);\n        scatter += RAYLEIGH_SCATTERING * rayleigh_phase(c)*rayleigh_density(h)*1.0;\n        scatter += MIE_SCATTERING * mie_phase(c)*mie_density(h)*0.25;\n        \n        result += incoming * scatter * exp(-tcoeff) * dt;\n    }\n\n    result += (background+0.00002*stars+sun) * exp(-tcoeff);\n\n    return result;\n}\n\nvec3 tone_map(vec3 color)\n{\n    return pow(color / (vec3(1.0) + color), vec3(1.0 / 2.2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    vec3 sun_direction = vec3(sin(2.0*PI*day_time()+PI/2.0), cos(2.0*PI*day_time()+PI/2.0)*cos(PI/2.0-beta), -cos(2.0*PI*day_time()+PI/2.0)*sin(PI/2.0-beta));\n   vec2 uv = fragCoord/iResolution.y;\n    float x1 =uv.x-0.5*iResolution.x/iResolution.y;\n    float y1 =0.5-uv.y;\n    float screenR = sqrt(x1 * x1 + y1 * y1);\n    float eyeay = PI / 2.0 - atan(screenR*0.15/ sightdistance);\n    float eyeax=asin(y1 / screenR);\n     if (x1 > 0.0) eyeax = PI/2.0+eyeax;\n\t\t\t else eyeax = 3.0*PI/2.0- eyeax;       \n    vec2 m = vec2(2.0*iMouse.x / iResolution.y,-2.0*iMouse.y / iResolution.y)+vec2(0,0.5);    \n    m *= PI;   \n    vec3 view_direction;\n    //Rotation of spatial cartesian coordinates\n\t\tmat3 n=spinxyz(2,-m.y,spinxyz(3,-m.x,mat3(1.0, 0.0, 0.0,0.0, 1.0, 0.0,0.0, 0.0, 1.0)));\n    //Space cartesian coordinates to spherical coordinates\n    view_direction =\n        n[0] * cos(eyeax) * cos(eyeay) +\n        n[1] * sin(eyeax) * cos(eyeay) +\n        n[2] * sin(eyeay);\n    vec3 color = sky_color(camera_position(), view_direction, sun_direction, INTEGRATION_STEPS);       \n    fragColor = vec4(5.0*tone_map(color)*brightness()*SUN_COLOR, 1.0);\n}", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slScDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[329, 329, 342, 342, 392], [393, 393, 410, 410, 462], [463, 463, 482, 482, 675], [830, 893, 916, 916, 969], [1594, 1594, 1632, 1632, 1669], [1671, 1671, 1704, 1704, 1741], [1743, 1743, 1778, 1778, 1840], [1842, 1842, 1873, 1873, 1921], [1923, 1923, 1949, 1949, 2086], [2105, 2105, 2151, 2151, 2204], [2206, 2206, 2226, 2226, 2250], [2252, 2252, 2301, 2301, 2693], [2695, 2706, 2751, 2751, 3157], [3158, 3158, 3196, 3196, 3393], [3394, 3394, 3466, 3519, 3822], [3824, 3824, 3886, 3886, 4139], [8047, 8047, 8074, 8074, 8138], [8140, 8140, 8195, 8195, 9341]], "test": "untested"}
{"id": "slXfDs", "name": "My try at the Mandelbrot set", "author": "JustBoredYo", "description": "Never got it to work, turns out I always had a logic problem!", "tags": ["fractalmandelbrot"], "likes": 0, "viewed": 185, "published": 3, "date": "1651651240", "time_retrieved": "2024-07-30T16:50:16.651101", "image_code": "float zoom = 1.0;\n\nfloat scaleX = 4.0;\nfloat scaleY = 2.5;\n\nfloat itterations = 2500.;\n\nvec2 center = vec2(0., 0.);\n\nfloat zVal = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    scaleX *= zoom;\n    scaleY *= zoom;\n    \n    // Normalized pixel coordinates\n    float a = (fragCoord.x/iResolution.x)*scaleX-(scaleX/2.)+center.x;\n    float b = (fragCoord.y/iResolution.y)*scaleY-(scaleY/2.)+center.y;\n    \n    float ca = a;\n    float cb = b;\n    \n    vec3 col = vec3(1, 1, 1);\n    float i = 0.;\n    \n    for(i = 0.; i < itterations; i++)\n    {\n        \n        \n        float aa = a*a-b*b;\n        float bb = 2.*a*b;\n        \n        a = aa+ca;\n        b = bb+cb;\n        \n        if(a+b > 4.)\n            break;\n        \n    }\n    \n    if(i == itterations)\n        col = vec3(0, 0, 0);\n    else\n    {\n        float brightness = sqrt(i/itterations);\n        col = vec3(brightness);\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXfDs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 192, 192, 964]], "test": "untested"}
{"id": "slfBWs", "name": "elliptic curves", "author": "FabriceNeyret2", "description": "y = x + kx +a\nk = mouse.x   y = mouse.y", "tags": ["curves", "plot", "short", "ellipticcurves", "isovalue"], "likes": 15, "viewed": 355, "published": 3, "date": "1651649366", "time_retrieved": "2024-07-30T16:50:17.426029", "image_code": "void mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*(2.*u - R ) / R.y,\n         M = iMouse.z<=0. ? vec2( cos(iTime), sin(.314*iTime) ) // demo\n                         : 2.* iMouse.xy/R - 1.;                // control\n    float k = M.x, a = M.y, x = U.x, y = U.y, \n          v =  y*y - x*x*x - k*x - a;                           // field\n    O = vec4( abs(v)/fwidth(v) );                               // isovalue 0\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 449]], "test": "untested"}
{"id": "slffDl", "name": "30 Minutes 5/3", "author": "scry", "description": "Timelapse:\nhttps://www.youtube.com/shorts/KEueoReMhc0", "tags": ["3d", "fractal", "reflection", "trippy"], "likes": 16, "viewed": 336, "published": 3, "date": "1651645733", "time_retrieved": "2024-07-30T16:50:18.164057", "image_code": "//////////////////////////////////////////////////\n#define time iTime*0.1\n#define pi 3.1415926535\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nfloat f1(vec2 uv) {\n    float c = sdBox(vec3(uv,0.),vec3(0.));\n    float us = 0.25;\n    for (int i=0;i<10;i++) {\n        uv = abs(uv)-us;\n        c += min(c,sdBox(vec3(uv,0.),vec3(0.)));\n        us /= 2.;\n    }\n    return c;\n}\n\nvec4 map(vec3 p) {\n    p.z -= 4.;\n    p.xy *= r2d(45.*deg);\n    p.xz *= r2d(time*0.7);\n    p.yz *= r2d(time*0.3);\n    float d = sdBox(p,vec3(1.));\n    float dc = d;\n    p.zy *= r2d(45.*deg);\n    p.zy = abs(p.zy);\n    p.zy *= r2d(45.*deg);\n    p.xz *= r2d(45.*deg);\n    p.xz = abs(p.xz);\n    p.xz *= r2d(-45.*deg);\n    p.xy *= 0.5;\n    //float a = f1(p.xy);\n    //d += (sin(a*22.+time)*0.5+0.5)*0.04;\n    d = min(d,-sdBox(p,vec3(10.)));\n    p.xy = step(dc,2.)*p.xy+step(-dc,-2.)*p.xy*0.1;\n    float a = f1(p.xy);\n    d += (sin(a*22.-time*9.+sdBox(vec3(p.xy,0.),vec3(0.))*10.)*0.5+0.5)*0.1;\n    d += (sin(a*22.+time*9.)*0.5+0.5)*0.1*dc;\n    return vec4(p.xy,p.z,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<120;i++) {\n        vec3 p = ro + rd*dO;\n        float dS = map(p).w;\n        dO += dS*0.1;\n        ii += 0.01;\n        if (dO > 100. || dS < 0.01) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    float m = map(p+h.x).w;\n    return normalize(vec3(\n        m - map(p-h.xyy).w,\n        m - map(p-h.yxy).w,\n        m - map(p-h.yyx).w\n    ));\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d) {\n    vec3 mp = map(p).xyz;\n    float co = f1(mp.xy);\n    //co += time*0.2;\n    co = co;\n    co += n.x*0.2;\n    float sm = 10.;\n    vec3 col = vec3(sin(co*1.*sm),sin(co*sm*1.2),sin(co*sm*1.3))*0.5+0.5;\n    if (d.x > 99.) {\n        col = vec3(d.y);\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    col += sdBox(vec3(uv,0.),vec3(0.));\n    float us = 0.25;\n    float co = f1(uv);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    vec3 mp = map(p).xyz;\n    col = colo(p,n,d);\n    for (int i=0;i<2;i++) {\n        ro = p+n*0.003;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*0.5;\n    }\n    col *= 0.5;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slffDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 138, 138, 187], [189, 189, 218, 218, 281], [283, 283, 302, 302, 509], [511, 511, 529, 529, 1176], [1178, 1178, 1205, 1205, 1450], [1452, 1452, 1475, 1475, 1652], [1654, 1654, 1689, 1689, 1959], [1961, 1961, 2016, 2016, 2677]], "test": "untested"}
{"id": "ftXBWs", "name": "The Shapes Dance By Moonlight", "author": "zesterer", "description": "Playing around with SDFs and procedural music until I find something I like.", "tags": ["raymarching", "sdf", "shapes", "dance"], "likes": 5, "viewed": 389, "published": 3, "date": "1651618851", "time_retrieved": "2024-07-30T16:50:18.981869", "image_code": "vec3 ray_dir(vec3 z_up, vec3 dir, float fov, float aspect, vec2 uv) {\n    vec3 right = normalize(cross(z_up, dir));\n    vec3 up = cross(dir, right);\n    return normalize(dir + right * uv.x * aspect * fov + up * uv.y * fov);\n}\n\nconst float PLANCK = 0.01;\n\n\nvec2 smin(float a, float b, float k, float n)\n{\n    float h = max(k - abs(a - b), 0.0) / k;\n    float m = pow(h, n)*0.5;\n    float s = m*k/n;\n    \n    vec2 inv = vec2(1.0) / vec2(a, b);\n    float blend = inv.y / (inv.x + inv.y);\n    \n    return vec2((a<b) ? (a-s) : (b-s), blend);\n}\n\nvec4 sdf_union(vec4 a, vec4 b, float s) {\n    vec2 min_blend = smin(a.w, b.w, s, 2.0);\n    return vec4(mix(a.rgb, b.rgb, clamp(min_blend.y, 0.0, 1.0)), min_blend.x);\n    //return a.w < b.w ? a : b;\n}\n\nfloat vmin(vec3 v) {\n    return min(v.x, min(v.y, v.z));\n}\n\nfloat vmax(vec3 v) {\n    return max(v.x, max(v.y, v.z));\n}\n\nfloat s;\n\nvec4 sdf(vec3 pos) {\n    vec3 p = pos;\n\n    pos.xy = fract((pos.xy + 12.0) / 24.0) * 24.0 - 12.0;\n\n    ivec2 chess = ivec2(floor(pos.xy));\n    vec4 ground = vec4(\n        mix(vec3(0.5), vec3(float((chess.x ^ chess.y) & 1)), clamp(10.0 / length(pos), 0.0, 1.0)),\n       pos.z);\n    \n    float angle = iTime * sign(sin(p.y - pos.y) + 0.01) * 3.0 + sin(p.x - pos.x) * 10.0;\n    vec2 dir = vec2(sin(angle), cos(angle));\n    \n    vec4 ball = vec4(vec3(1, 0, 0), length(pos + vec3(dir * 5.0, -2.0)) - 2.0);\n    \n    vec4 cube = vec4(vec3(0, 1, 0), length(max(vec3(0.0), abs(pos - vec3(dir * 5.0, 2)) - vec3(2, 2, 5))));\n\n    vec4 sdf = sdf_union(sdf_union(ground, ball, s), cube, s);\n    return vec4(sdf.rgb, min(sdf.w, 2.0)); // Hack\n}\n\nvec3 sdf_norm(vec3 pos) {\n    float d000 = sdf(pos).w;\n    float d100 = sdf(pos + vec3(PLANCK, 0.0, 0.0)).w;\n    float d010 = sdf(pos + vec3(0.0, PLANCK, 0.0)).w;\n    float d001 = sdf(pos + vec3(0.0, 0.0, PLANCK)).w;\n    \n    return normalize(d000 - vec3(d100, d010, d001));\n}\n\nconst vec3 sky = vec3(0.2, 0.3, 0.6);\nvec3 sun_dir;\n\nvec3 color_ray(vec3 dir, inout vec3 pos, out bool hit) {\n    for (int i = 0; i < 256; ++i) {\n        vec4 col_dist = sdf(pos);\n        float dist = col_dist.w;\n        \n        if (dist < PLANCK) {\n            hit = true;\n            return col_dist.rgb;\n        }\n        \n        pos += dir * dist;\n    }\n    \n    hit = false;\n    return sky;\n}\n\nfloat shadow_ray(vec3 dir, inout vec3 pos) {\n    vec3 p = pos;\n    float min_shade = 1.0;\n    \n    // Throw in a bit of noise\n    pos += dir * PLANCK * 1.0 * fract(dot(pos, vec3(1000.0)));\n    \n    float t = 0.0;\n    float last_dist = 1e20;\n    for (int i = 0; i < 256; ++i) {\n        float dist = sdf(pos).w;\n        \n        // Approaching surface\n        if (dot(sdf_norm(pos - dir * last_dist), dir) > 0.0) {\n            float y = dist*dist/(2.0*last_dist);\n            float d = sqrt(dist*dist-y*y);\n            d = dist;\n\n            min_shade = min(min_shade, d * 3.0 / t);\n            \n            if (dist < PLANCK) {\n                min_shade = 0.0;\n                break;\n            }\n        }\n        \n        last_dist = dist;\n        t += dist;\n        \n        pos += dir * dist;\n    }\n    \n    return min_shade;\n}\n\nvec3 ray_cast(vec3 dir, inout vec3 pos) {\n    bool hit;\n    vec3 p = pos;\n    vec3 color = color_ray(dir, pos, hit);\n    vec3 q = pos;\n    \n    vec3 light = vec3(0);\n    if (hit) {\n        vec3 norm = sdf_norm(pos);\n        float lambert = max(dot(sun_dir, norm), 0.0);\n        float specular = pow(max(dot(reflect(-sun_dir, norm), dir), 0.0), 120.0) * 3.0;\n        float shade = min(lambert, clamp(shadow_ray(-sun_dir, pos), 0.0, 1.0));\n        float ambient = 0.1;\n        light = ((ambient + shade) * color + specular * shade) * sky * 2.0;\n        light = mix(sky, light, min(1.0 / exp(0.01 * distance(p, q)), 1.0));\n    } else {\n        light = sky + pow(max(dot(dir, -sun_dir), 0.0), 250.0) * 1.0;\n    }\n    \n    return light;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    sun_dir = normalize(vec3(vec2(sin(iTime), cos(iTime)) * sin(iTime * 0.2) * 5.0, -2.0));\n    s = 16.0 * sin(iTime * 3.0) * 0.5 + 0.5;\n\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    \n    vec2 angle = (iMouse.xy - iResolution.xy / 2.0) * 0.01;\n    vec3 cam_pos = vec3(vec2(sin(angle.x), cos(angle.x)) * 10.0, angle.y * 6.0 + 10.0);\n    \n    cam_pos.xy = vec2(sin(iTime * 0.5), cos(iTime * 0.8)) * 50.0;\n    cam_pos.z = 6.0 + (sin(iTime * 1.5) * 0.5 + 0.5) * 30.0;\n    \n    vec3 cam_focus = vec3(-vec2(sin(iTime * 1.2), cos(iTime * 1.0 + 0.5)) * 50.0 + vec2(10.0, 15.0), 5.0);\n    cam_pos.z = 7.5 + (sin(iTime * 1.3) * 0.5 + 0.5) * 30.0;\n    vec3 cam_dir = -normalize(cam_pos - cam_focus);\n    \n    vec3 dir = ray_dir(vec3(0, 0, 1), cam_dir, 1.5, 1.5, uv);\n    \n    vec3 col = ray_cast(dir, cam_pos);\n\n    // Output to screen\n    fragColor = vec4(col * min(iTime * 0.1, 1.0),1.0);\n}", "image_inputs": [], "sound_code": "float tone(float len, float time) {\n    time = time / len * (time > 0.0 ? 1.0 : 400.0);\n    time += 3.1415 * 0.5;\n    return (cos(time) * 0.5 + 0.5) * (abs(time) > 3.141 ? 0.0 : 1.0);\n}\n\nfloat repeat(float tempo, float time) {\n    return mod(time, tempo);\n}\n\nfloat Note(float pitch, float len, float time) {\n    return (sin(6.2 * 440.0 * time * pitch) * 0.5) * tone(len, time);\n}\n\nvec2 mainSound( int samp, float time )\n{\n    vec2 nz = vec2(0.0);\n    \n    time *= 1.0;\n    float t0 = repeat(4.5, time);\n    \n    float octave = sin(floor(time / 4.5)) * 0.35;\n    \n    nz += Note(0.7 + octave, 0.3, t0 - 0.5);\n    nz += Note(0.8 + octave, 0.3, t0 - 1.0);\n    nz += Note(0.9 + octave, 0.3, t0 - 1.5);\n    nz += Note(1.0 + octave, 0.3, t0 - 2.0);\n    nz += Note(0.9 + octave, 0.3, t0 - 2.5);\n    nz += Note(0.8 + octave, 0.3, t0 - 3.0);\n    nz += Note(0.7 + octave, 0.3, t0 - 3.5);\n    \n    float t1 = repeat(4.5, time * 2.0);\n    \n    float octave2 = sin(floor(time / 4.5)) * 0.35;\n    \n    nz += Note(1.0 + octave2, 0.25, t1 - 0.5) * 0.3;\n    nz += Note(0.9 + octave2, 0.25, t1 - 1.0) * 0.3;\n    nz += Note(0.8 + octave2, 0.25, t1 - 1.5) * 0.3;\n    nz += Note(0.7 + octave2, 0.25, t1 - 2.0) * 0.3;\n    nz += Note(0.8 + octave2, 0.25, t1 - 2.5) * 0.3;\n    nz += Note(0.9 + octave2, 0.25, t1 - 3.0) * 0.3;\n    nz += Note(1.0 + octave2, 0.25, t1 - 3.5) * 0.3;\n    \n    float t2 = repeat(4.5, time * 0.5);\n    \n    float octave3 = sin(floor(time / 4.5)) * 0.35;\n    \n    nz += Note(1.0 + octave3, 0.3, t2 - 0.5) * 0.3;\n    nz += Note(0.9 + octave3, 0.3, t2 - 1.0) * 0.3;\n    nz += Note(0.8 + octave3, 0.3, t2 - 1.5) * 0.3;\n    nz += Note(0.7 + octave3, 0.3, t2 - 2.0) * 0.3;\n    nz += Note(0.8 + octave3, 0.3, t2 - 2.5) * 0.3;\n    nz += Note(0.9 + octave3, 0.3, t2 - 3.0) * 0.3;\n    nz += Note(1.0 + octave3, 0.3, t2 - 3.5) * 0.3;\n    \n    return nz * min(time * 0.1, 1.0);\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXBWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 69, 69, 225], [256, 256, 303, 303, 538], [540, 540, 581, 581, 739], [741, 741, 761, 761, 799], [801, 801, 821, 821, 859], [871, 871, 891, 891, 1601], [1603, 1603, 1628, 1628, 1879], [1934, 1934, 1990, 1990, 2280], [2282, 2282, 2326, 2326, 3113], [3115, 3115, 3156, 3156, 3848], [3850, 3850, 3907, 3907, 4794]], "test": "untested"}
{"id": "7tsfDf", "name": "descending stairs", "author": "jorge2017a2", "description": "descending stairs", "tags": ["descendingstairs"], "likes": 15, "viewed": 239, "published": 3, "date": "1651609573", "time_retrieved": "2024-07-30T16:50:19.722888", "image_code": "///-------referencia\n///https://www.shadertoy.com/view/wlc3Wl\n///https://www.shadertoy.com/view/WlycDz\n\n//----------image\n//por jorge2017a2-\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define MIN_DIST 0.001\n#define EPSILON 0.001\n#define Ka 0.5\n#define Kd 0.4\nvec3 GetColorYMaterial(vec3 p,  vec3 n, vec3 ro,  vec3 rd, int id_color, float id_material);\nvec3 getMaterial( vec3 pp, float id_material);\nvec3 light_pos1;  vec3 light_color1 ;\nvec3 light_pos2;  vec3 light_color2 ;\n//descending stairs-----por JorgeF...3-may-2022\n\n//operacion de Union  por FabriceNeyret2\n#define opU2(d1, d2) ( d1.x < d2.x ? d1 : d2 )\n\nfloat sdBox( vec3 p, vec3 b )\n\t{ vec3 d = abs(p) - b;   return length(max(d,0.0))+ min(max(d.x,max(d.y,d.z)),0.0); }\nfloat sdCylinderYZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.yz),p.x)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXZ( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xz),p.y)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\nfloat sdCylinderXY( vec3 p, vec2 h )\n\t{ vec2 d = abs(vec2(length(p.xy),p.z)) - h; return min(max(d.x,d.y),0.0) + length(max(d,0.0)); }\n\nfloat Intersect(float distA, float distB)\n\t{ return max(distA, distB);}\nfloat Union(float distA, float distB)\n\t{ return min(distA, distB);}\nfloat Difference(float distA, float distB)\n\t{ return max(distA, -distB);}\n\nfloat opRep1D( float p, float c )\n\t{ float q = mod(p+0.5*c,c)-0.5*c; return  q ;}\n\nvec3 rotate_x(vec3 p, float phi)\n{   float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\n\n///https://www.shadertoy.com/view/WlycDz\nfloat distStairway(vec3 p) \n{\n    p.z = mod(p.z, sqrt(2.)) - sqrt(2.)/2.;\n    p.zx = abs(p.zx);\n    float d1 = dot(p, normalize(vec3(0, 1, 1))) - 0.5;\n    float d2 = dot(p, normalize(vec3(0, -1, -1))) - 0.5;\n    return max(p.x - 5., max(d1, d2));\n}\n\nvec2 GetDist(vec3 p  ) \n{\tvec2 res= vec2(9999.0, -1.0);  \n    p= rotate_x(p,radians(-45.0));\n    vec3 p0=p;\n\tfloat planeDist1 = p.y-1.0;  //piso inf\n    res =opU2(res, vec2(planeDist1,57.0));\n    float planeDist2 = 20.0-p.y;  //piso sup\n    float planeDist3 = p.x+5.0; //pared izq\n    float planeDist4 = 5.0-p.x;  //pared der\n    res =opU2(res, vec2(planeDist2,100.0)); \n    res =opU2(res, vec2(planeDist3,100.0)); \n    res =opU2(res, vec2(planeDist4,100.0)); \n    p.y=p.y-5.0;\n    \n    float d1= distStairway(p) ;\n    res =opU2(res, vec2(d1,57.0));\n    \n    vec3 prep=p0-vec3(0.0,10.0,5.0);\n    prep.z=opRep1D(prep.z, 20.0 );\n    prep.x=abs(prep.x)-4.0;\n    float d2= sdCylinderXZ(prep, vec2(1.0,10.0) );\n    res =opU2(res, vec2(d2,0.0));\n    \n    return res;\n}\n\nvec3 GetNormal(vec3 p)\n{   float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(GetDist(p-e.xyy).x,GetDist(p-e.yxy).x,GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, int PMaxSteps)\n{   vec3 p;\n    vec2 hit, object=vec2(0.1,0.0);\n    for(int i=0; i <= PMaxSteps; i++) \n    { p = ro + rd*object.x;\n      hit = GetDist(p);\n      object.x += hit.x;\n      object.y = hit.y;\n      if (abs(hit.x) < EPSILON || object.x > MAX_DIST) break;\n    }    \n    return object;\n}\n\n\nfloat getSoftShadow(vec3 p, vec3 lightPos) {\n    float res = 9999.0;\n    float dist = 0.01;\n    float lightSize = 0.03;\n    for (int i = 0; i < MAX_STEPS; i++) {\n      float hit = GetDist(p + lightPos * dist).x;\n      res = min(res, hit / (dist * lightSize));\n      dist += hit;\n      if (hit < 0.0001 || dist > 60.0) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat occlusion(vec3 pos, vec3 nor)\n{   float sca = 2.0, occ = 0.0;\n    for(int i = 0; i < 10; i++) {    \n      float hr = 0.01 + float(i) * 0.5 / 4.0;\n      float dd = GetDist(nor * hr + pos).x;\n      occ += (hr - dd)*sca;\n      sca *= 0.6;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\nvec3 lightingv3(vec3 normal,vec3 p, vec3 lp, vec3 rd, vec3 ro,vec3 lightColor, float t) \n{   vec3 lightPos=lp;\n    vec3 worldPos = p;\n    vec3 V = -rd;\n    vec3 N = normal;\n    vec3 L = normalize (lightPos - worldPos);\n    vec3 R = reflect (-L, N);\n\n    float lightDist = max(length(L), .001);\n    float atten=1.0 / (1.0 + lightDist * 0.125 + lightDist * lightDist * .05);\n    L /= (lightDist*atten);\n\n    float shadow = getSoftShadow(worldPos, L);// shadows\n        \n    float occ = occlusion(worldPos, N);// occ\n    vec3 ambient = Ka + Ka * dot(normal, vec3(0., 1., 0.))*lightColor;\n    ambient*=0.5;\n\n    vec3 fresnel =  lightColor *  pow(clamp(1.0 + dot(rd, N), 0.0, 1.0), 2.0);;\n    float diff= clamp(dot(N, L), 0.0, 1.0);\n    vec3 diffuse =  lightColor * diff;\n    float shininess=10.0;\n    float specular    = pow(max(dot(R, V), 0.0), shininess);\n\n    vec3 back = 0.5 * lightColor * clamp(dot(N, -L), 0.0, 1.0); // back\n    vec3 colOut = occ*lightColor*(ambient+diffuse*shadow+.25 +back) + vec3(.7,.9,1)*specular*specular;\n    return colOut;\n}\n\nvec3 getColorTextura( vec3 p, vec3 nor,  int i)\n{\tif (i==100 )\n    { vec3 col=tex3D(iChannel0, p/32., nor); return col*2.5; }\n\t\n}\n\nvec3 render_sky_color(vec3 rd)\n{   float t = (rd.x + 1.0) / 2.0;\n    vec3 col= vec3((1.0 - t) + t * 0.3, (1.0 - t) + t * 0.5, (1.0 - t) + t);\n    vec3  sky = mix(vec3(.0, .1, .4)*col, vec3(.3, .6, .8)*0.75, 1.0 - rd.y);\n    return sky;\n    \n}\n\n//https://www.shadertoy.com/view/4lcSRn   ///IQ\nvec3 pattern( in vec2 uv )\n{   vec3 col = vec3(0.4);\n    col += 0.4*smoothstep(-0.01,0.02,cos(uv.x*0.5)*cos(uv.y*0.5)); \n    col *= smoothstep(-1.0,-0.98,cos(uv.x))*smoothstep(-1.0,-0.98,cos(uv.y));\n    return col;\n}\n\n//iq\nfloat xorTexture( in vec2 pos )\n{  float xor = 0.0;\n    for( int i=0; i<8; i++ )\n    {   xor += mod( floor(pos.x)+floor(pos.y), 2.0 );\n       pos *= 0.5;\n        xor *= 0.5;\n    }\n    return xor;\n}\n\nvec3 GetMaterial(vec3 p,  vec3 nor, vec3 ro,  vec3 rd, int id_color)\n{  \tvec3 colobj; \n     if (id_color==0) { colobj=vec3(0.0);  return colobj; }\n\n    if (id_color==57) {return pattern( p.xz );}\n    if (id_color==58) {return pattern( p.xy );}\n    if (id_color==59) {return pattern( p.zy );}\n    \n    if (id_color==67)\n    {return vec3(1.0)*xorTexture(p.xz*10.0 );}\n    \n    \n   if (id_color>=100 )\n   { return  getColorTextura( p, nor,id_color); }\n      \n}\n\nvec3 linear2srgb(vec3 c) \n{ return mix(12.92 * c,1.055 * pow(c, vec3(1.0/1.8)) - 0.055, step(vec3(0.0031308), c)); }\n\nvec3 exposureToneMapping(float exposure, vec3 hdrColor) \n{ return vec3(1.0) - exp(-hdrColor * exposure); }\n\nvec3 ACESFilm(vec3 x)\n{   float a,b,c,d,e;\n    a = 2.51; b = 0.03; c = 2.43;d = 0.59; e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\n\nvec3 Render(vec3 ro, vec3 rd)\n{  vec3 col = vec3(0);\n  vec3 p;\n     vec2 hit=RayMarch(ro,rd, MAX_STEPS);\n      if(hit.x<MAX_DIST)\n       {   p = (ro + rd * hit.x );\n        vec3 nor=GetNormal(p);\n        vec3 colobj;\n        colobj=GetMaterial( p, nor, ro, rd,  int(hit.y));\n        vec3 result;\n         result= lightingv3(nor, p,light_pos1, rd,ro,colobj,hit.x)*light_color1;\n        result+= lightingv3(nor, p,light_pos2,rd, ro,colobj,hit.x)*light_color2;\n        col= result/2.0;\n        col= (ACESFilm(col)+linear2srgb(col)+col+ exposureToneMapping(3.0, col))/4.0 ;\n        if(3.0*sin(iTime)>0.0)\n        col=vec3((col.x+ col.y+ col.z)/3.0)*(0.5-0.4*cos(5.*iTime));\n    }\n    else if(hit.x>MAX_DIST)\n    //col= render_sky_color(rd);\n    col= vec3(0.5);\n   return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t;\n    float t0=iTime;\n    t=mod(t0*5.0,500.0);\n \tlight_pos1= vec3(0.0, 60.0, 25.); light_color1=vec3( 1.0,1.0,1.0 );\n \tlight_pos2= vec3(0.0, 20.0, -25.0 ); light_color2 =vec3( 1.0,1.0,1.0 ); \n   vec3 ro=vec3(0.0,40.0-t,-25.0+t);  ///bien\n   \n   vec3 rd=normalize( vec3(uv.x,uv.y,1.0));\n   rd= rotate_x(rd,radians(60.0));\n   float Amp=7.0;\n   t=t0;\n   float ang1=Amp*sin(t);\n   float ang2=Amp*cos(t);\n   rd= rotate_y(rd,radians(ang1));\n   rd= rotate_z(rd,radians(ang2));\n   \n   \n    light_pos1+=ro;\n    light_pos2+=ro;\n    vec3 col= Render( ro,  rd);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//-------common\n#define PI 3.14159265\n\n///Gracias a Shane...16-jun-2020\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){    \n  n = max(n*n - .2, .001); // max(abs(n), 0.001), etc.\n  n /= dot(n, vec3(1)); \n  vec3 tx = texture(tex, p.yz).xyz;\n  vec3 ty = texture(tex, p.zx).xyz;\n  vec3 tz = texture(tex, p.xy).xyz;\n  return mat3(tx*tx, ty*ty, tz*tz)*n; \n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tsfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[614, 614, 646, 646, 730], [731, 731, 770, 770, 865], [866, 866, 905, 905, 1000], [1001, 1001, 1040, 1040, 1135], [1137, 1137, 1181, 1181, 1208], [1209, 1209, 1249, 1249, 1276], [1277, 1277, 1322, 1322, 1350], [1352, 1352, 1388, 1388, 1433], [1435, 1435, 1469, 1469, 1565], [1566, 1566, 1600, 1600, 1691], [1692, 1692, 1726, 1726, 1817], [1820, 1861, 1890, 1890, 2109], [2111, 2111, 2136, 2136, 2873], [2875, 2875, 2899, 2899, 3061], [3063, 3063, 3111, 3111, 3390], [3393, 3393, 3437, 3437, 3758], [3760, 3760, 3797, 3797, 4054], [4056, 4056, 4146, 4146, 5106], [5108, 5108, 5157, 5157, 5237], [5239, 5239, 5271, 5271, 5481], [5483, 5531, 5559, 5559, 5747], [5749, 5754, 5787, 5787, 5951], [5953, 5953, 6023, 6023, 6410], [6412, 6412, 6439, 6439, 6528], [6530, 6530, 6588, 6588, 6636], [6638, 6638, 6661, 6661, 6773], [6775, 6775, 6806, 6806, 7548], [7550, 7550, 7607, 7607, 8257]], "test": "untested"}
{"id": "ftlfDf", "name": "paint brush 2", "author": "FabriceNeyret2", "description": "just a test\nline 14, try different iChannel bindings", "tags": ["chalk", "paintbrush", "charcoal"], "likes": 21, "viewed": 667, "published": 3, "date": "1651596593", "time_retrieved": "2024-07-30T16:50:20.467898", "image_code": "// variant of https://shadertoy.com/view/7lByWt\n\n\n//#define T(c) texelFetch(c, ivec2(u) % textureSize(c,0) ,0 ).r\n  #define T(c) texture(c, u/R.y ).r  // or u/360.\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    int i  = int(iTime)%4;                                    // demo selector\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n    U = vec2( fract(atan(U.y,U.x)/6.28), length(U)-.7 );      // ring coords\n   \n    float g = T(iChannel1),                                   // paper grain\n          p = smoothstep(.1,-.1,abs(U.y)-.2),                 // stroke profile\n          f = smoothstep(.1,.8,U.x) * smoothstep(.9,.8,U.x),  // stroke force\n          v =   i==0 ? step( g,  1.2*p*f )                    // pigment threshold\n              : i==1 ? smoothstep(-.25,.25, 1.2*p*f - g)  // ( should clamp but nice paper effect )\n              : i==2 ? 1.2*p*f - g                        // ( idem ) \n              :         2.*p*f - g ;                      // ( idem ) \n           //  step( 1.-p  + 1.-f , g );                                   \n           //  step( 1.-p  + f    , g );                                 \n    O = mix( vec4(1), vec4(.5,0,0,1), v );                    // color scheme\n}\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftlfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[165, 165, 203, 203, 1215]], "test": "untested"}
{"id": "ftsfDf", "name": "Fast, High-Quality Noise", "author": "zesterer", "description": "A slight variation on traditional simplex noise using a very fast hash function.", "tags": ["procedural", "noise", "fast"], "likes": 8, "viewed": 397, "published": 3, "date": "1651593709", "time_retrieved": "2024-07-30T16:50:21.208916", "image_code": "// 0 = linear, 1 = smoothstep, 2 = cosine\n#define LERP 1\n\n// Very fast hash function\nfloat hash(ivec2 p) {\n    ivec2 q = p * ivec2(1317301, 1712759) + p.yx;\n    return float((((q.x ^ q.y) * 3536471) & 0xFFFF)) * 0.00001526;\n}\n\nfloat lerp(float a, float b, float x) {\n    #if (LERP == 1)\n        return a + (b - a) * smoothstep(0.0, 1.0, x);\n    #elif (LERP == 2)\n        return mix(a, b, 0.5 - cos(x * 3.1415) * 0.5);\n    #else\n        return mix(a, b, x);\n    #endif\n}\n\nfloat layer(vec2 p0) {\n    const float f = 0.35;\n    vec2 p = p0 + (p0.x + p0.y) * f;\n    \n    const ivec2 iota = ivec2(0, 1);\n    \n    ivec2 ip = ivec2(p);\n    float v00 = hash(ip + iota.xx);\n    float v11 = hash(ip + iota.yy);\n    \n    vec2 fp = fract(p);\n    if (fp.x > fp.y) {\n        float v10 = hash(ip + iota.yx);\n        return lerp(\n            lerp(v00, v10, (fp.x - fp.y) / (1.0 - fp.y)),\n            v11,\n            fp.y\n        );\n    } else {\n        float v01 = hash(ip + iota.xy);\n        return lerp(\n            v00,\n            lerp(v01, v11, fp.x / fp.y),\n            fp.y\n        );\n    }\n}\n\nfloat noise(vec2 p) {\n    const float layer_scale = 0.5;\n    const float detail = 0.05;\n    \n    float total = 0.0;\n    float cap = 0.0;\n    for (float scale = 1.0; scale > detail; scale *= layer_scale) {\n        total += layer(p / scale) * scale;\n        cap += scale;\n    }\n    return total / cap;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    if (uv.x < 0.25) {\n        fragColor = vec4(vec3(hash(ivec2(floor(fragCoord * 0.2 + iTime * 10.0)))), 1.0);\n    } else if (uv.x < 0.5) {\n        fragColor = vec4(vec3(layer(fragCoord * 0.2 + iTime * 10.0)), 1.0);\n    } else if (uv.x < 0.75) {\n        fragColor = vec4(vec3(noise(fragCoord * 0.02 + iTime * 1.0)), 1.0);\n    } else {\n        fragColor = vec4(vec3(sin(noise(fragCoord * 0.02 + iTime * 1.0) * 30.0) * 0.5 + 0.5), 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 85, 106, 106, 225], [227, 227, 266, 266, 469], [471, 471, 493, 493, 1083], [1085, 1085, 1106, 1106, 1386], [1388, 1388, 1445, 1445, 1931]], "test": "untested"}
{"id": "flsBWf", "name": "Gravity Wells", "author": "zesterer", "description": "A peaceful visualisation I wrote during a bout of depression intended to evoke images of a solar system in motion.", "tags": ["sun", "orbit", "planets", "solar"], "likes": 6, "viewed": 284, "published": 3, "date": "1651588471", "time_retrieved": "2024-07-30T16:50:21.947939", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float d = 0.0;\n    for (int i = 1; i < 100; i ++) {\n        float o = fract(iDate.w / float(i) * 1.0) * 3.14159 * 2.0;\n        vec2 q = iResolution.xy / 2.0 + vec2(sin(o), cos(o)) * float(i) * 5.0;\n        d += 1.0 / length(q - fragCoord);\n    }\n    fragColor = vec4(sin(vec3(10, 23, 15) / d), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flsBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "untested"}
{"id": "ftsfDX", "name": "Meeting Doodle", "author": "TekF", "description": "I find it hard to concentrate in meetings, so I decided to doodle. I think it helps, so long as the doodles don't get too complicated.", "tags": ["doodle"], "likes": 3, "viewed": 251, "published": 3, "date": "1651586610", "time_retrieved": "2024-07-30T16:50:22.685966", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale1 = mix(3.,19.,smoothstep(-.7,.7,sin(iTime/3.)));\n    float scale2 = mix(1.,4.,smoothstep(-.7,.7,sin(iTime/(3.*1.68))));\n    float imix = .7;\n\n\n    vec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n    \n    float a = iTime*.2;\n    uv = uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n    \n    vec2 uv2 = abs(fract(uv*scale1)-.5)*2.;\n\n    uv = uv*cos(-2.*a) + uv.yx*vec2(1,-1)*sin(-2.*a);\n\n    uv = mix( uv2, abs(fract(uv*scale2)-.5)*2., imix);\n\n    uv = uv*cos(a) + uv.yx*vec2(1,-1)*sin(a);\n\n    uv *= vec2(.07,.5);\n    uv -= iTime*vec2(.1,.13);\n\n    // Time varying pixel color\n//    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    vec3 col = texture(iChannel0,uv+iTime*vec2(.1,.13)).rgb;\n    \n    //col = 1.-col;\n    col = col.rbg;\n    col = clamp(col*8.-7.*dot(col,vec3(.2,.75,.05)),.0,1.); // saturation boost\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftsfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 948]], "test": "untested"}
{"id": "slfBD2", "name": "fork : julia feathers", "author": "sympou", "description": "a fork from ronwnor's great shader !!\ni changed the mandelbrot set to an interactive julia set,\nand added a light scattering effect to the feathers.", "tags": ["fractal"], "likes": 12, "viewed": 320, "published": 3, "date": "1651583940", "time_retrieved": "2024-07-30T16:50:23.421000", "image_code": "//original : https://www.shadertoy.com/view/7tffDj by ronwnor\n\nconst float tau = 6.28; \n\nmat2 rot(float a) {\n    return mat2(\n        cos(a), sin(a),\n        -sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    float zoom = 1.;\n    \n    vec2 u1 = (2.*fragCoord - iResolution.xy)/iResolution.y * zoom;\n\n\tvec2 mouse = iMouse.xy/iResolution.xy*2.-1.;\n    \n    if (mouse == vec2(-1)) mouse = vec2(-0.26,0.85); \n\n    float val = 0.; \n\n    //loop (originally i < 64)\n    for(float i = 0.; i < 15. && val == 0.; i++){\n            \n        u1 = mouse + vec2(u1.x*u1.x - u1.y*u1.y,2.*u1.x*u1.y);       \n        vec2 u2 = u1*rot(3.1415692*(iTime*0.1+i));\n        \n        if (u2.y >= 8.) {\n            val = 0.01 + i/64. + 1./u2.y;\n        }\n    }\n    \n    vec3 col = 0.5 + 0.5*cos(tau*(val+.4+vec3(.0,.1,.2)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[89, 89, 108, 108, 177], [179, 179, 236, 236, 890]], "test": "untested"}
{"id": "slXfWX", "name": "World of Spheres", "author": "Spi3lot", "description": "Rotate around using your mouse/touchpad/touchscreen/fingers/..", "tags": ["reflection", "refraction", "sphere", "infinite"], "likes": 7, "viewed": 286, "published": 3, "date": "1651574462", "time_retrieved": "2024-07-30T16:50:24.158030", "image_code": "#define AA 2\n\n// RAY MARCHING //\n#define EPSILON 0.001\n#define MAX_STEPS 1000\n#define MAX_DISTANCE 1000.0\n//              //\n\n//////////////////////////\n#define MAX_REFLECTIONS 10\n#define LIGHT vec3(10.0, 10.0, 10.0) * vec3(cos(iTime), 1, sin(iTime))\n\n#define ZOOM 1.0\n//////////////////////////\n\n\nconst float PI = 3.141592;\nconst float TAU = PI + PI;\n\n\nfloat sdGrid(vec3 p)\n{\n    float plane = p.y;\n    plane += 0.025 * smoothstep(0.05, 0.0, abs(p.x - round(p.x)));\n    plane += 0.025 * smoothstep(0.05, 0.0, abs(p.z - round(p.z)));\n\n    return plane;\n}\n\nfloat sdSpheres(vec3 p)\n{\n    float off = TAU * Hash21(round(p.xz));\n    p.xz = mod(p.xz, 2.0) - 1.0;\n    p.y -= 0.2 * sin(iTime + off) + 1.0;\n    \n    return length(p) - 0.4;\n}\n\nfloat GetDist(vec3 p)\n{\n    float grid = sdGrid(p);\n    float spheres = sdSpheres(p);\n\n    return min(grid, spheres);\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(EPSILON, 0);\n    \n    return normalize(d - vec3(GetDist(p - e.xyy),\n                              GetDist(p - e.yxy),\n                              GetDist(p - e.yyx)));\n}\n\nfloat GetLight(vec3 p, vec3 n)\n{\n    vec3 l = normalize(LIGHT - p);\n    float diff = max(0.0, dot(n, l));\n\n    return diff;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd, float side)\n{\n    float dO = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS = side * GetDist(p);\n        if (abs(dS) <= EPSILON || dO > MAX_DISTANCE) break;\n        dO += dS;\n    }\n    \n    return dO;\n}\n\nvec3 offset(vec3 n)\n{\n    return EPSILON * 2.0 * n;\n}\n\n\nvoid image( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    vec2 mouse;\n\n    if (iMouse.x == 0.0 && iMouse.y == 0.0)\n        mouse = vec2(0,0);\n    else\n        mouse = iMouse.xy / iResolution.xy - 0.5;\n\n    float yaw = mouse.x * TAU;\n    float pitch = mouse.y * PI;\n    vec4 cs = vec4(cos(yaw), sin(yaw), cos(pitch), sin(pitch));\n\n    vec3 ro = vec3(0, 1, 0),\n         p = cs.xwy * vec3(cs.z, 1, cs.z),\n         f = normalize(p),  // p = lookAt - ro (because lookAt = ro + p)\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         rd = normalize(uv.x * r + uv.y * u + f * ZOOM);\n         //c = ro + f * ZOOM,\n         //i = c + uv.x * r + uv.y * u,\n         //rd = normalize(i - ro);\n\n    vec3 col = vec3(0);\n    vec3 n = vec3(0);  // vec3(0) so that the first offset is vec3(0) as well\n    vec3 reflOri = ro;\n    vec3 reflDir = rd;\n    \n    for (float r = 0.; r <= float(MAX_REFLECTIONS); r++)\n    {\n        vec3 off = offset(n);\n        reflOri += off;\n\n        float d = RayMarch(reflOri, reflDir, 1.0);\n        reflOri += reflDir * d;\n        vec3 spec = vec3(0);\n\n        if (sdGrid(reflOri) <= EPSILON)\n            spec += mod(floor(reflOri.x) + floor(reflOri.z), 2.0);\n        else if (sdSpheres(reflOri) <= EPSILON)\n            spec += Hash23(round(reflOri.xz));\n        else\n            break;\n\n        n = GetNormal(reflOri);\n        float diff = GetLight(reflOri, n);\n        spec += smoothstep(0.975, 1.0, diff);\n\n        col += diff * spec * pow(0.4, r);\n        //col += diff * spec / float(r + 1);\n\n        // For the next iteration\n        reflDir = reflect(reflDir, n);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n\n    for (int j = 0; j < AA; j++)\n        for (int i = 0; i < AA; i++)\n        {\n            vec4 color;\n            vec2 co = fragCoord - 0.5;\n            vec2 off = (vec2(i, j) + 0.5) / float(AA);\n            image(color, co + off);\n            fragColor += color;\n        }\n\n    fragColor /= float(AA * AA);\n}\n", "image_inputs": [], "common_code": "float Hash21(vec2 p) {\n    return fract(43697.62 * sin(dot(p, vec2(52.83, 823.17))));\n}\n\nvec3 Hash23(vec2 p)\n{\n    float r = Hash21(p);\n    float g = Hash21(vec2(p.y * 59.84, r * 81.53));\n    float b = Hash21(vec2(g * 124.21, p.x * 62.27));\n    \n    return vec3(r,g,b);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slXfWX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 376, 376, 554], [556, 556, 581, 581, 733], [735, 735, 758, 758, 854], [857, 857, 881, 881, 1097], [1099, 1099, 1131, 1131, 1224], [1227, 1227, 1273, 1273, 1519], [1521, 1521, 1542, 1542, 1574], [1577, 1577, 1630, 1630, 3316], [3318, 3318, 3375, 3375, 3713]], "test": "untested"}
{"id": "stXBWf", "name": "30 Minutes 4/29", "author": "scry", "description": "30 Minute timelapse:\nhttps://www.youtube.com/shorts/y8vtM-_zm00", "tags": ["3d", "kifs", "trippy", "symmetric"], "likes": 4, "viewed": 259, "published": 3, "date": "1651562946", "time_retrieved": "2024-07-30T16:50:24.898051", "image_code": "/////////////////////////////////////////////////////\n#define time iTime*0.1\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nvec4 map(vec3 p) {\n    p.z -= 2.4;\n    p.yz *= r2d(iMouse.y/iResolution.y+0.);\n    p.xz *= r2d(iMouse.x/iResolution.x+0.);\n    p.yz *= r2d(sin(time/2.)*0.5);\n    p.xz *= r2d(time*0.5);\n    p = abs(p)-0.6;\n    p.yz *= r2d(time);\n    p.xz *= r2d(time);\n    p = abs(p)-0.01;\n    float di = 0.1;\n    float d2 = 0.01;\n    for(int i=0;i<3;i++) {\n        p = abs(p)-di;\n        p.yz *= r2d(time);\n        p.xz *= r2d(time);\n        p = abs(p)-d2;\n    }\n    //p.yz *= r2d(-time);\n    //p.xz *= r2d(-time);\n    float d = sdBox(vec3(p),vec3(0.1));\n    //p.xy *= r2d(90.*deg);\n    p.yz *= r2d(45.*deg);\n    \n    p.yz = abs(p.yz);\n    p.yz *= r2d(-45.*deg);\n    p.xz *= r2d(-45.*deg);\n    //p.yz *= r2d(45.*deg);\n    p.xz = abs(p.xz);\n    p.xz *= r2d(-45.*deg);\n    //p.yz *= r2d(45.*deg);\n    return vec4(p.xy,p.z,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<16;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dO > 100. || dS < 0.001) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    vec2 tv = uv;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 mp = map(p).xyz;\n    uv = mix(uv,mp.xy,1.);\n    float fs = 4.;\n    vec2 ov = uv;\n    uv *= r2d(deg*360./6.);\n    //uv.y -= uv.x/2.;\n    //uv.x -= uv.y;\n    //uv.y *= 1.155;\n    uv.y *= 1.155;\n    uv.x -= uv.y/2.;\n    vec2 t1v = uv;\n    vec3 trv = vec3(floor(uv.xy),floor(ov.y*fs*1.155));\n    uv.y += time*trv.x;\n    uv.x += time*trv.y;\n    uv.x = (fract(uv.x*fs)-0.5);\n    uv.y = (fract(uv.y*fs)-0.5);\n    col.rg = uv.xy;\n    col.b += (fract((t1v.x+t1v.y)*fs));\n    col.g += sin(trv.z*20.+time*2.);\n    col += sin(col*20.+d.x*0.1)*0.4;\n    col += sin(col*20.+p.x*210.+d.x)*0.4;\n    col = clamp(col,0.,1.);\n    col *= 1.-d.x*0.2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 120, 139, 139, 188], [190, 190, 219, 219, 282], [284, 284, 302, 302, 1092], [1094, 1094, 1121, 1121, 1382], [1384, 1384, 1439, 1439, 2392]], "test": "untested"}
{"id": "ftffDf", "name": "", "author": "shimakz", "description": "based on Diana from a-soul", "tags": ["3d"], "likes": 2, "viewed": 117, "published": 3, "date": "1651548638", "time_retrieved": "2024-07-30T16:50:25.810611", "image_code": "#define TMIN 0.1\n#define TMAX 100.\n#define RAYMARCH_TIME 128\n#define PRESICION .001\n#define PI 3.14159265\nvec2 fixUV(in vec2 c){\n    return .7*((2.*c-iResolution.xy)/min(iResolution.y,iResolution.y)+vec2(0.,.6));\n}\nfloat sdfSphere(in vec3 p,in float r){\n    return length(p)-r;\n}\n\nfloat sin_noise( in vec2 x ) { return sin(x.x+sin(x.y)); }\nfloat fbm( vec2 p ){\n    const mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n    float f = 0.0;\n    f += 0.5000*sin_noise( p ); p = m2*p*2.02;\n    f += 0.2500*sin_noise( p ); p = m2*p*2.03;\n    f += 0.1250*sin_noise( p ); p = m2*p*2.01;\n    f += 0.0625*sin_noise( p );\n    return f;\n}\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat sdParabola( in vec2 pos, in float wi, in float he ){\n    pos.x = abs(pos.x);\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n    float x = (h>0.0) ? \n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        2.0*cos(atan(r/q)/3.0)*sqrt(p);\n    x = min(x,wi);\n    return length(pos-vec2(x,he-x*x/ik)) * \n           sign(ik*(pos.y-he)+pos.x*pos.x);\n}\nfloat sdArc( in vec2 p, in vec2 scb, in float ra ){\n    p.x = abs(p.x);\n    float k = (scb.y*p.x>scb.x*p.y) ? dot(p.xy,scb) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k );\n}\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdfrec(in vec3 p,vec3 b){\n    vec3 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.z,max(d.x,d.y)),0.);\n}\nfloat udTriangle( vec3 p, vec3 a, vec3 b, vec3 c )\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\nvec2 opU(vec2 a,vec2 b){\n    return a.x<b.x?a:b;\n}\nfloat sdCutHollowSphere( vec3 p, float r, float h, float t ){\n  // sampling independent computations (only depend on shape)\n  float w = sqrt(r*r-h*h);\n  \n  // sampling dependant computations\n  vec2 q = vec2( length(p.xz), p.y );\n  return ((h*q.x<w*q.y) ? length(q-vec2(w,h)) : \n                          abs(length(q)-r) ) - t;\n}\nfloat sdbEllipsoidV2( in vec3 p, in vec3 r ){\n    float k1 = length(p/r);\n    float k2 = length(p/(r*r));\n    return k1*(k1-1.0)/k2;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat smin( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\nfloat smax( float a, float b, float k ){\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return max( a, b ) + h*h*h*k*(1.0/6.0);\n}\nvec2 opUS(vec2 a,vec2 b){\n    return vec2(smin(a.x,b.x,0.09),a.x<b.x?a.y:b.y);\n}\nvec2 opUS2(vec2 a,vec2 b){\n    return vec2(smin(a.x,b.x,0.16),a.x<b.x?a.y:b.y);\n}\n\nvec2 opMS(in vec2 a,in vec2 b){\n    return vec2(smax(a.x,b.x,0.1),a.x>b.x?a.y:b.y);\n}\nvec2 opM(in vec2 a,in vec2 b){\n    return a.x>b.x?a:b;\n}\nvec2 opMS2(in vec2 a,in vec2 b){\n    return vec2(smax(a.x,b.x,0.03),a.x>b.x?a.y:b.y);\n}\nvec2 opMS3(in vec2 a,in vec2 b){\n    return vec2(smax(a.x,b.x,0.15),a.x>b.x?a.y:b.y);\n}\nmat3 rotate_yz(float theta){\n    return mat3(vec3(1.,0.,0.),vec3(0.,cos(theta),sin(theta)),vec3(0.,-sin(theta),cos(theta)));\n}\nmat3 rotate_xz(float theta){\n    return mat3(vec3(cos(theta),0.,-sin(theta)),vec3(0.,1.,0.),vec3(sin(theta),0.,cos(theta)));\n}\nmat3 rotate_xy(float theta){\n    return mat3(vec3(cos(theta),sin(theta),0.),vec3(-sin(theta),cos(theta),0.),vec3(0.,0.,1.));\n}\nmat2 rot2(float theta){\n    float s=sin(theta),c=cos(theta);\n\n    return mat2(c,-s,s,c);\n}\n\nvec2 sdSegment(vec3 p, vec3 a, vec3 b){\n    vec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn vec2( length( pa - ba*h ), h );\n}\nfloat sdTriPrism( vec3 p, vec2 h ,float theta){\n  vec3 q = abs(p);\n  float d=max(q.z-h.y,max(q.x*cos(theta)+p.y*sin(theta),-p.y)-h.x*sin(PI/4.));\n  return d;\n}\n// float sdTriPlane(vec3,vec2 h){\n//     vec3 q = abs(p);\n//     return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n// }\nfloat sdCone( vec3 p, vec2 c, float h ,float rad){\n    vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s)-rad;\n}\nvec3 xabs(vec3 p){\n    return vec3(sqrt(p.x*p.x+3.0e-3),p.y,p.z);\n}\n// float Bend_Tri(vec3 p,vec2 h){\n//     const float k = -1.2; // or some other amount\n//     float c = cos(k*p.x);\n//     float s = sin(k*p.x);\n//     mat2  m = mat2(c,-s,s,c);\n//     vec3  q = vec3(m*p.xy,p.z);\n//     return sdTriPrism(q,h);\n// }\nfloat Bend_cone(vec3 p,vec2 co,float h,float k,float rad){\n     // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(p.x,m*p.yz);\n    return sdCone(q,co,h,rad);\n}\nfloat Bend_Elli(vec3 p,vec3 r,float k1,float k2){\n    float c = cos(k1*p.x);\n    float s = sin(k1*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 pp=m*p.xy;\n    c = cos(k2*p.x);\n    s = sin(k2*p.x);\n    vec2 pz=m*p.xz;\n    vec3  q = vec3(pp.x,pp.y,pz.y);\n    return sdbEllipsoidV2(q,r);\n}\nfloat Bend_Elli2(vec3 p,vec3 r,float k1,float k2){\n    p.y*=-1.;\n    float c = cos(k1*p.x);\n    float s = sin(k2*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 pp=m*p.xy;\n    c = cos(k2*p.x);\n    s = sin(k2*p.x);\n    m = -mat2(c,-s,s,c);\n    vec2 pz=m*p.xz;\n    vec3  q = vec3(pp.x,pp.y,pz.y);\n    return sdbEllipsoidV2(q,r);\n}\n\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ){\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\nfloat Bend_Triangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 ,in float k){\n    \n    float c = cos(k*(p.y-3.67));\n    float s = sin(k*(p.y-3.67));\n    mat2  m = mat2(c,-s,s,c);\n    vec2 q=m*p;\n    return sdTriangle(q,p0,p1,p2);\n}\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus(vec3 p, float la, float lb, float h){\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y), p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\nfloat sdcloth(in vec3 p){\n    const float k = .6; // or some other amount\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 pp=m*p.yz;\n    vec3  q = vec3(p.x,pp);\n    return sdTriPrism(q,vec2(.45,.06),.1*PI);\n}\nfloat sdfrontcloth(in vec3 p){\n    float k=-.2;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 pp=m*p.yz;\n    vec3  q = vec3(p.x,pp);\n    return sdTriPrism(q,vec2(.5,.04),.15*PI);\n}\nfloat sdshoulder(in vec3 p){\n    vec3 sos = vec3( abs(p.x), p.yz );    \n    vec2 se = sdSegment(sos, vec3(0.18,-1.6,-0.3), vec3(.83,-1.85,0.0) );\n    float d = se.x-mix(0.25,0.43,se.y);\n    // d = smin(d,sdfSphere(sos-vec3(0.3,-2.2,0.4), 0.5 ),0.2);\n    return d;\n}\nfloat ahoge(in vec3 p){\n    float k=-2.5;\n    float c = cos(k*p.z);\n    float s = sin(k*p.z);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 pp=m*p.zy;\n    vec3  q = vec3(p.x,pp.yx);\n    return sdRhombus(q,.08,.4,.0005);\n}\nvec2 shapehead(in vec3 p){\n    vec2 d=vec2(Bend_cone(rotate_yz(-PI/80.)*(vec3(p.x,-p.y,p.z)-vec3(0.,-.93,.67)),vec2(sin(PI/3.5),cos(PI/3.5)),.41,-1.95,.03),2.);// \n    // vec2(Bend_Tri(rotate_yz(PI/19.)*(p.xzy-vec3(0.,.58,.1)),vec2(.31,1.31)),2.);\n    // d=opMS(d,vec2(sdbEllipsoidV2(rotate_yz(PI/2.9)*(p-vec3(0.,1.6,0.1)),1.5*vec3(0.0196, 0.0196, 0.0196)),2.));\n    // d=opUS(d,vec2(sdbEllipsoidV2(rotate_yz(-PI/11.)*(p-vec3(0.,1.61,.52)),1.*vec3(0.6,0.1,0.5)),.2));\n    d=opUS(d,vec2(sdfSphere(p-vec3(0.,1.87,-0.1),1.),2.));//\n    // opU(d,vec2(sdfrec(p-vec3(1.,1.,0.),vec3(1.,1.,1.)),3.))\n    float ani_time=min(1.,mod(iTime,6.1));\n    ani_time=smoothstep(0.,0.1,ani_time)-smoothstep(0.18,0.4,ani_time);\n    float tt = mod(1.0+iTime,3.0);\n    ani_time = max(ani_time,smoothstep(0.0,0.07,tt)-smoothstep(0.1,0.35,tt));\n    ani_time=1.-ani_time;\n    // ani_time=0.;\n    d=opUS2(d,vec2(sdbEllipsoidV2(rotate_yz(PI/4.1)*(p-vec3(0.,1.63,0.17)),1.49*vec3(0.49,0.58,0.40)),2.));//\n    d=opMS3(d,vec2(-1.*sdbEllipsoidV2(xabs(p)-vec3(.59,1.81,1.02),rotate_xz(PI/6.)*.63*vec3(0.58,0.45+.01*(1.-ani_time),0.9)),2.));\n    d=opMS3(d,vec2(-1.*sdbEllipsoidV2(xabs(p)-vec3(.41,1.76,0.8),.35*vec3(0.5,0.53,0.50)),2.));//\n\n    d=opUS2(d,vec2(Bend_cone(rotate_yz(PI/30.)*(vec3(1.2*p.x,p.y,0.98*p.z)-vec3(0.,1.84,.75)),vec2(sin(PI/10.),cos(PI/10.)),.32,.95,.0),2.));//nose\n    d=opUS2(d,vec2(Bend_cone(rotate_yz(PI/9.)*(vec3(p.x,-p.y,p.z)-vec3(0.,-1.47,.86)),vec2(sin(PI/9.),cos(PI/9.)),.09,-.07,.02),2.));\n    d=opUS(d,vec2(Bend_Elli(rotate_xy(PI/20.)*rotate_xz(-PI/9.)*(xabs(p)-vec3(.36,1.98-.05*(1.-ani_time),.78)),.18*vec3(0.9,0.4,0.1),-1.3,-1.3),2.));//\n    d=opUS2(d,vec2(Bend_Elli2(rotate_xy(-PI/9.)*rotate_xz(-PI/9.)*(xabs(p)-vec3(.35,1.57+.05*(1.-ani_time),.76)),.18*vec3(0.9,0.3,0.1),-1.4,-1.4),2.));//\n    d=opUS2(d,vec2(sdCutHollowSphere(rotate_yz((1.5-.45*(1.-ani_time))*PI)*(xabs(p)-vec3(.28,1.78,.58)),.25,.1,.0001),2.));//1.5,1.05\n    d=opUS2(d,vec2(sdCutHollowSphere(rotate_yz((-.3+.15*(1.-ani_time))*PI)*(xabs(p)-vec3(.28,1.78,.58)),.25,.05,.0001),2.));//-.3 -.15\n    d=opMS2(d,vec2(-1.*sdbEllipsoidV2(xabs(p)-vec3(.0,1.32,.88),.8*vec3(0.13,0.08,0.1)),2.));//\n    // d=opUS2(d,vec2(sdbEllipsoidV2(rotate_yz(-.1*PI)*rotate_xz(-.2*PI)*rotate_xy(.05*PI)*(xabs(p)-vec3(.85,1.58,.4)),.3*vec3(.45*(1.+1.2*(p.y-1.)),.9,.1)),2.));\n    return d;\n}\nvec2 map(in vec3 p){\n    vec2 d=vec2(sdfSphere(xabs(p)-vec3(.28,3.78,.58),.25),3.);\n    vec3 q=p;\n    d=opUS(d,vec2(sdCapsule(q,vec3(0.,2.,-0.2),vec3(0.,3.5,-0.2),.35),4.));\n    d=opUS(d,vec2(sdCapsule(xabs(q),vec3(0.2,1.9,-0.2),vec3(0.55,1.88,-0.),.35),4.));\n    d=opU(d,shapehead(p-vec3(0.,2.,0.)));\n    d=opU(d,vec2(sdcloth(rotate_xy(.17*PI)*rotate_xz(-.05*PI)*rotate_yz(-PI/1.9)*(vec3(-abs(q.x),q.yz)-vec3(-.59,2.3,-.1))),5.));\n    d=opUS(d,vec2(sdshoulder(q-vec3(0.,3.7,0.1)),6.));\n    d=opUS(d,vec2(sdfrontcloth(rotate_yz(-.15*PI)*(vec3(q.x,-q.y,q.z)-vec3(-.0,-1.8,.53))),5.));\n    d=opU(d,vec2(ahoge(rotate_xy(-PI/3.3)*rotate_xz(-PI/20.)*rotate_yz(-PI/2.)*(p-vec3(-.18,5.,.3))),7.));\n    // d=opU(d,vec2(sdHoodie(.95*rotate_xz(-PI/15.)*(p-vec3(0.,4.1,0.))),5.));\n    return d;\n}\nvec2 tri( in vec2 x ){\n    vec2 h = fract(x*.5)-.5;\n    return 1.-2.*abs(h);\n}\nfloat checkersGrad( in vec2 uv, in vec2 ddx, in vec2 ddy ){\n    vec2 w = max(abs(ddx), abs(ddy)) + 0.01;    // filter kernel\n    vec2 i = (tri(uv+0.5*w)-tri(uv-0.5*w))/w;   // analytical integral (box filter)\n    return 0.5 - 0.5*i.x*i.y;                   // xor pattern\n}\n\nvec3 calcNormal( in vec3 p ){\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x+ \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\nvec2 Ray_march(in vec3 ro,in vec3 rd){\n    float t=0.1;\n    vec2 res=vec2(-1.);\n    float tmax=40.;\n    if(rd.y<0.){\n        float tp=-ro.y/rd.y;\n        tmax=min(tmax,-ro.y/rd.y);\n        res=vec2(tp,1.);\n    }\n    for(int i=0;i<RAYMARCH_TIME&&t<tmax;i++){\n        vec3 p=ro+t*rd;\n        vec2 d=map(p);\n        if(d.x<PRESICION){\n            res=vec2(t,d.y);\n            break;\n        }\n        t+=d.x;\n    }\n    return res;\n}\nmat3 setCamera(vec3 ta,vec3 ro,float cr){\n    vec3 z=normalize(ta-ro);\n    vec3 cp=vec3(sin(cr),cos(cr),0.);\n    vec3 x=normalize(cross(z,cp));\n    vec3 y=cross(x,z);\n    return mat3(x,y,z);\n}\nfloat soft_shadow(in vec3 ro, vec3 rd,float k){\n    float res = 1.0;\n    float ph = 1e20;\n    float tmin=.1,tmax=10.;\n    for( float t=tmin; t<tmax; ){\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return clamp(res,0.0,1.0);\n}\nvec3 render(vec2 uv,vec2 px,vec2 py){\n    vec3 ro=vec3(3.*cos(PI/2.1),4.3,3.*sin(PI/2.1));\n    \n    vec3 ta=vec3(0.,3.,0.);\n    mat3 cam=setCamera(ta,ro,0.);\n    float fl=1.;\n    vec3 rd=normalize(cam*vec3(uv,fl)); \n    vec2 t=Ray_march(ro,rd);\n    vec3 bg=vec3(0.4,0.7,1.0)*0.7;\n    \n    vec3 rd2=normalize(cam*vec3(px,fl));\n    vec3 rd3=normalize(cam*vec3(px,fl));\n    vec2 t2=Ray_march(ro,rd2);\n    vec2 t3=Ray_march(ro,rd3);\n    float gra = smoothstep(-0.3,.6,rd.y);                    \n    vec3  sky = vec3(0.4,0.7,1.0);\n    float h = (1000.0-ro.y)/rd.y;\n    if( h>0.0 )\n    {\n        vec2 uv = ro.xz + rd.xz*h;\n        float cl = smoothstep( 0.0, 0.8, fbm( 0.002*uv ) );\n        cl = clamp( floor(cl*3.0)/(3.0-1.0), 0.0, 1.0 );\n        sky = mix( sky, vec3(0.9,0.6,0.3), 0.4*cl*gra );\n    }\n    vec3 col = vec3(.1)+mix( vec3(0.6,0.9,1.0), sky, gra );\n    if(t.y>0.){\n        vec3 p=ro+t.x*rd;\n        vec3 nor = calcNormal(p);\n\t\tvec3 ref = reflect( rd, nor );\n        vec3 n=(t.y<1.1)?vec3(0.,1.,0.):calcNormal(p);\n        vec3 light=normalize(vec3(0.8,0.6,0.3));\n        float dif=clamp(dot(normalize(light),n),0.,1.);\n        p+=PRESICION*n;\n        float st=soft_shadow(p,normalize(light),10.);\n        dif*=st;\n        float amb=0.5+0.5*dot(n,vec3(0.,1.,0.));\n        // vec3 c=vec3(242.,96.,31)/256.;\n        vec3 c=vec3(0.);\n        if(t.y>1.9&&t.y<2.1){\n            c=vec3(239,177.,151.)/256.;\n            c/=1.8;\n            if(p.z>-0.00001){\n                \n                p.y+=.02;\n                float ani_time=min(1.,mod(iTime,6.1));\n                ani_time=smoothstep(0.,0.1,ani_time)-smoothstep(0.18,0.4,ani_time);\n                float tt = mod(1.0+iTime,3.0);\n                ani_time = max(ani_time,smoothstep(0.0,0.07,tt)-smoothstep(0.1,0.35,tt));\n                // ani_time=1.;\n                vec3 cb=vec3(98.,82.,72.)/256./2.9;\n                vec3 ca=vec3(52.,16.,15.)/256./2.5;\n                vec3 q=vec3(p.x,p.y+.1*ani_time,p.z);\n                float lam1=smoothstep(0.009,0.0055,abs(sdParabola(mat2\n                (vec2(cos(PI/18.),sin(PI/18.)),\n                vec2(-sin(PI/18.),cos(PI/18.)))\n                *(vec2(abs(p.x),p.y)-vec2(.38,4.15)),.24,-.02)));\n                c=(1.-lam1)*c+lam1*cb;//\n                float theta1=(1.-1.2*ani_time)*PI/15.;\n                float lam2=smoothstep(0.033,0.025,abs(sdParabola(mat2\n                (vec2(cos(theta1),sin(theta1)),\n                vec2(-sin(theta1),cos(theta1)))\n                *(vec2(abs(q.x),q.y)-vec2(.39,3.84)),.20,.1-.13*ani_time)));\n                c=(1.-lam2)*c+lam2*ca;//\n                \n                float lam3=smoothstep(0.021,0.015,Bend_Triangle(vec2(abs(q.x),q.y),\n                vec2(.61,3.8),rot2(ani_time*.2*PI)*(vec2(.41,3.7)-vec2(.61,3.8))+vec2(.61,3.8),vec2(.52,3.88),-0.0));\n                c=(1.-lam3)*c+lam3*ca;//\n                \n                float lam4=smoothstep(0.01,0.001,Bend_Triangle(vec2(abs(q.x)-.01,q.y),\n                vec2(.61,3.9),vec2(.52,3.89),rot2(-.2*ani_time*PI)*(vec2(.40,3.94)-vec2(.52,3.89))+vec2(.52,3.89),-0.0));\n                c=(1.-lam4)*c+lam4*ca;//\n                \n                float lam5=smoothstep(0.01,0.001,Bend_Triangle(vec2(abs(q.x)+.06,q.y-.04+.06*ani_time),\n                vec2(.61,3.92),vec2(.52,3.89),rot2(-.2*ani_time*PI)*(vec2(.40,3.91)-vec2(.52,3.89))+vec2(.52,3.89),-0.0));\n                c=(1.-lam5)*c+lam5*ca;//\n                float lam6=smoothstep(0.3,0.,min(length(p.xy-vec2(.4,3.5)),length(p.xy-vec2(-.6,3.5))));\n                c=(1.-lam6)*c+lam6*vec3(251,177,151)/256./2.;//\n                if(abs(p.x+.13)<0.005&&abs(p.y-3.61)<.005)c=vec3(0.);\n            }\n            \n        }else if(t.y>0.9&&t.y<1.1){\n            vec2 grid=floor(p.xz);\n            vec3 rdx=normalize(cam*vec3(px,fl));\n            vec3 rdy=normalize(cam*vec3(py,fl));\n            vec3 ddx=ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 ddy=ro.y*(rd/rd.y-rdy/rdy.y);\n            c=vec3(.3,.2,.2)+col*checkersGrad(p.xz,ddx.xz,ddy.xz);\n        }else if(t.y>2.9&&t.y<3.1){\n            \n            p.x+=sign(p.x)*.01;\n                p.y+=.02;\n            vec2 cen=vec2(.29,3.83);\n            float prx=p.x-.02;\n            float lam1=smoothstep(0.145,0.135,length(vec2(abs(prx),p.y)-cen));\n            float lam2=smoothstep(0.135,0.129,length(vec2(abs(prx),p.y)-cen));\n            float lam3=smoothstep(0.105,0.100,length(vec2(abs(prx),p.y)-cen));\n            float lam4=smoothstep(0.098,0.075,length(vec2(abs(prx),p.y)-cen));\n            float lam5=smoothstep(0.050,0.045,length(vec2(abs(prx),p.y)-cen));\n            float lam7=smoothstep(0.140,0.190,length(vec2(abs(prx),p.y)-cen));\n            //\n            float lam6=smoothstep(0.060,0.045,length(vec2(abs(p.x*0.7),p.y)-vec2(.30*0.75,3.698)));\n            //\n            c=(1.-lam1)*vec3(1.,1.,1.)+lam1*vec3(0.1,0.1,.1)/1.5;\n            c=(1.-lam2)*c+lam2*vec3(0.488,0.758,1.)/1.5;\n            c=(1.-lam3)*c+lam3*vec3(33,83,130)/256./1.5;\n            c=(1.-lam4)*c+lam4*vec3(0.488,0.758,1.)/1.5;\n            c=(1.-lam5)*c+lam5*vec3(33,83,130)/300./1.5;;\n            float lamhr=smoothstep(0.035,0.015,length(vec2(p.x,p.y)-vec2(.24,3.89)));\n            float lamhl=smoothstep(0.035,0.015,length(vec2(p.x,p.y)-vec2(-.395,3.89)));\n            //\n            c=c+lamhr*vec3(1.,1.,1.);\n            c=c+lamhl*vec3(1.,1.,1.);\n            c=c+lam6*vec3(1.,1.,1.);\n            c=(1.-lam7*vec3(206.,214.,221.)/256.)*c;\n        }else if(t.y>3.9&&t.y<4.1){\n            c=vec3(239,177.,151.)/256.;\n            c/=1.8;\n        }else if(t.y>4.9&&t.y<5.1){\n            c=vec3(255.,241.,255.)/256.;\n            c/=1.5;\n        }else if(t.y>5.9&&t.y<6.1){\n            c=vec3(228.,143.,147.)/256.;\n            c/=1.5;\n        }else if (t.y>6.9&&t.y<7.1){\n            c=vec3(122.,90.,78.)/256.;\n            c/=1.5;\n        }\n\t\tfloat fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 8.0 );\n        vec3 brdf = vec3(0.0);\n        brdf += 1.5*st;\n\t\tbrdf += 0.75;\n        brdf += 0.7*smoothstep(0.1,0.15,fre*st);\n        col=c*brdf;\n        // col=amb*c+dif*vec3(.7,.5,.44)+.1*(1.-abs(dot(n,rd)))*(1.-abs(dot(n,rd)))*vec3(239,233,198)/256.;\n        \n        if(t.y>1.1)col *= clamp( 1.0 - 10.*max(abs(t.x-t2.x),abs(t.x-t3.x)), 0.0,.95 );\n    }\n    col = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n    return col;\n}\nfloat sdgEllipse( vec2 p, in vec2 ab ){\n    vec2 sp = sign(p); p = abs( p );\n    \n    bool s = dot(p/ab,p/ab)>1.0;\n    float w = atan(p.y*ab.x, p.x*ab.y);\n    if(!s) w=(ab.x*(p.x-ab.x)<ab.y*(p.y-ab.y))? 1.570796327 : 0.0;\n    \n    for( int i=0; i<4; i++ )\n    {\n        vec2 cs = vec2(cos(w),sin(w));\n        vec2 u = ab*vec2( cs.x,cs.y);\n        vec2 v = ab*vec2(-cs.y,cs.x);\n        w = w + dot(p-u,v)/(dot(p-u,u)+dot(v,v));\n    }\n    vec2  q = ab*vec2(cos(w),sin(w));\n\n    float d = length(p-q);\n    return d*(s?1.0:-1.0);\n}\n#define M 4\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n    vec3 col=vec3(0.);\n    vec2 px=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    float len=iResolution.x/iResolution.y;\n    float v=.7,w=5.1;\n    if(iMouse.z>0.01){\n        float mx=length(vec2(len,1.));\n        vec2 uvMouse=(2.*iMouse.xy-iResolution.xy)/iResolution.xy;\n        v=mix(.5,2.,abs(uvMouse.y));\n        w=mix(5.1,7.1,abs(uvMouse.x)/len);\n    }\n    float ani_time=min(1.,mod(v*iTime,w));\n    ani_time=smoothstep(0.,0.1,ani_time)-smoothstep(0.18,0.4,ani_time);\n    float tt = mod(1.0+iTime,3.0);\n    ani_time = max(ani_time,smoothstep(0.0,0.07,tt)-smoothstep(0.1,0.35,tt));\n    for(int m=0;m<M;m++){\n        for(int n=0;n<M;n++){\n            vec2 offset=2.*(vec2(float(m),float(n))/float(M)-0.5);\n            vec2 uv=fixUV(fragCoord+offset);\n            vec2 px=fixUV(fragCoord+vec2(1.,0.)+offset);\n            vec2 py=fixUV(fragCoord+vec2(0.,1.)+offset);\n            col+=render(uv,px,py);\n        }\n    }\n    vec2 uv=fragCoord / iResolution.xy;\n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    float d=sdgEllipse(px,vec2(len+.2,2.-2.*ani_time));\n    col=col*smoothstep(.5,0.,d);\n    fragColor=vec4(col/16.,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftffDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 128, 128, 214], [215, 215, 253, 253, 279], [281, 281, 311, 311, 339], [340, 340, 360, 360, 621], [622, 622, 658, 658, 738], [739, 739, 797, 797, 1208], [1209, 1209, 1260, 1260, 1398], [1399, 1399, 1424, 1424, 1443], [1444, 1444, 1475, 1475, 1558], [1559, 1559, 1611, 1611, 2108], [2109, 2109, 2133, 2133, 2159], [2160, 2160, 2221, 2283, 2489], [2490, 2490, 2535, 2535, 2624], [2625, 2625, 2676, 2676, 2797], [2798, 2798, 2838, 2838, 2924], [2925, 2925, 2965, 2965, 3051], [3052, 3052, 3077, 3077, 3132], [3133, 3133, 3159, 3159, 3214], [3216, 3216, 3247, 3247, 3301], [3302, 3302, 3332, 3332, 3358], [3359, 3359, 3391, 3391, 3446], [3447, 3447, 3479, 3479, 3534], [3535, 3535, 3563, 3563, 3661], [3662, 3662, 3690, 3690, 3788], [3789, 3789, 3817, 3817, 3915], [3916, 3916, 3939, 3939, 4006], [4008, 4008, 4047, 4047, 4171], [4172, 4172, 4219, 4219, 4331], [4332, 4462, 4512, 4512, 4853], [4854, 4854, 4872, 4872, 4921], [4922, 5171, 5229, 5258, 5405], [5406, 5406, 5455, 5455, 5691], [5692, 5692, 5742, 5742, 6017], [6019, 6019, 6085, 6085, 6650], [6651, 6651, 6731, 6731, 6885], [6886, 6886, 6915, 6915, 6943], [6944, 6944, 6997, 6997, 7252], [7253, 7253, 7278, 7278, 7504], [7505, 7505, 7535, 7535, 7730], [7731, 7731, 7759, 7759, 7996], [7997, 7997, 8020, 8020, 8211], [8212, 8212, 8238, 8238, 10646], [10647, 10647, 10667, 10667, 11432], [11433, 11433, 11455, 11455, 11511], [11512, 11512, 11571, 11571, 11785], [11787, 11787, 11816, 11816, 12119], [12120, 12120, 12158, 12158, 12549], [12550, 12550, 12591, 12591, 12742], [12743, 12743, 12790, 12790, 13156], [13157, 13157, 13194, 13194, 19518], [19519, 19519, 19558, 19558, 20046], [20059, 20059, 20112, 20112, 21267]], "test": "untested"}
{"id": "ftXfDf", "name": "color bars", "author": "artemis", "description": "variant on electron beam from awhile ago. idk whats going on but it looks cool.", "tags": ["oscilloscope", "rainbow"], "likes": 7, "viewed": 307, "published": 3, "date": "1651545751", "time_retrieved": "2024-07-30T16:50:26.566590", "image_code": "#define FALLOFF_START 1.0\n#define DECAY_START 0.1\n#define DECAY 20.0\n\n#define GRIDW 0.02\n\n#define GRID_R 0.672443156957688\n#define GRID_G 0.0103298230296269\n#define GRID_B 0.246201326707835\n#define FALLOFF_GRID 0.75\n\n//#define GRID_R 0.0544802764424424\n//#define GRID_G 0.0\n//#define GRID_B 0.0761853814813079\n\nfloat sRGB(float x) {\n    if (x <= 0.00031308)\n        return 12.92 * x;\n    else\n        return 1.055*pow(x,(1.0 / 2.4) ) - 0.055;\n}\n\nfloat saw(float t) {\n    t = t / 3.141592 / 2.0;\n \treturn t - floor(t);   \n}\n\nfloat tri(float t) {\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\nfloat tri2(float t) {\n    t = t / 3.141592 / 2.0;\n    return 2.0 * abs(t - floor(t + 0.5));\n}\n\nfloat grid(vec2 pix, float t) {\n    \n    float d = t + (pix.y / 30.0) + sin(pix.x * 500.0);\n    \n    float distortion = (sin(d * 400.0) + (sin(d * 600.0) / 2.0) + (sin(d * 800.0) / 3.0)) / 4.0;\n    \n    //float w = max(0.0, tri((pix.x + distortion) / 8.0) - (1.0 - GRIDW)) / GRIDW;\n    //float h = max(0.0, tri((pix.y + distortion) / 8.0) - (1.0 - GRIDW)) / GRIDW;\n    \n    float w = tri((pix.x + distortion) / 50.0);\n    float h = tri((pix.y + distortion) / 50.0);\n    \n    \n    float power = 1.0 + 0.25 * tri(pix.y / 50.0 + t / 6.0);\n    \n    float falloff = power * FALLOFF_GRID;\n    \n    float dist = min(w, h) * 25.0;\n    \n    \n    \n    //return min(power, max(w, h)\n    return min(power, power * (falloff * falloff) / (dist * dist));\n\n    \n    //return w;\n}\n\nfloat electron_beam(vec2 pix, float t, float toff) {\n\n    //toff = 0.0;\n    float beam_x = (saw(t * 4.0 + toff) * 400.0 - 200.0 + saw(t / -3.0 * tri2(t / 8.0)) * 200.0 - 100.0) / 2.0;\n    float beam_y = (saw(t * 3.0 - toff) * 400.0 - 200.0 + saw(t / -2.0 * tri2(t / 6.0)) * 200.0 - 100.0) / 2.0;\n\n    float dist = distance(pix, vec2(beam_x, beam_y));\n    \n    float power = 1.0 - (min(iTime - t, DECAY) / DECAY);\n    \n    float falloff = power * FALLOFF_START;\n    \n    return min(power, power * (falloff * falloff) / (dist * dist));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    \n    \n    vec2 center = iResolution.xy / 2.0;\n    \n    float scale = 386.0 / iResolution.x;\n    \n    vec2 uv = (fragCoord - center) * scale;\n    \n    \n        \n    float beam = 0.0;\n    \n    vec3 beamzz = vec3(0.0);\n    \n    float t = 0.0;\n    for (int i = 0; i < 2000; i++) {\n        float bbbb = electron_beam(uv, iTime - t, iTime / 2.0 + sin(t));\n        \n        float r = sin(float(i) / 50.0) + 1.0 / 2.0;\n        float g = cos(float(i) / 75.0) + 1.0 / 2.0;\n        float b = cos(float(i) / 25.0) + 1.0 / 2.0;\n        beamzz += vec3(bbbb * r, bbbb * g, bbbb * b);\n        t += 0.01;\n    }\n    //beamzz.a = 1.0;\n    \n    vec2 uv_r = uv - vec2(sin(iTime / 5.0 + uv.y / 100.0) * 2.0, sin(uv.x / 75.0 + iTime / 8.0));\n    vec2 uv_g = uv;\n    vec2 uv_b = uv + vec2(sin(iTime / 4.0 + uv.y / 100.0) * 2.0, cos(uv.x / 50.0 + iTime / 4.0));\n    \n    float grid_r = grid(uv_r, iTime) * GRID_R;\n    float grid_g = grid(uv_g, iTime - 0.1) * GRID_G;\n    float grid_b = grid(uv_b, iTime + 0.1) * GRID_B;\n    \n    vec3 grid_col = vec3(sRGB(grid_r), sRGB(grid_g), sRGB(grid_b));\n    //vec3 beam_col = vec3(sRGB(beam * 0.25), sRGB(beam), sRGB(beam));\n    vec3 beam_col = vec3(sRGB(beamzz.r), sRGB(beamzz.g), sRGB(beamzz.b));\n    \n    fragColor = vec4(grid_col + beam_col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftXfDf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[311, 311, 332, 332, 444], [446, 446, 466, 466, 522], [524, 524, 544, 544, 588], [590, 590, 611, 611, 683], [685, 685, 716, 716, 1448], [1450, 1450, 1502, 1521, 1985], [1987, 1987, 2044, 2044, 3320]], "test": "untested"}
{"id": "NlffDX", "name": "XY Oscilloscope Optimized: ~2x!", "author": "shyshokayu", "description": "~2x times faster: ~120 fps 800x450 with GTX 1060 6GB at 2000 iterations\nReduced texture calls by half than before, and storing half of the points with zw components in vec4.\nThe branch in Buffer A is removed, idk about performance improvements for that.", "tags": ["oscilloscope", "framework", "music", "optimized", "xy", "xyoscilloscope"], "likes": 19, "viewed": 612, "published": 3, "date": "1651534945", "time_retrieved": "2024-07-30T16:50:27.486131", "image_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n/*\n    ---| Go to Common tab to play with sound |---\n*/\n\n#define VISUAL_LINE_COLOR vec3(0.4, 1.0, 0.4)\n#define VISUAL_LINE_BLUR 2.0\n#define VISUAL_LINE_BRIGHTNESS 2000.0\n\nfloat sliderPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 ab = b - a;\n    return dot(p - a, ab) / dot(ab, ab);\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in float d) {\n    return mix(a, b, saturate(d));\n}\n\nvec2 closestPointLine(in vec2 a, in vec2 b, in vec2 p) {\n    return closestPointLine(a, b, sliderPointLine(a, b, p));\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p, in float k) {\n    vec2 d = p - closestPointLine(a, b, k);\n    return dot(d, d);\n}\n\nfloat distToLineSqr(in vec2 a, in vec2 b, in vec2 p) {\n    vec2 d = p - closestPointLine(a, b, p);\n    return dot(d, d);\n}\n\nfloat distToLine(in vec2 a, in vec2 b, in vec2 p) {\n    return sqrt(distToLineSqr(a, b, p));\n}\n\nvec2 pointTex(in float t) {\n    // Estimate location based on texture coordinate\n    t *= float(VISUAL_ITERATIONS_HALF);\n    \n    // Convert to int for texelFetch and for more reliable arithmetic\n    int i = int(t);\n    int j = i + 1;\n    \n    // Interpolation between two sampled points\n    ivec2 ip1 = ivec2(i % int(iChannelResolution[0].x), i / int(iChannelResolution[0].x));\n    vec4 p1 = texelFetch(iChannel0, ip1, 0).xyzw;\n    \n    vec2 p = mix(p1.xy, p1.zw, fract(t));\n\n    return p;\n}\n\nvec4 pointTexi(in int i) {\n    int r = int(iChannelResolution[0].x);\n    return texelFetch(iChannel0, ivec2(i % r, i / r), 0).xyzw;\n}\n\nfloat imageVectorScopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    float d = 0.01 + distanceSqr(a - b); // Emit less light if line is longer\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return min((0.00000004 / ((ld + (VISUAL_LINE_BLUR * 0.00001)) * d)), 0.2) * VISUAL_LINE_BRIGHTNESS;\n}\n\nfloat imageVectorScopeLines(in vec2 uv) {\n    float v = 0.0; // Total value\n    float lv = 0.0; // Last value\n    float cv = 0.0; // Current value\n    \n    vec4 cp;\n    \n    float fv = 1.0 / float(VISUAL_ITERATIONS_HALF);\n    float k;\n    \n    for(int i = 0; i < VISUAL_ITERATIONS_HALF; ++i) {\n        k = float(i) * fv;\n        cp = pointTexi(i); // Get the point\n        cv = imageVectorScopeLine(cp.xy, cp.zw, uv) * (1.0 - k);\n        v += max(cv, lv);\n        lv = cv;\n    }\n    \n    return v * fv;\n}\n\nvec3 imageVectorScope(in vec2 uv, in float un) {\n    vec3 col = vec3(0.0);\n\n    // Lines\n    float v = imageVectorScopeLines(uv);\n    vec3 emitCol = pow(v * 0.5, 0.5) * VISUAL_LINE_COLOR;\n\n    // Grid\n    vec3 surfaceCol = vec3(1.0);\n    float gridLineSize = 0.015;\n    float gridSize = 4.0;\n    float gridV =  0.1 * (max(max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.x * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.x * gridSize))), max(smoothstep(gridLineSize + un, gridLineSize, fract(uv.y * gridSize)), smoothstep((1.0 - gridLineSize) - un, 1.0 - gridLineSize, fract(uv.y * gridSize)))));\n    surfaceCol = mix(surfaceCol, vec3(2.0), gridV);\n\n    // Ambient light                                                           Inner display tube light absorption?\n    vec3 lightCol = vec3(0.045) * max(0.0, dot(uv + 0.5, vec2(0.12, 0.15) * 4.0)) * linearstep(-0.5, 3.0, length(uv));\n\n    // Color compositing\n    col = surfaceCol * lightCol;\n    col += emitCol * (1.0 - gridV);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n\n    return col;\n}\n\nfloat imageOscilloscopeLine(in vec2 a, in vec2 b, in vec2 p) {\n    const float ta = 0.0;\n    const float tb = 0.004;\n    const float dta = ta * ta;\n    const float dtb = tb * tb;\n    float s = saturate(sliderPointLine(a.xy, b.xy, p));\n    float ld = distToLineSqr(a.xy, b.xy, p, s);\n    return linearstep(dtb, dta, ld);\n}\n\nvec3 oscilloscopePoint(float x) {\n    return vec3(x, pointTex(1.0 - ((x * 0.5) + 0.5)));\n}\n\nvec3 imageOscilloscope(in vec2 uv, in float un) {\n    const float segments = 250.0;\n    const float thickness = 1.0 / segments;\n    const float gridThickness = 0.001;\n    const float gridInterval = 2.0;\n    float ip = round(uv.x * segments);\n    float unit = 1.0 / segments;\n\n    vec3 p0 = oscilloscopePoint((ip - 2.0) * unit),\n         p1 = oscilloscopePoint((ip - 1.0) * unit),\n         p2 = oscilloscopePoint((ip) * unit),\n         p3 = oscilloscopePoint((ip + 1.0) * unit),\n         p4 = oscilloscopePoint((ip + 2.0) * unit);\n\n    float dist1 = min(min(distToLine(p0.xy, p1.xy, uv), distToLine(p1.xy, p2.xy, uv)),\n                      min(distToLine(p2.xy, p3.xy, uv), distToLine(p3.xy, p4.xy, uv))) - thickness;\n    \n    float dist2 = min(min(distToLine(p0.xz, p1.xz, uv), distToLine(p1.xz, p2.xz, uv)),\n                      min(distToLine(p2.xz, p3.xz, uv), distToLine(p3.xz, p4.xz, uv))) - thickness;\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.8, 0.2, 0.2) * smoothstep(un, -un, dist1);\n    col += vec3(0.2, 0.2, 0.8) * smoothstep(un, -un, dist2);\n\n    // Cut out to make a square view\n    col *= step(abs(uv.x), 1.0) * step(abs(uv.y), 1.0);\n    \n    return col;\n}\n\nvec3 aces(vec3 x) {\n    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);\n}\n\nvoid mainImage(out vec4 o, in vec2 u) {\n    float un = 1.0 / min(iResolution.x, iResolution.y);\n    un *= 2.0;\n    \n    vec2 uv = (u - (0.5 * iResolution.xy)) * un;\n    \n    vec3 col = mix(\n        mix(\n            imageVectorScope(uv, un),\n            imageOscilloscope(uv, un),\n            texelFetch(iChannel3, ivec2(69, 2), 0).x // nice\n        ),\n        ((texture(iChannel0, (u / iResolution.xy)).xyz * 0.5) + 0.5), // Show cached points visually\n        texelFetch(iChannel3, ivec2(81, 2), 0).x\n    );\n\n    col = pow(col, vec3(1.0 / 1.2));\n\n    col = aces(col);\n\n    // Full depth dithering, a way to make your images less bandy in low color ranges.\n    // Since we're using floats here, we can use that as an opportunity to dither that to the common color format, 32bit rgba.\n    // Essentially for free.\n    float depth = 256.0;\n    vec3 cd = col * depth;\n    vec3 di = floor(cd);\n    vec3 df = cd - di;\n    vec3 ditheredCol = (step(texture(iChannel2, u * 0.125).x + 0.00001, df) + di) / depth;\n    \n    o = vec4(ditheredCol, 1.0);\n\n    // Just uncomment this line and see how much of a difference this dithering makes in the dark areas.\n    //o = vec4(col, 1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n    MIT License\n\n    Copyright (c) 2022 shyshokayu\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy\n    of this software and associated documentation files (the Software), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, andor sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\n/*\n    Feel free to make your own music/art with this shader,\n    but don't forget to provide credit to me for making this framework.\n*/\n\n#define VISUAL_ITERATIONS 2000 // Number of iterations to draw the whole line for the current frame\n#define VISUAL_DURATION (2.0 / 60.0) // How long the line should last for a frame\n\n#define VISUAL_ITERATIONS_HALF (VISUAL_ITERATIONS / 2) // Actual texture calls internally, but actual iterations is VISUAL_ITERATIONS (not half)\n\n// Mathematical functions\n#define PI 3.1415926535897932384626433832795\n#define TAU (PI * 2.0)\n\n#define map(a, b, x) (((x) - (a)) / ((b) - (a)))\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define linearstep(a, b, x) saturate(map(a, b, x))\n#define cmix(a, b, x) mix(a, b, saturate(x))\n\n#define steprange(a, b, t) (step(a, t) * step(t, b))\n\n#define distanceSqr(v) dot(v, v)\n\nmat2 rot(float r) {\n    float s = sin(r), c = cos(r);\n    return mat2(c, -s, s, c);\n}\n\n#define rote(r) rot(r * PI)\n\nmat3 rotX(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        1.0, 0.0, 0.0,\n        0.0, c  , -s ,\n        0.0, s  , c\n    );\n}\n\nmat3 rotY(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , 0.0, -s ,\n        0.0, 1.0, 0.0,\n        s  , 0.0, c\n    );\n}\n\nmat3 rotZ(float r) {\n    float s = sin(r), c = cos(r);\n    return mat3(\n        c  , -s , 0.0,\n        s  , c  , 0.0,\n        0.0, 0.0, 1.0\n    );\n}\n\nmat3 roteX(float r) {\n    return rotX(r * PI);\n}\n\nmat3 roteY(float r) {\n    return rotY(r * PI);\n}\n\nmat3 roteZ(float r) {\n    return rotZ(r * PI);\n}\n\nmat4 matrixTransform(float x, float y, float z) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        x  , y  , z  , 1.0\n    );\n}\n\nmat4 matrixTransform(vec3 p) {\n    return mat4(\n        1.0, 0.0, 0.0, 0.0,\n        0.0, 1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0, 0.0,\n        p.x, p.y, p.z, 1.0\n    );\n}\n\nmat4 matrixScale(float x, float y, float z) {\n    return mat4(\n        x  , 0.0, 0.0, 0.0,\n        0.0, y  , 0.0, 0.0,\n        0.0, 0.0, z  , 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\n\nmat4 matrixScale(vec3 p) {\n    return mat4(\n        p.x, 0.0, 0.0, 0.0,\n        0.0, p.y, 0.0, 0.0,\n        0.0, 0.0, p.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    );\n}\nfloat easeIn(float x) {\n    return x * x;\n}\n\nfloat easeOut(float x) {\n    return 1.0 - easeIn(1.0 - x);\n}\n\nfloat easeInOut(float x) {\n    return mix(easeIn(x), easeOut(x), x);\n}\n\nfloat easeIn(float a, float b, float x) {\n    return easeIn(linearstep(a, b, x));\n}\n\nfloat easeOut(float a, float b, float x) {\n    return easeOut(linearstep(a, b, x));\n}\n\nfloat easeInOut(float a, float b, float x) {\n    return easeInOut(linearstep(a, b, x));\n}\n\nfloat randomnoise11(float p) {\n    return fract(sin(p * 12.9898) * 43758.5453123);\n}\n\nvec2 randomnoise12(float p) {\n    float x = randomnoise11(p);\n    return vec2(x, randomnoise11(p + x));\n}\n\n// Musical functions\n#define pitch(x) (pow(1.059460646483, x) * 440.0)\n\n#define sine(x) sin((x) * PI)\n#define cosine(x) cos((x) * PI)\n#define square(x) ((fract((x) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define cosquare(x) ((fract(((x) + 0.5) * 0.5) > 0.5) ? -1.0 : 1.0)\n#define saw(x) ((fract((x) * 0.5) * 2.0) - 1.0)\n#define cosaw(x) ((fract(((x) + 0.5) * 0.5) * 2.0) - 1.0)\n#define cotriangle(x) (-(abs(fract((x) * 0.5) - 0.5) * 4.0) + 1.0)\n#define triangle(x) cotriangle((x) + 0.5)\n\n// Some musical functions made specifically for this preview\nvec3 hihats(float t) {\n    vec3 p = vec3(0.0);\n\n    p.xy = ((randomnoise12(t) * 2.0) - 1.0) * 0.5 * fract(-t + 0.25);\n    \n    p.xy *= step(fract(t * 2.0), 0.125) * step(fract(t * 0.5), 0.85);\n    \n    return p;\n}\n\nvec3 kick(float t) {\n    float tf = (t * 300.0) - (20.0 * (fract(-t * 0.5) * easeOut(0.0, 0.1, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p *= 3.0 * fract(-t * 3.0);\n    p *= smoothstep(0.0625, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 kicks(float t) {\n    vec3 p;\n    \n    float t2 = fract(t * 0.125) * 8.0;\n    \n    p += kick(t2);\n    p += kick(t2 - 2.5);\n    \n    p += kick(t2 - 4.0);\n    p += kick(t2 - 6.5);\n    \n    return p;\n}\n\nvec3 snare(float t) {\n    float tf = (t * 400.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 4.0, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snare2(float t) {\n    float tf = (t * 1200.0) - (20.0 * (fract(-t * 0.5) * easeOut(-0.015, 0.04, fract(t * 3.0))));\n    vec3 p = vec3(sine(tf), cosine(tf), 0.0);\n    p.xy += ((randomnoise12(t) * 2.0) - 1.0) * 2.0 * fract(t * 3.0);\n    p *= 3.0 * fract(-t * 4.0);\n    p *= smoothstep(0.0625 * 3.0 * 0.25, 0.0, t);\n    p *= step(0.0, t);\n    return p;\n}\n\nvec3 snares(float t) {\n    vec3 p;\n    \n    float t2 = fract((t * 0.25) + 0.25) * 4.0;\n    \n    p += snare(t2);\n    p += snare(t2 - 2.0);\n    \n    return p;\n}\n\nvec3 drums(float t) {\n    vec3 p;\n    \n    p += kicks(t);\n    p += snares(t);\n    \n    return p;\n}\n\nfloat freqArpeggiator1(float t) {\n    float s = ((triangle(floor(fract(t) * 4.0) * 0.25) * 0.5) + 0.5) * 4.0;\n    s += ((triangle(floor(t) * 0.5) * 0.5) + 0.5) * 8.0;\n    s += 1.0;\n    \n    return pitch(s);\n}\n\n// Fade in at t = (0.0 .. 0.0 + delta) then fade out at t = (1.0 .. 1.0 - delta)\nfloat declick(float t, float delta) {\n    return linearstep(0.0, delta, t) * linearstep(1.0, 1.0 - delta, t);\n}\n\n// This is your sandbox:\nvec2 point(float t) {\n    vec3 p = vec3(0.0);\n    \n    t = fract(t / 32.0) * 32.0; // Loop\n    \n    float freq = freqArpeggiator1(t);\n    float tf = t * freq;\n    \n    p = vec3(sine(tf), cosine(tf), 0.0);\n\n    p.yz *= rote(t * 0.5);\n    p.xy *= rote(t * 0.25);\n    \n    p *= mix(1.0, fract(tf * 0.125), 0.25) * mix(0.75, 1.0, fract(-t * 2.0));\n\n    p -= vec3(0.0, 0.0, -1.5);\n    \n    p.xy /= p.z;\n    \n    p += step(8.0, t) * hihats(t);\n    p += step(16.0, t) * drums(t);\n    \n    p *= 1.0 - (easeOut(7.75, 8.0, fract(t * 0.125) * 8.0) * fract(floor(t * 16.0) * 0.5));\n    \n    p *= easeOut(0.0, 0.5, t);\n    p *= easeOut(32.0, 31.5, t);\n    \n    return clamp(p.xy, vec2(-1.0), vec2(1.0));\n}\n", "buffer_a_code": "// Samples coordinates every frame instead of sampling every iteration for every pixel for every frame\nvoid mainImage(out vec4 o, in vec2 u) {\n    // Estimate time based on pixel and calculate point\n    u.y -= 0.5; // For some reason this fixes the error where t > VISUAL_ITERATIONS is wrong\n    float t = u.x + (u.y * iResolution.x);\n    \n    // Skip samples if outside used region\n    /*if(t > float(VISUAL_ITERATIONS)) {\n        o = vec4(0.0, 0.0, 0.0, 0.0);\n        return;\n    }*/\n    \n    t *= VISUAL_DURATION / float(VISUAL_ITERATIONS);\n    \n    float tk = (iTime + iTimeDelta) - t;\n    \n    // Output point result\n    o.xy = point(tk);\n    o.zw = point(tk - (VISUAL_DURATION / float(VISUAL_ITERATIONS)));\n}\n", "buffer_a_inputs": [], "sound_code": "vec2 mainSound(int s, float t) {\n    vec2 v = point(t);\n\n    // Some background noise (optional)\n    v += (((texture(iChannel0, vec2(t * 1.4236, t * 1.2267)).xy * 2.0) - 1.0) * 0.0625 * 0.25);\n\n    return v * 0.25; // User convenience, we don't want to destroy any ears\n}\n", "sound_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlffDX.jpg", "access": "api", "license": "mit", "functions": [[1445, 1445, 1501, 1501, 1565], [1567, 1567, 1624, 1624, 1661], [1663, 1663, 1719, 1719, 1782], [1784, 1784, 1850, 1850, 1918], [1920, 1920, 1974, 1974, 2042], [2044, 2044, 2095, 2095, 2138], [2140, 2140, 2167, 2220, 2632], [2634, 2634, 2660, 2660, 2767], [2769, 2769, 2830, 2830, 3118], [3120, 3120, 3161, 3161, 3624], [3626, 3626, 3674, 3674, 4759], [4761, 4761, 4823, 4823, 5082], [5084, 5084, 5117, 5117, 5174], [5176, 5176, 5225, 5225, 6360], [6362, 6362, 6381, 6381, 6469], [6471, 6471, 6510, 6510, 7645]], "test": "untested"}
{"id": "stXfD2", "name": "Exponential interpolation", "author": "fermion", "description": "Interpolation of an exponential function with curvature determined by the mouse x-position.\n\nPlay with the function here:\n[url]https://www.desmos.com/calculator/b9z3gtxma2[/url]", "tags": ["math", "function", "interpolation"], "likes": 10, "viewed": 227, "published": 3, "date": "1651534726", "time_retrieved": "2024-07-30T16:50:28.234132", "image_code": "// parameters\nfloat start = 0.9;\nfloat end = 0.1;\n\nfloat lineWidth = .015;\nfloat antiAliasing = 0.002;\nfloat glowWidth = .25;\n\n// colors\nvec3 aboveGradientTop    = vec3(0.15, 0.1, 0.5);\nvec3 aboveGradientBottom = vec3(0.0 , 0.0, 0.15);\nvec3 belowGradientTop    = vec3(0.1 , 0.2, 0.7);\nvec3 belowGradientBottom = vec3(0.3 , 0.6, 0.9);\n\nvec3 lineColor = vec3(0.6, 0.8, 1.0);\nvec3 glowColor = vec3(0.1, 0.1, 0.25);\n\nfloat exponentialFunction(float x, float yStart, float yEnd, float k) {\n    \n    float expOfK = exp(k);\n    float expOfKX = exp(k * x);\n    float normalization = expOfK - 1.0;\n\n    return (1.0f / normalization) * (yEnd * (expOfKX - 1.0) - (yStart * (expOfKX - expOfK)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n        \n    float curvature = 32.0f * ((iMouse.x / iResolution.x) - 0.5f);\n    \n    vec3 aboveColor = mix(aboveGradientBottom, aboveGradientTop, uv.y);\n    vec3 belowColor = mix(belowGradientBottom, belowGradientTop, uv.y);\n\n    // y value of exponential curve\n    float y = abs(curvature) < 0.0001 ? // prevent division by zero\n              mix(start, end, uv.x)   : // 0 curvatuve is just a line\n              exponentialFunction(uv.x, start, end, curvature);\n        \n    float verticalDistance = uv.y - y;\n    float derivativeOfVerticalDistance = fwidth(verticalDistance) * iResolution.y;\n\n    // Output to screen\n    vec3 backgroundColor = (verticalDistance < 0.0) ? belowColor : aboveColor;\n    \n    float line = abs(verticalDistance) - 0.5 * lineWidth * derivativeOfVerticalDistance;\n    line = smoothstep(antiAliasing, -antiAliasing, line);\n    \n    float glow = abs(verticalDistance) - 0.5 * glowWidth * derivativeOfVerticalDistance;\n    glow = smoothstep(glowWidth, -glowWidth, glow);\n    \n    fragColor.rgb = mix(backgroundColor, lineColor, line);\n    fragColor.rgb += glow * glowColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[413, 413, 484, 484, 685], [687, 687, 744, 794, 1936]], "test": "untested"}
{"id": "ftfBWf", "name": "Purple Newtons Fractal", "author": "zmayhew", "description": "A basic newton fractal renderer", "tags": ["fractal"], "likes": 4, "viewed": 228, "published": 3, "date": "1651533363", "time_retrieved": "2024-07-30T16:50:28.978142", "image_code": "const vec2 ROOT_0 = vec2(0.5, 0.0);\nconst vec2 ROOT_1 = vec2(0.0, 0.5);\nconst vec2 ROOT_2 = vec2(1.0, 0.5);\n\nconst int ITERATIONS = 100;\n\nconst float SCALE = 1.5;\n\nconst vec3 COL_0 = vec3(0.39, 0.66, 0.97);\nconst vec3 COL_1 = vec3(0.53, 0.45, 0.97);\nconst vec3 COL_2 = vec3(0.40, 0.40, 0.90);\n\nstruct roots_t {\n    vec2 r0;\n    vec2 r1;\n    vec2 r2;\n};\n\nvec2 product(in vec2 a, in vec2 b) {\n    return vec2(a.x*b.x-a.y*b.y, a.x*b.y+a.y*b.x);\n}\n\nvec2 divide(in vec2 a, in vec2 b) {\n    return vec2(((a.x*b.x+a.y*b.y)/(b.x*b.x+b.y*b.y)),((a.y*b.x-a.x*b.y)/(b.x*b.x+b.y*b.y)));\n}\n\nvec2 f(in roots_t roots, in vec2 z) {\n    return product(product(z - roots.r0, z - roots.r1), z - roots.r2);\n}\n\nvec2 f_prime(in roots_t roots, in vec2 z) {\n    vec2 z2 = 3.0 * product(z, z);\n    vec2 z1 = -2.0 * product(z, roots.r0 + roots.r1 + roots.r2);\n    vec2 z0 = product(roots.r0, roots.r1 + roots.r2)\n            + product(roots.r1, roots.r2);\n    return z2 + z1 + z0;\n}\n\nvec2 newton_iteration(in roots_t roots, in vec2 z_n) {\n    return z_n - divide(f(roots, z_n), f_prime(roots, z_n));\n}\n\nvec2 newton_loop(in roots_t roots, in vec2 initial_z) {\n    vec2 z = initial_z;\n    for (int i = 0; i < ITERATIONS - 1; ++i) {\n        z = newton_iteration(roots, z);\n    }\n    return z;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (((fragCoord/iResolution.y) * 2.0) - vec2(1.0, 1.0))/SCALE;\n    vec2 mouse = (((iMouse.xy/iResolution.y) * 2.0) - vec2(1.0, 1.0))/SCALE;\n\n    \n    roots_t roots = roots_t(\n        mouse,\n        ROOT_1,\n        ROOT_2\n    );\n\n    \n    if (distance(uv, roots.r0) < 0.05\n     || distance(uv, roots.r1) < 0.05\n     || distance(uv, roots.r2) < 0.05\n       ) {\n        fragColor = vec4(1.0);\n        return;\n    }\n    \n    vec2 z = newton_loop(roots, uv);\n    \n    float d_0 = distance(z, roots.r0);\n    float d_1 = distance(z, roots.r1);\n    float d_2 = distance(z, roots.r2);\n    \n    vec3 col = COL_2;\n    \n    if (d_0 < d_1 && d_0 < d_2) {\n        col = COL_0;\n    } else if (d_1 < d_2 && d_1 < d_0) {\n        col = COL_1;\n    }\n    \n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ftfBWf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[354, 354, 390, 390, 443], [445, 445, 480, 480, 576], [578, 578, 615, 615, 688], [690, 690, 733, 733, 956], [958, 958, 1012, 1012, 1075], [1077, 1077, 1132, 1132, 1265], [1268, 1268, 1325, 1325, 2107]], "test": "untested"}
{"id": "NtXfDX", "name": "Pixel Thing 98761", "author": "SnoopethDuckDuck", "description": "lots of unused code", "tags": ["e"], "likes": 8, "viewed": 210, "published": 3, "date": "1651529722", "time_retrieved": "2024-07-30T16:50:29.715172", "image_code": "#define rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define thc(a,b) tanh(a*cos(b))/tanh(a)\n#define pi 3.14159\n\nfloat line(in vec2 f, in vec2 p, in vec2 q) { \n    // Translate space. We consider 0,0 to p-q\n    f -= p;\n    \n    vec2 pq = p - q;   \n    float a = atan(pq.x, pq.y) + pi / 2.;\n    \n    // Rotate f\n    float c = cos(a), s = sin(a);    \n    float x = c * f.x - s * f.y;\n    float y = s * f.x + c * f.y;\n\n    // Split space into 1 (above rotated y), 0 (below)\n    float e = step(y, 0.);\n\n    // Do the same for 4 neighbouring cells (in non-rotated space)\n    float t = step(y,  c);\n    float b = step(y, -c);\n    float r = step(y,  s);\n    float l = step(y, -s);  \n     \n    // If some neighbours are different, we draw a line\n    // Otherwise, we don't (0 0 0 0, 1 1 1 1 -> 0 )  \n    float m = max(max(t,b),max(l,r)) - min(min(t,b),min(l,r));\n    // m = step(1., mod(t + b + l + r, 4.));\n    \n    // Center x at d (in rotated space). Only include cells within d of it.\n    // (only include cells between p and q)\n    float d = 0.5 * length(pq);  \n    return e * m * step(abs(x - d), d);   \n}\n\nvec2 edge(vec2 p) {\n    vec2 p2 = abs(p);\n    if (p2.x > p2.y) return vec2((p.x < 0.) ? -1. : 1., 0);\n    else             return vec2(0., (p.y < 0.) ? -1. : 1.);\n}\n\nfloat circle(vec2 coord, float r) {\n    float d = length(coord);     \n    float d2 = length(coord + edge(coord));   \n    return step(d,r) - step(d2, r);\n}\n\nfloat v(vec2 f, float o) {\n    float t = iTime;\n    f.y += 0.2 * f.x * thc(400., 0.15 * f.x  - 2.5 * t + o);\n    return step(f.y, \n    32. * thc(100., -2. * t + 0.15 * f.x + 0.5 * thc(4., 10.5 * f.y - t) ));    \n}\n\nfloat test(vec2 f, float o) {  \n    float e = v(f, o);\n    \n    float t = v(f + vec2(0,1), o);\n    float b = v(f - vec2(0,1), o);\n    float l = v(f + vec2(1,0), o);\n    float r = v(f - vec2(1,0), o);\n    float m = max(max(t,b),max(l,r)) - min(min(t,b),min(l,r));\n    return e * m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    uv *= 3.;\n\n    float sc = 42.;\n    vec2 ipos = floor(sc * uv) + 0.5;\n\n    float o = 2. * pi / 3.;\n    vec3 col = vec3(test(ipos, 0.),\n                    test(ipos, -o),\n                    test(ipos, o));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXfDX.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 155, 203, 1100], [1102, 1102, 1121, 1121, 1266], [1268, 1268, 1303, 1303, 1422], [1424, 1424, 1450, 1450, 1637], [1639, 1639, 1668, 1668, 1921], [1923, 1923, 1980, 1980, 2294]], "test": "untested"}
{"id": "7tlfD2", "name": "Liquid Crystal Forest", "author": "tomachi", "description": "Fluid-like continuous cellular automata by  cornusammonis in 2016:  [url]https://shadertoy.com/view/Xst3Dj[/url]\nWebGL2 cleansing by FabriceNeyret2 in 2019:  [url] https://www.shadertoy.com/view/ttjXzR[/url]\nin 2022 I add colour and crystalisation.", "tags": ["diffusion", "feedback", "reaction"], "likes": 7, "viewed": 330, "published": 3, "date": "1651523143", "time_retrieved": "2024-07-30T16:50:30.462174", "image_code": "// WebGL2 cleaned-up version of \"Viscous Fingering\" by cornusammonis. https://shadertoy.com/view/Xst3Dj\n\nvoid mainImage(out vec4 O, vec2 u) {\n        vec2 U = u;\n        O =  normalize(T()); \n        \n        // Before Fabrice suggestion I had chosen values:\n        //O =  O/vec4(2,4,4,1) + .5*O.z;\n   \n        // now I boost the blue and dial back the red and green\n        O =  O/vec4(1.3,1.3,0.75,1) + 0.4 *O.z; // 28.1 fps \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 O, vec2 U )\n{\nfloat _K0 = -20./6., // center weight\n      _K1 =   4./6., // edge-neighbors\n      _K2 =   1./6., // vertex-neighbors\n       cs =  .12052 + (U.x*0.0000051),    // curl scale\n       ls =  .12052 + (U.x*0.0000051),    // laplacian scale\n       ps = -.06,    // laplacian of divergence scale\n       ds = -.08,    // divergence scale\n      pwr =  .2,     // power when deriving rotation angle from curl\n      amp = 0.888+(U.y*0.00051),      // self-amplification\n      sq2 =  .7;     // diagonal weight\n\n// 3x3 neighborhood coordinates\n    vec4 uv = T( ),\n          n = T(vec2( 0,  1 )),\n          e = T(vec2( 1,  0 )),\n          s = T(vec2( 0, -1 )),\n          w = T(vec2(-1,  0 )),\n         nw = T(vec2(-1,  1 )),\n         sw = T(vec2(-1     )),\n         ne = T(vec2( 1     )),\n         se = T(vec2( 1, -1 ));\n    \n    // uv.x and uv.y are our x and y components, uv.z is divergence \n\n    // laplacian of all components\n    vec4 lapl  = _K0*uv + _K1*(n + e + w + s) \n                        + _K2*(nw + sw + ne + se);\n    float sp = ps * lapl.z;\n    \n    // calculate curl\n    // vectors point clockwise about the center point\n    float curl = n.x - s.x - e.y + w.y \n        + sq2 * (nw.x + nw.y + ne.x - ne.y + sw.y - sw.x - se.y - se.x);\n    \n    // compute angle of rotation from curl\n    float a = cs * sign(curl) * pow(abs(curl), pwr);\n    \n    // calculate divergence\n    // vectors point inwards towards the center point\n    float div  = s.y - n.y - e.x + w.x \n        + sq2 * (nw.x - nw.y - ne.x - ne.y + sw.x + sw.y + se.y - se.x);\n    float sd = ds * div;\n\n    vec2 norm = normalize(uv.xy);\n    \n    // temp values for the update rule\n     vec2 t = (amp * uv + ls * lapl + uv * sd).xy + norm * sp;\n     float red = sd;\n     float green = div;\n     float blue = t.x;\n     //O = vec4(red,green, blue, 1.0);\n     //O = clamp(vec4(t,div,0), -1., 1.);\n     \n     t *= mat2(cos(a), -sin(a), sin(a), cos(a) );\n    if(iFrame<12)\n        O = -.5 + texture(iChannel1, U/R), O.a=0.;\n     else \n        O = clamp(vec4(t,div,0), -1., 1.);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R    iResolution.xy\n#define T(d) texelFetch(iChannel0, ivec2(d+U)%ivec2(R),0)", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tlfD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[105, 105, 141, 141, 430]], "test": "untested"}
{"id": "NlsfWN", "name": "Mesmerizing rings", "author": "LongJohnny", "description": "A set of metallic torus rotating aroung a sphere in an interesting way.", "tags": ["torus", "specular", "metal", "rotating"], "likes": 15, "viewed": 404, "published": 3, "date": "1651500293", "time_retrieved": "2024-07-30T16:50:31.222142", "image_code": "// A set of metallic torus rotating aroung \n// a sphere in an interesting way.\n//\n// The effect comes from accumulating the rotations from the smallest\n// to the largest ring.\n// ----------------------------------------\n\n#define MAX_MARCH_STEPS 50\n#define MAX_MARCH_DIST 10.\n#define MIN_MARCH_DIST 0.01\n\n#define PI 3.14159265359\n#define COLOR vec3(227./255.,147./255.,64./255.)\n#define COLOR2 vec3(.01,0.01,.05)\n\nvec4 sdScene(vec3 p);\n\nvec4 rayMarch(vec3 ro, vec3 rd) {\n    \n    vec4 res = vec4(-1.); // color = xyz, distance = w \n    \n    float t = 0.001f;\n    for (int i = 0; i < MAX_MARCH_STEPS; ++i) {\n        \n        vec4 ds = sdScene(ro + rd*t);   \n        if(ds.w < MIN_MARCH_DIST) {\n            res = vec4(ds.xyz, t);\n            break;\n        }\n        \n        if (ds.w > MAX_MARCH_DIST) {\n            res = vec4(0.0, 0.0, 0.0, -1);\n            break;\n        }\n        \n        t += ds.w;\n    }\n    \n    return res;\n}\n\nvec4 sdScene(vec3 p) {\n     \n    float t = sdSphere(p, 1.);;\n    float ds;\n    \n    p.yz *= rot(PI/2.);\n    \n    float mrgs = 23.;\n    float rgs = floor((mrgs - 5.) / 2.);\n    \n    for (float i = 5.; i < mrgs; i++) {\n        \n        if (mod(i,2.) == 0.) {\n            p.xz *= rot(pow(sin(iTime * .07),2.) * sin(iTime * .01) * 10.);\n            ds = sdTorus(p, vec2(i * .3,.1 * min(3.,i/rgs))); if (ds < t) t = ds; \n        } else {\n            p.zy *= rot(pow(cos(iTime * .07),2.) * cos(iTime * .01) * 10.);\n        }\n    }\n        \n    return vec4(vec3(0.), t);\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal(vec3 p) // for function f(p)\n{\n    const float h = 0.0001; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*sdScene( p + k.xyy*h ).w + \n                      k.yyx*sdScene( p + k.yyx*h ).w + \n                      k.yxy*sdScene( p + k.yxy*h ).w + \n                      k.xxx*sdScene( p + k.xxx*h ).w );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    vec3 origin = vec3(0.);\n    \n    vec3 ro = vec3(0., 0., -7.);\n    ro.z -= (sin(iTime) * .5 + .5) * 2.;\n    vec3 rd = rayDir(ro, origin, uv);\n    \n    vec4  obj = vec4(0.);\n    if (intersectSphere(ro, rd, vec3(0.), 6.93)) {\n        obj = rayMarch(ro, rd);\n    }\n    \n    vec3 col;\n    if (obj.w > 0.) {\n        \n        vec3 p = ro + rd*obj.w;\n        vec3 n = calcNormal(p);\n       \n        float R0 = pow((1. - 0.46094)/(1. + 0.46094),2.);        \n        \n        // Bottom Light\n        {\n            float dif = -n.y*.5 + .5;\n            float spe = -reflect(rd, n).y;\n           \n            spe = smoothstep(0.3,0.9, spe); \n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.) * 0.3;\n            \n            col += COLOR * dif * 0.02;\n            col += COLOR * spe * dif * .8;\n        }\n        \n        // Top Light\n        {\n            float dif = n.y*.5 + .5;\n            float spe = reflect(rd, n).y;\n            \n            spe = smoothstep(0.3,0.9, spe); \n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.) * 10.;\n            \n            col += COLOR2 * dif;\n            col += COLOR2 * spe * dif * .8;\n        }\n        \n        // Right Light\n        {\n            vec3 ld = normalize(vec3(1.0, -0.4, 0.3));\n            float dif = max(0., dot(n, ld));\n            \n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.);\n            \n            col += dif * COLOR * .5;\n            col += spe * COLOR * dif * .8;\n        }\n        \n        // Left Light\n        {\n            vec3 ld = normalize(-vec3(1.0, -0.7, 0.3));\n            float dif = max(0., dot(n, ld));\n            \n            vec3 hlf = normalize(-rd + ld);\n            float spe = pow(max(0., dot(n, hlf)), 16.);\n            spe *= R0 + (1. - R0)*pow(1. - dot(rd, n), 5.);\n            \n            col += dif * COLOR2 * .5;\n            col += spe * COLOR2 * dif * 6. * .8;\n        }\n        \n    } else {\n        col = COLOR2 * min(fragCoord.y/iResolution.y + .15, 1.);\n    }\n     \n    // Gamma correct ^(1/2.2)\n    col = pow(col, vec3(.4545));\n    \n    col = clamp(col, 0., 1.);\n    col = smoothstep(0., 1., col);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec3 rayDir(vec3 ro, vec3 origin, vec2 uv) {\n    \n    vec3 d = normalize(origin - ro);\n    \n    vec3 r = normalize(cross(vec3(0.,1.,0.), d));\n    vec3 u = cross(d, r);\n    \n    return normalize(d + r*uv.x + u*uv.y); \n}\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nbool intersectSphere(vec3 ro, vec3 rd, vec3 p, float r) {\n    vec3 oc = ro - p;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - r*r;\n    float h = b*b - c;\n    if( h<0.0 ) return false;\n    return true;\n}\n\n/* ----- Distance functions ---------- */\nfloat sdSphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlsfWN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[436, 436, 469, 469, 930], [932, 932, 954, 954, 1497], [1499, 1545, 1591, 1591, 1911], [1913, 1913, 1970, 1970, 4321]], "test": "untested"}
{"id": "slfBW2", "name": "", "author": "sunebear", "description": "", "tags": ["threejs", "cineshader"], "likes": 15, "viewed": 4407, "published": 3, "date": "1651479397", "time_retrieved": "2024-07-30T16:50:32.041950", "image_code": "// Sourcehttps://www.shadertoy.com/view/stdXz7\n// The fork is for learning pmod\n\nprecision highp float;\n\n#define patternSide 6.0\n\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nconst float pi = acos(-1.0);\nconst float pi2 = pi*2.0;\n\nvec2 pmod(vec2 p, float r) {\n    float a = atan(p.x, p.y) + pi/r;\n    float n = pi2 / r;\n    a = floor(a/n)*n;\n    return p*rot(-a);\n}\n\nfloat box( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,-0.1));\n}\n\nfloat ifsBox(vec3 p) {\n    for (int i=0; i<3; i++) {\n        p = abs(p) - 1.0;\n        p.xy *= rot(iTime*0.3);\n        p.xz *= rot(iTime*0.1);\n    }\n    p.xz *= rot(iTime);\n    return box(p, vec3(0.4,0.8,0.3));\n}\n\nfloat map(vec3 p, vec3 cPos) {\n    vec3 p1 = p;\n    p1.x = mod(p1.x-5., 10.) - 5.;\n    p1.y = mod(p1.y-5., 10.) - 5.;\n    p1.z = mod(p1.z, 16.)-8.;\n    p1.xy = pmod(p1.xy, patternSide);\n    return ifsBox(p1);\n}\n\n\n// @REF: https://www.shadertoy.com/view/ttKGDt\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    vec3 cPos = vec3(0.0,0.0, -3.0 * iTime);\n    // vec3 cPos = vec3(0.3*sin(iTime*0.8), 0.4*cos(iTime*0.3), -6.0 * iTime);\n    vec3 cDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 cUp  = vec3(cos(iTime), 1.0, 0.0);\n    vec3 cSide = cross(cDir, cUp);\n\n    vec3 ray = normalize(cSide * p.x + cUp * p.y + cDir);\n\n    // Phantom Mode https://www.shadertoy.com/view/MtScWW by aiekick\n    float acc = 0.0;\n    float acc2 = 0.0;\n    float t = 0.0;\n    for (int i = 0; i < 99; i++) {\n        vec3 pos = cPos + ray * t;\n        float dist = map(pos, cPos);\n        dist = max(abs(dist), 0.02);\n        float a = exp(-dist*3.0);\n        if (mod(length(pos)+24.0*iTime, 30.0) < 3.0) {\n            a *= 2.0;\n            acc2 += a;\n        }\n        acc += a;\n        t += dist * 0.5;\n    }\n\n    vec3 col = vec3(acc * 0.01, acc * 0.011 + acc2*0.005, acc * 0.012+ acc2*0.008);\n    fragColor = vec4(col, 1.0 - t * 0.03);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfBW2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[134, 134, 153, 153, 216], [274, 274, 302, 302, 408], [410, 410, 439, 439, 531], [533, 533, 555, 555, 745], [747, 747, 777, 777, 957], [960, 1007, 1064, 1064, 2063]], "test": "untested"}
{"id": "slffDS", "name": "Intergral fog", "author": "El_Sargo", "description": "An experiment as a supplement to my math homework, added better lighting to one of my old shaders as well as integral fog based on the equation d=e^-h where d is the density. More info: https://www.desmos.com/calculator/4s65etlteh", "tags": ["3d", "raymarching", "fractal"], "likes": 10, "viewed": 514, "published": 3, "date": "1651475321", "time_retrieved": "2024-07-30T16:50:32.781972", "image_code": "//Heavy performance impact \n#define AA 1\n#define raymarchSteps 30\n#define rotationSpeed 7.\n#define ZERO min(iFrame, 0)\n#define post\n#define vignet\n\nconst float pi = 3.14159265359;\nmat2 rot(float a){\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c,-s,s,c);\n}\n// Base primitive\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec4 map(vec3 p) {\n    mat2 rotx = rot(sin (2. * iTime*0.1)*pi + sin(pi * iTime*0.1)*pi);\n    mat2 rotz = rot(cos(iTime/4.)*pi);\n    mat2 roty = rot(sin(iTime/4.+12313.123)*pi);\n    int maxI = 8;\n    float scale = 1.;\n    const float factor = 2.;\n    const float baseSize = .7;\n    float d = 10e10;\n    for (int i=ZERO;i<maxI;i++){ \n        p = abs(p)-.4*factor;\n        p *= factor;\n        scale /= factor;\n        p.yz *= rotx;\n        p.xy *= rotz;\n        p.xz *= roty;\n\n    }\n            d = min(d,\n             sdBox(p-vec3(0,.44*factor,0), (vec3(baseSize)))*scale-(0.4*scale)\n             );\n    return vec4(d,p);\n}\n\nfloat intersection(vec3 ro, vec3 rd){\n    float T = 0.;\n    for(int i=0;i < raymarchSteps;i++){\n        float dist = map(ro+rd*T).x;\n        \n        T +=dist;\n        if(dist <0.0026*T || dist > 4.)\n            break;\n    }\n    return T;\n}\n\n//iq ---\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k , float d){\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.0005*d )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\nvec3 calcNormal( in vec3 p, float t ){\n    float h = 0.002*t;\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(p+e*h).x;\n    }\n    return normalize(n);\n}\nfloat calcAO(vec3 pos, vec3 nor){\n\tfloat occ = 0.0;\n    float sca = .4;\n    for( int i=ZERO; i<5; i++ )\n    {\n            float h = 0.01 + 0.25*float(i)/4.0;\n        float d = map( pos+h*nor).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n// ---\nvec4 render(vec3 ro, vec3 rd){\n    //world info\n    float dist = clamp(0.,10.,intersection(ro,rd));\n    vec3 pos = dist*rd+ro;\n    vec4 d_t = map(pos);\n    vec3 trp = d_t.yzw;\n   float dis = d_t.x;\n   float trd = distance(pos, trp);\n    //Shading\n     vec3 sun = normalize(vec3(1., 1., 1.1));\n    float sha = softshadow(pos, sun, 0.01, 5., 4., dist);\n     vec3 nor = calcNormal(pos,dist);\n    float occ = calcAO(pos, nor);\n    float lig = (dot(sun,nor)*0.5+0.5);\n\n    //Colors\n    vec3 col = vec3(0);\n    vec3 bcl = 0.8*vec3(log(trd),0.5,cos(trd))*vec3(1,2,2);\n    vec3 scl = vec3(0.933,0.918,0.827);\n    vec3 amb = vec3(0.949,0.702,1.000);\n    vec3 ref = reflect(rd,nor);\n    \n    vec3 hvc = normalize(sun - rd);\n    //Intergral fog\n    float fogAmount;\n    {\n        float a = rd.y*0.0125;\n        float h = ro.y-2.5;\n        float fogDist = length(rd.xy)*dist;\n        fogAmount = (exp(fogDist*a*1.1)-1.)*exp(-fogDist*a-h)/a;\n    }\n    //Sun fog\n    float sunFog;\n    {\n        float a = sun.y*0.0125;\n        float h = pos.y-2.5;\n        float fogDist = length(sun.xy)*1000.;\n        sunFog = (exp(fogDist*a)-1.)*exp(-fogDist*a-h)/a;\n    }\n    float sunOcc = exp(-sunFog*0.0003);\n    \n    if (dis < 0.1) {\n        col += 4.*lig*sha*bcl*scl*sunOcc;\n        col += .2*amb*occ*bcl*(abs(dot(nor,sun))*.5+.5)*sunOcc;\n        col += .2*occ*(dot(ref, rd)+1.);\n        col += amb*pow(dot(nor,hvc)*.5+.5, 5.)*sha;\n        col += occ*2.*vec3(0.757,0.486,0.024)*bcl*scl*(.75+0.25*dot(nor,-sun))/smoothstep(-2.0,2.,length(pos.xz))*sunOcc;\n    } else {\n        fogAmount = 1.;\n    }\n    \n    col = mix(col,amb,clamp(fogAmount , 0., 1.));\n        \n        \n    col += vec3(0.878,0.412,0.102)*smoothstep(-.2,.5,dot(rd,sun));\n    return vec4(col, 1);\n}\n\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec3   ro = vec3(0, 0, -5.5);\n    mat2 yrot = rot(iTime*0.2);\n    mat2 xrot = rot(.9);\n           ro.yz *= xrot;\n           ro.xz *= yrot;\n\n    vec4 tot = vec4(0);\n    \n    //Super sampling\n    for(int m=0;m<AA;m++){\n    for(int n=0;n<AA;n++){\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 u = ((fragCoord+o) / iResolution.xy - 0.5) / vec2(iResolution.y / iResolution.x, 1);\n        vec3 rd = normalize(vec3(u, 1));\n        rd.yz *= xrot;\n        rd.xz *= yrot;\n        tot += render(ro, rd) / float(AA*AA);\n    }}\n\n    \n    #ifdef vignet\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n    tot *= smoothstep(1.34, 0., length(uv));\n    tot = smoothstep(.0,1.6,tot);\n    tot = pow(tot, vec4(1.,1.4,1.1,1.));\n    #endif\n    \n    // Output to screen\n    #ifdef post\n    fragColor = vec4(aces_tonemap(pow(tot.xyz\n    ,vec3(1.15)\n    )),1.);\n    #else\n    fragColor = tot;\n    #endif\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slffDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[180, 180, 198, 198, 271], [272, 290, 321, 321, 412], [414, 414, 432, 432, 1037], [1039, 1039, 1076, 1076, 1279], [1281, 1290, 1375, 1375, 1593], [1594, 1594, 1632, 1632, 1852], [1853, 1853, 1886, 1886, 2147], [2148, 2155, 2185, 2202, 3895], [3898, 3898, 3928, 3928, 4375], [4378, 4378, 4435, 4435, 5344]], "test": "untested"}
{"id": "stXfDj", "name": "Dramatic Window", "author": "Xibanya", "description": "I just think it's neat.", "tags": ["raymarch", "raymarched", "purple", "aesthetic", "vaporwave"], "likes": 22, "viewed": 612, "published": 3, "date": "1651474781", "time_retrieved": "2024-07-30T16:50:33.524985", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 texel = 1. / iResolution.xy;\n    vec2 duv = texel * vec2(-0.5, 0.5);\n    vec3 col1 = texture(iChannel0, uv + duv).rgb;\n    vec3 col2 = texture(iChannel0, uv - duv).rgb;\n    vec3 col = vec3((col1.r + col2.r) * 0.5, col1.g, col2.b) * 1.3;\n    col = pow(col, vec3(1.1));\n    \n    float n = fract(cos(\n        (sin(uv.x / texel.x) * uv.y / texel.y + iTime * 0.01)\n        * 90.) * 343.);\n\tcol = mix(col, max(col, n), 0.075);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float _XRot = 0.;\nfloat _YRot = 90.;\nfloat _XPos = 3.;\nfloat _YPos = 0.3;\nfloat _ZPos = 0.;\nfloat _FOV = 25.;\n\nconst int MARCH_STEPS = 250;\nconst int SHADOW_MARCH_STEPS = 50;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 200.0;\nconst float EPSILON = 0.0001;\n\nconst vec3 SHADOW_COLOR = vec3(0.1, 0.1, 0.2);\nconst vec3 PINK = pow(vec3(0.8, 0.3, 0.6), vec3(1.5));\nconst vec3 PURPLE = vec3(0.25, 0.1, 0.35);\nconst vec3 SKY_COLOR = pow(vec3(0.9, 0.4, 0.46), vec3(1.5));\n\nstruct Objects {\n    float main; float bg; float sphere; float ground;\n};\n\nmat3 YRotationMatrix(float degrees)\n{\n\tfloat angleY = radians(degrees);\n\tfloat c = cos(angleY);\n\tfloat s = sin(angleY);\n\tmat3 rotateYMatrix = mat3(\n        c, 0, s,\n\t\t0, 1, 0,\n\t\t-s, 0, c);\n\treturn rotateYMatrix;\n}\nmat3 XRotationMatrix(float degrees)\n{\n\tfloat angleX = radians(degrees);\n\tfloat c = cos(angleX);\n\tfloat s = sin(angleX);\n\tmat3 rotateXMatrix = mat3(\n        1, 0, 0,\n\t\t0, c, -s, \n\t\t0, s, c);\n\treturn rotateXMatrix;\n}\n\n//https://iquilezles.org/articles/distfunctions/\nfloat SDFBox(vec3 p, vec3 b) \n{\n    vec3 d = abs(p) - b;\n    vec3 v = min(d, 0.);\n    return length(max(d, 0.0)) + max(max(v.x, v.y), v.z);\n}\nfloat SDFCylinder(vec3 p, float r, float height) \n{\n    float d = length(p.xz) - r;\n    return max(d, abs(p.y) - height);\n}\nfloat SDFCapped( vec3 p, float r, float h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r, h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat SDFSphere(vec3 p, float radius) \n{\n    return length(p) - radius;\n}\nfloat SDFUnion( float sphere, float ground, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(ground-sphere)/k, 0.0, 1.0 );\n    return mix( ground, sphere, h ) - k*h*(1.0-h); \n}\nfloat SDFSub( float sphere, float ground, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(ground+sphere)/k, 0.0, 1.0 );\n    return mix( ground, -sphere, h ) + k*h*(1.0-h); \n}\nvec3 domainRepeat(vec3 p, vec3 size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\nfloat domainRepeat1D(float p, float size)\n{\n    return mod(abs(p) + size * .5, size) - size * .5;\n}\n#define PI 3.14159265\nvec2 pModPolar(vec2 p, float repetitions) \n{\n    float angle = 2.0 * PI / repetitions;\n    float a = atan(p.y, p.x) + angle * .5;\n    float r = length(p);\n\n    a = mod(a, angle) - angle * .5;\n    return vec2(cos(a), sin(a)) * r;\n}\nfloat Scene(vec3 p, out Objects o)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\tvec4 a1 = a0;\n\twsPos = ( a1.xyz * vec3(4.238,4.238,4.238)) - vec3(-.62,.081,.284);\n    vec3 spherePos = p + vec3(0.5, -0.1, 0.25);\n\tfloat sphere = SDFSphere(spherePos, 0.1);\n    o.sphere = sphere;\n\tvec4 a2 = a0;\n\twsPos = a2.xyz - vec3(.084,.0,.0);\n    vec3 groundPos = wsPos;\n\tfloat ground = SDFBox(groundPos, vec3(1.,.001,1.));\n    o.ground = ground; \n\tfloat sdf = min(sphere, ground);\n    float ceiling = SDFBox(\n        groundPos - vec3(0., 1., 0.), vec3(2., .01, 2.));\n    sdf = min(sdf, ceiling);\n    o.ground = min(o.ground, ceiling);\n\tvec4 a3 = a0;\n\tvec4 a4 = a3;\n\twsPos = a4.xyz - vec3(-.894,.232,.0);\n\tfloat d4 = SDFBox(wsPos,vec3(.08,.165,.25));\n\twsPos = (mat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, -.412, -.867, .0, 1.0) * a4).xyz;\n\td4 = min(d4,SDFCylinder(wsPos, .25,.078));\n\tvec4 a5 = (a3 * vec4(1.0,1.0,1.112,1.0));\n\twsPos = (mat4(.0, -1.0, .0, .0, 1.0, .0, .0, .0, .0, .0, 1.0, .0, -.62, -.889, .0, 1.0) * a5).xyz;\n\tfloat d5 = SDFBox(wsPos,vec3(.65,.037,1.0));\n\tfloat d3 = max(-d4,d5);\n\tsdf = min(sdf,d3);\n\tvec4 a6 = a0;\n\twsPos = a6.xyz - vec3(-.907,.4,.0);\n\tfloat d6 = SDFBox(wsPos,vec3(.005,.005,.25));\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .0, 1.0, .0, .0, -1.0, .0, .0, .907, -.1, -.36, 1.0) * a6).xyz;\n\td6 = min(d6,SDFBox(wsPos,vec3(.005,.005,.292)));\n\twsPos = (mat4(1.0, .0, .0, .0, .0, .0, 1.0, .0, .0, -1.0, .0, .0, .907, .1, -.36, 1.0) * a6).xyz;\n\td6 = min(d6,SDFBox(wsPos,vec3(.005,.005,.292)));\n\tsdf = min(sdf,d6);\n    o.main = max(max(sdf, -sphere), -ground);\n    float cyl = SDFCylinder(p + vec3(0.5, -0.1, -0.25), 0.05, 0.15);\n    o.sphere = min(o.sphere, cyl);\n    sdf = min(sdf, cyl);\n\treturn sdf;\n}\nfloat Skyline(vec3 p)\n{\n    vec3 wsPos = vec3(.0,.0,.0);\n\tvec4 a0 = vec4(p, 1.0);\n\twsPos = (mat4(\n        .936, .0, .352, .0, \n        .0, 1.0, .0, .0, \n        -.352, .0, .936, .0, \n        3.653, .081, 1.754, 1.0) * a0).xyz;\n\twsPos = domainRepeat(wsPos, vec3(2., 0., 4.));\n    float d0 = SDFBox(wsPos,vec3(.15,.77,.15));\n\twsPos = a0.xyz - vec3(-3.322,-.2,.132);\n\td0 = min(d0,SDFBox(wsPos,vec3(.18,.52,.2)));\n\twsPos = a0.xyz - vec3(-5, -.55, -.8);\n\td0 = min(d0,SDFBox(wsPos,vec3(.18,.87,.2)));\n\treturn d0;\n}\nfloat Distance(vec3 p)\n{\n    Objects o;\n    return Scene(p, o);\n}\n// https://iquilezles.org/articles/normalsSDF\nvec3 GetNormal(vec3 pos)\n{\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * EPSILON;\n    return normalize( e.xyy * Distance( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx * Distance( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy * Distance( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx * Distance( pos + e.xxx ) );\n}\nfloat March(vec3 pos, vec3 dir, out Objects o) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Scene(p, o);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\nfloat BGMarch(vec3 pos, vec3 dir) \n{\n    float depth = MIN_DIST;\n    for (int i = 0; i < MARCH_STEPS; i++) \n    {\n        vec3 p = pos + depth * dir;\n        float dist = Skyline(p);\n        if (dist < EPSILON) return depth;\n        depth += dist;\n        if (depth >= MAX_DIST) break;\n    }\n    return MAX_DIST;\n}\n// https://iquilezles.org/articles/rmshadows\nfloat Shadow( in vec3 ro, in vec3 rd)\n{\n    float mint = 0.02;\n    float tmax = 2.5;\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i< SHADOW_MARCH_STEPS; i++ )\n    {\n\t\tfloat h = Distance( ro + rd*t );\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0);\n}       \nfloat GetLight(vec3 normal, vec3 p, vec3 lightPos)\n{\n    vec3 lightDir = normalize(p - lightPos);\n    float nDotL;\n    nDotL = dot(lightDir, normal) * 0.5 + 0.5;\n    float shadow = pow(Shadow(p, lightDir), .5);\n    nDotL *= shadow;\n    float atten = smoothstep(0.5, 1.5, length(lightDir));\n    nDotL /= atten;\n    return nDotL;\n}\nvec3 RayDir(float fieldOfView, vec2 size, vec2 fragCoord) \n{\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\nvec3 Color(Objects o, vec3 p, vec3 dir, vec3 normal)\n{\n    // DIFFUSE\n    vec3 lightPos = vec3(20., -10., 0.);\n    float diffuseTerm = GetLight(normal, p, lightPos);\n    lightPos = vec3(20., -10., 5.);\n    diffuseTerm += GetLight(normal, p, lightPos) * 0.5;\n    lightPos = vec3(20., -10., -5.);\n    diffuseTerm += GetLight(normal, p, lightPos) * 0.5;\n    vec3 diffuse = mix(SHADOW_COLOR, PURPLE, diffuseTerm);\n\n    // FRESNEL\n    float fresnelTerm = 1. - max(0., dot(normal, -dir));\n    fresnelTerm = smoothstep(0.7, 0.75, fresnelTerm) * diffuseTerm;\n    fresnelTerm *= (o.main < o.ground || o.sphere < o.ground) ? 1. : 0.;\n    return diffuse + fresnelTerm * SKY_COLOR;\n}\nfloat fbm (vec2 uv)\n{\n    float freq = 0.0;\n    float total = 0.0;\n    float amplitude = 0.5;\n    \n    for(int i = 0; i < 4; i++)\n    {\n        freq += texture(iChannel0, uv).r * amplitude;\n        total += amplitude;\n        uv *= 2.0;\n        amplitude *= 0.5;\n    }\n    return freq / total;\n}\n\nvec3 ColorBG(vec2 fragCoord, vec3 p, vec3 dir)\n{\n    vec2 uv = (fragCoord * 2.-iResolution.xy)/iResolution.x;\n    uv += 0.5;\n    float mixFactor = smoothstep(0.2, 0.7, uv.y);\n    vec3 bgColor = mix(PINK, SKY_COLOR, mixFactor);\n    \n     if (iMouse.xy != vec2(0)) \n     {\n         vec2 m = (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n         p.z -= m.y * 0.05;\n     }\n    \n    float skyline = BGMarch(p, dir);\n    p = p + skyline * dir;\n    if (skyline <= MAX_DIST - EPSILON)\n    {\n        mixFactor = clamp(smoothstep(0.0, 0.7, p.y), 0., 1.);\n        vec3 buildingColor = pow(SHADOW_COLOR, vec3(2.));\n        bgColor = mix(bgColor, buildingColor, min(mixFactor, 0.7));\n    }\n    else\n    {\n        mixFactor = smoothstep(0.5, 0.75, uv.y);\n        float color1 = fbm(uv * vec2(0.05, 0.1) + \n            vec2(iTime * 1.e-3, 0.));\n        color1 = smoothstep(0.6, 0.75, color1) * mixFactor;\n        bgColor = mix(bgColor, SKY_COLOR * vec3(1.5), color1);\n    }\n\n    return bgColor;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 rot = vec2(_XRot, _YRot);\n    if (iMouse.xy != vec2(0)) \n     {\n         vec2 m = (vec2(iMouse.xy / iResolution.xy).yx * 2. - 1.);\n         rot.x += m.x * 0.5;\n         rot.y -= m.y;\n     }\n\tvec3 dir = RayDir(_FOV, iResolution.xy, fragCoord);\n    dir *= XRotationMatrix(rot.x);\n    dir = dir * YRotationMatrix(rot.y);\n    vec3 pos = vec3(_XPos, _YPos, _ZPos);\n    Objects o;\n    float dist = March(pos, dir, o);\n    if (dist > MAX_DIST - EPSILON) \n    {\n        vec2 uv = fragCoord.xy / iResolution.xy;\n        float mixFactor = smoothstep(0.2, 0.7, uv.y);\n        vec3 bgColor = ColorBG(fragCoord, pos, dir);\n        fragColor = vec4(bgColor, 0.);\n\t\treturn;\n    }\n    \n    vec3 p = pos + dist * dir;\n    vec3 normal = GetNormal(p);\n    vec3 diffuse = Color(o, p, dir, normal);\n    fragColor = vec4(diffuse, 1.0);\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXfDj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 576]], "test": "untested"}
{"id": "7tXfWj", "name": "Fork Noise Creep", "author": "isaul", "description": "Just playing around, trying to make it somewhat interactive as well\n\nfrom ", "tags": ["noise"], "likes": 0, "viewed": 197, "published": 3, "date": "1651463208", "time_retrieved": "2024-07-30T16:50:34.271988", "image_code": "/** Uses fbm / noise aparatus from iq's clouds on shadertoy, **/\n/** some digits were changed to protect the innocent **/\n\nmat3 m = mat3( 0.0,  0.8,  0.70,\n              -0.60,  0.36, -0.68,\n              -0.90, -0.19,  0.14 );\n\nfloat cubicPulse( float c, float w, float x )\n{\n    x = abs(x - c);\n    if(x > w) { return 0.0; }\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                        mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n                    mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                        mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n    return 1.0 - sqrt(res);\n}\n\nfloat fbm( vec3 p )\n{\n    float f;    \n    f  = 0.5000*noise( p ); p = m*p*3.02;\n    f += 0.200*noise( p ); p = m*p*1.0130;\n    f += 0.0275*noise( p ); p = m*p*2.02;\n    f += 0.00513*noise(p * 2.00);\n    return f;\n}\n\nfloat iat(in vec2 q) {\n  return fbm(vec3(q + .2 * vec2(iTime, iTime), 0.));\n}\n\nvec2 normz(vec2 x) {\n\treturn x == vec2(1.0) ? vec2(0.0) : normalize(x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord.xy / iResolution.x;\n  \n  if (iMouse.z > 0.0) {\n    \tvec2 d = (fragCoord.xy - iMouse.xy) / iResolution.x;\n        vec2 m = 0.05 * normz(d) * exp(-length(d) / 0.1);\n        \n        q.xy += m;\n  }\n\n  vec2 n = q + vec2(0.0, 0.001);\n  vec2 e = q + vec2(0.001, 0.0);\n\n  float i  = iat(q * 15.0);\n  float ni = iat(n * (15.0 * i));\n  float ei = iat(e * 15.0);\n  \n  vec3 no = (normalize(vec3( (ni - ei), (ei - ni), sqrt((ei - ni)*(ei - ni) + (ni - ei)*(ni - ei)))));\n  float dif = 1.2 * dot( no, normalize(vec3(-0.13, 0.8, .97)));\n  vec3 col = vec3(0.1,0.1,tan(i*e)) / 0.3;\n  col *= dif;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7tXfWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[229, 229, 276, 276, 374], [376, 376, 399, 399, 438], [440, 440, 466, 466, 882], [884, 884, 905, 905, 1099], [1101, 1101, 1123, 1123, 1178], [1180, 1180, 1200, 1200, 1253], [1255, 1255, 1312, 1312, 1945]], "test": "untested"}
{"id": "NtXBD2", "name": "Simple Toon (Quantize - Edges)", "author": "TheKraai", "description": "My first shader :D\n\nEdge detection: Sobel operator\n\nQuantize brightness: based on https://lettier.github.io/3d-game-shaders-for-beginners/posterization.html", "tags": ["toon"], "likes": 0, "viewed": 270, "published": 3, "date": "1651448478", "time_retrieved": "2024-07-30T16:50:35.012009", "image_code": "const int levels = 5;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    \n    \n    // EDGE DETECTION\n\n    vec4 edge_x;\n    vec4 edge_y;\n\n    for (int dx = -1; dx <= 1; dx++) {\n    for (int dy = -1; dy <= 1; dy++) {\n        vec2 uv = (fragCoord + vec2(dx,dy)) / iResolution.xy;\n        \n        vec4 pixel = texture(iChannel0, uv);\n                \n        edge_x += float(dx + dx * abs(dy)) * pixel;\n        edge_y += float(dy + dy * abs(dx)) * pixel;\n    }\n    }\n    \n    float edge_x_max = max(edge_x.r, max(edge_x.g, edge_x.b));\n    float edge_y_max = max(edge_y.r, max(edge_y.g, edge_y.b));\n    \n    float edge = edge_x_max * edge_x_max + edge_y_max * edge_y_max;\n    edge = smoothstep(.04,.09,edge);\n    // result: mostly black, but white along edges\n    \n    \n    \n    // BRIGHTNESS QUANTIZATION\n    \n    vec4 pixel = texture(iChannel0, uv);\n    float grey = max(pixel.r, max(pixel.g, pixel.b));\n    float factor = ceil(grey * float(levels)) / float(levels);\n    vec3 color = pixel.rgb * factor;\n\n\n\n    // PUTTING IT ALL TOGETHER\n\n    fragColor = vec4(color - edge, 1.);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtXBD2.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 81, 81, 1138]], "test": "untested"}
{"id": "NlfBWj", "name": "Voxel Sphere", "author": "Spi3lot", "description": "Sphere of Voxels", "tags": ["cube", "sphere", "voxel", "circle", "effect", "moire", "minecraft", "normal", "henry", "segerman"], "likes": 9, "viewed": 419, "published": 3, "date": "1651444310", "time_retrieved": "2024-07-30T16:50:35.791924", "image_code": "// Inspired by Henry Segerman (henryseg): https://www.shadertoy.com/view/7ds3zB\n\n\n/* Implementation using ray marching - work in progress */\n\n#define EPSILON 0.001\n#define MAX_STEPS 250\n#define MAX_DISTANCE 2.0 * DISTANCE\n\n#define DISTANCE (2.0 + iTime * 2.0)\n#define ZOOM 1.25\n//#define ROTATE\n\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdClosestCube(vec3 p)\n{\n    vec3 distances = abs(p - round(p));\n    return min(min(distances.x, distances.y), distances.z);\n}\n\n/* Now implemented in RayMarch() * /\nfloat GetDist(vec3 p)\n{\n    \n    \n    float minDist = 1e20;\n    \n    float cube = sdClosestCube(p);\n    float sphere = sdSphere(trunc(p), iTime);\n    \n    //if (sphere < sqrt(3.0))\n    if (sphere < EPSILON)\n        minDist = -cube;  // Negative so that we exit the sphere\n    else\n        minDist = sphere;\n    \n    return minDist;\n}\n/* */\n\nvec3 GetNormal(vec3 dpdx, vec3 dpdy)\n{\n    return normalize(cross(dpdx, dpdy));\n    //return normalize(cross(dFdx(p), dFdy(p)));\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n    // ALGORITHM:\n    //     RETURN THE INTERSECTION OF A SPHERE AND THE ADJACENT AND (TO THE CAMERA)\n    //     CLOSEST CUBE (ON AN INFINITE LATTICE OF CUBES) THAT IS\n    //     ENTIRELY CONTAINED INSIDE THE SPHERE\n\n    float dO = 0.0;\n    bool touchedSphere = false;\n\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * dO;\n        float dS;\n        \n        // touchedSphere does not change anything... how???\n        if (touchedSphere) {\n            // Negative so that we exit the sphere\n            dS = -sdClosestCube(p);\n        } else {\n            dS = sdSphere(trunc(p), iTime);\n            \n            if (dS <= EPSILON)  {\n                touchedSphere = true;\n                \n                // sdClosestCube(p) is negated so that we exit the sphere\n                // If my distance function would work properly, the sign would not make\n                // a lot of difference.\n                // Positive would mean that we are rendering the (visible) cubes that are\n                // entirely inside the sphere.\n                // Negative would mean that we are rendering the (visible) cubes that are just\n                // one unit away from the sphere, which would be the border of the sphere.\n                \n                // I actually want to render the cubes that are contained inside the\n                // sphere, but with my current implementation of the distance function\n                // only this (negated sign -> the border of the sphere) works.\n                dS = -sdClosestCube(p); \n            }\n        }\n\n        dO += dS;\n        if (abs(dS) <= EPSILON || dO > MAX_DISTANCE) break;\n    }\n\n    return dO;\n}\n\nvec4 intersection(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n    \n    vec3 ro = vec3(DISTANCE);\n\n#ifdef ROTATE\n    ro *= vec3(cos(iTime), 1, sin(iTime));\n#endif\n\n    vec3 lookAt = vec3(0,0,0),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i - ro);\n    \n    float d = RayMarch(ro, rd);\n    vec3 p = ro + rd * d;\n    \n    return vec4(p, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = intersection(fragCoord);\n    vec4 px = intersection(fragCoord + vec2(1,0));\n    vec4 py = intersection(fragCoord + vec2(0,1));\n\n    // Background\n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    if (p.w <= MAX_DISTANCE && px.w <= MAX_DISTANCE && py.w <= MAX_DISTANCE)\n    {\n        vec3 dpdx = px.xyz - p.xyz;\n        vec3 dpdy = py.xyz - p.xyz;\n    \n        vec3 n = GetNormal(dpdx, dpdy);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}\n\n/* */\n\n\n/* Implementation using ray tracing - does not work propely * /\n\n#define ZOOM 1.5\n\n\nvec3 GetNormal(vec3 p)\n{\n    vec3 difference = abs(p - round(p));\n    float closest = min(min(difference.x, difference.y), difference.z);\n    \n    if (closest == difference.x)\n        return sign(difference.x) * vec3(1,0,0);\n        \n    else if (closest == difference.y)\n        return sign(difference.y) * vec3(0,1,0);\n        \n    else if (closest == difference.z)\n        return sign(difference.z) * vec3(0,0,1);\n    \n    return vec3(0);\n    //return normalize(cross(dpdx, dpdy));\n    //return normalize(cross(dFdx(p), dFdy(p)));\n}\n\n\n// https://iquilezles.org/articles/intersectors/\nfloat sphIntersect( in vec3 ro, in vec3 rd, in vec3 ce, float ra )\n{\n    vec3 oc = ro - ce;\n    float b = dot( oc, rd );\n    float c = dot( oc, oc ) - ra*ra;\n    float h = b*b - c;\n    if( h<0.0 ) return -1.0; // no intersection\n    return -b - sqrt(h);\n}\n\n\nvec4 intersection(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - iResolution.xy * 0.5) / min(iResolution.x, iResolution.y);\n\n    vec3 ro = vec3(DISTANCE);\n    vec3 lookAt = vec3(0,0,0),\n         f = normalize(lookAt - ro),\n         r = normalize(cross(f, vec3(0,1,0))),\n         u = cross(r, f),\n         c = ro + f * ZOOM,\n         i = c + uv.x * r + uv.y * u,\n         rd = normalize(i - ro);\n    \n    float d = sphIntersect(ro, rd, lookAt, iTime);\n    vec3 p = ro + rd * d;\n    \n    return vec4(p, d);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 p = intersection(fragCoord);\n\n    // Background\n    fragColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    if (p.w > 0.0)\n    {\n        vec3 n = GetNormal(p.xyz);\n        fragColor = vec4(abs(n), 1.0);\n    }\n}\n\n/* */", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NlfBWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 297, 330, 330, 358], [360, 360, 389, 389, 491], [871, 871, 909, 909, 1001], [1004, 1004, 1038, 1254, 2712], [2714, 2714, 2749, 2749, 3269], [3272, 3272, 3329, 3329, 3778]], "test": "untested"}
{"id": "flffzs", "name": "Soothing Movement II", "author": "byt3_m3chanic", "description": "Daily shading - Playing around more with just motion and ended up here / Mac folks - I have an issues - see comments.. blah! ", "tags": ["raymarching", "domain", "repetition", "balls", "looping"], "likes": 22, "viewed": 329, "published": 3, "date": "1651437572", "time_retrieved": "2024-07-30T16:50:36.531945", "image_code": "/** \n    License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n    Soothing Motion II\n    05/01/22 | byt3_m3chanic\n\n    Daily shading - Playing around more with just motion and ended up here. \n    The balls are an illusion with the ID's rolling up 1 in the y while the\n    animation loops in place as you move over the scene.\n    \n    \n*/\n\n#define R           iResolution\n#define T           iTime\n#define M           iMouse\n\n#define MIN_DIST    .0001\n#define MAX_DIST    75.\n\n#define PI          3.1415926\n#define PI2         6.2831853\n\n//global\nvec3 FC = vec3(0.596,0.812,0.941);\nvec3 hp=vec3(0),hitPoint=vec3(0);\nvec2 gid=vec2(0), sid=vec2(0);\nfloat glow;\nfloat zoom = 10.;\nfloat maptime,time,fractTime,modTime,iss;\nmat2 crt1,crt2;\n\n//constants\nconst float space = 9.5;\nconst float hlf = space/2.;\nconst float dbl = space*2.;\nconst vec3 bsize = vec3(3,5,3);\nconst vec3 wsize = vec3(1,2,1.65);\n    \nconst float c = 1.5;\nconst float c2=c/2.;\n    \n// Helper functions for building smin stairs\n// http://mercury.sexy/hg_sdf/\nfloat fOpUnionStairs(float a, float b, float r, float n) {\n\tfloat s = r/n, u = b-r;\n\treturn min(min(a,b), 0.5 * (u + a + abs ((mod (u - a + s, 2. * s)) - s)));\n}\nfloat fOpDifferenceStairs(float a, float b, float r, float n) {return -fOpUnionStairs(-a, b, r, n);}\n\nfloat hash21( vec2 p ) {return fract(sin(dot(p,vec2(23.43,84.21)))*4832.3234);}\n\nmat2 rot(float a){ return mat2(cos(a),sin(a),-sin(a),cos(a)); }\n\n//@Dave_Hoskins \n//https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p){\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//@iq for all the SDF's\nfloat box( vec3 p, vec3 b ) {\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cyl(vec3 p, float r, float h) {\n\tfloat d =length(p.xy)-r;\n\treturn max(d,abs(p.z)-h);\n}\n\nvec2 map(vec3 p, float sg) {\n\tvec2 res = vec2(1e5,0);\n    vec3 q = p-vec3(0,-1.25,maptime);\n    vec3 r = q;\n    \n    float flr = q.y;\n    if(flr<res.x) {\n        res = vec2(flr,1.);\n        hp=q;\n    }\n    \n    float qd = floor((q.z+hlf)/space);\n    q.z=mod(q.z+hlf,space)-hlf;\n\n    float pole = min(cyl(q.zxy-vec3(4,5,0),.045,4.),length(q-vec3(5,4,4))-.1 );\n    if(pole<res.x) {\n        res = vec2(pole,3.);\n        hp=q;\n    }\n    \n    vec3 nq=q;\n    float wave = .5*sin(nq.z*2.35+maptime);\n    float flo = clamp(2.-(nq.z*.5),0.,1.);\n    wave = mix(0.,wave,flo);\n    nq.x+=wave;\n    \n    float flag = box(nq-vec3(5,3.35,3),vec3(.03,.5,1));\n    if(flag<res.x) {\n        res = vec2(flag,6.);\n        hp=nq;\n        gid=vec2(qd,1.);\n    }\n\n    q.x = abs(q.x)-bsize.x;\n\n    float wall = box(q,vec3(.25,bsize.y,bsize.z));\n    float roof = box(q-vec3(-(bsize.x-.25),bsize.y-.5,0.),vec3(3.,.1,bsize.z));\n    \n    vec3 q2 = q, q3 = q;\n    \n    q2.z = abs(q2.z)+.6;\n    float window = box(q2-vec3(0,wsize.y/2.,0),vec3(.4,wsize.x,wsize.z));\n    window=min(cyl(q2.zyx-vec3(0,wsize.y,0.),wsize.z,.4),window);\n    wall = min(box(q2-vec3(.3,bsize.y/2.,bsize.z),vec3(.1,bsize.y/2.,.05)),wall);\n\n    float lits = length(q2-vec3(.575,4.65,2.5))-.05;\n    if (lits<res.x && sg==1.) {\n        res = vec2(lits,4.);\n    \tglow += .0005/(.000025+lits*lits);\n    }\n\n    float qi = floor((q3.z + c2)/c);\n    q3.z = q3.z-c*clamp(round(q3.z/c),-2.,2.);\n    float tip1 = box(q3-vec3(-.1,bsize.y,0),vec3(.08,.45,.5));\n\n    float tip=min(cyl(q2.zyx-vec3(0,bsize.y,-.1),1.,.08),tip1);\n    roof = min(tip,roof);\n    \n    float mainwall = fOpDifferenceStairs(wall,window,.25,3.);\n    float building = fOpUnionStairs(mainwall,roof,.25,3.);\n\n    if(building<res.x) {\n        res = vec2(building,2.);\n        hp=q3;\n        gid=vec2((tip1>res.x)?qd:qd-.5,1.);\n    }\n    \n    vec2 id = vec2(\n        floor((r.x+space)/dbl),\n        floor((r.z+hlf)/space)\n        );\n        \n    float hs,fs;\n    if(modTime<2.){\n      \ths = hash21(id.yy);\n        r.x += (hs<.5) ? fractTime : -fractTime; \n    } else {\n        r.z += -fractTime;\n    }\n    \n    id = vec2(floor((r.x+space)/dbl),floor((r.z+hlf)/space));\n    id.y-=iss;\n    r.xz=vec2(mod(r.x+space,dbl)-space,mod(r.z+hlf,space)-hlf);\n    r-=vec3(0,1,0);\n    \n    if(modTime<2.){\n        r.xy*= (hs<.5) ? crt1 :  crt2 ;\n    } else {\n        r.zy*= crt2 ;\n    }\n    \n    float ball = length(r)-.9;\n    if(ball<res.x) {\n        res = vec2(ball,5.);\n        hp=r;\n        gid=vec2(id);\n    }\n    return res;\n}\n\nvec3 normal(vec3 p, float t) {\n    t*=MIN_DIST;\n    float d = map(p,0.).x;\n    vec2 e = vec2(t,0);\n    vec3 n = d - vec3(\n        map(p-e.xyy,0.).x,\n        map(p-e.yxy,0.).x,\n        map(p-e.yyx,0.).x\n    );\n    return normalize(n);\n}\n\nvec2 marcher(vec3 ro, vec3 rd, inout vec3 p, inout bool hit, int steps) {\n    hit = false; float d=0., m = 0.;\n    for(int i=0;i<steps;i++) {\n        p = ro + rd * d;\n        vec2 t = map(p,1.);\n        if(abs(t.x)<d*MIN_DIST) hit = true;\n        d += i<32? t.x*.5:t.x;\n        m  = t.y;\n        if(d>MAX_DIST) break;\n    } \n    return vec2(d,m);\n}\n\nvec3 hue(float t) { \n    vec3 d = vec3(0.929,0.690,0.027);\n    return .45+.4*cos( PI2*t*vec3(0.984,0.914,0.914)+d ); \n}\n\nvec3 render(inout vec3 ro, inout vec3 rd, inout vec3 ref, int bnc, inout float d, vec2 F) {\n        \n    vec3 C=vec3(0);\n    vec3 p = ro;\n    float m = 0.;\n    bool hit = false;\n    \n    vec2 ray = marcher(ro,rd,p,hit,80);\n    d = ray.x;\n    m = ray.y;\n    hitPoint = hp;\n    sid=gid;\n    if(hit) {\n  \n        vec3 n = normal(p,d);\n        vec3 lpos = vec3(5.5,8,8.5);\n        vec3 l = normalize(lpos);\n        float diff = clamp(dot(n,l),0.,1.);\n       \n        float shdw = 1.;\n        for( float t=.01;t<18.; ) {\n            float h = map(p + l*t,0.).x;\n            if( h<MIN_DIST ) { shdw = .001; break; }\n            shdw = min(shdw, 14.*h/t);\n            t += h;\n            if( shdw<MIN_DIST || t>18. ) break;\n        }\n        diff = mix(diff,diff*shdw,.35);\n\n        vec3 ret = reflect(normalize(lpos),n);\n        float spec = .75 * pow(max(dot(normalize(p-ro),ret),0.),24.);\n        vec3 h = vec3(.25);\n\n        if(m==1.) {\n            vec2 f = hitPoint.xz;\n            h=FC;\n            \n            if(abs(f.x)<4.5) {\n                h=vec3(.5);\n                vec2 ff=fract(hitPoint.xz*.77)-.5;\n                if(ff.x*ff.y>0.)h=vec3(.2);\n            }\n            \n            if(abs(f.x)>4.5&&abs(f.x)<5.5) h=vec3(.15);\n\n            ref = h*.3;\n        }\n        \n        if(m==2.||m==6.) {\n            h=hue(hash21(sid+m)*.982);\n            ref = h*.3;\n        }\n        \n        if(m==5.) {\n            hitPoint.xy *= rot(1.5707);\n            vec3 f = fract(hitPoint*2.)-.5;\n            f.x=abs(f.x)-.2;\n            h=mod(sid.y,2.)<1. ? vec3(.01):vec3(.9);\n            ref=vec3(.1);\n            if(f.x*1.>0.) {h=hue(hash21(vec2(sid.y,25.))*3.13);  ref = h;}\n           \n        }\n        \n        if(m==6.) {\n            vec2 f = fract(hitPoint.zy*3.5)-.5;\n            h=vec3(.009);\n            if(f.x*f.y>0.)h=hue(hash21(sid+12.)*3.5);\n            ref = h;\n        }\n        \n        C = (m!=2.) ? h * diff + min(shdw,spec):h * diff;\n        C = mix(C,vec3(.90,.49,.82)*vec3(glow*1.15),clamp(.0,1.,glow)); \n        //if(bnc<2) C = mix(C,FC, 1.-exp(-.001*d*d*d));//slows down some\n        ro = p+n*.1;\n        rd = reflect(rd,n);\n        \n    } else {\n        C=FC;\n    }\n\n    return clamp(C,vec3(.0001),vec3(1));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 F) { \n    vec3 col = vec3(.00);\n    //precal\n    time = T*.5; \n    float ms = 3.;\n    float mt = 1./ms;\n    modTime = mod(time,ms);\n    //time for ids\n    float os = floor(modTime);\n    //weird bug - IOS needs +1 to make work\n    //float ios = floor(time+1.);\n    float ios = floor(time);\n    iss = floor(ios*mt)-1.;\n\n    fractTime = modTime<2.? (fract(time) * (space))+(space*os) : fract(time) * (space);\n    maptime = time*5.;\n    //ball rotations\n    crt1 = rot(modTime*PI2);\n    crt2 = rot(-modTime*PI2);\n    \n    vec2 uv = (-R.xy + 2. * (F)) / R.x;\n    \n    // mouse //\n    float x = M.xy==vec2(0) ? 0. : -(M.y/R.y*4.-2.)*PI;\n    float y = M.xy==vec2(0) ? 0. : -(M.x/R.x*2.-1.)*PI;\n    zoom+=x;\n    // ro + rd\n    vec3 ro = vec3(uv*zoom,-zoom-15.);\n    vec3 rd = vec3(0,0,1.);\n    \n    FC=hue((uv.y+125.)*.25);\n    \n    mat2 rx =rot(.425);\n    mat2 ry =rot(-.98+y);\n    ro.zy*=rx;rd.zy*=rx;\n    ro.xz*=ry;rd.xz*=ry;\n\n    vec3 C=vec3(0), RC=vec3(0), ref=vec3(0), fill=vec3(1);\n    vec3 p = ro;\n    float m = 0., d = 0., fA = 0.;\n\n    int bnc = 2;\n    for(int i = 0; i < bnc; i++){\n        RC = render(ro,rd,ref,bnc-i,d,F);\n        C += RC*fill;\n        fill *= ref; \n        if(i==0) fA += d*.2;\n    }\n\n    C = mix(C,FC, 1.-exp(-.002*fA*fA*fA));\n    clamp(C,vec3(0),vec3(1));\n    C = pow( C, vec3(0.4545) );\n\n    fragColor = vec4(C, 0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/flffzs.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[979, 1055, 1113, 1113, 1216], [1217, 1217, 1280, 1280, 1317], [1319, 1319, 1343, 1343, 1398], [1400, 1400, 1418, 1418, 1463], [1465, 1522, 1543, 1543, 1660], [1662, 1686, 1715, 1715, 1806], [1808, 1808, 1845, 1845, 1900], [1902, 1902, 1930, 1930, 4418], [4420, 4420, 4450, 4450, 4655], [4657, 4657, 4730, 4730, 5005], [5007, 5007, 5026, 5026, 5126], [5128, 5128, 5219, 5219, 7361], [7363, 7363, 7410, 7410, 8748]], "test": "untested"}
{"id": "slsfWB", "name": "Myopia", "author": "TrExTeSt", "description": "Control how much you need glasses using the horizontal position of your mouse :P\nDon't know how that effect is called. Looks like a soft blur, like a bloom effect maybe.\nGot inspired by Neyret's mipmap tricks.", "tags": ["blur", "mipmap"], "likes": 3, "viewed": 435, "published": 3, "date": "1651428208", "time_retrieved": "2024-07-30T16:50:37.270969", "image_code": "vec4 mixLod(sampler2D tex, vec2 uv, float lod, float lod_step){\n    float counter = 0.0;\n    float times = 1.0;\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    while(counter < lod){\n        col = mix(col, textureLod(tex, uv, counter).rgb, 1.0 / times);\n        counter += lod_step;\n        times += 1.0;\n    }\n    return vec4(col, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = fragCoord / iResolution.xy;\n    float control = ((1.0 - (iMouse.x / iResolution.x))*5.0) + 0.1;\n    \n    fragColor = mixLod(iChannel0, uv, control, .5);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slsfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 330], [332, 332, 387, 387, 556]], "test": "untested"}
{"id": "stlBWB", "name": "30 Minutes 4/16", "author": "scry", "description": "30 Second timelapse:\nhttps://youtube.com/shorts/ffZjn80hv8c", "tags": ["3d", "trippy", "reflective"], "likes": 6, "viewed": 288, "published": 3, "date": "1651424371", "time_retrieved": "2024-07-30T16:50:38.009993", "image_code": "#define time iTime*0.1\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nvec3 isor(vec3 p) {\n    p.yz *= r2d(deg*35.265);\n    p.xz *= r2d(deg*45.);\n    return p;\n}\n\n//from https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [01], including hue.\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\n//#define dtime time*hill(time,10.)\nfloat bitm(vec2 uv,int c) {\n    float h = 5.;\n    float w = 3.;\n    int p = int(pow(2.,w));\n    float line1 = 9591.;\n    uv = floor(vec2(uv.x*w,uv.y*h))/vec2(w,w);\n    float c1 = 0.;\n    float cc = uv.x + uv.y*w;\n    c1 = mod( floor( float(c) / exp2(ceil(cc*w-0.6))) ,2.);\n    c1 *= step(0.,uv.x)*step(0.,uv.y);\n    c1 *= step(0.,(-uv.x+0.99))*step(0.,(-uv.y+1.6));\n    return (c1);\n}\n \n\nvec3 slogo(vec2 uv, float ar, float size) {\n    vec2 px = vec2(1./3.,1./5.);\n    float ls = 4.1;\n    uv.x = 0.993-uv.x;\n    uv *= 8.*ls*(1./size);\n    ls += 2.;\n    float ul = length(uv);\n    uv -= px.yx*0.5*0.5*ls;\n    ul = length(vec2(uv.x*0.5,uv.y)-0.5);\n    uv.x *= ar*1.75;\n    int s = 29671;\n    int c = 29263;\n    int r = 31469;\n    int y = 23186;\n    uv.x= 5.-uv.x;\n    float b = bitm(uv,s);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,c);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,r);\n    uv.x -= 1./3.*4.;\n    b += bitm(uv,y);\n    float rr = step(0.,uv.x+px.x*13.)*step(0.,uv.y+px.y)*step(0.,(-uv.x+px.x*4.))*step(0.,(-uv.y+px.y*6.));\n    b = clamp(b,0.,1.);\n    //b = rr*floor(b);\n    //float ptime = iTime;\n    vec3 l = hsv2rgb(vec3(b+iTime/40.,0.1,rr-b*1.9))*rr;\n    //l -= length(uv)*0.5;\n    //l -= ul*rr*0.6;\n    l -= 0.1-clamp(ul*0.1,rr*1.-b,0.1);\n    //l -= 3.-ul*2;\n    //l = clamp(l,-1.,1.);\n    return vec3(l);\n}\n\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.z -= 1.;\n    p.yz *= r2d(deg*35.265*sin(time));\n    p.xz *= r2d(deg*45.+time);\n    vec3 ob = isor(p);\n    float d = -sdBox(p,vec3(1.01));\n    d = min(d,sdBox(ob,vec3(0.01)));\n    //p.xz *= r2d(deg*45.);\n    p.xz = abs(p.xz);\n    p.xz *= r2d(deg*45.);\n    p.xy *= r2d(deg*45.);\n    p.xy = -abs(p.xy)+0.75;\n    p.xy *= r2d(-deg*45.);\n    p.xyz -= 0.5;\n    float pf = 3.;\n    p = (fract(p*pf)-0.5)/pf;\n    p.y = abs(p.y);\n    p.xz = abs(p.xz);\n    p.xz *= r2d(deg*45.);\n    p.xy *= r2d(deg*20.);\n    \n    p.x += 0.15;\n    d = min(d,max(sdBox(p,vec3(mix(0.15,0.2,sin(ob.y*4.+time)*0.5+0.5))),-(length(o.z)-0.075)));\n    //d = max(d,-(length(o.z)-0.075));\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<120;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii *= 0.01;\n        if (dO > 100. || dS < 0.001) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3(\n        map(p+h.xyy).w-map(p-h.xyy).w,\n        map(p+h.yxy).w-map(p-h.yxy).w,\n        map(p+h.yyx).w-map(p-h.yyx).w\n    ));\n}\n\nvec3 colo(vec3 p, vec3 n, vec2 d) {\n    //vec3 col = sin(n+d.y*20.);\n    vec3 col = 1.-d.xxx*0.6;\n    col *= sin(vec3(0.3,0.36,0.5)*d.x*5.+vec3(0.3,0.8,0.1)*d.y*200.);\n    return clamp(col,0.,1.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    vec2 tv = uv;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    float c = length(uv);\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    float rl = 0.99;\n    //col += d.xxx/5.;\n    //col = n;\n    col += colo(p,n,d);\n    for (int i=0;i<9;i++) {\n        ro = p+n*0.003;\n        rd = reflect(rd,n);\n        d = RM(ro,rd);\n        p = ro+rd*d.x;\n        n = calcNorm(p);\n        col += colo(p,n,d)*rl;\n        rl *= rl;\n    }\n    col *= 0.4;\n    col -= 0.2;\n    //col *= rl+0.5;\n    \n    //col -= sin(c*1400.)*0.06;\n    col += slogo(tv,ar,1.)/40.;\n    //col -= sin(d.x*35200.)*0.05;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stlBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 134], [136, 136, 165, 165, 228], [230, 230, 249, 249, 320], [322, 464, 486, 486, 817], [822, 881, 903, 903, 1072], [1075, 1111, 1138, 1138, 1495], [1499, 1499, 1542, 1542, 2424], [2427, 2427, 2445, 2445, 3142], [3144, 3144, 3171, 3171, 3411], [3413, 3413, 3436, 3436, 3618], [3620, 3620, 3655, 3688, 3818], [3820, 3820, 3875, 3875, 4688]], "test": "untested"}
{"id": "stsfDS", "name": "30 Minutes 4/9", "author": "scry", "description": "30 Second timelapse:\nhttps://youtube.com/shorts/DyK-aycdLu8", "tags": ["2d", "kifs", "trippy"], "likes": 3, "viewed": 261, "published": 3, "date": "1651423999", "time_retrieved": "2024-07-30T16:50:38.826810", "image_code": "#define pi 3.14159265\n#define time iTime*0.1\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat line(vec2 uv,vec2 s) {\n    return smoothstep(max(abs(uv.x)-s.y,abs(uv.y)-s.x),0.,0.001);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    float c = length(uv);\n    vec3 col = vec3(1.);\n    float a = 1.-exp(-1.*time);\n    a -= c*0.2;\n    uv *= 0.4*(1.-exp(-0.3*time-0.1));\n    for (int i=0;i<31;i++) {\n        if (i > int(time*20.-log(c)*0.2)) {break;}\n        col *= line(uv,vec2(0.01,0.01));\n        uv = abs(uv);\n        uv.x -= 0.02*a;\n        uv.y -= 0.05*a;\n        a *= 0.96;\n        uv *= r2d(time/2.+sin(time*0.3)*0.6);\n    }//uv *= r2d(col.r*0.1);\n    //col *= 0.;\n    col *= 0.4;\n    col += 0.004;\n    col += sin(col*vec3(0.1,0.2,0.3)*20.)*0.8;\n    col += sin(col*vec3(0.5,0.2,0.45)*12./c*0.1)*0.4;\n    col += sin(col*70.+c*60.-time*10.)*0.01;\n    col += sin(col*100.+c*86.-time*5.)*0.003;\n    //col += line(uv,vec2(0.01,0.01));\n    //col += fract(col*2.-time)*2.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stsfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 134], [136, 136, 164, 164, 232], [234, 234, 289, 289, 1192]], "test": "untested"}
{"id": "7llfDS", "name": "30 Minutes 4/4", "author": "scry", "description": "30 Second timelapse:\nhttps://youtube.com/shorts/XJlf49QrPNc", "tags": ["3d", "normal"], "likes": 4, "viewed": 186, "published": 3, "date": "1651423885", "time_retrieved": "2024-07-30T16:50:39.562842", "image_code": "#define time iTime*0.1\n#define pi 3.14159265\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    return max(abs(p.z)-s.z,max(abs(p.x)-s.x,abs(p.y)-s.y));\n}\n\nvec4 map(vec3 p) {\n    vec3 o = p;\n    p.y += 1.;\n    p.yz *= r2d(-0.5);\n    p.z -= 2.2;\n    p.xz *= r2d(time);\n    float d = p.y+1.;\n    float s = 3.;\n    float sd = 0.255;\n    //d = 100.;\n    p.y += s*1.2;\n    for (int i=0;i<20;i++) {\n        p.xz *= r2d(time*0.1+float(i)*0.01);\n        d = min(d,sdBox(p,vec3(s)));\n        s *= 0.73;\n        p.y -= s*0.5;\n    }\n    //d = min(d,sdBox(p,vec3(s)));\n    return vec4(p,d);\n}\n\nvec2 RM(vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<33;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = map(p).w;\n        dO += dS;\n        ii += 0.01;\n        if (dS < 0.001 || dO > 100.) {break;}\n    }\n    return vec2(dO,ii);\n}\n\nvec3 calcNorm(vec3 p) {\n    vec2 h = vec2(0.001,0.);\n    return normalize(vec3( map(p-h.xyy).w-map(p+h.xyy).w,\n                           map(p-h.yxy).w-map(p+h.yxy).w,\n                           map(p-h.yyx).w-map(p+h.yyx).w ));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec3 col = vec3(0.);\n    vec3 ro = vec3(0.);\n    vec3 rd = normalize(vec3(uv,1.));\n    vec2 d = RM(ro,rd);\n    vec3 p = ro+rd*d.x;\n    vec3 n = calcNorm(p);\n    col += d.xxx/10.;\n    col -= n/10.;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/7llfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 85, 85, 134], [136, 136, 165, 165, 228], [230, 230, 248, 248, 654], [656, 656, 683, 683, 922], [924, 924, 947, 947, 1155], [1157, 1157, 1212, 1212, 1575]], "test": "untested"}
{"id": "sllfDS", "name": "30 Minutes 4/6", "author": "scry", "description": "30 second timelapse:\nhttps://www.youtube.com/shorts/tGJ05wPXr7M", "tags": ["2d", "trippy"], "likes": 5, "viewed": 273, "published": 3, "date": "1651423750", "time_retrieved": "2024-07-30T16:50:40.363700", "image_code": "#define pi 3.14159\n#define time iTime*1.\n#define deg pi/180.\n\nmat2 r2d(float a) {\n    return mat2(cos(a),sin(a),-sin(a),cos(a));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 tv = uv;\n    vec2 R = iResolution.xy;\n    float ar = R.x/R.y;\n    uv -= 0.5;\n    uv.x *= ar;\n    vec2 ov = uv;\n    vec3 col = vec3(uv,0.);\n    float b = max(abs(ov.x),abs(ov.y));\n    float r = (sin(time*0.25)*0.5+0.5)*100.;\n    b = floor(b*r)*0.4;\n    //for (int i=0;i<3;i++) {\n        //b = step(-b,-0.45)+0.01;\n    //}\n    float c = length(uv);\n    uv *= r2d(-time/4.-c*0.7+1.+(b));\n    uv.x += uv.y;\n    uv *= r2d(time/4.+c*0.7);\n    float m = 2.;\n    for (int i=0;i<8;i++) {\n        col += sin(uv.x*700.)*sin(uv.y*8.+time)*m;\n        col += sin(uv.x*501.-time*10.+uv.y*600.)*sin(uv.y*2.+time)*m;\n        uv *= r2d(pi+ov.y*0.001-time*0.001+c*0.01);\n        uv *= 0.75;\n        //uv *= sin(ov.y*pi*2.+time/5.)*0.5+0.5;\n        m *= sin(time*1.+ov.x*pi);\n        col = sin(col+0.5+ov.y*pi+time+ov.x*5.);\n        //m *= sin(uv.x*pi*2.-time/5.)*0.5+0.5;\n    }\n    col.rb *= r2d(time+uv.y*3.);\n    col.gb *= r2d(time+ov.x);\n    col = sin(col+time+uv.x*32.)*0.5+0.5;\n    col *= 1.5;\n    col -= 0.5;\n    //col *= 0.1;\n    //col += \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/sllfDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[62, 62, 81, 81, 130], [133, 133, 188, 188, 1303]], "test": "untested"}
{"id": "NtlfWB", "name": "Water Shader - Gradient Noise", "author": "rge15", "description": "A shader simulating some water, training with some Gradient Noise. ", "tags": ["noise", "water", "gradient"], "likes": 3, "viewed": 244, "published": 3, "date": "1651409763", "time_retrieved": "2024-07-30T16:50:41.167551", "image_code": "#define PI 3.141592653589793238\n\n\nvec2 hash2D( vec2 p )\n{\n    p = 50. * fract(p/PI);\n    p = fract(p * vec2(p.y, p.x) + vec2(0.43,0.452));\n    \n    p = vec2(dot( p , vec2(0.83,0.69)), dot( p , vec2(0.64,0.18)));\n    return -1. + 2. * fract(sin(p) * 4573.98203 + p.x*p.y/(p.x+p.y));\n}\n\nfloat gradientNoise( vec2 p )\n{ \n    vec2 i = floor(p);\n    vec2 f = fract(p);\n\n\n    vec2 func = f*f*(3. - 2.*f);\n    \n    vec2 a = hash2D( i + vec2(0.,0.)) ;\n    vec2 b = hash2D( i + vec2(1.,0.)) ;\n    vec2 c = hash2D( i + vec2(0.,1.)) ;\n    vec2 d = hash2D( i + vec2(1.,1.)) ;\n\n    float ga = dot( a, f - vec2(0.,0.) );\n    float gb = dot( b, f - vec2(1.,0.) );\n    float gc = dot( c, f - vec2(0.,1.) );\n    float gd = dot( d, f - vec2(1.,1.) );\n    \n    return ga + (gb - ga) * func.x + (gc - ga) * func.y + (ga - gb - gc +gd) * func.x * func.y; \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2. * fragCoord - iResolution.xy)/iResolution.y;\n\n    float p = 0.;\n    float p2 = 0.;\n    float p3 = 0.;\n    float p4 = 0.;\n    float value = 0.;\n    float caus = 0.;\n    \n    p =  0.3 + gradientNoise( 5. * uv + sin(uv.x + iTime*0.5) );\n    p2 = gradientNoise( 3. * uv + iTime*0.5 );\n    p3 = gradientNoise( 2.5 * uv + iTime*0.5 );\n    p4 = gradientNoise( 2.5 * vec2(uv.x - iTime*0.1, uv.y + iTime*0.1) );\n            \n    caus = (p + p2) * abs(sin(iTime));\n    caus = pow(cos( PI * caus / 2.5),6.0);\n    \n    float border = (p3+p4)*0.3;\n    \n    border += length(vec3(p3+p4)); \n    \n    value = ((p * 0.5 * sin(p2)) * 3.) * abs(cos(iTime));\n    \n    vec3 col =  vec3(0.,0.45,0.85) + (1.-value) * vec3(0.2,0.3,0.9);\n    col += (caus) * vec3(0., 0.1,0.4);\n    col += (1. - 10. *  vec3( border * .5) ) * 0.03;\n\n\n    fragColor = vec4( col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtlfWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 57, 57, 283], [285, 285, 316, 316, 837], [839, 839, 896, 896, 1757]], "test": "untested"}
{"id": "NtsBWB", "name": "paintingWithMath2", "author": "Ron1Adi", "description": "math", "tags": ["math"], "likes": 0, "viewed": 151, "published": 3, "date": "1651408467", "time_retrieved": "2024-07-30T16:50:41.948463", "image_code": "//Live Coding and Painting with Maths menit: 1:09:54 / 5:43:05\n\nfloat sdElipsoid( in vec3 pos, vec3 rad )\n{\n float k0 = length(pos/rad);\n float k1 = length(pos/rad/rad);\n \n return k0*(k0-1.0)/k1; //d*mix(rad.x, rad.y;\n}\n\nfloat sdGuy( in vec3 pos )\n{\n  float t = 0.5; //fract(iTime);\n  \n  float y = 4.0*t*(1.0-t);\n  float dy = 4.0*(1.0-2.0*t);\n  \n  vec2 u = normalize(vec2( 1.0, -dy ) );\n  vec2 v = vec2( dy, 1.0 );\n  \n  vec3 cen = vec3(0.0, y, 0.0);\n  \n  float sy = 0.5 + 0.5*y;\n  float sz = 1.0/sy;\n  \n  vec3 rad = vec3(0.25, 0.25*sy, 0.25*sz);\n  \n  vec3 q = pos-cen;\n  //q.yz = vec2( dot(u, q.yz), dot(v, q.yz) );\n  \n  float d = sdElipsoid(q, rad);\n  \n  return d;\n}\n\nfloat map( in vec3 pos )\n{\n      float d1 = sdGuy(pos);\n      \n      float d2 = pos.y - (-0.25);\n      return min(d1, d2);\n}\n    \nvec3 calcNormal( in vec3 pos )\n{\n  vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                        map(pos+e.yxy)-map(pos-e.yxy),\n                        map(pos+e.yyx)-map(pos-e.yyx) ) );\n}\n\nfloat castRay( in vec3 ro, vec3 rd )\n{\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n      {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.001 )\n            break;\n        t += h;\n        if( t>20.0 )\n            break;\n      }\n      if( t>20.0 ) t=-1.0;\n      return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10.0*iMouse.x/iResolution.x; //0.1*iTime;\n    \n    vec3 ta = vec3(0.0, 0.5, 0.0);\n    vec3 ro= ta + vec3(1.5*sin(an), 0.0, 1.5*cos(an));\n    \n    vec3 ww = normalize( ta-ro );\n    vec3 uu = normalize( cross( ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross( uu, ww) );\n    \n    vec3 rd= normalize( p.x*uu + p.y*vv + 1.8*ww);\n\n    //float f = smoothstep( 0.25, 0.26, length(p) );\n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7*rd.y;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y) );\n    \n    float t = castRay( ro, rd );\n      \n      if( t>0.0 )\n      {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2) );\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = step(castRay( pos+nor*0.001, sun_dir ), 0.0 );\n        float sky_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0) ), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0) ), 0.0, 1.0);\n        \n        col = mate*vec3(7.0, 4.5, 3.0)*sun_dif*sun_sha;  //nor.zzz;\n        col += mate*vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif;\n      }\n\n    col = pow(col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NtsBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 107, 107, 219], [221, 221, 249, 249, 667], [669, 669, 695, 695, 793], [799, 799, 831, 831, 1032], [1034, 1034, 1072, 1072, 1336], [1338, 1338, 1395, 1395, 2779]], "test": "untested"}
{"id": "NllBDS", "name": "digital street typo graffiti", "author": "yasuo", "description": "original street typo graffiti\n\n1. Learned how to draw the street graffiti by handwritten.\n2. Decided to use my first word for graffiti as the \"SHADER\".\n3. Added the bunch of radom elements around the word.", "tags": ["cineshader", "typograffiti"], "likes": 25, "viewed": 2648, "published": 3, "date": "1651402184", "time_retrieved": "2024-07-30T16:50:42.861023", "image_code": "// raymarching based from https://www.shadertoy.com/view/wdGGz3\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .0005\n#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define MATERIAL 0\n#define MATERIAL1 1\n#define MATERIAL2 2\n\n#define ZERO (min(iFrame,0))\n\nvec2 combine(vec2 val1, vec2 val2 ){\n    return (val1.x < val2.x)?val1:val2;\n}\n\n// IQ's 3D noise function. It's faster than the FBM and enough for me to design.\n// The compile is also faster.\nfloat noise3d( vec3 p )\n{\n    const vec3 s = vec3(27, 111, 57);\n    vec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); \n    //p *= p*p*(p*(p*6. - 15.) + 10.); // option\n    h = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); \n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p ){\n    p = vec2( dot(p,vec2(127.1,311.7)),\n             dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p ){\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n    \n    vec2 i = floor( p + (p.x+p.y)*K1 );\n    \n    vec2 a = p - i + (i.x+i.y)*K2;\n    vec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n    vec2 b = a - o + K2;\n    vec2 c = a - 1.0 + 2.0*K2;\n    \n    vec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n    \n    vec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    \n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv){\n    float f;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    f  = 0.5000*noise2d( uv ); uv = m*uv;\n    f += 0.2500*noise2d( uv ); uv = m*uv;\n    f += 0.1250*noise2d( uv ); uv = m*uv;\n    f += 0.0625*noise2d( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n    return f;\n}\n\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat sdTriangleIsosceles( in vec2 p, in vec2 q )\n{\n    p.x = abs(p.x);\n    vec2 a = p - q*clamp( dot(p,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = p - q*vec2( clamp( p.x/q.x, 0.0, 1.0 ), 1.0 );\n    float s = -sign( q.y );\n    vec2 d = min( vec2( dot(a,a), s*(p.x*q.y-p.y*q.x) ),\n                  vec2( dot(b,b), s*(p.y-q.y)  ));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// thx iq! https://iquilezles.org/articles/distfunctions2d/\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\nfloat sdRhombus( in vec2 p, in vec2 b ) \n{\n    p = abs(p);\n    float h = clamp( ndot(b-2.0*p,b)/dot(b,b), -1.0, 1.0 );\n    float d = length( p-0.5*b*vec2(1.0-h,1.0+h) );\n    return d * sign( p.x*b.y + p.y*b.x - b.x*b.y );\n}\n\n\nfloat charS(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(length(p-vec2(-0.02,0.06))-0.06)-0.02;\n    float d2 = B(p-vec2(0.03,0.02),vec2(0.045,0.04));\n    d = max(-d2,d);\n    \n    d2 = abs(length(p-vec2(-0.02,-0.06))-0.06)-0.02;\n    float d3 = B(p-vec2(-0.06,-0.02),vec2(0.045,0.04));\n    d2 = max(-d3,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat charH(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.06;\n    float d = B(p,vec2(0.02,0.14));\n    p = prevP;\n    float d2 = B(p,vec2(0.08,0.02));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charA(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    p.x = abs(p.x)-0.04;\n    p*=Rot(radians(-15.0));\n    float d = B(p,vec2(0.02,0.16));\n    p = prevP;\n    float d2 = B(p-vec2(0.0,-0.03),vec2(0.05,0.02));\n    d = min(d,d2);\n    d = max((abs(p.y)-0.09),d);\n    p = prevP;\n    p*=Rot(radians(22.0));\n    d2 =  B(p-vec2(-0.037,-0.12),vec2(0.019,0.12));\n    p*=Rot(radians(-21.0));\n    d2 = max(-p.y-0.2,d2);\n    d = min(d,d2);\n    return d;\n}\n\nfloat charD(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p,vec2(0.02,0.075))-0.04)-0.02;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    return d;\n}\n\nfloat charE(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = B(p,vec2(0.065,0.13));\n    p.y = abs(p.y)-0.055;\n    float d2 = B(p-vec2(0.03,0.0),vec2(0.065,0.03));\n    d = max(-d2,d);\n    return d;\n}\n\nfloat charR(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    float d = abs(sdBox(p-vec2(0.0,0.05),vec2(0.02,0.025))-0.04)-0.02;\n    d = max(-p.x-0.03,d);\n    float d2 = B(p-vec2(-0.05,0.0),vec2(0.02,0.135));\n    d = min(d,d2);\n    p*=Rot(radians(-20.0));\n    d2 = B(p-vec2(0.02,-0.14),vec2(0.02,0.13));\n    p*=Rot(radians(20.0));\n    d2 = max(-p.y-0.2,d2);\n    \n    d = min(d,d2);\n    return d;\n}\n\nfloat arrow(vec2 p){\n    vec2 prevP = p;\n    p.y*=1.5;\n    \n    float d = B(p-vec2(0.0,-0.1),vec2(0.02,0.15));\n    float d2 = sdTriangleIsosceles(p-vec2(0.0,0.2),vec2(0.06,-0.2));\n    d = min(d,d2);\n    return d;\n}\n\nfloat trydent(vec2 p) {\n    vec2 prevP = p;\n    float d = B(p-vec2(0.0,-0.015),vec2(0.1,0.02));\n    \n    float d2 = sdTriangleIsosceles(p-vec2(0.0,0.095),vec2(0.035,-0.1));\n    d = min(d,d2);\n    \n    p.x = abs(p.x)-0.067;\n    p.y*=1.1;\n    d2 = sdTriangleIsosceles(p-vec2(0.0,0.095),vec2(0.035,-0.1));\n    d = min(d,d2);\n    return d;\n}\n\nfloat shaderText(vec2 p){\n    vec2 prevP = p;\n    p.y*=0.9;\n    float d = charS(p-vec2(-0.5,0.0));\n    float d2 = charH(p-vec2(-0.34,0.0));\n    d = min(d,d2);\n    d2 = charA(p-vec2(-0.14,0.0));\n    d = min(d,d2);\n    d2 = charD(p-vec2(0.05,0.0));\n    d = min(d,d2);\n    d2 = charE(p-vec2(0.22,0.0));\n    d = min(d,d2);\n    d2 = charR(p-vec2(0.38,0.0));\n    d = min(d,d2);\n    return d;\n}\n\nfloat typoGraphic(vec2 p, float option){\n    p.x-=0.06;\n    vec2 prevP = p;\n    \n    float d = length(p-vec2(0.22,0.1))-0.13;\n    float d2 = length(p-vec2(-0.3,-0.08))-0.05;\n    d = min(d,d2);\n    d2 = length(p-vec2(-0.4,0.1))-0.08;\n    d = min(d,d2);\n    d2 = sdRhombus(p-vec2(-0.05,0.0),vec2(0.05,0.2));\n    d = min(d,d2);\n        \n    p*=Rot(radians(-145.0));\n    d2 = arrow(p-vec2(0.5,0.47));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(45.0));\n    d2 = arrow(p-vec2(0.25,0.53));\n    d = min(d,d2);\n    \n    p = prevP;\n    p*=Rot(radians(125.0));\n    d2 = arrow(p-vec2(0.0,0.3));\n    d = min(d,d2);   \n    \n    p = prevP;\n    p*=Rot(radians(-50.0));\n    d2 = arrow(p-vec2(-0.29,0.63));      \n    d = min(d,d2);\n    \n    p = prevP;\n    \n    p*=Rot(radians(180.0));\n    d2 = trydent(p-vec2(0.48,0.12));\n    d = min(d,d2);\n    \n    p = prevP;\n\n    d2 = shaderText(p);\n    d = min(d,d2);\n    \n    p.y = abs(p.y)-0.03;\n    float mask = B(p,vec2(2.0,0.012));\n    d = max(mask*option,d);\n    return d*0.3;\n}\n\nfloat circleArrow(vec2 p) {\n    vec2 prevP = p;\n    float d = abs(length(p)-0.3)-0.005;\n    \n    p*=Rot(radians(-40.0));\n    float d2 = B(p-vec2(0.0,0.2),vec2(0.17,0.2));\n    d = max(-d2,d);\n    \n    p = prevP;\n\n    p*=Rot(radians(90.0));\n    d2 = sdTriangleIsosceles(p-vec2(-0.3,-0.1),vec2(0.03,0.1));\n    d = min(d,d2);\n    return d;\n}\n\nvec2 GetDist(vec3 p) {\n\n    vec3 prevP = p;\n    \n    p = prevP;\n    p+=noise3d(p*300.0)*0.002;\n    float d = typoGraphic(p.xy,-1.0);\n    d = max((abs(p.z)-0.05),d);\n    \n    vec2 model = vec2(d,MATERIAL);\n    \n    p = prevP;\n    p.xz*=Rot(radians(30.0));\n    p.xy*=Rot(radians(-iTime*50.0));\n    d = circleArrow(p.xy);\n    d = max((abs(p.z)-0.01),d);\n    \n    vec2 model2 = vec2(d,MATERIAL1);\n    \n    p = prevP;\n    p*=0.8;\n    p.xz*=Rot(radians(-20.0));\n    p.xy*=Rot(radians(180.0-iTime*70.0));\n    p.yz*=Rot(radians(10.0));\n    d = circleArrow(p.xy);\n    d = max((abs(p.z)-0.01),d);\n    \n    vec2 model3 = vec2(d,MATERIAL1);\n    \n    model2 = combine(model2,model3);\n\n    return combine(model,model2);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, float side, int stepnum) {\n    vec2 dO = vec2(0.0);\n    \n    for(int i=0; i<stepnum; i++) {\n        vec3 p = ro + rd*dO.x;\n        vec2 dS = GetDist(p);\n        dO.x += dS.x*side;\n        dO.y = dS.y;\n        \n        if(dO.x>MAX_DIST || abs(dS.x)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n    float d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n// https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<4; i++ )\n    {\n        float h = 0.01 + 0.15*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = GetDist( opos ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nvec3 diffuseMaterial(vec3 n, vec3 rd, vec3 p, vec3 col) {\n    float occ = calcOcclusion(p,n);\n    vec3 diffCol = vec3(0.0);\n    vec3 lightDir = normalize(vec3(1,10,-10));\n    float diff = clamp(dot(n,lightDir),0.0,1.0);\n    float shadow = step(RayMarch(p+n*0.3,lightDir,1.0, 15).x,0.9);\n    float skyDiff = clamp(0.5+0.5*dot(n,vec3(0,1,0)),0.0,1.0);\n    float bounceDiff = clamp(0.5+0.5*dot(n,vec3(0,-1,0)),0.0,1.0);\n    diffCol = col*vec3(-0.5)*diff*shadow*occ;\n    diffCol += col*vec3(1.0,1.0,0.9)*skyDiff*occ;\n    diffCol += col*vec3(0.3,0.3,0.3)*bounceDiff*occ;\n    diffCol += col*pow(max(dot(rd, reflect(lightDir, n)), 0.0), 60.)*occ; // spec\n        \n    return diffCol;\n}\n\nfloat randomSquare(vec2 p,float a,float startSize){\n    p*=a;\n    vec2 id = floor(p);\n    p = fract(p)-0.5;\n    vec2 n = hash(id);\n    \n    float d = B(p+(n*0.2),vec2(startSize+clamp(n.x,0.1,0.15)));\n    if(n.x<0.5){\n        d = 1.0;\n    }\n    return d;\n}\n\nvec3 materials(int mat, vec3 n, vec3 rd, vec3 p, vec3 col){\n    if(mat == MATERIAL){\n        vec3 texCol = mix(vec3(0.0,0.5,1.0),vec3(0.8,0.2,0.2),smoothstep(0.3,-0.3,p.y));\n        float d = randomSquare(p.xy,100.0,0.2);\n        texCol = mix(texCol,vec3(0.5,0.7,0.9),S(d,0.0));\n        col = diffuseMaterial(n,rd,p,texCol);\n    } if(mat == MATERIAL1){\n        col = diffuseMaterial(n,rd,p,vec3(0.1,0.3,0.7));\n    } if(mat == MATERIAL2){\n        col = diffuseMaterial(n,rd,p,vec3(0.2));\n    }\n    return col;\n}\n\nvec3 drawGraphic(vec2 p, vec3 col){\n    vec2 prevP = p;\n    \n    float d = typoGraphic(p-vec2(0.015,-0.02),-1.0);\n    col = mix(col,vec3(0.3),S(d,0.0));    \n    \n    p.x-=0.06;\n    d = shaderText(p);\n    col = mix(col,vec3(0.9,0.8,0.0),S(d,0.0));\n    \n    p = prevP;\n    d = typoGraphic(p,-1.0);\n    col = mix(col,vec3(0.5,0.8,0.9),S(d,0.0));\n    \n    return col;\n}\n\nvec3 randomSquareBg(vec2 p, vec3 col) {\n    vec2 prevP = p;\n    \n    p.y-=iTime*0.1;\n    p*=Rot(radians(45.0));\n    float d = randomSquare(p,7.0,0.01);\n    \n    vec2 id = floor(p);\n    vec2 n = hash(id)*0.1;\n    col = mix(col,vec3(0.8)+n.x,S(d,0.0));\n    \n    p = prevP;\n    p.y-=iTime*0.05;\n    p.x-=0.5;\n    p*=Rot(radians(-45.0));\n    d = randomSquare(p,5.0,0.01);\n\n    col = mix(col,vec3(0.9)+n.y,S(d,0.0));\n    \n    return col;\n}\n\nvec3 rhombusBg(vec2 p, vec3 col) {\n    p*=10.0;\n    p*=Rot(radians(65.0));\n    p.y-=iTime*0.5;\n    vec2 id = floor(p);\n    p = fract(p)-0.5;\n    vec2 n = hash(id);\n    \n    float d = sdRhombus(p,vec2(0.2,0.5));\n    if(n.x>-0.4){\n        d = abs(sdRhombus(p,vec2(0.2,0.5)))-0.02;\n    }\n    \n    col = mix(col,vec3(0.9)+n.y*0.5, S(d,0.0));\n    return col;\n}\n\nvec3 animationBg(vec2 p, vec3 col){\n        vec2 prevP = p;\n        \n        col = rhombusBg(p,col);\n        \n        col = randomSquareBg(p,col);\n        \n        p.x+=iTime*0.02;\n        p*=Rot(radians(20.0));\n        p.x = mod(p.x,0.016)-0.008;\n        \n        float border = abs(p.x)-0.005;\n        \n        p = prevP;\n        p*=fbm(p*2.5)*0.95;\n        \n        p.x*=0.5;\n        float d = length(p)-0.15;\n        \n        col = mix(col,vec3(0.85),S(d,0.0));\n        \n        p = prevP;\n        p*=fbm(p*2.8)*0.9;\n        \n        p.x*=0.5;\n        d = length(p)-0.13;\n        d = max(-border,d);\n        \n        col = mix(col,vec3(0.95),S(d,0.0));\n        return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec2 m =  iMouse.xy/iResolution.xy;\n    \n    vec3 ro = vec3(0, 0, -1.15);\n    if(iMouse.z>0.){\n        ro.yz *= Rot(m.y*3.14+1.);\n        ro.y = max(-0.9,ro.y);\n        ro.xz *= Rot(-m.x*6.2831);\n    } else {\n        ro.yz *= Rot(radians(-5.0));\n        ro.xz *= Rot(radians(sin(iTime)*5.0));\n    }\n    \n    vec3 rd = R(uv, ro, vec3(0,0.0,0), 1.0);\n    vec2 d = RayMarch(ro, rd, 1.,MAX_STEPS);\n    vec3 col = vec3(1.0);\n    \n    if(d.x<MAX_DIST) {\n        vec3 p = ro + rd * d.x;\n        vec3 n = GetNormal(p);\n        int mat = int(d.y);\n        col = materials(mat,n,rd,p,col);\n    } else {\n        col = animationBg(uv,col);\n        \n        uv*=0.98;\n        col = drawGraphic(uv,col);\n    }\n    \n    // gamma correction\n    col = pow( col, vec3(0.9545) );    \n\n    uv.x+=iTime*2.0;\n    col+=(hash(uv).x*3.0*hash(uv).y*3.0)*0.03;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/NllBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[426, 426, 462, 462, 504], [506, 618, 643, 643, 988], [990, 1139, 1159, 1159, 1293], [1295, 1295, 1322, 1322, 1825], [1827, 1827, 1846, 1846, 2108], [2111, 2171, 2208, 2208, 2288], [2290, 2350, 2401, 2401, 2709], [2711, 2771, 2800, 2800, 2828], [2829, 2829, 2871, 2871, 3052], [3055, 3055, 3075, 3075, 3416], [3418, 3418, 3438, 3438, 3620], [3622, 3622, 3642, 3642, 4068], [4070, 4070, 4090, 4090, 4295], [4297, 4297, 4317, 4317, 4503], [4505, 4505, 4525, 4525, 4899], [4901, 4901, 4921, 4921, 5115], [5117, 5117, 5140, 5140, 5454], [5456, 5456, 5481, 5481, 5843], [5845, 5845, 5885, 5885, 6863], [6865, 6865, 6892, 6892, 7202], [7204, 7204, 7226, 7226, 7911], [7913, 7913, 7971, 7971, 8238], [8240, 8240, 8264, 8264, 8465], [8467, 8467, 8509, 8509, 8704], [8706, 8747, 8796, 8796, 9090], [9092, 9092, 9149, 9149, 9770], [9772, 9772, 9823, 9823, 10027], [10029, 10029, 10088, 10088, 10539], [10541, 10541, 10576, 10576, 10906], [10908, 10908, 10947, 10947, 11342], [11344, 11344, 11378, 11378, 11699], [11701, 11701, 11736, 11736, 12379], [12381, 12381, 12438, 12438, 13391]], "test": "untested"}
{"id": "slffWB", "name": "paintingWithMath", "author": "Ron1Adi", "description": "math", "tags": ["math"], "likes": 0, "viewed": 158, "published": 3, "date": "1651391689", "time_retrieved": "2024-07-30T16:50:43.597055", "image_code": "\nfloat map( in vec3 pos )\n    {\n      float d1 = length(pos) - 0.25;\n      \n      float d2 = pos.y - (-0.25);\n      return min(d1, d2);\n    }\n    \nvec3 calcNormal( in vec3 pos )\n{\n  vec2 e = vec2(0.0001, 0.0);\n  return normalize(vec3(map(pos+e.xyy)-map(pos-e.xyy),\n                        map(pos+e.yxy)-map(pos-e.yxy),\n                        map(pos+e.yyx)-map(pos-e.yyx) ) );\n}\n\nfloat castRay( in vec3 ro, vec3 rd )\n{\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n      {\n        vec3 pos = ro + t*rd;\n        float h = map(pos);\n        if( h<0.001 )\n            break;\n        t += h;\n        if( t>20.0 )\n            break;\n      }\n      if( t>20.0 ) t=-1.0;\n      return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    float an = 10.0*iMouse.x/iResolution.x; //0.1*iTime;\n    \n    vec3 ro= vec3(1.0*sin(an), 0.0, 1.0*cos(an));\n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ww = normalize( ta-ro );\n    vec3 uu = normalize( cross( ww, vec3(0,1,0)));\n    vec3 vv = normalize( cross( uu, ww) );\n    \n    vec3 rd= normalize( p.x*uu + p.y*vv + 1.5*ww);\n\n    //float f = smoothstep( 0.25, 0.26, length(p) );\n    vec3 col = vec3(0.4, 0.75, 1.0) - 0.7*rd.y;\n    col = mix(col, vec3(0.7, 0.75, 0.8), exp(-10.0*rd.y) );\n    \n    float t = castRay( ro, rd );\n      \n      if( t>0.0 )\n      {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n        \n        vec3 mate = vec3(0.18);\n        \n        vec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2) );\n        float sun_dif = clamp(dot(nor, sun_dir), 0.0, 1.0);\n        float sun_sha = step(castRay( pos+nor*0.001, sun_dir ), 0.0 );\n        float sky_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, 1.0, 0.0) ), 0.0, 1.0);\n        float bou_dif = clamp(0.5 + 0.5*dot(nor, vec3(0.0, -1.0, 0.0) ), 0.0, 1.0);\n        \n        col = mate*vec3(7.0, 4.5, 3.0)*sun_dif*sun_sha;  //nor.zzz;\n        col += mate*vec3(0.5, 0.8, 0.9)*sky_dif;\n        col += mate*vec3(0.7, 0.3, 0.2)*bou_dif;\n      }\n\n    col = pow(col, vec3(0.4545) );\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slffWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 31, 31, 141], [147, 147, 179, 179, 380], [382, 382, 420, 420, 684], [686, 686, 743, 743, 2122]], "test": "untested"}
{"id": "stXBWB", "name": "Gaussian vs Cartesian shake", "author": "copperbotte", "description": "two different kinds of shake, one is a uniform random, the other is a gaussian random.\n\nWorks better with fonts or text.", "tags": ["noise", "random"], "likes": 5, "viewed": 239, "published": 3, "date": "1651383902", "time_retrieved": "2024-07-30T16:50:44.338074", "image_code": "// random number generator **\n// taken from iq :)\nfloat seed;    //seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\nbool hitStar(vec2 center, vec2 xy)\n{\n    xy -= center;\n    \n    float factor = 0.5;\n    float l = pow(pow(abs(xy.x), factor) + pow(abs(xy.y), factor), 1.0/factor);\n    \n    return l < 0.25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Correct for aspect ratio, convert so 0 is the center\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.x *= iResolution.x/iResolution.y;\n    \n    // Generate random seed\n    //float seedtime = iTime;\n    float seedtime = floor(float(iFrame) / (60.0/12.0))/12.0;\n    \n    seed = fract(seedtime);// + iResolution.y * uv.x + uv.y;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    col *= 0.25;\n    \n    // Shake parameters\n    float jitterscale = 0.05;\n    float seperation = 0.5;\n    const int samples = 4;\n    \n    vec3 avg = vec3(0.0);\n    \n    for(int i=0; i<samples; ++i)\n    {\n        // Linear random jitter\n        vec2 jitter = vec2(rnd(), rnd()) * 2.0 - 1.0;\n        jitter *= jitterscale;\n        if(hitStar(vec2(-seperation, 0.0) + jitter, xy))\n            avg += vec3(1);\n\n        // Gaussian random jitter\n        vec2 xi = vec2(rnd(), rnd());\n        float r = sqrt(-log(1.0 - xi.x));\n        float theta = 2.0 * 3.141592 * xi.y;\n        jitter = vec2(cos(theta), sin(theta)) * r;\n\n        jitter *= jitterscale;\n        if(hitStar(vec2(seperation, 0.0) + jitter, xy))\n            avg += vec3(1);\n    }\n\n    col = mix(col, vec3(1), avg / float(samples));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXBWB.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 105, 105, 148], [150, 150, 186, 186, 341], [343, 343, 400, 450, 1761]], "test": "untested"}
{"id": "slfBDS", "name": "Mandelbrot, blue and yellow", "author": "Tomas3w", "description": "Mandelbrot set", "tags": ["fractal"], "likes": 1, "viewed": 183, "published": 3, "date": "1651377508", "time_retrieved": "2024-07-30T16:50:45.073109", "image_code": "\nvec2 square_complex(vec2 c)\n{\n    // (a + bi)*(a + bi)\n    // a*a+abi + bia+bibi\n    // a*a+abi + abi+bibi\n    // a*a+2abi+bibi\n    // a*a+2abi+bbii\n    // a*a+2abi-b*b\n    // aa-bb+2abi\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nint iterations = 20;\n\nstruct MandelResult\n{\n    int it;\n    float dist;\n};\n\nMandelResult mandelbrot_point(vec2 c)\n{\n    vec2 z = vec2(0, 0);\n    int it = 0;\n    while (it < iterations && dot(z, z) < 4.0)\n    {\n        z = square_complex(z) + c;\n        it++;\n    }\n    return MandelResult(it, dot(z, z) - 4.0);\n}\n\nvec3 color_from_point(vec2 point)\n{\n    MandelResult it = mandelbrot_point(point);\n    float fit = (float(it.it)) / float(iterations);\n    return vec3(fit, fit, it.dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv *= 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    uv *= 2.2;\n\n    // Getting final value from uv as position\n    vec3 col = color_from_point(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/slfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 187, 238], [316, 316, 355, 355, 552], [728, 728, 785, 835, 1120]], "test": "untested"}
{"id": "stfBDS", "name": "Mandelbrot, blue and yello", "author": "Tomas3w", "description": "Mandelbrot set", "tags": ["fractal"], "likes": 1, "viewed": 154, "published": 3, "date": "1651377415", "time_retrieved": "2024-07-30T16:50:45.820112", "image_code": "\nvec2 square_complex(vec2 c)\n{\n    // (a + bi)*(a + bi)\n    // a*a+abi + bia+bibi\n    // a*a+abi + abi+bibi\n    // a*a+2abi+bibi\n    // a*a+2abi+bbii\n    // a*a+2abi-b*b\n    // aa-bb+2abi\n    return vec2(c.x*c.x - c.y*c.y, 2.0*c.x*c.y);\n}\n\nint iterations = 20;\n\nstruct MandelResult\n{\n    int it;\n    float dist;\n};\n\nMandelResult mandelbrot_point(vec2 c)\n{\n    vec2 z = vec2(0, 0);\n    int it = 0;\n    while (it < iterations && dot(z, z) < 4.0)\n    {\n        z = square_complex(z) + c;\n        it++;\n    }\n    return MandelResult(it, dot(z, z) - 4.0);\n}\n\nvec3 color_from_point(vec2 point)\n{\n    MandelResult it = mandelbrot_point(point);\n    float fit = (float(it.it)) / float(iterations);\n    return vec3(fit, fit, it.dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv *= 2.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    uv *= 2.2;\n\n    // Getting final value from uv as position\n    vec3 col = color_from_point(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stfBDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 30, 187, 238], [316, 316, 355, 355, 552], [728, 728, 785, 835, 1120]], "test": "untested"}
{"id": "stXfWS", "name": "2D Transform from 3 Points", "author": "pyBlob", "description": "Calculates the transform between a camera and a square, such that the rays through the 3 image points intersect 3 corners of that square.\n\nMouse: manually move image points / directions.", "tags": ["geometry", "transform", "projective"], "likes": 3, "viewed": 272, "published": 3, "date": "1651370897", "time_retrieved": "2024-07-30T16:50:46.559136", "image_code": "// The interesting bits:\n//   void Common::recover_transform(inout State z);\n\nvoid mainImage(out vec4 C, vec2 O)\n{\n    C = image(O, iResolution, iMouse, iFrame, iChannel0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "struct View\n{\n    float f;\n    vec2 uv;\n    vec2 mouse;\n    vec2 click;\n    bool down;\n    bool clicked;\n};\n\nvoid init(inout View v, vec2 O, vec3 R, vec4 mouse)\n{\n    v.f = R.x / 10.;\n    vec2 o = vec2(0, R.y) / 2.;\n    v.uv = (O - o) / v.f;\n    v.mouse = (abs(mouse.xy) - o) / v.f;\n    v.click = (abs(mouse.zw) - o) / v.f;\n    v.down = mouse.z > 0.;\n    v.clicked = mouse.w > 0.;\n}\n\nconst int N = 3;\nstruct State\n{\n    float screen[N];\n\n    int selected_point;\n    \n    mat2x3 T;\n};\n\nvoid recover_transform(inout State z)\n{\n    float i, j, k, x, y, c, s, r;\n\n    i = z.screen[0];\n    j = z.screen[1];\n    k = z.screen[2];\n\n    x =  j * k + 1.;\n    y =  i * x;\n    c =  i * k - i - j * k + k;\n    s = -i * j - i + j * k + j;\n    r = length(vec2(c, s));\n\n    z.T = mat2x3(\n        x, c, -s,\n        y, s,  c\n    ) / r;\n}\n\n/*\nwhen j == 0 (red):\n    x =  1.\n    y =  i\n    c =  i * k - i + k\n      = -i + k * (i + 1)\n    s = -i\n    \n    when k == i / (i + 1):\n        => c, s = 0, -i\n\nwhen k == 0 (blue):\n    x =  1\n    y =  i\n    c = -i\n    s = -i * j - i + j\n      = -i + j * (1 - i)\n    \n    when j == i / (1 - i):\n        => c, s = -i, 0\n\nwhen i == j:\n    x =  i * k + 1\n    y =  i * x\n    c =  i * k - i - i * k + k\n      =        - i         + k\n    s = -i * i     + i * k\n    \n    when k == 0:\n        => x, y, c, s, r = 1, i, -i, -i, i + i\n\n    when i == j == 0:\n        => x, y, c, s = 1, 0, k, 0\n*/\n\nvoid load(inout State z, sampler2D A)\n{\n    vec4 t;\n    t = texelFetch(A, ivec2(0, 0), 0);\n    z.selected_point = int(t.y);\n\n    for (int i=0 ; i<N ; ++i)\n    {\n        t = texelFetch(A, ivec2(1, i), 0);\n        z.screen[i] = t.x;\n    }\n    \n    recover_transform(z);\n}\n\nvec4 save(State z, ivec2 O)\n{\n    vec4 t = vec4(0);\n    if (O == ivec2(0, 0))\n    {\n        t.y = float(z.selected_point);\n    }\n    \n    for (int i=0 ; i<N ; ++i)\n        if (O == ivec2(1, i))\n            t.x = z.screen[i];\n    \n    return t;\n}\n\nvoid demo(inout State z, vec4 M, int iFrame, float iTime)\n{\n    if (iFrame == 0)\n    {\n        z.screen[0] = -0.05;\n        z.screen[1] = 0.3;\n        z.screen[2] = -0.2;\n    }\n    if (M == vec4(0))\n    {\n        float t = (iTime - 2.5) / 5.;\n        float a = 0.3 * cos(t * 2.4166);\n        float v = 3. * cos(t * 1.) + 0.2 * t;\n        float b = 0.35 * cos(v);\n        float c = 0.35 * sin(v);\n        float d = sqrt(0.6 + 0.5 * abs(a) + 0.5 * cos(t * 5.1341));\n        z.screen[0] = a;\n        z.screen[1] = a + b * d;\n        z.screen[2] = a + c * d;\n    }\n}\n\nfloat ray(vec2 x, vec2 t)\n{\n    return abs(dot(x, normalize(t).yx * vec2(-1, 1)));\n}\n\nfloat ray(vec2 x, State z, int i)\n{\n    return ray(x, vec2(1, z.screen[i]));\n}\n\nvec4 bufferA(vec2 O, vec3 R, vec4 M, int iFrame, float iTime, sampler2D A)\n{\n    View v; init(v, O, R, M);\n    State z; load(z, A); demo(z, M, iFrame, iTime);\n    if (!v.down)\n        z.selected_point = -1;\n    if (v.clicked)\n    {\n        int closest = 0;\n        for (int i=1 ; i<N ; ++i)\n            if (ray(v.mouse, z, i) < ray(v.mouse, z, closest))\n                closest = i;\n        float r = ray(v.mouse, z, closest);\n        z.selected_point = r < 20. / v.f ? closest : -1;\n    }\n    for (int i=0 ; i<N ; ++i)\n        if (v.down && z.selected_point >= 0 && i==z.selected_point)\n            z.screen[i] = v.mouse.y / v.mouse.x;\n    return save(z, ivec2(O));\n}\n\nvoid blend(inout vec4 C, vec3 c, float r)\n{\n    C = mix(C, vec4(c, 1), clamp(r, 0., 1.));\n}\n\nvoid blend(inout vec4 C, vec4 c)\n{\n    blend(C, c.xyz, c.w);\n}\n\nvoid circle(inout vec4 C, View v, vec3 c, vec2 center, float r)\n{\n    float l = r - length(v.uv - center) * v.f;\n    blend(C, vec3(1), l + 1.);\n    blend(C, c, l);\n}\n\nView transform(View v, mat2x3 T)\n{\n    mat3x3 M = inverse(mat3x3(1, 0, 0, T[0], T[1]));\n    T = mat2x3(M[1], M[2]);\n    v.uv = vec3(1, v.uv) * T;\n    v.mouse = vec3(1, v.mouse) * T;\n    return v;\n}\n\nconst vec3 colors[] = vec3[](\n    vec3(0),\n    vec3(1,   0, 0),\n    vec3(0,   0, 1),\n    vec3(1, 0.3, 0)\n);\n\nvoid object(inout vec4 C, View v)\n{\n    vec2 x = abs(v.uv - 0.5) - 0.5;\n    float l = 1. - max(0., max(x.x, x.y)) * v.f;\n    vec3 c1, c2, c;\n    c1 = mix(colors[0], colors[1], v.uv.x);\n    c2 = mix(colors[2], colors[3], v.uv.x);\n    c = mix(c1, c2, v.uv.y);\n    blend(C, c, l);\n\n    for (int i=0 ; i<4 ; ++i)\n        circle(C, v, colors[i], vec2(i%2, i/2), 3.);\n}\n\nvec4 image(vec2 O, vec3 R, vec4 M, int iFrame, sampler2D A)\n{\n    View v; init(v, O, R, M);\n    State z; load(z, A);\n    vec4 C = vec4(1, 1, 1, 0);\n    \n    // object\n    object(C, transform(v, z.T));\n\n    // image plane\n    blend(C, vec3(0), 1. - abs(v.uv.x - 1.) * v.f);\n\n    for (int i=0 ; i<N ; ++i)\n    {\n        float r = 3., l = 1.;\n        if (z.selected_point == i)\n        {\n            r = 5.;\n            l = 1.5;\n        }\n        vec2 image_point = vec2(1, z.screen[i]);\n        \n        // ray\n        blend(C, colors[i], l - ray(v.uv, image_point) * v.f);\n        \n        // image point\n        circle(C, v, colors[i], image_point, r);\n    }\n    C = sqrt(C);\n    return C;\n}\n", "buffer_a_code": "void mainImage(out vec4 C, vec2 O)\n{\n    C = bufferA(O, iResolution, iMouse, iFrame, iTime, iChannel0);\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/stXfWS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 114, 114, 174]], "test": "untested"}
