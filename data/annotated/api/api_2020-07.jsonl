{"id": "tlXBR8", "name": "Tetrahedron SDF (rounded)", "author": "teadrinker", "description": "Is roundmax() a decent name? \nIs it known by some other name?", "tags": ["sdf", "tetrahedron", "tetrahedronsdf", "roundmax"], "likes": 5, "viewed": 623, "published": 3, "date": "1596228303", "time_retrieved": "2024-07-30T20:52:55.336119", "image_code": "\n/*\n\nA common problem when building sdf functions is that when\ncombining sdf distances (like for example from 2 planes) using\nmax(a,b) the result will have incorrect distance for the corners.\nFor many cases this is fine, and if not you can use a smooth union.\nHowever, there are cases, like morphing, where it is nicer to have\nsomething closer to an exact solution.\n\nI was trying to understand this problem better by looking at plots\nof 2D SDF functions when I realized that there seem to be a simple\ngeneral solution to this problem (I am not sure how useful it is,\nbut it seemed to work fine for a tetrahedron)\n\nroundmax() below can be used to combine SDF distances.\nIt's only correct if used with planes that are perpendicular,\nbut seem to work ok to raymarch for angles < 90 degrees.\n\nAngles > 90 degrees might cause ray marching to overshoot\n(but you could then use gamma space, pow(pow(a,g) + pow(a,g),1/g)\n instead of sqrt(a*a + b*b), for a more extreme warp of the space)\n\n\nbtw, If you need an exact tetrahedron sdf, iq posted one here:\n  https://www.shadertoy.com/view/ts3SRs\n\n*/\n\n\nfloat roundmax(float a, float b) \n{\n    return a > 0. && b > 0. ? length(vec2(a, b)) : max(a, b);\n}\n\nfloat roundmax(float a, float b, float c) \n{\n    return length(max(vec3(a, b, c), 0.0)) + min(max(max(a, b), c), 0.0);\n}\n\nfloat roundmax(float a, float b, float c, float d) \n{\n    return length(max(vec4(a, b, c, d), 0.0)) + min(max(max(a, b), max(c, d)), 0.0);\n}\n\nfloat sdTetrahedron(vec3 p, float size) // not exact!\n{\n    return roundmax(\n         (p.x + p.z) - p.y - size, \n        -(p.x + p.z) - p.y - size,\n         (p.x - p.z) + p.y - size, \n        -(p.x - p.z) + p.y - size\n    ) * (1. / sqrt(3.));\n}\n\nfloat sdTetrahedronFaster(vec3 p, float size) // not exact, no interior\n{\n    return length(max(vec4(\n         (p.x + p.z) - p.y - size,\n        -(p.x + p.z) - p.y - size,\n         (p.x - p.z) + p.y - size,\n        -(p.x - p.z) + p.y - size\n        ), 0.0)) * (1. / sqrt(3.));\n}\n\n\n\n\nfloat mapbasic( in vec3 pos )\n{\n    float roundness = 0.08 * (1. + sin(iTime));\n    return sdTetrahedron(pos-vec3(0.0, 0.35, 0.0), 0.25 - roundness * 1.3) - roundness;\n}\n\n\n// (this is using Inigo Quilez raymarching code)\n\n//------------------------------------------------------------------\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 pos )\n{\n    vec2 res = vec2( 1e10, 0.0 );\n\n    float roundness = 0.08 * (1. + sin(iTime));\n    res = opU(res, vec2(mapbasic(pos), 1.5));\n    \n    return res;\n}\n\n\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\n\n\n// https://iquilezles.org/articles/boxfunctions\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    }\n    \n    return res;\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// https://iquilezles.org/articles/checkerfiltering\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0;// + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.3, 0.0 );\n    vec3 ro = ta + vec3( 1.5*cos(0.1*time + 7.0*mo.x), 0.4 + 1.0*mo.y, 1.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1091, 1091, 1126, 1126, 1190], [1192, 1192, 1236, 1236, 1312], [1314, 1314, 1367, 1367, 1454], [1456, 1456, 1511, 1511, 1700], [1702, 1702, 1775, 1775, 1980], [1985, 1985, 2016, 2016, 2154], [2448, 2448, 2473, 2473, 2488], [2490, 2490, 2520, 2520, 2553], [2555, 2555, 2580, 2580, 2732], [2908, 2956, 3007, 3007, 3212], [3214, 3214, 3254, 3254, 4064], [4066, 4111, 4189, 4212, 4600], [4602, 4648, 4680, 4680, 5250], [5252, 5252, 5294, 5294, 5603], [5605, 5657, 5721, 5742, 5975], [5977, 5977, 6042, 6061, 8484], [8486, 8486, 8538, 8538, 8715]], "test": "untested"}
{"id": "wtXBR4", "name": "Cartoon ride", "author": "iapafoto", "description": "try a cartoon style with a kind of adaptative anti-aliasing.", "tags": ["cartoon", "edge"], "likes": 23, "viewed": 744, "published": 3, "date": "1596208063", "time_retrieved": "2024-07-30T20:52:56.379330", "image_code": "// based on one desert canyon of the fantastic Shane shader\n\n// best for small size\n#define WITH_AA\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 res = texture(iChannel0, uv);\n\n#ifdef WITH_AA\n    \n    vec3 dp = vec3(1./iResolution.xy, 0);\n    float needAA = 0.;\n    for (int j=-1; j<3; j++) {\n        for (int i=-1; i<3; i++) {\n            needAA += texture(iChannel0, uv).w;\n        }\n    }\n    \n    // Antialising only on edges and big curvature\n    if (needAA > .5) {\n    \tfor (int k=0; k<4; k++)\n        \tres += render(fragCoord+.66*vec2(k%2-1,k/2-1)-.33, iTime, iResolution.xy, iChannel0);\n        res /= 5.;\n    }\n    \n#endif\n\n    fragColor = res;\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = render(fragCoord.xy, iTime, iResolution.xy, iChannel0);\n}\n\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define FAR 400.\n//#define PRECISE\n//#define WITH_AO\n\n#define ID_SKY    0.\n#define ID_SHIP   1.\n#define ID_GROUND 2.\n#define ID_PATH   3.\n\n#define EDGE_WIDTH 5e-3\n\n\n\n// Frequencies and amplitudes of the \"path\" function, used to shape the tunnel and guide the camera.\nconst float freqA = .34*.15/3.75;\nconst float freqB = .25*.25/2.75;\nconst float ampA = 20.;\nconst float ampB = 4.;\n\n\nvec3 gRO;\nmat3 gbaseShip;\n\nfloat gedge;\nfloat gedge2;\nfloat glastt;\n\n\n// 2x2 matrix rotation. Angle vector, courtesy of Fabrice.\nmat2 rot2( float th ){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// 1x1 and 3x1 hash functions.\nfloat hash(float n){ return fract(cos(n)*45758.5453); }\nfloat hash(vec3 p){ return fract(sin(dot(p, vec3(7, 157, 113)))*45758.5453); }\n\n\n// Smooth maximum, based on the function above.\nfloat smaxP(float a, float b, float s){    \n    float h = clamp(.5 + .5*(a - b)/s, 0., 1.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r ) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvoid pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*3.141592/repetitions;\n\tfloat a = atan(p.y, p.x) + angle*.5;\n\ta = mod(a,angle) - angle*.5;\n\tp = vec2(cos(a), sin(a))*length(p);\n}\n\nvoid pR45(inout vec2 p) {\n\tp = (p + vec2(p.y, -p.x))*sqrt(0.5);\n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n    return vec2(ampA*sin(z * freqA) + 2.*cos(z*.0252) - 1., 10.+ ampB*cos(z * freqB) * (.5+ .5*sin(z*0.0015)));\n}\n\nfloat sdGround(in vec3 p, sampler2D channel){\n    p += vec3(0,2,0);\n    float tx1 = 2.5*textureLod(channel, p.xz/28. + p.xy/100., 0.).x;\n    float tx2 = 2.*textureLod(channel, p.xy/vec2(31.,15.), 0.).x;\n  \tfloat tx = tx1 - tx2;\n\n    vec3 q = p*.125;\n    float h = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n\n    float d = p.y + h*6.;\n    q = p*.07125;\n    float h3 = dot(sin(q)*cos(q.yzx), vec3(.222)) + dot(sin(q*1.5)*cos(q.yzx*1.5), vec3(.111));\n    float d3 = p.y + h3*22.-22.;\n  \n    q = sin(p*.5 + h);\n    float h2 = q.x*q.y*q.z;\n  \n    vec3 p0 = p;\n    p.xy -= path(p.z);\n    \n    float dPath = length(p.xy)-38.;\n    \n    vec3 p1 = p;\n    float tnl = 1.5 - length(p.xy*vec2(1.2, 1.96)) + h2;// - (1. - tx)*.25;\n    \n    p.xz = mod(p0.xz+150.,300.)-150.; \n    \n    float dCaps = mix(999., sdVerticalCapsule(p+vec3(45,60,50), 130., 15.) + tx1, step(2500., p0.z));\n    \n    p = p1;\n    p.z = mod(p.z+250.,500.)-250.; \n    \n    float dGate = sdTorus(p.yzx-vec3(25,25,5), vec2(50.,15.))+tx1;\n\tdCaps = mix(dCaps, dGate, step(4600., p0.z));\n            \n    p.xz = mod(p0.xz+450.,900.)-450.;\n    float dCaps2 = sdVerticalCapsule(p+vec3(20,55,0), 100., 30.) + .5*tx;\n        \n    float d4 = smaxP(d - tx*.5+ tnl*.4, .2*tnl, 8.);\n    d3 = mix(d3, d4, smoothstep(.5,1., .5+.5*(sin(p0.z*.001-.8))));\n    \n    d = min(dCaps, smaxP(d3, d4, 10.));\n    float dend = max(p0.y-60., -dPath-.5*tx+.25*tx2);\n    d = mix(d, dend, smoothstep(7000.,9000., p0.z)*smoothstep(12000.,9000., p0.z));\n    d = smaxP(-dCaps2, d,2.);\n            \n    return d;\n}\n\nfloat sdShip(in vec3 p0) {\n    p0 -= vec3(4,0,0);\n    float d = length(p0) -4.;\n    \n    vec3 pRot = p0;\n    pModPolar(pRot.zy, 16.);\n    pRot.x = abs(pRot.x);\n    d = min(d, length(pRot-vec3(2.6,0,3.))-.2);\n\td = min(d, sdBox(pRot-vec3(4.5,0,.8), vec3(.5,.1,.2)));    \n    \n    vec3 p = p0;\n    p.zy = abs(p.zy);\n    p -= vec3(-5.6,2.5,2);\n    pR45(p.yz);\n    pR45(p.xy);\n    return min(d, sdBox(p, vec3(1.,2,.2)));  \n}\n\nfloat sdPath(in vec3 p0) {\n    float d2 = length(path(p0.z)-p0.xy)-.5;\n    return max(d2, -gRO.z + p0.z);\n}\n\nfloat map(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0-vec3(0,0,0));\n    return min(dPath,d); \n}\n\nfloat mapFull(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0,channel);\n    float dPath = sdPath(p0);\n    return min(sdShip((p0-gRO)*gbaseShip),min(dPath,d)); \n}\n\nvec2 min2(vec2 c0, vec2 c1) {\n\treturn c0.x < c1.x ? c0 : c1;\n}\n\nvec2 mapColor(in vec3 p0, sampler2D channel) {\n    float d = sdGround(p0, channel);\n    float dPath = sdPath(p0);\n    return min2(vec2(sdShip((p0-gRO)*gbaseShip), ID_SHIP), \n                min2(vec2(dPath, ID_PATH), vec2(d, ID_GROUND))); \n}\n\n\nfloat logBisectTrace(in vec3 ro, in vec3 rd, sampler2D channel){\n    float t = 0., told = 0., mid, dn;\n    float d = map(rd*t + ro, channel);\n    float sgn = sign(d);\n\n    float lastDistEval = 1e10, lastt = 0.;\n\tvec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n\n    for (int i=0; i<164; i++){\n        if (sign(d) != sgn || d < 0.01 || t > FAR) break;\n \n        told = t;    \n        t += step(d, 1.)*(log(abs(d) + 1.1) - d) + d;\n        \n        d = map(rd*t + ro, channel);\n        d = min(d, sdShip(rdShip*t + roShip));\n        \n        if (d < lastDistEval) {\n            lastt = t;\n            lastDistEval = d;\n        } else {\n            if (d > lastDistEval + 0.0001 &&  lastDistEval/mix(30., lastt, smoothstep(FAR*.75, FAR*.9, t)) < EDGE_WIDTH) {\n            \tgedge = 1.f;\n                if (glastt == 0.) glastt = lastt;\n            }\n            if (d > lastDistEval + 0.0001 && (lastDistEval < EDGE_WIDTH*40. || lastDistEval/lastt < EDGE_WIDTH*2.)) {\n            \tgedge2 = 1.f;\n            }\n\t\t\t//edge = smoothstep(-EDGE_WIDTH,-EDGE_WIDTH*.5f,-(lastDistEval/100.));///lastt));\n\t\t}\n    }\n    if (glastt == 0.)  glastt = lastt;\n\n#ifdef PRECISE\n    // If a threshold was crossed without a solution, use the bisection method.\n    if (sign(d) != sgn){\n    \n        // Based on suggestions from CeeJayDK, with some minor changes.\n\n        dn = sign(map(rd*told + ro, channel));\n        \n        vec2 iv = vec2(told, t); // Near, Far\n\n        // 6 iterations seems to be more than enough, for most cases...\n        // but there's an early exit, so I've added a couple more.\n        for (int ii=0; ii<8; ii++) { \n            //Evaluate midpoint\n            mid = dot(iv, vec2(.5));\n            float d = map(rd*mid + ro, channel);\n            if (abs(d) < 0.001)break;\n            iv = mix(vec2(iv.x, mid), vec2(mid, iv.y), step(0.0, d*dn));\n        }\n\n        t = mid;       \n    }\n#endif\n    \n    return min(t, FAR);\n}\n\n\nvec3 normal(in vec3 p, sampler2D channel) {  \n    vec2 e = vec2(-1, 1)*.001;   \n\treturn normalize(e.yxx*mapFull(p + e.yxx, channel) + e.xxy*mapFull(p + e.xxy, channel) + \n\t\t\t\t\t e.xyx*mapFull(p + e.xyx, channel) + e.yyy*mapFull(p + e.yyy, channel) );   \n}\n\n\nfloat softShadow(in vec3 ro, in vec3 rd, in float start, in float end, in float k, sampler2D channel){\n    ro += rd*hash(ro);\n    vec3 rdShip = rd*gbaseShip;\n\tvec3 roShip = (ro-gRO)*gbaseShip;\n    float shade = 1.;\n    const int maxIterationsShad = 24; \n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = min(map(ro + rd*dist, channel), sdShip(roShip + dist*rdShip));\n        shade = min(shade, smoothstep(0., 1., k*h/dist));\n        dist += clamp(h, .2, stepDist*2.);\n        if (abs(h)<.001 || dist > end) break; \n    }\n    return min(max(shade, 0.) + .1, 1.); \n}\n\n#ifdef WITH_AO\n\nfloat calculateAO( in vec3 p, in vec3 n, float maxDist, sampler2D channel )\n{\n\tfloat ao = 0., l;\n\tconst float nbIte = 6.;\n    for(float i=1.; i< nbIte+.5; i++){\n        l = (i + hash(i))*.5/nbIte*maxDist;\n        ao += (l - mapFull( p + n*l, channel))/(1. + l);\n    }\n    return clamp(1. - ao/nbIte, 0., 1.);\n}\n#endif\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 sunDir){\n\treturn vec3(smoothstep(.97,1.,max(dot(rd, sunDir), 0.)));\n}\n\n// Curve function, by Shadertoy user, Nimitz.\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\nfloat curve(in vec3 p, sampler2D channel){\n    const float eps = .05, amp = 4., ampInit = .5;\n\tvec2 e = vec2(-1, 1)*eps; // 0.05->3.5 - 0.04->5.5 - 0.03->10.->0.1->1.\n    float t1 = mapFull(p + e.yxx, channel), t2 = mapFull(p + e.xxy, channel);\n    float t3 = mapFull(p + e.xyx, channel), t4 = mapFull(p + e.yyy, channel);\n    return clamp((t1 + t2 + t3 + t4 - 4.*mapFull(p, channel))*amp + ampInit, 0., 1.);\n}\n\n\nvec4 render(in vec2 fragCoord, float Time, vec2 Resolution, sampler2D channel){\n        \n    gedge = 0.;\n    gedge2= 0.;\n    glastt = 0.;\n\t\n\t// Screen coordinates.\n\tvec2 u = (fragCoord - Resolution.xy*.5)/Resolution.y;\n    float dBox = sdBox(u, vec2(.5*Resolution.x/Resolution.y-.1,.4));\n    \n    vec3 col = vec3(.2);\n   \tfloat needAA = 0.; \n    float ed = 0., ed2 = 0., lastt1 = 0.;\n    \n    if (dBox <0.){\t\n\n        // Camera Setup.\n        vec3 lookAt = vec3(0, 0, Time*100.);  // \"Look At\" position.\n        vec3 ro = lookAt + vec3(0, 0, -.25); // Camera position, doubling as the ray origin.\n\n        lookAt.xy += path(lookAt.z);\n        ro.xy += path(ro.z);\n        lookAt.y -= .071;\n\n        // Using the above to produce the unit ray-direction vector.\n        float FOV = 3.14159/2.; // FOV - Field of view.\n\n        vec3 forward = normalize(lookAt - ro);\n        vec3 right = normalize(vec3(forward.z, 0, -forward.x )); \n\n        right.xy *= rot2( path(lookAt.z).x/64.);\n        right.xy *= rot2( -.7*cos(Time*.12));\n\n\n        vec3 up = cross(forward, right);\n\n        vec3 rd = normalize(forward + FOV*u.x*right + FOV*u.y*up);\n        vec3 lp = vec3(.5*FAR, FAR, 1.5*FAR) + vec3(0, 0, ro.z);\n\n\n        gRO = ro+vec3(0,0,1);\n        gRO.xy = path(gRO.z);\n        vec3 p2 = vec3(path(gRO.z+1.), gRO.z+1.);\n\n        forward = normalize(p2 - gRO);\n        right = normalize(vec3(forward.z, 0, -forward.x )); \n        right.xy *= rot2( path(lookAt.z).x/32.);\n        up = cross(forward, right);\n        gbaseShip = mat3(forward, up, right);\n\n        float dist = mix(35., 15., smoothstep(7000.,8500., gRO.z));\n        dist = mix(dist, 45., smoothstep(10000.,12000., gRO.z));\n        ro += (dist*(.5+.5*cos(.31*Time))+2.)*vec3(.3,1,-2.);\n        ro.x += .3*dist*cos(.31*Time);\n\n        float t = logBisectTrace(ro, rd, channel);\n        ed = gedge; ed2 = gedge2;  lastt1 = glastt;\n\n\n        vec3 sky = getSky(ro, rd, normalize(lp - ro));\n\n        col = sky;\n\n        vec2 mapCol = mapColor(ro+t*rd, channel);\n\n        vec3 sp;\n\t\tfloat cur;\n        if (t < FAR){\n\n            sp = ro+t*rd; // Surface point.\n            vec3 sn = normal(sp, channel); // Surface normal.\n            vec3 ld = lp-sp;\n            ld /= max(length(ld), 0.001); // Normalize the light direct vector.\n\n            float shd = softShadow(sp, ld, .1, FAR, 8., channel); // Shadows.\n            cur = curve(sp, channel);\n            float curv = cur*.9 +.1; // Surface curvature.\n#ifdef WITH_AO\n            float ao = calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#else\n            float ao = 1.;//calculateAO(sp, sn, 4., channel); // Ambient occlusion.\n#endif\n            float dif = max( dot( ld, sn ), 0.); // Diffuse term.\n            float spe = pow(max( dot( reflect(-ld, sn), -rd ), 0. ), 5.); // Specular term.\n            float fre = clamp(1.0 + dot(rd, sn), 0., 1.); // Fresnel reflection term.\n            float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n            float fre2 = mix(.2, 1., Schlick);  //F0 = .2 - Hard clay... or close enough.\n            float amb = fre*fre2 + .06*ao;        \n\n            col = clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n            col = pow(col, vec3(1.5));\n            col = (col*(dif + .1) + fre2*spe)*shd*ao + amb*col;      \n        }\n\n        col = pow(max(col, 0.), vec3(.75));\n\n        u = fragCoord/Resolution.xy;\n\n        vec3 cGround = vec3(248,210,155)/256.;\n        vec3 cSky = vec3(177,186,213)/256.;\n\n        if (t < FAR){\n            \n            vec3 cFill;\n            if (mapCol.y == ID_PATH) {\n                cFill = vec3(1,.01,0.01);//mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(12.0,12.1,(sp.y)));\n            }\n            else if (mapCol.y == ID_SHIP) {\n               \tvec3 pShip = (sp-gRO)*gbaseShip;\n                cFill = mix(vec3(0,1,1),vec3(.7),smoothstep(.0,.1, pShip.x-1.3));\n            } else {\n                cFill = mix(vec3(248,210,155)/256., vec3(248,185,155)/256., smoothstep(.0,.1,sp.y-8.));\n                cFill = mix(cFill, vec3(1,0,0), .4*smoothstep(1000.,3000., gRO.z));\n            \tvec3 col3 = cos(sp.y*.08+1.1)*clamp(mix(vec3(.8, .5, .3), vec3(.5, .25, .125),(sp.y+1.)*.15), vec3(.5, .25, .125), vec3(1));\n\n                cFill = mix(cFill, col3, .5*smoothstep(6000.,8500., gRO.z));\n            }\n\n            col = mix(cFill,cSky,t/FAR)*(.5+.5*smoothstep(.4,.5,length(col)));\n            col = mix(col, vec3(.0), ed);\n            col = mix(vec3(0), col, .5+.5*smoothstep(.4,.41,cur)); // Surface curvature.;\n            ed2 += cur<.35?1.:0.;\n\n        } else {\n            col = mix(cSky*abs(1.-rd.y),vec3(1),smoothstep(1.3,1.4,length(col)));\n            col = mix(col, vec3(.1), ed);\n        \tfloat sun = max(dot(rd, normalize(lp - ro)), 0.); // Sun strength.\n\t\t\tcol = mix(vec3(0), col, smoothstep(.09/Resolution.y,.2/Resolution.y, abs(sun-.9892)));//.zyx;\t\n        }\n\n        col = mix(col, cSky*abs(1.-rd.y), sqrt(smoothstep(FAR - (ed <0. ? 200. : 100.), FAR, lastt1)));\n        \n    }  \n    \n    // BD frame\n    col = mix(col, vec3(.2),smoothstep(.0,1./Resolution.y,dBox));\n    col = mix(col, vec3(0.),smoothstep(1./Resolution.y,.0,abs(dBox)-.005));\n\n    return vec4(clamp(col, 0., 1.), ed2);\n}\n\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 158, 158, 722]], "test": "untested"}
{"id": "tlsfR4", "name": "Hydrophobic floor", "author": "michael0884", "description": "fluid 3d rendering", "tags": ["particles", "ca"], "likes": 41, "viewed": 747, "published": 3, "date": "1596202367", "time_retrieved": "2024-07-30T20:52:57.147292", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD 400.\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 3.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.8*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.5, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 0.5\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n     // Normalized pixel coordinates \n    pos = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 uv = iMouse.xy/R;\n    vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.3)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    //tracking particle\n    vec4 fp = vec4(R*0.5, 0., 0.);\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 X = ray_march(cam_pos, ray);\n  \n    if(X.w < min_d)\n    {\n        \n        float D = rho(X.xyz);\n        vec3 albedo = 0.5 - 0.5*cos(4.*vec3(1.,1.,1.)*D);\n    \t\n        vec4 N0 = calcNormal(X.xyz, 2.*X.w);\n   \t\tvec3 n = normalize(N0.xyz);\n        vec3 rd = reflect(ray, n);\n        vec3 colA = texture(iChannel2,  rd.yzx).xyz;\n        float K = 1. - pow(max(dot(n,rd),0.), 3.);\n        col.xyz = 8.*albedo + colA*K;\n    }\n    else\n    {    \n        //background\n        col = texture(iChannel2,  ray.yzx);\n    }\n    col = tanh(pow(col, vec4(1.)));\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.5\n#define R iResolution.xy\n\n//mold stuff \n#define sense_ang 0.4\n#define sense_dis 2.5\n#define sense_force 0.\n#define trailing 0.\n#define acceleration 0.0\n\n//SPH pressure\n#define Pressure(rho) 1.*rho*(rho - 0.2)\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = 0.7 + 0.4*smoothstep(0., 0.5, M0.x);\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 1e-6;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        //slime mold sensors\n        float ang = atan(V.y, V.x);\n        vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n        vec2 sd = vec2(P(X + dir.xy).z, P(X + dir.zw).z);\n        F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n\n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n    M *= 0.999;\n   \n    M = mix(M, 0.5, GS((pos - R*0.5 + Dir(iTime)*60.)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [438, 438, 469, 469, 503], [505, 505, 557, 557, 676], [678, 678, 713, 713, 737], [739, 739, 770, 770, 857], [859, 859, 880, 880, 994], [996, 996, 1016, 1016, 1210], [1213, 1213, 1248, 1248, 1433], [1473, 1473, 1505, 1505, 1673], [1675, 1675, 1720, 1762, 2962]], "test": "untested"}
{"id": "wtlfR4", "name": "HSB Colour Twist - TBOS 6.0", "author": "stungeye", "description": "More colour hypnotism. The HSB spectrum plotted Polar and twisted through time.", "tags": ["sin", "color", "rgb", "colour", "colour", "trig", "twist", "hsb"], "likes": 2, "viewed": 436, "published": 3, "date": "1596200410", "time_retrieved": "2024-07-30T20:52:58.020956", "image_code": "#define TWO_PI 6.28318530718\n#define PI 3.1415926535897\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb( in vec3 c ){\n    \n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// Polar plot of the HSB Colour Space.\n// https://thebookofshaders.com/06/\nvoid mainImage(out vec4 fragColor,  // Output (r, g, b, a) pixel color \n               in vec2 fragCoord) { // Input (x, y) image coordinate\n    \n    vec2 st = fragCoord.xy/iResolution.y;\n    \n    vec3 color = vec3(0.0);\n   \n    // Use polar coordinates instead of cartesian\n    vec2 toCenter = vec2(0.5)-st;\n    float radius = length(toCenter)*2.0;\n    float angle = atan(toCenter.y,toCenter.x);\n    \n    // I only added the twist. :)\n    float twist = 10. * (sin(iTime / PI));\n    angle +=  twist * radius; // Rotate according to radius.\n    \n\n    // Map the angle (-PI to PI) to the Hue (from 0 to 1)\n    // and the Saturation to the radius\n    color = hsb2rgb(vec3((angle/TWO_PI)+0.5,radius,1.0));\n\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 131, 157, 157, 340], [342, 417, 524, 557, 1154]], "test": "untested"}
{"id": "tllBR4", "name": "Slime molds 3D", "author": "michael0884", "description": "3d rendering", "tags": ["particles", "ca"], "likes": 42, "viewed": 1070, "published": 3, "date": "1596199441", "time_retrieved": "2024-07-30T20:52:58.911575", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n#define FOV 1.5\n#define RAD 350.\n\nfloat gauss(float x, float r)\n{\n    x/=r;\n    return exp(-x*x);\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat rho(vec3 pos)\n{\n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    vec4 v = P(pos.xy);\n    return v.z;\n}\n\nfloat DE(vec3 pos)\n{\n    float y = 6.*rho(pos);  \n    \n    pos.xy += R*0.5;\n \tpos.xy = mod(pos.xy, R-1.);\n    float de = 1e10;\n    de = min(de, 0.8*sdBox(pos - vec3(R, 4.*y)*0.5, vec3(R*0.51, 3.)));\n    return de;\n}\n\n\nvec4 calcNormal(vec3 p, float dx) {\n\tconst vec3 K = vec3(1,-1,0);\n\treturn  (K.xyyx*DE(p + K.xyy*dx) +\n\t\t\t K.yyxx*DE(p + K.yyx*dx) +\n\t\t\t K.yxyx*DE(p + K.yxy*dx) +\n\t\t\t K.xxxx*DE(p + K.xxx*dx))/vec4(4.*dx,4.*dx,4.*dx,4.);\n}\n\n#define marches 70.\n#define min_d 1.\nvec4 ray_march(vec3 p, vec3 r)\n{\n    float d;\n    for(float i = 0.; i < marches; i++)\n    {\n        d = DE(p); \n        p += r*d;\n        if(d < min_d || d > R.x) break;\n    }\n    return vec4(p, d);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{    \n     // Normalized pixel coordinates \n    pos = (pos - R*0.5)/max(R.x,R.y);\n    \n    vec2 uv = iMouse.xy/R;\n    vec2 angles = vec2(uv.x*2., 0.3*uv.y - 0.4)*PI;\n    \n    vec3 camera_z = vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    vec3 camera_x = normalize(vec3(cos(angles.x+PI*0.5), sin(angles.x+PI*0.5),0.)); \n    vec3 camera_y = -normalize(cross(camera_x,camera_z));\n    \n    //tracking particle\n    vec4 fp = vec4(R*0.5, 0., 0.);\n    \n    vec3 ray = normalize(camera_z + FOV*(pos.x*camera_x + pos.y*camera_y));\n    vec3 cam_pos = vec3(fp.xy-R*0.5, 0.) - RAD*vec3(cos(angles.x)*cos(angles.y),sin(angles.x)*cos(angles.y),sin(angles.y));\n    \n    vec4 X = ray_march(cam_pos, ray);\n  \n    if(X.w < min_d)\n    {\n        \n        float D = rho(X.xyz);\n        vec3 albedo = 0.5 - 0.5*cos(8.*vec3(0.3,0.5,1.)*D);\n    \t\n        vec4 N0 = calcNormal(X.xyz, 2.*X.w);\n   \t\tvec3 n = normalize(N0.xyz);\n        vec3 rd = reflect(ray, n);\n        vec3 colA = texture(iChannel2,  rd.yzx).xyz;\n        vec3 colB = texture(iChannel3,  n.yzx).xyz;\n        float b = clamp(0.5 + 0.5*dot(n, normalize(vec3(1,1,1))), 0.,1.);\n        float K = 1. - pow(max(dot(n,rd),0.), 2.);\n        col.xyz = 1.*albedo*colB + colA*K;\n    }\n    else\n    {    \n        //background\n        col = texture(iChannel2,  ray.yzx);\n    }\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.5\n#define R iResolution.xy\n\n//mold stuff \n#define sense_ang 0.4\n#define sense_dis 2.5\n#define sense_force 0.1\n#define trailing 0.\n#define acceleration 0.01\n\n//SPH pressure\n#define Pressure(rho) 1.*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = 1.3;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 1e-6;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        //slime mold sensors\n        float ang = atan(V.y, V.x);\n        vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n        vec2 sd = vec2(P(X + dir.xy).z, P(X + dir.zw).z);\n        F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n\n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n    M *= 0.997;\n   \n    M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [438, 438, 469, 469, 503], [505, 505, 557, 557, 676], [678, 678, 713, 713, 737], [739, 739, 770, 770, 857], [859, 859, 880, 880, 994], [996, 996, 1016, 1016, 1211], [1214, 1214, 1249, 1249, 1434], [1473, 1473, 1505, 1505, 1673], [1675, 1675, 1720, 1762, 3059]], "test": "untested"}
{"id": "3tXfzN", "name": "Complex Waveforms", "author": "zwegner", "description": "A square/saw/parabolic wave as a sum of positive-frequency complex sinusoids in 3D, with constantly rotating phase. The \"Buffer A\" shader renders a 2-dimensional wavetable (shape based on WAVE in \"Common\"), that the main shader uses for pseudo-raytracing.", "tags": ["squarewave", "dsp"], "likes": 4, "viewed": 456, "published": 3, "date": "1596173383", "time_retrieved": "2024-07-30T20:53:00.452455", "image_code": "// Intersect the o->d ray with a window of the waveform DOWNSAMPLE_FACTOR+1 samples wide, accounting\n// for scaling and rotation. The \"Buffer B\" texture stores min/max real/imaginary values for this\n// window\nbool bbox_intersect(vec3 o, vec3 d, int index, float rotation, float tex_scale, float scale_out) {\n    float u = (float(index) + .5) / tex_scale;\n    vec2 uv = vec2(u, rotation);\n    // One texture sample provides the min/max y/z coordinates of a DOWNSAMPLE_FACTOR-wide\n    // window of segments. Also add a WAVE_SIZE-width fudge factor to the window\n    vec4 s = texture(iChannel1, uv, 0.);\n    float x1 = (float(index) * scale_out) / tex_scale - WAVE_SIZE,\n          x2 = (float(index+DOWNSAMPLE_FACTOR+1) * scale_out) / tex_scale + WAVE_SIZE;\n\n    // Get the two points of intersection of the ray with the\n    // x=[index,index+DOWNSAMPLE_FACTOR+1] planes\n    float t1 = (x1 - o.x) / d.x;\n    vec2 p1 = o.yz + t1 * d.yz;\n    float t2 = (x2 - o.x) / d.x;\n    vec2 p2 = o.yz + t2 * d.yz;\n\n    // The coordinates here are confusing: p1.xy is logically the yz coordinates\n    float min_y = min(p1.x, p2.x), max_y = max(p1.x, p2.x),\n          min_z = min(p1.y, p2.y), max_z = max(p1.y, p2.y);\n\n    // Test bounding box intersection. Note that the sample is (min_y, max_y, min_z, max_z)\n    return (min_y > s.y || max_y < s.x || min_z > s.w || max_z < s.z);\n}\n\n// Sample the waveform texture based on the waveform phase and the rotation\nvoid get_segment(int index, float rotation, out vec3 a, out vec3 b,\n        float tex_scale, float scale_out) {\n    float u = (float(index) + .5) / tex_scale;\n    vec2 uv = vec2(u, rotation);\n    // One texture sample provides the y/z coordinates of two adjacent samples\n    vec4 s = texture(iChannel0, uv, 0.);\n    a = vec3(float(index)   * scale_out / tex_scale, s.xy);\n    b = vec3(float(index+1) * scale_out / tex_scale, s.zw);\n}\n\n// Test intersection of a ray o->d with a cylinder around the x axis of a given\n// radius, returning the x coordinates of the two intersection points if it does\nbool cyl_intersect(vec3 o1, vec3 d1, float radius, out float x1, out float x2) {\n    const vec3 o2 = vec3(0, 0, 0);\n    const vec3 d2 = vec3(1, 0, 0);\n    vec3 n = cross(d1, d2);\n\n    // Quick check that the ray gets closer than the radius\n    float len = abs(dot(normalize(n), o2 - o1));\n    if (len >= radius)\n        return false;\n\n    // Get the nearest point on the ray to the x axis\n    vec3 n2 = cross(d2, n);\n    float t1 = dot(o2 - o1, n2) / dot(d1, n2);\n    vec3 c1 = o1 + t1 * d1;\n\n    // Get the +/-z offsets of where the intersection points would be if the\n    // ray is parallel to the z axis. The ray should always be closer than\n    // the radius here, modulo precision issues...?\n    float z = sqrt(radius*radius - len*len);\n\n    // Use the x/z components of the ray's direction to see how far along the\n    // x axis the intersection points are. We only need the x component, so\n    // we don't care about the angle of the ray's direction about the x axis\n    float xdelta = d1.x * z / d1.z;\n    x1 = c1.x + xdelta;\n    x2 = c1.x - xdelta;\n    return true;\n}\n\n// Find distance and nearest intersection point from the ray o->d to the\n// line or segment a->b (use_clamp=true <=> segment)\nfloat line_dist(vec3 o, vec3 d, vec3 a, vec3 b, bool use_clamp, out vec3 p) {\n    vec3 d2 = b - a;\n    vec3 n = cross(d, d2);\n    vec3 n1 = cross(d, n);\n    // Get the parameter t of the nearest point on the line a+t*b\n    float t2 = dot(o - a, n1) / dot(d2, n1);\n    // If this is just the segment ab, clamp to the endpoints\n    if (use_clamp)\n        t2 = clamp(t2, 0., 1.);\n    p = a + d2 * t2;\n    vec3 po = p - o;\n    float h = dot(po, d) / dot(d, d);\n    return length(po - d*h);\n}\n\nfloat line_distance(vec3 o, vec3 d, vec3 a, vec3 d2, out vec3 p) {\n    return line_dist(o, d, a, a + d2, false, p);\n}\n\nfloat segment_distance(vec3 o, vec3 d, vec3 a, vec3 b, out vec3 p) {\n    return line_dist(o, d, a, b, true, p);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Number of horizontal samples in the rendered waveform texture\n    float TEX_SCALE = iChannelResolution[0].x;\n    // Wavelength scale\n    float SCALE = .5;\n    // Maximum magnitude of complex wave\n    const float BOUND = wavetable[0].x * GAIN + WAVE_SIZE;\n    // Fudge factor for waveform texture lookup to compensate for waveform thickness\n    const int FUDGE = 10;\n\n    // Compute screen coordinates based on the max dimension, to keep coordinates\n    // proportional/square\n    float res = max(iResolution.x, iResolution.y);\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / res;\n\n    // Rotate based on time\n    float rotation = mod(ROTATION_RATE * iTime + .25, 1.);\n\n    // Get camera rotation about the x and y axes from mouse position, in\n    // the form of (z, y)- and (z, x)-coordinate complex numbers\n    vec2 mouse = iMouse.xy / iResolution.xy - .5;\n    // \"Demo mode\" -> move camera if no mouse movement\n    if (iMouse.x == 0. && iMouse.y == 0.) {\n        float tf = clamp((iTime - 3.) / 5., 0., 1.);\n        mouse = vec2(mix(0., .5, tf),\n                mix(0., .015, tf));\n    }\n    vec2 cang = mouse * 3.;\n    vec2 czy = vec2(cos(cang.y), sin(cang.y));\n    vec2 czx = vec2(cos(cang.x), sin(cang.x));\n    // Rotate the screen coordinates by the camera angles, and zoom out\n    vec2 rzy = cmul(vec2(1, uv.y), czy);\n    vec2 rzx = cmul(vec2(rzy.x, uv.x), czx);\n    vec3 ro = CAMERA_DISTANCE * vec3(rzx.y, rzy.y, rzx.x);\n    // Get the camera direction by rotating the y and x axis rotations, negating,\n    // and adding a bit of perspective correction.\n    vec2 crzx = cmul(vec2(czy.x, 0), czx);\n    vec3 cam = vec3(crzx.y, czy.y, crzx.x);\n    vec3 rd = PERSPECTIVE_FACTOR * ro - cam;\n\n    // Find the min/max x/y values of interest by intersecting the ray with\n    // the BOUND-radius cylinder around the x axis. BOUND is the maximum magnitude\n    // of the waveform (always the first sample's real part for us).\n    // The min/max x values dictate how many waveform samples we look at.\n    float cx1, cx2;\n    float min_dist = WAVE_SIZE, min_depth = 1e10;\n    float z = -100.;\n    if (cyl_intersect(ro, rd, BOUND, cx1, cx2)) {\n        float x1 = min(cx1, cx2), x2 = max(cx1, cx2);\n\n        // Translate x values to min/max integer indices. As a small optimization,\n        // we convert based on the texture size (Shadertoy uses the viewport resolution\n        // for render buffers, so we can't just use the waveform size). This means we\n        // only sample each texel once in the loop, and we can use \"nearest\" filtering.\n        // We also add a fudge factor due to the thickness of the waveform lines, and\n        // clamp the max number of samples a pixel will look at so the shader doesn't\n        // completely die if the camera goes too far sideways.\n        int idx_lo = int(x1 * TEX_SCALE / SCALE) - FUDGE,\n            idx_hi = min(int(x2 * TEX_SCALE / SCALE) + FUDGE, idx_lo + MAX_SAMPLES);\n\n        // For each x value with a different texel, sample the texture. We get two\n        // adjacent waveform samples from each texture sample, and use these as endpoints\n        // of a 3D line segment that we check distance from the ray from\n        for (int x = idx_lo; x <= idx_hi; x++) {\n            // First, check if the view ray intersects the bounding box of the wave for\n            // the next DOWNSAMPLE_FACTOR segments\n            if (bbox_intersect(ro, rd, x, rotation, TEX_SCALE, SCALE)) {\n                x += DOWNSAMPLE_FACTOR;\n                continue;\n            }\n            vec3 a, b;\n            get_segment(x, rotation, a, b, TEX_SCALE, SCALE);\n\n            vec3 p;\n            float d = segment_distance(ro, rd, a, b, p);\n            float depth = ro.z - p.z;\n            // Separate min-distance and Z testing\n            if (d < WAVE_SIZE && depth < min_depth) {\n                min_depth = depth;\n                z = p.z;\n            }\n            if (d < min_dist)\n                min_dist = d;\n        }\n    }\n\n    // Compute nearest grid line\n    float grid_dist = 1000.;\n    const int GRID = 1;\n    const int N_GRID_LINES = 40;\n    float gz = -1000.;\n    for (int i = -N_GRID_LINES; i < N_GRID_LINES; i++) {\n        float f = float(i) / float(GRID);\n        // Test grid lines in three dimensions\n        vec3 start[] = vec3[](\n                vec3(f, 0, 0), vec3(0, f, 0), vec3(f, 0, 0));\n        vec3 dir[] = vec3[](\n                vec3(0, 1, 0), vec3(1, 0, 0), vec3(0, 0, 1));\n\n        for (int n = 0; n < 3; n++) {\n            vec3 p;\n            float d = line_distance(ro, rd, start[n], dir[n], p);\n            if (d < grid_dist)\n                grid_dist = d;\n            if (d < GRID_SIZE && p.z < 4. && p.z > gz)\n                gz = p.z;\n        }\n    }\n\n    // Compute final pixel color. This uses some hacky code for basic anti-aliasing\n    // and depth testing. Ideally, we'd compute alpha/color for each grid/waveform\n    // point that touch each ray, and do full blending/depth testing, but that's\n    // complicated and probably quite slow\n    const vec4 grey = vec4(1, 1, 1, 1) * .9;\n    fragColor = vec4(0, 0, 0, 1);\n    // Waveform color, based on the z value found and distance from the center of\n    // the 3d waveform path--we roll off for basic antialiasing\n    float c = z/BOUND + .5;\n    vec4 wcolor = vec4(c, c-.5, 1.-c, 1) * smoothstep(1., 0., min_dist*140. - .9);\n    if (grid_dist < GRID_SIZE && gz > -50. && gz < 4.) {\n        // Break ties (where both grid/waveform are visible) based on the closest\n        if (min_dist < WAVE_SIZE && z > gz)\n            fragColor = wcolor;\n        else {\n            float a = clamp(smoothstep(1., 0., grid_dist*250. - .1), 0., 1.);\n            fragColor = grey * a * 1. / (4. - gz/4.);\n        }\n    } else if (min_dist < WAVE_SIZE)\n        fragColor = wcolor;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv1 = fragCoord / iResolution.xy;\n    vec2 uv2 = (fragCoord + vec2(1, 0)) / iResolution.xy;\n\n    float t = uv1.y * PI * 2.;\n    vec2 rotate = vec2(cos(t), sin(t));\n\n    // We have four channels to store data in, so compute two adjacent samples and\n    // store both as one segment\n    vec2 s1 = get_sample_rot(uv1.x, rotate),\n         s2 = get_sample_rot(uv2.x, rotate);\n\n    fragColor = vec4(s1, s2);\n}", "buffer_a_inputs": [], "common_code": "const float PI = 3.141592653589793;\n\n// Waveform selection\n// WAVE==0 -> square wave\n// WAVE==1 -> saw wave\n// WAVE==2 -> parabolic wave (based on the waveform in\n//\t\thttps://mobile.twitter.com/sigfpe/status/1287956522652205056)\n// WAVE==3 -> stair wave (two octaves of square waves)\n#define WAVE 0\n\n// Waveform size in samples\nconst int SIZE = 1024;\nconst float FSIZE = float(SIZE);\n\n// Scaling factor of complex amplitude for each sample\nconst float GAIN = .125;\n// Waveform rotation in Hz\nconst float ROTATION_RATE = .35;\n// Perspective factor--how much each view ray diverges\nconst float PERSPECTIVE_FACTOR = 0.04;\n// Camera distance\nconst float CAMERA_DISTANCE = 2.5;\n// Grid/waveform thickness\nconst float GRID_SIZE = .003;\nconst float WAVE_SIZE = .010;\n\n// Maximum number of waveform samples to check intersection for each pixel\nconst int MAX_SAMPLES = 80000;\n// Downsampling factor for buffer B min/max extent values\nconst int DOWNSAMPLE_FACTOR = 48;\n\n// Complex multiplication\nvec2 cmul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n// Rest of this file is the raw unrotated wavetable data, and then one function\n// (get_sample_rot()) at the very bottom that depends on the wavetable.\n\nconst vec2 wavetable[SIZE] = vec2[](\n#if WAVE == 0\n\n    vec2(3.754344, 0.000000),\n    vec2(2.930203, 0.925970),\n    vec2(2.535511, 0.709074),\n    vec2(2.349360, 0.837384),\n    vec2(2.197141, 0.746077),\n    vec2(2.090593, 0.816987),\n    vec2(1.996050, 0.759011),\n    vec2(1.921360, 0.808050),\n    vec2(1.852766, 0.765558),\n    vec2(1.795252, 0.803047),\n    vec2(1.741418, 0.769505),\n    vec2(1.694650, 0.799854),\n    vec2(1.650342, 0.772142),\n    vec2(1.610929, 0.797639),\n    vec2(1.573277, 0.774028),\n    vec2(1.539217, 0.796014),\n    vec2(1.506478, 0.775443),\n    vec2(1.476485, 0.794771),\n    vec2(1.447521, 0.776544),\n    vec2(1.420724, 0.793789),\n    vec2(1.394751, 0.777424),\n    vec2(1.370532, 0.792995),\n    vec2(1.346985, 0.778145),\n    vec2(1.324888, 0.792338),\n    vec2(1.303352, 0.778745),\n    vec2(1.283032, 0.791787),\n    vec2(1.263186, 0.779253),\n    vec2(1.244376, 0.791318),\n    vec2(1.225972, 0.779687),\n    vec2(1.208461, 0.790914),\n    vec2(1.191302, 0.780064),\n    vec2(1.174919, 0.790562),\n    vec2(1.158844, 0.780393),\n    vec2(1.143451, 0.790253),\n    vec2(1.128329, 0.780684),\n    vec2(1.113811, 0.789980),\n    vec2(1.099534, 0.780942),\n    vec2(1.085795, 0.789736),\n    vec2(1.072271, 0.781172),\n    vec2(1.059229, 0.789518),\n    vec2(1.046381, 0.781380),\n    vec2(1.033968, 0.789321),\n    vec2(1.021730, 0.781567),\n    vec2(1.009886, 0.789142),\n    vec2(0.998200, 0.781737),\n    vec2(0.986874, 0.788980),\n    vec2(0.975692, 0.781892),\n    vec2(0.964838, 0.788832),\n    vec2(0.954116, 0.782034),\n    vec2(0.943695, 0.788695),\n    vec2(0.933396, 0.782165),\n    vec2(0.923374, 0.788570),\n    vec2(0.913463, 0.782285),\n    vec2(0.903809, 0.788454),\n    vec2(0.894258, 0.782396),\n    vec2(0.884944, 0.788347),\n    vec2(0.875726, 0.782500),\n    vec2(0.866727, 0.788248),\n    vec2(0.857818, 0.782595),\n    vec2(0.849114, 0.788155),\n    vec2(0.840492, 0.782685),\n    vec2(0.832062, 0.788069),\n    vec2(0.823709, 0.782768),\n    vec2(0.815535, 0.787988),\n    vec2(0.807433, 0.782846),\n    vec2(0.799499, 0.787913),\n    vec2(0.791633, 0.782920),\n    vec2(0.783923, 0.787842),\n    vec2(0.776278, 0.782988),\n    vec2(0.768780, 0.787775),\n    vec2(0.761343, 0.783053),\n    vec2(0.754044, 0.787712),\n    vec2(0.746802, 0.783114),\n    vec2(0.739691, 0.787653),\n    vec2(0.732634, 0.783172),\n    vec2(0.725701, 0.787597),\n    vec2(0.718818, 0.783226),\n    vec2(0.712052, 0.787544),\n    vec2(0.705335, 0.783278),\n    vec2(0.698728, 0.787494),\n    vec2(0.692167, 0.783327),\n    vec2(0.685710, 0.787446),\n    vec2(0.679297, 0.783373),\n    vec2(0.672984, 0.787401),\n    vec2(0.666712, 0.783417),\n    vec2(0.660535, 0.787358),\n    vec2(0.654396, 0.783459),\n    vec2(0.648348, 0.787317),\n    vec2(0.642337, 0.783499),\n    vec2(0.636412, 0.787278),\n    vec2(0.630522, 0.783537),\n    vec2(0.624715, 0.787241),\n    vec2(0.618941, 0.783573),\n    vec2(0.613245, 0.787206),\n    vec2(0.607581, 0.783607),\n    vec2(0.601992, 0.787172),\n    vec2(0.596434, 0.783640),\n    vec2(0.590947, 0.787140),\n    vec2(0.585490, 0.783672),\n    vec2(0.580101, 0.787109),\n    vec2(0.574740, 0.783702),\n    vec2(0.569444, 0.787080),\n    vec2(0.564175, 0.783731),\n    vec2(0.558969, 0.787051),\n    vec2(0.553789, 0.783759),\n    vec2(0.548668, 0.787024),\n    vec2(0.543573, 0.783785),\n    vec2(0.538534, 0.786998),\n    vec2(0.533520, 0.783811),\n    vec2(0.528561, 0.786973),\n    vec2(0.523624, 0.783835),\n    vec2(0.518741, 0.786949),\n    vec2(0.513879, 0.783859),\n    vec2(0.509068, 0.786926),\n    vec2(0.504278, 0.783881),\n    vec2(0.499537, 0.786904),\n    vec2(0.494817, 0.783903),\n    vec2(0.490143, 0.786883),\n    vec2(0.485489, 0.783924),\n    vec2(0.480880, 0.786862),\n    vec2(0.476289, 0.783944),\n    vec2(0.471743, 0.786843),\n    vec2(0.467214, 0.783963),\n    vec2(0.462727, 0.786824),\n    vec2(0.458257, 0.783982),\n    vec2(0.453828, 0.786805),\n    vec2(0.449415, 0.784000),\n    vec2(0.445042, 0.786788),\n    vec2(0.440684, 0.784017),\n    vec2(0.436364, 0.786771),\n    vec2(0.432059, 0.784034),\n    vec2(0.427791, 0.786754),\n    vec2(0.423537, 0.784050),\n    vec2(0.419318, 0.786739),\n    vec2(0.415114, 0.784065),\n    vec2(0.410943, 0.786724),\n    vec2(0.406786, 0.784080),\n    vec2(0.402662, 0.786709),\n    vec2(0.398551, 0.784095),\n    vec2(0.394471, 0.786695),\n    vec2(0.390404, 0.784108),\n    vec2(0.386367, 0.786681),\n    vec2(0.382343, 0.784122),\n    vec2(0.378348, 0.786668),\n    vec2(0.374365, 0.784135),\n    vec2(0.370410, 0.786655),\n    vec2(0.366467, 0.784147),\n    vec2(0.362551, 0.786643),\n    vec2(0.358646, 0.784159),\n    vec2(0.354767, 0.786631),\n    vec2(0.350900, 0.784171),\n    vec2(0.347057, 0.786620),\n    vec2(0.343225, 0.784182),\n    vec2(0.339418, 0.786608),\n    vec2(0.335621, 0.784193),\n    vec2(0.331847, 0.786598),\n    vec2(0.328083, 0.784204),\n    vec2(0.324342, 0.786587),\n    vec2(0.320610, 0.784214),\n    vec2(0.316900, 0.786578),\n    vec2(0.313200, 0.784224),\n    vec2(0.309521, 0.786568),\n    vec2(0.305850, 0.784233),\n    vec2(0.302200, 0.786559),\n    vec2(0.298559, 0.784242),\n    vec2(0.294937, 0.786550),\n    vec2(0.291324, 0.784251),\n    vec2(0.287730, 0.786541),\n    vec2(0.284144, 0.784260),\n    vec2(0.280576, 0.786533),\n    vec2(0.277016, 0.784268),\n    vec2(0.273474, 0.786524),\n    vec2(0.269939, 0.784276),\n    vec2(0.266422, 0.786517),\n    vec2(0.262912, 0.784283),\n    vec2(0.259418, 0.786509),\n    vec2(0.255931, 0.784291),\n    vec2(0.252460, 0.786502),\n    vec2(0.248996, 0.784298),\n    vec2(0.245548, 0.786495),\n    vec2(0.242105, 0.784305),\n    vec2(0.238678, 0.786488),\n    vec2(0.235257, 0.784311),\n    vec2(0.231850, 0.786482),\n    vec2(0.228450, 0.784318),\n    vec2(0.225063, 0.786475),\n    vec2(0.221681, 0.784324),\n    vec2(0.218314, 0.786469),\n    vec2(0.214951, 0.784330),\n    vec2(0.211602, 0.786463),\n    vec2(0.208258, 0.784336),\n    vec2(0.204926, 0.786458),\n    vec2(0.201599, 0.784341),\n    vec2(0.198284, 0.786453),\n    vec2(0.194974, 0.784346),\n    vec2(0.191676, 0.786447),\n    vec2(0.188382, 0.784351),\n    vec2(0.185099, 0.786442),\n    vec2(0.181821, 0.784356),\n    vec2(0.178553, 0.786438),\n    vec2(0.175289, 0.784361),\n    vec2(0.172036, 0.786433),\n    vec2(0.168787, 0.784365),\n    vec2(0.165547, 0.786429),\n    vec2(0.162311, 0.784370),\n    vec2(0.159085, 0.786425),\n    vec2(0.155862, 0.784374),\n    vec2(0.152648, 0.786421),\n    vec2(0.149438, 0.784378),\n    vec2(0.146236, 0.786417),\n    vec2(0.143038, 0.784381),\n    vec2(0.139847, 0.786413),\n    vec2(0.136660, 0.784385),\n    vec2(0.133481, 0.786410),\n    vec2(0.130304, 0.784388),\n    vec2(0.127135, 0.786406),\n    vec2(0.123969, 0.784391),\n    vec2(0.120810, 0.786403),\n    vec2(0.117653, 0.784394),\n    vec2(0.114503, 0.786400),\n    vec2(0.111355, 0.784397),\n    vec2(0.108214, 0.786398),\n    vec2(0.105075, 0.784400),\n    vec2(0.101942, 0.786395),\n    vec2(0.098811, 0.784402),\n    vec2(0.095686, 0.786393),\n    vec2(0.092563, 0.784405),\n    vec2(0.089445, 0.786390),\n    vec2(0.086328, 0.784407),\n    vec2(0.083217, 0.786388),\n    vec2(0.080107, 0.784409),\n    vec2(0.077002, 0.786386),\n    vec2(0.073898, 0.784411),\n    vec2(0.070799, 0.786385),\n    vec2(0.067701, 0.784413),\n    vec2(0.064606, 0.786383),\n    vec2(0.061514, 0.784414),\n    vec2(0.058424, 0.786381),\n    vec2(0.055336, 0.784416),\n    vec2(0.052250, 0.786380),\n    vec2(0.049166, 0.784417),\n    vec2(0.046085, 0.786379),\n    vec2(0.043004, 0.784418),\n    vec2(0.039926, 0.786378),\n    vec2(0.036849, 0.784419),\n    vec2(0.033773, 0.786377),\n    vec2(0.030699, 0.784420),\n    vec2(0.027626, 0.786376),\n    vec2(0.024553, 0.784420),\n    vec2(0.021482, 0.786376),\n    vec2(0.018412, 0.784421),\n    vec2(0.015342, 0.786375),\n    vec2(0.012273, 0.784421),\n    vec2(0.009204, 0.786375),\n    vec2(0.006136, 0.784422),\n    vec2(0.003068, 0.786375),\n    vec2(0.000000, 0.784422),\n    vec2(-0.003068, 0.786375),\n    vec2(-0.006136, 0.784422),\n    vec2(-0.009204, 0.786375),\n    vec2(-0.012273, 0.784421),\n    vec2(-0.015342, 0.786375),\n    vec2(-0.018412, 0.784421),\n    vec2(-0.021482, 0.786376),\n    vec2(-0.024553, 0.784420),\n    vec2(-0.027626, 0.786376),\n    vec2(-0.030699, 0.784420),\n    vec2(-0.033773, 0.786377),\n    vec2(-0.036849, 0.784419),\n    vec2(-0.039926, 0.786378),\n    vec2(-0.043004, 0.784418),\n    vec2(-0.046085, 0.786379),\n    vec2(-0.049166, 0.784417),\n    vec2(-0.052250, 0.786380),\n    vec2(-0.055336, 0.784416),\n    vec2(-0.058424, 0.786381),\n    vec2(-0.061514, 0.784414),\n    vec2(-0.064606, 0.786383),\n    vec2(-0.067701, 0.784413),\n    vec2(-0.070799, 0.786385),\n    vec2(-0.073898, 0.784411),\n    vec2(-0.077002, 0.786386),\n    vec2(-0.080107, 0.784409),\n    vec2(-0.083217, 0.786388),\n    vec2(-0.086328, 0.784407),\n    vec2(-0.089445, 0.786390),\n    vec2(-0.092563, 0.784405),\n    vec2(-0.095686, 0.786393),\n    vec2(-0.098811, 0.784402),\n    vec2(-0.101942, 0.786395),\n    vec2(-0.105075, 0.784400),\n    vec2(-0.108214, 0.786398),\n    vec2(-0.111355, 0.784397),\n    vec2(-0.114503, 0.786400),\n    vec2(-0.117653, 0.784394),\n    vec2(-0.120810, 0.786403),\n    vec2(-0.123969, 0.784391),\n    vec2(-0.127135, 0.786406),\n    vec2(-0.130304, 0.784388),\n    vec2(-0.133481, 0.786410),\n    vec2(-0.136660, 0.784385),\n    vec2(-0.139847, 0.786413),\n    vec2(-0.143038, 0.784381),\n    vec2(-0.146236, 0.786417),\n    vec2(-0.149438, 0.784378),\n    vec2(-0.152648, 0.786421),\n    vec2(-0.155862, 0.784374),\n    vec2(-0.159085, 0.786425),\n    vec2(-0.162311, 0.784370),\n    vec2(-0.165547, 0.786429),\n    vec2(-0.168787, 0.784365),\n    vec2(-0.172036, 0.786433),\n    vec2(-0.175289, 0.784361),\n    vec2(-0.178553, 0.786438),\n    vec2(-0.181821, 0.784356),\n    vec2(-0.185099, 0.786442),\n    vec2(-0.188382, 0.784351),\n    vec2(-0.191676, 0.786447),\n    vec2(-0.194974, 0.784346),\n    vec2(-0.198284, 0.786453),\n    vec2(-0.201599, 0.784341),\n    vec2(-0.204926, 0.786458),\n    vec2(-0.208258, 0.784336),\n    vec2(-0.211602, 0.786463),\n    vec2(-0.214951, 0.784330),\n    vec2(-0.218314, 0.786469),\n    vec2(-0.221681, 0.784324),\n    vec2(-0.225063, 0.786475),\n    vec2(-0.228450, 0.784318),\n    vec2(-0.231850, 0.786482),\n    vec2(-0.235257, 0.784311),\n    vec2(-0.238678, 0.786488),\n    vec2(-0.242105, 0.784305),\n    vec2(-0.245548, 0.786495),\n    vec2(-0.248996, 0.784298),\n    vec2(-0.252460, 0.786502),\n    vec2(-0.255931, 0.784291),\n    vec2(-0.259418, 0.786509),\n    vec2(-0.262912, 0.784283),\n    vec2(-0.266422, 0.786517),\n    vec2(-0.269939, 0.784276),\n    vec2(-0.273474, 0.786524),\n    vec2(-0.277016, 0.784268),\n    vec2(-0.280576, 0.786533),\n    vec2(-0.284144, 0.784260),\n    vec2(-0.287730, 0.786541),\n    vec2(-0.291324, 0.784251),\n    vec2(-0.294937, 0.786550),\n    vec2(-0.298559, 0.784242),\n    vec2(-0.302200, 0.786559),\n    vec2(-0.305850, 0.784233),\n    vec2(-0.309521, 0.786568),\n    vec2(-0.313200, 0.784224),\n    vec2(-0.316900, 0.786578),\n    vec2(-0.320610, 0.784214),\n    vec2(-0.324342, 0.786587),\n    vec2(-0.328083, 0.784204),\n    vec2(-0.331847, 0.786598),\n    vec2(-0.335621, 0.784193),\n    vec2(-0.339418, 0.786608),\n    vec2(-0.343225, 0.784182),\n    vec2(-0.347057, 0.786620),\n    vec2(-0.350900, 0.784171),\n    vec2(-0.354767, 0.786631),\n    vec2(-0.358646, 0.784159),\n    vec2(-0.362551, 0.786643),\n    vec2(-0.366467, 0.784147),\n    vec2(-0.370410, 0.786655),\n    vec2(-0.374365, 0.784135),\n    vec2(-0.378348, 0.786668),\n    vec2(-0.382343, 0.784122),\n    vec2(-0.386367, 0.786681),\n    vec2(-0.390404, 0.784108),\n    vec2(-0.394471, 0.786695),\n    vec2(-0.398551, 0.784095),\n    vec2(-0.402662, 0.786709),\n    vec2(-0.406786, 0.784080),\n    vec2(-0.410943, 0.786724),\n    vec2(-0.415114, 0.784065),\n    vec2(-0.419318, 0.786739),\n    vec2(-0.423537, 0.784050),\n    vec2(-0.427791, 0.786754),\n    vec2(-0.432059, 0.784034),\n    vec2(-0.436364, 0.786771),\n    vec2(-0.440684, 0.784017),\n    vec2(-0.445042, 0.786788),\n    vec2(-0.449415, 0.784000),\n    vec2(-0.453828, 0.786805),\n    vec2(-0.458257, 0.783982),\n    vec2(-0.462727, 0.786824),\n    vec2(-0.467214, 0.783963),\n    vec2(-0.471743, 0.786843),\n    vec2(-0.476289, 0.783944),\n    vec2(-0.480880, 0.786862),\n    vec2(-0.485489, 0.783924),\n    vec2(-0.490143, 0.786883),\n    vec2(-0.494817, 0.783903),\n    vec2(-0.499537, 0.786904),\n    vec2(-0.504278, 0.783881),\n    vec2(-0.509068, 0.786926),\n    vec2(-0.513879, 0.783859),\n    vec2(-0.518741, 0.786949),\n    vec2(-0.523624, 0.783835),\n    vec2(-0.528561, 0.786973),\n    vec2(-0.533520, 0.783811),\n    vec2(-0.538534, 0.786998),\n    vec2(-0.543573, 0.783785),\n    vec2(-0.548668, 0.787024),\n    vec2(-0.553789, 0.783759),\n    vec2(-0.558969, 0.787051),\n    vec2(-0.564175, 0.783731),\n    vec2(-0.569444, 0.787080),\n    vec2(-0.574740, 0.783702),\n    vec2(-0.580101, 0.787109),\n    vec2(-0.585490, 0.783672),\n    vec2(-0.590947, 0.787140),\n    vec2(-0.596434, 0.783640),\n    vec2(-0.601992, 0.787172),\n    vec2(-0.607581, 0.783607),\n    vec2(-0.613245, 0.787206),\n    vec2(-0.618941, 0.783573),\n    vec2(-0.624715, 0.787241),\n    vec2(-0.630522, 0.783537),\n    vec2(-0.636412, 0.787278),\n    vec2(-0.642337, 0.783499),\n    vec2(-0.648348, 0.787317),\n    vec2(-0.654396, 0.783459),\n    vec2(-0.660535, 0.787358),\n    vec2(-0.666712, 0.783417),\n    vec2(-0.672984, 0.787401),\n    vec2(-0.679297, 0.783373),\n    vec2(-0.685710, 0.787446),\n    vec2(-0.692167, 0.783327),\n    vec2(-0.698728, 0.787494),\n    vec2(-0.705335, 0.783278),\n    vec2(-0.712052, 0.787544),\n    vec2(-0.718818, 0.783226),\n    vec2(-0.725701, 0.787597),\n    vec2(-0.732634, 0.783172),\n    vec2(-0.739691, 0.787653),\n    vec2(-0.746802, 0.783114),\n    vec2(-0.754044, 0.787712),\n    vec2(-0.761343, 0.783053),\n    vec2(-0.768780, 0.787775),\n    vec2(-0.776278, 0.782988),\n    vec2(-0.783923, 0.787842),\n    vec2(-0.791633, 0.782920),\n    vec2(-0.799499, 0.787913),\n    vec2(-0.807433, 0.782846),\n    vec2(-0.815535, 0.787988),\n    vec2(-0.823709, 0.782768),\n    vec2(-0.832062, 0.788069),\n    vec2(-0.840492, 0.782685),\n    vec2(-0.849114, 0.788155),\n    vec2(-0.857818, 0.782595),\n    vec2(-0.866727, 0.788248),\n    vec2(-0.875726, 0.782500),\n    vec2(-0.884944, 0.788347),\n    vec2(-0.894258, 0.782396),\n    vec2(-0.903809, 0.788454),\n    vec2(-0.913463, 0.782285),\n    vec2(-0.923374, 0.788570),\n    vec2(-0.933396, 0.782165),\n    vec2(-0.943695, 0.788695),\n    vec2(-0.954116, 0.782034),\n    vec2(-0.964838, 0.788832),\n    vec2(-0.975692, 0.781892),\n    vec2(-0.986874, 0.788980),\n    vec2(-0.998200, 0.781737),\n    vec2(-1.009886, 0.789142),\n    vec2(-1.021730, 0.781567),\n    vec2(-1.033968, 0.789321),\n    vec2(-1.046381, 0.781380),\n    vec2(-1.059229, 0.789518),\n    vec2(-1.072271, 0.781172),\n    vec2(-1.085795, 0.789736),\n    vec2(-1.099534, 0.780942),\n    vec2(-1.113811, 0.789980),\n    vec2(-1.128329, 0.780684),\n    vec2(-1.143451, 0.790253),\n    vec2(-1.158844, 0.780393),\n    vec2(-1.174919, 0.790562),\n    vec2(-1.191302, 0.780064),\n    vec2(-1.208461, 0.790914),\n    vec2(-1.225972, 0.779687),\n    vec2(-1.244376, 0.791318),\n    vec2(-1.263186, 0.779253),\n    vec2(-1.283032, 0.791787),\n    vec2(-1.303352, 0.778745),\n    vec2(-1.324888, 0.792338),\n    vec2(-1.346985, 0.778145),\n    vec2(-1.370532, 0.792995),\n    vec2(-1.394751, 0.777424),\n    vec2(-1.420724, 0.793789),\n    vec2(-1.447521, 0.776544),\n    vec2(-1.476485, 0.794771),\n    vec2(-1.506478, 0.775443),\n    vec2(-1.539217, 0.796014),\n    vec2(-1.573277, 0.774028),\n    vec2(-1.610929, 0.797639),\n    vec2(-1.650342, 0.772142),\n    vec2(-1.694650, 0.799854),\n    vec2(-1.741418, 0.769505),\n    vec2(-1.795252, 0.803047),\n    vec2(-1.852766, 0.765558),\n    vec2(-1.921360, 0.808050),\n    vec2(-1.996050, 0.759011),\n    vec2(-2.090593, 0.816987),\n    vec2(-2.197141, 0.746077),\n    vec2(-2.349360, 0.837384),\n    vec2(-2.535511, 0.709074),\n    vec2(-2.930203, 0.925970),\n    vec2(-3.754344, 0.000000),\n    vec2(-2.930203, -0.925970),\n    vec2(-2.535511, -0.709074),\n    vec2(-2.349360, -0.837384),\n    vec2(-2.197141, -0.746077),\n    vec2(-2.090593, -0.816987),\n    vec2(-1.996050, -0.759011),\n    vec2(-1.921360, -0.808050),\n    vec2(-1.852766, -0.765558),\n    vec2(-1.795252, -0.803047),\n    vec2(-1.741418, -0.769505),\n    vec2(-1.694650, -0.799854),\n    vec2(-1.650342, -0.772142),\n    vec2(-1.610929, -0.797639),\n    vec2(-1.573277, -0.774028),\n    vec2(-1.539217, -0.796014),\n    vec2(-1.506478, -0.775443),\n    vec2(-1.476485, -0.794771),\n    vec2(-1.447521, -0.776544),\n    vec2(-1.420724, -0.793789),\n    vec2(-1.394751, -0.777424),\n    vec2(-1.370532, -0.792995),\n    vec2(-1.346985, -0.778145),\n    vec2(-1.324888, -0.792338),\n    vec2(-1.303352, -0.778745),\n    vec2(-1.283032, -0.791787),\n    vec2(-1.263186, -0.779253),\n    vec2(-1.244376, -0.791318),\n    vec2(-1.225972, -0.779687),\n    vec2(-1.208461, -0.790914),\n    vec2(-1.191302, -0.780064),\n    vec2(-1.174919, -0.790562),\n    vec2(-1.158844, -0.780393),\n    vec2(-1.143451, -0.790253),\n    vec2(-1.128329, -0.780684),\n    vec2(-1.113811, -0.789980),\n    vec2(-1.099534, -0.780942),\n    vec2(-1.085795, -0.789736),\n    vec2(-1.072271, -0.781172),\n    vec2(-1.059229, -0.789518),\n    vec2(-1.046381, -0.781380),\n    vec2(-1.033968, -0.789321),\n    vec2(-1.021730, -0.781567),\n    vec2(-1.009886, -0.789142),\n    vec2(-0.998200, -0.781737),\n    vec2(-0.986874, -0.788980),\n    vec2(-0.975692, -0.781892),\n    vec2(-0.964838, -0.788832),\n    vec2(-0.954116, -0.782034),\n    vec2(-0.943695, -0.788695),\n    vec2(-0.933396, -0.782165),\n    vec2(-0.923374, -0.788570),\n    vec2(-0.913463, -0.782285),\n    vec2(-0.903809, -0.788454),\n    vec2(-0.894258, -0.782396),\n    vec2(-0.884944, -0.788347),\n    vec2(-0.875726, -0.782500),\n    vec2(-0.866727, -0.788248),\n    vec2(-0.857818, -0.782595),\n    vec2(-0.849114, -0.788155),\n    vec2(-0.840492, -0.782685),\n    vec2(-0.832062, -0.788069),\n    vec2(-0.823709, -0.782768),\n    vec2(-0.815535, -0.787988),\n    vec2(-0.807433, -0.782846),\n    vec2(-0.799499, -0.787913),\n    vec2(-0.791633, -0.782920),\n    vec2(-0.783923, -0.787842),\n    vec2(-0.776278, -0.782988),\n    vec2(-0.768780, -0.787775),\n    vec2(-0.761343, -0.783053),\n    vec2(-0.754044, -0.787712),\n    vec2(-0.746802, -0.783114),\n    vec2(-0.739691, -0.787653),\n    vec2(-0.732634, -0.783172),\n    vec2(-0.725701, -0.787597),\n    vec2(-0.718818, -0.783226),\n    vec2(-0.712052, -0.787544),\n    vec2(-0.705335, -0.783278),\n    vec2(-0.698728, -0.787494),\n    vec2(-0.692167, -0.783327),\n    vec2(-0.685710, -0.787446),\n    vec2(-0.679297, -0.783373),\n    vec2(-0.672984, -0.787401),\n    vec2(-0.666712, -0.783417),\n    vec2(-0.660535, -0.787358),\n    vec2(-0.654396, -0.783459),\n    vec2(-0.648348, -0.787317),\n    vec2(-0.642337, -0.783499),\n    vec2(-0.636412, -0.787278),\n    vec2(-0.630522, -0.783537),\n    vec2(-0.624715, -0.787241),\n    vec2(-0.618941, -0.783573),\n    vec2(-0.613245, -0.787206),\n    vec2(-0.607581, -0.783607),\n    vec2(-0.601992, -0.787172),\n    vec2(-0.596434, -0.783640),\n    vec2(-0.590947, -0.787140),\n    vec2(-0.585490, -0.783672),\n    vec2(-0.580101, -0.787109),\n    vec2(-0.574740, -0.783702),\n    vec2(-0.569444, -0.787080),\n    vec2(-0.564175, -0.783731),\n    vec2(-0.558969, -0.787051),\n    vec2(-0.553789, -0.783759),\n    vec2(-0.548668, -0.787024),\n    vec2(-0.543573, -0.783785),\n    vec2(-0.538534, -0.786998),\n    vec2(-0.533520, -0.783811),\n    vec2(-0.528561, -0.786973),\n    vec2(-0.523624, -0.783835),\n    vec2(-0.518741, -0.786949),\n    vec2(-0.513879, -0.783859),\n    vec2(-0.509068, -0.786926),\n    vec2(-0.504278, -0.783881),\n    vec2(-0.499537, -0.786904),\n    vec2(-0.494817, -0.783903),\n    vec2(-0.490143, -0.786883),\n    vec2(-0.485489, -0.783924),\n    vec2(-0.480880, -0.786862),\n    vec2(-0.476289, -0.783944),\n    vec2(-0.471743, -0.786843),\n    vec2(-0.467214, -0.783963),\n    vec2(-0.462727, -0.786824),\n    vec2(-0.458257, -0.783982),\n    vec2(-0.453828, -0.786805),\n    vec2(-0.449415, -0.784000),\n    vec2(-0.445042, -0.786788),\n    vec2(-0.440684, -0.784017),\n    vec2(-0.436364, -0.786771),\n    vec2(-0.432059, -0.784034),\n    vec2(-0.427791, -0.786754),\n    vec2(-0.423537, -0.784050),\n    vec2(-0.419318, -0.786739),\n    vec2(-0.415114, -0.784065),\n    vec2(-0.410943, -0.786724),\n    vec2(-0.406786, -0.784080),\n    vec2(-0.402662, -0.786709),\n    vec2(-0.398551, -0.784095),\n    vec2(-0.394471, -0.786695),\n    vec2(-0.390404, -0.784108),\n    vec2(-0.386367, -0.786681),\n    vec2(-0.382343, -0.784122),\n    vec2(-0.378348, -0.786668),\n    vec2(-0.374365, -0.784135),\n    vec2(-0.370410, -0.786655),\n    vec2(-0.366467, -0.784147),\n    vec2(-0.362551, -0.786643),\n    vec2(-0.358646, -0.784159),\n    vec2(-0.354767, -0.786631),\n    vec2(-0.350900, -0.784171),\n    vec2(-0.347057, -0.786620),\n    vec2(-0.343225, -0.784182),\n    vec2(-0.339418, -0.786608),\n    vec2(-0.335621, -0.784193),\n    vec2(-0.331847, -0.786598),\n    vec2(-0.328083, -0.784204),\n    vec2(-0.324342, -0.786587),\n    vec2(-0.320610, -0.784214),\n    vec2(-0.316900, -0.786578),\n    vec2(-0.313200, -0.784224),\n    vec2(-0.309521, -0.786568),\n    vec2(-0.305850, -0.784233),\n    vec2(-0.302200, -0.786559),\n    vec2(-0.298559, -0.784242),\n    vec2(-0.294937, -0.786550),\n    vec2(-0.291324, -0.784251),\n    vec2(-0.287730, -0.786541),\n    vec2(-0.284144, -0.784260),\n    vec2(-0.280576, -0.786533),\n    vec2(-0.277016, -0.784268),\n    vec2(-0.273474, -0.786524),\n    vec2(-0.269939, -0.784276),\n    vec2(-0.266422, -0.786517),\n    vec2(-0.262912, -0.784283),\n    vec2(-0.259418, -0.786509),\n    vec2(-0.255931, -0.784291),\n    vec2(-0.252460, -0.786502),\n    vec2(-0.248996, -0.784298),\n    vec2(-0.245548, -0.786495),\n    vec2(-0.242105, -0.784305),\n    vec2(-0.238678, -0.786488),\n    vec2(-0.235257, -0.784311),\n    vec2(-0.231850, -0.786482),\n    vec2(-0.228450, -0.784318),\n    vec2(-0.225063, -0.786475),\n    vec2(-0.221681, -0.784324),\n    vec2(-0.218314, -0.786469),\n    vec2(-0.214951, -0.784330),\n    vec2(-0.211602, -0.786463),\n    vec2(-0.208258, -0.784336),\n    vec2(-0.204926, -0.786458),\n    vec2(-0.201599, -0.784341),\n    vec2(-0.198284, -0.786453),\n    vec2(-0.194974, -0.784346),\n    vec2(-0.191676, -0.786447),\n    vec2(-0.188382, -0.784351),\n    vec2(-0.185099, -0.786442),\n    vec2(-0.181821, -0.784356),\n    vec2(-0.178553, -0.786438),\n    vec2(-0.175289, -0.784361),\n    vec2(-0.172036, -0.786433),\n    vec2(-0.168787, -0.784365),\n    vec2(-0.165547, -0.786429),\n    vec2(-0.162311, -0.784370),\n    vec2(-0.159085, -0.786425),\n    vec2(-0.155862, -0.784374),\n    vec2(-0.152648, -0.786421),\n    vec2(-0.149438, -0.784378),\n    vec2(-0.146236, -0.786417),\n    vec2(-0.143038, -0.784381),\n    vec2(-0.139847, -0.786413),\n    vec2(-0.136660, -0.784385),\n    vec2(-0.133481, -0.786410),\n    vec2(-0.130304, -0.784388),\n    vec2(-0.127135, -0.786406),\n    vec2(-0.123969, -0.784391),\n    vec2(-0.120810, -0.786403),\n    vec2(-0.117653, -0.784394),\n    vec2(-0.114503, -0.786400),\n    vec2(-0.111355, -0.784397),\n    vec2(-0.108214, -0.786398),\n    vec2(-0.105075, -0.784400),\n    vec2(-0.101942, -0.786395),\n    vec2(-0.098811, -0.784402),\n    vec2(-0.095686, -0.786393),\n    vec2(-0.092563, -0.784405),\n    vec2(-0.089445, -0.786390),\n    vec2(-0.086328, -0.784407),\n    vec2(-0.083217, -0.786388),\n    vec2(-0.080107, -0.784409),\n    vec2(-0.077002, -0.786386),\n    vec2(-0.073898, -0.784411),\n    vec2(-0.070799, -0.786385),\n    vec2(-0.067701, -0.784413),\n    vec2(-0.064606, -0.786383),\n    vec2(-0.061514, -0.784414),\n    vec2(-0.058424, -0.786381),\n    vec2(-0.055336, -0.784416),\n    vec2(-0.052250, -0.786380),\n    vec2(-0.049166, -0.784417),\n    vec2(-0.046085, -0.786379),\n    vec2(-0.043004, -0.784418),\n    vec2(-0.039926, -0.786378),\n    vec2(-0.036849, -0.784419),\n    vec2(-0.033773, -0.786377),\n    vec2(-0.030699, -0.784420),\n    vec2(-0.027626, -0.786376),\n    vec2(-0.024553, -0.784420),\n    vec2(-0.021482, -0.786376),\n    vec2(-0.018412, -0.784421),\n    vec2(-0.015342, -0.786375),\n    vec2(-0.012273, -0.784421),\n    vec2(-0.009204, -0.786375),\n    vec2(-0.006136, -0.784422),\n    vec2(-0.003068, -0.786375),\n    vec2(0.000000, -0.784422),\n    vec2(0.003068, -0.786375),\n    vec2(0.006136, -0.784422),\n    vec2(0.009204, -0.786375),\n    vec2(0.012273, -0.784421),\n    vec2(0.015342, -0.786375),\n    vec2(0.018412, -0.784421),\n    vec2(0.021482, -0.786376),\n    vec2(0.024553, -0.784420),\n    vec2(0.027626, -0.786376),\n    vec2(0.030699, -0.784420),\n    vec2(0.033773, -0.786377),\n    vec2(0.036849, -0.784419),\n    vec2(0.039926, -0.786378),\n    vec2(0.043004, -0.784418),\n    vec2(0.046085, -0.786379),\n    vec2(0.049166, -0.784417),\n    vec2(0.052250, -0.786380),\n    vec2(0.055336, -0.784416),\n    vec2(0.058424, -0.786381),\n    vec2(0.061514, -0.784414),\n    vec2(0.064606, -0.786383),\n    vec2(0.067701, -0.784413),\n    vec2(0.070799, -0.786385),\n    vec2(0.073898, -0.784411),\n    vec2(0.077002, -0.786386),\n    vec2(0.080107, -0.784409),\n    vec2(0.083217, -0.786388),\n    vec2(0.086328, -0.784407),\n    vec2(0.089445, -0.786390),\n    vec2(0.092563, -0.784405),\n    vec2(0.095686, -0.786393),\n    vec2(0.098811, -0.784402),\n    vec2(0.101942, -0.786395),\n    vec2(0.105075, -0.784400),\n    vec2(0.108214, -0.786398),\n    vec2(0.111355, -0.784397),\n    vec2(0.114503, -0.786400),\n    vec2(0.117653, -0.784394),\n    vec2(0.120810, -0.786403),\n    vec2(0.123969, -0.784391),\n    vec2(0.127135, -0.786406),\n    vec2(0.130304, -0.784388),\n    vec2(0.133481, -0.786410),\n    vec2(0.136660, -0.784385),\n    vec2(0.139847, -0.786413),\n    vec2(0.143038, -0.784381),\n    vec2(0.146236, -0.786417),\n    vec2(0.149438, -0.784378),\n    vec2(0.152648, -0.786421),\n    vec2(0.155862, -0.784374),\n    vec2(0.159085, -0.786425),\n    vec2(0.162311, -0.784370),\n    vec2(0.165547, -0.786429),\n    vec2(0.168787, -0.784365),\n    vec2(0.172036, -0.786433),\n    vec2(0.175289, -0.784361),\n    vec2(0.178553, -0.786438),\n    vec2(0.181821, -0.784356),\n    vec2(0.185099, -0.786442),\n    vec2(0.188382, -0.784351),\n    vec2(0.191676, -0.786447),\n    vec2(0.194974, -0.784346),\n    vec2(0.198284, -0.786453),\n    vec2(0.201599, -0.784341),\n    vec2(0.204926, -0.786458),\n    vec2(0.208258, -0.784336),\n    vec2(0.211602, -0.786463),\n    vec2(0.214951, -0.784330),\n    vec2(0.218314, -0.786469),\n    vec2(0.221681, -0.784324),\n    vec2(0.225063, -0.786475),\n    vec2(0.228450, -0.784318),\n    vec2(0.231850, -0.786482),\n    vec2(0.235257, -0.784311),\n    vec2(0.238678, -0.786488),\n    vec2(0.242105, -0.784305),\n    vec2(0.245548, -0.786495),\n    vec2(0.248996, -0.784298),\n    vec2(0.252460, -0.786502),\n    vec2(0.255931, -0.784291),\n    vec2(0.259418, -0.786509),\n    vec2(0.262912, -0.784283),\n    vec2(0.266422, -0.786517),\n    vec2(0.269939, -0.784276),\n    vec2(0.273474, -0.786524),\n    vec2(0.277016, -0.784268),\n    vec2(0.280576, -0.786533),\n    vec2(0.284144, -0.784260),\n    vec2(0.287730, -0.786541),\n    vec2(0.291324, -0.784251),\n    vec2(0.294937, -0.786550),\n    vec2(0.298559, -0.784242),\n    vec2(0.302200, -0.786559),\n    vec2(0.305850, -0.784233),\n    vec2(0.309521, -0.786568),\n    vec2(0.313200, -0.784224),\n    vec2(0.316900, -0.786578),\n    vec2(0.320610, -0.784214),\n    vec2(0.324342, -0.786587),\n    vec2(0.328083, -0.784204),\n    vec2(0.331847, -0.786598),\n    vec2(0.335621, -0.784193),\n    vec2(0.339418, -0.786608),\n    vec2(0.343225, -0.784182),\n    vec2(0.347057, -0.786620),\n    vec2(0.350900, -0.784171),\n    vec2(0.354767, -0.786631),\n    vec2(0.358646, -0.784159),\n    vec2(0.362551, -0.786643),\n    vec2(0.366467, -0.784147),\n    vec2(0.370410, -0.786655),\n    vec2(0.374365, -0.784135),\n    vec2(0.378348, -0.786668),\n    vec2(0.382343, -0.784122),\n    vec2(0.386367, -0.786681),\n    vec2(0.390404, -0.784108),\n    vec2(0.394471, -0.786695),\n    vec2(0.398551, -0.784095),\n    vec2(0.402662, -0.786709),\n    vec2(0.406786, -0.784080),\n    vec2(0.410943, -0.786724),\n    vec2(0.415114, -0.784065),\n    vec2(0.419318, -0.786739),\n    vec2(0.423537, -0.784050),\n    vec2(0.427791, -0.786754),\n    vec2(0.432059, -0.784034),\n    vec2(0.436364, -0.786771),\n    vec2(0.440684, -0.784017),\n    vec2(0.445042, -0.786788),\n    vec2(0.449415, -0.784000),\n    vec2(0.453828, -0.786805),\n    vec2(0.458257, -0.783982),\n    vec2(0.462727, -0.786824),\n    vec2(0.467214, -0.783963),\n    vec2(0.471743, -0.786843),\n    vec2(0.476289, -0.783944),\n    vec2(0.480880, -0.786862),\n    vec2(0.485489, -0.783924),\n    vec2(0.490143, -0.786883),\n    vec2(0.494817, -0.783903),\n    vec2(0.499537, -0.786904),\n    vec2(0.504278, -0.783881),\n    vec2(0.509068, -0.786926),\n    vec2(0.513879, -0.783859),\n    vec2(0.518741, -0.786949),\n    vec2(0.523624, -0.783835),\n    vec2(0.528561, -0.786973),\n    vec2(0.533520, -0.783811),\n    vec2(0.538534, -0.786998),\n    vec2(0.543573, -0.783785),\n    vec2(0.548668, -0.787024),\n    vec2(0.553789, -0.783759),\n    vec2(0.558969, -0.787051),\n    vec2(0.564175, -0.783731),\n    vec2(0.569444, -0.787080),\n    vec2(0.574740, -0.783702),\n    vec2(0.580101, -0.787109),\n    vec2(0.585490, -0.783672),\n    vec2(0.590947, -0.787140),\n    vec2(0.596434, -0.783640),\n    vec2(0.601992, -0.787172),\n    vec2(0.607581, -0.783607),\n    vec2(0.613245, -0.787206),\n    vec2(0.618941, -0.783573),\n    vec2(0.624715, -0.787241),\n    vec2(0.630522, -0.783537),\n    vec2(0.636412, -0.787278),\n    vec2(0.642337, -0.783499),\n    vec2(0.648348, -0.787317),\n    vec2(0.654396, -0.783459),\n    vec2(0.660535, -0.787358),\n    vec2(0.666712, -0.783417),\n    vec2(0.672984, -0.787401),\n    vec2(0.679297, -0.783373),\n    vec2(0.685710, -0.787446),\n    vec2(0.692167, -0.783327),\n    vec2(0.698728, -0.787494),\n    vec2(0.705335, -0.783278),\n    vec2(0.712052, -0.787544),\n    vec2(0.718818, -0.783226),\n    vec2(0.725701, -0.787597),\n    vec2(0.732634, -0.783172),\n    vec2(0.739691, -0.787653),\n    vec2(0.746802, -0.783114),\n    vec2(0.754044, -0.787712),\n    vec2(0.761343, -0.783053),\n    vec2(0.768780, -0.787775),\n    vec2(0.776278, -0.782988),\n    vec2(0.783923, -0.787842),\n    vec2(0.791633, -0.782920),\n    vec2(0.799499, -0.787913),\n    vec2(0.807433, -0.782846),\n    vec2(0.815535, -0.787988),\n    vec2(0.823709, -0.782768),\n    vec2(0.832062, -0.788069),\n    vec2(0.840492, -0.782685),\n    vec2(0.849114, -0.788155),\n    vec2(0.857818, -0.782595),\n    vec2(0.866727, -0.788248),\n    vec2(0.875726, -0.782500),\n    vec2(0.884944, -0.788347),\n    vec2(0.894258, -0.782396),\n    vec2(0.903809, -0.788454),\n    vec2(0.913463, -0.782285),\n    vec2(0.923374, -0.788570),\n    vec2(0.933396, -0.782165),\n    vec2(0.943695, -0.788695),\n    vec2(0.954116, -0.782034),\n    vec2(0.964838, -0.788832),\n    vec2(0.975692, -0.781892),\n    vec2(0.986874, -0.788980),\n    vec2(0.998200, -0.781737),\n    vec2(1.009886, -0.789142),\n    vec2(1.021730, -0.781567),\n    vec2(1.033968, -0.789321),\n    vec2(1.046381, -0.781380),\n    vec2(1.059229, -0.789518),\n    vec2(1.072271, -0.781172),\n    vec2(1.085795, -0.789736),\n    vec2(1.099534, -0.780942),\n    vec2(1.113811, -0.789980),\n    vec2(1.128329, -0.780684),\n    vec2(1.143451, -0.790253),\n    vec2(1.158844, -0.780393),\n    vec2(1.174919, -0.790562),\n    vec2(1.191302, -0.780064),\n    vec2(1.208461, -0.790914),\n    vec2(1.225972, -0.779687),\n    vec2(1.244376, -0.791318),\n    vec2(1.263186, -0.779253),\n    vec2(1.283032, -0.791787),\n    vec2(1.303352, -0.778745),\n    vec2(1.324888, -0.792338),\n    vec2(1.346985, -0.778145),\n    vec2(1.370532, -0.792995),\n    vec2(1.394751, -0.777424),\n    vec2(1.420724, -0.793789),\n    vec2(1.447521, -0.776544),\n    vec2(1.476485, -0.794771),\n    vec2(1.506478, -0.775443),\n    vec2(1.539217, -0.796014),\n    vec2(1.573277, -0.774028),\n    vec2(1.610929, -0.797639),\n    vec2(1.650342, -0.772142),\n    vec2(1.694650, -0.799854),\n    vec2(1.741418, -0.769505),\n    vec2(1.795252, -0.803047),\n    vec2(1.852766, -0.765558),\n    vec2(1.921360, -0.808050),\n    vec2(1.996050, -0.759011),\n    vec2(2.090593, -0.816987),\n    vec2(2.197141, -0.746077),\n    vec2(2.349360, -0.837384),\n    vec2(2.535511, -0.709074),\n    vec2(2.930203, -0.925970)\n\n#elif WAVE == 1\n\n    vec2(3.407282, 0.000000),\n    vec2(2.584121, 0.924434),\n    vec2(2.188458, 0.706009),\n    vec2(2.003297, 0.832777),\n    vec2(1.850116, 0.739947),\n    vec2(1.744567, 0.809310),\n    vec2(1.649073, 0.749816),\n    vec2(1.575391, 0.797301),\n    vec2(1.505854, 0.753298),\n    vec2(1.449358, 0.789228),\n    vec2(1.394591, 0.754180),\n    vec2(1.348850, 0.782964),\n    vec2(1.303618, 0.753752),\n    vec2(1.265242, 0.777678),\n    vec2(1.226676, 0.752573),\n    vec2(1.193662, 0.772982),\n    vec2(1.160018, 0.750923),\n    vec2(1.131081, 0.768668),\n    vec2(1.101221, 0.748959),\n    vec2(1.075490, 0.764615),\n    vec2(1.048630, 0.746775),\n    vec2(1.025485, 0.760749),\n    vec2(1.001063, 0.744430),\n    vec2(0.980049, 0.757022),\n    vec2(0.957646, 0.741965),\n    vec2(0.938419, 0.753400),\n    vec2(0.917716, 0.739408),\n    vec2(0.900009, 0.749860),\n    vec2(0.880757, 0.736778),\n    vec2(0.864358, 0.746385),\n    vec2(0.846360, 0.734090),\n    vec2(0.831099, 0.742962),\n    vec2(0.814195, 0.731354),\n    vec2(0.799933, 0.739582),\n    vec2(0.783992, 0.728580),\n    vec2(0.770614, 0.736238),\n    vec2(0.755527, 0.725773),\n    vec2(0.742938, 0.732923),\n    vec2(0.728614, 0.722938),\n    vec2(0.716732, 0.729634),\n    vec2(0.703093, 0.720081),\n    vec2(0.691849, 0.726366),\n    vec2(0.678830, 0.717203),\n    vec2(0.668164, 0.723116),\n    vec2(0.655707, 0.714308),\n    vec2(0.645569, 0.719883),\n    vec2(0.633625, 0.711398),\n    vec2(0.623969, 0.716664),\n    vec2(0.612495, 0.708476),\n    vec2(0.603281, 0.713456),\n    vec2(0.592240, 0.705541),\n    vec2(0.583434, 0.710260),\n    vec2(0.572791, 0.702597),\n    vec2(0.564363, 0.707073),\n    vec2(0.554089, 0.699643),\n    vec2(0.546011, 0.703895),\n    vec2(0.536079, 0.696681),\n    vec2(0.528327, 0.700725),\n    vec2(0.518714, 0.693712),\n    vec2(0.511265, 0.697561),\n    vec2(0.501949, 0.690737),\n    vec2(0.494785, 0.694404),\n    vec2(0.485747, 0.687756),\n    vec2(0.478848, 0.691252),\n    vec2(0.470072, 0.684769),\n    vec2(0.463423, 0.688105),\n    vec2(0.454891, 0.681777),\n    vec2(0.448477, 0.684963),\n    vec2(0.440176, 0.678781),\n    vec2(0.433983, 0.681825),\n    vec2(0.425900, 0.675781),\n    vec2(0.419916, 0.678691),\n    vec2(0.412039, 0.672777),\n    vec2(0.406252, 0.675561),\n    vec2(0.398570, 0.669770),\n    vec2(0.392971, 0.672434),\n    vec2(0.385472, 0.666760),\n    vec2(0.380051, 0.669310),\n    vec2(0.372727, 0.663746),\n    vec2(0.367475, 0.666189),\n    vec2(0.360318, 0.660730),\n    vec2(0.355226, 0.663070),\n    vec2(0.348227, 0.657712),\n    vec2(0.343288, 0.659954),\n    vec2(0.336440, 0.654691),\n    vec2(0.331647, 0.656840),\n    vec2(0.324943, 0.651668),\n    vec2(0.320289, 0.653728),\n    vec2(0.313723, 0.648643),\n    vec2(0.309202, 0.650617),\n    vec2(0.302767, 0.645617),\n    vec2(0.298374, 0.647509),\n    vec2(0.292065, 0.642588),\n    vec2(0.287794, 0.644403),\n    vec2(0.281606, 0.639558),\n    vec2(0.277452, 0.641298),\n    vec2(0.271379, 0.636526),\n    vec2(0.267338, 0.638194),\n    vec2(0.261376, 0.633493),\n    vec2(0.257442, 0.635092),\n    vec2(0.251587, 0.630459),\n    vec2(0.247758, 0.631991),\n    vec2(0.242005, 0.627423),\n    vec2(0.238275, 0.628892),\n    vec2(0.232621, 0.624386),\n    vec2(0.228988, 0.625793),\n    vec2(0.223429, 0.621348),\n    vec2(0.219889, 0.622696),\n    vec2(0.214422, 0.618309),\n    vec2(0.210970, 0.619600),\n    vec2(0.205592, 0.615269),\n    vec2(0.202227, 0.616504),\n    vec2(0.196934, 0.612228),\n    vec2(0.193652, 0.613410),\n    vec2(0.188441, 0.609186),\n    vec2(0.185240, 0.610316),\n    vec2(0.180109, 0.606143),\n    vec2(0.176986, 0.607224),\n    vec2(0.171933, 0.603099),\n    vec2(0.168885, 0.604132),\n    vec2(0.163906, 0.600055),\n    vec2(0.160931, 0.601041),\n    vec2(0.156025, 0.597009),\n    vec2(0.153120, 0.597950),\n    vec2(0.148284, 0.593964),\n    vec2(0.145449, 0.594861),\n    vec2(0.140680, 0.590917),\n    vec2(0.137911, 0.591772),\n    vec2(0.133208, 0.587870),\n    vec2(0.130504, 0.588683),\n    vec2(0.125865, 0.584822),\n    vec2(0.123224, 0.585595),\n    vec2(0.118647, 0.581774),\n    vec2(0.116067, 0.582508),\n    vec2(0.111550, 0.578725),\n    vec2(0.109029, 0.579421),\n    vec2(0.104572, 0.575675),\n    vec2(0.102107, 0.576335),\n    vec2(0.097707, 0.572625),\n    vec2(0.095299, 0.573250),\n    vec2(0.090954, 0.569575),\n    vec2(0.088601, 0.570164),\n    vec2(0.084310, 0.566524),\n    vec2(0.082010, 0.567080),\n    vec2(0.077772, 0.563473),\n    vec2(0.075523, 0.563995),\n    vec2(0.071336, 0.560421),\n    vec2(0.069138, 0.560911),\n    vec2(0.065001, 0.557369),\n    vec2(0.062852, 0.557828),\n    vec2(0.058764, 0.554316),\n    vec2(0.056662, 0.554745),\n    vec2(0.052622, 0.551263),\n    vec2(0.050567, 0.551662),\n    vec2(0.046573, 0.548210),\n    vec2(0.044564, 0.548579),\n    vec2(0.040615, 0.545156),\n    vec2(0.038651, 0.545497),\n    vec2(0.034746, 0.542102),\n    vec2(0.032825, 0.542416),\n    vec2(0.028964, 0.539048),\n    vec2(0.027085, 0.539334),\n    vec2(0.023266, 0.535993),\n    vec2(0.021429, 0.536253),\n    vec2(0.017651, 0.532938),\n    vec2(0.015855, 0.533172),\n    vec2(0.012117, 0.529883),\n    vec2(0.010361, 0.530092),\n    vec2(0.006662, 0.526827),\n    vec2(0.004945, 0.527011),\n    vec2(0.001285, 0.523772),\n    vec2(-0.000394, 0.523931),\n    vec2(-0.004016, 0.520716),\n    vec2(-0.005659, 0.520851),\n    vec2(-0.009243, 0.517659),\n    vec2(-0.010849, 0.517772),\n    vec2(-0.014398, 0.514603),\n    vec2(-0.015968, 0.514693),\n    vec2(-0.019481, 0.511546),\n    vec2(-0.021016, 0.511613),\n    vec2(-0.024494, 0.508489),\n    vec2(-0.025995, 0.508535),\n    vec2(-0.029439, 0.505432),\n    vec2(-0.030906, 0.505456),\n    vec2(-0.034317, 0.502375),\n    vec2(-0.035751, 0.502378),\n    vec2(-0.039129, 0.499317),\n    vec2(-0.040531, 0.499299),\n    vec2(-0.043877, 0.496259),\n    vec2(-0.045247, 0.496221),\n    vec2(-0.048561, 0.493201),\n    vec2(-0.049900, 0.493143),\n    vec2(-0.053183, 0.490143),\n    vec2(-0.054492, 0.490066),\n    vec2(-0.057744, 0.487085),\n    vec2(-0.059023, 0.486988),\n    vec2(-0.062246, 0.484026),\n    vec2(-0.063495, 0.483911),\n    vec2(-0.066688, 0.480968),\n    vec2(-0.067908, 0.480834),\n    vec2(-0.071073, 0.477909),\n    vec2(-0.072265, 0.477757),\n    vec2(-0.075401, 0.474850),\n    vec2(-0.076565, 0.474680),\n    vec2(-0.079673, 0.471791),\n    vec2(-0.080809, 0.471603),\n    vec2(-0.083890, 0.468731),\n    vec2(-0.084999, 0.468527),\n    vec2(-0.088054, 0.465672),\n    vec2(-0.089136, 0.465450),\n    vec2(-0.092164, 0.462612),\n    vec2(-0.093220, 0.462374),\n    vec2(-0.096222, 0.459552),\n    vec2(-0.097253, 0.459298),\n    vec2(-0.100229, 0.456493),\n    vec2(-0.101234, 0.456222),\n    vec2(-0.104185, 0.453433),\n    vec2(-0.105165, 0.453146),\n    vec2(-0.108091, 0.450373),\n    vec2(-0.109047, 0.450070),\n    vec2(-0.111949, 0.447312),\n    vec2(-0.112880, 0.446995),\n    vec2(-0.115758, 0.444252),\n    vec2(-0.116666, 0.443919),\n    vec2(-0.119520, 0.441191),\n    vec2(-0.120404, 0.440844),\n    vec2(-0.123235, 0.438131),\n    vec2(-0.124096, 0.437768),\n    vec2(-0.126904, 0.435070),\n    vec2(-0.127742, 0.434693),\n    vec2(-0.130527, 0.432009),\n    vec2(-0.131344, 0.431618),\n    vec2(-0.134106, 0.428949),\n    vec2(-0.134900, 0.428543),\n    vec2(-0.137641, 0.425888),\n    vec2(-0.138413, 0.425468),\n    vec2(-0.141132, 0.422826),\n    vec2(-0.141883, 0.422394),\n    vec2(-0.144580, 0.419765),\n    vec2(-0.145310, 0.419319),\n    vec2(-0.147986, 0.416704),\n    vec2(-0.148695, 0.416244),\n    vec2(-0.151350, 0.413643),\n    vec2(-0.152038, 0.413170),\n    vec2(-0.154673, 0.410581),\n    vec2(-0.155341, 0.410095),\n    vec2(-0.157956, 0.407520),\n    vec2(-0.158603, 0.407021),\n    vec2(-0.161198, 0.404458),\n    vec2(-0.161826, 0.403947),\n    vec2(-0.164401, 0.401396),\n    vec2(-0.165009, 0.400872),\n    vec2(-0.167564, 0.398335),\n    vec2(-0.168153, 0.397798),\n    vec2(-0.170689, 0.395273),\n    vec2(-0.171259, 0.394724),\n    vec2(-0.173776, 0.392211),\n    vec2(-0.174327, 0.391650),\n    vec2(-0.176825, 0.389149),\n    vec2(-0.177357, 0.388577),\n    vec2(-0.179837, 0.386087),\n    vec2(-0.180351, 0.385503),\n    vec2(-0.182812, 0.383025),\n    vec2(-0.183308, 0.382429),\n    vec2(-0.185751, 0.379962),\n    vec2(-0.186229, 0.379355),\n    vec2(-0.188655, 0.376900),\n    vec2(-0.189114, 0.376282),\n    vec2(-0.191522, 0.373838),\n    vec2(-0.191964, 0.373208),\n    vec2(-0.194355, 0.370775),\n    vec2(-0.194780, 0.370135),\n    vec2(-0.197152, 0.367713),\n    vec2(-0.197560, 0.367061),\n    vec2(-0.199916, 0.364650),\n    vec2(-0.200307, 0.363988),\n    vec2(-0.202646, 0.361588),\n    vec2(-0.203020, 0.360915),\n    vec2(-0.205342, 0.358525),\n    vec2(-0.205699, 0.357841),\n    vec2(-0.208005, 0.355462),\n    vec2(-0.208346, 0.354768),\n    vec2(-0.210635, 0.352400),\n    vec2(-0.210959, 0.351695),\n    vec2(-0.213232, 0.349337),\n    vec2(-0.213541, 0.348622),\n    vec2(-0.215798, 0.346274),\n    vec2(-0.216090, 0.345549),\n    vec2(-0.218331, 0.343211),\n    vec2(-0.218608, 0.342476),\n    vec2(-0.220833, 0.340148),\n    vec2(-0.221095, 0.339403),\n    vec2(-0.223304, 0.337085),\n    vec2(-0.223550, 0.336330),\n    vec2(-0.225744, 0.334022),\n    vec2(-0.225975, 0.333257),\n    vec2(-0.228154, 0.330959),\n    vec2(-0.228369, 0.330185),\n    vec2(-0.230533, 0.327896),\n    vec2(-0.230733, 0.327112),\n    vec2(-0.232882, 0.324832),\n    vec2(-0.233067, 0.324039),\n    vec2(-0.235202, 0.321769),\n    vec2(-0.235372, 0.320966),\n    vec2(-0.237492, 0.318706),\n    vec2(-0.237648, 0.317894),\n    vec2(-0.239752, 0.315643),\n    vec2(-0.239894, 0.314821),\n    vec2(-0.241984, 0.312579),\n    vec2(-0.242111, 0.311749),\n    vec2(-0.244187, 0.309516),\n    vec2(-0.244300, 0.308676),\n    vec2(-0.246362, 0.306452),\n    vec2(-0.246461, 0.305604),\n    vec2(-0.248509, 0.303389),\n    vec2(-0.248594, 0.302531),\n    vec2(-0.250628, 0.300325),\n    vec2(-0.250699, 0.299459),\n    vec2(-0.252719, 0.297262),\n    vec2(-0.252776, 0.296387),\n    vec2(-0.254782, 0.294198),\n    vec2(-0.254826, 0.293314),\n    vec2(-0.256819, 0.291134),\n    vec2(-0.256849, 0.290242),\n    vec2(-0.258828, 0.288071),\n    vec2(-0.258845, 0.287170),\n    vec2(-0.260811, 0.285007),\n    vec2(-0.260814, 0.284098),\n    vec2(-0.262767, 0.281943),\n    vec2(-0.262757, 0.281026),\n    vec2(-0.264696, 0.278879),\n    vec2(-0.264673, 0.277953),\n    vec2(-0.266600, 0.275816),\n    vec2(-0.266564, 0.274881),\n    vec2(-0.268477, 0.272752),\n    vec2(-0.268428, 0.271809),\n    vec2(-0.270329, 0.269688),\n    vec2(-0.270267, 0.268737),\n    vec2(-0.272155, 0.266624),\n    vec2(-0.272081, 0.265665),\n    vec2(-0.273956, 0.263560),\n    vec2(-0.273869, 0.262593),\n    vec2(-0.275731, 0.260496),\n    vec2(-0.275632, 0.259521),\n    vec2(-0.277481, 0.257432),\n    vec2(-0.277370, 0.256449),\n    vec2(-0.279207, 0.254368),\n    vec2(-0.279083, 0.253378),\n    vec2(-0.280908, 0.251304),\n    vec2(-0.280771, 0.250306),\n    vec2(-0.282584, 0.248240),\n    vec2(-0.282435, 0.247234),\n    vec2(-0.284236, 0.245176),\n    vec2(-0.284075, 0.244162),\n    vec2(-0.285864, 0.242112),\n    vec2(-0.285691, 0.241090),\n    vec2(-0.287468, 0.239048),\n    vec2(-0.287283, 0.238018),\n    vec2(-0.289048, 0.235983),\n    vec2(-0.288851, 0.234947),\n    vec2(-0.290604, 0.232919),\n    vec2(-0.290395, 0.231875),\n    vec2(-0.292136, 0.229855),\n    vec2(-0.291916, 0.228803),\n    vec2(-0.293645, 0.226791),\n    vec2(-0.293413, 0.225732),\n    vec2(-0.295131, 0.223727),\n    vec2(-0.294887, 0.222660),\n    vec2(-0.296594, 0.220662),\n    vec2(-0.296338, 0.219588),\n    vec2(-0.298033, 0.217598),\n    vec2(-0.297767, 0.216517),\n    vec2(-0.299450, 0.214534),\n    vec2(-0.299172, 0.213445),\n    vec2(-0.300844, 0.211469),\n    vec2(-0.300554, 0.210374),\n    vec2(-0.302215, 0.208405),\n    vec2(-0.301914, 0.207302),\n    vec2(-0.303564, 0.205341),\n    vec2(-0.303252, 0.204231),\n    vec2(-0.304890, 0.202276),\n    vec2(-0.304567, 0.201159),\n    vec2(-0.306194, 0.199212),\n    vec2(-0.305860, 0.198088),\n    vec2(-0.307476, 0.196147),\n    vec2(-0.307131, 0.195016),\n    vec2(-0.308735, 0.193083),\n    vec2(-0.308379, 0.191945),\n    vec2(-0.309973, 0.190018),\n    vec2(-0.309606, 0.188873),\n    vec2(-0.311189, 0.186954),\n    vec2(-0.310811, 0.185802),\n    vec2(-0.312384, 0.183889),\n    vec2(-0.311995, 0.182730),\n    vec2(-0.313556, 0.180825),\n    vec2(-0.313157, 0.179659),\n    vec2(-0.314707, 0.177760),\n    vec2(-0.314297, 0.176588),\n    vec2(-0.315837, 0.174696),\n    vec2(-0.315416, 0.173516),\n    vec2(-0.316945, 0.171631),\n    vec2(-0.316514, 0.170445),\n    vec2(-0.318032, 0.168567),\n    vec2(-0.317590, 0.167374),\n    vec2(-0.319098, 0.165502),\n    vec2(-0.318646, 0.164302),\n    vec2(-0.320143, 0.162437),\n    vec2(-0.319680, 0.161231),\n    vec2(-0.321167, 0.159373),\n    vec2(-0.320694, 0.158160),\n    vec2(-0.322170, 0.156308),\n    vec2(-0.321687, 0.155088),\n    vec2(-0.323153, 0.153243),\n    vec2(-0.322659, 0.152017),\n    vec2(-0.324114, 0.150179),\n    vec2(-0.323610, 0.148946),\n    vec2(-0.325055, 0.147114),\n    vec2(-0.324540, 0.145875),\n    vec2(-0.325976, 0.144049),\n    vec2(-0.325451, 0.142803),\n    vec2(-0.326876, 0.140985),\n    vec2(-0.326340, 0.139732),\n    vec2(-0.327755, 0.137920),\n    vec2(-0.327210, 0.136661),\n    vec2(-0.328614, 0.134855),\n    vec2(-0.328059, 0.133590),\n    vec2(-0.329453, 0.131790),\n    vec2(-0.328887, 0.130519),\n    vec2(-0.330272, 0.128726),\n    vec2(-0.329696, 0.127448),\n    vec2(-0.331070, 0.125661),\n    vec2(-0.330485, 0.124376),\n    vec2(-0.331849, 0.122596),\n    vec2(-0.331253, 0.121305),\n    vec2(-0.332607, 0.119531),\n    vec2(-0.332002, 0.118234),\n    vec2(-0.333346, 0.116467),\n    vec2(-0.332730, 0.115163),\n    vec2(-0.334065, 0.113402),\n    vec2(-0.333439, 0.112092),\n    vec2(-0.334763, 0.110337),\n    vec2(-0.334128, 0.109021),\n    vec2(-0.335442, 0.107272),\n    vec2(-0.334797, 0.105950),\n    vec2(-0.336102, 0.104207),\n    vec2(-0.335447, 0.102879),\n    vec2(-0.336741, 0.101142),\n    vec2(-0.336076, 0.099807),\n    vec2(-0.337362, 0.098078),\n    vec2(-0.336687, 0.096736),\n    vec2(-0.337962, 0.095013),\n    vec2(-0.337277, 0.093665),\n    vec2(-0.338543, 0.091948),\n    vec2(-0.337849, 0.090594),\n    vec2(-0.339104, 0.088883),\n    vec2(-0.338400, 0.087523),\n    vec2(-0.339646, 0.085818),\n    vec2(-0.338933, 0.084452),\n    vec2(-0.340169, 0.082753),\n    vec2(-0.339446, 0.081381),\n    vec2(-0.340672, 0.079688),\n    vec2(-0.339939, 0.078310),\n    vec2(-0.341156, 0.076624),\n    vec2(-0.340414, 0.075239),\n    vec2(-0.341621, 0.073559),\n    vec2(-0.340869, 0.072168),\n    vec2(-0.342067, 0.070494),\n    vec2(-0.341305, 0.069097),\n    vec2(-0.342493, 0.067429),\n    vec2(-0.341721, 0.066026),\n    vec2(-0.342900, 0.064364),\n    vec2(-0.342119, 0.062955),\n    vec2(-0.343288, 0.061299),\n    vec2(-0.342497, 0.059884),\n    vec2(-0.343657, 0.058234),\n    vec2(-0.342856, 0.056813),\n    vec2(-0.344007, 0.055169),\n    vec2(-0.343197, 0.053742),\n    vec2(-0.344337, 0.052104),\n    vec2(-0.343518, 0.050671),\n    vec2(-0.344649, 0.049039),\n    vec2(-0.343820, 0.047600),\n    vec2(-0.344942, 0.045974),\n    vec2(-0.344103, 0.044529),\n    vec2(-0.345215, 0.042909),\n    vec2(-0.344367, 0.041458),\n    vec2(-0.345470, 0.039844),\n    vec2(-0.344613, 0.038387),\n    vec2(-0.345706, 0.036780),\n    vec2(-0.344839, 0.035316),\n    vec2(-0.345923, 0.033715),\n    vec2(-0.345046, 0.032245),\n    vec2(-0.346121, 0.030650),\n    vec2(-0.345235, 0.029174),\n    vec2(-0.346300, 0.027585),\n    vec2(-0.345404, 0.026103),\n    vec2(-0.346460, 0.024520),\n    vec2(-0.345555, 0.023032),\n    vec2(-0.346601, 0.021455),\n    vec2(-0.345687, 0.019961),\n    vec2(-0.346723, 0.018390),\n    vec2(-0.345800, 0.016890),\n    vec2(-0.346827, 0.015325),\n    vec2(-0.345894, 0.013819),\n    vec2(-0.346912, 0.012260),\n    vec2(-0.345970, 0.010748),\n    vec2(-0.346978, 0.009195),\n    vec2(-0.346026, 0.007677),\n    vec2(-0.347025, 0.006130),\n    vec2(-0.346064, 0.004606),\n    vec2(-0.347053, 0.003065),\n    vec2(-0.346082, 0.001535),\n    vec2(-0.347062, -0.000000),\n    vec2(-0.346082, -0.001535),\n    vec2(-0.347053, -0.003065),\n    vec2(-0.346064, -0.004606),\n    vec2(-0.347025, -0.006130),\n    vec2(-0.346026, -0.007677),\n    vec2(-0.346978, -0.009195),\n    vec2(-0.345970, -0.010748),\n    vec2(-0.346912, -0.012260),\n    vec2(-0.345894, -0.013819),\n    vec2(-0.346827, -0.015325),\n    vec2(-0.345800, -0.016890),\n    vec2(-0.346723, -0.018390),\n    vec2(-0.345687, -0.019961),\n    vec2(-0.346601, -0.021455),\n    vec2(-0.345555, -0.023032),\n    vec2(-0.346460, -0.024520),\n    vec2(-0.345404, -0.026103),\n    vec2(-0.346300, -0.027585),\n    vec2(-0.345235, -0.029174),\n    vec2(-0.346121, -0.030650),\n    vec2(-0.345046, -0.032245),\n    vec2(-0.345923, -0.033715),\n    vec2(-0.344839, -0.035316),\n    vec2(-0.345706, -0.036780),\n    vec2(-0.344613, -0.038387),\n    vec2(-0.345470, -0.039844),\n    vec2(-0.344367, -0.041458),\n    vec2(-0.345215, -0.042909),\n    vec2(-0.344103, -0.044529),\n    vec2(-0.344942, -0.045974),\n    vec2(-0.343820, -0.047600),\n    vec2(-0.344649, -0.049039),\n    vec2(-0.343518, -0.050671),\n    vec2(-0.344337, -0.052104),\n    vec2(-0.343197, -0.053742),\n    vec2(-0.344007, -0.055169),\n    vec2(-0.342856, -0.056813),\n    vec2(-0.343657, -0.058234),\n    vec2(-0.342497, -0.059884),\n    vec2(-0.343288, -0.061299),\n    vec2(-0.342119, -0.062955),\n    vec2(-0.342900, -0.064364),\n    vec2(-0.341721, -0.066026),\n    vec2(-0.342493, -0.067429),\n    vec2(-0.341305, -0.069097),\n    vec2(-0.342067, -0.070494),\n    vec2(-0.340869, -0.072168),\n    vec2(-0.341621, -0.073559),\n    vec2(-0.340414, -0.075239),\n    vec2(-0.341156, -0.076624),\n    vec2(-0.339939, -0.078310),\n    vec2(-0.340672, -0.079688),\n    vec2(-0.339446, -0.081381),\n    vec2(-0.340169, -0.082753),\n    vec2(-0.338933, -0.084452),\n    vec2(-0.339646, -0.085818),\n    vec2(-0.338400, -0.087523),\n    vec2(-0.339104, -0.088883),\n    vec2(-0.337849, -0.090594),\n    vec2(-0.338543, -0.091948),\n    vec2(-0.337277, -0.093665),\n    vec2(-0.337962, -0.095013),\n    vec2(-0.336687, -0.096736),\n    vec2(-0.337362, -0.098078),\n    vec2(-0.336076, -0.099807),\n    vec2(-0.336741, -0.101142),\n    vec2(-0.335447, -0.102879),\n    vec2(-0.336102, -0.104207),\n    vec2(-0.334797, -0.105950),\n    vec2(-0.335442, -0.107272),\n    vec2(-0.334128, -0.109021),\n    vec2(-0.334763, -0.110337),\n    vec2(-0.333439, -0.112092),\n    vec2(-0.334065, -0.113402),\n    vec2(-0.332730, -0.115163),\n    vec2(-0.333346, -0.116467),\n    vec2(-0.332002, -0.118234),\n    vec2(-0.332607, -0.119531),\n    vec2(-0.331253, -0.121305),\n    vec2(-0.331849, -0.122596),\n    vec2(-0.330485, -0.124376),\n    vec2(-0.331070, -0.125661),\n    vec2(-0.329696, -0.127448),\n    vec2(-0.330272, -0.128726),\n    vec2(-0.328887, -0.130519),\n    vec2(-0.329453, -0.131790),\n    vec2(-0.328059, -0.133590),\n    vec2(-0.328614, -0.134855),\n    vec2(-0.327210, -0.136661),\n    vec2(-0.327755, -0.137920),\n    vec2(-0.326340, -0.139732),\n    vec2(-0.326876, -0.140985),\n    vec2(-0.325451, -0.142803),\n    vec2(-0.325976, -0.144049),\n    vec2(-0.324540, -0.145875),\n    vec2(-0.325055, -0.147114),\n    vec2(-0.323610, -0.148946),\n    vec2(-0.324114, -0.150179),\n    vec2(-0.322659, -0.152017),\n    vec2(-0.323153, -0.153243),\n    vec2(-0.321687, -0.155088),\n    vec2(-0.322170, -0.156308),\n    vec2(-0.320694, -0.158160),\n    vec2(-0.321167, -0.159373),\n    vec2(-0.319680, -0.161231),\n    vec2(-0.320143, -0.162437),\n    vec2(-0.318646, -0.164302),\n    vec2(-0.319098, -0.165502),\n    vec2(-0.317590, -0.167374),\n    vec2(-0.318032, -0.168567),\n    vec2(-0.316514, -0.170445),\n    vec2(-0.316945, -0.171631),\n    vec2(-0.315416, -0.173516),\n    vec2(-0.315837, -0.174696),\n    vec2(-0.314297, -0.176588),\n    vec2(-0.314707, -0.177760),\n    vec2(-0.313157, -0.179659),\n    vec2(-0.313556, -0.180825),\n    vec2(-0.311995, -0.182730),\n    vec2(-0.312384, -0.183889),\n    vec2(-0.310811, -0.185802),\n    vec2(-0.311189, -0.186954),\n    vec2(-0.309606, -0.188873),\n    vec2(-0.309973, -0.190018),\n    vec2(-0.308379, -0.191945),\n    vec2(-0.308735, -0.193083),\n    vec2(-0.307131, -0.195016),\n    vec2(-0.307476, -0.196147),\n    vec2(-0.305860, -0.198088),\n    vec2(-0.306194, -0.199212),\n    vec2(-0.304567, -0.201159),\n    vec2(-0.304890, -0.202276),\n    vec2(-0.303252, -0.204231),\n    vec2(-0.303564, -0.205341),\n    vec2(-0.301914, -0.207302),\n    vec2(-0.302215, -0.208405),\n    vec2(-0.300554, -0.210374),\n    vec2(-0.300844, -0.211469),\n    vec2(-0.299172, -0.213445),\n    vec2(-0.299450, -0.214534),\n    vec2(-0.297767, -0.216517),\n    vec2(-0.298033, -0.217598),\n    vec2(-0.296338, -0.219588),\n    vec2(-0.296594, -0.220662),\n    vec2(-0.294887, -0.222660),\n    vec2(-0.295131, -0.223727),\n    vec2(-0.293413, -0.225732),\n    vec2(-0.293645, -0.226791),\n    vec2(-0.291916, -0.228803),\n    vec2(-0.292136, -0.229855),\n    vec2(-0.290395, -0.231875),\n    vec2(-0.290604, -0.232919),\n    vec2(-0.288851, -0.234947),\n    vec2(-0.289048, -0.235983),\n    vec2(-0.287283, -0.238018),\n    vec2(-0.287468, -0.239048),\n    vec2(-0.285691, -0.241090),\n    vec2(-0.285864, -0.242112),\n    vec2(-0.284075, -0.244162),\n    vec2(-0.284236, -0.245176),\n    vec2(-0.282435, -0.247234),\n    vec2(-0.282584, -0.248240),\n    vec2(-0.280771, -0.250306),\n    vec2(-0.280908, -0.251304),\n    vec2(-0.279083, -0.253378),\n    vec2(-0.279207, -0.254368),\n    vec2(-0.277370, -0.256449),\n    vec2(-0.277481, -0.257432),\n    vec2(-0.275632, -0.259521),\n    vec2(-0.275731, -0.260496),\n    vec2(-0.273869, -0.262593),\n    vec2(-0.273956, -0.263560),\n    vec2(-0.272081, -0.265665),\n    vec2(-0.272155, -0.266624),\n    vec2(-0.270267, -0.268737),\n    vec2(-0.270329, -0.269688),\n    vec2(-0.268428, -0.271809),\n    vec2(-0.268477, -0.272752),\n    vec2(-0.266564, -0.274881),\n    vec2(-0.266600, -0.275816),\n    vec2(-0.264673, -0.277953),\n    vec2(-0.264696, -0.278879),\n    vec2(-0.262757, -0.281026),\n    vec2(-0.262767, -0.281943),\n    vec2(-0.260814, -0.284098),\n    vec2(-0.260811, -0.285007),\n    vec2(-0.258845, -0.287170),\n    vec2(-0.258828, -0.288071),\n    vec2(-0.256849, -0.290242),\n    vec2(-0.256819, -0.291134),\n    vec2(-0.254826, -0.293314),\n    vec2(-0.254782, -0.294198),\n    vec2(-0.252776, -0.296387),\n    vec2(-0.252719, -0.297262),\n    vec2(-0.250699, -0.299459),\n    vec2(-0.250628, -0.300325),\n    vec2(-0.248594, -0.302531),\n    vec2(-0.248509, -0.303389),\n    vec2(-0.246461, -0.305604),\n    vec2(-0.246362, -0.306452),\n    vec2(-0.244300, -0.308676),\n    vec2(-0.244187, -0.309516),\n    vec2(-0.242111, -0.311749),\n    vec2(-0.241984, -0.312579),\n    vec2(-0.239894, -0.314821),\n    vec2(-0.239752, -0.315643),\n    vec2(-0.237648, -0.317894),\n    vec2(-0.237492, -0.318706),\n    vec2(-0.235372, -0.320966),\n    vec2(-0.235202, -0.321769),\n    vec2(-0.233067, -0.324039),\n    vec2(-0.232882, -0.324832),\n    vec2(-0.230733, -0.327112),\n    vec2(-0.230533, -0.327896),\n    vec2(-0.228369, -0.330185),\n    vec2(-0.228154, -0.330959),\n    vec2(-0.225975, -0.333257),\n    vec2(-0.225744, -0.334022),\n    vec2(-0.223550, -0.336330),\n    vec2(-0.223304, -0.337085),\n    vec2(-0.221095, -0.339403),\n    vec2(-0.220833, -0.340148),\n    vec2(-0.218608, -0.342476),\n    vec2(-0.218331, -0.343211),\n    vec2(-0.216090, -0.345549),\n    vec2(-0.215798, -0.346274),\n    vec2(-0.213541, -0.348622),\n    vec2(-0.213232, -0.349337),\n    vec2(-0.210959, -0.351695),\n    vec2(-0.210635, -0.352400),\n    vec2(-0.208346, -0.354768),\n    vec2(-0.208005, -0.355462),\n    vec2(-0.205699, -0.357841),\n    vec2(-0.205342, -0.358525),\n    vec2(-0.203020, -0.360915),\n    vec2(-0.202646, -0.361588),\n    vec2(-0.200307, -0.363988),\n    vec2(-0.199916, -0.364650),\n    vec2(-0.197560, -0.367061),\n    vec2(-0.197152, -0.367713),\n    vec2(-0.194780, -0.370135),\n    vec2(-0.194355, -0.370775),\n    vec2(-0.191964, -0.373208),\n    vec2(-0.191522, -0.373838),\n    vec2(-0.189114, -0.376282),\n    vec2(-0.188655, -0.376900),\n    vec2(-0.186229, -0.379355),\n    vec2(-0.185751, -0.379962),\n    vec2(-0.183308, -0.382429),\n    vec2(-0.182812, -0.383025),\n    vec2(-0.180351, -0.385503),\n    vec2(-0.179837, -0.386087),\n    vec2(-0.177357, -0.388577),\n    vec2(-0.176825, -0.389149),\n    vec2(-0.174327, -0.391650),\n    vec2(-0.173776, -0.392211),\n    vec2(-0.171259, -0.394724),\n    vec2(-0.170689, -0.395273),\n    vec2(-0.168153, -0.397798),\n    vec2(-0.167564, -0.398335),\n    vec2(-0.165009, -0.400872),\n    vec2(-0.164401, -0.401396),\n    vec2(-0.161826, -0.403947),\n    vec2(-0.161198, -0.404458),\n    vec2(-0.158603, -0.407021),\n    vec2(-0.157956, -0.407520),\n    vec2(-0.155341, -0.410095),\n    vec2(-0.154673, -0.410581),\n    vec2(-0.152038, -0.413170),\n    vec2(-0.151350, -0.413643),\n    vec2(-0.148695, -0.416244),\n    vec2(-0.147986, -0.416704),\n    vec2(-0.145310, -0.419319),\n    vec2(-0.144580, -0.419765),\n    vec2(-0.141883, -0.422394),\n    vec2(-0.141132, -0.422826),\n    vec2(-0.138413, -0.425468),\n    vec2(-0.137641, -0.425888),\n    vec2(-0.134900, -0.428543),\n    vec2(-0.134106, -0.428949),\n    vec2(-0.131344, -0.431618),\n    vec2(-0.130527, -0.432009),\n    vec2(-0.127742, -0.434693),\n    vec2(-0.126904, -0.435070),\n    vec2(-0.124096, -0.437768),\n    vec2(-0.123235, -0.438131),\n    vec2(-0.120404, -0.440844),\n    vec2(-0.119520, -0.441191),\n    vec2(-0.116666, -0.443919),\n    vec2(-0.115758, -0.444252),\n    vec2(-0.112880, -0.446995),\n    vec2(-0.111949, -0.447312),\n    vec2(-0.109047, -0.450070),\n    vec2(-0.108091, -0.450373),\n    vec2(-0.105165, -0.453146),\n    vec2(-0.104185, -0.453433),\n    vec2(-0.101234, -0.456222),\n    vec2(-0.100229, -0.456493),\n    vec2(-0.097253, -0.459298),\n    vec2(-0.096222, -0.459552),\n    vec2(-0.093220, -0.462374),\n    vec2(-0.092164, -0.462612),\n    vec2(-0.089136, -0.465450),\n    vec2(-0.088054, -0.465672),\n    vec2(-0.084999, -0.468527),\n    vec2(-0.083890, -0.468731),\n    vec2(-0.080809, -0.471603),\n    vec2(-0.079673, -0.471791),\n    vec2(-0.076565, -0.474680),\n    vec2(-0.075401, -0.474850),\n    vec2(-0.072265, -0.477757),\n    vec2(-0.071073, -0.477909),\n    vec2(-0.067908, -0.480834),\n    vec2(-0.066688, -0.480968),\n    vec2(-0.063495, -0.483911),\n    vec2(-0.062246, -0.484026),\n    vec2(-0.059023, -0.486988),\n    vec2(-0.057744, -0.487085),\n    vec2(-0.054492, -0.490066),\n    vec2(-0.053183, -0.490143),\n    vec2(-0.049900, -0.493143),\n    vec2(-0.048561, -0.493201),\n    vec2(-0.045247, -0.496221),\n    vec2(-0.043877, -0.496259),\n    vec2(-0.040531, -0.499299),\n    vec2(-0.039129, -0.499317),\n    vec2(-0.035751, -0.502378),\n    vec2(-0.034317, -0.502375),\n    vec2(-0.030906, -0.505456),\n    vec2(-0.029439, -0.505432),\n    vec2(-0.025995, -0.508535),\n    vec2(-0.024494, -0.508489),\n    vec2(-0.021016, -0.511613),\n    vec2(-0.019481, -0.511546),\n    vec2(-0.015968, -0.514693),\n    vec2(-0.014398, -0.514603),\n    vec2(-0.010849, -0.517772),\n    vec2(-0.009243, -0.517659),\n    vec2(-0.005659, -0.520851),\n    vec2(-0.004016, -0.520716),\n    vec2(-0.000394, -0.523931),\n    vec2(0.001285, -0.523772),\n    vec2(0.004945, -0.527011),\n    vec2(0.006662, -0.526827),\n    vec2(0.010361, -0.530092),\n    vec2(0.012117, -0.529883),\n    vec2(0.015855, -0.533172),\n    vec2(0.017651, -0.532938),\n    vec2(0.021429, -0.536253),\n    vec2(0.023266, -0.535993),\n    vec2(0.027085, -0.539334),\n    vec2(0.028964, -0.539048),\n    vec2(0.032825, -0.542416),\n    vec2(0.034746, -0.542102),\n    vec2(0.038651, -0.545497),\n    vec2(0.040615, -0.545156),\n    vec2(0.044564, -0.548579),\n    vec2(0.046573, -0.548210),\n    vec2(0.050567, -0.551662),\n    vec2(0.052622, -0.551263),\n    vec2(0.056662, -0.554745),\n    vec2(0.058764, -0.554316),\n    vec2(0.062852, -0.557828),\n    vec2(0.065001, -0.557369),\n    vec2(0.069138, -0.560911),\n    vec2(0.071336, -0.560421),\n    vec2(0.075523, -0.563995),\n    vec2(0.077772, -0.563473),\n    vec2(0.082010, -0.567080),\n    vec2(0.084310, -0.566524),\n    vec2(0.088601, -0.570164),\n    vec2(0.090954, -0.569575),\n    vec2(0.095299, -0.573250),\n    vec2(0.097707, -0.572625),\n    vec2(0.102107, -0.576335),\n    vec2(0.104572, -0.575675),\n    vec2(0.109029, -0.579421),\n    vec2(0.111550, -0.578725),\n    vec2(0.116067, -0.582508),\n    vec2(0.118647, -0.581774),\n    vec2(0.123224, -0.585595),\n    vec2(0.125865, -0.584822),\n    vec2(0.130504, -0.588683),\n    vec2(0.133208, -0.587870),\n    vec2(0.137911, -0.591772),\n    vec2(0.140680, -0.590917),\n    vec2(0.145449, -0.594861),\n    vec2(0.148284, -0.593964),\n    vec2(0.153120, -0.597950),\n    vec2(0.156025, -0.597009),\n    vec2(0.160931, -0.601041),\n    vec2(0.163906, -0.600055),\n    vec2(0.168885, -0.604132),\n    vec2(0.171933, -0.603099),\n    vec2(0.176986, -0.607224),\n    vec2(0.180109, -0.606143),\n    vec2(0.185240, -0.610316),\n    vec2(0.188441, -0.609186),\n    vec2(0.193652, -0.613410),\n    vec2(0.196934, -0.612228),\n    vec2(0.202227, -0.616504),\n    vec2(0.205592, -0.615269),\n    vec2(0.210970, -0.619600),\n    vec2(0.214422, -0.618309),\n    vec2(0.219889, -0.622696),\n    vec2(0.223429, -0.621348),\n    vec2(0.228988, -0.625793),\n    vec2(0.232621, -0.624386),\n    vec2(0.238275, -0.628892),\n    vec2(0.242005, -0.627423),\n    vec2(0.247758, -0.631991),\n    vec2(0.251587, -0.630459),\n    vec2(0.257442, -0.635092),\n    vec2(0.261376, -0.633493),\n    vec2(0.267338, -0.638194),\n    vec2(0.271379, -0.636526),\n    vec2(0.277452, -0.641298),\n    vec2(0.281606, -0.639558),\n    vec2(0.287794, -0.644403),\n    vec2(0.292065, -0.642588),\n    vec2(0.298374, -0.647509),\n    vec2(0.302767, -0.645617),\n    vec2(0.309202, -0.650617),\n    vec2(0.313723, -0.648643),\n    vec2(0.320289, -0.653728),\n    vec2(0.324943, -0.651668),\n    vec2(0.331647, -0.656840),\n    vec2(0.336440, -0.654691),\n    vec2(0.343288, -0.659954),\n    vec2(0.348227, -0.657712),\n    vec2(0.355226, -0.663070),\n    vec2(0.360318, -0.660730),\n    vec2(0.367475, -0.666189),\n    vec2(0.372727, -0.663746),\n    vec2(0.380051, -0.669310),\n    vec2(0.385472, -0.666760),\n    vec2(0.392971, -0.672434),\n    vec2(0.398570, -0.669770),\n    vec2(0.406252, -0.675561),\n    vec2(0.412039, -0.672777),\n    vec2(0.419916, -0.678691),\n    vec2(0.425900, -0.675781),\n    vec2(0.433983, -0.681825),\n    vec2(0.440176, -0.678781),\n    vec2(0.448477, -0.684963),\n    vec2(0.454891, -0.681777),\n    vec2(0.463423, -0.688105),\n    vec2(0.470072, -0.684769),\n    vec2(0.478848, -0.691252),\n    vec2(0.485747, -0.687756),\n    vec2(0.494785, -0.694404),\n    vec2(0.501949, -0.690737),\n    vec2(0.511265, -0.697561),\n    vec2(0.518714, -0.693712),\n    vec2(0.528327, -0.700725),\n    vec2(0.536079, -0.696681),\n    vec2(0.546011, -0.703895),\n    vec2(0.554089, -0.699643),\n    vec2(0.564363, -0.707073),\n    vec2(0.572791, -0.702597),\n    vec2(0.583434, -0.710260),\n    vec2(0.592240, -0.705541),\n    vec2(0.603281, -0.713456),\n    vec2(0.612495, -0.708476),\n    vec2(0.623969, -0.716664),\n    vec2(0.633625, -0.711398),\n    vec2(0.645569, -0.719883),\n    vec2(0.655707, -0.714308),\n    vec2(0.668164, -0.723116),\n    vec2(0.678830, -0.717203),\n    vec2(0.691849, -0.726366),\n    vec2(0.703093, -0.720081),\n    vec2(0.716732, -0.729634),\n    vec2(0.728614, -0.722938),\n    vec2(0.742938, -0.732923),\n    vec2(0.755527, -0.725773),\n    vec2(0.770614, -0.736238),\n    vec2(0.783992, -0.728580),\n    vec2(0.799933, -0.739582),\n    vec2(0.814195, -0.731354),\n    vec2(0.831099, -0.742962),\n    vec2(0.846360, -0.734090),\n    vec2(0.864358, -0.746385),\n    vec2(0.880757, -0.736778),\n    vec2(0.900009, -0.749860),\n    vec2(0.917716, -0.739408),\n    vec2(0.938419, -0.753400),\n    vec2(0.957646, -0.741965),\n    vec2(0.980049, -0.757022),\n    vec2(1.001063, -0.744430),\n    vec2(1.025485, -0.760749),\n    vec2(1.048630, -0.746775),\n    vec2(1.075490, -0.764615),\n    vec2(1.101221, -0.748959),\n    vec2(1.131081, -0.768668),\n    vec2(1.160018, -0.750923),\n    vec2(1.193662, -0.772982),\n    vec2(1.226676, -0.752573),\n    vec2(1.265242, -0.777678),\n    vec2(1.303618, -0.753752),\n    vec2(1.348850, -0.782964),\n    vec2(1.394591, -0.754180),\n    vec2(1.449358, -0.789228),\n    vec2(1.505854, -0.753298),\n    vec2(1.575391, -0.797301),\n    vec2(1.649073, -0.749816),\n    vec2(1.744567, -0.809310),\n    vec2(1.850116, -0.739947),\n    vec2(2.003297, -0.832777),\n    vec2(2.188458, -0.706009),\n    vec2(2.584121, -0.924434)\n\n#elif WAVE == 2\n\n    vec2(1.642979, 0.000000),\n    vec2(1.635535, 0.037842),\n    vec2(1.625613, 0.065997),\n    vec2(1.616145, 0.092142),\n    vec2(1.606506, 0.115385),\n    vec2(1.596995, 0.137694),\n    vec2(1.587431, 0.158273),\n    vec2(1.577937, 0.178238),\n    vec2(1.568422, 0.196969),\n    vec2(1.558959, 0.215241),\n    vec2(1.549487, 0.232555),\n    vec2(1.540057, 0.249502),\n    vec2(1.530625, 0.265666),\n    vec2(1.521231, 0.281524),\n    vec2(1.511839, 0.296719),\n    vec2(1.502481, 0.311654),\n    vec2(1.493128, 0.326013),\n    vec2(1.483807, 0.340145),\n    vec2(1.474491, 0.353769),\n    vec2(1.465208, 0.367191),\n    vec2(1.455930, 0.380160),\n    vec2(1.446684, 0.392946),\n    vec2(1.437445, 0.405321),\n    vec2(1.428235, 0.417532),\n    vec2(1.419034, 0.429367),\n    vec2(1.409862, 0.441051),\n    vec2(1.400699, 0.452391),\n    vec2(1.391564, 0.463590),\n    vec2(1.382439, 0.474471),\n    vec2(1.373342, 0.485222),\n    vec2(1.364254, 0.495676),\n    vec2(1.355195, 0.506009),\n    vec2(1.346145, 0.516065),\n    vec2(1.337123, 0.526006),\n    vec2(1.328111, 0.535688),\n    vec2(1.319126, 0.545262),\n    vec2(1.310152, 0.554591),\n    vec2(1.301205, 0.563819),\n    vec2(1.292269, 0.572815),\n    vec2(1.283359, 0.581716),\n    vec2(1.274460, 0.590396),\n    vec2(1.265589, 0.598985),\n    vec2(1.256727, 0.607366),\n    vec2(1.247893, 0.615660),\n    vec2(1.239070, 0.623754),\n    vec2(1.230273, 0.631766),\n    vec2(1.221487, 0.639588),\n    vec2(1.212729, 0.647330),\n    vec2(1.203980, 0.654891),\n    vec2(1.195259, 0.662376),\n    vec2(1.186549, 0.669687),\n    vec2(1.177865, 0.676925),\n    vec2(1.169192, 0.683995),\n    vec2(1.160546, 0.690996),\n    vec2(1.151911, 0.697835),\n    vec2(1.143303, 0.704608),\n    vec2(1.134705, 0.711225),\n    vec2(1.126135, 0.717778),\n    vec2(1.117575, 0.724181),\n    vec2(1.109042, 0.730522),\n    vec2(1.100520, 0.736718),\n    vec2(1.092024, 0.742854),\n    vec2(1.083540, 0.748850),\n    vec2(1.075082, 0.754789),\n    vec2(1.066635, 0.760592),\n    vec2(1.058215, 0.766338),\n    vec2(1.049806, 0.771954),\n    vec2(1.041423, 0.777516),\n    vec2(1.033052, 0.782950),\n    vec2(1.024707, 0.788332),\n    vec2(1.016373, 0.793590),\n    vec2(1.008066, 0.798797),\n    vec2(0.999769, 0.803885),\n    vec2(0.991500, 0.808922),\n    vec2(0.983241, 0.813844),\n    vec2(0.975009, 0.818717),\n    vec2(0.966788, 0.823477),\n    vec2(0.958594, 0.828190),\n    vec2(0.950411, 0.832794),\n    vec2(0.942254, 0.837351),\n    vec2(0.934109, 0.841801),\n    vec2(0.925990, 0.846207),\n    vec2(0.917882, 0.850508),\n    vec2(0.909800, 0.854766),\n    vec2(0.901730, 0.858922),\n    vec2(0.893686, 0.863036),\n    vec2(0.885654, 0.867050),\n    vec2(0.877648, 0.871023),\n    vec2(0.869653, 0.874899),\n    vec2(0.861684, 0.878735),\n    vec2(0.853727, 0.882477),\n    vec2(0.845796, 0.886179),\n    vec2(0.837876, 0.889788),\n    vec2(0.829983, 0.893359),\n    vec2(0.822101, 0.896840),\n    vec2(0.814246, 0.900283),\n    vec2(0.806401, 0.903638),\n    vec2(0.798583, 0.906956),\n    vec2(0.790777, 0.910188),\n    vec2(0.782997, 0.913383),\n    vec2(0.775227, 0.916494),\n    vec2(0.767485, 0.919570),\n    vec2(0.759753, 0.922564),\n    vec2(0.752049, 0.925522),\n    vec2(0.744355, 0.928400),\n    vec2(0.736688, 0.931244),\n    vec2(0.729031, 0.934008),\n    vec2(0.721402, 0.936740),\n    vec2(0.713783, 0.939393),\n    vec2(0.706191, 0.942015),\n    vec2(0.698611, 0.944560),\n    vec2(0.691056, 0.947073),\n    vec2(0.683513, 0.949511),\n    vec2(0.675997, 0.951918),\n    vec2(0.668491, 0.954252),\n    vec2(0.661012, 0.956556),\n    vec2(0.653544, 0.958787),\n    vec2(0.646103, 0.960988),\n    vec2(0.638673, 0.963119),\n    vec2(0.631269, 0.965220),\n    vec2(0.623876, 0.967252),\n    vec2(0.616510, 0.969255),\n    vec2(0.609155, 0.971190),\n    vec2(0.601827, 0.973097),\n    vec2(0.594510, 0.974937),\n    vec2(0.587219, 0.976748),\n    vec2(0.579939, 0.978495),\n    vec2(0.572686, 0.980213),\n    vec2(0.565444, 0.981868),\n    vec2(0.558229, 0.983495),\n    vec2(0.551024, 0.985059),\n    vec2(0.543847, 0.986596),\n    vec2(0.536680, 0.988071),\n    vec2(0.529540, 0.989520),\n    vec2(0.522411, 0.990908),\n    vec2(0.515308, 0.992270),\n    vec2(0.508217, 0.993572),\n    vec2(0.501152, 0.994849),\n    vec2(0.494098, 0.996066),\n    vec2(0.487071, 0.997259),\n    vec2(0.480055, 0.998394),\n    vec2(0.473065, 0.999504),\n    vec2(0.466087, 1.000556),\n    vec2(0.459135, 1.001585),\n    vec2(0.452194, 1.002557),\n    vec2(0.445280, 1.003506),\n    vec2(0.438377, 1.004399),\n    vec2(0.431500, 1.005269),\n    vec2(0.424635, 1.006084),\n    vec2(0.417796, 1.006876),\n    vec2(0.410968, 1.007615),\n    vec2(0.404167, 1.008331),\n    vec2(0.397377, 1.008993),\n    vec2(0.390613, 1.009634),\n    vec2(0.383860, 1.010223),\n    vec2(0.377134, 1.010789),\n    vec2(0.370419, 1.011305),\n    vec2(0.363731, 1.011798),\n    vec2(0.357054, 1.012241),\n    vec2(0.350403, 1.012663),\n    vec2(0.343764, 1.013035),\n    vec2(0.337151, 1.013386),\n    vec2(0.330549, 1.013688),\n    vec2(0.323973, 1.013969),\n    vec2(0.317409, 1.014202),\n    vec2(0.310871, 1.014414),\n    vec2(0.304345, 1.014579),\n    vec2(0.297844, 1.014724),\n    vec2(0.291355, 1.014822),\n    vec2(0.284893, 1.014899),\n    vec2(0.278442, 1.014931),\n    vec2(0.272017, 1.014943),\n    vec2(0.265603, 1.014909),\n    vec2(0.259216, 1.014857),\n    vec2(0.252840, 1.014759),\n    vec2(0.246490, 1.014642),\n    vec2(0.240152, 1.014480),\n    vec2(0.233840, 1.014300),\n    vec2(0.227539, 1.014077),\n    vec2(0.221265, 1.013834),\n    vec2(0.215002, 1.013549),\n    vec2(0.208766, 1.013245),\n    vec2(0.202540, 1.012899),\n    vec2(0.196341, 1.012535),\n    vec2(0.190153, 1.012129),\n    vec2(0.183992, 1.011705),\n    vec2(0.177842, 1.011239),\n    vec2(0.171718, 1.010756),\n    vec2(0.165606, 1.010232),\n    vec2(0.159520, 1.009691),\n    vec2(0.153445, 1.009110),\n    vec2(0.147397, 1.008512),\n    vec2(0.141360, 1.007873),\n    vec2(0.135349, 1.007218),\n    vec2(0.129349, 1.006524),\n    vec2(0.123376, 1.005813),\n    vec2(0.117414, 1.005063),\n    vec2(0.111479, 1.004297),\n    vec2(0.105555, 1.003493),\n    vec2(0.099657, 1.002673),\n    vec2(0.093771, 1.001814),\n    vec2(0.087910, 1.000940),\n    vec2(0.082062, 1.000029),\n    vec2(0.076239, 0.999102),\n    vec2(0.070428, 0.998138),\n    vec2(0.064643, 0.997158),\n    vec2(0.058869, 0.996142),\n    vec2(0.053122, 0.995111),\n    vec2(0.047386, 0.994044),\n    vec2(0.041677, 0.992962),\n    vec2(0.035979, 0.991845),\n    vec2(0.030307, 0.990712),\n    vec2(0.024646, 0.989545),\n    vec2(0.019012, 0.988363),\n    vec2(0.013389, 0.987146),\n    vec2(0.007792, 0.985915),\n    vec2(0.002207, 0.984649),\n    vec2(-0.003352, 0.983370),\n    vec2(-0.008900, 0.982056),\n    vec2(-0.014421, 0.980729),\n    vec2(-0.019931, 0.979368),\n    vec2(-0.025415, 0.977993),\n    vec2(-0.030887, 0.976585),\n    vec2(-0.036333, 0.975164),\n    vec2(-0.041768, 0.973710),\n    vec2(-0.047176, 0.972243),\n    vec2(-0.052573, 0.970743),\n    vec2(-0.057944, 0.969230),\n    vec2(-0.063303, 0.967685),\n    vec2(-0.068636, 0.966127),\n    vec2(-0.073958, 0.964538),\n    vec2(-0.079254, 0.962936),\n    vec2(-0.084538, 0.961302),\n    vec2(-0.089795, 0.959656),\n    vec2(-0.095042, 0.957980),\n    vec2(-0.100262, 0.956290),\n    vec2(-0.105471, 0.954570),\n    vec2(-0.110653, 0.952838),\n    vec2(-0.115824, 0.951076),\n    vec2(-0.120969, 0.949302),\n    vec2(-0.126103, 0.947498),\n    vec2(-0.131210, 0.945682),\n    vec2(-0.136306, 0.943836),\n    vec2(-0.141375, 0.941979),\n    vec2(-0.146434, 0.940093),\n    vec2(-0.151465, 0.938195),\n    vec2(-0.156486, 0.936268),\n    vec2(-0.161480, 0.934330),\n    vec2(-0.166463, 0.932364),\n    vec2(-0.171420, 0.930386),\n    vec2(-0.176365, 0.928380),\n    vec2(-0.181284, 0.926363),\n    vec2(-0.186192, 0.924318),\n    vec2(-0.191073, 0.922262),\n    vec2(-0.195943, 0.920179),\n    vec2(-0.200786, 0.918085),\n    vec2(-0.205619, 0.915964),\n    vec2(-0.210425, 0.913832),\n    vec2(-0.215219, 0.911673),\n    vec2(-0.219988, 0.909504),\n    vec2(-0.224745, 0.907308),\n    vec2(-0.229475, 0.905102),\n    vec2(-0.234195, 0.902870),\n    vec2(-0.238888, 0.900627),\n    vec2(-0.243569, 0.898359),\n    vec2(-0.248225, 0.896080),\n    vec2(-0.252869, 0.893776),\n    vec2(-0.257487, 0.891462),\n    vec2(-0.262093, 0.889123),\n    vec2(-0.266673, 0.886773),\n    vec2(-0.271242, 0.884399),\n    vec2(-0.275784, 0.882015),\n    vec2(-0.280315, 0.879607),\n    vec2(-0.284820, 0.877188),\n    vec2(-0.289314, 0.874746),\n    vec2(-0.293781, 0.872293),\n    vec2(-0.298237, 0.869817),\n    vec2(-0.302666, 0.867332),\n    vec2(-0.307084, 0.864823),\n    vec2(-0.311476, 0.862304),\n    vec2(-0.315857, 0.859762),\n    vec2(-0.320211, 0.857211),\n    vec2(-0.324554, 0.854637),\n    vec2(-0.328870, 0.852053),\n    vec2(-0.333175, 0.849447),\n    vec2(-0.337454, 0.846831),\n    vec2(-0.341722, 0.844194),\n    vec2(-0.345963, 0.841547),\n    vec2(-0.350193, 0.838878),\n    vec2(-0.354396, 0.836200),\n    vec2(-0.358589, 0.833501),\n    vec2(-0.362755, 0.830792),\n    vec2(-0.366909, 0.828062),\n    vec2(-0.371038, 0.825324),\n    vec2(-0.375155, 0.822564),\n    vec2(-0.379245, 0.819795),\n    vec2(-0.383325, 0.817006),\n    vec2(-0.387377, 0.814207),\n    vec2(-0.391419, 0.811389),\n    vec2(-0.395434, 0.808561),\n    vec2(-0.399439, 0.805714),\n    vec2(-0.403416, 0.802857),\n    vec2(-0.407383, 0.799981),\n    vec2(-0.411323, 0.797097),\n    vec2(-0.415251, 0.794192),\n    vec2(-0.419154, 0.791280),\n    vec2(-0.423045, 0.788348),\n    vec2(-0.426910, 0.785407),\n    vec2(-0.430763, 0.782448),\n    vec2(-0.434590, 0.779480),\n    vec2(-0.438406, 0.776494),\n    vec2(-0.442195, 0.773499),\n    vec2(-0.445973, 0.770486),\n    vec2(-0.449725, 0.767464),\n    vec2(-0.453466, 0.764425),\n    vec2(-0.457180, 0.761377),\n    vec2(-0.460883, 0.758311),\n    vec2(-0.464559, 0.755238),\n    vec2(-0.468224, 0.752146),\n    vec2(-0.471863, 0.749047),\n    vec2(-0.475491, 0.745930),\n    vec2(-0.479092, 0.742806),\n    vec2(-0.482682, 0.739664),\n    vec2(-0.486245, 0.736515),\n    vec2(-0.489797, 0.733348),\n    vec2(-0.493323, 0.730174),\n    vec2(-0.496838, 0.726983),\n    vec2(-0.500326, 0.723785),\n    vec2(-0.503803, 0.720570),\n    vec2(-0.507254, 0.717347),\n    vec2(-0.510693, 0.714109),\n    vec2(-0.514106, 0.710863),\n    vec2(-0.517508, 0.707601),\n    vec2(-0.520883, 0.704332),\n    vec2(-0.524247, 0.701046),\n    vec2(-0.527584, 0.697754),\n    vec2(-0.530911, 0.694446),\n    vec2(-0.534211, 0.691131),\n    vec2(-0.537499, 0.687801),\n    vec2(-0.540762, 0.684464),\n    vec2(-0.544013, 0.681111),\n    vec2(-0.547237, 0.677752),\n    vec2(-0.550451, 0.674377),\n    vec2(-0.553638, 0.670996),\n    vec2(-0.556814, 0.667600),\n    vec2(-0.559963, 0.664198),\n    vec2(-0.563101, 0.660781),\n    vec2(-0.566213, 0.657357),\n    vec2(-0.569313, 0.653919),\n    vec2(-0.572387, 0.650475),\n    vec2(-0.575450, 0.647016),\n    vec2(-0.578487, 0.643551),\n    vec2(-0.581512, 0.640072),\n    vec2(-0.584511, 0.636587),\n    vec2(-0.587498, 0.633088),\n    vec2(-0.590459, 0.629583),\n    vec2(-0.593409, 0.626064),\n    vec2(-0.596332, 0.622539),\n    vec2(-0.599245, 0.619001),\n    vec2(-0.602131, 0.615457),\n    vec2(-0.605005, 0.611899),\n    vec2(-0.607853, 0.608336),\n    vec2(-0.610690, 0.604760),\n    vec2(-0.613501, 0.601178),\n    vec2(-0.616300, 0.597583),\n    vec2(-0.619073, 0.593983),\n    vec2(-0.621834, 0.590370),\n    vec2(-0.624570, 0.586752),\n    vec2(-0.627294, 0.583120),\n    vec2(-0.629991, 0.579484),\n    vec2(-0.632678, 0.575835),\n    vec2(-0.635337, 0.572181),\n    vec2(-0.637986, 0.568515),\n    vec2(-0.640608, 0.564844),\n    vec2(-0.643219, 0.561160),\n    vec2(-0.645804, 0.557472),\n    vec2(-0.648377, 0.553772),\n    vec2(-0.650924, 0.550066),\n    vec2(-0.653460, 0.546349),\n    vec2(-0.655969, 0.542628),\n    vec2(-0.658467, 0.538895),\n    vec2(-0.660939, 0.535157),\n    vec2(-0.663400, 0.531407),\n    vec2(-0.665834, 0.527654),\n    vec2(-0.668256, 0.523889),\n    vec2(-0.670653, 0.520119),\n    vec2(-0.673038, 0.516338),\n    vec2(-0.675397, 0.512553),\n    vec2(-0.677744, 0.508758),\n    vec2(-0.680065, 0.504958),\n    vec2(-0.682375, 0.501147),\n    vec2(-0.684658, 0.497332),\n    vec2(-0.686931, 0.493506),\n    vec2(-0.689176, 0.489677),\n    vec2(-0.691411, 0.485837),\n    vec2(-0.693619, 0.481993),\n    vec2(-0.695816, 0.478139),\n    vec2(-0.697986, 0.474281),\n    vec2(-0.700146, 0.470413),\n    vec2(-0.702278, 0.466541),\n    vec2(-0.704400, 0.462660),\n    vec2(-0.706495, 0.458774),\n    vec2(-0.708579, 0.454879),\n    vec2(-0.710637, 0.450980),\n    vec2(-0.712683, 0.447072),\n    vec2(-0.714703, 0.443161),\n    vec2(-0.716711, 0.439240),\n    vec2(-0.718694, 0.435315),\n    vec2(-0.720665, 0.431382),\n    vec2(-0.722609, 0.427444),\n    vec2(-0.724542, 0.423499),\n    vec2(-0.726449, 0.419549),\n    vec2(-0.728345, 0.415591),\n    vec2(-0.730214, 0.411630),\n    vec2(-0.732072, 0.407660),\n    vec2(-0.733904, 0.403687),\n    vec2(-0.735724, 0.399706),\n    vec2(-0.737518, 0.395721),\n    vec2(-0.739301, 0.391728),\n    vec2(-0.741057, 0.387732),\n    vec2(-0.742802, 0.383728),\n    vec2(-0.744521, 0.379721),\n    vec2(-0.746229, 0.375707),\n    vec2(-0.747910, 0.371689),\n    vec2(-0.749579, 0.367664),\n    vec2(-0.751223, 0.363636),\n    vec2(-0.752855, 0.359600),\n    vec2(-0.754461, 0.355562),\n    vec2(-0.756055, 0.351516),\n    vec2(-0.757623, 0.347468),\n    vec2(-0.759180, 0.343412),\n    vec2(-0.760710, 0.339354),\n    vec2(-0.762230, 0.335289),\n    vec2(-0.763722, 0.331221),\n    vec2(-0.765204, 0.327147),\n    vec2(-0.766659, 0.323070),\n    vec2(-0.768103, 0.318986),\n    vec2(-0.769520, 0.314900),\n    vec2(-0.770927, 0.310808),\n    vec2(-0.772307, 0.306713),\n    vec2(-0.773675, 0.302612),\n    vec2(-0.775017, 0.298509),\n    vec2(-0.776348, 0.294399),\n    vec2(-0.777653, 0.290288),\n    vec2(-0.778946, 0.286170),\n    vec2(-0.780213, 0.282051),\n    vec2(-0.781469, 0.277925),\n    vec2(-0.782698, 0.273798),\n    vec2(-0.783916, 0.269665),\n    vec2(-0.785107, 0.265530),\n    vec2(-0.786288, 0.261389),\n    vec2(-0.787442, 0.257247),\n    vec2(-0.788584, 0.253099),\n    vec2(-0.789701, 0.248950),\n    vec2(-0.790806, 0.244795),\n    vec2(-0.791884, 0.240639),\n    vec2(-0.792952, 0.236478),\n    vec2(-0.793993, 0.232315),\n    vec2(-0.795022, 0.228147),\n    vec2(-0.796026, 0.223978),\n    vec2(-0.797018, 0.219804),\n    vec2(-0.797984, 0.215628),\n    vec2(-0.798938, 0.211449),\n    vec2(-0.799866, 0.207267),\n    vec2(-0.800783, 0.203082),\n    vec2(-0.801673, 0.198894),\n    vec2(-0.802552, 0.194703),\n    vec2(-0.803405, 0.190511),\n    vec2(-0.804247, 0.186315),\n    vec2(-0.805062, 0.182117),\n    vec2(-0.805865, 0.177916),\n    vec2(-0.806643, 0.173713),\n    vec2(-0.807409, 0.169507),\n    vec2(-0.808149, 0.165299),\n    vec2(-0.808877, 0.161089),\n    vec2(-0.809580, 0.156877),\n    vec2(-0.810270, 0.152662),\n    vec2(-0.810935, 0.148445),\n    vec2(-0.811588, 0.144226),\n    vec2(-0.812215, 0.140006),\n    vec2(-0.812831, 0.135783),\n    vec2(-0.813420, 0.131559),\n    vec2(-0.813998, 0.127333),\n    vec2(-0.814549, 0.123105),\n    vec2(-0.815090, 0.118875),\n    vec2(-0.815603, 0.114644),\n    vec2(-0.816106, 0.110411),\n    vec2(-0.816582, 0.106177),\n    vec2(-0.817047, 0.101941),\n    vec2(-0.817486, 0.097704),\n    vec2(-0.817913, 0.093465),\n    vec2(-0.818314, 0.089226),\n    vec2(-0.818704, 0.084985),\n    vec2(-0.819067, 0.080743),\n    vec2(-0.819419, 0.076500),\n    vec2(-0.819745, 0.072255),\n    vec2(-0.820059, 0.068010),\n    vec2(-0.820347, 0.063764),\n    vec2(-0.820624, 0.059517),\n    vec2(-0.820874, 0.055269),\n    vec2(-0.821114, 0.051020),\n    vec2(-0.821326, 0.046771),\n    vec2(-0.821528, 0.042521),\n    vec2(-0.821703, 0.038271),\n    vec2(-0.821867, 0.034020),\n    vec2(-0.822004, 0.029768),\n    vec2(-0.822130, 0.025516),\n    vec2(-0.822230, 0.021264),\n    vec2(-0.822318, 0.017012),\n    vec2(-0.822380, 0.012759),\n    vec2(-0.822431, 0.008506),\n    vec2(-0.822456, 0.004253),\n    vec2(-0.822469, 0.000000),\n    vec2(-0.822456, -0.004253),\n    vec2(-0.822431, -0.008506),\n    vec2(-0.822380, -0.012759),\n    vec2(-0.822318, -0.017012),\n    vec2(-0.822230, -0.021264),\n    vec2(-0.822130, -0.025516),\n    vec2(-0.822004, -0.029768),\n    vec2(-0.821867, -0.034020),\n    vec2(-0.821703, -0.038271),\n    vec2(-0.821528, -0.042521),\n    vec2(-0.821326, -0.046771),\n    vec2(-0.821114, -0.051020),\n    vec2(-0.820874, -0.055269),\n    vec2(-0.820624, -0.059517),\n    vec2(-0.820347, -0.063764),\n    vec2(-0.820059, -0.068010),\n    vec2(-0.819745, -0.072255),\n    vec2(-0.819419, -0.076500),\n    vec2(-0.819067, -0.080743),\n    vec2(-0.818704, -0.084985),\n    vec2(-0.818314, -0.089226),\n    vec2(-0.817913, -0.093465),\n    vec2(-0.817486, -0.097704),\n    vec2(-0.817047, -0.101941),\n    vec2(-0.816582, -0.106177),\n    vec2(-0.816106, -0.110411),\n    vec2(-0.815603, -0.114644),\n    vec2(-0.815090, -0.118875),\n    vec2(-0.814549, -0.123105),\n    vec2(-0.813998, -0.127333),\n    vec2(-0.813420, -0.131559),\n    vec2(-0.812831, -0.135783),\n    vec2(-0.812215, -0.140006),\n    vec2(-0.811588, -0.144226),\n    vec2(-0.810935, -0.148445),\n    vec2(-0.810270, -0.152662),\n    vec2(-0.809580, -0.156877),\n    vec2(-0.808877, -0.161089),\n    vec2(-0.808149, -0.165299),\n    vec2(-0.807409, -0.169507),\n    vec2(-0.806643, -0.173713),\n    vec2(-0.805865, -0.177916),\n    vec2(-0.805062, -0.182117),\n    vec2(-0.804247, -0.186315),\n    vec2(-0.803405, -0.190511),\n    vec2(-0.802552, -0.194703),\n    vec2(-0.801673, -0.198894),\n    vec2(-0.800783, -0.203082),\n    vec2(-0.799866, -0.207267),\n    vec2(-0.798938, -0.211449),\n    vec2(-0.797984, -0.215628),\n    vec2(-0.797018, -0.219804),\n    vec2(-0.796026, -0.223978),\n    vec2(-0.795022, -0.228147),\n    vec2(-0.793993, -0.232315),\n    vec2(-0.792952, -0.236478),\n    vec2(-0.791884, -0.240639),\n    vec2(-0.790806, -0.244795),\n    vec2(-0.789701, -0.248950),\n    vec2(-0.788584, -0.253099),\n    vec2(-0.787442, -0.257247),\n    vec2(-0.786288, -0.261389),\n    vec2(-0.785107, -0.265530),\n    vec2(-0.783916, -0.269665),\n    vec2(-0.782698, -0.273798),\n    vec2(-0.781469, -0.277925),\n    vec2(-0.780213, -0.282051),\n    vec2(-0.778946, -0.286170),\n    vec2(-0.777653, -0.290288),\n    vec2(-0.776348, -0.294399),\n    vec2(-0.775017, -0.298509),\n    vec2(-0.773675, -0.302612),\n    vec2(-0.772307, -0.306713),\n    vec2(-0.770927, -0.310808),\n    vec2(-0.769520, -0.314900),\n    vec2(-0.768103, -0.318986),\n    vec2(-0.766659, -0.323070),\n    vec2(-0.765204, -0.327147),\n    vec2(-0.763722, -0.331221),\n    vec2(-0.762230, -0.335289),\n    vec2(-0.760710, -0.339354),\n    vec2(-0.759180, -0.343412),\n    vec2(-0.757623, -0.347468),\n    vec2(-0.756055, -0.351516),\n    vec2(-0.754461, -0.355562),\n    vec2(-0.752855, -0.359600),\n    vec2(-0.751223, -0.363636),\n    vec2(-0.749579, -0.367664),\n    vec2(-0.747910, -0.371689),\n    vec2(-0.746229, -0.375707),\n    vec2(-0.744521, -0.379721),\n    vec2(-0.742802, -0.383728),\n    vec2(-0.741057, -0.387732),\n    vec2(-0.739301, -0.391728),\n    vec2(-0.737518, -0.395721),\n    vec2(-0.735724, -0.399706),\n    vec2(-0.733904, -0.403687),\n    vec2(-0.732072, -0.407660),\n    vec2(-0.730214, -0.411630),\n    vec2(-0.728345, -0.415591),\n    vec2(-0.726449, -0.419549),\n    vec2(-0.724542, -0.423499),\n    vec2(-0.722609, -0.427444),\n    vec2(-0.720665, -0.431382),\n    vec2(-0.718694, -0.435315),\n    vec2(-0.716711, -0.439240),\n    vec2(-0.714703, -0.443161),\n    vec2(-0.712683, -0.447072),\n    vec2(-0.710637, -0.450980),\n    vec2(-0.708579, -0.454879),\n    vec2(-0.706495, -0.458774),\n    vec2(-0.704400, -0.462660),\n    vec2(-0.702278, -0.466541),\n    vec2(-0.700146, -0.470413),\n    vec2(-0.697986, -0.474281),\n    vec2(-0.695816, -0.478139),\n    vec2(-0.693619, -0.481993),\n    vec2(-0.691411, -0.485837),\n    vec2(-0.689176, -0.489677),\n    vec2(-0.686931, -0.493506),\n    vec2(-0.684658, -0.497332),\n    vec2(-0.682375, -0.501147),\n    vec2(-0.680065, -0.504958),\n    vec2(-0.677744, -0.508758),\n    vec2(-0.675397, -0.512553),\n    vec2(-0.673038, -0.516338),\n    vec2(-0.670653, -0.520119),\n    vec2(-0.668256, -0.523889),\n    vec2(-0.665834, -0.527654),\n    vec2(-0.663400, -0.531407),\n    vec2(-0.660939, -0.535157),\n    vec2(-0.658467, -0.538895),\n    vec2(-0.655969, -0.542628),\n    vec2(-0.653460, -0.546349),\n    vec2(-0.650924, -0.550066),\n    vec2(-0.648377, -0.553772),\n    vec2(-0.645804, -0.557472),\n    vec2(-0.643219, -0.561160),\n    vec2(-0.640608, -0.564844),\n    vec2(-0.637986, -0.568515),\n    vec2(-0.635337, -0.572181),\n    vec2(-0.632678, -0.575835),\n    vec2(-0.629991, -0.579484),\n    vec2(-0.627294, -0.583120),\n    vec2(-0.624570, -0.586752),\n    vec2(-0.621834, -0.590370),\n    vec2(-0.619073, -0.593983),\n    vec2(-0.616300, -0.597583),\n    vec2(-0.613501, -0.601178),\n    vec2(-0.610690, -0.604760),\n    vec2(-0.607853, -0.608336),\n    vec2(-0.605005, -0.611899),\n    vec2(-0.602131, -0.615457),\n    vec2(-0.599245, -0.619001),\n    vec2(-0.596332, -0.622539),\n    vec2(-0.593409, -0.626064),\n    vec2(-0.590459, -0.629583),\n    vec2(-0.587498, -0.633088),\n    vec2(-0.584511, -0.636587),\n    vec2(-0.581512, -0.640072),\n    vec2(-0.578487, -0.643551),\n    vec2(-0.575450, -0.647016),\n    vec2(-0.572387, -0.650475),\n    vec2(-0.569313, -0.653919),\n    vec2(-0.566213, -0.657357),\n    vec2(-0.563101, -0.660781),\n    vec2(-0.559963, -0.664198),\n    vec2(-0.556814, -0.667600),\n    vec2(-0.553638, -0.670996),\n    vec2(-0.550451, -0.674377),\n    vec2(-0.547237, -0.677752),\n    vec2(-0.544013, -0.681111),\n    vec2(-0.540762, -0.684464),\n    vec2(-0.537499, -0.687801),\n    vec2(-0.534211, -0.691131),\n    vec2(-0.530911, -0.694446),\n    vec2(-0.527584, -0.697754),\n    vec2(-0.524247, -0.701046),\n    vec2(-0.520883, -0.704332),\n    vec2(-0.517508, -0.707601),\n    vec2(-0.514106, -0.710863),\n    vec2(-0.510693, -0.714109),\n    vec2(-0.507254, -0.717347),\n    vec2(-0.503803, -0.720570),\n    vec2(-0.500326, -0.723785),\n    vec2(-0.496838, -0.726983),\n    vec2(-0.493323, -0.730174),\n    vec2(-0.489797, -0.733348),\n    vec2(-0.486245, -0.736515),\n    vec2(-0.482682, -0.739664),\n    vec2(-0.479092, -0.742806),\n    vec2(-0.475491, -0.745930),\n    vec2(-0.471863, -0.749047),\n    vec2(-0.468224, -0.752146),\n    vec2(-0.464559, -0.755238),\n    vec2(-0.460883, -0.758311),\n    vec2(-0.457180, -0.761377),\n    vec2(-0.453466, -0.764425),\n    vec2(-0.449725, -0.767464),\n    vec2(-0.445973, -0.770486),\n    vec2(-0.442195, -0.773499),\n    vec2(-0.438406, -0.776494),\n    vec2(-0.434590, -0.779480),\n    vec2(-0.430763, -0.782448),\n    vec2(-0.426910, -0.785407),\n    vec2(-0.423045, -0.788348),\n    vec2(-0.419154, -0.791280),\n    vec2(-0.415251, -0.794192),\n    vec2(-0.411323, -0.797097),\n    vec2(-0.407383, -0.799981),\n    vec2(-0.403416, -0.802857),\n    vec2(-0.399439, -0.805714),\n    vec2(-0.395434, -0.808561),\n    vec2(-0.391419, -0.811389),\n    vec2(-0.387377, -0.814207),\n    vec2(-0.383325, -0.817006),\n    vec2(-0.379245, -0.819795),\n    vec2(-0.375155, -0.822564),\n    vec2(-0.371038, -0.825324),\n    vec2(-0.366909, -0.828062),\n    vec2(-0.362755, -0.830792),\n    vec2(-0.358589, -0.833501),\n    vec2(-0.354396, -0.836200),\n    vec2(-0.350193, -0.838878),\n    vec2(-0.345963, -0.841547),\n    vec2(-0.341722, -0.844194),\n    vec2(-0.337454, -0.846831),\n    vec2(-0.333175, -0.849447),\n    vec2(-0.328870, -0.852053),\n    vec2(-0.324554, -0.854637),\n    vec2(-0.320211, -0.857211),\n    vec2(-0.315857, -0.859762),\n    vec2(-0.311476, -0.862304),\n    vec2(-0.307084, -0.864823),\n    vec2(-0.302666, -0.867332),\n    vec2(-0.298237, -0.869817),\n    vec2(-0.293781, -0.872293),\n    vec2(-0.289314, -0.874746),\n    vec2(-0.284820, -0.877188),\n    vec2(-0.280315, -0.879607),\n    vec2(-0.275784, -0.882015),\n    vec2(-0.271242, -0.884399),\n    vec2(-0.266673, -0.886773),\n    vec2(-0.262093, -0.889123),\n    vec2(-0.257487, -0.891462),\n    vec2(-0.252869, -0.893776),\n    vec2(-0.248225, -0.896080),\n    vec2(-0.243569, -0.898359),\n    vec2(-0.238888, -0.900627),\n    vec2(-0.234195, -0.902870),\n    vec2(-0.229475, -0.905102),\n    vec2(-0.224745, -0.907308),\n    vec2(-0.219988, -0.909504),\n    vec2(-0.215219, -0.911673),\n    vec2(-0.210425, -0.913832),\n    vec2(-0.205619, -0.915964),\n    vec2(-0.200786, -0.918085),\n    vec2(-0.195943, -0.920179),\n    vec2(-0.191073, -0.922262),\n    vec2(-0.186192, -0.924318),\n    vec2(-0.181284, -0.926363),\n    vec2(-0.176365, -0.928380),\n    vec2(-0.171420, -0.930386),\n    vec2(-0.166463, -0.932364),\n    vec2(-0.161480, -0.934330),\n    vec2(-0.156486, -0.936268),\n    vec2(-0.151465, -0.938195),\n    vec2(-0.146434, -0.940093),\n    vec2(-0.141375, -0.941979),\n    vec2(-0.136306, -0.943836),\n    vec2(-0.131210, -0.945682),\n    vec2(-0.126103, -0.947498),\n    vec2(-0.120969, -0.949302),\n    vec2(-0.115824, -0.951076),\n    vec2(-0.110653, -0.952838),\n    vec2(-0.105471, -0.954570),\n    vec2(-0.100262, -0.956290),\n    vec2(-0.095042, -0.957980),\n    vec2(-0.089795, -0.959656),\n    vec2(-0.084538, -0.961302),\n    vec2(-0.079254, -0.962936),\n    vec2(-0.073958, -0.964538),\n    vec2(-0.068636, -0.966127),\n    vec2(-0.063303, -0.967685),\n    vec2(-0.057944, -0.969230),\n    vec2(-0.052573, -0.970743),\n    vec2(-0.047176, -0.972243),\n    vec2(-0.041768, -0.973710),\n    vec2(-0.036333, -0.975164),\n    vec2(-0.030887, -0.976585),\n    vec2(-0.025415, -0.977993),\n    vec2(-0.019931, -0.979368),\n    vec2(-0.014421, -0.980729),\n    vec2(-0.008900, -0.982056),\n    vec2(-0.003352, -0.983370),\n    vec2(0.002207, -0.984649),\n    vec2(0.007792, -0.985915),\n    vec2(0.013389, -0.987146),\n    vec2(0.019012, -0.988363),\n    vec2(0.024646, -0.989545),\n    vec2(0.030307, -0.990712),\n    vec2(0.035979, -0.991845),\n    vec2(0.041677, -0.992962),\n    vec2(0.047386, -0.994044),\n    vec2(0.053122, -0.995111),\n    vec2(0.058869, -0.996142),\n    vec2(0.064643, -0.997158),\n    vec2(0.070428, -0.998138),\n    vec2(0.076239, -0.999102),\n    vec2(0.082062, -1.000029),\n    vec2(0.087910, -1.000940),\n    vec2(0.093771, -1.001814),\n    vec2(0.099657, -1.002673),\n    vec2(0.105555, -1.003493),\n    vec2(0.111479, -1.004297),\n    vec2(0.117414, -1.005063),\n    vec2(0.123376, -1.005813),\n    vec2(0.129349, -1.006524),\n    vec2(0.135349, -1.007218),\n    vec2(0.141360, -1.007873),\n    vec2(0.147397, -1.008512),\n    vec2(0.153445, -1.009110),\n    vec2(0.159520, -1.009691),\n    vec2(0.165606, -1.010232),\n    vec2(0.171718, -1.010756),\n    vec2(0.177842, -1.011239),\n    vec2(0.183992, -1.011705),\n    vec2(0.190153, -1.012129),\n    vec2(0.196341, -1.012535),\n    vec2(0.202540, -1.012899),\n    vec2(0.208766, -1.013245),\n    vec2(0.215002, -1.013549),\n    vec2(0.221265, -1.013834),\n    vec2(0.227539, -1.014077),\n    vec2(0.233840, -1.014300),\n    vec2(0.240152, -1.014480),\n    vec2(0.246490, -1.014642),\n    vec2(0.252840, -1.014759),\n    vec2(0.259216, -1.014857),\n    vec2(0.265603, -1.014909),\n    vec2(0.272017, -1.014943),\n    vec2(0.278442, -1.014931),\n    vec2(0.284893, -1.014899),\n    vec2(0.291355, -1.014822),\n    vec2(0.297844, -1.014724),\n    vec2(0.304345, -1.014579),\n    vec2(0.310871, -1.014414),\n    vec2(0.317409, -1.014202),\n    vec2(0.323973, -1.013969),\n    vec2(0.330549, -1.013688),\n    vec2(0.337151, -1.013386),\n    vec2(0.343764, -1.013035),\n    vec2(0.350403, -1.012663),\n    vec2(0.357054, -1.012241),\n    vec2(0.363731, -1.011798),\n    vec2(0.370419, -1.011305),\n    vec2(0.377134, -1.010789),\n    vec2(0.383860, -1.010223),\n    vec2(0.390613, -1.009634),\n    vec2(0.397377, -1.008993),\n    vec2(0.404167, -1.008331),\n    vec2(0.410968, -1.007615),\n    vec2(0.417796, -1.006876),\n    vec2(0.424635, -1.006084),\n    vec2(0.431500, -1.005269),\n    vec2(0.438377, -1.004399),\n    vec2(0.445280, -1.003506),\n    vec2(0.452194, -1.002557),\n    vec2(0.459135, -1.001585),\n    vec2(0.466087, -1.000556),\n    vec2(0.473065, -0.999504),\n    vec2(0.480055, -0.998394),\n    vec2(0.487071, -0.997259),\n    vec2(0.494098, -0.996066),\n    vec2(0.501152, -0.994849),\n    vec2(0.508217, -0.993572),\n    vec2(0.515308, -0.992270),\n    vec2(0.522411, -0.990908),\n    vec2(0.529540, -0.989520),\n    vec2(0.536680, -0.988071),\n    vec2(0.543847, -0.986596),\n    vec2(0.551024, -0.985059),\n    vec2(0.558229, -0.983495),\n    vec2(0.565444, -0.981868),\n    vec2(0.572686, -0.980213),\n    vec2(0.579939, -0.978495),\n    vec2(0.587219, -0.976748),\n    vec2(0.594510, -0.974937),\n    vec2(0.601827, -0.973097),\n    vec2(0.609155, -0.971190),\n    vec2(0.616510, -0.969255),\n    vec2(0.623876, -0.967252),\n    vec2(0.631269, -0.965220),\n    vec2(0.638673, -0.963119),\n    vec2(0.646103, -0.960988),\n    vec2(0.653544, -0.958787),\n    vec2(0.661012, -0.956556),\n    vec2(0.668491, -0.954252),\n    vec2(0.675997, -0.951918),\n    vec2(0.683513, -0.949511),\n    vec2(0.691056, -0.947073),\n    vec2(0.698611, -0.944560),\n    vec2(0.706191, -0.942015),\n    vec2(0.713783, -0.939393),\n    vec2(0.721402, -0.936740),\n    vec2(0.729031, -0.934008),\n    vec2(0.736688, -0.931244),\n    vec2(0.744355, -0.928400),\n    vec2(0.752049, -0.925522),\n    vec2(0.759753, -0.922564),\n    vec2(0.767485, -0.919570),\n    vec2(0.775227, -0.916494),\n    vec2(0.782997, -0.913383),\n    vec2(0.790777, -0.910188),\n    vec2(0.798583, -0.906956),\n    vec2(0.806401, -0.903638),\n    vec2(0.814246, -0.900283),\n    vec2(0.822101, -0.896840),\n    vec2(0.829983, -0.893359),\n    vec2(0.837876, -0.889788),\n    vec2(0.845796, -0.886179),\n    vec2(0.853727, -0.882477),\n    vec2(0.861684, -0.878735),\n    vec2(0.869653, -0.874899),\n    vec2(0.877648, -0.871023),\n    vec2(0.885654, -0.867050),\n    vec2(0.893686, -0.863036),\n    vec2(0.901730, -0.858922),\n    vec2(0.909800, -0.854766),\n    vec2(0.917882, -0.850508),\n    vec2(0.925990, -0.846207),\n    vec2(0.934109, -0.841801),\n    vec2(0.942254, -0.837351),\n    vec2(0.950411, -0.832794),\n    vec2(0.958594, -0.828190),\n    vec2(0.966788, -0.823477),\n    vec2(0.975009, -0.818717),\n    vec2(0.983241, -0.813844),\n    vec2(0.991500, -0.808922),\n    vec2(0.999769, -0.803885),\n    vec2(1.008066, -0.798797),\n    vec2(1.016373, -0.793590),\n    vec2(1.024707, -0.788332),\n    vec2(1.033052, -0.782950),\n    vec2(1.041423, -0.777516),\n    vec2(1.049806, -0.771954),\n    vec2(1.058215, -0.766338),\n    vec2(1.066635, -0.760592),\n    vec2(1.075082, -0.754789),\n    vec2(1.083540, -0.748850),\n    vec2(1.092024, -0.742854),\n    vec2(1.100520, -0.736718),\n    vec2(1.109042, -0.730522),\n    vec2(1.117575, -0.724181),\n    vec2(1.126135, -0.717778),\n    vec2(1.134705, -0.711225),\n    vec2(1.143303, -0.704608),\n    vec2(1.151911, -0.697835),\n    vec2(1.160546, -0.690996),\n    vec2(1.169192, -0.683995),\n    vec2(1.177865, -0.676925),\n    vec2(1.186549, -0.669687),\n    vec2(1.195259, -0.662376),\n    vec2(1.203980, -0.654891),\n    vec2(1.212729, -0.647330),\n    vec2(1.221487, -0.639588),\n    vec2(1.230273, -0.631766),\n    vec2(1.239070, -0.623754),\n    vec2(1.247893, -0.615660),\n    vec2(1.256727, -0.607366),\n    vec2(1.265589, -0.598985),\n    vec2(1.274460, -0.590396),\n    vec2(1.283359, -0.581716),\n    vec2(1.292269, -0.572815),\n    vec2(1.301205, -0.563819),\n    vec2(1.310152, -0.554591),\n    vec2(1.319126, -0.545262),\n    vec2(1.328111, -0.535688),\n    vec2(1.337123, -0.526006),\n    vec2(1.346145, -0.516065),\n    vec2(1.355195, -0.506009),\n    vec2(1.364254, -0.495676),\n    vec2(1.373342, -0.485222),\n    vec2(1.382439, -0.474471),\n    vec2(1.391564, -0.463590),\n    vec2(1.400699, -0.452391),\n    vec2(1.409862, -0.441051),\n    vec2(1.419034, -0.429367),\n    vec2(1.428235, -0.417532),\n    vec2(1.437445, -0.405321),\n    vec2(1.446684, -0.392946),\n    vec2(1.455930, -0.380160),\n    vec2(1.465208, -0.367191),\n    vec2(1.474491, -0.353769),\n    vec2(1.483807, -0.340145),\n    vec2(1.493128, -0.326013),\n    vec2(1.502481, -0.311654),\n    vec2(1.511839, -0.296719),\n    vec2(1.521231, -0.281524),\n    vec2(1.530625, -0.265666),\n    vec2(1.540057, -0.249502),\n    vec2(1.549487, -0.232555),\n    vec2(1.558959, -0.215241),\n    vec2(1.568422, -0.196969),\n    vec2(1.577937, -0.178238),\n    vec2(1.587431, -0.158273),\n    vec2(1.596995, -0.137694),\n    vec2(1.606506, -0.115385),\n    vec2(1.616145, -0.092142),\n    vec2(1.625613, -0.065997),\n    vec2(1.635535, -0.037842)\n \n#elif WAVE == 3\n\n    vec2(5.458230, 0.000000),\n    vec2(4.222015, 1.388956),\n    vec2(3.629971, 1.063608),\n    vec2(3.350732, 1.256080),\n    vec2(3.122387, 1.119109),\n    vec2(2.962543, 1.225489),\n    vec2(2.820705, 1.138507),\n    vec2(2.708638, 1.212085),\n    vec2(2.605712, 1.148324),\n    vec2(2.519400, 1.204585),\n    vec2(2.438605, 1.154242),\n    vec2(2.368402, 1.199797),\n    vec2(2.301887, 1.158195),\n    vec2(2.242708, 1.196478),\n    vec2(2.186167, 1.161020),\n    vec2(2.135007, 1.194044),\n    vec2(2.085826, 1.163140),\n    vec2(2.040758, 1.192182),\n    vec2(1.997230, 1.164788),\n    vec2(1.956947, 1.190712),\n    vec2(1.917894, 1.166106),\n    vec2(1.881467, 1.189524),\n    vec2(1.846047, 1.167184),\n    vec2(1.812793, 1.188542),\n    vec2(1.780377, 1.168081),\n    vec2(1.749780, 1.187719),\n    vec2(1.719890, 1.168839),\n    vec2(1.691548, 1.187018),\n    vec2(1.663812, 1.169489),\n    vec2(1.637407, 1.186415),\n    vec2(1.611527, 1.170050),\n    vec2(1.586806, 1.185891),\n    vec2(1.562543, 1.170541),\n    vec2(1.539296, 1.185431),\n    vec2(1.516452, 1.170973),\n    vec2(1.494507, 1.185024),\n    vec2(1.472921, 1.171357),\n    vec2(1.452134, 1.184661),\n    vec2(1.431667, 1.171700),\n    vec2(1.411916, 1.184337),\n    vec2(1.392453, 1.172007),\n    vec2(1.373635, 1.184045),\n    vec2(1.355075, 1.172285),\n    vec2(1.337100, 1.183781),\n    vec2(1.319360, 1.172537),\n    vec2(1.302150, 1.183540),\n    vec2(1.285154, 1.172766),\n    vec2(1.268642, 1.183321),\n    vec2(1.252326, 1.172976),\n    vec2(1.236452, 1.183121),\n    vec2(1.220759, 1.173168),\n    vec2(1.205473, 1.182936),\n    vec2(1.190351, 1.173345),\n    vec2(1.175605, 1.182766),\n    vec2(1.161012, 1.173508),\n    vec2(1.146765, 1.182609),\n    vec2(1.132660, 1.173659),\n    vec2(1.118875, 1.182464),\n    vec2(1.105221, 1.173800),\n    vec2(1.091866, 1.182329),\n    vec2(1.078632, 1.173930),\n    vec2(1.065676, 1.182203),\n    vec2(1.052834, 1.174051),\n    vec2(1.040250, 1.182086),\n    vec2(1.027771, 1.174164),\n    vec2(1.015535, 1.181976),\n    vec2(1.003398, 1.174270),\n    vec2(0.991486, 1.181874),\n    vec2(0.979668, 1.174370),\n    vec2(0.968061, 1.181778),\n    vec2(0.956542, 1.174463),\n    vec2(0.945221, 1.181688),\n    vec2(0.933982, 1.174550),\n    vec2(0.922930, 1.181603),\n    vec2(0.911955, 1.174632),\n    vec2(0.901155, 1.181523),\n    vec2(0.890428, 1.174710),\n    vec2(0.879867, 1.181448),\n    vec2(0.869374, 1.174782),\n    vec2(0.859037, 1.181377),\n    vec2(0.848764, 1.174851),\n    vec2(0.838639, 1.181310),\n    vec2(0.828575, 1.174916),\n    vec2(0.818650, 1.181247),\n    vec2(0.808782, 1.174978),\n    vec2(0.799046, 1.181188),\n    vec2(0.789364, 1.175036),\n    vec2(0.779807, 1.181131),\n    vec2(0.770301, 1.175090),\n    vec2(0.760913, 1.181078),\n    vec2(0.751574, 1.175142),\n    vec2(0.742346, 1.181027),\n    vec2(0.733164, 1.175192),\n    vec2(0.724088, 1.180979),\n    vec2(0.715056, 1.175238),\n    vec2(0.706123, 1.180934),\n    vec2(0.697233, 1.175283),\n    vec2(0.688437, 1.180891),\n    vec2(0.679680, 1.175324),\n    vec2(0.671013, 1.180850),\n    vec2(0.662383, 1.175364),\n    vec2(0.653839, 1.180811),\n    vec2(0.645330, 1.175402),\n    vec2(0.636902, 1.180775),\n    vec2(0.628507, 1.175437),\n    vec2(0.620189, 1.180740),\n    vec2(0.611902, 1.175471),\n    vec2(0.603688, 1.180707),\n    vec2(0.595504, 1.175503),\n    vec2(0.587388, 1.180676),\n    vec2(0.579301, 1.175534),\n    vec2(0.571279, 1.180646),\n    vec2(0.563284, 1.175562),\n    vec2(0.555350, 1.180619),\n    vec2(0.547442, 1.175589),\n    vec2(0.539592, 1.180592),\n    vec2(0.531765, 1.175615),\n    vec2(0.523994, 1.180567),\n    vec2(0.516245, 1.175639),\n    vec2(0.508548, 1.180544),\n    vec2(0.500872, 1.175662),\n    vec2(0.493245, 1.180522),\n    vec2(0.485638, 1.175683),\n    vec2(0.478076, 1.180501),\n    vec2(0.470534, 1.175703),\n    vec2(0.463034, 1.180482),\n    vec2(0.455552, 1.175722),\n    vec2(0.448110, 1.180463),\n    vec2(0.440684, 1.175740),\n    vec2(0.433296, 1.180447),\n    vec2(0.425923, 1.175756),\n    vec2(0.418585, 1.180431),\n    vec2(0.411261, 1.175771),\n    vec2(0.403969, 1.180416),\n    vec2(0.396690, 1.175785),\n    vec2(0.389441, 1.180403),\n    vec2(0.382203, 1.175798),\n    vec2(0.374993, 1.180390),\n    vec2(0.367794, 1.175810),\n    vec2(0.360620, 1.180379),\n    vec2(0.353455, 1.175820),\n    vec2(0.346313, 1.180369),\n    vec2(0.339180, 1.175830),\n    vec2(0.332066, 1.180360),\n    vec2(0.324960, 1.175838),\n    vec2(0.317872, 1.180352),\n    vec2(0.310790, 1.175846),\n    vec2(0.303723, 1.180346),\n    vec2(0.296662, 1.175852),\n    vec2(0.289614, 1.180340),\n    vec2(0.282570, 1.175857),\n    vec2(0.275537, 1.180335),\n    vec2(0.268507, 1.175861),\n    vec2(0.261485, 1.180332),\n    vec2(0.254466, 1.175864),\n    vec2(0.247452, 1.180330),\n    vec2(0.240439, 1.175866),\n    vec2(0.233429, 1.180328),\n    vec2(0.226420, 1.175866),\n    vec2(0.219411, 1.180328),\n    vec2(0.212402, 1.175866),\n    vec2(0.205390, 1.180329),\n    vec2(0.198376, 1.175864),\n    vec2(0.191357, 1.180332),\n    vec2(0.184336, 1.175861),\n    vec2(0.177306, 1.180335),\n    vec2(0.170273, 1.175857),\n    vec2(0.163229, 1.180340),\n    vec2(0.156180, 1.175851),\n    vec2(0.149117, 1.180346),\n    vec2(0.142048, 1.175845),\n    vec2(0.134963, 1.180354),\n    vec2(0.127869, 1.175836),\n    vec2(0.120756, 1.180363),\n    vec2(0.113634, 1.175827),\n    vec2(0.106489, 1.180373),\n    vec2(0.099334, 1.175815),\n    vec2(0.092151, 1.180385),\n    vec2(0.084957, 1.175803),\n    vec2(0.077733, 1.180399),\n    vec2(0.070495, 1.175788),\n    vec2(0.063224, 1.180414),\n    vec2(0.055937, 1.175772),\n    vec2(0.048612, 1.180431),\n    vec2(0.041270, 1.175754),\n    vec2(0.033886, 1.180451),\n    vec2(0.026483, 1.175733),\n    vec2(0.019033, 1.180472),\n    vec2(0.011562, 1.175711),\n    vec2(0.004039, 1.180495),\n    vec2(-0.003507, 1.175686),\n    vec2(-0.011110, 1.180521),\n    vec2(-0.018739, 1.175659),\n    vec2(-0.026431, 1.180550),\n    vec2(-0.034150, 1.175629),\n    vec2(-0.041939, 1.180581),\n    vec2(-0.049758, 1.175596),\n    vec2(-0.057654, 1.180616),\n    vec2(-0.065583, 1.175560),\n    vec2(-0.073595, 1.180653),\n    vec2(-0.081645, 1.175521),\n    vec2(-0.089786, 1.180695),\n    vec2(-0.097967, 1.175477),\n    vec2(-0.106250, 1.180741),\n    vec2(-0.114577, 1.175430),\n    vec2(-0.123014, 1.180791),\n    vec2(-0.131501, 1.175377),\n    vec2(-0.140109, 1.180846),\n    vec2(-0.148772, 1.175319),\n    vec2(-0.157568, 1.180907),\n    vec2(-0.166424, 1.175255),\n    vec2(-0.175429, 1.180974),\n    vec2(-0.184499, 1.175185),\n    vec2(-0.193734, 1.181048),\n    vec2(-0.203041, 1.175106),\n    vec2(-0.212532, 1.181131),\n    vec2(-0.222103, 1.175019),\n    vec2(-0.231878, 1.181223),\n    vec2(-0.241743, 1.174922),\n    vec2(-0.251836, 1.181326),\n    vec2(-0.262032, 1.174813),\n    vec2(-0.272482, 1.181441),\n    vec2(-0.283048, 1.174690),\n    vec2(-0.293902, 1.181572),\n    vec2(-0.304887, 1.174550),\n    vec2(-0.316201, 1.181721),\n    vec2(-0.327663, 1.174391),\n    vec2(-0.339501, 1.181892),\n    vec2(-0.351511, 1.174208),\n    vec2(-0.363955, 1.182088),\n    vec2(-0.376597, 1.173996),\n    vec2(-0.389746, 1.182318),\n    vec2(-0.403127, 1.173747),\n    vec2(-0.417106, 1.182589),\n    vec2(-0.431361, 1.173452),\n    vec2(-0.446329, 1.182912),\n    vec2(-0.461630, 1.173096),\n    vec2(-0.477798, 1.183305),\n    vec2(-0.494373, 1.172660),\n    vec2(-0.512023, 1.183791),\n    vec2(-0.530182, 1.172114),\n    vec2(-0.549706, 1.184408),\n    vec2(-0.569886, 1.171411),\n    vec2(-0.591853, 1.185217),\n    vec2(-0.614696, 1.170472),\n    vec2(-0.639979, 1.186320),\n    vec2(-0.666488, 1.169157),\n    vec2(-0.696522, 1.187913),\n    vec2(-0.728392, 1.167187),\n    vec2(-0.765795, 1.190411),\n    vec2(-0.806242, 1.163917),\n    vec2(-0.856608, 1.194876),\n    vec2(-0.912973, 1.157454),\n    vec2(-0.992167, 1.205071),\n    vec2(-1.088324, 1.138955),\n    vec2(-1.288744, 1.249361),\n    vec2(-1.703886, 0.784422),\n    vec2(-1.294880, 0.323388),\n    vec2(-1.100596, 0.429888),\n    vec2(-1.010576, 0.367678),\n    vec2(-0.937519, 0.411389),\n    vec2(-0.887293, 0.377874),\n    vec2(-0.843066, 0.404924),\n    vec2(-0.808760, 0.382340),\n    vec2(-0.777499, 0.401654),\n    vec2(-0.751774, 0.384839),\n    vec2(-0.727886, 0.399683),\n    vec2(-0.707526, 0.386434),\n    vec2(-0.688394, 0.398366),\n    vec2(-0.671705, 0.387539),\n    vec2(-0.655894, 0.397425),\n    vec2(-0.641875, 0.388349),\n    vec2(-0.628515, 0.396720),\n    vec2(-0.616524, 0.388969),\n    vec2(-0.605045, 0.396171),\n    vec2(-0.594646, 0.389458),\n    vec2(-0.584657, 0.395732),\n    vec2(-0.575542, 0.389854),\n    vec2(-0.566762, 0.395374),\n    vec2(-0.558704, 0.390181),\n    vec2(-0.550924, 0.395075),\n    vec2(-0.543750, 0.390455),\n    vec2(-0.536811, 0.394822),\n    vec2(-0.530388, 0.390688),\n    vec2(-0.524167, 0.394606),\n    vec2(-0.518390, 0.390889),\n    vec2(-0.512788, 0.394419),\n    vec2(-0.507573, 0.391064),\n    vec2(-0.502510, 0.394255),\n    vec2(-0.497787, 0.391218),\n    vec2(-0.493198, 0.394110),\n    vec2(-0.488910, 0.391354),\n    vec2(-0.484742, 0.393982),\n    vec2(-0.480842, 0.391475),\n    vec2(-0.477049, 0.393867),\n    vec2(-0.473497, 0.391584),\n    vec2(-0.470041, 0.393764),\n    vec2(-0.466802, 0.391682),\n    vec2(-0.463650, 0.393670),\n    vec2(-0.460695, 0.391771),\n    vec2(-0.457819, 0.393585),\n    vec2(-0.455123, 0.391853),\n    vec2(-0.452500, 0.393507),\n    vec2(-0.450040, 0.391927),\n    vec2(-0.447647, 0.393436),\n    vec2(-0.445406, 0.391995),\n    vec2(-0.443225, 0.393371),\n    vec2(-0.441184, 0.392059),\n    vec2(-0.439199, 0.393310),\n    vec2(-0.437344, 0.392117),\n    vec2(-0.435541, 0.393254),\n    vec2(-0.433857, 0.392171),\n    vec2(-0.432223, 0.393201),\n    vec2(-0.430701, 0.392222),\n    vec2(-0.429224, 0.393152),\n    vec2(-0.427852, 0.392269),\n    vec2(-0.426522, 0.393106),\n    vec2(-0.425290, 0.392313),\n    vec2(-0.424098, 0.393064),\n    vec2(-0.422999, 0.392355),\n    vec2(-0.421937, 0.393023),\n    vec2(-0.420962, 0.392394),\n    vec2(-0.420022, 0.392985),\n    vec2(-0.419165, 0.392432),\n    vec2(-0.418341, 0.392949),\n    vec2(-0.417595, 0.392467),\n    vec2(-0.416880, 0.392915),\n    vec2(-0.416239, 0.392500),\n    vec2(-0.415629, 0.392882),\n    vec2(-0.415089, 0.392532),\n    vec2(-0.414577, 0.392851),\n    vec2(-0.414133, 0.392562),\n    vec2(-0.413715, 0.392822),\n    vec2(-0.413362, 0.392591),\n    vec2(-0.413035, 0.392793),\n    vec2(-0.412769, 0.392619),\n    vec2(-0.412529, 0.392766),\n    vec2(-0.412347, 0.392645),\n    vec2(-0.412189, 0.392740),\n    vec2(-0.412088, 0.392671),\n    vec2(-0.412009, 0.392715),\n    vec2(-0.411986, 0.392695),\n    vec2(-0.411984, 0.392691),\n    vec2(-0.412035, 0.392719),\n    vec2(-0.412108, 0.392668),\n    vec2(-0.412231, 0.392742),\n    vec2(-0.412375, 0.392645),\n    vec2(-0.412569, 0.392764),\n    vec2(-0.412782, 0.392623),\n    vec2(-0.413043, 0.392785),\n    vec2(-0.413324, 0.392602),\n    vec2(-0.413652, 0.392806),\n    vec2(-0.413998, 0.392582),\n    vec2(-0.414389, 0.392827),\n    vec2(-0.414800, 0.392561),\n    vec2(-0.415254, 0.392847),\n    vec2(-0.415726, 0.392542),\n    vec2(-0.416242, 0.392866),\n    vec2(-0.416775, 0.392523),\n    vec2(-0.417350, 0.392885),\n    vec2(-0.417943, 0.392504),\n    vec2(-0.418578, 0.392904),\n    vec2(-0.419229, 0.392485),\n    vec2(-0.419921, 0.392922),\n    vec2(-0.420630, 0.392467),\n    vec2(-0.421379, 0.392940),\n    vec2(-0.422144, 0.392449),\n    vec2(-0.422949, 0.392958),\n    vec2(-0.423770, 0.392431),\n    vec2(-0.424630, 0.392975),\n    vec2(-0.425507, 0.392414),\n    vec2(-0.426422, 0.392993),\n    vec2(-0.427353, 0.392397),\n    vec2(-0.428322, 0.393010),\n    vec2(-0.429307, 0.392379),\n    vec2(-0.430330, 0.393027),\n    vec2(-0.431369, 0.392362),\n    vec2(-0.432446, 0.393044),\n    vec2(-0.433538, 0.392345),\n    vec2(-0.434668, 0.393061),\n    vec2(-0.435814, 0.392328),\n    vec2(-0.436997, 0.393078),\n    vec2(-0.438196, 0.392312),\n    vec2(-0.439432, 0.393095),\n    vec2(-0.440684, 0.392295),\n    vec2(-0.441974, 0.393112),\n    vec2(-0.443279, 0.392278),\n    vec2(-0.444622, 0.393129),\n    vec2(-0.445981, 0.392261),\n    vec2(-0.447377, 0.393146),\n    vec2(-0.448790, 0.392243),\n    vec2(-0.450240, 0.393163),\n    vec2(-0.451707, 0.392226),\n    vec2(-0.453211, 0.393181),\n    vec2(-0.454732, 0.392209),\n    vec2(-0.456292, 0.393198),\n    vec2(-0.457868, 0.392191),\n    vec2(-0.459483, 0.393216),\n    vec2(-0.461115, 0.392173),\n    vec2(-0.462786, 0.393234),\n    vec2(-0.464474, 0.392155),\n    vec2(-0.466202, 0.393252),\n    vec2(-0.467947, 0.392137),\n    vec2(-0.469733, 0.393270),\n    vec2(-0.471536, 0.392119),\n    vec2(-0.473381, 0.393289),\n    vec2(-0.475243, 0.392100),\n    vec2(-0.477148, 0.393308),\n    vec2(-0.479071, 0.392080),\n    vec2(-0.481037, 0.393328),\n    vec2(-0.483021, 0.392061),\n    vec2(-0.485049, 0.393348),\n    vec2(-0.487096, 0.392040),\n    vec2(-0.489189, 0.393368),\n    vec2(-0.491300, 0.392020),\n    vec2(-0.493458, 0.393389),\n    vec2(-0.495636, 0.391998),\n    vec2(-0.497861, 0.393411),\n    vec2(-0.500107, 0.391977),\n    vec2(-0.502402, 0.393433),\n    vec2(-0.504718, 0.391954),\n    vec2(-0.507084, 0.393456),\n    vec2(-0.509471, 0.391931),\n    vec2(-0.511911, 0.393479),\n    vec2(-0.514373, 0.391907),\n    vec2(-0.516889, 0.393504),\n    vec2(-0.519428, 0.391882),\n    vec2(-0.522023, 0.393529),\n    vec2(-0.524642, 0.391856),\n    vec2(-0.527319, 0.393555),\n    vec2(-0.530020, 0.391830),\n    vec2(-0.532782, 0.393582),\n    vec2(-0.535569, 0.391802),\n    vec2(-0.538419, 0.393610),\n    vec2(-0.541296, 0.391773),\n    vec2(-0.544238, 0.393640),\n    vec2(-0.547208, 0.391743),\n    vec2(-0.550246, 0.393671),\n    vec2(-0.553314, 0.391711),\n    vec2(-0.556453, 0.393703),\n    vec2(-0.559623, 0.391678),\n    vec2(-0.562867, 0.393737),\n    vec2(-0.566144, 0.391644),\n    vec2(-0.569499, 0.393772),\n    vec2(-0.572888, 0.391607),\n    vec2(-0.576360, 0.393810),\n    vec2(-0.579868, 0.391569),\n    vec2(-0.583463, 0.393849),\n    vec2(-0.587095, 0.391528),\n    vec2(-0.590820, 0.393891),\n    vec2(-0.594585, 0.391485),\n    vec2(-0.598447, 0.393935),\n    vec2(-0.602352, 0.391440),\n    vec2(-0.606361, 0.393982),\n    vec2(-0.610415, 0.391391),\n    vec2(-0.614579, 0.394032),\n    vec2(-0.618792, 0.391340),\n    vec2(-0.623122, 0.394086),\n    vec2(-0.627504, 0.391285),\n    vec2(-0.632012, 0.394143),\n    vec2(-0.636576, 0.391225),\n    vec2(-0.641275, 0.394204),\n    vec2(-0.646033, 0.391162),\n    vec2(-0.650938, 0.394270),\n    vec2(-0.655907, 0.391093),\n    vec2(-0.661033, 0.394342),\n    vec2(-0.666230, 0.391018),\n    vec2(-0.671598, 0.394419),\n    vec2(-0.677041, 0.390937),\n    vec2(-0.682671, 0.394504),\n    vec2(-0.688384, 0.390849),\n    vec2(-0.694301, 0.394597),\n    vec2(-0.700309, 0.390752),\n    vec2(-0.706542, 0.394698),\n    vec2(-0.712874, 0.390645),\n    vec2(-0.719455, 0.394811),\n    vec2(-0.726147, 0.390526),\n    vec2(-0.733115, 0.394936),\n    vec2(-0.740206, 0.390394),\n    vec2(-0.747606, 0.395076),\n    vec2(-0.755145, 0.390246),\n    vec2(-0.763032, 0.395234),\n    vec2(-0.771076, 0.390078),\n    vec2(-0.779515, 0.395413),\n    vec2(-0.788133, 0.389886),\n    vec2(-0.797205, 0.395618),\n    vec2(-0.806482, 0.389666),\n    vec2(-0.816284, 0.395856),\n    vec2(-0.826326, 0.389409),\n    vec2(-0.836984, 0.396134),\n    vec2(-0.847924, 0.389106),\n    vec2(-0.859596, 0.396465),\n    vec2(-0.871607, 0.388742),\n    vec2(-0.884502, 0.396866),\n    vec2(-0.897812, 0.388299),\n    vec2(-0.912212, 0.397360),\n    vec2(-0.927129, 0.387746),\n    vec2(-0.943427, 0.397984),\n    vec2(-0.960387, 0.387035),\n    vec2(-0.979150, 0.398800),\n    vec2(-0.998797, 0.386089),\n    vec2(-1.020897, 0.399910),\n    vec2(-1.044231, 0.384767),\n    vec2(-1.071104, 0.401510),\n    vec2(-1.099820, 0.382791),\n    vec2(-1.134083, 0.404014),\n    vec2(-1.171396, 0.379514),\n    vec2(-1.218643, 0.408486),\n    vec2(-1.271894, 0.373044),\n    vec2(-1.347989, 0.418687),\n    vec2(-1.441051, 0.354540),\n    vec2(-1.638391, 0.462983),\n    vec2(-2.050458, 0.000000),\n    vec2(-1.638391, -0.462983),\n    vec2(-1.441051, -0.354540),\n    vec2(-1.347989, -0.418687),\n    vec2(-1.271894, -0.373044),\n    vec2(-1.218643, -0.408486),\n    vec2(-1.171396, -0.379514),\n    vec2(-1.134083, -0.404014),\n    vec2(-1.099820, -0.382791),\n    vec2(-1.071104, -0.401510),\n    vec2(-1.044231, -0.384767),\n    vec2(-1.020897, -0.399910),\n    vec2(-0.998797, -0.386089),\n    vec2(-0.979150, -0.398800),\n    vec2(-0.960387, -0.387035),\n    vec2(-0.943427, -0.397984),\n    vec2(-0.927129, -0.387746),\n    vec2(-0.912212, -0.397360),\n    vec2(-0.897812, -0.388299),\n    vec2(-0.884502, -0.396866),\n    vec2(-0.871607, -0.388742),\n    vec2(-0.859596, -0.396465),\n    vec2(-0.847924, -0.389106),\n    vec2(-0.836984, -0.396134),\n    vec2(-0.826326, -0.389409),\n    vec2(-0.816284, -0.395856),\n    vec2(-0.806482, -0.389666),\n    vec2(-0.797205, -0.395618),\n    vec2(-0.788133, -0.389886),\n    vec2(-0.779515, -0.395413),\n    vec2(-0.771076, -0.390078),\n    vec2(-0.763032, -0.395234),\n    vec2(-0.755145, -0.390246),\n    vec2(-0.747606, -0.395076),\n    vec2(-0.740206, -0.390394),\n    vec2(-0.733115, -0.394936),\n    vec2(-0.726147, -0.390526),\n    vec2(-0.719455, -0.394811),\n    vec2(-0.712874, -0.390645),\n    vec2(-0.706542, -0.394698),\n    vec2(-0.700309, -0.390752),\n    vec2(-0.694301, -0.394597),\n    vec2(-0.688384, -0.390849),\n    vec2(-0.682671, -0.394504),\n    vec2(-0.677041, -0.390937),\n    vec2(-0.671598, -0.394419),\n    vec2(-0.666230, -0.391018),\n    vec2(-0.661033, -0.394342),\n    vec2(-0.655907, -0.391093),\n    vec2(-0.650938, -0.394270),\n    vec2(-0.646033, -0.391162),\n    vec2(-0.641275, -0.394204),\n    vec2(-0.636576, -0.391225),\n    vec2(-0.632012, -0.394143),\n    vec2(-0.627504, -0.391285),\n    vec2(-0.623122, -0.394086),\n    vec2(-0.618792, -0.391340),\n    vec2(-0.614579, -0.394032),\n    vec2(-0.610415, -0.391391),\n    vec2(-0.606361, -0.393982),\n    vec2(-0.602352, -0.391440),\n    vec2(-0.598447, -0.393935),\n    vec2(-0.594585, -0.391485),\n    vec2(-0.590820, -0.393891),\n    vec2(-0.587095, -0.391528),\n    vec2(-0.583463, -0.393849),\n    vec2(-0.579868, -0.391569),\n    vec2(-0.576360, -0.393810),\n    vec2(-0.572888, -0.391607),\n    vec2(-0.569499, -0.393772),\n    vec2(-0.566144, -0.391644),\n    vec2(-0.562867, -0.393737),\n    vec2(-0.559623, -0.391678),\n    vec2(-0.556453, -0.393703),\n    vec2(-0.553314, -0.391711),\n    vec2(-0.550246, -0.393671),\n    vec2(-0.547208, -0.391743),\n    vec2(-0.544238, -0.393640),\n    vec2(-0.541296, -0.391773),\n    vec2(-0.538419, -0.393610),\n    vec2(-0.535569, -0.391802),\n    vec2(-0.532782, -0.393582),\n    vec2(-0.530020, -0.391830),\n    vec2(-0.527319, -0.393555),\n    vec2(-0.524642, -0.391856),\n    vec2(-0.522023, -0.393529),\n    vec2(-0.519428, -0.391882),\n    vec2(-0.516889, -0.393504),\n    vec2(-0.514373, -0.391907),\n    vec2(-0.511911, -0.393479),\n    vec2(-0.509471, -0.391931),\n    vec2(-0.507084, -0.393456),\n    vec2(-0.504718, -0.391954),\n    vec2(-0.502402, -0.393433),\n    vec2(-0.500107, -0.391977),\n    vec2(-0.497861, -0.393411),\n    vec2(-0.495636, -0.391998),\n    vec2(-0.493458, -0.393389),\n    vec2(-0.491300, -0.392020),\n    vec2(-0.489189, -0.393368),\n    vec2(-0.487096, -0.392040),\n    vec2(-0.485049, -0.393348),\n    vec2(-0.483021, -0.392061),\n    vec2(-0.481037, -0.393328),\n    vec2(-0.479071, -0.392080),\n    vec2(-0.477148, -0.393308),\n    vec2(-0.475243, -0.392100),\n    vec2(-0.473381, -0.393289),\n    vec2(-0.471536, -0.392119),\n    vec2(-0.469733, -0.393270),\n    vec2(-0.467947, -0.392137),\n    vec2(-0.466202, -0.393252),\n    vec2(-0.464474, -0.392155),\n    vec2(-0.462786, -0.393234),\n    vec2(-0.461115, -0.392173),\n    vec2(-0.459483, -0.393216),\n    vec2(-0.457868, -0.392191),\n    vec2(-0.456292, -0.393198),\n    vec2(-0.454732, -0.392209),\n    vec2(-0.453211, -0.393181),\n    vec2(-0.451707, -0.392226),\n    vec2(-0.450240, -0.393163),\n    vec2(-0.448790, -0.392243),\n    vec2(-0.447377, -0.393146),\n    vec2(-0.445981, -0.392261),\n    vec2(-0.444622, -0.393129),\n    vec2(-0.443279, -0.392278),\n    vec2(-0.441974, -0.393112),\n    vec2(-0.440684, -0.392295),\n    vec2(-0.439432, -0.393095),\n    vec2(-0.438196, -0.392312),\n    vec2(-0.436997, -0.393078),\n    vec2(-0.435814, -0.392328),\n    vec2(-0.434668, -0.393061),\n    vec2(-0.433538, -0.392345),\n    vec2(-0.432446, -0.393044),\n    vec2(-0.431369, -0.392362),\n    vec2(-0.430330, -0.393027),\n    vec2(-0.429307, -0.392379),\n    vec2(-0.428322, -0.393010),\n    vec2(-0.427353, -0.392397),\n    vec2(-0.426422, -0.392993),\n    vec2(-0.425507, -0.392414),\n    vec2(-0.424630, -0.392975),\n    vec2(-0.423770, -0.392431),\n    vec2(-0.422949, -0.392958),\n    vec2(-0.422144, -0.392449),\n    vec2(-0.421379, -0.392940),\n    vec2(-0.420630, -0.392467),\n    vec2(-0.419921, -0.392922),\n    vec2(-0.419229, -0.392485),\n    vec2(-0.418578, -0.392904),\n    vec2(-0.417943, -0.392504),\n    vec2(-0.417350, -0.392885),\n    vec2(-0.416775, -0.392523),\n    vec2(-0.416242, -0.392866),\n    vec2(-0.415726, -0.392542),\n    vec2(-0.415254, -0.392847),\n    vec2(-0.414800, -0.392561),\n    vec2(-0.414389, -0.392827),\n    vec2(-0.413998, -0.392582),\n    vec2(-0.413652, -0.392806),\n    vec2(-0.413324, -0.392602),\n    vec2(-0.413043, -0.392785),\n    vec2(-0.412782, -0.392623),\n    vec2(-0.412569, -0.392764),\n    vec2(-0.412375, -0.392645),\n    vec2(-0.412231, -0.392742),\n    vec2(-0.412108, -0.392668),\n    vec2(-0.412035, -0.392719),\n    vec2(-0.411984, -0.392691),\n    vec2(-0.411986, -0.392695),\n    vec2(-0.412009, -0.392715),\n    vec2(-0.412088, -0.392671),\n    vec2(-0.412189, -0.392740),\n    vec2(-0.412347, -0.392645),\n    vec2(-0.412529, -0.392766),\n    vec2(-0.412769, -0.392619),\n    vec2(-0.413035, -0.392793),\n    vec2(-0.413362, -0.392591),\n    vec2(-0.413715, -0.392822),\n    vec2(-0.414133, -0.392562),\n    vec2(-0.414577, -0.392851),\n    vec2(-0.415089, -0.392532),\n    vec2(-0.415629, -0.392882),\n    vec2(-0.416239, -0.392500),\n    vec2(-0.416880, -0.392915),\n    vec2(-0.417595, -0.392467),\n    vec2(-0.418341, -0.392949),\n    vec2(-0.419165, -0.392432),\n    vec2(-0.420022, -0.392985),\n    vec2(-0.420962, -0.392394),\n    vec2(-0.421937, -0.393023),\n    vec2(-0.422999, -0.392355),\n    vec2(-0.424098, -0.393064),\n    vec2(-0.425290, -0.392313),\n    vec2(-0.426522, -0.393106),\n    vec2(-0.427852, -0.392269),\n    vec2(-0.429224, -0.393152),\n    vec2(-0.430701, -0.392222),\n    vec2(-0.432223, -0.393201),\n    vec2(-0.433857, -0.392171),\n    vec2(-0.435541, -0.393254),\n    vec2(-0.437344, -0.392117),\n    vec2(-0.439199, -0.393310),\n    vec2(-0.441184, -0.392059),\n    vec2(-0.443225, -0.393371),\n    vec2(-0.445406, -0.391995),\n    vec2(-0.447647, -0.393436),\n    vec2(-0.450040, -0.391927),\n    vec2(-0.452500, -0.393507),\n    vec2(-0.455123, -0.391853),\n    vec2(-0.457819, -0.393585),\n    vec2(-0.460695, -0.391771),\n    vec2(-0.463650, -0.393670),\n    vec2(-0.466802, -0.391682),\n    vec2(-0.470041, -0.393764),\n    vec2(-0.473497, -0.391584),\n    vec2(-0.477049, -0.393867),\n    vec2(-0.480842, -0.391475),\n    vec2(-0.484742, -0.393982),\n    vec2(-0.488910, -0.391354),\n    vec2(-0.493198, -0.394110),\n    vec2(-0.497787, -0.391218),\n    vec2(-0.502510, -0.394255),\n    vec2(-0.507573, -0.391064),\n    vec2(-0.512788, -0.394419),\n    vec2(-0.518390, -0.390889),\n    vec2(-0.524167, -0.394606),\n    vec2(-0.530388, -0.390688),\n    vec2(-0.536811, -0.394822),\n    vec2(-0.543750, -0.390455),\n    vec2(-0.550924, -0.395075),\n    vec2(-0.558704, -0.390181),\n    vec2(-0.566762, -0.395374),\n    vec2(-0.575542, -0.389854),\n    vec2(-0.584657, -0.395732),\n    vec2(-0.594646, -0.389458),\n    vec2(-0.605045, -0.396171),\n    vec2(-0.616524, -0.388969),\n    vec2(-0.628515, -0.396720),\n    vec2(-0.641875, -0.388349),\n    vec2(-0.655894, -0.397425),\n    vec2(-0.671705, -0.387539),\n    vec2(-0.688394, -0.398366),\n    vec2(-0.707526, -0.386434),\n    vec2(-0.727886, -0.399683),\n    vec2(-0.751774, -0.384839),\n    vec2(-0.777499, -0.401654),\n    vec2(-0.808760, -0.382340),\n    vec2(-0.843066, -0.404924),\n    vec2(-0.887293, -0.377874),\n    vec2(-0.937519, -0.411389),\n    vec2(-1.010576, -0.367678),\n    vec2(-1.100596, -0.429888),\n    vec2(-1.294880, -0.323388),\n    vec2(-1.703886, -0.784422),\n    vec2(-1.288744, -1.249361),\n    vec2(-1.088324, -1.138955),\n    vec2(-0.992167, -1.205071),\n    vec2(-0.912973, -1.157454),\n    vec2(-0.856608, -1.194876),\n    vec2(-0.806242, -1.163917),\n    vec2(-0.765795, -1.190411),\n    vec2(-0.728392, -1.167187),\n    vec2(-0.696522, -1.187913),\n    vec2(-0.666488, -1.169157),\n    vec2(-0.639979, -1.186320),\n    vec2(-0.614696, -1.170472),\n    vec2(-0.591853, -1.185217),\n    vec2(-0.569886, -1.171411),\n    vec2(-0.549706, -1.184408),\n    vec2(-0.530182, -1.172114),\n    vec2(-0.512023, -1.183791),\n    vec2(-0.494373, -1.172660),\n    vec2(-0.477798, -1.183305),\n    vec2(-0.461630, -1.173096),\n    vec2(-0.446329, -1.182912),\n    vec2(-0.431361, -1.173452),\n    vec2(-0.417106, -1.182589),\n    vec2(-0.403127, -1.173747),\n    vec2(-0.389746, -1.182318),\n    vec2(-0.376597, -1.173996),\n    vec2(-0.363955, -1.182088),\n    vec2(-0.351511, -1.174208),\n    vec2(-0.339501, -1.181892),\n    vec2(-0.327663, -1.174391),\n    vec2(-0.316201, -1.181721),\n    vec2(-0.304887, -1.174550),\n    vec2(-0.293902, -1.181572),\n    vec2(-0.283048, -1.174690),\n    vec2(-0.272482, -1.181441),\n    vec2(-0.262032, -1.174813),\n    vec2(-0.251836, -1.181326),\n    vec2(-0.241743, -1.174922),\n    vec2(-0.231878, -1.181223),\n    vec2(-0.222103, -1.175019),\n    vec2(-0.212532, -1.181131),\n    vec2(-0.203041, -1.175106),\n    vec2(-0.193734, -1.181048),\n    vec2(-0.184499, -1.175185),\n    vec2(-0.175429, -1.180974),\n    vec2(-0.166424, -1.175255),\n    vec2(-0.157568, -1.180907),\n    vec2(-0.148772, -1.175319),\n    vec2(-0.140109, -1.180846),\n    vec2(-0.131501, -1.175377),\n    vec2(-0.123014, -1.180791),\n    vec2(-0.114577, -1.175430),\n    vec2(-0.106250, -1.180741),\n    vec2(-0.097967, -1.175477),\n    vec2(-0.089786, -1.180695),\n    vec2(-0.081645, -1.175521),\n    vec2(-0.073595, -1.180653),\n    vec2(-0.065583, -1.175560),\n    vec2(-0.057654, -1.180616),\n    vec2(-0.049758, -1.175596),\n    vec2(-0.041939, -1.180581),\n    vec2(-0.034150, -1.175629),\n    vec2(-0.026431, -1.180550),\n    vec2(-0.018739, -1.175659),\n    vec2(-0.011110, -1.180521),\n    vec2(-0.003507, -1.175686),\n    vec2(0.004039, -1.180495),\n    vec2(0.011562, -1.175711),\n    vec2(0.019033, -1.180472),\n    vec2(0.026483, -1.175733),\n    vec2(0.033886, -1.180451),\n    vec2(0.041270, -1.175754),\n    vec2(0.048612, -1.180431),\n    vec2(0.055937, -1.175772),\n    vec2(0.063224, -1.180414),\n    vec2(0.070495, -1.175788),\n    vec2(0.077733, -1.180399),\n    vec2(0.084957, -1.175803),\n    vec2(0.092151, -1.180385),\n    vec2(0.099334, -1.175815),\n    vec2(0.106489, -1.180373),\n    vec2(0.113634, -1.175827),\n    vec2(0.120756, -1.180363),\n    vec2(0.127869, -1.175836),\n    vec2(0.134963, -1.180354),\n    vec2(0.142048, -1.175845),\n    vec2(0.149117, -1.180346),\n    vec2(0.156180, -1.175851),\n    vec2(0.163229, -1.180340),\n    vec2(0.170273, -1.175857),\n    vec2(0.177306, -1.180335),\n    vec2(0.184336, -1.175861),\n    vec2(0.191357, -1.180332),\n    vec2(0.198376, -1.175864),\n    vec2(0.205390, -1.180329),\n    vec2(0.212402, -1.175866),\n    vec2(0.219411, -1.180328),\n    vec2(0.226420, -1.175866),\n    vec2(0.233429, -1.180328),\n    vec2(0.240439, -1.175866),\n    vec2(0.247452, -1.180330),\n    vec2(0.254466, -1.175864),\n    vec2(0.261485, -1.180332),\n    vec2(0.268507, -1.175861),\n    vec2(0.275537, -1.180335),\n    vec2(0.282570, -1.175857),\n    vec2(0.289614, -1.180340),\n    vec2(0.296662, -1.175852),\n    vec2(0.303723, -1.180346),\n    vec2(0.310790, -1.175846),\n    vec2(0.317872, -1.180352),\n    vec2(0.324960, -1.175838),\n    vec2(0.332066, -1.180360),\n    vec2(0.339180, -1.175830),\n    vec2(0.346313, -1.180369),\n    vec2(0.353455, -1.175820),\n    vec2(0.360620, -1.180379),\n    vec2(0.367794, -1.175810),\n    vec2(0.374993, -1.180390),\n    vec2(0.382203, -1.175798),\n    vec2(0.389441, -1.180403),\n    vec2(0.396690, -1.175785),\n    vec2(0.403969, -1.180416),\n    vec2(0.411261, -1.175771),\n    vec2(0.418585, -1.180431),\n    vec2(0.425923, -1.175756),\n    vec2(0.433296, -1.180447),\n    vec2(0.440684, -1.175740),\n    vec2(0.448110, -1.180463),\n    vec2(0.455552, -1.175722),\n    vec2(0.463034, -1.180482),\n    vec2(0.470534, -1.175703),\n    vec2(0.478076, -1.180501),\n    vec2(0.485638, -1.175683),\n    vec2(0.493245, -1.180522),\n    vec2(0.500872, -1.175662),\n    vec2(0.508548, -1.180544),\n    vec2(0.516245, -1.175639),\n    vec2(0.523994, -1.180567),\n    vec2(0.531765, -1.175615),\n    vec2(0.539592, -1.180592),\n    vec2(0.547442, -1.175589),\n    vec2(0.555350, -1.180619),\n    vec2(0.563284, -1.175562),\n    vec2(0.571279, -1.180646),\n    vec2(0.579301, -1.175534),\n    vec2(0.587388, -1.180676),\n    vec2(0.595504, -1.175503),\n    vec2(0.603688, -1.180707),\n    vec2(0.611902, -1.175471),\n    vec2(0.620189, -1.180740),\n    vec2(0.628507, -1.175437),\n    vec2(0.636902, -1.180775),\n    vec2(0.645330, -1.175402),\n    vec2(0.653839, -1.180811),\n    vec2(0.662383, -1.175364),\n    vec2(0.671013, -1.180850),\n    vec2(0.679680, -1.175324),\n    vec2(0.688437, -1.180891),\n    vec2(0.697233, -1.175283),\n    vec2(0.706123, -1.180934),\n    vec2(0.715056, -1.175238),\n    vec2(0.724088, -1.180979),\n    vec2(0.733164, -1.175192),\n    vec2(0.742346, -1.181027),\n    vec2(0.751574, -1.175142),\n    vec2(0.760913, -1.181078),\n    vec2(0.770301, -1.175090),\n    vec2(0.779807, -1.181131),\n    vec2(0.789364, -1.175036),\n    vec2(0.799046, -1.181188),\n    vec2(0.808782, -1.174978),\n    vec2(0.818650, -1.181247),\n    vec2(0.828575, -1.174916),\n    vec2(0.838639, -1.181310),\n    vec2(0.848764, -1.174851),\n    vec2(0.859037, -1.181377),\n    vec2(0.869374, -1.174782),\n    vec2(0.879867, -1.181448),\n    vec2(0.890428, -1.174710),\n    vec2(0.901155, -1.181523),\n    vec2(0.911955, -1.174632),\n    vec2(0.922930, -1.181603),\n    vec2(0.933982, -1.174550),\n    vec2(0.945221, -1.181688),\n    vec2(0.956542, -1.174463),\n    vec2(0.968061, -1.181778),\n    vec2(0.979668, -1.174370),\n    vec2(0.991486, -1.181874),\n    vec2(1.003398, -1.174270),\n    vec2(1.015535, -1.181976),\n    vec2(1.027771, -1.174164),\n    vec2(1.040250, -1.182086),\n    vec2(1.052834, -1.174051),\n    vec2(1.065676, -1.182203),\n    vec2(1.078632, -1.173930),\n    vec2(1.091866, -1.182329),\n    vec2(1.105221, -1.173800),\n    vec2(1.118875, -1.182464),\n    vec2(1.132660, -1.173659),\n    vec2(1.146765, -1.182609),\n    vec2(1.161012, -1.173508),\n    vec2(1.175605, -1.182766),\n    vec2(1.190351, -1.173345),\n    vec2(1.205473, -1.182936),\n    vec2(1.220759, -1.173168),\n    vec2(1.236452, -1.183121),\n    vec2(1.252326, -1.172976),\n    vec2(1.268642, -1.183321),\n    vec2(1.285154, -1.172766),\n    vec2(1.302150, -1.183540),\n    vec2(1.319360, -1.172537),\n    vec2(1.337100, -1.183781),\n    vec2(1.355075, -1.172285),\n    vec2(1.373635, -1.184045),\n    vec2(1.392453, -1.172007),\n    vec2(1.411916, -1.184337),\n    vec2(1.431667, -1.171700),\n    vec2(1.452134, -1.184661),\n    vec2(1.472921, -1.171357),\n    vec2(1.494507, -1.185024),\n    vec2(1.516452, -1.170973),\n    vec2(1.539296, -1.185431),\n    vec2(1.562543, -1.170541),\n    vec2(1.586806, -1.185891),\n    vec2(1.611527, -1.170050),\n    vec2(1.637407, -1.186415),\n    vec2(1.663812, -1.169489),\n    vec2(1.691548, -1.187018),\n    vec2(1.719890, -1.168839),\n    vec2(1.749780, -1.187719),\n    vec2(1.780377, -1.168081),\n    vec2(1.812793, -1.188542),\n    vec2(1.846047, -1.167184),\n    vec2(1.881467, -1.189524),\n    vec2(1.917894, -1.166106),\n    vec2(1.956947, -1.190712),\n    vec2(1.997230, -1.164788),\n    vec2(2.040758, -1.192182),\n    vec2(2.085826, -1.163140),\n    vec2(2.135007, -1.194044),\n    vec2(2.186167, -1.161020),\n    vec2(2.242708, -1.196478),\n    vec2(2.301887, -1.158195),\n    vec2(2.368402, -1.199797),\n    vec2(2.438605, -1.154242),\n    vec2(2.519400, -1.204585),\n    vec2(2.605712, -1.148324),\n    vec2(2.708638, -1.212085),\n    vec2(2.820705, -1.138507),\n    vec2(2.962543, -1.225489),\n    vec2(3.122387, -1.119109),\n    vec2(3.350732, -1.256080),\n    vec2(3.629971, -1.063608),\n    vec2(4.222015, -1.388956)\n\n#endif\n);\n\nvec2 get_sample_rot(float index, vec2 rotate) {\n    // .8 is just a magic number chosen empirically so that the filtered waveform looks right\n    index = index * float(SIZE) + .8;\n    int i = int(index);\n    float f = index - float(i);\n\n    // Cubic interpolation of 4 adjacent samples\n    vec2 s0 = wavetable[(i-1) % SIZE],\n         s1 = wavetable[(i+0) % SIZE],\n         s2 = wavetable[(i+1) % SIZE],\n         s3 = wavetable[(i+2) % SIZE];\n    vec2 mixed = (-f*(f-1.)*(f-2.)/6. * s0) +\n        ((f+1.)*(f-1.)*(f-2.)/2. * s1) + \n        (-(f+1.)*f*(f-2.)/2. * s2) +\n        ((f+1.)*f*(f-1.)/6. * s3);\n    return GAIN * cmul(mixed, rotate);\n}", "buffer_b_code": "// Buffer B stores min/max values of the real/imaginary components of samples in a\n// range of the wavetable (the window controlled by DOWNSAMPLE_FACTOR)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv1 = fragCoord / iResolution.xy;\n\n    float t = uv1.y * PI * 2.;\n    vec2 rotate = vec2(cos(t), sin(t));\n\n    // Get the min/max values of the next DOWNSAMPLE_FACTOR+1 samples. The +1 is\n    // because we store segment endpoints, and X segments have X+1 endpoints.\n    // Note that sample xy coordinates correspond to logical yz coordinates\n    vec2 s1 = get_sample_rot(uv1.x, rotate);\n    float min_y = s1.x, max_y = s1.x, min_z = s1.y, max_z = s1.y;\n    for (int i = 1; i < DOWNSAMPLE_FACTOR+2; i++) {\n    \tvec2 uv2 = (fragCoord + vec2(i, 0)) / iResolution.xy;\n    \tvec2 s2 = get_sample_rot(uv2.x, rotate);\n\n        min_y = min(min_y, s2.x);\n        max_y = max(max_y, s2.x);\n        min_z = min(min_z, s2.y);\n        max_z = max(max_z, s2.y);\n    }\n\n    // Store the extents plus a WAVE_SIZE fudge factor\n    const float M = 1.*WAVE_SIZE;\n    fragColor = vec4(min_y-M, max_y+M, min_z-M, max_z+M);\n}", "buffer_b_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfzN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1878, 2039, 2119, 2119, 3115], [3117, 3243, 3320, 3320, 3730], [3732, 3732, 3798, 3798, 3849], [3851, 3851, 3919, 3919, 3964]], "test": "untested"}
{"id": "3lsfR4", "name": "Strange xor", "author": "NLIBS", "description": "trippy eh?", "tags": ["trippy", "xor", "pattern", "short"], "likes": 3, "viewed": 320, "published": 3, "date": "1596171936", "time_retrieved": "2024-07-30T20:53:01.221399", "image_code": "void mainImage( out vec4 O, in vec2 U )\n{\t\n    vec2 R = iResolution.xy, p = (2.*U-R)/R.x;\n\tfloat r = (p.x+p.y)*1e3;\n    O-=O-fract(float(int(atan(p.y,iTime*.01)*r+iTime*10.)^int(r))/256.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 190]], "test": "untested"}
{"id": "3lKGRm", "name": "That's Six-Dimensional Gravy", "author": "blackle", "description": "3d slices of a 6d object. rotation done with a random 6x6 orthogonal matrix. uncomment the defines at the top to see what the 6d object looks like without the rotation", "tags": ["slices", "6d", "gravy", "highdimensional"], "likes": 12, "viewed": 531, "published": 3, "date": "1596171237", "time_retrieved": "2024-07-30T20:53:02.008295", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n#define ROTATE\n#define SLICE\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n    vec3 p1 = p;\n#ifdef SLICE\n    vec3 p2 = vec3(asin(sin(iTime)),0,0);\n#else\n    vec3 p2 = vec3(1,0,0);\n#endif\n\n#ifdef ROTATE\n\tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n\tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n\tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n\tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n#else    \n    mat3 r11 = mat3(1);\n    mat3 r12 = mat3(0);\n    mat3 r21 = mat3(0);\n    mat3 r22 = mat3(1);\n#endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\tvec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/2.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.7,uv));\n    vec3 init = vec3(-10,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n    vec3 col = ao*mix(ss,diff,.5)*vec3(.3,.1,.07)+pow(spec,30.)*fres*3.*ro;\n    \n    float bg = length(sin(cam*2.5)*0.4+0.6)/sqrt(3.);\n  \tfragColor.xyz = hit ? sqrt(col) : vec3(pow(bg,3.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lKGRm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[224, 224, 260, 260, 325], [327, 327, 346, 346, 1108], [1110, 1110, 1131, 1237, 1294], [1296, 1296, 1315, 1315, 1430], [1432, 1432, 1489, 1489, 2912]], "test": "untested"}
{"id": "WtsBR4", "name": "OpenSimplex2 Fractal Warp V3", "author": "Auburn", "description": "Modified https://www.shadertoy.com/view/wlcXzB", "tags": ["noise"], "likes": 7, "viewed": 528, "published": 3, "date": "1596160692", "time_retrieved": "2024-07-30T20:53:02.830098", "image_code": "////////////////// K.jpg's Smooth Re-oriented 8-Point BCC Noise (OpenSimplex 2, Smooth Version) //////////////////\n///////////////////////// Modified to output a 2D vector instead of a standard 1D value. /////////////////////////\n\n// Borrowed from Stefan Gustavson's noise code\nvec4 permute(vec4 t) {\n    return t * (t * 34.0 + 133.0);\n}\n\n// Gradient set is a normalized expanded rhombic dodecahedron\nvec3 grad(float hash) {\n    \n    // Random vertex of a cube, +/- 1 each\n    vec3 cube = mod(floor(hash / vec3(1.0, 2.0, 4.0)), 2.0) * 2.0 - 1.0;\n    \n    // Random edge of the three edges connected to that vertex\n    // Also a cuboctahedral vertex\n    // And corresponds to the face of its dual, the rhombic dodecahedron\n    vec3 cuboct = cube;\n    cuboct[int(hash / 16.0)] = 0.0;\n    \n    // In a funky way, pick one of the four points on the rhombic face\n    float type = mod(floor(hash / 8.0), 2.0);\n    vec3 rhomb = (1.0 - type) * cube + type * (cuboct + cross(cube, cuboct));\n    \n    // Expand it so that the new edges are the same length\n    // as the existing ones\n    vec3 grad = cuboct * 1.22474487139 + rhomb;\n    \n    // To make all gradients the same length, we only need to shorten the\n    // second type of vector. We also put in the whole noise scale constant.\n    // The compiler should reduce it into the existing floats. I think.\n    grad *= (1.0 - 0.042942436724648037 * type) * 3.5946317686139184;\n    \n    return grad;\n}\n\n// BCC lattice split up into 2 cube lattices\nvec2 bccNoisePart(vec3 X) {\n    vec3 b = floor(X);\n    vec4 i4 = vec4(X - b, 2.5);\n    \n    // Pick between each pair of oppposite corners in the cube.\n    vec3 v1 = b + floor(dot(i4, vec4(.25)));\n    vec3 v2 = b + vec3(1, 0, 0) + vec3(-1, 1, 1) * floor(dot(i4, vec4(-.25, .25, .25, .35)));\n    vec3 v3 = b + vec3(0, 1, 0) + vec3(1, -1, 1) * floor(dot(i4, vec4(.25, -.25, .25, .35)));\n    vec3 v4 = b + vec3(0, 0, 1) + vec3(1, 1, -1) * floor(dot(i4, vec4(.25, .25, -.25, .35)));\n    \n    // Gradient hashes for the four vertices in this half-lattice.\n    vec4 hashes = permute(mod(vec4(v1.x, v2.x, v3.x, v4.x), 289.0));\n    hashes = permute(mod(hashes + vec4(v1.y, v2.y, v3.y, v4.y), 289.0));\n    vec4 hashesRaw = permute(mod(hashes + vec4(v1.z, v2.z, v3.z, v4.z), 289.0));\n    hashes = mod(hashesRaw, 48.0);\n    vec4 outDirHashes = mod(floor(hashesRaw / 48.0), 6.0);\n    vec4 outDirAngles = outDirHashes / 6.0 * 3.14159 * 2.0; // You could easily create more than 6 output base directions, with a wider-ranged hash\n    \n    // Gradient extrapolations & kernel function\n    vec3 d1 = X - v1; vec3 d2 = X - v2; vec3 d3 = X - v3; vec3 d4 = X - v4;\n    vec4 a = max(0.75 - vec4(dot(d1, d1), dot(d2, d2), dot(d3, d3), dot(d4, d4)), 0.0);\n    vec4 aa = a * a; vec4 aaaa = aa * aa;\n    vec3 g1 = grad(hashes.x); vec3 g2 = grad(hashes.y);\n    vec3 g3 = grad(hashes.z); vec3 g4 = grad(hashes.w);\n    vec4 extrapolations = vec4(dot(d1, g1), dot(d2, g2), dot(d3, g3), dot(d4, g4));\n    vec4 extrapolationsP = extrapolations * sin(outDirAngles);\n    vec4 extrapolationsQ = extrapolations * cos(outDirAngles);\n    \n    // Return it all as a vec4\n    return vec2(dot(aaaa, extrapolationsP), dot(aaaa, extrapolationsQ));\n   \n}\n\n// Classic \"Simplex\" noise lattice orientation.\nvec2 bccNoise_XYZ(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    X = dot(X, vec3(2.0/3.0)) - X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec2 bccNoise_PlaneFirst(vec3 X) {\n    \n    // Orthonormal rotation, not a skew transform.\n    mat3 orthonormalMap = mat3(\n        0.788675134594813, -0.211324865405187, -0.577350269189626,\n        -0.211324865405187, 0.788675134594813, -0.577350269189626,\n        0.577350269189626, 0.577350269189626, 0.577350269189626);\n    \n    X = orthonormalMap * X;\n    return bccNoisePart(X) + bccNoisePart(X + 144.5);\n}\n\n//////////////////////////////// End noise code ////////////////////////////////\n\n// Borrowed from https://www.shadertoy.com/view/Wt3XzS by FabriceNeyret2\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    // Normalized pixel coordinates (from 0 to 1 on largest axis)\n    vec2 uv = fragCoord;\n    uv *= 0.004;\n    \n    // Input point\n    vec3 X = vec3(uv, mod(iTime, 10000.0) * 0.09);\n    \n    // Evaluate noise\n    vec2 noiseResult = vec2(0);\n    float amp = 1.;\n    float z = 0.;\n    \n    for(int i = 0; i < 11; i++)\n    {\n    \tnoiseResult += bccNoise_PlaneFirst(X + vec3(noiseResult * (0.8 / sqrt(amp)), z)) * amp;\n        X *= 1.57;\n        amp *= 0.65;\n        z += 17.;\n    }\n    \n    float phi = atan(noiseResult.y, noiseResult.x);\n    vec3 col = hsv2rgb(vec3(phi/(2.*3.14159), 1., min(1.,length(noiseResult)*0.9)));\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsBR4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[231, 278, 300, 300, 337], [339, 401, 424, 472, 1443], [1445, 1490, 1517, 1517, 3202], [3204, 3252, 3279, 3335, 3426], [3428, 3579, 3613, 3669, 3990], [4074, 4147, 4169, 4169, 4338], [4340, 4340, 4395, 4466, 5081]], "test": "untested"}
{"id": "wlffRN", "name": "spiralyRects", "author": "pohy", "description": "spiralyRects", "tags": ["spiralyrects"], "likes": 2, "viewed": 197, "published": 3, "date": "1596143315", "time_retrieved": "2024-07-30T20:53:03.597047", "image_code": "#define PI 3.14159\n\nfloat Circle(vec2 uv, vec2 p, float r) {\n\tfloat d = distance(uv, p);\n    d = smoothstep(r, r * .99, d);\n    return d;\n}\n\nvec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nfloat Rect(vec2 uv, vec2 p, vec2 wh, float rot) {\n    vec2 sizeH = wh * .5;\n    vec2 uvRot = rotate(uv - p, rot);\n    float d = distance(uvRot, vec2(clamp(uvRot.x, -sizeH.x, sizeH.x), clamp(uvRot.y, -sizeH.y, sizeH.y)));\n    d = smoothstep(.001, .0, d);\n    return d;\n}\n\nfloat vecAngle(vec2 a, vec2 b) {\n\tfloat cosA = dot(a, b) / length(a) * length(b);\n    return acos(cosA);\n}\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\n\nfloat posCos(float x) {\n    return cos(x) * .5 + .5;\n}\n\nfloat remap(float val, vec2 from, vec2 to) {\n    return val / from.x * to.x;\n}\n\nfloat triangle(float x, float p) {\n    return 4. / p * (x - p / 2. * floor(2. * x / p + .5)) * pow(-1., floor(2. * x / p + .5));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    float t = 10. + iTime * .2;\n\n    // Time varying pixel color\n    vec3 col;// = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    //uv *= .1 + posSin(t) * 3.;\n    uv *= 1.7;\n    \n    \n    //col += Rect(uv, vec2(1), .25, PI * sin(t) * .5 + PI * mouse.x);\n    \n    float start = 150. * posCos(300. + sin(t) + posCos(t));\n    //float start = 0.;\n    float it = 5. + 300. * posSin(cos(t) + posSin(t));//posSin(t) * 1000.;\n    for (float i = start; i < it; i++) {\n        float iN = i / it;\n    \tfloat r =  .005;\n        float rotR = i * .002;\n        float spread = i * .1;\n        vec2 p = vec2(sin(spread) * rotR, cos(spread) * rotR);\n        //float d = Circle(uv, p, r);\n        float a = vecAngle(vec2(.0001, .00001), p) + sin(t + i * .1);\n        vec2 wh = vec2(.1 * iN, distance(vec2(0), p) * .1 + iN * .3);\n        float d = Rect(uv, p, wh, a);\n        d *= iN * .2;\n        //d *= texture(iChannel0, p).rgb;\n        //col += texture(iChannel0, rotate(uv - p * wh, a) * 4.).rgb * (iN * .3) * d;\n        col += d * vec3(.9 * iN, .2 * iN, .9);\n        ///*\n        if (i > it - 1.) {\n        \tcol *= .3 + fract(it) * iN;\n        }\n\t\t//*/\n        //col.r +=  vecAngle(vec2(.0001, .00001), p);\n        //col = sampleNoise.rgb;\n        //col.rg += samplePos;\n    }\n\t    \n    //col.rg += uv;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 60, 60, 139], [141, 141, 171, 171, 267], [269, 269, 318, 318, 538], [540, 540, 572, 572, 646], [648, 648, 671, 671, 702], [704, 704, 727, 727, 758], [760, 760, 804, 804, 838], [840, 840, 874, 874, 970], [972, 972, 1029, 1079, 2563]], "test": "untested"}
{"id": "wtlBzn", "name": "Ray Tracing One Weekend - jvbs96", "author": "joaovbs96", "description": "Shadertoy implementation of Peter Shirley's Ray Tracing One Weekend. First time playing around with shaders, so a lot of things here are hacks. Tried to keep it close to the book whenever I could. \n\nTakes about 15s to compile the code.", "tags": ["raytracing", "petershirley", "rtow"], "likes": 7, "viewed": 932, "published": 3, "date": "1596140196", "time_retrieved": "2024-07-30T20:53:04.597372", "image_code": "//////////////////////////////////////////////////////////////////////////////\n//\t\t\t\t\tRay Tracing in One Weekend\n//\t\t\t\tShadertoy port by João V. B. Silva\n//\n// \tThis is my first time doing anything remotely related to shaders, so you\n// might see a lot of hacks and non-recommended things here. Tried to stay as\n// close to Peter Shirley's book as I could. Feedback is appreciated :)\n//\n//  The scene (i.e. geometries & BRDFs) is generated by a Python script. You \n// can find it (as well as a copy of these files) on this repository:\n// https://github.com/joaovbs96/shadertoy_raytracer\n//\n//////////////////////////////////////////////////////////////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    // Accumulate and output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 oldColor = texture(iChannel0, uv);\n    \n    fragColor = vec4(sqrt(oldColor.rgb / float(iFrame)), 1.0f);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// ===================== Ray =====================\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n};\n\n// p = o + t * d\nvec3 pointAt(Ray r, float t) {\n\treturn r.origin + t * r.direction;\n}\n\n\n// ===================== Camera =====================\nstruct Camera {\n    vec3 origin;\n    vec3 hor, vert;\n    vec3 llc;\n    vec3 u, v, w;\n    float lens_radius;\n};\n\n// Creates new Camera\nCamera newCamera(vec3 lookfrom, vec3 lookat, \n                 vec3 vup, float vfov, \n                 float aRatio, float aperture, float focus_dist) {\n    float theta = radians(vfov);\n    float vpH = 2.0f * tan(theta / 2.0f);\n    float vpW = aRatio * vpH;\n    \n\tvec3 w = normalize(lookfrom - lookat);\n    vec3 u = normalize(cross(vup, w));\n    vec3 v = cross(w, u);\n    \n\tvec3 o = lookfrom;\n    vec3 hh = focus_dist * vpW * u;\n    vec3 vv = focus_dist * vpH* v;\n    vec3 llc = o - hh/2.0f - vv/2.0f - focus_dist * w;\n    return Camera(o, hh, vv, llc, u, v, w, aperture / 2.0f);\n}\n\n// Generates a new ray leaving from the camera\nRay getRay(Camera c, float s, float t) {\n    vec3 rd = c.lens_radius * randomInUnitDisk();\n    vec3 offset = c.u * rd.x + c.v * rd.y;\n    return Ray(c.origin + offset, c.llc + s * c.hor + t * c.vert - c.origin - offset);\n}\n\n// ===================== Hit Record =====================\n\nstruct HitRecord {\n    vec3 p;\n    vec3 n;\n    bool front_face;\n    float t;\n    int index;\n};\n    \n// TODO: add brdfIdx to the geometry, allowing us to reuse BRDFs accross several geometries\n    \n// ===================== Sphere =====================\n    \nstruct Sphere{\n    vec3 center;\n    float r;\n};\n    \nbool hitSphere(Sphere s, Ray r, float t_min, float t_max, out HitRecord rec){\n\tvec3 oc = r.origin - s.center;\n    float a = squaredLength(r.direction);\n    float hb = dot(oc, r.direction);\n    float c = squaredLength(oc) - s.r * s.r;\n    float d = hb*hb - a * c;\n    \n    // if the descriminant is > 0, we might have a hit\n    if(d > 0.0f){\n        float root = sqrt(d);\n        \n        float t = (-hb - root) / a;\n        if(t < t_max && t > t_min){\n            vec3 p = pointAt(r, t);\n            vec3 n = (p - s.center) / s.r;\n            rec = HitRecord(p, faceforward(n, r.direction, n), dot(r.direction, n) < 0.0f, t, 0);\n            return true;\n        }\n        \n        t = (-hb + root) / a;\n        if(t < t_max && t > t_min){\n            vec3 p = pointAt(r, t);\n            vec3 n = (p - s.center) / s.r;\n            rec = HitRecord(p, faceforward(n, r.direction, n), dot(r.direction, n) < 0.0f, t, 0);\n            return true;\n        }\n        \n        // if neither of the t's is in the (t_min, t_max) range, it's not a hit\n    }\n    \n    // else, not a hit\n    return false;\n}\n\n// List of Geometries - must have one BRDF per geometry\nSphere spheres[148] = Sphere[](Sphere(vec3(0.0f, -1000.0f, 0.0f), 1000.0f),\tSphere(vec3(-16.32f,0.2f,-16.2f), 0.2f),\tSphere(vec3(-16.93f,0.2f,-14.8f), 0.2f),\n                               Sphere(vec3(-16.19f,0.2f,-12.17f), 0.2f),\tSphere(vec3(-16.43f,0.2f,-10.84f), 0.2f),\tSphere(vec3(-16.72f,0.2f,-8.63f), 0.2f),\n                               Sphere(vec3(-16.67f,0.2f,-6.33f), 0.2f),\t\tSphere(vec3(-16.81f,0.2f,-4.89f), 0.2f),\tSphere(vec3(-16.23f,0.2f,-2.25f), 0.2f),\n                               Sphere(vec3(-16.16f,0.2f,-0.3f), 0.2f),\t\tSphere(vec3(-16.15f,0.2f,1.3f), 0.2f),\t\tSphere(vec3(-16.92f,0.2f,3.47f), 0.2f),\n                               Sphere(vec3(-16.22f,0.2f,5.57f), 0.2f),\t\tSphere(vec3(-14.5f,0.2f,-16.55f), 0.2f),\tSphere(vec3(-14.84f,0.2f,-14.86f), 0.2f),\n                               Sphere(vec3(-14.86f,0.2f,-12.63f), 0.2f),\tSphere(vec3(-14.77f,0.2f,-10.79f), 0.2f),\tSphere(vec3(-14.11f,0.2f,-8.96f), 0.2f),\n                               Sphere(vec3(-14.36f,0.2f,-6.92f), 0.2f),\t\tSphere(vec3(-14.28f,0.2f,-4.61f), 0.2f),\tSphere(vec3(-14.21f,0.2f,-2.19f), 0.2f),\n                               Sphere(vec3(-14.85f,0.2f,-0.49f), 0.2f),\t\tSphere(vec3(-14.33f,0.2f,1.82f), 0.2f),\t\tSphere(vec3(-14.84f,0.2f,3.28f), 0.2f),\n                               Sphere(vec3(-14.79f,0.2f,5.62f), 0.2f),\t\tSphere(vec3(-12.7f,0.2f,-16.97f), 0.2f),\tSphere(vec3(-12.97f,0.2f,-14.72f), 0.2f),\n                               Sphere(vec3(-12.1f,0.2f,-12.76f), 0.2f),\t\tSphere(vec3(-12.85f,0.2f,-10.97f), 0.2f),\tSphere(vec3(-12.36f,0.2f,-8.51f), 0.2f),\n                               Sphere(vec3(-12.61f,0.2f,-6.9f), 0.2f),\t\tSphere(vec3(-12.81f,0.2f,-4.4f), 0.2f),\t\tSphere(vec3(-12.36f,0.2f,-2.22f), 0.2f),\n                               Sphere(vec3(-12.37f,0.2f,-0.63f), 0.2f),\t\tSphere(vec3(-12.69f,0.2f,1.11f), 0.2f),\t\tSphere(vec3(-12.17f,0.2f,3.8f), 0.2f),\n                               Sphere(vec3(-12.13f,0.2f,5.58f), 0.2f),\t\tSphere(vec3(-10.81f,0.2f,-16.69f), 0.2f),\tSphere(vec3(-10.51f,0.2f,-14.18f), 0.2f),\n                               Sphere(vec3(-10.73f,0.2f,-12.68f), 0.2f),\tSphere(vec3(-10.29f,0.2f,-10.26f), 0.2f),\tSphere(vec3(-10.72f,0.2f,-8.65f), 0.2f),\n                               Sphere(vec3(-10.14f,0.2f,-6.72f), 0.2f),\t\tSphere(vec3(-10.38f,0.2f,-4.77f), 0.2f),\tSphere(vec3(-10.32f,0.2f,-2.55f), 0.2f),\n                               Sphere(vec3(-10.97f,0.2f,-0.27f), 0.2f),\t\tSphere(vec3(-10.44f,0.2f,1.34f), 0.2f),\t\tSphere(vec3(-10.81f,0.2f,3.26f), 0.2f),\n                               Sphere(vec3(-10.25f,0.2f,5.69f), 0.2f),\t\tSphere(vec3(-8.45f,0.2f,-16.27f), 0.2f),\tSphere(vec3(-8.19f,0.2f,-14.33f), 0.2f),\n                               Sphere(vec3(-8.11f,0.2f,-12.69f), 0.2f),\t\tSphere(vec3(-8.6f,0.2f,-10.5f), 0.2f),\t\tSphere(vec3(-8.89f,0.2f,-8.72f), 0.2f),\n                               Sphere(vec3(-8.74f,0.2f,-6.89f), 0.2f),\t\tSphere(vec3(-8.64f,0.2f,-4.46f), 0.2f),\t\tSphere(vec3(-8.22f,0.2f,-2.4f), 0.2f),\n                               Sphere(vec3(-8.65f,0.2f,-0.12f), 0.2f),\t\tSphere(vec3(-8.51f,0.2f,1.35f), 0.2f),\t\tSphere(vec3(-8.65f,0.2f,3.6f), 0.2f),\n                               Sphere(vec3(-8.12f,0.2f,5.31f), 0.2f),\t\tSphere(vec3(-6.44f,0.2f,-16.18f), 0.2f),\tSphere(vec3(-6.44f,0.2f,-14.48f), 0.2f),\n                               Sphere(vec3(-6.89f,0.2f,-12.51f), 0.2f),\t\tSphere(vec3(-6.47f,0.2f,-10.12f), 0.2f),\tSphere(vec3(-6.12f,0.2f,-8.35f), 0.2f),\n                               Sphere(vec3(-6.56f,0.2f,-6.62f), 0.2f),\t\tSphere(vec3(-6.49f,0.2f,-4.67f), 0.2f),\t\tSphere(vec3(-6.28f,0.2f,-2.25f), 0.2f),\n                               Sphere(vec3(-6.57f,0.2f,-0.27f), 0.2f),\t\tSphere(vec3(-6.55f,0.2f,1.11f), 0.2f),\t\tSphere(vec3(-6.19f,0.2f,3.62f), 0.2f),\n                               Sphere(vec3(-6.88f,0.2f,5.48f), 0.2f),\t\tSphere(vec3(-4.99f,0.2f,-16.8f), 0.2f),\t\tSphere(vec3(-4.28f,0.2f,-14.23f), 0.2f),\n                               Sphere(vec3(-4.91f,0.2f,-12.98f), 0.2f),\t\tSphere(vec3(-4.8f,0.2f,-10.87f), 0.2f),\t\tSphere(vec3(-4.22f,0.2f,-8.99f), 0.2f),\n                               Sphere(vec3(-4.66f,0.2f,-6.84f), 0.2f),\t\tSphere(vec3(-4.93f,0.2f,-4.96f), 0.2f),\t\tSphere(vec3(-4.63f,0.2f,-2.57f), 0.2f),\n                               Sphere(vec3(-4.39f,0.2f,-0.97f), 0.2f),\t\tSphere(vec3(-4.83f,0.2f,1.6f), 0.2f),\t\tSphere(vec3(-4.99f,0.2f,3.42f), 0.2f),\n                               Sphere(vec3(-4.21f,0.2f,5.42f), 0.2f),\t\tSphere(vec3(-2.28f,0.2f,-16.8f), 0.2f),\t\tSphere(vec3(-2.95f,0.2f,-14.18f), 0.2f),\n                               Sphere(vec3(-2.49f,0.2f,-12.86f), 0.2f),\t\tSphere(vec3(-2.2f,0.2f,-10.78f), 0.2f),\t\tSphere(vec3(-2.35f,0.2f,-8.14f), 0.2f),\n                               Sphere(vec3(-2.17f,0.2f,-6.33f), 0.2f),\t\tSphere(vec3(-2.18f,0.2f,-4.96f), 0.2f),\t\tSphere(vec3(-2.81f,0.2f,-2.72f), 0.2f),\n                               Sphere(vec3(-2.29f,0.2f,-0.47f), 0.2f),\t\tSphere(vec3(-2.19f,0.2f,1.72f), 0.2f),\t\tSphere(vec3(-2.16f,0.2f,3.08f), 0.2f),\n                               Sphere(vec3(-2.13f,0.2f,5.57f), 0.2f),\t\tSphere(vec3(-0.93f,0.2f,-16.37f), 0.2f),\tSphere(vec3(-0.2f,0.2f,-14.6f), 0.2f),\n                               Sphere(vec3(-0.16f,0.2f,-12.83f), 0.2f),\t\tSphere(vec3(-0.12f,0.2f,-10.63f), 0.2f),\tSphere(vec3(-0.19f,0.2f,-8.48f), 0.2f),\n                               Sphere(vec3(-0.12f,0.2f,-6.29f), 0.2f),\t\tSphere(vec3(-0.38f,0.2f,-4.51f), 0.2f),\t\tSphere(vec3(-0.63f,0.2f,-2.32f), 0.2f),\n                               Sphere(vec3(-0.43f,0.2f,-0.22f), 0.2f),\t\tSphere(vec3(-0.13f,0.2f,1.65f), 0.2f),\t\tSphere(vec3(-0.81f,0.2f,3.17f), 0.2f),\n                               Sphere(vec3(-0.98f,0.2f,5.45f), 0.2f),\t\tSphere(vec3(1.59f,0.2f,-16.7f), 0.2f),\t\tSphere(vec3(1.56f,0.2f,-14.79f), 0.2f),\n                               Sphere(vec3(1.55f,0.2f,-12.72f), 0.2f),\t\tSphere(vec3(1.65f,0.2f,-10.3f), 0.2f),\t\tSphere(vec3(1.56f,0.2f,-8.77f), 0.2f),\n                               Sphere(vec3(1.45f,0.2f,-6.86f), 0.2f),\t\tSphere(vec3(1.8f,0.2f,-4.45f), 0.2f),\t\tSphere(vec3(1.6f,0.2f,-2.87f), 0.2f),\n                               Sphere(vec3(1.73f,0.2f,-0.62f), 0.2f),\t\tSphere(vec3(1.53f,0.2f,1.46f), 0.2f),\t\tSphere(vec3(1.11f,0.2f,3.41f), 0.2f),\n                               Sphere(vec3(1.02f,0.2f,5.43f), 0.2f),\t\tSphere(vec3(3.5f,0.2f,-16.62f), 0.2f),\t\tSphere(vec3(3.2f,0.2f,-14.96f), 0.2f),\n                               Sphere(vec3(3.12f,0.2f,-12.36f), 0.2f),\t\tSphere(vec3(3.74f,0.2f,-10.69f), 0.2f),\t\tSphere(vec3(3.34f,0.2f,-8.54f), 0.2f),\n                               Sphere(vec3(3.66f,0.2f,-6.5f), 0.2f),\t\tSphere(vec3(3.88f,0.2f,-4.34f), 0.2f),\t\tSphere(vec3(3.55f,0.2f,-2.33f), 0.2f),\n                               Sphere(vec3(3.37f,0.2f,-0.69f), 0.2f),\t\tSphere(vec3(3.85f,0.2f,1.23f), 0.2f),\t\tSphere(vec3(3.08f,0.2f,3.22f), 0.2f),\n                               Sphere(vec3(3.22f,0.2f,5.45f), 0.2f),\t\tSphere(vec3(5.02f,0.2f,-16.42f), 0.2f),\t\tSphere(vec3(5.53f,0.2f,-14.65f), 0.2f),\n                               Sphere(vec3(5.19f,0.2f,-12.15f), 0.2f),\t\tSphere(vec3(5.27f,0.2f,-10.96f), 0.2f),\t\tSphere(vec3(5.43f,0.2f,-8.32f), 0.2f),\n                               Sphere(vec3(5.5f,0.2f,-6.92f), 0.2f),\t\tSphere(vec3(5.88f,0.2f,-4.37f), 0.2f),\t\tSphere(vec3(5.61f,0.2f,-2.77f), 0.2f),\n                               Sphere(vec3(5.13f,0.2f,-0.34f), 0.2f),\t\tSphere(vec3(5.79f,0.2f,1.71f), 0.2f),\t\tSphere(vec3(5.53f,0.2f,3.34f), 0.2f),\n                               Sphere(vec3(5.19f,0.2f,5.52f), 0.2f),\t\tSphere(vec3(-4.0f, 1.0f, 0.0f), 1.0f),\t\tSphere(vec3(4.0f, 1.0f, 0.0f), 1.0f),\n                               Sphere(vec3(0.0f, 1.0f, 0.0f), 1.0f)\n);\n\n// ===================== BRDFs =====================\nstruct BRDF {\n    // Common params\n\tint type; // 0 - Lambertian, 1 - Metal, 2 - Dielectric\n    vec3 color;\n    \n    // Metal Params\n    float fuzz;\n    \n    // dielectric\n    float ior;\n};\n\n// List of BRDFs - must have one BRDF per geometry\nBRDF brdfs[148] = BRDF[](BRDF(0, vec3(0.5f), 0.0f, 0.0f),\t\t\t\tBRDF(0, vec3(0.14f, 0.46f, 0.02f), 0.0f, 0.0f),\tBRDF(1, vec3(0.88f, 0.57f, 0.73f), 0.5f, 0.0f),\n                         BRDF(1, vec3(0.51f, 0.83f, 0.75f), 0.5f, 0.0f),BRDF(1, vec3(0.73f, 0.86f, 0.69f), 0.5f, 0.0f),\tBRDF(0, vec3(0.43f, 0.22f, 0.01f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.88f, 0.88f, 0.66f), 0.5f, 0.0f),\tBRDF(1, vec3(0.69f, 0.78f, 0.52f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.37f, 0.09f, 0.27f), 0.0f, 0.0f),BRDF(0, vec3(0.02f, 0.03f, 0.06f), 0.0f, 0.0f),\tBRDF(0, vec3(0.05f, 0.57f, 0.29f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.22f, 0.11f, 0.61f), 0.0f, 0.0f),\tBRDF(0, vec3(0.0f, 0.12f, 0.26f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.03f, 0.33f, 0.06f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.05f, 0.45f, 0.3f), 0.0f, 0.0f),\tBRDF(0, vec3(0.42f, 0.19f, 0.45f), 0.0f, 0.0f),\tBRDF(0, vec3(0.14f, 0.19f, 0.07f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.38f, 0.06f, 0.03f), 0.0f, 0.0f),BRDF(1, vec3(0.69f, 0.76f, 0.57f), 0.5f, 0.0f),\tBRDF(0, vec3(0.47f, 0.33f, 0.14f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.68f, 0.26f, 0.01f), 0.0f, 0.0f),\tBRDF(1, vec3(0.57f, 0.67f, 0.58f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.04f, 0.62f, 0.14f), 0.0f, 0.0f),BRDF(1, vec3(0.64f, 0.81f, 0.75f), 0.5f, 0.0f),\tBRDF(0, vec3(0.44f, 0.12f, 0.32f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.3f, 0.21f, 0.47f), 0.0f, 0.0f),\tBRDF(1, vec3(0.82f, 0.61f, 0.69f), 0.5f, 0.0f),\tBRDF(1, vec3(0.69f, 0.73f, 0.84f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.14f, 0.55f, 0.48f), 0.0f, 0.0f),BRDF(0, vec3(0.78f, 0.87f, 0.47f), 0.0f, 0.0f),\tBRDF(0, vec3(0.31f, 0.05f, 0.75f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.17f, 0.41f, 0.44f), 0.0f, 0.0f),\tBRDF(0, vec3(0.38f, 0.41f, 0.12f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.66f, 0.16f, 0.23f), 0.0f, 0.0f),BRDF(0, vec3(0.31f, 0.23f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.66f, 0.0f, 0.14f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.94f, 0.91f, 0.55f), 0.5f, 0.0f),BRDF(0, vec3(0.27f, 0.03f, 0.04f), 0.0f, 0.0f),\tBRDF(0, vec3(0.05f, 0.44f, 0.16f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.05f, 0.77f, 0.13f), 0.0f, 0.0f),BRDF(1, vec3(0.53f, 0.51f, 0.8f), 0.5f, 0.0f),\tBRDF(0, vec3(0.64f, 0.13f, 0.59f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.03f, 0.0f, 0.13f), 0.0f, 0.0f),\tBRDF(1, vec3(0.78f, 0.59f, 0.59f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.04f, 0.91f, 0.02f), 0.0f, 0.0f),BRDF(0, vec3(0.08f, 0.62f, 0.16f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.12f, 0.03f, 0.22f), 0.0f, 0.0f),BRDF(0, vec3(0.04f, 0.36f, 0.73f), 0.0f, 0.0f),\tBRDF(0, vec3(0.18f, 0.68f, 0.08f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.67f, 0.86f, 0.88f), 0.5f, 0.0f),BRDF(0, vec3(0.05f, 0.18f, 0.19f), 0.0f, 0.0f),\tBRDF(1, vec3(0.84f, 0.78f, 0.61f), 0.5f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.1f, 0.0f, 0.08f), 0.0f, 0.0f),\tBRDF(1, vec3(0.56f, 0.81f, 0.69f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.32f, 0.25f, 0.01f), 0.0f, 0.0f),BRDF(0, vec3(0.09f, 0.14f, 0.47f), 0.0f, 0.0f),\tBRDF(0, vec3(0.57f, 0.46f, 0.01f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.14f, 0.69f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.12f, 0.32f, 0.37f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.67f, 0.66f, 0.03f), 0.0f, 0.0f),BRDF(0, vec3(0.12f, 0.74f, 0.07f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.35f, 0.35f, 0.32f), 0.0f, 0.0f),\tBRDF(0, vec3(0.53f, 0.04f, 0.27f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.01f, 0.55f, 0.26f), 0.0f, 0.0f),BRDF(0, vec3(0.45f, 0.07f, 0.24f), 0.0f, 0.0f),\tBRDF(0, vec3(0.01f, 0.02f, 0.08f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.03f, 0.06f, 0.16f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.24f, 0.07f, 0.61f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.14f, 0.2f, 0.16f), 0.0f, 0.0f),\tBRDF(0, vec3(0.03f, 0.55f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.17f, 0.12f, 0.15f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.21f, 0.0f), 0.0f, 0.0f),\tBRDF(0, vec3(0.1f, 0.02f, 0.1f), 0.0f, 0.0f),\tBRDF(0, vec3(0.04f, 0.02f, 0.18f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.84f, 0.67f, 0.96f), 0.5f, 0.0f),BRDF(0, vec3(0.31f, 0.12f, 0.45f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.15f, 0.45f, 0.07f), 0.0f, 0.0f),BRDF(1, vec3(0.63f, 0.62f, 0.93f), 0.5f, 0.0f),\tBRDF(0, vec3(0.06f, 0.18f, 0.0f), 0.0f, 0.0f),\n                         BRDF(1, vec3(0.94f, 0.5f, 0.56f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.27f, 0.12f, 0.09f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.25f, 0.08f, 0.28f), 0.0f, 0.0f),BRDF(1, vec3(0.63f, 0.76f, 0.97f), 0.5f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.21f, 0.0f, 0.09f), 0.0f, 0.0f),\tBRDF(0, vec3(0.26f, 0.43f, 0.03f), 0.0f, 0.0f),\tBRDF(0, vec3(0.44f, 0.73f, 0.4f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.82f, 0.8f, 0.94f), 0.5f, 0.0f),\tBRDF(0, vec3(0.17f, 0.04f, 0.6f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.51f, 0.44f, 0.07f), 0.0f, 0.0f),BRDF(0, vec3(0.37f, 0.17f, 0.11f), 0.0f, 0.0f),\tBRDF(1, vec3(0.91f, 0.83f, 0.56f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.07f, 0.44f, 0.16f), 0.0f, 0.0f),BRDF(0, vec3(0.58f, 0.01f, 0.04f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.27f, 0.01f, 0.01f), 0.0f, 0.0f),BRDF(0, vec3(0.59f, 0.24f, 0.17f), 0.0f, 0.0f),\tBRDF(0, vec3(0.1f, 0.03f, 0.3f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.02f, 0.66f, 0.28f), 0.0f, 0.0f),BRDF(1, vec3(0.83f, 0.78f, 0.73f), 0.5f, 0.0f),\tBRDF(0, vec3(0.76f, 0.14f, 0.31f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.15f, 0.19f), 0.0f, 0.0f),BRDF(1, vec3(0.71f, 0.58f, 0.81f), 0.5f, 0.0f),\tBRDF(1, vec3(0.91f, 0.99f, 0.83f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.53f, 0.47f, 0.25f), 0.0f, 0.0f),BRDF(0, vec3(0.27f, 0.09f, 0.53f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.15f, 0.14f, 0.26f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.32f, 0.05f, 0.18f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.61f, 0.4f, 0.42f), 0.0f, 0.0f),\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.59f, 0.98f, 0.89f), 0.5f, 0.0f),\n                         BRDF(0, vec3(0.09f, 0.45f, 0.33f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(2, vec3(1.0f), 0.0f, 1.5f),\n                         BRDF(0, vec3(0.13f, 0.87f, 0.33f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.64f, 0.31f, 0.38f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.34f, 0.04f, 0.63f), 0.0f, 0.0f),BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.66f, 0.01f, 0.07f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(1, vec3(0.99f, 0.62f, 0.87f), 0.5f, 0.0f),\tBRDF(0, vec3(0.13f, 0.02f, 0.73f), 0.0f, 0.0f),\n                         BRDF(0, vec3(0.35f, 0.06f, 0.3f), 0.0f, 0.0f),\tBRDF(0, vec3(0.37f, 0.69f, 0.02f), 0.0f, 0.0f),\tBRDF(0, vec3(0.38f, 0.11f, 0.16f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f),\t\t\t\tBRDF(0, vec3(0.4f, 0.2f, 0.1f), 0.0f, 0.0f),\tBRDF(1, vec3(0.7f, 0.6f, 0.5f), 0.0f, 0.0f),\n                         BRDF(2, vec3(1.0f), 0.0f, 1.5f)\n);\n\nfloat schlick(float cosine, float ref_idx) {\n  float r0 = (1.0f - ref_idx) / (1.0f + ref_idx);\n  r0 = r0 * r0;\n  return r0 + (1.0f - r0) * pow((1.0f - cosine), 5.0f);\n}\n\n// Samples BRDF\nvec3 sampleBRDF(Ray r, HitRecord rec) {\n\tswitch(brdfs[rec.index].type) {\n        case 0: // Lambertian\n        \treturn rec.n + randomUnitVector();\n        \tbreak;\n        \n        case 1: // Metal\n        \treturn reflect(normalize(r.direction), normalize(rec.n)) + brdfs[rec.index].fuzz * randomInUnitSphere();\n        \tbreak;\n        \n        case 2: // Dielectric\n        \tfloat ior = brdfs[rec.index].ior;\n        \tfloat etai_over_etat = rec.front_face ? (1.0f / ior) : ior;\n        \n        \tvec3 dir = normalize(r.direction);\n        \tvec3 nn = normalize(rec.n);\n        \n        \tfloat cos_theta = min(dot(-dir, nn), 1.0f);\n        \tfloat sin_theta = sqrt(1.0f - cos_theta * cos_theta);\n        \tif(etai_over_etat * sin_theta > 1.0f) {\n        \t\treturn normalize(reflect(dir, nn));\n            }\n        \n        \treturn normalize(refract(dir, nn, etai_over_etat));\n        \n        \tbreak;\n    }\n    \n}\n\n// Evaluates BRDF\nvec3 evalBRDF(Ray r, HitRecord rec) {\n    switch(brdfs[rec.index].type) {\n        case 0: // Lambertian\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n        \n        case 1: // Metal\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n        \n        case 2: // Dielectric\n        \treturn brdfs[rec.index].color;\n        \tbreak;\n    }\n}\n\n// ===================== Main =====================\n\n// Iterates over a list of geometries and tries to find a hit\nbool hitWorld(Ray r, float t_min, float t_max, out HitRecord rec) {\n    HitRecord temp;\n    bool hitAnything = false;\n    float closest = t_max;\n    \n    for(int i = 0; i < spheres.length(); i++){\n        if(hitSphere(spheres[i], r, t_min, t_max, temp)){\n            if(temp.t < closest){\n                hitAnything = true;\n                closest = temp.t;\n                rec = temp;\n                rec.index = i;\n            }\n        }\n    }\n    \n    return hitAnything;\n}\n\n// Traces ray\nvec3 trace(Ray r) {\n    vec3 throughput = vec3(1.0f);\n    \n    // iterative version of recursion\n    for(int i = 0; i < 50; i++){\n        HitRecord rec;\n        \n        // ray hit\n        if(hitWorld(r, 0.001f, FLT_MAX, rec)) {\n            vec3 wi = sampleBRDF(r, rec);\n            throughput *= evalBRDF(r, rec);\n            \n            r = Ray(rec.p, wi);\n        } \n        \n        // ray miss\n        else {\n            vec3 uDirection = normalize(r.direction);\n        \tfloat t = 0.5f * (uDirection.y + 1.0f);\n        \tvec3 color = (1.0f - t) * vec3(1.0f) + t * vec3(0.5f, 0.7f, 1.0f);\n            return throughput * color;\n        }           \n    }\n    \n    \n    return vec3(0.0f);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {  \n    // rnd seed\n    seed = tea(int(iResolution.x) * int(fragCoord.y) + int(fragCoord.x), iFrame);\n    \n    // camera\n    float aRatio = iResolution.x/iResolution.y;\n    vec3 lookfrom = vec3(13.0f, 2.0f, 3.0f);\n    vec3 lookat = vec3(0.0f, 0.0f, 0.0f);\n    vec3 vup = vec3(0.0f, 1.0f, 0.0f);\n    Camera c = newCamera(lookfrom, lookat, vup, 20.0f, aRatio, 0.1f, 10.0f);\n    \n    // shoot a ray\n    float u = (fragCoord.x + rnd()) / iResolution.x;\n    float v = (fragCoord.y + rnd()) / iResolution.y;\n    Ray r = getRay(c, u, v);\n\n    // Accumulate and output to screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 oldColor = texture( iChannel0, uv );\n    \n    // initiates buffer if we are on frame 0\n    if(iFrame == 0) oldColor = vec4(0.0f);\n    \n    // TODO: Fix. The reset on keypress works, but we need to save the current frame \n    // somewhere so we can do accum /(currentFrame - savedFrame).\n    //if(KeyPressed(82)) oldColor = vec4(0.0f); // Press R to reset\n    \n    fragColor = oldColor + vec4(de_nan(trace(r)), 0.0f);\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// ===================== Math Defines =====================\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#define FLT_MAX 3.402823466e+38\n#define FLT_MIN 1.175494351e-38\n\n#define squaredLength(x) pow(length(x), 2.0f)\n\n// ===================== Random Generator =====================\n// RNG adapted from the random generator used by NVidia in their OptiX's samples.\n// The following licence only applies to the functions tea, rnd and lcg.\n\n//////////////////////////////////////////////////////////////////////////////////////\n// ******************************************************************************** //\n/*\n * Copyright (c) 2018, NVIDIA CORPORATION. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *  * Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  * Neither the name of NVIDIA CORPORATION nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ``AS IS'' AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\nint seed;\n\nint tea(int val0, int val1) {\n  int v0 = val0;\n  int v1 = val1;\n  int s0 = 0;\n\n  for (int n = 0; n < 16; n++) {\n    s0 += 0x9e3779b9;\n    v0 += ((v1 << 4) + 0xa341316c) ^ (v1 + s0) ^ ((v1 >> 5) + 0xc8013ea4);\n    v1 += ((v0 << 4) + 0xad90777d) ^ (v0 + s0) ^ ((v0 >> 5) + 0x7e95761e);\n  }\n\n  return v0;\n}\n\nint lcg() {\n  int LCG_A = 1664525;\n  int LCG_C = 1013904223;\n  seed = (LCG_A * seed + LCG_C);\n  return seed & 0x00FFFFFF;\n}\n\nfloat rnd() {\n  return (float(lcg()) / float(0x01000000));\n}\n\n\n// ******************************************************************************** //\n//////////////////////////////////////////////////////////////////////////////////////\n\n// ===================== Sampling =====================\n\nvec3 randomInUnitSphere() {\n  \tfloat z = rnd() * 2.f - 1.f;\n\n  \tfloat t = rnd() * 2.f * PI;\n  \tfloat r = sqrt((0.f > (1.f - z * z) ? 0.f : (1.f - z * z)));\n\n  \tfloat x = r * cos(t);\n  \tfloat y = r * sin(t);\n\n  \tvec3 res = vec3(x, y, z);\n  \tres *= pow(rnd(), 1.f / 3.f);\n\n  \treturn res;\n}\n\nvec3 randomUnitVector() {\n    float a = rnd() * TWOPI;\n    float z = (rnd() * 2.0f) - 1.0f;\n    float r = sqrt(1.0f - z * z);\n    \n    return vec3(r * cos(a), r * sin(a), z);\n}\n\nvec3 randomInUnitDisk() {\n\tfloat a = rnd() * TWOPI;\n\tvec3 xy = vec3(sin(a), cos(a), 0.0f);\n\txy *= sqrt(rnd());\n\treturn xy;\n}\n\n// ===================== Removing NaNs =====================\n\n// Source: https://stackoverflow.com/a/34276047\nbool isNan(float val) {\n  return (val < 0.0 || 0.0 < val || val == 0.0) ? false : true;\n\n}\n\nvec3 de_nan(vec3 c) {\n  vec3 temp = c;\n  if (isNan(temp.x)) temp.x = 0.0f;\n  if (isNan(temp.y)) temp.y = 0.0f;\n  if (isNan(temp.z)) temp.z = 0.0f;\n  return temp;\n}\n\n// ===================== Keyboard Input =====================\n#define keyChannel iChannel1\n#define KeyPressed(key) _keyPressed(keyChannel, key)\n\n// Return true if given key is pressed\n// Source: https://www.shadertoy.com/view/XsycWw\nbool _keyPressed(sampler2D keyChannel, int key) {\n  return texelFetch(keyChannel, ivec2(key,0), 0).x > 0.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[671, 671, 728, 769, 929]], "test": "untested"}
{"id": "wlsfRn", "name": "Iterations - stripes", "author": "iq", "description": "Another abstract thingy based on noise. Loosely based on [url]https://www.shadertoy.com/view/MssGW4[/url]", "tags": ["procedural", "2d", "iterations"], "likes": 79, "viewed": 5154, "published": 3, "date": "1596125298", "time_retrieved": "2024-07-30T20:53:05.477020", "image_code": "// Copyright Inigo Quilez, 2020 - https://iquilezles.org/\n// I am the sole copyright owner of this Work.\n// You cannot host, display, distribute or share this Work neither\n// as it is or altered, here on Shadertoy or anywhere else, in any\n// form including physical and digital. You cannot use this Work in any\n// commercial or non-commercial product, website or project. You cannot\n// sell this Work and you cannot mint an NFTs of it or train a neural\n// network with it without permission. I share this Work for educational\n// purposes, and you can link to it, through an URL, proper attribution\n// and unmodified screenshot, as part of your educational material. If\n// these conditions are too restrictive please contact me and we'll\n// definitely work it out.\n\n\n// Other \"Iterations\" shaders:\n//\n// \"trigonometric\"   : https://www.shadertoy.com/view/Mdl3RH\n// \"trigonometric 2\" : https://www.shadertoy.com/view/Wss3zB\n// \"circles\"         : https://www.shadertoy.com/view/MdVGWR\n// \"coral\"           : https://www.shadertoy.com/view/4sXGDN\n// \"guts\"            : https://www.shadertoy.com/view/MssGW4\n// \"inversion\"       : https://www.shadertoy.com/view/XdXGDS\n// \"inversion 2\"     : https://www.shadertoy.com/view/4t3SzN\n// \"shiny\"           : https://www.shadertoy.com/view/MslXz8\n// \"worms\"           : https://www.shadertoy.com/view/ldl3W4\n// \"stripes\"         : https://www.shadertoy.com/view/wlsfRn\n\n#define AA 2\n\nfloat hash( in float n )\n{\n    return fract(sin(n)*43758.5453);\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*57.0;\n    return mix(mix( hash(n+ 0.0), hash(n+ 1.0),f.x),\n               mix( hash(n+57.0), hash(n+58.0),f.x),f.y);\n}\n\nvec2 map( in vec2 p, in float time )\n{\n    for( int i=0; i<4; i++ )\n    {\n    \tfloat a = noise(p*1.5)*6.2831 + time;\n\t\tp += 0.1*vec2( cos(a), sin(a) );\n    }\n    return p;\n}\n\nfloat height( in vec2 p, in vec2 q )\n{\n    float h = dot(p-q,p-q);\n    h += 0.005*texture(iChannel0,0.75*(p+q)).x;\n    return h;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = 0.25*iTime;\n    \n    vec3 tot = vec3(0.0);\n\t#if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n\t\t#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\t\t#endif\n\n        // deformation\n        vec2 q = map(p,time);\n\n        // color\n        float w = 10.0*q.x;\n        float u = floor(w);\n        float f = fract(w);\n        vec3  col = vec3(0.7,0.55,0.5) + 0.3*sin(3.0*u+vec3(0.0,1.5,2.0));\n        \n        // filtered drop-shadow\n        float sha = smoothstep(0.0,0.5,f)-smoothstep(1.0-fwidth(w),1.0,f);\n        \n        // normal\n        vec2  eps = vec2(2.0/iResolution.y,0.0);\n\t\tfloat l2c = height(q,p);\n        float l2x = height(map(p+eps.xy,time),p) - l2c;\n        float l2y = height(map(p+eps.yx,time),p) - l2c;\n        vec3  nor = normalize( vec3( l2x, eps.x, l2y ) );\n            \n        // lighting\n        col *= 0.4+0.6*sha;\n        col *= 0.8+0.2*vec3(1.0,0.9,0.3)*dot(nor,vec3(0.7,0.3,0.7));\n        col += 0.2*pow(nor.y,8.0)*sha;\n        col *= 7.5*l2c;\n\n        tot += col;\n\t#if AA>1\n    }\n    tot /= float(AA*AA);\n\t#endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfRn.jpg", "access": "api", "license": "proprietary-license", "functions": [[1425, 1425, 1451, 1451, 1490], [1491, 1491, 1517, 1517, 1731], [1733, 1733, 1771, 1771, 1906], [1908, 1908, 1946, 1946, 2038]], "test": "untested"}
{"id": "ttsfRH", "name": "BEEPLE COVER: WORKSPACE", "author": "toomuchvoltage", "description": "Took a break and decided to do another Beeple Shadertoy cover :D!\nThis one actually raymarches/raycasts against a triangular height field.\nReference: https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e4bb9677562593.5c8adf0c5fd1d.jpg", "tags": ["3d", "raymarch", "raycast", "heightfield", "triangle", "raytrace", "beeple", "workspace"], "likes": 12, "viewed": 673, "published": 3, "date": "1596090375", "time_retrieved": "2024-07-30T20:53:06.489314", "image_code": "/***********************************************************\n\n   Got kinda tired, so decided to do another Beeple Shadertoy cover :D!\n   Reference: https://mir-s3-cdn-cf.behance.net/project_modules/max_1200/e4bb9677562593.5c8adf0c5fd1d.jpg\n   All value noise is modified iq noise from : https://www.shadertoy.com/view/lsf3WH\n   FXAA is the FXAAv2 that's commonly passed around, Shadertoy'd by Dave_Hoskins: https://www.shadertoy.com/view/4dfGDj\n\n   Covered under the MIT license:\n\n   Copyright (c) 2020 TooMuchVoltage Software Inc.\n\n   Permission is hereby granted, free of charge, to any person obtaining a copy\n   of this software and associated documentation files (the \"Software\"), to deal\n   in the Software without restriction, including without limitation the rights\n   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n   copies of the Software, and to permit persons to whom the Software is\n   furnished to do so, subject to the following conditions:\n\n   The above copyright notice and this permission notice shall be included in all\n   copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n   SOFTWARE.\n\n\n   Hit me up! :)\n   Twitter: twitter.com/toomuchvoltage\n   Facebook: fb.com/toomuchvoltage\n   YouTube: youtube.com/toomuchvoltage\n   Mastodon: https://mastodon.gamedev.place/@toomuchvoltage\n   Website: www.toomuchvoltage.com\n\n************************************************************/\n\n#define FXAA_SPAN_MAX\t8.0\n#define FXAA_REDUCE_MUL 1.0/8.0\n#define FXAA_REDUCE_MIN 1.0/128.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\tvec2 add = vec2(1.0) / iResolution.xy;\n\t\t\t\n\tvec3 rgbNW = texture(iChannel0, uv+vec2(-add.x, -add.y)).rgb;\n\tvec3 rgbNE = texture(iChannel0, uv+vec2( add.x, -add.y)).rgb;\n\tvec3 rgbSW = texture(iChannel0, uv+vec2(-add.x,  add.y)).rgb;\n\tvec3 rgbSE = texture(iChannel0, uv+vec2( add.x,  add.y)).rgb;\n\tvec3 rgbM  = texture(iChannel0, uv).rgb;\n\t\n\tvec3 luma\t = vec3(0.299, 0.587, 0.114);\n\tfloat lumaNW = dot(rgbNW, luma);\n\tfloat lumaNE = dot(rgbNE, luma);\n\tfloat lumaSW = dot(rgbSW, luma);\n\tfloat lumaSE = dot(rgbSE, luma);\n\tfloat lumaM  = dot(rgbM,  luma);\n\t\n\tfloat lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));\n\tfloat lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));\n\t\n\tvec2 dir;\n\tdir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));\n\tdir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));\n\t\n\t\n\tfloat dirReduce = max(\n\t\t(lumaNW + lumaNE + lumaSW + lumaSE) * (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);\n\t  \n\tfloat rcpDirMin = 1.0/(min(abs(dir.x), abs(dir.y)) + dirReduce);\n\t\n\n\tdir = min(vec2( FXAA_SPAN_MAX,  FXAA_SPAN_MAX),\n\t\t  max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),\n\t\t  dir * rcpDirMin)) * add;\n\n\t\t\n\tvec3 rgbA = (1.0/2.0) * (texture(iChannel0, uv + dir * (1.0/3.0 - 0.5)).rgb +\n\t\t\t\t\t\t\t texture(iChannel0, uv + dir * (2.0/2.0 - 0.5)).rgb);\n\t\n\tvec3 rgbB = rgbA * (1.0/2.0) + (1.0/4.0) *\n\t\t(texture(iChannel0, uv.xy + dir * (0.0/3.0 - 0.5)).rgb +\n\t\t texture(iChannel0, uv.xy + dir * (3.0/3.0 - 0.5)).rgb);\n\t\n\tfloat lumaB = dot(rgbB, luma);\n\tif((lumaB < lumaMin) || (lumaB > lumaMax))\n\t{\n\t\tfragColor.xyz=rgbA;\n\t}else\n\t{\n\t\tfragColor.xyz=rgbB;\n\t}\n    fragColor.a = 1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsfRH.jpg", "access": "api", "license": "mit", "functions": [[1985, 1985, 2043, 2043, 3686]], "test": "untested"}
{"id": "3tXBRN", "name": "kundalini", "author": "xenn", "description": "propagation duration will vary. give it time", "tags": ["particles", "ca"], "likes": 10, "viewed": 617, "published": 3, "date": "1596087655", "time_retrieved": "2024-07-30T20:53:07.386914", "image_code": "\n// Fork of \"electrical sublime moulds\" by xenn. https://shadertoy.com/view/WtSyDd\n// 2020-07-30 05:38:33\n\n// Fork of \"My virtual slime molds\" by michael0884. https://shadertoy.com/view/WtBcDG\n// 2020-07-24 21:29:48\n\n// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(01., 0.92, 1.);\n    // Output to screen\n    col.xyz += 0.1*a;\n    col.xyz += 0.5 - 0.5*cos(10.0*vec3(0.36131*sin(iTime*0.51),0.22*cos(iTime*0.61),0.1606*cos(iTime*(0.51)))*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 2.\n\n#define fluid_rho 0.2\n\n\n//mold stuff \n#define sense_ang (0.63*sin(time*0.032)+0.255)\n#define sense_dis (8.0*cos(time*0.632)+10.0)\n#define sense_force 0.5\n#define trailing (1000.0*sin(time*0.32))\n#define acceleration 0.25\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 01.05*rho.x + 0.*rho.y; //gas\n    return 0.002*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.3\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= (00.005*sin(time*0.32))*P.M.x*vec2(0,1);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = sin(iTime); Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = cos(iTime);\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/0.75); \n    }\n    \n    rho.w  =P.M.y;\n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBRN.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[414, 414, 441, 441, 619], [621, 621, 657, 657, 707], [709, 709, 725, 725, 753], [755, 755, 800, 800, 1967]], "test": "untested"}
{"id": "WtlBRH", "name": "WhenImAlone", "author": "t420babe", "description": "Using easing functions\nMusic: Glue by Bicep on Channel0", "tags": ["magenta", "easingfunctions"], "likes": 2, "viewed": 242, "published": 3, "date": "1596078926", "time_retrieved": "2024-07-30T20:53:08.320418", "image_code": "#define PI 3.1415926535\n\nfloat plot(vec2 pos, float pct, float width){\n  float upper = smoothstep( pct - width, pct, pos.y);\n  float lower = smoothstep( pct, pct + width, pos.y);\n  return upper - lower;\n}\n\nvec3 scene(in vec2 fragCoord, float song_time) {\n  vec3 color = vec3(0.0);\n  float ratio = iResolution.x / iResolution.y;\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y *2.25 + 0.1;\n  float norm = (uv.x / ratio + 1.0) / 2.0;\n  float wave = texelFetch(iChannel0, ivec2(norm * 512.0, 1), 0).x;\n   \n\n  float mod_time = mod(song_time * 0.2, uv.x);\n  float y = easeInOutQuart(mod_time);\n\n  y+= easeInOutCubic(pow(uv.x, uv.y));\n  float func2 = plot(vec2(wave), y, 1.08);\n\n  float pct = 0.0;\n  return (1.0 - func2) * color * wave + func2 * vec3(1.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 color = vec3(0.0);\n    float song_duration = 268.5;\n    float song_time = mod(iTime, song_duration);\n    color = scene(fragCoord, song_time);\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [{"id": 23533, "src": "https://soundcloud.com/user-847010156/bicep-glue-original-mix", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "/* All easing functions from https://easings.net/# */\nfloat easeInCubic(float x) {\n  return pow(x, 3.0);\n}\n\nfloat easeOutCubic(float x) {\n  return 1.0 - pow(1.0 - x, 3.0);\n}\n\nfloat easeInOutCubic(float x) {\n  if (x < 0.5) {\n    return 4.0 * easeInCubic(x);\n  } else {\n    return 1.0 - pow(-2.0 * x + 2.0, 3.0) / 2.0;\n  }\n}\n\nfloat easeInQuart(float x) {\n  return pow(x, 4.0);\n}\n\nfloat easeOutQuart(float x) {\n  return 1.0 - pow(1.0 - x, 4.0);\n}\n\nfloat easeInOutQuart(float x) {\n  if (x < 0.5) {\n    return 8.0 * easeInQuart(x);\n  } else {\n    return 1.0 - pow(-2.0 * x + 2.0, 4.0);\n  }\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtlBRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 70, 70, 204], [206, 206, 254, 254, 780], [782, 782, 839, 839, 1025]], "test": "untested"}
{"id": "WtXfz4", "name": "Tweaked band limited synthesis", "author": "Mipmap", "description": "Tweak of Band Limited Synthesis 2 [url]https://www.shadertoy.com/view/wtXfRH[/url] by Inigo Quilez", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 7, "viewed": 440, "published": 3, "date": "1596078529", "time_retrieved": "2024-07-30T20:53:09.196077", "image_code": "// Tweak of Band Limited Synthesis 2 https://www.shadertoy.com/view/wtXfRH by Inigo Quilez\n\n// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(8.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.3,0.4,0.5);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.10*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.10*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.10*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.10*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n    \n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    vec2 q = p;\n    p.x += iTime*0.1;\n    \n    // deform 2\n    p += 0.2*sin( 1.5*p.yx + 0.03*1.0*iTime + vec2(0.1,1.1) );\n\tp += 0.2*cos( 2.4*p.yx + 0.03*1.6*iTime + vec2(4.5,2.6) );\n\tp += 0.2*sin( 3.3*p.yx + 0.03*1.2*iTime + vec2(3.2,3.4) );\n\tp += 0.2*cos( 4.2*p.yx + 0.03*1.7*iTime + vec2(1.8,5.2) );\n\tp += 0.2*sin( 9.1*p.yx + 0.03*1.1*iTime + vec2(6.3,3.9) );\n\n    // base color pattern\n    vec3 col = getColor( 0.4*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.07*length(q);\n \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfz4.jpg", "access": "api", "license": "mit", "functions": [[1935, 1935, 1956, 1956, 2134], [2136, 2136, 2165, 2165, 2673], [2675, 2675, 2731, 2750, 3405]], "test": "untested"}
{"id": "3tXfz4", "name": "Mandelbulb Super HQ", "author": "Zi7ar21", "description": "No compromises will nuke your PC", "tags": ["3d", "ray", "ray", "volume", "raymarch", "mandelbulb", "fake", "sphere", "cheap", "marcher", "epic", "render", "volumetrics", "yeet", "hq", "fakevolumetrics"], "likes": 2, "viewed": 431, "published": 3, "date": "1596077863", "time_retrieved": "2024-07-30T20:53:09.973997", "image_code": "// ^^^ Check Buffer A ^^^\n// See https://www.shadertoy.com/view/ttBcWR for full license details\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x){\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Pixel Color\n    vec3 col = texture(iChannel0, uv).rgb/float(iFrame+1);\n\n    // sample texture and output to screen\n    fragColor = vec4(acesFilm(col), 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// Super HQ Version July 29th, 2020\n// The Original:\n// https://www.shadertoy.com/view/ttBcWR\n\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You keep the links to source I used (I don't want to get in trouble)\n// You keep the link to this on ShaderToy\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n// If you are absolutely not able to follow these terms, that is OK and I allow you I guess.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Or the exact copy can be found here:\n// https://www.shadertoy.com/view/3tXfz4\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking! (Warning: These are already nuked so\n// I don't recommend bumping them up unless you have a excellent PC)\n#define MAX_MARCHES 1024\n#define MAX_DISTANCE 32.0\n// Fake Volumetric Function\n#define COLLISION_DISTANCE abs(tan(hash11(float(iFrame+1))*3.14159265)/512.0)\n#define Bailout 4.0\n#define Iterations 64\n\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\n// Mandelbulb Distance Estimator\nfloat sphere(vec3 pos) {\n\tfloat Power = float(2.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 1.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(-4, 0, -2);\n\tvec3 lightpositionb = vec3(0, 0, -2);\n    vec3 lightpositionc = vec3(4, 0, -2);\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\nfloat mod289(float x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 mod289(vec4 x){return x - floor(x * (1.0 / 289.0)) * 289.0;}\nvec4 perm(vec4 x){return mod289(((x * 34.0) + 1.0) * x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p - a;\n    d = d * d * (3.0 - 2.0 * d);\n\n    vec4 b = a.xxyy + vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy + b.zzww);\n\n    vec4 c = k2 + a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c + 1.0);\n\n    vec4 o1 = fract(k3 * (1.0 / 41.0));\n    vec4 o2 = fract(k4 * (1.0 / 41.0));\n\n    vec4 o3 = o2 * d.z + o1 * (1.0 - d.z);\n    vec2 o4 = o3.yw * d.x + o3.xz * (1.0 - d.x);\n\n    return o4.y * d.y + o4.x * (1.0 - d.y);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1.0,0.0,0.0);\n\tvec3 ydir = vec3(0.0,1.0,0.0);\n\tvec3 zdir = vec3(0.0,0.0,1.0);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(sin(float(iFrame))/(iResolution.x/(FOV)), cos(float(iFrame))/(iResolution.y/(FOV)), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n    vec2 uvb = fragCoord/iResolution.xy;\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\n\t// Dither\n\tcol = diffuse*(hash33(vec3((float(iFrame)*fragCoord)+(fragCoord*2.0), iFrame*2)));\n\n    // Output to Screen\n    fragColor = vec4((col+texture(iChannel0, uvb).rgb),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXfz4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 116, 144, 144, 329], [331, 331, 387, 437, 648]], "test": "untested"}
{"id": "wlsBzH", "name": "glitch-linesh.frag", "author": "thefox231", "description": "the official sequel to glitch-lines.frag", "tags": ["glitch", "glitchlines"], "likes": 9, "viewed": 622, "published": 3, "date": "1596058142", "time_retrieved": "2024-07-30T20:53:10.747927", "image_code": "#define value iMouse.x / iResolution.x\n#define smoothen iMouse.y / iResolution.y\n\n#define PI 3.1415\n\nfloat inOutSine(float x) {\n  return 0.5 - 0.5 * cos(x * PI);\n}\n\nfloat rand( vec2 n ) {\n  return fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\nfloat smoothRand(float x, float t) {\n  return mix(rand(vec2(floor(x), t)), rand(vec2(ceil(x), t)), inOutSine(fract(x)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = fragCoord/iResolution.xy;\n\n  uv.x += smoothRand(uv.y * iResolution.y * smoothen, iTime / 10.0) * value;\n\n  vec3 col = texture(iChannel0, fract(uv)).rgb;\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 127, 127, 163], [165, 165, 187, 187, 256], [258, 258, 294, 294, 380], [382, 382, 439, 439, 635]], "test": "untested"}
{"id": "ttXBR8", "name": "Obra Dinn Dithering Test", "author": "CelestialAmber", "description": "Combination of the dithering methods used in Obra Dinn. (left to right: bayer, blue noise, custom dithering)\n\nThanks to cornasummonis for the custom dithering code (link: https://www.shadertoy.com/view/4sySzw)", "tags": ["dithering", "obradinn"], "likes": 8, "viewed": 788, "published": 3, "date": "1596045771", "time_retrieved": "2024-07-30T20:53:11.643533", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec4 texColor = texture(iChannel3, uv);\n    float gray = dot(texColor.rgb, vec3(0.2126,0.7152,0.0722));\t\n    vec3 col = vec3(gray);\n    \n    //Bayer Matrix dithering\n    float dither = texture(iChannel0, fragCoord/8.).r;\n    //Blue Noise dithering\n    if(uv.x > 0.33) dither = texture(iChannel1, fragCoord/1024.).r;\n        \n    col = floor(col + dither);\n    \n    if(uv.x > 0.66) col = vec3(texture(iChannel2, uv).b);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define B 232.0\n\nvec2 uv = vec2(0);\nvec2 texel = vec2(0);\n\nfloat err(int i, int j) {\n    vec4 temp = texture(iChannel1, uv + vec2(float(i)*texel.x, float(j)*texel.y));\n    return temp.y*(1.0-temp.z) - temp.y*temp.z;\n} \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float kernel[25];         \n\n    kernel[0] = 1.0/B;    \n    kernel[1] = 4.0/B;     \n    kernel[2] = 7.0/B;    \n    kernel[3] = 4.0/B;     \n    kernel[4] = 1.0/B; \n    kernel[5] = 4.0/B;  \n    kernel[6] = 16.0/B;  \n    kernel[7] = 26.0/B; \n    kernel[8] = 16.0/B;  \n    kernel[9] = 4.0/B; \n    kernel[10] = 7.0/B;  \n    kernel[11] = 26.0/B;  \n    kernel[12] = 0.0/B;  \n    kernel[13] = 26.0/B;  \n    kernel[14] = 7.0/B; \n    kernel[15] = 4.0/B;  \n    kernel[16] = 16.0/B;  \n    kernel[17] = 26.0/B; \n    kernel[18] = 16.0/B;  \n    kernel[19] = 4.0/B; \n    kernel[20] = 1.0/B;  \n    kernel[21] = 4.0/B;   \n    kernel[22] = 7.0/B;  \n    kernel[23] = 4.0/B;   \n    kernel[24] = 1.0/B;\n\n    uv = fragCoord.xy / iResolution.xy;\n    texel = 1.0 / iResolution.xy;\n    vec4 cr = texture(iChannel0, uv); \n    vec4 rc = texture(iChannel1, uv);\n    float gray = dot(cr.rgb, vec3(0.2126,0.7152,0.0722));\n    vec4 cur = vec4(gray, rc.yz, 0.0);\n    float sum = cur.x + kernel[ 0]*err(-2,-2) + kernel[ 1]*err(-1,-2) + kernel[ 2]*err( 0,-2) + kernel[ 3]*err( 1,-2) + kernel[ 4]*err( 2,-2) + \n        kernel[ 5]*err(-2,-1) + kernel[ 6]*err(-1,-1) + kernel[ 7]*err( 0,-1) + kernel[ 8]*err( 1,-1) + kernel[ 9]*err( 2,-1) + \n        kernel[10]*err(-2, 0) + kernel[11]*err(-1, 0) + kernel[12]*err( 0, 0) + kernel[13]*err( 1, 0) + kernel[14]*err( 2, 0) + \n        kernel[15]*err(-2, 1) + kernel[16]*err(-1, 1) + kernel[17]*err( 0, 1) + kernel[18]*err( 1, 1) + kernel[19]*err( 2, 1) + \n        kernel[20]*err(-2, 2) + kernel[21]*err(-1, 2) + kernel[22]*err( 0, 2) + kernel[23]*err( 1, 2) + kernel[24]*err( 2, 2); \n    vec4 new = ((sum > 0.5))?vec4(cur.x,1.0-sum,1.0,1.0):vec4(cur.x,sum-0.0,0.0,1.0);\n    int fx = int(mod(fragCoord.x, 3.0));\n    int fy = int(mod(fragCoord.y, 3.0));\n\n    int px = int(mod(float(iFrame), 3.0));\n    int py = int(mod(float(iFrame) / 3.0, 3.0));\n    fragColor = ((fx == px)&&(fy == py))?new:cur; \n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttXBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 587]], "test": "untested"}
{"id": "wl2yDc", "name": "Ancient Symbols", "author": "BackwardsCap", "description": "What could they mean?", "tags": ["procedural", "noise", "random", "fonts", "symbols"], "likes": 22, "viewed": 634, "published": 3, "date": "1596042977", "time_retrieved": "2024-07-30T20:53:12.581026", "image_code": "//Ancient Symbols\n//by Sam Gates (BackwardsCap)\n\n#define R iResolution.xy\n#define PI 3.1415927\n#define m vec2(5.+2.*4.,10.)\n#define SS(U) smoothstep(PX, 0., U)\n\n//#define MORPH\n\n//Any advice on fixing the inconsistency on the connecting edges when you resize the screen would be very welcome\n#define PX 30./R.y\n\n\nfloat rand (vec2 p)\n{\n    float d = iDate.w;\n    #ifdef MORPH\n    vec2 pp = mod(p,m);\n    d=floor(d*pp.x*pp.y)/30.;\n    #endif\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*(12893.128933)+cos(floor(d)));\n}\n\nmat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\n//https://www.shadertoy.com/view/4llXD7\nfloat B(vec2 p, vec2 b, vec4 r)\n{\n    r.xy = p.x>0.0?r.xy : r.zw;\n    r.x = p.y>0.0 ? r.x : r.y;\n    vec2 q = abs(p)-b+r.x;\n    return SS(min(max(q.x,q.y),0.0)+length(max(q,0.0))-r.x);\n}\n\nbool removed(float h, vec2 p)\n{\n    vec2 lp = mod(p,m);\n    float h2 = rand(vec2(20.+h*(floor(p.y))+10.84));\n    if(lp.x>=4.&&lp.x<11.||lp.y>=6.)return true;\n    return h*dot(h,h2)*5.<=.5;\n}\n\n\nfloat C(vec2 p){return SS(length(p-.5)-.4);}\n\nfloat CL(vec2 p, float a)\n{\n    vec2 bp = (p-.5);\n    bp*=rot(PI/4.*a);\n    bp.x+=.5;\n    return B(bp, vec2(.6,.345), vec4(.3));\n}\n\nfloat CE(vec2 p, vec2 o)\n{\n    return B((p+o)*rot(PI/4.), vec2(.5), vec4(0));\n}\n\nfloat EL(vec2 p, float t)\n{\n    vec2 b = vec2(.5,.4-PX);\n    p-=vec2(.5,.5);\n    p*=rot(PI/2.*t);\n    p.x+=PX;\n    vec4 r = vec4(b.x-b.x/2.,b.x-b.x/2.,0,0);\n    return B(p, b, r);\n}\n\nfloat D(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    p+=.13;\n    float b1 = B(p,vec2(.5),vec4(.5,0,0,0));\n    p+=.77;\n    float b2 = B(p,vec2(.5),vec4(0,0,0,.025));\n    return b1-b2;\n}\n\n\nfloat T(vec2 p, float r)\n{\n    p-=.5;\n    p*=rot(PI/2.*r);\n    return B(p,vec2(.4-PX,.6), vec4(0));\n}\n\nfloat render(vec2 p, float h)\n{\n    bool neighbors[9];\n    int ul=6,u=7,ur=8,l=3,me=4,r=5,dl=0,d=1,dr=2;\n    int n=0;\n\n    float o = 0.;\n\n    for(float y=-1.;y<=1.;y++)\n    {\n        for(float x=-1.;x<=1.;x++){\n\n            int i = int((x+1.)+(y+1.)*3.);\n\n            vec2 pos = floor(p+vec2(x,y));\n\n            neighbors[i]= !removed(rand(pos),pos);\n\n            if(i!=me&&neighbors[i])\n            {\n                n++;\n            }\n        }\n    }\n    \n    p=fract(p);\n\n    if(neighbors[me])\n    {\n        if(n==0) return C(fract(p));\n\t\t\n        if(neighbors[u]&&neighbors[d]){\n\n            float o = T(p,0.);\n            if(neighbors[l])o+=EL(p+vec2(.175,0),0.);\n            if(neighbors[r])o+=EL(p-vec2(.175,0),2.);\n            return o;\n        }\n        if(neighbors[l]&&neighbors[r])\n        {\n            float o = T(p,1.);\n            if(neighbors[u])o+=EL(p-vec2(0,.25),1.);\n            if(neighbors[d])o+=EL(p+vec2(0,.25),3.);\n            return o;\n        }\n\n\n        if(neighbors[u]&&!neighbors[d]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p-vec2(0,.3),1.);\n\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[d]&&!neighbors[u]&&!neighbors[l]&&!neighbors[r])\n        {\n            float o = EL(p+vec2(0,.3),3.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[ur]) o+=CL(p+vec2(.175),3.);\n\n            return o;\n        }\n\n        if(neighbors[l]&&!neighbors[r]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p+vec2(.3,0),0.);\n\n            if(neighbors[ur]) o+=CL(p+vec2(.175,.175),3.);\n            if(neighbors[dr]) o+=CL(p-vec2(-.175,.175),5.);\n\n            return o;\n        }\n\n        if(neighbors[r]&&!neighbors[l]&&!neighbors[d]&&!neighbors[u])\n        {\n            float o = EL(p-vec2(.3,0),2.);\n\n            if(neighbors[ul]) o+=CL(p+vec2(-.175,.175),1.);\n            if(neighbors[dl]) o+=CL(p-vec2(.175),7.);\n\n            return o;\n        }\n        float j = 0.0;\n        if(!neighbors[u]&&neighbors[r]&&!neighbors[l]&&neighbors[d])j+= D(p,3.);\n        if(neighbors[u]&&neighbors[r]&&!neighbors[l]&&!neighbors[d])j+= D(p,2.);\n        if(!neighbors[u]&&!neighbors[r]&&neighbors[l]&&neighbors[d])j+= D(p,0.);\n        if(neighbors[u]&&!neighbors[r]&&neighbors[l]&&!neighbors[d])j+= D(p,1.);\n        if(neighbors[ul]&&!neighbors[l]&&!neighbors[u]) j+=CL(p+vec2(-.175,.175),1.);\n        if(neighbors[dl]&&!neighbors[l]&&!neighbors[d]) j+=CL(p-vec2(.175),7.);\n        if(neighbors[ur]&&!neighbors[r]&&!neighbors[u]) j+=CL(p+vec2(.175,.175),3.);\n        if(neighbors[dr]&&!neighbors[r]&&!neighbors[d]) j+=CL(p-vec2(-.175,.175),5.);\n        \n\n        return  j;\n    }else{\n        float o = 0.0;\n        if(!neighbors[ul]&&neighbors[u]&&neighbors[l])o+= CE(p,vec2(.07,-1.15));\n        if(!neighbors[ur]&&neighbors[u]&&neighbors[r])o+= CE(p, vec2(-1.11));\n        if(!neighbors[dl]&&neighbors[d]&&neighbors[l])o+= CE(p,vec2(.11));\n        if(!neighbors[dr]&&neighbors[d]&&neighbors[r])o+= CE(p,vec2(-1.11,.11));\n        return o;\n    }\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n\n    vec2 p = ((2.0*f-R)/R.y), u=p;\n    \n    p*= (6.0/PI)* (20.*clamp((1.0+sin(-2.1+iTime/5.))/1.5,0.1,1.25));\n    p-=vec2(51,-3.);    \n\n    vec2 lp = (p);\n    p=floor(p);\n    float hash = rand(p);\n    c.rgb=vec3(clamp(render(lp,hash),0.,1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[313, 313, 334, 334, 531], [533, 533, 551, 551, 594], [596, 636, 669, 669, 822], [824, 824, 855, 855, 1014], [1017, 1017, 1033, 1033, 1061], [1063, 1063, 1090, 1090, 1193], [1195, 1195, 1221, 1221, 1274], [1276, 1276, 1303, 1303, 1457], [1459, 1459, 1485, 1485, 1653], [1656, 1656, 1682, 1682, 1757], [1759, 1759, 1790, 1790, 4913], [4915, 4915, 4956, 4956, 5202]], "test": "untested"}
{"id": "wllBz8", "name": "Russian flag (artlebedev)", "author": "Zabidon", "description": "Inspired by https://www.artlebedev.ru/constitution-of-russia/", "tags": ["flag", "russia"], "likes": 3, "viewed": 314, "published": 3, "date": "1596032184", "time_retrieved": "2024-07-30T20:53:13.508547", "image_code": "// The MIT License\n// Created by Kirill Osipov --- zabidon\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 white = vec4(1, 1, 1, 1);\n    vec4 blue = vec4(0, 0, 1, 1);\n    vec4 red = vec4(1, 0, 0, 1);\n    \n    vec4 color = white;\n    if(uv.y > 0.5) {\n        float wbFactor = smoothstep(0.55, 0.9, uv.y);\n        color = mix(blue, white, wbFactor);\n    }\n    if(uv.y < 0.5){\n        float wbFactor = smoothstep(0.1, 0.45, uv.y);\n        color = mix(red, blue, wbFactor);\n    }\n    fragColor = color;\n\n    float sep = iResolution.x*0.5;\n    if (iMouse.z > 0.1) {\n        sep = iMouse.x;\n    }\n    \n    if (abs(fragCoord.x - sep) < 2.0) {\n        fragColor = vec4(0);\n    } else {\n        if (fragCoord.x < sep) {\n        \t// Gamma\n        \tfragColor.rgb = pow(fragColor.rgb, vec3(1.0/2.2));\n    \t}\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBz8.jpg", "access": "api", "license": "mit", "functions": [[1084, 1084, 1141, 1141, 1888]], "test": "untested"}
{"id": "ttlBz8", "name": "Purple Waves - TBOS 5.1", "author": "stungeye", "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nThese hypnotic purple waves are part of my exploration of shaping functions.", "tags": ["waves", "trig", "shaping"], "likes": 1, "viewed": 338, "published": 3, "date": "1596030946", "time_retrieved": "2024-07-30T20:53:14.276493", "image_code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.1 - Shaping Function Gallery - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n#define PI 3.1415926535897\n\n// A fun time with trig.\nfloat function(float x) {\n    float time = mod(iTime, 100. * PI); // Loop the animation.\n    x *= 20. * (sin(time / 50.));       // Change the scale over time.\n    return sin(x * sin(time * .2)) * sin(6. * x + cos(time * time * .001)) * .5  + .5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 st        = fragCoord.xy / iResolution.xy; // Normalize texture coords 0.0 to 1.0.\n  float gradient = function(st.x);                // Gradient value from function. \n  vec3 colour    = vec3(1., 0., 0.)               // Base colour.\n                   + vec3(0., .3, gradient);      // Tinted gradient colour.\n                 \n  fragColor = vec4(colour, 1.);                   // Set pixel colour.\n}\n\n// Kyle Geske - stungeye.com - Unlicense 2020 - https://unlicense.org\n// This is free and unencumbered software released into the public domain", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBz8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[288, 313, 338, 338, 561], [564, 564, 621, 621, 1029]], "test": "untested"}
{"id": "WtsfzH", "name": "Star Ball", "author": "dr2", "description": "Star and hollow balls with a little light and shadow (awaiting total obfuscation)", "tags": ["shadow", "icosahedron", "dodecahedron"], "likes": 10, "viewed": 355, "published": 3, "date": "1596015513", "time_retrieved": "2024-07-30T20:53:15.059401", "image_code": "// \"Star Ball\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  1  // optional antialiasing\n\n#define VAR_ZERO min (iFrame, 0)\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define CosSin(x) (sin ((x) + vec2 (0.5 * pi, 0.)))\n\nvec3 SymCom (vec3 p, vec2 cs, vec2 w)\n{\n  vec2 f;\n  float a;\n  p.x = - abs (p.x);\n  for (int j = 0; j < 4; j ++) {\n    f.y = dot (p.yz, vec2 (cs.x, - cs.y));\n    if (f.y > 0.) {\n      f.x = dot (p.yz, cs.yx);\n      p.yz = vec2 (dot (f, vec2 (cs.y, - cs.x)), dot (f, cs));\n    }\n    if (j < 3) p.xy = Rot2Cs (p.xy, w);\n  }\n  return vec3 (p.xy, - p.z);\n}\n\nvec3 IcosSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * acos (sqrt (5.) / 3.));\n  p.yz = Rot2Cs (vec2 (p.y, abs (p.z)), vec2 (cs.x, - cs.y));\n  return SymCom (p, cs, CosSin (-2. * pi / 3.));\n}\n\nvec3 DodecSym (vec3 p)\n{\n  vec2 cs;\n  cs = CosSin (0.5 * atan (2.));\n  p.xz = Rot2Cs (vec2 (p.x, abs (p.z)), cs);\n  p.xy = Rot2Cs (p.xy, CosSin (- pi / 10.));\n  return SymCom (p, cs, CosSin (-2. * pi / 5.));\n}\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q1, q2;\n  float dMin, d;\n  dMin = dstFar;\n  q1 = IcosSym (p);\n  q1.z += 0.48;\n  q2 = DodecSym (p);\n  q2.z += 0.48;\n  d = min (0.9 * min (PrCylDf (q1, 0.05 * (0.55 + 1.5 * q1.z), 0.3),\n     PrCylDf (q2, 0.05 * (0.55 + 1.5 * q2.z), 0.3)), PrSphDf (p, 0.2));\n  DMIN (1);\n  d = min (d, max (abs (abs (PrSphDf (p, 0.4)) - 0.04) - 0.01,\n     - min (PrCylDf (q1, 0.15 * (0.55 + 1.5 * q1.z), 0.3),\n     PrCylDf (q2, 0.15 * (0.55 + 1.5 * q2.z), 0.3))));\n  DMIN (2);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;\n  float dstObj, at, nDotL, sh;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 1., 3.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. - 0.2 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 5., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.22 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 2) vn = VaryNf (64. * ro, vn, 0.4);\n    dfTot = vec3 (0.);\n    spTot = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.6, 0.95, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro + 0.05 * vn, ltDir);\n      c = HsvToRgb (vec3 (0.9 - 0.25 * float (k), 0.9, 1.));\n      nDotL = max (dot (vn, ltDir), 0.);\n      dfTot += c * (0.05 + 0.95 * at * sh * nDotL * nDotL);\n      spTot += 0.5 * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n    col = dfTot + spTot;\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.07 * pi;\n  el = -0.12 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = floor (tCur / 3.) + smoothstep (0.9, 1., mod (tCur / 3., 1.));\n    az += 0.22 * pi * t;\n    el += 0.2 * pi * sin (0.1 * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -5.);\n  zmFac = 6.;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtsfzH.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[541, 541, 580, 580, 893], [895, 895, 918, 918, 1087], [1089, 1089, 1113, 1113, 1298], [1359, 1359, 1381, 1381, 1862], [1864, 1864, 1897, 1897, 2081], [2083, 2083, 2104, 2104, 2359], [2361, 2361, 2398, 2398, 2627], [2629, 2629, 2664, 2664, 3821], [3823, 3823, 3879, 3879, 4963], [4965, 4965, 4998, 4998, 5025], [5027, 5027, 5069, 5069, 5120], [5122, 5122, 5146, 5146, 5263], [5265, 5265, 5301, 5301, 5507], [5509, 5509, 5539, 5539, 5652], [5654, 5654, 5685, 5685, 5749], [5783, 5783, 5807, 5807, 5919], [5921, 5921, 5946, 5946, 6132], [6134, 6134, 6163, 6163, 6375], [6377, 6377, 6416, 6416, 6596]], "test": "untested"}
{"id": "3lsfRH", "name": "circle rotation in 3D", "author": "Ausfragezeichen", "description": "work in progress", "tags": ["notworking"], "likes": 0, "viewed": 421, "published": 3, "date": "1596000845", "time_retrieved": "2024-07-30T20:53:15.842307", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //constants\n    float pi     = 3.14159265359;\n    float piHalf = 1.57079632679;\n    \n    //variables\n    float zoom = 2.;\n    float speed = 1.25; //rotation speed\n    float radius = 1.;\n  \n    \n    vec2 uv = (fragCoord *2. - iResolution.xy)/iResolution.y;\n    \n    uv *= zoom;  \n    \n    vec3 col = vec3(0.); //black space\n       \n    float cycle = fract(iTime * speed); // from 0. to 1.\n    //float alpha = cycle * 2. * pi; // alpha in rad from 0 to 2*pi\n    float alpha = cycle;\n\n    \n    vec4 new3D = vec4(uv.x, uv.y, 0., 1.);\n    \n    //alpha = piHalf;\n    mat4x4 rotationMat = mat4x4( //rotate by alpha on y axis)\n        cos(alpha), 0., -sin(alpha), 0., \n        0., \t\t1., 0., \t\t0., \n        sin(alpha), 0., cos(alpha), 0., \n        0., \t\t0., 0., \t\t1.); \n    \n    vec4 rot3D = new3D * rotationMat;\n    \n    if(length(rot3D.xyz) < radius){\n        col = vec3(length(rot3D.xyz));\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 1009]], "test": "untested"}
{"id": "3tlfR8", "name": "PlasmaShaper", "author": "parabola", "description": "Masking shapes and changing backogrunds.", "tags": ["parabola", "lisandro"], "likes": 0, "viewed": 298, "published": 3, "date": "1595980223", "time_retrieved": "2024-07-30T20:53:16.614243", "image_code": "\n\n#define PI 3.14159265359\n#define TWO_PI PI * 2\n\nfloat poly(vec2 uv,vec2 p, float s, float dif,int N,float a){\n    // Remap the space to -1. to 1.\n    vec2 st = p - uv ;\n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    \n    float N_float = float(N);\n    float r = PI*2.0/N_float;\n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,s+dif,d);\n    return e;\n}\n\n\nfloat poly(vec2 uv,vec2 p, float s, float dif,float N,float a){\n    // Remap the space to -1. to 1.\n    vec2 st = p - uv ;\n    // Angle and radius from the current pixel\n    float a2 = atan(st.x,st.y)+a;\n    \n    float N_float = float(N);\n    float r = PI*2.0/N_float;\n    float d = cos(floor(.5+a2/r)*r-a2)*length(st);\n    float e = 1.0 - smoothstep(s,s+dif,d);\n    return e;\n}\n\nmat2 scale(vec2 _scale){\n    return mat2(_scale.x,0.0,\n                0.0,_scale.y);\n}\nmat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\n\nvec2 rotate2d(vec2 uv,float _rot){\n    float fix = iResolution.x/iResolution.y; \n    uv-=vec2(0.5*fix,0.5);\n    uv = rotate2d(_rot)*uv;\n    uv+=vec2(0.5*fix,0.5);\n    return uv;\n}\n\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = vec2 (gl_FragCoord.xy/iResolution.xy);\n\n    float fix = iResolution.x/iResolution.y; \n    uv=fract(vec2(uv.x,uv.y)*15.); \n    \n    uv.x*=fix;\n    float shape1 = poly(uv,vec2(0.5*fix,0.5), 0.35,0.008,4,iTime)*2.; \n\n    uv = vec2 (gl_FragCoord.xy/iResolution.xy);\n    uv.x*=fix;\n    float shape2 = poly(uv,vec2(0.5*fix,0.5), sin(iTime*3.)/3.,0.0003,3.,iTime); \n \n    float shape3 = poly(uv,vec2(0.5*fix,0.5), sin(-iTime*3.)/3.,0.0003,4.,-iTime); \n   \n    vec3 finalShapePass = vec3 (mix(shape2,shape3,shape1) );\n    vec3 finalShapePass2 = vec3 (mix(shape2,shape3,shape3) )-vec3 (mix(shape2,shape3,shape2) );\n   \n   \n    uv = fract(rotate2d(vec2 (gl_FragCoord.xy/iResolution.xy),iTime/9.));\n    vec2 p = vec2(0.5) - uv; \n    float r = length(p);\n    float a = atan(p.x,p.y);\n    \n    float color= fract( sin(uv.x*9.+iTime)-iTime+sin(r+iTime/50.)*5.);\n    vec3 finalColor= vec3(color-0.2,color-0.1,color-0.1);\n   \n   \n    vec3 finalPass= vec3(mix(finalColor,finalShapePass,-finalShapePass));\n   \n\n    fragColor = vec4(finalPass,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 111, 147, 426], [429, 429, 492, 528, 807], [809, 809, 833, 833, 896], [897, 897, 925, 925, 1011], [1014, 1014, 1048, 1048, 1193], [1196, 1196, 1252, 1252, 2298]], "test": "untested"}
{"id": "3llBR8", "name": "DNA Palace", "author": "scry", "description": "raymarching! texturing! voxel-ish stuff! woohoo!\noriginally made in KodeLife\n\nnext thing to figure out...anti-aliasing... haha", "tags": ["3d", "raymarch", "trippy"], "likes": 20, "viewed": 640, "published": 3, "date": "1595976881", "time_retrieved": "2024-07-30T20:53:17.379198", "image_code": "#define time iTime*0.5\n// All components are in the range [0…1], including hue.\n//rgb2hsv & hsv2rgb from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n \n\n// All components are in the range [0…1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\nmat2 r2d(float a) {\n    return mat2(sin(a),cos(a),-cos(a),sin(a));\n}\n\nfloat cr(vec2 uv) {\n    float col = 0.;\n    col = (sin(uv.y+time*1.));\n    col += (sin(uv.x*10.));\n    return col;\n}\n\n//from https://iquilezles.org/articles/distfunctions\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvec2 getDist(vec3 p) {\n    //d = min(d,sdBox(vec3(p.x+5.,p.y+bd+2.,p.z),vec3(bd3,bd2,bd2)));\n    //return d;\n    float rd = 0.02;\n    \n    float id = 0.+p.y*0.02;\n    //p = floor(p*2)/10.;\n    //p.zy *= r2d(mouse.x*2.);\n    //p.xz = (fract(p.xz*rd)-0.5)/rd;\n    p.xz = (fract((abs(p.xz)+5.)*rd)-0.5)/rd;\n    //p.xy *= r2d(mouse.y*2.);\n    //float ps = floor(p.y*0.15-2.5)*0.3;\n    float ps = 0.9;\n    vec3 p1 = p;\n    float t = time;\n    float sc = 3.;\n    float wl = 0.3;\n    p1.zx *= r2d(t+t);\n    p1 = floor(p1*ps)/ps;\n    //p1.z -= 2.;\n    p1.zx *= r2d(p1.y*wl-t);\n    p1.xy += sc;\n    //p1 = floor(p1*ps)/ps;\n    vec3 p2 = p;\n    p2.zx *= r2d(t+t);\n    p2 = floor(p2*ps)/ps;\n    //p2.z -= 0.9;\n    p2.zx *= r2d(p2.y*wl-t+3.);\n    p2.xy += sc;\n    //p1.yx *= r2d(time*0.01);\n    float s = 0.1294+(p.y*p.y*p.y+500.)*0.001;\n    //float s = 0.1294;\n    //p1 = floor(p1*0.5)*0.09;\n    //p1.xz = fract(p1.xz);\n    float d = length(p1.xz)-s;\n    float d2 = length(p2.xz)-s;\n    d = min(d,d2);\n    if (d2 > d) {\n        id += 0.3;\n        //d *= 02.9;\n    }\n    d = min(d,p.y+8.);\n    if (p.y+7.99 < d) {\n        float cs = 2.;\n        vec2 fp = p.xz*0.02;\n        fp.xy *= r2d(p1.y*1.-time+3.);\n        fp = floor(fp.xy*cs)/cs;\n        //fp.xy *= r2d(p1.y*1.+time*0.1);\n        id = (mod(fp.x + mod(fp.y, 2.0), 2.0));\n        //if (id < 0.) {\n        //    id = 0.;\n        //}\n        //id = floor(id);\n        //id = 0.3;\n        if (d < 0.) {\n            d = 40.0;\n        }\n        //d = abs(d);\n    }\n    //if (d < 0.) {\n    //        d = -20.;\n    //    }\n    return vec2(d,id);\n}\n\nvec2 RM (vec3 ro, vec3 rd) {\n    float dO = 0.;\n    float ii = 0.;\n    for (int i=0;i<200;i++) {\n        vec3 p = ro+rd*dO;\n        float dS = getDist(p).x;\n        dO += dS*0.3;\n        ii += 0.01;\n        if (dS < 0.01 || dO > 1000.) {\n            break;\n        }\n    }\n    return vec2(dO,ii);\n}\n\n\n\nvec3 mainKL(vec2 uv)\n{\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    //vec2 tv = inData.v_texcoord;\n    vec2 tv = uv;\n    vec3 col = vec3(0.);\n    uv.x *= iResolution.x/iResolution.y;\n    float c = length(uv);\n    //uv *= 0.5;\n    float t = time*0.1;\n    vec3 ro = vec3(0,-2,-0.);\n    ro.z += time*30.;\n    ro.z += iMouse.x*0.5;\n    //ro += mouse.y*20.;\n    vec3 rd = normalize(vec3(uv,0.8));\n    //rd.zx *= r2d(-mouse.x*20.);\n    rd.zy *= r2d(1.9);\n    rd.zx *= r2d(tv.x+t*5.);\n    //rd.zy *= r2d(2.5);\n    vec2 d = RM(ro,rd);\n    vec3 p2 = rd*d.x;\n    vec3 p = ro+rd*d.x;\n    col = vec3(d.x/100.);\n    float ci = getDist(p).y;\n    //col = hsv2rgb(vec3(ci,1.,(d.y)+(d.x*0.001)));\n    col = hsv2rgb(vec3(ci,1.,1.));\n    if (d.x > 999.) {\n        col *= 0.8;\n    }\n    //d.y += -ci*2.;\n    col += ((d.y*0.9)/(d.x*0.01)-1.)*0.2+d.y*0.2;\n    vec3 cf = fwidth(col);\n    col -= cf;\n    //col = (1.-col)+cf;\n    //col = 1.-cf;\n    //cf = fwidth(col);\n    //col = cf-col;\n    col -= vec3(d.x*0.05)*cf;\n    col = mix(col,vec3(0.),clamp(d.x*0.003,0.,1.));\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = mainKL(uv-0.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3llBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 163, 185, 185, 516], [521, 580, 602, 602, 771], [772, 772, 791, 791, 840], [842, 842, 861, 861, 958], [960, 1013, 1044, 1044, 1131], [1133, 1133, 1155, 1241, 2717], [2719, 2719, 2747, 2747, 3017], [3021, 3021, 3043, 3124, 4089], [4091, 4091, 4148, 4198, 4335]], "test": "untested"}
{"id": "wlXfzH", "name": "Camera Movement Test", "author": "Zi7ar21", "description": "Testing camera rotation", "tags": ["3d", "ray", "ray", "raymarch", "mandelbulb", "sphere", "marcher", "epic", "yeet"], "likes": 5, "viewed": 348, "published": 3, "date": "1595974454", "time_retrieved": "2024-07-30T20:53:18.141161", "image_code": "// Fork of \"My Very First Working Fractal\" by Zi7ar21. https://shadertoy.com/view/ttBcWR\n// 2020-07-28 21:58:56\n\n// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 32\n#define MAX_DISTANCE 32.0\n#define COLLISION_DISTANCE 0.01\n#define Bailout 16.0\n#define Iterations 6\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sphere(vec3 pos) {\n\tfloat Power = float((sin(iTime * 2.5) * 0.5) + 8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(0, 8, 0);\n\tvec3 lightpositionb = vec3(0, 0, 0);\n    vec3 lightpositionc = vec3(0, -8, 0);\n\t// Animate Lights\n    lightpositiona.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionb.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n    lightpositionc.xz += vec2(sin(iTime * 4.0), cos(iTime * 4.0))*4.0;\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(0.0, 0.0, -4.5);\n    camerapos = vec3(camerapos.x+((-iMouse.x+iResolution.x/2.0)/iResolution.x), camerapos.y+((-iMouse.y+iResolution.y/2.0)/iResolution.x), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\t\n\t// Finish the Image and Apply Tone Map\n    col = vec3(acesFilm(diffuse));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[929, 1105, 1129, 1129, 1711], [1713, 1738, 1783, 1783, 2092], [2094, 2108, 2134, 2134, 2353], [2355, 2370, 2394, 2414, 3865], [3867, 3886, 3915, 3915, 4100], [4102, 4122, 4179, 4202, 5071]], "test": "untested"}
{"id": "wlXfRH", "name": "Ode to: Piet Mondrian - Tableau", "author": "ChocolatePinecone", "description": "An ode to the work Tableau by Piet Mondrian", "tags": ["mondrian", "pietmondrian", "tableau"], "likes": 3, "viewed": 300, "published": 3, "date": "1595969273", "time_retrieved": "2024-07-30T20:53:18.994878", "image_code": "#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 drawRectangle(vec4 bounds, float edgeWidth, vec2 st) {\n    vec2 stWidth = edgeWidth / iResolution.xy;\n    vec2 relPos = st.xy - bounds.xy;\n    vec3 color = vec3(1.0);\n    \n    // Check to determine if point is inside rect edge or inner part\n    vec2 ch1 = step(bounds.xy, st.xy) - step(bounds.xy + bounds.zw, st.xy); // 1.0 if rect\n    vec2 ch2 = step(bounds.xy + stWidth, st.xy) - step(bounds.xy + bounds.zw - stWidth, st.xy); // 1.0 if inside inner rect\n    float edge = ch1.x * ch1.y - ch2.x * ch2.y; // 1.0 if inside edge\n    \n    // Give edge black color\n    color -= edge;\n    \n    return color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    float fade = (sin(iTime * 2.0) + 1.0) * 0.5;\n    \n    vec3 red = vec3(0.662, 0.129, 0.137);\n    vec3 yellow = vec3(0.996, 0.792, 0.227);\n    vec3 blue = vec3(0.0, 0.368, 0.608);\n\n    // Draw lines\n    color = drawRectangle(vec4(0.05,0.65,0.2,0.4), 10.0, st);\n    color *= drawRectangle(vec4(-0.1,0.65,1.2,0.2), 10.0, st);\n    color *= drawRectangle(vec4(-0.1,-0.1,0.35,1.2), 10.0, st);\n    color *= drawRectangle(vec4(0.7,-0.1,0.25,1.2), 10.0, st);\n    color *= drawRectangle(vec4(0.237,-0.1,0.8,0.2), 10.0, st);\n\n    // Draw colors\n    if(st.x < 0.25 && st.y > 0.65) {\n    \tcolor *= red * fade;\n    }\n    if(st.x > 0.95 && st.y > 0.65) {\n    \tcolor *= yellow * fade;\n    }\n    if(st.x > 0.7 && st.y < 0.1) {\n    \tcolor *= blue * fade;\n    }\n    \n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 105, 105, 654], [657, 657, 714, 714, 1578]], "test": "untested"}
{"id": "wtXfRH", "name": "Bandlimited Synthesis 2", "author": "iq", "description": "A way to prevent aliasing of cosine functions (the color palette in this case) by analytically integrating them. Move the mouse to compare naive versus filtered cos(x). More info [url]https://iquilezles.org/articles/bandlimiting/bandlimiting.htm[/url]", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 101, "viewed": 3638, "published": 3, "date": "1595968982", "time_retrieved": "2024-07-30T20:53:19.878515", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nbool mode;\n\nvec3 fcos( vec3 x )\n{\n    if( mode) return cos(x);                // naive\n\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(6.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n    col += 0.12*fcos(6.28318*t*  1.0+vec3(0.0,0.8,1.1));\n    col += 0.11*fcos(6.28318*t*  3.1+vec3(0.3,0.4,0.1));\n    col += 0.10*fcos(6.28318*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.09*fcos(6.28318*t*  9.1+vec3(0.2,0.8,1.4));\n    col += 0.08*fcos(6.28318*t* 17.1+vec3(0.2,0.6,0.7));\n    col += 0.07*fcos(6.28318*t* 31.1+vec3(0.1,0.6,0.7));\n    col += 0.06*fcos(6.28318*t* 65.1+vec3(0.0,0.5,0.8));\n    col += 0.06*fcos(6.28318*t*115.1+vec3(0.1,0.4,0.7));\n    col += 0.09*fcos(6.28318*t*265.1+vec3(1.1,1.4,2.7));\n    return col;\n}\n\nvec2 deform( in vec2 p )\n{\n    // deform 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    p.x += iTime*0.1;\n    \n    // deform 2\n    p += 0.2*cos( 1.5*p.yx + 0.03*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.2*cos( 2.4*p.yx + 0.03*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.2*cos( 3.3*p.yx + 0.03*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.2*cos( 4.2*p.yx + 0.03*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.2*cos( 9.1*p.yx + 0.03*1.1*iTime + vec2(6.3,3.9) );\n    \n    return p;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 w = p;\n    \n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (w.x-th<0.0);\n\n    // deformation\n    p = deform( p );\n\n    // base color pattern\n    vec3 col = getColor( 0.5*length(p) );\n    \n    // lighting\n    col *= 1.4 - 0.14/length(w);\n\n    // separation\n    col *= smoothstep(0.005,0.010,abs(w.x-th));\n    \n    // palette\n    if( w.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n \n    // output\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtXfRH.jpg", "access": "api", "license": "mit", "functions": [[1854, 1854, 1875, 1875, 2107], [2109, 2109, 2138, 2138, 2703], [2705, 2705, 2731, 2747, 3165], [3167, 3167, 3223, 3242, 3824]], "test": "untested"}
{"id": "tlXfRH", "name": "Fake Temporal Volumetrics", "author": "Zi7ar21", "description": "This changes the collision distance over time and averages the picture", "tags": ["3d", "ray", "ray", "raymarch", "mandelbulb", "sphere", "marcher", "epic", "yeet"], "likes": 3, "viewed": 356, "published": 3, "date": "1595968784", "time_retrieved": "2024-07-30T20:53:20.780104", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // sample texture and output to screen\n    fragColor = texture(iChannel0, uv)/float(iFrame);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 128\n#define MAX_DISTANCE 32.0\n#define COLLISION_DISTANCE ((abs(tan((float(iFrame/60))*16.0)))/256.0)\n#define Bailout 8.0\n#define Iterations 16\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat sphere(vec3 pos) {\n\tfloat Power = float(8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n\t\tif (r>Bailout) break;\n\t\t\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta = theta*Power;\n\t\tphi = phi*Power;\n\t\t\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat distorigin=0.0;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*distorigin;\n        float distsurface = sphere(raypos);\n        distorigin += distsurface;\n        if(distorigin>MAX_DISTANCE || distsurface<COLLISION_DISTANCE) break;\n    }\n    \n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march) {\n\t// Light Positions\n    vec3 lightpositiona = vec3(-4, 0, -2);\n\tvec3 lightpositionb = vec3(0, 0, -2);\n    vec3 lightpositionc = vec3(4, 0, -2);\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// ACES Tone Curve\nvec3 acesFilm(const vec3 x) {\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return clamp((x*(a*x+b))/(x*(c*x+d)+e),0.0,1.0);\n}\n\n// Render the Image\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(sin(float(iFrame))/(iResolution.x/(FOV/0.5)), cos(float(iFrame))/(iResolution.y/(FOV/0.5)), -4.5);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n    vec2 uvb = fragCoord/iResolution.xy;\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Compute and Shade\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    vec3 diffuse = shade(march);\n\t\n\t// Finish the Image and Apply Tone Map\n    col = vec3(acesFilm(diffuse));\n\n    // Output to Screen\n    fragColor = vec4((col+texture(iChannel0, uvb).rgb),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 247]], "test": "untested"}
{"id": "WlfBzH", "name": "Shaping Gallery - TBOS 5.1", "author": "stungeye", "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nA gallery of shaping functions where each function generates:\n\n- Black to white gradient based on the x position of each pixel.\n- 2D x/y graph of the function.\n- The easing movement of an orange circle.", "tags": ["sdf", "text", "bitmap", "graph", "plot", "smoothstep", "gallery", "shaping"], "likes": 3, "viewed": 428, "published": 3, "date": "1595954921", "time_retrieved": "2024-07-30T20:53:21.544062", "image_code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.1 - Shaping Function Gallery - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#define PI 3.1415926535897\n#define DISPLAY_TIME_IN_SECONDS 6.\n#define NUMBER_OF_FUNCTIONS 8\n\n// Bitmap text rendering from: https://www.shadertoy.com/view/4dtGD2\n// Also see: https://www.shadertoy.com/view/4s3fzl\n\n#define _f float\nconst lowp _f CH_A    = _f(0x69f99), CH_B    = _f(0x79797), CH_C    = _f(0xe111e),\n              CH_D    = _f(0x79997), CH_E    = _f(0xf171f), CH_F    = _f(0xf1711),\n              CH_G    = _f(0xe1d96), CH_H    = _f(0x99f99), CH_I    = _f(0xf444f),\n              CH_J    = _f(0x88996), CH_K    = _f(0x95159), CH_L    = _f(0x1111f),\n              CH_M    = _f(0x9f999), CH_N    = _f(0x9bd99), CH_O    = _f(0x69996),\n              CH_P    = _f(0x79971), CH_Q    = _f(0x69b5a), CH_R    = _f(0x79759),\n              CH_S    = _f(0xe1687), CH_T    = _f(0xf4444), CH_U    = _f(0x99996),\n              CH_V    = _f(0x999a4), CH_W    = _f(0x999f9), CH_X    = _f(0x99699),\n              CH_Y    = _f(0x99e8e), CH_Z    = _f(0xf843f), CH_0    = _f(0x6bd96),\n              CH_1    = _f(0x46444), CH_2    = _f(0x6942f), CH_3    = _f(0x69496),\n              CH_4    = _f(0x99f88), CH_5    = _f(0xf1687), CH_6    = _f(0x61796),\n              CH_7    = _f(0xf8421), CH_8    = _f(0x69696), CH_9    = _f(0x69e84),\n              CH_APST = _f(0x66400), CH_PI   = _f(0x0faa9), CH_UNDS = _f(0x0000f),\n              CH_HYPH = _f(0x00600), CH_TILD = _f(0x0a500), CH_PLUS = _f(0x02720),\n              CH_EQUL = _f(0x0f0f0), CH_SLSH = _f(0x08421), CH_EXCL = _f(0x33303),\n              CH_QUES = _f(0x69404), CH_COMM = _f(0x00032), CH_FSTP = _f(0x00002),\n              CH_QUOT = _f(0x55000), CH_BLNK = _f(0x00000), CH_COLN = _f(0x00202),\n              CH_LPAR = _f(0x42224), CH_RPAR = _f(0x24442), CH_END  = _f(0x99999);\n\n// Returns the status of a bit in a bitmap. See above URL for more details.\nfloat getBit( in float map, in float index )\n{\n    return mod( floor( map*exp2(-index) ), 2.0 );\n}\n\n// Draws a character from it's bitmap. See above URL for more details.\nfloat drawChar( in float char, in vec2 pos, in vec2 size, in vec2 uv )\n{\n    uv = (uv - pos) / size;\n    float res = step(0.0,min(uv.x,uv.y)) - step(1.0,max(uv.x,uv.y));\n    uv *= vec2(4,6);\n    res *= getBit(char, 4.0*floor(uv.y) + floor(uv.x));\n    return clamp(res,0.,1.);\n}\n\n// Given an array of bitmap floats, draw out the characters.\nfloat textArray(in vec2 uv, in float[20] string) {\n    const float spacing = 0.08;\n    const vec2 charSize = vec2(spacing * .8, spacing * .8);\n    vec2 charPos = vec2(0.07, 0.88);\n\n    float chr = 0.0;\n\n    for (int i = 0; i < 20; i++) {\n        chr += drawChar( string[i], charPos, charSize, uv);\n        charPos.x += spacing;\n    }\n\n    return chr;\n}\n\n// Which function are we currently displaying? Index from 0 to NUMBER_OF_FUNCTIONS-1\nint functionIndexBasedOnTime() {\n    return int(mod(iTime / DISPLAY_TIME_IN_SECONDS, float(NUMBER_OF_FUNCTIONS)));\n}\n\n// Pick and apply the indexed function.\nfloat pickFunction(float x) {\n    float y;\n    int index = functionIndexBasedOnTime();\n\n    if (index == 0) {                // sin(pi/2 * x)\n        y = sin(.5 * PI * x);\n    } else if (index == 1) {         // 1/2 + (sin(2 * pi * x) / 2)\n        y = sin(x * 2. * PI);\n        y = .5 * y + .5;\n    } else if (index == 2) {         // abs(sin(2 * pi * x))\n        y = abs(sin(2. * PI * x));\n    } else if (index == 3) {         // 1/2 + (tan((pi * x) - pi/2) / 10)\n        y = tan(x * PI - (.5 * PI));\n        y = .1 * y + .5;\n\n        // Don't antialias the infinity that lies just beyond 0 and 1.\n        if (x < 0.) { y = 0.0; }\n        if (x > 1.) { y = 100.; }\n    } else if (index == 4) {         // x^5\n        y = pow(x, 5.);\n    } else if (index == 5) {         // smoothstep(0.1, 0.9, x)\n        y = smoothstep(.1, .9, x);\n    } else if (index == 6) {         // smoothstep(0.4, 0.5, x) - smoothstep(0.5, 0.6, x)\n        y = smoothstep(.4, .5, x) - smoothstep(0.5, 0.6, x);\n    } else if (index == 7) {         // Found: https://www.shadertoy.com/view/3sKSWc\n        float time = mod(iTime, 100.);\n        x *= 5.;\n        y = sin(x * sin(time * .2)) * sin(6. * x + cos(time * time * .001)) * .5  + .5;\n    }\n\n    return y;\n}\n\n// Pick and display the text rendering of the indexed function.\nfloat pickText( in vec2 uv )\n{\n    float s[20];\n    int index = functionIndexBasedOnTime();\n    \n   const float array[3] = float[3](2.5, 7.0, 1.5);\n\n    // This code was originally written targeting WebGL, which is OpenGL 2.x, so doesn't include array constructors.\n    // So instead we have a fixed size array that we \"fill up\" with text by indexing each character.\n    // On ShaderToy this code could be refactored to use array constructors. It would be much more concise.\n    \n    if (index == 0) {          // sin(pi/2 * x)\n        s[0] = CH_S;\n        s[1] = CH_I;\n        s[2] = CH_N;\n        s[3] = CH_LPAR;\n        s[4] = CH_PI;\n        s[5] = CH_SLSH;\n        s[6] = CH_2;\n        s[7] = CH_X;\n        s[8] = CH_RPAR;\n    } if (index == 1) {        // 1/2 + (sin(2 * pi * x) / 2)\n        s[0] = CH_1;\n        s[1] = CH_SLSH;\n        s[2] = CH_2;\n        s[3] = CH_PLUS;\n        s[4] = CH_S;\n        s[5] = CH_I;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_2;\n        s[9] = CH_PI;\n        s[10] = CH_X;\n        s[11] = CH_RPAR;\n        s[12] = CH_SLSH;\n        s[13] = CH_2;\n    } else if (index == 2) {   // abs(sin(2 * pi * x))\n        s[0] = CH_A;\n        s[1] = CH_B;\n        s[2] = CH_S;\n        s[3] = CH_LPAR;\n        s[4] = CH_S;\n        s[5] = CH_I;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_2;\n        s[9] = CH_PI;\n        s[10] = CH_X;\n        s[11] = CH_RPAR;\n        s[12] = CH_RPAR;\n    }  else if (index == 3) {   // 1/2 + (tan((pi * x) - pi/2) / 10)\n        s[0] = CH_1;\n        s[1] = CH_SLSH;\n        s[2] = CH_2;\n        s[3] = CH_PLUS;\n        s[4] = CH_T;\n        s[5] = CH_A;\n        s[6] = CH_N;\n        s[7] = CH_LPAR;\n        s[8] = CH_PI;\n        s[9] = CH_X;\n        s[10] = CH_HYPH;\n        s[11] = CH_PI;\n        s[12] = CH_SLSH;\n        s[13] = CH_2;\n        s[14] = CH_RPAR;\n        s[15] = CH_SLSH;\n        s[16] = CH_1;\n        s[17] = CH_0;\n    } else if (index == 4) {   // x^5\n        s[0] = CH_P;\n        s[1] = CH_O;\n        s[2] = CH_W;\n        s[3] = CH_LPAR;\n        s[4] = CH_X;\n        s[5] = CH_COMM;\n        s[6] = CH_5;\n        s[7] = CH_RPAR;\n    } else if (index == 5) {   // smoothstep(0.1, 0.9, x)\n        s[0] = CH_S;\n        s[1] = CH_M;\n        s[2] = CH_O;\n        s[3] = CH_O;\n        s[4] = CH_T;\n        s[5] = CH_H;\n        s[6] = CH_S;\n        s[7] = CH_T;\n        s[8] = CH_E;\n        s[9] = CH_P;\n    } else if (index == 6) {   // // smoothstep(0.4, 0.5, x) - smoothstep(0.5, 0.6, x)\n        s[0] = CH_QUOT;\n        s[1] = CH_S;\n        s[2] = CH_M;\n        s[3] = CH_O;\n        s[4] = CH_O;\n        s[5] = CH_T;\n        s[6] = CH_H;\n        s[7] = CH_L;\n        s[8] = CH_I;\n        s[9] = CH_N;\n        s[10] = CH_E;\n        s[11] = CH_QUOT;\n    } else if (index == 7) {   // See pickFunction above. :)\n        s[0] = CH_S;\n        s[1] = CH_E;\n        s[2] = CH_E;\n        s[3] = CH_BLNK;\n        s[4] = CH_S;\n        s[5] = CH_O;\n        s[6] = CH_U;\n        s[7] = CH_R;\n        s[8] = CH_C;\n        s[9] = CH_E;\n        s[10] = CH_BLNK;\n        s[11] = CH_COLN;\n        s[12] = CH_RPAR;\n    }\n    \n    return textArray(uv, s);\n\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat distanceToLineSegment(vec2 p0, vec2 p1, vec2 p) {\n    float distanceP0 = length(p0 - p);\n    float distanceP1 = length(p1 - p);\n    float l2 =pow(length(p0 - p1), 2.);\n    float t = max(0., min(1., dot(p - p0, p1 - p0) / l2));\n    vec2 projection = p0 + t * (p1 - p0);\n    float distanceToProjection = length(projection - p);\n\n    return min(min(distanceP0, distanceP1), distanceToProjection);\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat distanceToFunction(vec2 p, float xDelta) {\n    float result = 100.;\n\n    for (float i = -3.; i < 3.; i += 1.) {\n        vec2 q = p;\n        q.x += xDelta * i;\n\n        vec2 p0 = vec2(q.x, pickFunction(q.x));\n        vec2 p1 = vec2(q.x + xDelta, pickFunction(q.x + xDelta));\n        result = min(result, distanceToLineSegment(p0, p1, p));\n    }\n\n    return result;\n}\n\n// Used for smooth function plotting see: https://www.shadertoy.com/view/3sKSWc\nfloat plotIt(vec2 st, float pct){ // (st = texture coordinates) (pct = % from 0.0 to 1.0)\n  float width = 4.;\n  float distanceToPlot = distanceToFunction(st, 1. / iResolution.x);\n  return smoothstep(0., width, width - distanceToPlot * iResolution.y);\n}\n\n// Draws a progress bar along the bottom of the texture.\nfloat progressBar(vec2 st) {\n    float width = 0.01;\n    float seconds = mod(iTime, DISPLAY_TIME_IN_SECONDS) / DISPLAY_TIME_IN_SECONDS;\n\n    return float(st.y < width && st.x < seconds);\n}\n\n// Signed distance circle with an offset. See: https://www.shadertoy.com/view/3ltSW2\nfloat sdCircle(vec2 p, float r, vec2 offset)\n{\n    p.xy -= offset.xy;                      // Position the circle with an x/y offset.\n    p.y *= iResolution.y / iResolution.x;   // Unskew circle based on aspect ratio.\n    return (1. - sign(length(p) - r)) / 2.; // Are we inside (1) or outside (0) the circle?\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Colours for our various on-screen components.\n  const vec3 plotColour = vec3(0.46, 0.37, 0.74);\n  const vec3 textColour = vec3(.9, .15, .3);\n  const vec3 progressColour = vec3(0., .33, .58);\n  const vec3 circleColour = vec3(0.850,0.591,0.227);\n\n  vec2 st = fragCoord.xy / iResolution.xy; // Normalize texture coords from 0.0 to 1.0.\n  vec2 tt = fragCoord / iResolution.y;     // Normalize based only on y resolution for text.\n\n  float y = pickFunction(st.x);     // Pick and calculate a function.\n  float text = pickText(tt);        // Pick and create the bitmapped text and offset shadow.\n  float textShadow = pickText(tt + vec2(-.004, .005));\n  float progress = progressBar(st); // Render the progress bar.\n  float plot = plotIt(st, y);       // Smooth plot the function.\n\n  // Plot the circle easing it's position by the selected function across three second intervals.\n  float circle = sdCircle(st, 0.04, vec2(pickFunction(mod(iTime, 3.) / 3.)));\n\n  float gradient  = min(y, 1.0);      // Black to white background gradient.\n        gradient *= (1. - plot);      // Remove gradient \"below\" where plot will be drawn.\n        gradient *= (1. - text);      // Remove gradient \"below\" where text will be drawn.\n        gradient *= (1. - textShadow);// Remove gradient to leave a text shadow.\n        gradient *= (1. - progress);  // Remove gradient \"below\" where the progress bar will be drawn.\n        gradient *= (1. - circle);    // Remove gradient \"below\" where the circle will be drawn.\n        gradient  = max(gradient, 0.0); // Negative values become zero.\n\n  // Putting everything together with colours.\n  vec3 colour = vec3(gradient)\n                 + vec3(plot) * plotColour\n                 + vec3(text) * textColour\n                 + vec3(progress) * progressColour\n                 + vec3(circle) * circleColour;\n\n  fragColor = vec4(colour, 1.);  // Set pixel colour.\n}\n\n\n// Kyle Geske - stungeye.com - Unlicense 2020 - https://unlicense.org\n// This is free and unencumbered software released into the public domain", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlfBzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1940, 2016, 2062, 2062, 2114], [2116, 2187, 2259, 2259, 2464], [2881, 2966, 2998, 2998, 3082], [3084, 3124, 3153, 3153, 4359], [4361, 4425, 4455, 4455, 7571], [7573, 7653, 7708, 7708, 8054], [8056, 8136, 8184, 8184, 8507], [8509, 8589, 8622, 8678, 8841], [8843, 8900, 8928, 8928, 9088], [9090, 9175, 9221, 9221, 9486], [9490, 9490, 9547, 9598, 11437]], "test": "untested"}
{"id": "tlXfR8", "name": "Interlocked Tetrahedra - fab2", "author": "FabriceNeyret2", "description": "as an exercise, recoding the base shape of  dr2's 3904 chars [url]https://www.shadertoy.com/view/3lfBz8[/url] (without shading or shadows).\nHere, with approx of dr2's shading & lighting.\n\n", "tags": ["raymarching", "escher", "tetrahedron", "shape"], "likes": 7, "viewed": 330, "published": 3, "date": "1595953216", "time_retrieved": "2024-07-30T20:53:22.311011", "image_code": "// variant of https://shadertoy.com/view/WtXfzH\n// Here, with approx of dr2's shading & lighting. https://www.shadertoy.com/view/3lfBz8\n\n// pyramid with hole SDF + normal ( Matrix version: too bad we don't have invmax() )\n#define P  T = -q.y - 1.;  N=vec3(0,-1,0);                  \\\n           for(float k=0.; k<3.; k++) {                     \\\n               V = vec3(.94*cos(2.1*k+vec2(0,11)),.33).xzy; \\\n               d = dot(V,q) - 1.;                           \\\n               if ( d > T ) T = d, N = V;                   \\\n           }                                                \\\n           d = 1.5-length(q);                               \\\n           if ( d > T ) T = d, N = -q/length(q)                   \n\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n                    \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=1.,T, d;\n    vec3  R = iResolution, V, k = vec3(0,2.1,4.2),n,N,\n          D = normalize(vec3( U+U, -10.*R.y ) - R ),     // ray direction\n       // D = normalize(vec3(.1*(U+U-R.xy)/R.y, -1)),    // ray direction\n          p = 30./R, q;                                  // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p; \n        q.yz *= rot(.3),                                 // rotations\n        q.xz *= rot(.3*iTime),\n            \n        q.y += .5;                       P; t = T,n=N,   // bottom pyramid\n        q.y = .5-q.y; q.xz *= rot(1.05); P; t = min(t,T);// top pyramid\n        p += t*D;                                        // step forward = dist to obj\n    }\n    if (t==T) n = N;\n    \n/**/n.xy *= rot(.3*iTime);                               // rotate 3 lights\n    O.rgb *= .8 + .5*n;                                  // pseudo-dr2 shading + color-lighting\n/**/\n/** O *= t==T ? (.5+N.y) * vec4(1,.7,.5,1)               // object shading\n              : (.5+n.y) * vec4(.5,.7,1,1);              // & coloring\n/**/\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlXfR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[810, 810, 846, 846, 1946]], "test": "untested"}
{"id": "WtXfzH", "name": "Interlocked Tetrahedra - fab", "author": "FabriceNeyret2", "description": "as an exercise, recoding the base shape of  dr2's 3904 chars [url]https://www.shadertoy.com/view/3lfBz8[/url] (without shading or shadows).\n\n", "tags": ["raymarching", "escher", "tetrahedron", "shape"], "likes": 8, "viewed": 329, "published": 3, "date": "1595950969", "time_retrieved": "2024-07-30T20:53:23.206617", "image_code": "// pyramid with hole SDF;  matrix vs loop equivalent versions.\n#define P       V = .94*mat3(cos(k),.35*R/R,sin(k)) * q - 1.,    \\\n                T = max( max( -q.y - 1.,V.x), max(V.y,V.z)),     \\\n                T = max( T, 1.5-length(q) )                   /**/\n/*\n#define P       T = -q.y - 1.;                                   \\\n                for(float k=0.; k<3.; k++)                       \\\n                    V = vec3(.94*cos(2.1*k+vec2(0,11)),.33).xzy, \\\n                    T = max( T, dot(V,q) - 1. );                 \\\n                T = max( T, 1.5-length(q) )                   /**/\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                    \n                    \nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=1.,T;\n    vec3  R = iResolution, V, k = vec3(0,2.1,4.2),\n          D = normalize(vec3( U+U, -10.*R.y ) - R ),     // ray direction\n       // D = normalize(vec3(.1*(U+U-R.xy)/R.y, -1)),    // ray direction\n          p = 30./R, q;                                  // marching point along ray \n    O-=O;\n    for ( O++; O.x > 0. && t > .01 ; O-=.015 ) {\n        q = p; \n        q.yz *= rot(.3),                                 // rotations\n        q.xz *= rot(.3*iTime),\n            \n        q.y += .5;                       P, t = T,       // bottom pyramid\n        q.y = .5-q.y; q.xz *= rot(1.05); P, t = min(t,T);// top pyramid\n\n        p += t*D;                                        // step forward = dist to obj\n    }\n    O *= t==T ? vec4(1,.7,.5,1) : vec4(.5,.7,1,1);       // object coloring\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXfzH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[688, 688, 724, 724, 1540]], "test": "untested"}
{"id": "3tffRH", "name": "ReTrAdUi amalgations6 ad37", "author": "ollj", "description": "in 2d view:\ndrag dots, klick to add dot. drag to lower left to erase.\n\nin 3d view:\nESDF+mouse to move\nT pauses time\nG freezes mouse input for other modes\n\nparent:    https://www.shadertoy.com/view/WtfBRH\ngrandparent: https://www.shadertoy.com/view/Wt2yDV\n", "tags": ["gradient", "csg", "ik", "derivative", "ui", "trace", "ad", "automaticdifferentiation", "superprim", "bayeeps", "barycentricfrustumcull"], "likes": 2, "viewed": 339, "published": 3, "date": "1595936584", "time_retrieved": "2024-07-30T20:53:24.850222", "image_code": "/*\nReTrAdUi\n=[Re]Relativistic Epsilon          (buffC relativisic marcher with performance optimizations)\n,[Tr]Temporal     Reprojection     (buffD is still on its own)\n,[Ad]Automatic    Differentiation  (BuffB hopefully 3 derivatives in 4d)\n,[Ui]User         Interface        (BuffA drag and drop)\n\nthis amalgation is a bit messy, it can only go uphill from here.\nthe CommonTab has toggles between 3 scenes; Temporal Reprojection, Automatic Differentiation, and a 2d UI-focused Scene.\nbelow test is mostly about the [automatic differentiation] scene\nthe Image-MainImage function on the bottom here toggles between Re7 (relativityEngine) and all else.\nThe goal here is to unify concepts of 4 other shaders, where ever that makes sense and evades conflicts.\n*/\n\n/*\nin 3d space \n- keys [ESDF] moves camera\n- Mouse drag rotates camera (while not in edit mode)\n\n- key [t] toggles pausedTime                (camera unaffected)\n- key [g] toggles editMode (and halts Time) (mouse drag no longer rotates camera)\n\n\n\n*/\n\n//bayemode =0 has a period of 1 second //good to visualize the effect \n//bayemode =1 has a period of 1 frame, but may flicker way too much\n//bayemode =2 has a period of 1 frame, averages 7 averages of iTimeDelta (over intervals up to 1,2,4,8,1632,64,128)\n//bayemode =2 is extra slow for loading 2 fragments values of another buffer\n//bayemode =2 sucks for being way too slow without fragmentshader providing the values\n//bayemode =1 sucks while the player gives any inputs (second intgerval lags)\n//bayemode =0 sucks for maybe flickering like crazy \n#define BayeMode 2\n\n//but it should automatically adjust nicely to most resolutions (up to 1900x1000 px)\n//to maintain the same framerate at any resolution, it will automatically adjust the LoD\n//(LoD for now just the epsilon of the raymarrching)\n//BUT it does NOT predict the processing power of your gpu well\n//and that needs to be manually scaled to that by a divisor:\n\n//if you have a modern graphic card with like 6 GB vram (like geforce 1660)\n//these values are for a 1900x1000ish resolutuion) (nd smaller cones scale pretty well)\n//#define FPStarget pow(30./7.,1.68)  //60 fps\n\n//#define FPStarget (60.*3.)    //60 fps\n//#define FPStarget (50.*3.)    //50 fps\n//#define FPStarget (40.*3.)    //40 fps\n#define FPStarget (30.*3.)    //30 fps\n//#define FPStarget (20.*3.)    //20 fps\n//#define FPStarget (15.*3.)    //15 fps\n\n//#define FPStarget (1./500.)    //testing the [mie] limits for minimum epsilon\n\n//if you have an older graphic card with like 2 GB vram (geforce 0960)\n//chose any of the below, firstvalue is the fps you want (disregarding any LoD)\n\n//this one is old, the pow is likely not needed\n//you likely only change the divisor of /5.\n//#define FPStarget pow(60.,1.68) //60 fps\n//#define FPStarget pow(50.,1.68) //50 fps\n//#define FPStarget pow(40.,1.68) //40 fps\n//#define FPStarget pow(30.,1.68) //30 fps\n//#define FPStarget pow(20.,1.68) //20 fps //this integer fraction of 60 seems fine\n//#define FPStarget pow(10.,1.68) //10 fps\n//#define FPStarget pow(5.,1.68)\n\n//error to fix: a very small epsilon (hight LoD) results in noisy black dots\n//its a rough estimate, wobbly, more noticable while rotating the camera \n// on larger resolutions with lower fps\n//i did not even doisplay the fps result, and only did \"by feel\"\n\n\nvec4 Get(float a,sampler2D b\n){return texture(b,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nvec4 Get(float a){return Get(a,iRe);}\n//return texture(iRe,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\nRE,RelativityEngine,TargetFps\nTR,TemporalReprojection\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nself UI2TARD38: https://www.shadertoy.com/view/3l2GDR (amalgations2)\nparent UI2AD37: https://www.shadertoy.com/view/3tSGDz (slow progress)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\n\n//tags:\n//lod,blackhole,redshift,relativity,compatibility,dilation,bayesian,simultaneouity,bayeEp\n/*\nself    RE7 : https://www.shadertoy.com/view/tlf3zj\nparent0 RE6 : https://www.shadertoy.com/view/WtfGRj\nparent1 RE5?: https://www.shadertoy.com/view/tdfXDl\n/**/\n//todo, hide thes BaeysTheorem-oscillations in \n//- temporal reprojection\n//- a screenspace noisy-offset of parameters (uv stays unaffected)\n//- - 16x16BayerMatrix should be good enoug here\n//- all of the above\n//- a lower  FPStarget causes lessfps and better images\n//- a higher FPStarget causes higher and worse images\n//enter target fps as base below, and see it oscillate till it hopefully approaches the target fps\n//its a kind of magic of the logn() core function:\n//testing sclaing of resolutions is hard. the fps dispolay is a big overheat\n//, that tends to cost -5% of the fps.\n//the fun part, FPStarget is INDEPENDENT from the parameter below\n#define maxStepRayMarching 2000\n// within maxStepRayMarching[50..200], which mostly depends on the average scene curvature\n//which is hard to estimate becuase it has a black hole inside of it!!!\n//thats right, you enter 200 maxSteps, and   FPStarget pow(40.,1.68), and iut will reach 40 fps!\n//\"as you wish milord\"\n//initially FPStarget mapped to a targetFPS one to one (esponent was initially close to 1), \n//so yo you could enter what fps you wanted, and it would almost reach it.\n//but the more complex this gets, the worse your scales and estimates become\n//andd the overhead accumulates, and has problems to estimate its own cost.\n//currently the overhead is roughly an exponent of 1.6 to 1.7 ?\n//nonetheless, all the DIRECTIONS of the interpolations and bijections are correct\n//and with that exponent, you can enter the target fos as basis\n//it is optimized for the 500px-wide preview, may not scale too well to larger resolutions\n//i tried, this is VERY twittly.\n//this really needs BoundingVolumes, so that not all viewing angles have roughly the same complexity!!!\n//so yeah, if there ever was a shader that needed lobeps added to it...\n//but fitst let me fix compatibility iassues of this shader...\n/*\ncore idea here is, you set a target fps, and the renderer tries to just reach that FPS count.\nit may increase epsilon, if it was overperforming previously (fps was above FPStarget)\nit may decrease epsilon, if it was underperforming previously (fps was below FPStarget)\nstill, there exists a clamp() to the epsilon values\n, and a lot of of smoothened interpolation ramps and logarythms.\n, because an extreley huge epsilon makes little sense in 60fps\n, because an extremely tiny epsilon makes little sense, just to stay at a lower FPStarget\nThis begs for a better [BayesTheorem over time], but i have yet to implkement the necessary state for that.\nit does not just do this for epsilon, but also for [ReciprocalLipschitz]\n, ==[the amount you understep by]\n, ==[the interval of your volumeMarching]\nIt has a bias in vafor of the ScreenCenter \n- smaller reciprocalLipschitz near screencenter than near screen corner\n- smaller epsilon near screencenter than near screen corner\n- - the epsolon oscillations in a 1 second interval are more noticable near screen corners\n- - damnit this is inverse fovea!\nthis might be much more useful in a set with\n- Proper (axis aligned)BoundingVolume(hierarchy), may be great with fractals with simple escapeTime conditions\n- very different sceneries, a long beach horiton and a small simple box.\n- logatythmic epsilon marching\n- SoC marching\nnegative side effect;\n- it goes into the right directions, but it fails to estimate any half decent taylor series, and therfore misses the target a lot\n- , unles you add more exponents to twiddle with.\n- in too high resolutions (or at 15 or 30fps) , It may heavily oscillate between 2-4 states where it keeps being [too fast] , [too slow]\n- without proper [bayes theorem over time with buffer states] i fail to twiddle parameters to work with multiple resolutions/settings.\nbut so far the proof of concept holds up for this set, and it kinda works\n,while in     512.*384. px resolution\nmost of its magic comes from its bijective subroutine: (r2l2Ws(logn()))\n\n2020-08-02, i finally implemented the averaging over 8 averages of iTimeDelta\neach of them accumulates the incremental averave over the (up to) \nmost recent 1,2,4,8,16,32,64,128 frames, and the (non weighted) average of that\nis a pretty smooth alternative to just feedign iTimedelta or iFrameRate/60.\n*/\n\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log(x)/log(base);}//log2(x)/log2(base) has any utility? possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n//nope, i did not gain anything too useful from sucstituting for log2(x)/log2(bae), so far, i tried here, its just not pretty.\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}          //a[  0..1] <= a[1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //a[1/b..b] <= a[  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n//bayesEps concept\n//use BayesTheorem to adjust epsilon over time, to reach a target FPS\n//if you look along the horizon, expect epxsilon to increase, to maintain fps\n//if you look into a small box, expect epsilon to derase, for more precision\n//input current epsilon and TATGET fps\n//return an epsilon, in hopes to adjust epsilon, to get [[f] fps] with the next frames.\n\nfloat getEpsToFps(float e,float f   //f>0.\n){//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.5\n //.75 is a pretty high max epsilon, but its the easiest way to get performance\n //, especially further away from the camera or behind an occuder or near a black hole\n ;//mie=.00085*.8 has many dots in the spinning fractal balls on lightspeed=2.1 \n //when between blackhole of 2 and balls\n ;mie=.0009 //.00085 is ALMOST artefact free mie with recLipschitz==1.\n            //mie=.0009 is artefact free\n            //mie<.00085 makes the blackh hole looks smoother, but distant flat walls look worse.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode==2\n  //changes loD every frame, smoothly, but does +7 divisions per frame\n  ;vec4 reTime=Get(ReTime);//vec3 reTimE=Get(ReTimE).xyz//7 invremental averages\n  ;float a=suv(reTime)/4.  // divide by 4 to average 4\n  ;//float a=(suv(reTime)+suv(reTimE))/7.//average of 7 invremental averages (of different lengths)\n  ;//do NOT include iTimedelta into the above average, this just causes 1frape flickers\n  ;//im not sure if i even want the averaged 2 frames long flicker of reTime.x\n  ;i*=a/8.  //somehow a /8 modifier is needed //very smooth\n #elif BayeMode==1   \n  ;i*=iTimeDelta//changes LoD every frame, cheapest, very flickery\n #else\n  ;i/=iFrameRate//changes LoD every 60 seconds, cheap \n #endif\n ;i=i*FPStarget*6e3/(iResolution.x*iResolution.y) //6000=800*450/60\n ;e=r2l(i,6.)\n ;e=e//pow(e,2.)//sqrt(e)\n ;//e=log(e)\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae)\n ;//it seems i need a good sigmoid function here, maybe even hust atan1()\n ;return e\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not twiddle-account for many unknowns, without BayesTheorem.\n//the rotating fractal is evil here, because smaller epsilon result in BETTER lipschitz continuty AND better performance\n//so, some shapes are exceptions to general rules of optimitation-flow, with a shitty local extrema!\n//a minor drawbeck to the overall greatness of Naesian methods in sphertrackers.\n//or maybe just a bug to be fixed.\n\n//the fun of the above is, worst case is that it oscilates a bit\n//now, we can have 2 parameters independently modified in this way\n//both likely oscillate differently, and not the same (which woulc link them inapropriattrly)\n//so, lets also modify reciprocalLipschitz just like that:\n/**/\nfloat getReLipschitzToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.8//just do not make  mae>1., unless you are in logeps() marching territory.\n ;mie=.3 //mie<.3 has bad black lines in concave 90def corners\n ;//mie>.6 is already too large, for shapes\n ;//, that move with [half the speed of light][near a black hole]\n ;//- yes, these are my quality merasures for lipschitz continuity by now.\n ;//- once you have logeps()-marched a double [tensor] with lipschitz>5 \n ;//- with no continuity or performance problems\n ;//- , you kinda run out of challenges.\n ;float N=6.\n ;float i=pow(iResolution.x/512.,2.5)\n #if BayeMode ==1   \n  ;float tt=pow(FPStarget,1./1.68)\n  ;tt=pow(tt*300./40.,1.68)\n  ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n  ;i*=tt/60.\n #else\n  ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n  ;i*=FPStarget/60.\n #endif     \n ;i=clamp(i,1./N,N)//worksave bound\n ;e=r2l(i,N)\n ;//a 1/N ratio maps to 0\n ;//a 1/1 ratio maps to 1\n ;//a N/1 ratio maps to 2 , so, this transforms a ratio into something to mix with:\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae);\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\n\n\nfloat sscocS=32.;//how better near screencenter than near screenborders\n\nfloat getReLipschitzToFps(){return getReLipschitzToFps(.25,FPStarget);}\n//our baseline is still a targetPFS\n//#define dd(a) dot(a,a)\n//now, lets make it better near the screen center\n//lets weight them over how oval-distant they are to screenspace center\n//of course the oval is scaled by sqrt(2) and is a smoothstep and all the good stuf\n\nfloat getEpsToFps(float sscoc//here it makes sense, i suppose\n){sscoc=mix(FPStarget/sscocS,FPStarget*sscocS,sscoc)//larger epsilon neart screenspace borders, smaller near center\n  ;return getEpsToFps(.001,sscoc);}\n\nfloat getReLipschitzToFps(float sscoc){//return 1.\n   ;sscoc=mix(FPStarget/sscocS,FPStarget,sscoc)//lefr value near corner, right value near center\n   ;return getReLipschitzToFps(.25,FPStarget);}\n#define reciprocalLipschitz getReLipschitzToFps()\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.x is the inner bound of a dot's black border\n //e.y is the outer bound of a dot's black border \n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bézier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n//#define viewzoom  (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n//the old version of this was not ALL bad\n//it may be revivable, IF merged with \n//equicenter of : https://www.shadertoy.com/view/tlKcDz\n//IFF you do not need zFar.\n//and when points are swapped in some cases, to fold many cases.\n\n\n//barycentric triangle tracing speedup\n//+1 float division +1 float sqrt to  calculate what segments are being intersected.\n//of ray and triangle\n//the division only needs to be done once, every time RayTarget changed.\n//getPosSmallV() getPosLargeV() is a lot of min()max() branching tree though.\n//generates pseudo-bvec2 that stores what of the 2 segments are intersected.\n//then +1 sqrt and +1 div foreach segment , can be times (0,1 or 2)\nvec4 baryTriangleOldSemiObsolete(float t,vec2 u,vec3 r,vec4 m,vec2 p3,vec2 p4,vec2 p0,vec2 p1,vec2 p2,vec4 c){\n ;float h=line(u,p0,p1)-.01\n ;h=min(h,line(u,p1,p2)-.01)\n ;h=min(h,line(u,p2,p0)-.01)\n ;c.w=min(h,ray(u,p3,p4)-.01) //draw ray and triangle\n ;c.x=h\n ;c.z=sdTriangle(p0,p1,p2,u)-.04\n ;float carthesianDet=c2bdet(p0,p1,p2)//+1 div (preferred)\n ;vec3 uu=c2b(u,p0,p1,p2,carthesianDet)//+0 div foreach each c2b() with carthesianDet\n ;vec3 ssu=sat(sign(uu))\n ;float uus=suv(ssu)\n ;//return vec4(ssu,1.)\n ;mat3 n=mat3(p0,0,p1,0,p2,0)\n ;float ddd=0.\n ;float gpl=float(getPosLarge(ssu))\n\n ;vec3 oo=c2b(p3,p0,p1,p2,carthesianDet)\n ;vec3 tt=c2b(p4,p0,p1,p2,carthesianDet) //ray points transformed from carthesian to barycentric\n ;vec3 vs=oo-tt \n ;vec3 l=vec3(dd(p1-p2),dd(p2-p0),dd(p0-p1))//squared side length\n ;float radius=dd(lengthBary(oo-tt,l))//vector (oo-tt) length*length from barycentric vector\n //;vec3 vv=c2b(p4-p3,p0,p1,p2)\n ;float center=sqrt(lengthBary(oo-uu,l))//vector (oo-uu) length from barycentric vector\n ;c.w=min(c.w,abs(center-radius))//;c.w=min(c.w,abs(length(u-p3)-radius))\n //;c.w=min(h,ray(u,p3,p4)-.01)\n ;vec3 os=sat(floor(oo+1.))\n ;vec3 ts=sat(floor(tt+1.))//sat is needed for scale (large distances to the triangle are cheap)\n ;float ooo=suv(os)\n ;float ttt=suv(ts)//sum of vector components now points at 7 different segments:\n     //1* insideTriangle\n     //3* largeBorderTile(adjacent) \n     //3* cornerBorder   (only touches triangle corners) \n ;vec3 linesToCheck=vec3(0)\n ;if(ooo==2.//case 2: origin is in largeBorderTile\n ){if(ttt<2.&&os!=1.-ts)linesToCheck=vec3(0)\n  ;else{linesToCheck=getPosSmallV(os)//this one is simple, either misses all, or hits only one.\n      //nope nope nope,(vs) doesnt ALWAYS work HERE: \n      //but sure, there are other ways to do this, removed for now\n ;}}else if(ooo==1.){//case 1: origin is in cornerBorder\n  ;if(ttt<2.&&os!=ts)linesToCheck=vec3(0)//only the other 2 outer corners miss the triangle\n  ;else if(ttt==2.&&os!=1.-ts)linesToCheck=getPosSmallV(ts)//from cornerBorder to ADJACENT largeBorderTile, has 1 border\n      ;else{linesToCheck=1.-getPosLargeV(os);\n      ;if(1.-getPosLargeV(vs)!=linesToCheck)linesToCheck=vec3(0.)\n ;}}else //if(os==vec3(1) )//case 0: origin is in insideTriangle\n  {if(ttt==2.)linesToCheck=getPosSmallV(ts) //target is in any largeBorderTile /single border)\n  ;else linesToCheck=1.-getPosSmallV(vs)\n ;}  \n ;if(linesToCheck.x>0.)c.y=min(c.y,segment(u,p1,p2)-.04)//indicating segments that are hit.\n ;if(linesToCheck.y>0.)c.y=min(c.y,segment(u,p2,p0)-.04)//indicating segments that are hit.\n ;if(linesToCheck.z>0.)c.y=min(c.y,segment(u,p1,p0)-.04)//indicating segments that are hit.\n\n //the faces that are still in may only return the NEAR intersection.\n //there is no case where there is a far intersection, the firt positive intersection can be returned as nearest.\n //i have not implemented a function that takes (linesToCheck), to trace this triangle/prism.   \n //on tracing a triangle/prism efficiently.\n //triangles imply barycentric coordinates, converters exist, but they are not too fast, and should be avoided.\n //just start in barycentric coordinates\n     //how about one moore domain, doing a 3d simplex (skewable triangle pyramid)\n\n //below code is from its canvas source function\n //;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;//m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;//c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;return c;}\n\n//rotation of multiple inputs of same type for tpyes; vec4,vec3,vec2,float\n//rotate2by1(a,b) is a tripple swap\n#define rot2by1D(D) void rotate2by1(inout D a,inout D b){D s=a;a=b;b=s;}\n#define rot3by1D(D) void rotate3by1(inout D a,inout D b,inout D c){D s=a;a=b;b=c;c=s;}\n#define rot6by1D(D) void rotate6by1(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){D s=a;a=b;b=c;c=d;d=e;e=f;f=s;}\n#define rot4by2D(D) void rotate4by2(inout D a,inout D b,inout D c,inout D d                    ){rotate2by1(a,c  );rotate2by1(b,d  );}\n#define rot6by2D(D) void rotate6by2(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate3by1(a,c,e);rotate3by1(b,d,f);}\n#define rot6by3D(D) void rotate6by3(inout D a,inout D b,inout D c,inout D d,inout D e,inout D f){rotate2by1(a,d);rotate2by1(b,e);rotate2by1(c,f);}\n#define rotND(a) a(v0)a(v1)a(v2)a(v3)\nrotND(rot2by1D)rotND(rot3by1D)rotND(rot6by1D)\nrotND(rot4by2D)rotND(rot6by2D)\nrotND(rot6by3D) \n\n#define hxl0(a,b) z=gLLxXP(a,b,o,t);if(sat(z)==z)return a-(a-b)*z\n#define hxl1(a,b) return a-(a-b)*gLLxXP(a,b,o,t)\n#define hxl2(a,b,c) float hxl0(a,b);hxl1(b,c)\n#define hxl3(a,b,c,d) float hxl0(a,b);hxl0(b,c);hxl1(d,c)\n    \nvec2 hxL1(vec3 a,vec3 b,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y)\n ,b.xy=b2c(b,X,Y)\n ;return a.xy-(a.xy-b.xy)*gLLxXP(a.xy,b.xy,o,t);}\n\nvec2 hxL2(vec3 a,vec3 b,vec3 c,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;return b.xy-(b.xy-c.xy)*gLLxXP(b.xy,c.xy,o,t);}\n\nvec2 hxL3(vec3 a,vec3 b,vec3 c,vec3 d,vec2 o,vec2 t,vec3 X,vec3 Y\n){a.xy=b2c(a,X,Y),b.xy=b2c(b,X,Y)\n ;a.z=gLLxXP(a.xy,b.xy,o,t)\n ;if(sat(a.z)==a.z)return a.xy-(a.xy-b.xy)*a.z\n ;c.xy=b2c(c,X,Y)\n ;a.z=gLLxXP(b.xy,c.xy,o,t)\n ;if(sat(a.z)==a.z)return b.xy-(b.xy-c.xy)*a.z\n ;d.xy=b2c(d,X,Y)\n ;return c.xy-(c.xy-d.xy)*gLLxXP(c.xy,d.xy,o,t);}\n\n//X,Y set triangle of barycentric\n//all other params are in barycentric coords\n//origin,target,6CornersOfHex\nvec3  traceHexBaryInside(vec3 uu,vec3 oo,vec3 tt,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){vec2 o=b2c(oo,X,Y)\n ;vec2 t=b2c(tt,X,Y)\n ;vec2 p1=b2c(b1,X,Y)\n ;//vec2 p2=b2c(b2,X,Y)\n ;vec2 p3=b2c(b3,X,Y)\n ;vec2 p4=b2c(b4,X,Y)\n ;vec2 p5=b2c(b5,X,Y)\n ;vec2 p6=b2c(b6,X,Y)\n ;//return sat(floor(uu+1.)) //main triangle is white\n ;//r ia a vec4 with 1 of each color set to >0 foreach linesegment to test\n ;vec4 r=vec4(0)\n ;//uu=tt //for debug mode toggle\n //barycentric culling hell\n ;//if(uu.y<uu.z)uu.yz=uu.zy //mirror\n     \n ;if(\n     getPosSmall(floor(oo-tt))==2\n     //sign(oo.x)==sign(tt.x)\n    \n    )uu.yz=uu.zy\n ;if(uu.x<0.)r.x=1.\n ;if(uu.z>0.)r.x=1.\n ;if(uu.z<=0.&&uu.x<=1.)r.y=1.//right shade\n ;if(uu.x>0.){ \n  ;if(uu.x<1.)r.y=1.//horizontal\n  ;if(uu.y>1.)r.y=1.//right shade\n  ;if(uu.y>0.&&uu.y<1.)r.z=1.\n  ;if(uu.y<0.)r.w=1.\n  ;if(uu.z>uu.y-1.&&uu.z<uu.y+1.)r.w=1.\n  ;if(uu.x>1.&&uu.z<uu.y-1.)r.z=1.\n ;} \n ;return 1.-r.xyz //debug output a\n ;//return r.yzw //debug output a\n  ;//r=r.wxyz\n  ;float s=suv(r)     \n\n           /*\n  ;if(s==4.//if in main triangle, we have this small exclusion method\n \n  ){vec3 vs=getPos0V(floor(tt-oo))\n   ;//return vs\n       //.x points up   OR to the bottom corner\n       //.y boints side\n       //.z points down\n    //;r=vec4(0,0,0,1)\n    //;return hxL2(b3,b4,b5,o,t,X,Y).xyy\n    /*\n    ;if(vs.x==1.){\n        ;//return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n        ;                    r=vec4(1,1,0,0)\n        ;}\n   else if(vs.y==1.)return hxL3(b2b3,b4,b5,o,t,X,Y).xyy \n   ;else return hxL3(b3,b4,b5,b6,o,t,X,Y).xyy\n   ;s=suv(r) \n  ;}\n/**/\n\n ;if(s==3.//test 3\n ){if(r.x==1.)return hxL3(b2,b1,b6,b5,o,t,X,Y).xyy//1110\n  ;           return hxL3(b1,b6,b5,b4,o,t,X,Y).xyy//0111\n ;}else if(s==2.//test 2\n ){if(r.x==1.)return hxL2(b2,b1,b6,o,t,X,Y).xyy//1100 b2,b1,b6\n  ;if(r.y==1.)return hxL2(b1,b6,b5,o,t,X,Y).xyy//0110 b1,b6,b5\n  ;           return hxL2(b6,b5,b4,o,t,X,Y).xyy//0011 b6,b5,b4\n ;}////test 1 \n ;s=suv(r.xy)\n ;if(s==1.\n ){if(r.x==1.)return hxL1(b2,b1,o,t,X,Y).xyy  //1000==b2,b1\n  ;           return hxL1(b1,b6,o,t,X,Y).xyy;}//0100==b1,b6\n ; if(r.z==1.)return hxL1(b6,b5,o,t,X,Y).xyy  //0010==b4,b5\n ;            return hxL1(b5,b4,o,t,X,Y).xyy;}//0001==b5,b4\n\n\nvec2 traceHexBaryOutside(vec3 o,vec3 t,vec3 b1,vec3 b2,vec3 b3,vec3 b4,vec3 b5,vec3 b6,vec3 X,vec3 Y\n){return b2c(b1,X,Y)+vec2(.1)\n ;return vec2(.1,0);}\n\n//innerFrustrum() returns cakeslices, that cut trought (o) and all hex corners\n//no undefined cases via kerning-frustrums\nbool innF(vec2 u,vec2 o){return u.y*suv(o)>o.y*suv(u);}\nbool innS(vec2 u,vec2 o,vec2 a,vec2 b){return innF(u+a,o+a)||innF(o+b,u+b);}\nvec3 innerFrustrum(vec2 u,vec2 o//inputs are .yz of carthesian points\n){return vec3(ivec3(innS(u,o,vec2(0,-1),vec2( 0,1))\n                   ,innS(u,o,vec2(1, 0),vec2(-1,0))\n                  ,!innS(u,o,vec2(1,-1),vec2(-1,1))));}\n//110 top    center\n//010 top    right\n//011 bottom right\n//001 bottom center\n\n//return intersection of ray(ot) and barycentricHex (p0,p1,p2) (p0 is hex center)\nvec4 paintHexBary(vec2 u,vec2 o,vec2 t,vec2 p0,vec2 p1,vec2 p2\n){float cd=c2bdet(p0,p1,p2)\n ;vec4 c=vec4(1)     \n ;vec2 pro=p1-p0\n ;vec2 prt=p2-p0\n ;vec2 p3=p2-pro\n ;vec2 p4=p0-pro\n ;vec2 p5=p0-prt\n ;vec2 p6=p1-prt\n\n  //corners in barycentric (makes skew and flip simpler\n ;vec3 b0=vec3(1,0,0)\n ,b1=vec3(0,1,0)\n ,b2=vec3(0,0,1)\n ,b3=vec3(1,-1,1)\n ,b4=vec3(2,-1,0)\n ,b5=vec3(2,0,-1)\n ,b6=vec3(1,1,-1)\n     \n ;vec3 uu=c2b(u,p0,p1,p2,cd)//only for visualization\n ;vec3 oo=c2b(o,p0,p1,p2,cd)\n ;vec3 tt=c2b(t,p0,p1,p2,cd)\n ;float rotations=0.\n ;if(oo.x>1.){rotations=3.  //half rotation\n  ;uu=r36bary(uu-vec3(1,-1,0))\n  ;oo=r36bary(oo-vec3(1,-1,0))\n  ;tt=r36bary(tt-vec3(1,-1,0))\n ;}if(oo.y<0.){rotations++ //sixt rotation //rotate corner points by +1\n  ;uu=r16bary(uu-vec3(1,-1,0))\n  ;oo=r16bary(oo-vec3(1,-1,0))\n  ;tt=r16bary(tt-vec3(1,-1,0))\n ;}else if(oo.z<0.){rotations-- //negative sixt rotation //rotate corner points by -1\n  ;uu=r56bary(uu-vec3(0,1,-1))\n  ;oo=r56bary(oo-vec3(0,1,-1))\n  ;tt=r56bary(tt-vec3(0,1,-1));}//rotations range[-1..4]\n         \n ;if(rotations==-1.) rotate6by1(p6,p5,p4,p3,p2,p1)//reversed\n ;if(rotations== 4.) rotate6by2(p6,p5,p4,p3,p2,p1)//reversed \n ;if(rotations== 3.) rotate6by3(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 2.) rotate6by2(p1,p2,p3,p4,p5,p6)\n ;if(rotations== 1.) rotate6by1(p1,p2,p3,p4,p5,p6)\n //;if(rotations==1.||rotations==3.||rotations==-1.){\n     //half of all cases are skewed the other way\n     //instead of flipping our shit, we just do pur pN in barycentric coordinates\n //;}\n ;vec3 vs=c2b(o,p0,p1,p2,cd)\n ;vec3 center=sat((floor(uu+vec3(0,1,1))))\n\n ;c.y=min(c.y,ray(u,o,t)-.005)//green ray\n ;c.y=min(c.y,abs(segment(u,o,t)-.02))//green ray segment\n\n //;o=b2c(oo,p0,p1,p2)\n //;t=b2c(tt,p0,p1,p2)\n\n ;float bariOdet=c2bdet(o,p1,p2)//triangle with o instead of p0\n ;vec3 baryO=c2b(t,o,p1,p2,bariOdet)//triangles bariOcentric coords\n ;vec2 sect=intersectB2c(o,t,p1,p2)\n     \n //;vec2 sect=p1-(p1-p2)*tt.z/(tt.z+tt.y)//projection of o on outer border (from center)\n     //;vec2 sect=(oo.z*(tt.z+tt.y)-tt.z*(oo.z+oo.y))\n ;//c.y=uu.z*(oo.z+oo.y)-oo.z*(uu.z+uu.y) // iahas a line from corner to point\n      \n ;//return mix(c,floor(1.-vec4(frustrumX,frustrumY,frustrumZ,0)),.5)\n     \n ;//c.y=min(c.y,abs(sqrt(dd(u-sect))-.02))//intersection fail\n  \n;if(tt.z*(oo.z+oo.y)>oo.z*(tt.z+tt.y) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.z*(oo.z+oo.x)>oo.z*(tt.z+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n//;if(tt.y*(oo.y+oo.x)>oo.y*(tt.y+tt.x) //oh great its 2 ratios, and dividents flip sdes so its only mults\n\n //tt.y>oo.y//tt.z>tt.y//mirror symmetry on the whole thing\n ){uu.zy=uu.yz\n  ;oo.zy=oo.yz\n  ;tt.zy=tt.yz\n  ;rotate6by3(p1,p3,p5,p2,p6,p4)//strided half rotation == mirror\n  ;\n  ;}  \n/**/\n     \n  ;//projecting 2 points onto the axis is warely worth it\n  ;//, only where we have 2 caes to check and within some other constrrains\n  ;//p2=p1+(p2-p1)*.5\n  ;//p4=p5+(p4-p5)*.5\n     \n ;c.z=min(c.z,abs(length(u-p0)-.03))\n ;c.z=min(c.z,abs(length(u-p1)-.05))//blue circles\n ;c.z=min(c.z,abs(length(u-p2)-.07))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p3)-.08))//to distinguish inputs (handedness)\n ;c.z=min(c.z,abs(length(u-p4)-.09))//to distinguish inputs (handedness)\n ;c.w=min(c.w,abs(length(u-p5)-.09 ))//to distinguish inputs (handedness)\n     \n ;vec3 X=vec3(p0.x,p1.x,p2.x)\n ;vec3 Y=vec3(p0.y,p1.y,p2.y)\n ;p1=b2c(b1,X,Y)    \n ;p2=b2c(b2,X,Y)    \n ;p3=b2c(b3,X,Y)   \n ;p4=b2c(b4,X,Y)  \n ;p5=b2c(b5,X,Y)  \n ;p6=b2c(b6,X,Y)  //testing bN \n ;c.x=min(c.x,segment(u,p2,p1))\n ;c.x=min(c.x,segment(u,p3,p2))\n ;c.x=min(c.x,segment(u,p4,p3))\n ;c.x=min(c.x,segment(u,p5,p4))\n ;c.x=min(c.x,segment(u,p6,p5))\n ;c.x=min(c.x,segment(u,p1,p6))//red hexagon\n ;c.z=min(c.z,segment(u,p0,p1))\n ;c.z=min(c.z,segment(u,p0,p2))\n ;c.z=min(c.z,segment(u,p1,p2))//blue triangle (indicates pieslice or (o)\n     \n\n     \n ;//all mirroring and showing of it is done; \n ;//all casting pout of the target is done\n     \n ;float outU=min(floor(mav(abs(vec3(1,0,0)-uu))),1.)\n ;float outO=min(floor(mav(abs(vec3(1,0,0)-oo))),1.)\n     \n\n ;vec2 intersection=vec2(0)\n ;//if(outO>0.)intersection=traceHexBaryOutside(oo,tt,b1,b2,b3,b4,b5,b6,X,Y)\n ;//else       intersection=traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y).xy\n    \n \n ;c.w=min(c.w,abs(abs(length(u-intersection)-.03)-.01))//mark intersections\n \n ;c=smoothstep(.01,-.01,c)-.01\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n\n ;vec3 cake=(floor(uu)+vec3(0,1,1))\n ;cake=sat(floor(cake))\n ;//c.xyz=cake\n ;//if(cake.x>0.&&cake.y>0.)c.xyz=cake\n ;//if(cake.x>0.&&cake.y==0.)c.xyz=cake\n ;//c.xyz=mix(c.xyz,sat(cake-vec3(outU*.7)),.5)//inside\n  \n ;//c.xyz+=sat(floor(uu+1.))//upper triangle is white\n ;//c.xyz+=suv(sat(floor(uu+1.)))*.33//upper triangle is white 4sect\n                   /*\n ;//c.xyz+=sat(floor(uu+vec3(-1,1,1)))*.4 //opposing triangle is black\n ;//c.xyz+=suv(sat(floor(uu+vec3(-1,1,1))))*.5//opposing trianggle 4sected\n ;//c.xyz+=sat(floor(uu+1.))*.4 //upper triangle is white\n ;float sect4low=suv(sat(floor(uu+vec3(-1,1,1))))\n ;//float alowerT=suv(sat(floor(uu+vec3(-1,1,1))))\n  //;c*=alowerT  \n ;float uIsInside=mav(abs(uu-vec3(1,0,0)))\n ;float aa=suv(sat(floor(uu+vec3(0,1,1))))\n ;float needsPush=float(aa<1.||uIsInside>1.)//bool(inT))\n   /**/\n ;//float isSimple=float(suv(sat(floor(uu+vec3(-1,1,1))))==0.||mav(abs(uu-vec3(1,0,0)))>1.)//bool(inT))\n ;//c.xyz=mix(c.xyz,vec3(isSimple),.5)  \n     /**/\n ;//branching case wether oo is outside or inside \n  \n ;//c.xyz=mix(c.xyz,traceHexBaryInside(uu,oo,tt,b1,b2,b3,b4,b5,b6,X,Y),5.)//to debug oo is uu\n ;vec3 fuck=innerFrustrum(uu.yz,oo.yz)\n ;c.xyz=mix(c.xyz,fuck,.5)\n     \n  \n ;return c;}\n\nbvec3 getFustrumTri(vec3 tt,vec3 oo\n){bvec3 i=bvec3(false)//3 fustrums over 3 lineSegments, each in 2 signs.\n ;if(sign(oo.x)<0.)i.x=innS(tt.yz,oo.yz,vec2(0,-1),vec2(-1,0))     \n ;else             i.x=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,-1))\n ;if(sign(oo.y)<0.)i.y=innS(tt.yz,oo.yz,vec2(0,0),vec2(0,-1))  \n ;else             i.y=innS(tt.yz,oo.yz,vec2(0,-1),vec2(0,0))\n ;if(sign(oo.z)<0.)i.z=innS(tt.yz,oo.yz,vec2(-1,0),vec2(0,0))       \n ;else             i.z=innS(tt.yz,oo.yz,vec2(0,0),vec2(-1,0))\n ;return not(i);}\n\n\n//baryTriangleOLD() was a naive version (worse culling, only dies zNear)\n//baryTriangleOLD() can still be useful? (though it does extra divisions)\n//nah, looking closer into it, this fustrum solution seems most elegant\n//:\n//does 1 division for baricentric determinant (just like baryTriangleOLD())\n//each inB2c2N() is 1 division, BUT only iff there is an intersection\n//it also cheaply checks is there are 1 or 2 intersections in total.\nvec3 traceTriangle(vec2 u,vec2 o,vec2 t,vec2 a,vec2 b,vec2 c\n){vec4 r=vec4(1)\n ;r.x=min(r.x,segment(u,a,b))//red triangle border\n ;r.x=min(r.x,segment(u,b,c))//red triangle border\n ;r.x=min(r.x,segment(u,c,a))//red triangle border\n ;r.y=min(r.y,ray(u,o,t))//show ray and triangle\n ;float det=c2bdet(transp23)//by using det() we only need 1 division for all ctb(*,abc))\n ;vec3 uu=c2b(u,a,b,c,det)//+0 division (det variant) //uu is only for visualization\n ;vec3 oo=c2b(o,a,b,c,det)//+0 division (det variant)\n ;vec3 tt=c2b(t,a,b,c,det)//+0 division (det variant)\n ;bvec3 i=getFustrumTri(tt,oo)//+1 div, small branching tree\n ;if(!any(lessThan(oo,vec3(0)))//o is in triangle ->one intersection, zNear is o\n ){vec2 hit=vec2(0)\n  ;     if(i.x)hit=inB2c2N(o,t,c,b)\n  ;else if(i.y)hit=inB2c2N(o,t,c,a)\n  ;else        hit=inB2c2N(o,t,a,b)\n  ;r.w=min(r.w,segment(u,o,hit)-.01)//visualize      intersections\n  ;r.w=min(r.w,segment(u,o,o)-.03)  //visualize near intersection (origin)\n ;}else{//we miss all OR [12] segments\n  ;vec2 hit0=vec2(0),hit1=vec2(0)     \n  ;if(suv(vec3(i))<2.){hit0=o;hit1=o\n ;}else if(!i.x){hit0=inB2c2N(o,t,a,b);hit1=inB2c2N(o,t,c,a);if(oo.y<0.)rotate2by1(hit0,hit1)//rotate2by1()==strided swap/rotation library\n ;}else if(!i.y){hit0=inB2c2N(o,t,c,b);hit1=inB2c2N(o,t,a,b);if(oo.z<0.)rotate2by1(hit0,hit1)\n ;}else         {hit0=inB2c2N(o,t,c,a);hit1=inB2c2N(o,t,c,b);if(oo.x<0.)rotate2by1(hit0,hit1)\n ;}r.w=min(r.w,segment(u,hit0,hit1)-.01);//visualize     intersections\n  ;r.w=min(r.w,segment(u,hit0,hit0)-.03);//visualize far intersection\n ;}\n ;//compose visualizations\n ;r=smoothstep(.005,-.005,r)-.01 //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;r=pdOver(pdOver(v3(1,0,0,1)*r.x,v3(0,1,0,1)*r.y)\n          ,pdOver(v3(0,0,1,1)*r.z,v3(1,1,0,1)*r.w))\n ;r.xyz+=vec3(i)*.3\n //below visualizates fustrums\n ;i=getFustrumTri(uu,oo)\n ;r.xyz+=vec3(i)*.3\n ;return r.xyz;}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;v1 p3\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;//c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n ;v1 p4\n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;//c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,vec2(0),vec2(0))\n\n ;c.y=1.\n ;c.z=1.\n   \n\n ;//c=baryTriangle(t,u,r,m,p3,p4,p0,p1,p2,c) //trace triangle barycentric\n ;//vec2 p=TraceHexInsideBary(u,p3,p4,p0,p1,p2)\n ;//c.y=min(c.y,segment(u,p,p)-.05)\n \n\n  \n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;vec3 j=vec3(fract(abs(p1.x*2.)),1./7.,1./6.)\n \n ;//c=paintHexBary(u,p3,p4,p0,p1,p2)\n \n     /*\n ;u*=3.\n ;p4*=4.\n ;p4.y=-p4.y\n ;p2*=2.\n ;//p3*=sign(-p4)\n  ;if(mav(abs(u))<.75){\n         ; c.xyz+=.5*(simplexRotD(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   ;//c.y  +=.5*(simplexRot(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   //above 2 have periodic tiling.xy, below not:\n   ;//c.xyz+=.5*((simplexRotD(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n   ;//c.y  +=.5*((simplexRot(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n }else if(u.x<0.\n ){vec2 cel\n  ;if(u.y>0.)cel=cellular(     u/p3.xy      +     p4.xy      ,j)\n  ;else      cel=cellular(vec3(u/p3.xy,p2.x)+vec3(p4.xy,p2.y),j) \n  ;//c.x=snoise(u/p3.xy*2.+p4.xy*9.)*.5+.5;\n  ;c.xy+=cel.xy*.6\n ;}else{\n  ;if(u.y>0.\n  ){     c.y+=.6*(snoise(     u/p3.xy+p4           )*.5+.5)\n  ;}else c.y+=.6*(snoise(vec3(u/p3.xy+p4,p2.x+p2.y))*.5+.5)\n\n ;}/**/\n ;c.xyz=traceTriangle(u,p3,p4,p0,p1,p2)\n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point (p0) on line (l0,l1)\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n     //fuck it erased a line here, dumb UI\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n /*\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=demoProject(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;//o=sat(o)*/\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n\n//below code is: RE7 [[BayesianEpsilon targetFPS] [Image]]\n//iRe refers to the ichannel buffer locale of [relativistic camera movement]\n//the type of camera mkovement where [time slows down, reciprocal to the speed of light].\n//that is, reaching the speed of light is impossible, because that halts the speed of time.\n//and any 2 observers with no relative movement hate time between them pass with the speedOfLight.\n\n#define iRe iChannel2\n\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float i){return GetMaterialsColor(r,int(i));}\n\n//lod,ray,start,zFar\nvoid MarchLight(float sscoc,inout Ray r, float startTime, float f//relkativistic raymarcher\n){float acc = 0.\n ;float eps=getEpsToFps(sscoc)\n ;float lip=getReLipschitzToFps(sscoc)\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist=map(r.b,-1)\n  ;acc+=r.dist*lip\n  ;r.b+=r.dir*(r.dist)\n  ;if(abs(r.dist)<eps||acc>f)break;}}\n\nvoid MarchPOV(inout Ray r, float startTime,float sscoc\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])\n  //;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  // t' = Y(t-v*(x/Y)/c²)\n  // t' = Y(0-v*(x/Y)/c²)\n  // t' = Y(v*x/Y)/c²\n  // t' = vx/c²\n  ;r.time = startTime\n  ;r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection=(objPos[oBlackHole]-r.b)\n  ;r.dir+=(1./RayPrecision)*r.dist*reciprocalLipschitz\n      *normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<getEpsToFps(sscoc))break\n  ;r.b+= (1./RayPrecision)*(r.dist)*reciprocalLipschitz*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\n\nvec3 accHalo(vec3 oliPos,vec3 lightRelVel,float halo,vec3 lightColor){\n  ;vec3 camLightDir=normalize(oliPos-pos)\n  ;float cds=dot(camLightDir,dpos)//camDirCamSpeed \n  ;float cdl=dot(camLightDir,lightRelVel)//camDirLightSpeed\n  ;return halo*dsf(lightColor,(cSpe/(cSpe\n                      \n                                         \n     -(cds-cdl)/(1.-(cds*cdl/(cSpe*cSpe)))//haloRel\n                                         *dopplerF))*lorentzF)\n;}\n\nvec3 GetDiffuse(float sscoc, Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;//if(mat==8.)return vec3(0)//black holes are just black\n ;vec3 objVel=objVel[rayObj]\n ;vec3 lHalo =vec3(0)\n ;float[numLights] halos\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0;i<10;i++\n  ){lightLate=cLag*length(oliPos[L]-r.b)/cSpe;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos=          oliPos[L]-r.b\n  ;ProcessLightValue(r.time-lightLate+.01)\n  ;vec3  lightVel   =((oliPos[L]-r.b)-lightRelPos)/.01\n  ;vec3  lightRelVel=lightVel-objVel\n  ;float lightLorentzF   =LorentzFactor(length(lightVel))\n  ;vec3 lightDir   =normalize(lightRelPos)\n  ;vec3 camDir     =normalize(pos-r.b)\n  ;vec3 camRelVel  =dpos-objVel\n  //;float halo            =halos[L]\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   #define basicBug \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif    \n  #endif\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(sscoc,shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4\n  #ifdef redshiftdT\n  ;SetTime(r.time)\n  ;float speed=map(r.b,int(mat))\n  ;SetTime(r.time+.01)//1/100 time delta\n  ;speed-=map(r.b,int(mat))//now is propper differential\n  ;speed*=100.//scale by 100\n  //blackholes are tinted in Re0 wven without this bracket.\n  #else\n  ;float speed=0.\n  #endif\n  ;//speed += LorentzFactor(cSpe)//commented out in the original\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;vec3 lightColor =          oliCol[L].rgb \n  ;lorentzF/=mix(lorentzF,lightLorentzF,relativisticDoppler)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;cDiff+=     dsf(lightColor*matCol*atten,(cSpe/(cSpe-speed  *dopplerF))*lorentzF)\n  ;if(mat==8.)lHalo+=halos[L]//black holes suck upp all ambient and skipp dopplerShoift\n  ;else       lHalo+=accHalo(oliPos[L],lightRelVel,halos[L],lightColor)\n  ;}\n  ;if(mat==8.)return lHalo+vma2\n  ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n\nvec3 GetSampleColor(float sscoc,vec2 uv\n){Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]\n ;r.dir = qr(objRot[oCam],r.dir)\n ;MarchPOV(r,playerTime,sscoc)\n ;return GetDiffuse(sscoc,r);}\n\nvec4 mainImageRe8(vec4 o, in vec2 u\n){//vec2 u=fra(uv,iResolution)//(uv/iResolution.xy+.5)/iResolution.y\n ;float sscoc=length(u/iResolution.xy-.5) //length(u/iResolution.xy*+.5)/sqrt(2.)\n ;sscoc=smoothstep(.75,0.,sscoc)//full btight in the center, pitch black at the cotner, oval\n ;vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;float edit=Get(ReEdit).x\n ;if(edit>0.//if in edit mode\n ){if(length(abs(v)-.5)-.02<0.)return vec4(1)//circles filled\n ;}\n ;vec4 timE=Get(ReTimE)\n ;if(timE.w<0.&&abs(length(abs(v)-.5)-.03)-.003<0.)return vec4(1)//circles rings\n ;\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime=abs(timE.w)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;oCamSet(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(sscoc,v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iRe,u/iResolution.xy).rgba )//debug buffer of iRe\n ;return o;}\n\n/*\nbuffa buffers many params for diegeticUI\nbuffc buffers params for a relativistic camera\n\ni want a 3d UI, but\n- i can only rotate the head while left dragging\n- double klicking may get you out of the canvas\n\n- nomode solution, not good for direct feedback\nonMouseRelease; buffer the objectID of the object where mouse was released\ninKeyPresss: object properties of buffered objectID may change\n\n- editMode\nonKeypress, may toggle to editmode\nin editmode, mouse drag no longer moves camera\n\nonKeypress, may toggle to timeFreezesMode\n\n\ntime freeze and edit mode work in re8, but nothing is being edited\n*/\n\n\n//below is a very basic toggle-wrapper, showing what 2 shaders have been hodgepodged\n//this completes step2, fixing all namespace conflicts. (was easy for once)\n//step 2 is to clean up mainImageRe7() and its subroutines. - done re8()\n//step 3 is trckier\n//all these buffers store properties, an array of vec4 \n//and I need them to evade any conflict between them\n//so I can merge thzem into a single buffer\n//- (lets exclude BufferD for being a screenspace incrementalAveraging buffer)\n\n\n#define Scene2D\n\n//#if 1\nvec4 mainImageUI2AD37(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pDoOver(iAD)  //backdrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n ;return o;}\n/**/\n//#else\n/*\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}*/\n//#endif\n/**/\n\nvec4 spin(vec4 o,vec2 u\n){vec2 v=fra(iTime,u,iResolution,iMouse)\n ;o=vec4(0)\n   \n    \n ;//o=pdOver(iDiegeticUIshow(u),o)//ui dots\n ;//o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n ;v*=rot2D(u5(cos(iTime/9.)*99.))\n ;if(v.x>0.){if(v.y>.0){\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;//o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n   ;return o;\n   ;}\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n  ;//o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  ;return o\n  ;}\n ;if(v.y>0.){\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d drawing\n  ;return o\n ;}\n ;return o\n //;return mainImageRe8(o,u)\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){\n /*vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;//o=mainImage2(o,i)\n     ;return;//number overlay\n ;}*/\n \n //;o=spin(o,u)\n    \n #if 1\n ;o=mainImageUI2AD37(o,u)\n #else\n ;o=mainImageRe8(o,u)\n #endif\n //;o=(texture(iRe,u/iResolution.xy).rgba );\n/**/\n ;}\n\n\n/*\nI like my code modular, evading namespace conflicts, while having short namespaces.\nI heavily advocate for compatibility, performance and diegetic UI.\nIO see this ignored too often\nThe acronym \"ReTrAdUi\" makes fun of bad UI design, namespaces and typos.\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n#define phi (sqrt(5.)*.5+.5)\n\n#define tiny .00001\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n//#define u2(a) su(mu(a,2.), 1.)\n#define u3(a) su(mu(a,2.),-1.)\n//#define u5(a) su(mu(a,.5),.5)\n#define u5cos(a) (u5(cos(a))\n//below is needed for old code, that i failed to update so that su() and mu() work on the right inpout types.\n#define u5cos2(a) ((cos(a))*.5+.5)\n//#define cosu5(a) u5(co(a))\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n\n/**///--start: iDiegeticUI v2:\n/*\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n/**/\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a) (-(miv(-(a))))\nconst vec3 vs=vec3(-1,0,1);\nv1 perp(v1 a){return a.yx*vs.xz;}\nv1 perp2(v1 a,v1 b){return vec2(a.x*b.y,-a.y*b.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\nv0 perpdot(v1 a,v1 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//v0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n\n/*\nrelativistic engine, with mutable/slower speedOfLight\n\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\n\nDoes not simulate doppler correctly\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- objects changing in size may not doppler its light bounces correctly?\n\nblatantly false shadows&gravity\n- no gravity by object masses (camera does not orbit)\n- shadows are unaffected by mass (except for black hole)\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow?\n- object rotations may result in faster than light speeds of object vertex?\n\n\n/**/\n\n\n/**///--start: RelativityEngineParams\n\n//ESDF keyboard layout is tmore compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//above for movement\n//below toggles pausing of time\n#define KEY_T 84.5\n//below toggles grabEdit mode (mouse no longer rotates camera)\n#define KEY_G 71.5\n\n//fishEyeCam sucks\n#define fishEye false\n//FieldOfView 1.57 = 90deg\n#define FOV 1.57\n//take relative velocity of photons to camera & distort field of view\n#define FOVAberrationOfLight 1.\n\n//SpeedOfLight in m/s divides by /(cSpe*cSpe), so do not make it too large!\n#define cSpe 2.5\n//do not go over speed of light it breaks time & space\n#define maxSpeed (cSpe*2.2/2.5)\n//camera acceleration =24.\n#define thrustForce (cSpe*5./2.5)\n//known bug, bouncing off something too easily accellerates you faster than light\n//iff the speed of light is high\n//for no good reason, any bounce accellerates me without constrain\n\n//PhotonLatency [0..1]; 0.=instant vision\n#define cLag 1.\n//simultaneouity==1 to pretend that simultaneouity exists\n//Then you could see the future in front of you at high speeds.\n//r.time += mix(simultaneouity*dDirDpos*camDist/(cSpe*cSpe),-camDist*cLag/cSpe,cLag)\n#define simultaneouity 1.\n\n//take player/object/light vel to shift color\n#define dopplerF .5\n//take light source speed into account and their own time dilation\n#define relativisticDoppler .2\n//shrink map along velocity vector at high speed\n#define LgthContraction  1.\n//speed map frame time at high speed\n#define TimeDilation 1.\n\n//do +1 FAST (objectID-filtered) march measure how much a hit surface moves towards camera\n//important for realistic redshift, but only adffects diffuse.\n#define redshiftdT\n//higher rayprecision makes glow more bloomy, WHYYY\n#define RayPrecision 1.\n//repeatDoppler==1 seems nonsensical (just tints all in pink)\n#define repeatDoppler 0\n\n#define MaxRayDist 9.0\n\n//set by world\n#define numMats 7\n\n//black hole mass \n#define BlackHoleMassFactor 2.\n//.*cSpe)\n#define AccretionDisk 2.\n\n#define gravity vec3(0.,0.,0.)\n//end of relativity params\n\n/**///--end__: RelativityEngineParams\n\n//do not modify:\n#define pi acos(-1.)\n#define vec1 float\n#define u5(a) ((a)*.5+.5)\n#define u2(a) ((a)*2.-1.)\n\n//#define fra(u,r) (u-.5*r.xy) /r.y\n\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos  = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n/**///--end__: iDiegeticUI v2:\n/**///--\n/**///--start: iChannel-Buffer-pattern\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**///--end__: iChannel-Buffer-pattern\n/**///--\n/**///--start: compatibilityCore \n\n\n/*\ntodo, all the trigonometry functions with glES100 to gles300 porting\nseems to be prettyx fine\n*/\n\n\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\n\n\n//every 2d determinant has a perpendicular dotproduct\n\n//nul function is needed for cases, where the same function is defined 2 times\n//eg: once with sat and once without sat (with nul instead of with sat) => difference between segment() and line()\n#define nUl(b) b nul(b a){return a;}\nnUl(v0)\nnUl(v1)\nnUl(v2)\nnUl(v3)\n    \n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\n\n/**///--end__: compatibilityCore\n/**///--\n/**///--start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created #.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**///--end__: openGl NaN-precision\n/**///--\n/**///--start: AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n\nstruct d(v0 a;);//just use v0 instead of a [d]  struct\nthe whole DA set is pretty consistent, and i tried domain/ds the other way around and that sucked.\nthe first value is a float, because thats what the function returns, a length.\nAND most shapes apply the same functions to a value (no branching, all domains are NOT independent functionWise)\nbut many functions over 2d or 3d should be independent, and can be branching!\n...as a result, the d*** structs are nonsense, and i may need a BIG rewrite.\n\nso, what we may utilize here (to format an UV.xyz to give to any distanceField) is something like:\nc22 da_domain2(v2 p){return c22\n (d22(p.x,v2(1,0,0),v2(1,0,0))\n ,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n ,d22(p.y,v2(0,0,1),v2(0,0,1)));}\n//so the c22 struct first seperates by number of domains, seperating into 3 sub scructs, one foreach domain.\n//each derivative VECTOR has as many domains as the whole struct.\n//i actually wonder, WHY this is not always a type float.\n*/\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00   D00(v2   a){return d00(a.x,a.y,a.z);}\nv2     V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0     D0(v1   a){return d0(a.x,a.y);}\nv1     V1(d00  a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\n//the c* structs are used by the uv inputs, c2 is for 3d, with 1 derivative\n//a distance field is itterated over by: DAMValue s=df(da_domain1(o+i*t))\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt²\nST c000{d000 x                     ;};//1 domains t,dt²dt³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//the weirdness, that the first value is always a float, is based on the output of the function, with a scalar distance\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\n//v2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\n//the da_domain*() functions orhtogonally proiject the derivatives onto an matrix.\n//the inpput point o is spread among as many d*** structs as there are domains.\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.z,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0 da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n\n/**///--end__: AD structure\n/**///--\n/**///--start: AD functions \n\n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\n//AD uses these prexisNotation Namespaces and is defined for these domains):\n//[d0..d333] means, it is defined for up..3 derivatives over up..4 domains (but also any lesser permutation)\n//[c...] are some extended struct special cases (higher dimensional)\n//\n//ne()       0-a ,[d0..d333], also [c0..c333]\n//fl() floor(a  ),[d0..d333]\n//fr() fract(a  ),[d0..d333] <= su(1.,fl(a))==mod(a,1.) //complement..floor()\n//mo()   mod(a,b),[d0..d333] <= su(a,mu(b,fl(di(a,b)))) (true_basis_modulo)\n//si()   sin(a  ),[d0..d333]\n//co()   cos(a  ),[d0..d333]\n//ex()   exp(a  ),[d0..d333] //inverse of log()\n//ln()   log(a  ),[d0..d333]\n//sg()  sign(a  ),[d0..d333]\n//ab()   abs(a  ),[d0..d333],[c2]\n//su()        a-b,[d0..d333],[c0..c3]\n//ad()        a+b,[d0..d333],[c0..c3] <== su(a,ne(b))\n//mu()        a*b,[d0..d333],[c0..c3]\n//di()        a/b,[d0..d333]\n//po()   pow(a,b),[d0..d333] <= ex(mu(ln(x),x))\n//mi()   min(a,b),[d0..d333],[c2]\n//sr()  sqrt(a  ),[d0..d333]\n//p2()   pow(a,2),[d0..d333],[c0..c2] <=mu(a,a)\n//p3()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),a)\n//p4()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),mu(a,a))  //because for AD, mu() recursion is faster than pow(a,b)\n//dt()   dot(a,b),[d0..d333],[c0..c3] <=ad(mu(),mu()...)\n//dd()   dot(a,a),[d0..d333],[c0..c3] <= dt(a,a)\n//sd()  length(a),[d0..d333] <=po(dd(a),1./2.) == sq(dd(a))\n//cd()           , <=po(dd(a),1./3.)\n//qd()           , <=po(dd(a),1./4.)   \n//ud()           , <=po(dd(a),1./5.)\n//ata()          ,[d0..d333]\n//cl()  clamp()               <=mi(ma(a.,0.),1.)\n//st()   sat()                <=clamp(a.,0.,1.)\n//suab()         , [d0..d333] <=ab(sub(a))\n//\n//ab derivatives may be false/naive (3rd derivative is most likely nonsense)\n/**/\n\n//max(a,b)=-min(-a,-b), requires ne()\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n\n//floor(a) is a basis-function for mod() and fract() (all complement each other)\n//calculus on floor() is simpler than on fract() or mod() , so we defien fract() as 1.-floor(), and not as mod(a,1.)\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies automaticDiffernetiation (and it fixes mod())\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to multiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n//mod(a,1.) NEVER returns 1 (its a halfopen interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\nd00 AD(d00 a,v2 o){v0 O=a.c*o.x\n ;return D00(o.xyy*v2(1.,a.b,a.c)\n +v2(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\nv3 siD(v0 a){return v3(si(a),co(a),-si(a),-co(a));}//because derivatives of cin/cos have a periodicity of 4 derivatives,\nv2 siD2(v0 a){return v2(si(a),co(a),-si(a));}      //but we may also want just 2 derivatives (+base)\n\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\nd00 si(d00 a){return AD(a,siD2(a.a));}//sin()dxdxdx\nd00 co(d00 a){return AD(a,siD2(a.a).yzx);}//cos()dxdxdx\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\n\nd11 si(d11 a){d00 Omg(si,x);d00 Omg(si,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 si(d22 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 si(d33 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z);d00 Omg(si,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 si(d111 a){d000 OMg(si,x);d000 OMg(si,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 si(d333 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z);d000 OMg(si,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd11 co(d11 a){d00 Omg(co,x);d00 Omg(co,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 co(d22 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 co(d33 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z);d00 Omg(co,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 co(d111 a){d000 OMg(co,x);d000 OMg(co,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 co(d222 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 co(d333 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z);d000 OMg(co,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//once more a clear sign of my structure extending poorly HERE\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n\n\n//single parameter operations are MUCH simpler here:\n\n//ex(d000) seems to be fine\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n//ex(d00) seems to be fine\nd00  ex(d00  a){return d00 (ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c);}//(tripple) productRule\nd000 ex(d000 a){return d000(ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}//3rd derivative\nd11 ex(d11 a){d00 Omg(ex,x);d00 Omg(ex,y)              ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);d00 Omg(ex,w)\n    ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ln seems to be fine\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd00 ln(d00 a){return d00(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtdt\nd000 ln(d000 a){return d000(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtdt\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))/(a.a*a.a*a.a*a.a)//dtdtdt\n //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() is a special case of di() == one antiderivative higher.\nd1 ln(d1 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));return d1(x.a,v1(x.b,y.b));}\nd2 ln(d2 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z))\n ;return d2(x.a,v2(x.b,y.b,z.b));}\nd3 ln(d3 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z));d0 w=ln(d0(a.a,a.b.z))\n ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd11 ln(d11 a){d00 Omg(ln,x);d00 Omg(ln,y)              ;return d11(x.a,v1(x.b,y.b)    ,v1(x.c,y.c));}\nd22 ln(d22 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ln(d33 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);d00 Omg(ln,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//sg() seems to be fine\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\nd1 sg(d1 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;return d1(x.a,v1(x.b,y.b));}\nd2 sg(d2 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))\n   ;return d2(x.a,v2(x.b,y.b,z.b));}//this one is needed by sdUnterprim()\nd3 sg(d3 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z));d0 w=sg(d0(a.a,a.b.z))\n   ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd11 sg(d11 a){d00 Omg(sg,x);d00 Omg(sg,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 sg(d22 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 sg(d33 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z);d00 Omg(sg,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ab() 3rd derivative seems nonsensical, to check through!\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}//i am a bit suspicious about the derivatives here,not sure if it is THAT simple.\nd11 ab(d11 a){d00 Omg(ab,x);d00 Omg(ab,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ab(d22 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ab(d33 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z);d00 Omg(ab,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nc0   ab(c0   a){return c0  (ab(a.x));}\nc00  ab(c00  a){return c00 (ab(a.x));}\nc000 ab(c000 a){return c000(ab(a.x));}\nc1   ab(c1   a){return c1  (ab(a.x),ab(a.y));}\nc11  ab(c11  a){return c11 (ab(a.x),ab(a.y));}\nc111 ab(c111 a){return c111(ab(a.x),ab(a.y));}\nc2   ab(c2   a){return c2  (ab(a.x),ab(a.y),ab(a.z));}\nc22  ab(c22  a){return c22 (ab(a.x),ab(a.y),ab(a.z));}\nc222 ab(c222 a){return c222(ab(a.x),ab(a.y),ab(a.z));}\nc3   ab(c3   a){return c3  (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc33  ab(c33  a){return c33 (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc333 ab(c333 a){return c333(ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n//su() ad() seem to be fine\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\n#define oMg(f,x) f(d00(a.a,a.b.x,a.c.x),d00(b.a,b.b.x,b.c.x))\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)\nv0 su(v0 a,v0 sux\n//v1 su(v1 a,v0 sux\n//v1 su(v0 a,v1 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\nd00 su(d00 a,d00 b){return d00(a.a-b.a,a.b-b.b,a.c-b.c);}\nd11 su(d11 a,d11 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd22 su(d22 a,d22 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd33 su(d33 a,d33 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z);d00 wa=oMg(su,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd333 su(d333 a,d333 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z);d000 wa=omG(su,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\n      \nd33 su(d33 p,v3 s){return su(p,d33(s.x,v3(0),v3(0)));}\nd22 su(d22 p,v2 s){return su(p,d22(s.x,v2(0),v2(0)));}\nd11 su(d11 p,v1 s){return su(p,d11(s.x,v1(0),v1(0)));}\nd00 su(d00 p,v0 s){return su(p,d00(s  ,v0(0),v0(0)));}//this seems VERY nonsensical, to only store .x\n\nd33 su(d33 p,v0 s){return su(p,d33(s,v3(0),v3(0)));}\nd22 su(d22 p,v0 s){return su(p,d22(s,v2(0),v2(0)));}\nd11 su(d11 p,v0 s){return su(p,d11(s,v1(0),v1(0)));}\n      \n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\n\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd3 mu(d3 a,v0 b){return d3(atb\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nd00  mu(d00  a,d00  b){return d00 (a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b);}//dxdx\nd000 mu(d000 a,d000 b){return d000(a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b//dxdx\n,a.c*b.b+a.b*b.c+a.b*b.c+a.a*b.d+a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c);}//dxdxdx\nd11 mu(d11 a,d11 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mu(d22 a,d22 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mu(d33 a,d33 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z);d00 wa=oMg(mu,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mu(d333 a,d333 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z);d000 wa=omG(mu,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}    \nd00  mu(d00  a,v0 b){return mu(a,d00 (b,0.,0.));}\nd000 mu(d000 a,v0 b){return mu(a,d000(b,0.,0.,0.));}\nd11  mu(d11  a,v0 b){return mu(a,d11 (b,v1(0),v1(0)));}\nd111 mu(d111 a,v0 b){return mu(a,d111(b,v1(0),v1(0),v1(0)));}\nd22  mu(d22  a,v0 b){return mu(a,d22 (b,v2(0),v2(0)));}\nd222 mu(d222 a,v0 b){return mu(a,d222(b,v2(0),v2(0),v2(0)));}\nd33  mu(d33  a,v0 b){return mu(a,d33 (b,v3(0),v3(0)));}\nd333 mu(d333 a,v0 b){return mu(a,d333(b,v3(0),v3(0),v3(0)));}//multiply by constant, needed for sqrt()\nc3 mu(c3 p,v3 s){return c3(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z),mu(p.w,s.w));}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//special utility cases come last\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\n    \n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n\n//di() seems to be fine()\nd00  di(d00  a,d00  b){return d00 (a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a));}//dxdx\nd000 di(d000 a,d000 b){return d000(a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a) //dxdx\n//...\n,((((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a)\n+(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b)\n+(a.b*b.a-a.a*b.b)*(b.b*b.b+b.a*b.c)))*(b.a*b.a*b.a*b.a)\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n*4.*(b.b*b.a*b.a*b.a))/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a));}//dxdxdx //3rd derivative quotient rule sure is something\nd11 di(d11 a,d11 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 di(d22 a,d22 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 di(d33 a,d33 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z);d00 wa=oMg(di,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}                          \nd333 di(d333 a,d333 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z);d000 wa=omG(di,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\nd00  di(d00  a,v0 b){return di(a,d00 (b,0.,0.));}//needed for min()\nd000 di(d000 a,v0 b){return di(a,d000(b,0.,0.,0.));}//needed for min()\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),y))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define ma2(a,b,c) ma(ma(a,b),c)\n#define ma3fffff(a,b,c,d) ma(ma(a,b),ma(c,d))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n//min(x,y) = (x+y-abs(x-y))/2 == di(ad(x,su(y,ab(su(x,y)))),2.)\n//max(x,y) = (x+y+abs(x-y))/2 == di(ad(x,ad(y,ab(su(x,y)))),2.)\nd00  mi(d00  a,d00  b){return di(ad(a,su(b,ab(su(a,b)))),2.);}\nd000 mi(d000 a,d000 b){return di(ad(a,su(b,ab(su(a,b)))),2.);}     \nd11 mi(d11 a,d11 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mi(d22 a,d22 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mi(d33 a,d33 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z);d00 wa=oMg(mi,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mi(d333 a,d333 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z);d000 wa=omG(mi,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n//dot() takes vectors as input, so we take this one differently, dot() is only defined for c1(vec2) c22(vec3) c33(vec4)\n//dot()always returns a d0(float)\n//the function is ad( (ad(mu(),mu()),  ad(mu(),mu()) )\n//the function is ad( (ad(mu(),mu()),     mu()       )\n//the function is      ad(mu(),mu())\n//and multiplied terms are of type v0\n\n//ST c1  {d1   x;d1   y              ;};//2 domains t,dt   \n//ST d1  {v0   a;v1   b              ;};//2 domains t,dt\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n      \n//the c* inputs can be da_domain1(v*) outputs\nd0   dt(c0   a,c0   b){return       mu(a.x,b.x);}//dotproduct in 2d with 1 derivative (is just mu())\nd00  dt(c00  a,c00  b){return       mu(a.x,b.x);}//dotproduct in 2d with 2 derivative\nd000 dt(c000 a,c000 b){return       mu(a.x,b.x);}//dotproduct in 2d with 3 derivative   \nd1   dt(c1   a,c1   b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 1 derivative\nd11  dt(c11  a,c11  b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 2 derivative\nd111 dt(c111 a,c111 b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 3 derivative   \nd2   dt(c2   a,c2   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 1 derivative\nd22  dt(c22  a,c22  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 2 derivative\nd222 dt(c222 a,c222 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 3 derivative\nd3   dt(c3   a,c3   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 1 derivative\nd33  dt(c33  a,c33  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 2 derivative\nd333 dt(c333 a,c333 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 3 derivative\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\n#define dd(a) dt(a,a)\n//explicit dd() dual type (for uberprim)\n#define dd2(a,b) ad(p2(a),p2(b))\n//multi-dd() (muliple lengths at once)\n#define d2d(a,b)    v1(   dd(a),dd(b))\n#define d3d(a,b,c)  v2(d2d(a,b),dd(c))\n#define d4d(a,b,c,d)v3(d2d(a,b),d2d(c,d))\n         \nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\nv0 sr(v0 a){return sqrt(a);}v1 sr(v1 a){return sqrt(a);}v2 sr(v2 a){return sqrt(a);}v3 sr(v3 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\nd3 sr(d3 a){v0 q=sqrt(a.a);return d3(q,.5*rec(q)*a.b);}//first derivative shortcut is near\nd00  sr(d00  a){return ex(mu(ln(a),.5));}//2nd and 3rd derivative i do not bother with.,\nd000 sr(d000 a){return ex(mu(ln(a),.5));}\nd11  sr(d11  a){return ex(mu(ln(a),.5));}\nd111 sr(d111 a){return ex(mu(ln(a),.5));}\nd22  sr(d22  a){return ex(mu(ln(a),.5));}\nd222 sr(d222 a){return ex(mu(ln(a),.5));}\nd33  sr(d33  a){return ex(mu(ln(a),.5));}\nd333 sr(d333 a){return ex(mu(ln(a),.5));}\n\n/**///--end__: AD functions                    \n/**///--\n/**///--start: analysis common subroutines\n\n\n//compare [a] with [0.0] to return [b]==true or [c]==false\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n  #define    more(a,b,c) ((a> 0.)?b:c)\n//#define    more(a,b,c)             mix(a,b,step(c,0.))\n  #define    less(a,b,c) ((a< 0.)?b:c)\n//#define    less(a,b,c)             mix(a,b,step(0.,c))\n  #define   equal(a,b,c) ((a==0.)?b:c)\n//#define   equal(a,b,c)             mix(b,a,step2\n  #define unequal(a,b,c) ((a!=0.)?b:c)\n//#define unequal(a,b,c)             mix(a,b,step2\n  #define  unless(a,b,c) ((a>=0.)?b:c) \n//#define  unless(a,b,c)             mix(b,a,step(0.,c)) //==greater OR equal\n  #define  unmore(a,b,c) ((a<=0.)?b:c)\n//#define  unmore(a,b,c)             mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n/**///--end__: analysis common subroutines                  \n/**///--\n/**///--start: analysis Hue Gradient Gamma \n\n//rgba colorspace matrices\n      \n#define ut(a,b) (a*(1.-b))          \nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n\n//Re7 Re8 rainbow (do not change or doppler shifts get skewed)\n#define ab012(a,b)(a+b*vec3(0,1,2))//desaturation.rgb kernel;b scales offset\nvec3 rainbow(vec1 a,vec1 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nvec3 rainbow2(vec1 a,vec1 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nvec3 rainbow(vec1 a){return rainbow(a,1./3.);}\nvec3 rainbow2(vec1 a){return rainbow2(a,1./3.);}\n                              \n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\n                      \n/**///--end__: analysis Hue Gradient Gamma \n/**///--\n/**///--start: analysis smin smax smoothing functions  \n//\n//               smin smax smex variants collection: \n//in prefix-form for compatibility with AutomaticDifferentiation and whatnot.\n//\n//1th letter of thre is m for all smoothing fucntions\n//\n//2th letter sets 1of3 boolean fuzzy-union\n//a=max, i=min=-max(-a,-b), 3=mEx()==max(a,-b) is a semi-nonsense label, literally-in-between-vowel\n//\"mex\" is usually called \"difference\", coined by hg_df\n//, but mex() is often a smaller basis-function-subroutine for min(mex()) and max(mex))\n//\n//3th letter sets type of smoothing union (usually different exponents/complexity)\n//\n//\n//--- sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal and buffer the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))                   //sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)                       //sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\n//w11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n//);}//somehow almost correct, but almost is not good enough. uncommented this extension into a different type.\n//\n//\n//--- SminPPolynomial [m*s] by IQ is fast but not commutative;\n//mis2() is subroutine for SminPPolynomial\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//\n//\n//sMinQuadratic [m*r] use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\n//               \n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(-(a)))  \n//                      \nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n//\nfloat recsum(vec2 a){return 1./(1./(a.x+a.y));}\n//\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n//\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n//\n// demo for smin/smax collection, from https://www.shadertoy.com/view/3t2XzW\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;//d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n//\n// honorable mention:\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n//\n//note, when your function has asymptotes\n//, you may want to evade a divisionBy or LogarythmOf small numbers (epecially by 0).\n//for this [almostIdentity] is oftrmn a faster special subroutine fucntion\n//than offsetting all PRECISE asymptotes with an smin/smax.\n//see https://iquilezles.org/articles/functions/\n//BUT if you can predict all asymptotes PRECISELY (and if this is worth calculating)\n//, any smin(asymptiote) call may just look much smoother than smin(AlmostIdentity())\n//also, some asymptotes are nonlinear or even 3d planes.\n\n/**///--end__: analysis smin \n/**///--           \n/**///--start: analysis sabs smoothstep windowfunction hulls\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/**///--end__: analysis sabs smoothstep windowfunction hulls \n/**///--           \n/**///--start: pattern debug\n                               \n//todo,, wallpaper tiling\n                               \n//needed to debug complex (number) functions.\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\n                      \n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n \n\n#define sm(a,b)smoothstep(a-10./500.,a,b)\nfloat PatternCircles(vec2 p,float m//giraffe bubbles of\n){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n              \n/**///--end__: pattern debug\n/**///--\n/**///--start: pattern hash  \n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(v0 a){return vec3(a);}                        \nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(v0 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos2,p.zy),perm2(u5cos2,p.zx),perm2(u5cos2,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+      spd);b*=1.8;z*=1.5;p*=1.2\n//;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos2,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//voronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\n\n// Salt is added to limit the x,y values. No matter what you input,\n// it returns a float [0-5900]\n// may not be a great hash\nfloat salt(float seed){float a=mod(seed,5901.); //coords=vec3(vec2(seed(1.)),0)\n float b=mod(a,2.)==.0?-.01:.11;return a+4179./sqrt(a*5.)*b+1001.*a/seed;}\n      \n/**///--end__: pattern hash            \n/**///--\n/**///--start: pattern noise\n\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL. #version 120\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo without a division\nvec3 mod7(vec3 x){return x-floor(x*(1./7.))*7.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec2 mod289(vec2 x){return  x-floor(x*(1./289.))*289.;}\nfloat mod289(float x){return x-floor(x*(1./289.))*289.;}\nvec3 permute(vec3 x){return mod289((34.*x+1.)*x);}//(34*x*34*x+x)mod 289\nfloat permute(float x){return mod289((34.*x+1.)*x);}\nvec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n      \n      \n//simplex noise:\nfloat snoise(vec2 v\n){const vec4 C=vec4(.211324865405187 //(3.-sqrt(3.))/6.\n                  , .366025403784439 //sqrt(3.0)*.5-.5\n                  ,-.577350269189626 //C.x*2.-1.\n                  , .024390243902439)//1./41.\n ;vec2 i=floor(v+dot(v,C.yy))\n ;vec2 x0=v-i+dot(i,C.xx)\n ;vec2 ii1=(x0.x>x0.y)?vec2(1,0):vec2(0,1)\n ;vec4 x12=x0.xyxy+C.xxzz\n ;x12.xy-=ii1\n ;i=mod289(i)\n ;vec3 p=permute(permute(i.y+vec3(0,ii1.y,1))+i.x+vec3(0, ii1.x,1))\n ;vec3 m=max(.5-vec3(dd(x0),dd(x12.xy),dd(x12.zw)),0.)\n ;m*=m;m*=m\n ;// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n ;// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n ;vec3 x=2.*fract(p*C.www)-1.\n ;vec3 h=abs(x)-.5\n ;vec3 ox=floor(x+.5)\n ;vec3 a0=x-ox\n ;//Normalise gradients implicitly by scaling m\n ;//Approximation of: m *= inversesqrt( a0*a0 + h*h )\n ;m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\n ;a0=vec3(a0.x*x0.x+h.x*x0.y,a0.yz*x12.xz+h.yz*x12.yw)\n ;return 130.*dot(m,a0);}\n     \n\nfloat snoise(vec3 v\n){const vec2 C=vec2(1,2)/6.\n ;const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy))\n ;vec3 x0=v-i+dot(i,C.xxx)\n ;vec3 g=step(x0.yzx,x0.xyz)\n ;vec3 l=1.-g\n ;vec3 j1=min(g.xyz,l.zxy)\n ;vec3 i2=max(g.xyz,l.zxy)\n ;vec3 x1=x0-j1+C.xxx\n ;vec3 x2=x0-i2+C.yyy\n ;vec3 x3=x0-D.yyy\n ;i=mod289(i)\n ;vec4 p=vec4(0)\n ;p=permute(p+i.z+vec4(0,j1.z,i2.z,1))\n ;p=permute(p+i.y+vec4(0,j1.y,i2.y,1)) \n ;p=permute(p+i.x+vec4(0,j1.x,i2.x,1))\n ;//Gradients: 7x7 points over a square, mapped onto an octahedron.\n ;//ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n ;float n_=1./7.\n ;vec3 ns=n_*D.wyz-D.xzx\n ;vec4 j=p-49.*floor(p*ns.z*ns.z)\n ;vec4 x_=floor(j*ns.z);\n ;vec4 y_=floor(j-7.*x_)\n ;vec4 x =x_*ns.x+ns.yyyy\n ;vec4 y =y_*ns.x+ns.yyyy\n ;vec4 h =1.-abs(x)-abs(y)\n ;vec4 b0=vec4(x.xy,y.xy)\n ;vec4 b1=vec4(x.zw,y.zw)\n ;vec4 s0=u3(floor(b0))\n ;vec4 s1=u3(floor(b1))\n ;vec4 sh=-step(h,vec4(0))\n ;vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy\n ;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww\n ;vec3 p0=vec3(a0.xy,h.x)\n ;vec3 p1=vec3(a0.zw,h.y)\n ;vec3 p2=vec3(a1.xy,h.z)\n ;vec3 p3=vec3(a1.zw,h.w)\n ;a0=taylorInvSqrt(vec4(dd(p0),dd(p1),dd(p2),dd(p3)))\n ;p0*=a0.x;\n ;p1*=a0.y;\n ;p2*=a0.z;\n ;p3*=a0.w\n ;vec4 m=max(.6-vec4(dd(x0),dd(x1),dd(x2),dd(x3)),0.)\n ;m*=m\n ;return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\n\n//fbm around 3d simplex  https://www.shadertoy.com/view/ldByDy\nfloat snoiseFbm(int octaves,float persistence,float freq,vec3 coords){\n float amp=1.,maxamp=0.,sum=0.;for(int i=0;i<octaves;++i){\n  sum+=amp*snoise(coords*freq);freq*=2.;maxamp+=amp;amp*=persistence;}\n return(sum/maxamp)*.5+.5;}\n      \n//Cellular noise (Worley noise) in 3D in GLSL.\n//returni F1 and F2 (closest and second closest)of Cellular noise (3er neighborhood)\n//subroutines\nvoid twosmolS(inout vec3 a,inout vec3 b,inout vec3 c\n){vec3 d=min(a,b);b=max(a,b);a=min(d,c);c=max(d,c);b=min(b,c);}\nvoid twosmolC(inout vec3 a\n){a.xy=(a.x<a.y)?a.xy:a.yx;a.xz=(a.x<a.z)?a.xz:a.zx;}\nvec2 twosmolE(inout vec3 a,vec3 b\n){a.yz=min(a.yz,b.xy);a.y=miv(vec3(a.yz,b.z));return a.xy;}\nvec2 twoSmallest(vec3 a,vec3 b,vec3 c\n){twosmolS(a,b,c);twosmolC(a);return twosmolE(a,b);}                      \nvec2 twoSmallest(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i\n){twosmolS(a,b,c);twosmolS(d,e,f);twosmolS(g,h,i)\n ;twosmolS(a,d,g);twosmolC(a)\n ;b=min(b,min(min(d,e),min(g,h)));return twosmolE(a,b);}                      \nvec2 twoSmallest(mat3 a,mat3 b,mat3 c\n){return twoSmallest(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]);}\n\nvec3 makeC(vec3 u,vec2 f,vec3 o,float g,vec3 j){u*=j.y\n ;vec3 x=f.x-g+j.x*(     fract(u)     -j.z)\n ;     u=f.y-o+j.x*(mod7(floor(u))*j.y-j.z);return x*x+u*u;}\n//above makeC() is for 2d, below makeC()&makeB() are for 3d\n//u is permuted hash\n//f,g,w is shift a along (sub)domain\n//o is heretic dark magic\n//j,k are modifiable scalars; j.x sets straightness, range [0..1]\nvec3 makeC(vec3 u,vec2 f,vec3 o,vec3 k,vec3 j){vec3 l=u*k.x   \n ;vec3 a=o  +j.x*     fract(l)        -k.z;\n ;vec3 b=f.x+j.x*mod7(floor(l)   )*k.x-k.z;\n ;vec3 c=f.y+j.x*     floor(u*k.y)*j.y-j.z; \n ;return a*a+b*b+c*c;}\nmat3 makeB(vec3 u,vec4 f,vec3 x,vec3 w,vec3 k,vec3 j\n){vec3 a=makeC(permute(u+w.x),f.wx,x,k,j)\n ;vec3 b=makeC(permute(u+w.y),f.wy,x,k,j)\n ;vec3 c=makeC(permute(u+w.z),f.wz,x,k,j)//3d has one more permute() iteration\n ;return mat3(a,b,c);}\n\n//j.x==straightmess[0..] j.y is like 1/7 j.z is like 1/6\nvec2 cellular(vec2 u,vec3 j\n){vec2 m=mod289(floor(u));u=fract(u)\n ;vec3 w=vec3(-1,0,1)\n ;vec3 v=vec3(-1,1,3)*.5\n ;vec3 r=permute(m.x+w)+m.y\n ;vec3\n  p=permute(r.x+w);vec3 a=makeC(p,u,v,v.x,j)\n ;p=permute(r.y+w);vec3 b=makeC(p,u,v,v.y,j)\n ;p=permute(r.z+w);     p=makeC(p,u,v,v.z,j)\n ;return sqrt(twoSmallest(a,b,p));}              \n//above is 2d, below is 3d vellular noise with 2 shortest distances in 3x neigborhood\nvec2 cellular(vec3 u,vec3 j \n){vec3 k=vec3(j.y,j.y*j.y,.5-j.y)    //this param comes with 2 derivatives\n ;     j=vec3(j.x,j.z,.5*(1.-j.z))//jitter and 1 other param (and one derivative of it)\n ;vec3 m=mod289(floor(u));u=fract(u)-.5\n ;vec3 w=vec3(-1,0,1)\n ;vec3 x=u.x-w;vec3 y=u.y-w;u=u.z-w\n ;vec3 p=permute(m.x+w)+m.y\n ;mat3 a=makeB(permute(p+w.x)+m.z,vec4(u,y.x),x,w,k,j)\n ;mat3 b=makeB(permute(p+w.y)+m.z,vec4(u,y.y),x,w,k,j)     \n ;mat3 c=makeB(permute(p+w.z)+m.z,vec4(u,y.z),x,w,k,j)\n ;return sqrt(twoSmallest(a,b,c));}\n\n// Periodic (tiling) 2-D simplex noise (hexa lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n// axis-aligned and stretched in the y direction for rectangular tiling.\n//\n// periods (p) should be EVEN integers\n// ODD periods for y will automatically be doubled.\n//\n// (rd) makes \"flow noise\" effects\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the uv\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n//\n//  return.yz are .xy derivatives\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise                \n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// TODO: One-pixel wide artefacts used to occur due to precision issues with\n// the gradient indexing. This is specific to this variant of noise, because\n// one axis of the simplex grid is perfectly aligned with the input x axis.\n// The errors were rare, and they are now very unlikely to ever be visible\n// after a quick fix was introduced: a small offset is added to the y coordinate.\n// A proper fix would involve using round() instead of floor() in selected\n// places, but the quick fix works fine.\n// (If you run into problems with this, please let me know.)\n\n      \n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p,float rot){\n#if 0\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;\n  u=4.*fract(u)-2.;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.,abs(abs(u+1.)-2.)-1.);}\n#else\n  float u = permute(permute(p.x)+p.y)*.0243902439+rot;\n  u = fract(u) * 2.*pi; // 2*pi\n  return vec2(cos(u), sin(u));}\n#endif\n                      \nfloat NoiseNoDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec3 w=vec3(dot(rgrad2(vec2(iuw.x,ivw.x),rot),a)\n             ,dot(rgrad2(vec2(iuw.y,ivw.y),rot),b)\n             ,dot(rgrad2(vec2(iuw.z,ivw.z),rot),c))     \n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c));t*=t\n ;return 11.*dot(t*t,w);}\n//above and below are TAIL subroutines, wuith or without derivatives       \nvec3 NoiseDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec2 d=rgrad2(vec2(iuw.x,ivw.x),rot)\n ;vec2 e=rgrad2(vec2(iuw.y,ivw.y),rot)\n ;vec2 f=rgrad2(vec2(iuw.z,ivw.z),rot)\n ;vec3 w=vec3(dot(d,a),dot(e,b),dot(f,c))\n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c))\n ;if(t.x<0.){a.x=0.;a.y=0.;t.x=0.;}\n ;if(t.y<0.){b.x=0.;b.y=0.;t.y=0.;}\n ;if(t.z<0.){c.x=0.;c.y=0.;t.z=0.;}\n ;vec3 t3=t*t*t;t*=t;t*=t\n ;a=a*8.*t3.x;a=t.x*d-a*w.x\n ;b=b*8.*t3.y;b=t.y*e-b*w.y\n ;c=c*8.*t3.z;c=t.z*f-c*w.z\n ;return 11.*vec3(dot(t,w),a+b+c);;}\n\nvoid NoiseHead(vec2 u,inout vec3 x,inout vec3 y\n       ,inout vec2 d0,inout vec2 d1,inout vec2 d2\n       ,inout vec2 p0,inout vec2 p1,inout vec2 p2\n){u.y+=.001\n ;vec2 uv=vec2(u.x + u.y*0.5, u.y)\n ;vec2 j0=floor(uv)\n ;vec2 f0=fract(uv)\n ;vec2 j1=(f0.x>f0.y)?vec2(1,0):vec2(0,1)\n ;p0=vec2(j0.x-j0.y*.5,j0.y)\n ;p1=vec2(p0.x+j1.x- j1.y*.5,p0.y+j1.y)\n ;p2=vec2(p0.x+.5,p0.y +1.)\n ;j1=j0+j1\n ;vec2 i2 = j0 + vec2(1)\n ;d0=u-p0;d1=u-p1;d2=u-p2\n ;x=vec3(p0.x, p1.x, p2.x)\n ;y=vec3(p0.y, p1.y, p2.y);}\n\n//4 comboinations with rotation\nvec3 simplexRotD(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nvec3 simplexRotD(vec2 u,float rot\n){vec2 d0,d1,d2,p0,p1,p2;vec3 x,y;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)        //without TilingPeriod \n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nfloat simplexRot(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}   //without Detivatives               \nfloat simplexRot(vec2 u, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)       //without TilingPeriod\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}  //without Detivative   (.yz)\n//without rotation\nvec3  simplexRotD(vec2 u,vec2 p){return simplexRotD(u,p,0.);}//tiling derivative\nvec3  simplexRotD(vec2 u       ){return simplexRotD(u  ,0.);}//       derivative\nfloat simplexRot (vec2 u,vec2 p){return simplexRot (u,p,0.);}//tiling\nfloat simplexRot (vec2 u       ){return simplexRot (u  ,0.);}\n\n/**///--end__: pattern noise\n/**///--                         \n/**///--start: complex-number (including triginometry)\n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c22(c)-(c.a-c.b*i)\n#define c22(a)c4(anaa(a)).xy  //namespace conflict\nvec2 cs(v1 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(v0 a){return cs(vec2(a,a));}    \n                               \n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\nd000 ata(d000 a){v0 b=a.a*a.a+1.;v0 c=b*b;return d000(atan(a.a),a.a/b,-(b-2.)/b,2.*a.a*(a.a-4.)/(b*c));}\nd00  ata(d00  a){v0 b=a.a*a.a+1.;v0 c=b*b;return d00 (atan(a.a),a.a/b,-(b-2.)/b);}\nd0   ata(d0   a){v0 b=a.a*a.a+1.;v0 c=b*b;return d0  (atan(a.a),a.a/b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}\n\n/*\nd00 atand(d00 x,d00 y){//return atan(y,x);//2 branches, goes full circle.\n if(x.a >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}/**/\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\nv0 su(v1 a){return a.x-a.y;}\n\n#define le(a) sqrt(dd(a))\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2  \n//real and imaginary parts for polar z\nv0 arg(v1 a){return atan(a.y,a.x);}\nv1 p2c(v1 a){return v1(co(a.x),si(a.x))*a.y;}     //return carthesian of polar\nv1 c2p(v1 a){return v1(arg(a),le(a));}            //return polar      of carthesian\nv0 real(v1 z){return p2c(z).x;return z.s*co(z.t);}//return real       of carthesian\nv0 imag(v1 z){return p2c(z).y;return z.s*si(z.t);}//return imaginary  of carthesian\n\n//2 common subroutines:\nv1 crCo(v1 a){return sqrt(length(a)+c22(a.x));}//core of complex root function,lacks sign adjustment and scaling!\nv1 ciCo(v1 u,v1 z,v0 r){return v1(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//[param2&2*x] == complex number arithmetic (annotations updated in 2022-09)\n//v1 c2p(v1 a){return v1(arg(a),lenth(a));} is how i store polar coordinates in a vec2==v1\n//a.x==angle==argument , a.yzw = length\n//if [a] is a vec4==v3, it does an operation with multiple complex numbers that all have the same angle, and i call this [parallel complex numbers, they are colinear in hyperbolic space] and this made sense to define as subroutine, i suppose.\n//\n//[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\n//see https://en.wikipedia.org/wiki/Principal_branch\nv1 sqc(v1 a){v0 n=a.x+length(a);return v1(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i, == complex square root (a.x must be positive!!!)\nv3 sqc(v3 a){v3 c=v3(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\n//v1 sqc(v1 z){v1 c=sqrt((length(z)+c22(z.x))*.5);c.y*=sign(z.y);return c;}//this alternative has significantly worse precision near [.y=0.&&x>0]\nv1 po2c(v1 c){v1 d=c*c;return v1(d.x-d.y,2.*c.x*c.y);}//v1 po2c(v1 a){return muc(a,a);return v1(sub(a*a),2.*a.x*a.y);}//==complex square\nv1 po3c(v1 z){v0 p=z.x*z.x,q=z.y*z.y;return z*v1(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i, ==complex cube\nv1 recc(v1 a){if(a.x==0.)return v1(1e10);return c22(a)/dd(a);}//reciprocal/inverse of z ; 1/z=(a-b*i)/(a*a+b*b),inverse of z;\nv1 lgc(v1 a){a=c2p(a);a.x=log(a.x);return a;}//return v1(log(dd(a))*.5,arg(a)); == complex natural logarythm\nv3 lgc(v3 a){return v3(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nv1 suc(v1 a,v1 b){return a-b;}v1 adc(v1 a,v1 b){return a+b;}///complex addition=complexSum is trivial\nv1 muc(v1 a,v1 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multplication\nv1 muc(v1 a,v1 b,v1 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex multimplication of 3 factors\nv1 muc(v3 a){return muc(a.xy,a.zw);}//parallel mult\nv1 dic(v1 a,v1 b){if(a.x==0.)return v1(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nv1 lgc(v1 a,v1 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z, b is a complex numbr;\nv1 lgc(v1 a,v0 c){return v1(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nv1 exc(v1 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i)) == complex exp(c) == NATURAL exp() (inverse to natural log)\n//v1 lgc(v1 a,v0 c){a=c2p(a);return v1(log(a.x),a.y+c*tau);}//should be the same!\nv1 poc(v1 a,v1 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nv1 poc(v1 w,v1 z,v0 c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nv1 lgc(v1 a,v1 b,v0 c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nv1 wrtc(v1 a,v1 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nv1 wrtc(v1 a,v1 b,v0 c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n\nv1 sic(v1 z){return .5*cs(z.x).yx*(exp(z.y)+c22(exp(-z.y)));}//v1 sic(v1 z){return v1(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  v1 sic(v1 c){v1 d=exp(c2(c.y));return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 si2c(v1 c){v1 d=v1(exp(c.y),1);return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 coc(v1 z){return .5*c22(cs(z.x))*(exp(z.y)+c22(exp(-z.y)));}\n\n//obsoleted v1 coc(v1 z){ return v1(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted v1 coc(v1 c){v1 d=exp(c2(c.y));return v1(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nv1 ta2c(v1 c){v1 d=exp(c22(c.y));v0 e=cos(c.x),s=(d.x-d.y)*.5;return v1(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nv1 tac(v1 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nv1 cotc(v1 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nv1 sihc(v1 z){return .5*cs(z.y)*(exp(z.x)+c22(exp(-z.x)).yx);}//v1 sinh(v1 z){ return 0.5*v1((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//v1 sinh2c(v1 z){z=c22(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nv1 cohc(v1 z){return coc(c22(z.yx));}//v1 cosh(v1 z){ return v1(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 v1 tahc(v1 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 v1 cothc(v1 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(v1 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 v1 cschc(v1 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nv1 arsic(v1 z){return c22(lgc(perp(z)+sqc(c22(po2c(z.yx)))+v1(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//v1 arsic(v1 z){v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(-z.y+a.x,z.x+a.y));return v1(a.y,-a.x);}\nv1 arcoc(v1 z){return-c22(lgc(z+c22(sqc(po2c(z.yx)+v1(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//v1 arcoc(v1 z){ v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(z.x+a.y,z.y-a.x));return v1(-a.y,a.x);}\nv1 csec(v1 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nv1 ccsc(v1 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nv1 arcotc(v1 z){v0 r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((v3(z.yx,-z.yx)+v3(r,0,r,0)).yxzw/r)))*.5;}//v1 arcotc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=lgc(v1(p+q-z.y,-z.x)/r);v1 b=lgc(v1(p+q+z.y,z.x)/r);return v1(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nv1 artac(v1 z){return sub2(c4(lgc(v3(1,0,1,0)-c22(z.yx).xyxy).yxwz))*.5;}//v1 artac(v1 z){ v1 a=lgc(v1(1.0+z.y,-z.x));v1 b=lgc(v1(1.0-z.y,z.x));return v1(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nv1 arcsec(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(sub2(c4(v3(z,sqc(ciCo(u,z,r)).yx)))).yx)+v1(0.,log(r));}//v1 arcsec(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(z.x-a.y,a.x-z.y));return v1(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nv1 arccsc(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+v1(0.,log(r));}//v1 arccsc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(a.x+z.y,a.y+z.x));return v1(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nv1 arcsch(v1 z){v1 u=z*z;v0 r=su(u);return lgc(c22(z)+sqc(ciCo(u.yx,z,r)))-v1(0,log(r));}//v1 arcsch(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r+p-q,-2.0*z.x*z.y));a=lgc(v1(a.x+z.x,a.y-z.y));return v1(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nv1 arsinh(v1 z){return lgc(z+sqc(po2c(z)+v1(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nv1 arcosh(v1 z){return lgc(z+muc(sqc(z.xyxy+v3(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nv1 artanh(v1 z){v0 r=1.-su(z*z);z*=2.;return .5*lgc(-v1(r,z.y)/(r+z.x));}//v1 artanh(v1 z){v0 r=z.x*z.x+z.y*z.y;return lgc(v1(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nv1 arcoth(v1 z){;v0 r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(v1(r,z.y)/(r+2.+z.x));}//v1 arcoth(v1 z){ v0 r=z.x*z.x+z.y*z.y;return lgc(v1(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nv1 arsech(v1 z){v0 r=su(z*z);return lgc(c22(z)+muc(sqc(v3(-r,0,r,0)+c22(z).xyxy)))-v1(log(r),0);}//ok, tested by-ollj\n                \nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a;}                         \n                \n//maybe use a different complex number arithmetic visualizer like\n//https://www.shadertoy.com/view/NtcBDn\n\n\n/**///--end__: complex-number (including triginometry)\n/**///--\n/**///--start: sort\n                               \n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){const float twothirds=2./3.\n   ;if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\nvec3 getPos0V(vec3 a){vec3 r=vec3(0);r[getPos0(a)]=1.;return r;}\nvec3 getPos1V(vec3 a){vec3 r=vec3(0);r[getPos1(a)]=1.;return r;}\n//may wanrt to use getPos0() instead of getPosSmall()\nint getPosLarge(vec3 a//return position of largest  value [0..2]          \n){if(a.x>a.y){if(a.x>a.z)return 0;if(a.y>a.z)return 1;return 2\n       ;}else{if(a.y>a.z)return 1;return 3;}}\nint getPosSmall(vec3 a//return position of smallest value [0..2]          \n){if(a.x<a.y){if(a.x<a.z)return 0;if(a.y<a.z)return 1;return 2\n       ;}else{if(a.y<a.z)return 1;return 2;}}\nint getPosMid(vec3 a//return position of middle value [0..2]          \n){if(a.x<a.y){if(a.y<a.z)return 1;if(a.z<a.x)return 0;return 1  \n       ;}else{if(a.z<a.y)return 1;if(a.x<a.z)return 1;return 3;}}\nvec3 getPosLargeV(vec3 a){vec3 r=vec3(0);r[getPosLarge(a)]=1.;return r;}//return vector that indicates smalles value with a [1]   \nvec3 getPosSmallV(vec3 a){vec3 r=vec3(0);r[getPosSmall(a)]=1.;return r;}//return vector that indicates smalles value with a [1]\n//vec3 getPosMidV  (vec3 a){return vec3(1)-getPosLargeV(a)-getPosSmallV(a);}//dumb and slow but works\n      \n\n      \nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n\n                 \n//project point [a] onto line trough vecN(0) and vecN([b])  b!=0.\n//project(u-a,b-a)+a((project u on line(a,b)\n\n//return [0..1] for projection being on [a..b]\nv0 project0(v1 a,v1 b\n){float c=dd(b)\n ;if(c==0.)return -1.//projecting onto a point is nonsense, [-1] tends to be parsed as a miss\n ;return dot(a,b)/dd(b);}\n      \n\n\n//(project(o-p1,p2-p1)+p1)-o//==vector from o to projection of o on on line\n//project(p-a,b-a)+a//projected point (p) on line (a,b) (not clamped)\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest vector from point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\nv1 projectBary(v1 a,v1 b,v1 c){return b*dot(a,b)/dd(c);}//skewed mirror\n      \n     \nd3 suab(d3 p,v0 s){return su(ab((p)),s);}\nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\nd33 suab(d33 p,d33 s){return su(ab((p)),s);}           \nd22 suab(d22 p,d22 s){return su(ab((p)),s);}\nd11 suab(d11 p,d11 s){return su(ab((p)),s);}\nd00 suab(d00 p,d00 s){return su(ab((p)),s);}\nd333 suab(d333 p,d333 s){return su(ab((p)),s);}           \nd222 suab(d222 p,d222 s){return su(ab((p)),s);}\nd111 suab(d111 p,d111 s){return su(ab((p)),s);}\nd000 suab(d000 p,d000 s){return su(ab((p)),s);}\n//suab extendsions have been frustrating and halted                    \n                      \nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z),suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//c22 suab(c22 p,v2 s){return c22(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\n\n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}\n      \n/**///--end__: common aliases\n/**///\n/**///--start: linear hulls smoothstep\n\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n      \n#define fsaa 2.\n//#define fsaa 2, (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n/**///--end__: linear hulls smoothstep\n/**///\n/**///--start: Reflect and rotate            \n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\nv1 r4(v1 r){return v1(r.y,-r.x);}//perpendicular quater rotation\n                      \nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\n\n//return distance to 1/24th rotated axis (for super fast arrow shape)\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(v0 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(v0 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n        \n//modify inputs to abs(.x) == mirror vertically\nvoid mirror(inout vec2 u,inout vec2 m){m.x=abs(m.x);u.x=abs(u.x);}\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r1(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n//float angleBetween(v1 a,v1 b){return acos(dt(a,b);}\n\n//Quaternion\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dd(a)! \nv3 qn(v3 q){return q/dd(q);}\n/**/\n      /*\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n*/\n                      \n/**///--end__: Reflect and rotate  \n/**///--\n/**///--start: analytic closed-form  solutions \n\n\n//(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}//used to get closest point on ellipse: https://www.shadertoy.com/view/XttyWN\n\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  suv(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n \n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n/**///--end__: analytic solutions  \n/**///--\n/**///--start: tracing and project (euclidena and bary)\n\n\n//--start: barycentric\n\n//return transposed 2x3 matrix (vector form)\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant\nfloat c2bdetR(vec3 X,vec3 Y){return suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec3 X,vec3 Y){return 1./c2bdetR(X,Y);}     \nfloat c2bdetR(vec2 a,vec2 b,vec2 c){return c2bdetR(transp23);}\nfloat c2bdet (vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//c2bdet  for cached   division (by fragment shader) (more common)\n//c2bdetR for deferred division (intersectB2b() carthesian intersection)\n//\n//return barycentric of carthesian point (t) over triangle (a,b,c)==(X,Y)\n#define c2bCore vec4 c=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*(t-vec2(X.z,Y.z)).xyxy;c.xy=vec2(suv(c.xy),suv(c.zw))\nvec3 c2b(vec2 t,vec3 X,vec3 Y,float d){c2bCore\n    ;c.xy*=d;return vec3(c.xy,1.-c.x-c.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}\n\n//float suv(vec2 a){return a.x+a.y;}\n//float suv(vec3 a){return a.x+a.y+a.z;}\n\n//barycentric tracing is great, it gives you a frustrum for free!\n\n//barycentric lineLine intersection CORE (in barycentric coords);\n//functionally identical to Intersection of ray(o,t) with RaySegmentLine(a,b)\n//but division is deferred AFTER checking if it hits\n//barycentric triangle corners are o=vec3(1,0,0)   a=vec3(0,1,0)   b=vec3(0,1,0)\n//carthesian  triangle corners are o=vec2(X.x,Y.x) a=vec2(X.y,Y.y) b=vec2(X.z,Y.z)\n//t=barycentricRayTarget   = c2b(carthesianRayTarget,X,Y,d)\n//d=barycentricDeterminant = c2bdetR(X,Y)\n//very deferred division\nvec3 intersectB2bN(vec3 t,float d\n){t.y=t.y/(d-t.x);return vec3(0,t.y,1.-t.y);}//intersection just scales a ratio\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y,float d\n){//if(d==0.)return vec3(1,0,0)//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;if(t.x==d)return vec3(1,0,0)//poorly evade division by 0 case (of parallel lines)\n ;//we can do cases before the first division\n ;//if( t.x             >abs(d))return vec3(1,0,0)//miss when looking away\n ;//the one above is only needed when one of the 2 below is NOT active\n ;if((t.x+t.y)*sign(d)>abs(d))return vec3(1,0,0)//miss <a (rayRay intersection)\n ;if(0.  >t.y *sign(d)       )return vec3(1,0,0)//miss >b (rayRay intersection)\n ;//set both above for (a<x<b) raySegment intersection\n ;//below is identical to above, BUT each side of (ab) may behave differently.\n ;if(d<0.){\n  ;//if(t.x<d    )return vec3(1,0,0)//miss when looking away from sideA\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x<d-t.y)return vec3(1,0,0)//miss <a                from sideA\n  ;//if(0. <  t.y)return vec3(1,0,0)//miss >b                from sideA\n ;}else{//if(d>0.){\n  ;//if(t.x>d    )return vec3(1,0,0)//miss when looking away from sideB\n  ;//the one above is only needed when one of the 2 below is NOT active\n  ;//if(t.x>d-t.y)return vec3(1,0,0)//miss <a                from sideB\n  ;//if(0. >  t.y)return vec3(1,0,0)//miss >b                from sideB \n ;}\n ;//if you only need a boolean if it hits, return it here, and skip the only division\n ;return intersectB2bN(t,d);}\n //;t.y=t.y/(d-t.x)//division deferred AFTER tracing if it hits\n //;return vec3(0,t.y,1.-t.y);}\n//wrappers:\nvec3 intersectB2b(vec3 t,vec3 X,vec3 Y){return intersectB2b(t,X,Y,c2bdetR(X,Y));}\nvec3 intersectB2b(vec3 o,vec3 t,vec3 a,vec3 b,vec3 c// intersect segment (ab)\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;return intersectB2b(t,X,Y,c2bdetR(X,Y));}\n//carthesian lineLine intersection (in barycentric coords);\nvec2 intersectB2c(vec2 o,vec2 t,vec2 a,vec2 b\n){//identical to: g=gLLxXP(a,b,o,t);if(sat(g)==g)return a-(a-b)*g\n ;vec3 X=vec3(o.x,a.x,b.x)\n ;vec3 Y=vec3(o.y,a.y,b.y)//barycentrics of triangle (0,a,b)\n ;float d=c2bdetR(X,Y)//barycentric triangle determinant\n ;if(d==0.)return o//triangle (o,a,b) is a line, therefore o is on line (ab)\n ;c2bCore;//barycentric to carthesian BUT c.z is irrelevant \n ;c.xyz=intersectB2b(c.xyz,X,Y,d)//barycentric tracing\n ;return b2c(c.xyz,X,Y);}//outout as carthesian\n \n//N version knows that it hits, (within fustrum culling)\nvec2 inB2c2N(vec2 o,vec2 t,vec2 a,vec2 b\n){vec3 X=vec3(o.x,a.x,b.x),Y=vec3(o.y,a.y,b.y)\n ;c2bCore;return b2c(intersectB2bN(c.xyz,c2bdetR(X,Y)),X,Y);}\n\n//return 3 squared lengths of triangle sides of triangle (a,b,c)\nvec3 getSqoaredLengths(vec2 a,vec2 b,vec2 c){return d3d(a-b,b-c,c-a);}\n//return SQUARED length of vector (p) in barycentric coordinates\n//t=getSqoaredLengths(a,b,c) is intended to be buffered\nfloat lengthBary(vec3 p,vec3 t){return -suv(t*p.yxx*p.zzy);}\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Distance_between_points               \n\n     \n//shortest carthesian distance may be different than euclidean. even to the 3 points??\n//anyways, this is buggy, and i cant find the bug.\n\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\n      \nfloat segmentB(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\n\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float cd=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //c2bdet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //c2bdet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,cd)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segmentB(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n /*\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{/**/\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segmentB(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}\n  //min of 3 line distances only inside the triangle\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}\n/**///--end__: barycentric\n \n//lineLineIntersection (carthesian 2d)\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection of lines AB and CD; http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;if (dotperp==0.)return A//worksave for parallel case\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x //==perpdot() function (same order of operands?)\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//return iAlong of segment(AB) with ray(CD) (beware that segment comes first!)\n//asserts that ray points towards segment !!! (that needs a second pass with swapped parameters)\n//if (sat(iAlong)==iAlong)//ray(CD) intersects the segment(AB)\n//if (sat(iAlong)>=iAlong)//ray(CD) intersects the ray(AB)\n//intersectionPoint == A+B*iAlong\nv0 gLLxXP(v1 A,v1 B,v1 C,v1 D\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 e=dot(d,perp(b)) //==perpdot() function (same order of operands?)\n ;if(e==0.)return -.1//worksave for parallel case\n ;v0 t=-dot(c,perp(d))/e\n ;return t;}//gLLxXP(a,b,o,t) tests if ray hits segment (asserting way looks towards segment)\n//intersection points:\n\nvec2 mirror(vec2 o,vec2 a,vec2 b){ //return o, mirrored on ab\n ;vec2 m=project(o-a,b)+a-o\n ;return o+m*2.;}\n\n//mirror o along the axis (x,a+(b-a)*.5) == sqap 2 parycentric components\nvec3 mirrorBaryYZ(vec3 o,vec2 a,vec2 b,vec2 c){ //return o, mirrored on ab (triangle abc)\n ;return o.yxz\n ;//vec2 ass=gLLxX(o,o+b-a,a+(b-a)*.5,c)//hard and dumb carthesian within bary\n ;//return o+(ass-o)*2.//hard and dumb carthesian within bary\n ;}\n\n//mirror o along the axis (p2,p1)\nvec3 mirrorBaryZ(vec3 o){return vec3(o.xy+o.z,-o.z);}\nvec3 mirrorBaryY(vec3 o){return mirrorBaryZ(o.xzy).xzy;}\nvec3 mirrorBaryX(vec3 o){return mirrorBaryZ(o.zyx).zyx;}\n\n//vec2 or=b2c(oo-vec3(-1,0,1).xyz,p2,p0,p1)//third rotation barycentric (but around what point?)\n//barycentrically rotate around vec3(0,0,1) by N/6 full rotations\nvec3 r16bary(vec3 o){return mirrorBaryX(o).yxz;}//oo=r16bary(oo-vec3(1,-1,0))\nvec3 r56bary(vec3 o){return mirrorBaryY(o).yxz;}//oo=r56bary(oo-vec3(0,1,-1))\nvec3 r36bary(vec3 o){return mirrorBaryZ(o).yxz;}//oo=r36bary(oo-vec3(1,-1,0))\n\n//return how far (p) is in front of ray/normal (ut), [>0],or on (u)[=0], or behind (u)[<0] (along the ray)\nfloat isInfront(vec2 u,vec2 t,vec2 p){return dot(p-u,t-u);}\n//isInfront doesnt care for zFar,isWithin asserts (t] to be zfar\n//use isWithin to check if a lineLineIntersection is within a segment.   [<]0for false, >=0 true\nfloat isWithin(vec2 u,vec2 t,float r\n){if(r>=0.){\n ;if(dd(t-u)<=r*r)return r;\n };return -1.;}\n//above already has a cached dotproduct.\nfloat isWithin(vec2 u,vec2 t,vec2 r){r.x=isInfront(u,t,r);return isWithin(u,t,r.x);}\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his MIT licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n//The MIT License\n//Copyright © 2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 vv0,vec3 vv1,vec3 vv2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=vv0-vv1\n ;vec3 b=vv2-vv0\n ;vec3 p=vv0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright © 2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(miv(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n// Slightly improved version of a Trapezoid primitive without flicking.\nfloat sdTrapezoidFixed(vec2 u,vec2 a,vec2 b,float ra,float rb\n){u-=a;b-=a;float c=dd(b)\n ;a=vec2(abs(dot(perp(u),b))/sqrt(c),dot(u,b)/c)\n ;b.x=rb-ra;b.y=sat((b.x*(a.x-ra)+a.y*c)/(b.x*b.x+c))\n ;vec4 r=vec4(ma0(a.x-((a.y<.5)?ra:rb)),abs(a.y-.5)-.5,a.x-ra-b.y*b.x,a.y-b.y)\n ;a.x=sign(mav(r.zy));r*=r;r.yw*=c;r.xz+=r.yw\n ;return a.x*sqrt(miv(r.xz));}//https://www.shadertoy.com/view/wtSyWc\n\n      \n/**///--end__: euclidean tracing\n/**///--\n/**///--start: AD-/mercury.sexy/hd_sdf\n\n//SIMPLE old source lib of mercury.sexy/hd_sdf is: https://www.shadertoy.com/view/Xs3GRB\n//Below are translations of the hg_sdf library into a compressed AND generalized form\n//to be more parametic/modular/pipelined\n//to use the above [Derivative Arithmetic] with hg_sdf\n//\n//mostly just in prefix-notation, but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics/libraties.\n//\n//note: euclidean tracing [line-line-intersection] is needed for some shapes here.\n                                 \n//mod()-extensions must be on top of all hg_sdf unions, that include mod() (which is almost all of them)\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefit from my improved pmod() code\n\n//pmod() got killed by su() incompatibility\n//#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\n////frflpm(v00,c00)  frflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)  //high domain su() incompatibility\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n                      \n//float ma(vec4 a){return 0.;}\n\nconst vec1 _1=.57735026919; // sqrt(3)/3.\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\n     /* killed by incompatibility                 \nfloat Blob(vec3 p){p=abs(p);p=mix(p,p.yzx,step(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n/**/\n#define fPlane(p,n,d) ad(dt(p,n),d)\n      \n      \n      \nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz continuity.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\n/*  old struct fr() incompatibility\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fr(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}*/\n\n           \n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\n\nconst float eRm=.0001;\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n\n//https://en.wikipedia.org/wiki/Moss%27s_Egg\n#define EarVagEgg moss\n#define CylEarVagEgg cylMoss\n//moss() is still far from standardized. rac is the central radius, should be parametric.\nfloat moss(vec2 u,vec3 m//m.x+m.xy<=1. is relevant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //cylMoss() is capped cylinder to extrude it to 3d.\nfloat moss(vec2 u,vec2 m){return moss(u,vec3(m,mix(.5,3.,sin(1.)*.5+.5)));} //ain(1.) was iTime\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(moss(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//cylMoss() is capped cylinder to extrude it to 3d.\nfloat cylMoss(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\n//distance from (u) to lenss nut hourglass (rd) (radius,circleCenterDistances)\nfloat vesica(vec2 u,float r,float d\n){u=abs(u);float b=(r*r-d*d);vec2 a=vec2(u.y*d,u.x+d);a*=a*sign(a)\n ;return((a.x/b>a.y))?length(u-vec2(0,sqrt(b)))*sign(d)\n                     :length(u+vec2(d,0))-r;}//https://www.shadertoy.com/view/XtVfRW\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat sdHorseshoe(vec2 p,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;p.x=abs(p.x)\n ;float l=length(p)\n ;p=mat2(-c.x,c.y,c.y,c.x)*p\n ;p=vec2((p.y>0.)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l )\n ;p=vec2(p.x,abs(p.y-r))-w.xy\n ;return length(max(p,0.)+min(mav(p),0.))   -w.z;\n ;//return length(ma0(p))+mi0(mav(p))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n\n      \n                      /*\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n/**/\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}  \n\n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n\n){float s=r/n\n ;float u=b-r\n ;return mi(mi(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\n      \n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n\n\n/**///--end__: AD mercury.sexy/hd_sdf\n/**///--\n/**///--start: projections\n                      \n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv22 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=vec2(0)//-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*1.)//autopilot //*iTime\n ;m=vec2(1)//mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v22(pos,dir);}\n\n//Phong+debugPlanes\n//todo (fix df() nonsense\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n                      \n                      \n/**///--end__: projections  \n/**///--\n/**///--start: AD Superprims\n      \nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//odsoleted by cir()\n/*\n#define abm(a,b) (abs(a)-b)  //ditance taxicap   -b\n#define lbm(a,b) (length(a)-b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))   //==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a)) //i am not convinced by this one\n//#define box(a,b) roundit(abm(a,b))\n/**/\n      \n//cir()  return distance of (u) to (rounded) box/circle/AxisAlignedLineSegment\n//yes, thats a lot of basic shapes\n//called cir() because all lowest LOD are boxes.\n//cirS() seperates polynomials to allow to delay the sqrt() \n//       of ALL boxes with the same thickness (if tree-branch-thicknesses are uniform)\n//       by getting sqrt(min(multiple squared values))\n//cirS() header exists with and without stretching(&automatic offset)\n//\n//u=uv point\n//b.x=thickness\n//b.y=cornerRoundness [0..1] interpolates between circle and boxRounded\n//lod=LoD lod==0 is always a square\nvec2 cirCore(vec2 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\nvec2 cirCore(vec3 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\n\n//cir header without stretch\nvec2 cirS(vec2 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\n\n//cir header with stretch option\n//s=size stretch\n//positibes are useful for segments/boxes\n//negative inputs create ray/wedge (wedge interiors (2 negative domains) are only good within +-b.x)\n//s=vec2(0,-1) creates an upwards ray, af moves the base up, till vec2(0) touches the bottom\n//s=vec2(1,0) stretches by 1 along .x and moves to the right till vec2(0) is on the surface.\n//any s>0 will create a line segment, where vec2(0) is on the surface, iff one other domain of s==0\nvec2 cirS(vec2 u,vec2 b,float l,vec2 s\n){bvec2 e=lessThan(s,vec2(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;e=greaterThan(s,vec2(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l,vec3 s\n){bvec3 e=lessThan(s,vec3(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;if(e.z){u.z-=b.y*.5;s.z=0.;u.z=min((u.z),0.);}\n ;e=greaterThan(s,vec3(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;if(e.z)u.z-=(s.z+b.y)*.5 \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\n\nfloat cir(vec2 u,vec2 b,float l,vec2 s){u   =cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec2 u,vec2 b,float l       ){u   =cirS(u,b,l  );return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l,vec3 s){u.xy=cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l       ){u.xy=cirS(u,  b,l);return more(u.x,sqrt(u.x),0.)+u.y;}\n\n//without LoD (default to 1.)\nfloat cir(vec2 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec2 u,vec2 b,vec2 s){return cir(u,b,1.,s);}\nfloat cir(vec3 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec3 u,vec2 b,vec3 s){return cir(u,b,1.,s);}\n\n//without lod & with maximum roundness (b and s swapped to avoid namespace conflict with self)\nfloat cir(vec2 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec2 u,float b,vec2 s){return cir(u,vec2(b,1.),s);}\nfloat cir(vec3 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec3 u,float b,vec3 s){return cir(u,vec2(b,1.),s);}\n//cir was tested in 2d, but 3d may have typos?)\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat horseshoe(vec2 u,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;float circle=length(u)-w.z\n ;u.x=abs(u.x)\n ;u=mat2(-c.x,c.y,c.y,c.x)*u\n ;float l=length(u)\n ;u=vec2((u.y>0.)?u.x:l*sign(-c.x),(u.x>0.)?u.y:l)\n ;u=vec2(u.x,abs(u.y-r))-w.xy;\n ;return length(max(u,0.))+ min(0.,max(u.x,u.y))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n      \n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=vec2(0)//iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(mav(dt(p,y))-o.x*3.,sqrt(miv(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\n                      \nstruct v14{float a;vec4 b;};\n                      \nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//guessing this was what this one does\n                      \nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=.5 //iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n                      \n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n             \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\n\n                      //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r){return max(box(u,vec3(r)),fOctahedron(u,r));}\n\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\n //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n                      \n/**///--end__: AD Superprims\n/**///--\n/**///--start: Glyphs\n\nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n                      \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n/**///--end__: Glyphs\n/**///--\n/**///--start: AD march RayMarchingPrimitivesBasic                 \n                      \n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}\n\n//#u,o,t) distance between (u) and segment  from   (o) to     (t)   (strethed dot always does sqrt)\n//    ray(u,o,t) distance between (u) and ray      from   (o) trough (t)   \n//   line(u,o,t) distance between (u) and line     though (o) trough (t)  \n//    ray(u)     distance between (u) and ray      from (0,0) trough (0,1) \n#define segment2(a,c,d) dd(su(a,mu(c,d(di(dt(a,c),dd(c))))))      \n#define segments(u,o,t,d) (segment2(su(u,o),su(t,o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n#define    line(u,o,t) sqrt(segments(u,o,t,nul))\n#define rAy(c) float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}\nrAy(v0)rAy(v1)rAy(v2)rAy(v3)\nfloat ray(v1 u){if(u.x>0.)return length(u);return u.y;}   \n\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\n/**///--end__: march RayMarchingPrimitivesBasic\n/**///follows:\n/**///--start: march bezier \n\n//[follows], because segment() is special case of bezier()\n   \n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n                      \n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b));}\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L){v1 l=p2-p0;float s=L*L//https://www.shadertoy.com/view/4ltyWr\n ;return .5*((p0+p2)+sqrt(max(0.,s-dot(l,l)))*sign(L)*norma(v1(-l.y,l.x)));}\n\n/**///--end__: march bezier \n/**///--\n/**///--start: RE mach RayMarchingPrimitivesBasic               \n\n                           \n\n\n//c.xy=sin/cos of angle. r is the radius //uppr segment is always round\nfloat pieSlice(vec2 u,vec2 c,float r //a simple packman\n){u.x=abs(u.x)\n ;v0 l=length(u)-r\n ;v0 m=length(u-c*clamp(dot(u,c),0.,r) )\n ;return max(l,m*sign(c.y*u.x-c.x*u.y));}//https://www.shadertoy.com/view/3l23RK\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he\n){vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dd(k2), 0., 1. );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0\n   ;return s*sqrt( min(dd(ca),dd(cb)));}//https://www.shadertoy.com/view/MlycD3\n\n//polygon distance does crossingCumbers, has better (rounded) interios than windingnumbers.\nconst int N = 5;\nfloat sdPoly(vec2[N] v, in vec2 p\n){const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }return s*sqrt(d);}//https://www.shadertoy.com/view/wdBXRW\n      \n/**///--end__: RayMarchingPrimitivesBasic\n/**///--\n/**///--start: Relativity\n\n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\nint nextMat;\nint rayMat;\nint rayObj;\nfloat matSize;\nfloat lastrDist;\nfloat lastrDistObj;\nvec4 volumetricCol;\n\n//camera buffer data of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer)\n//- 0<=x<Resolution.xy\n#define RePos   0.  \n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n//ReTime.xyzw store the averages of the (up to) most recent 2,4,8,16  iTimeDelta\n//ReTimE.xyz  store the averages of the (up to) most recent 32,64,128 iTimeDelta\n//ReTimE   .w stores relativistic cameraTime, if (.w<0) time is paused\n#define ReTime  5.  \n#define ReTimE  6.  //\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\n#define ReEdit  9.  //not yet used by Image\nfloat varWdth=1.; //scale up visually\n\n//relativity made compatible: ?\n//RE7 uses a lot of structs in arrays.\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays struct params\n//(arrays of struct params, addressed by struct enum) \n//objectOfStruct.param -> param[objectOfStruct]\n//this mage Re7 gles100 compatible, but now we need an enum foreach object.\n#define objNum 7\n//for below object properties;\nvec4 [objNum] objRot;//rotation\nvec3 [objNum] objPos;//position\nvec3 [objNum] objVel;//velocity\nvec3 [objNum] objSca;//scale\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n\n//float[objNum] objRad;//radius optimization\n#define numLights 3\nvec4 [numLights] oliCol;//colorIntensity;\nvec3 [numLights] oliPos;//position\nfloat[numLights] oliHal;//HaloResult\n//float[numLights] oliSiz;//size\n//lights have no labels\n\n//some global accumulators (some reset each frame, some dont)\n//float mGI;//avccumulator for globalIllumination?\nfloat lorentzF;\n//mat3x3 LZLgthContract;\nvec3 pos; //campos.xyz\nvec3 dpos;//relevant for each pixel of [RE] and [Image] \nfloat playerTime;\n//volume marching accumulator, used for blackHoleAccretionDisk\nfloat vma=0.; \nint curObj = 0;\nint minObjDepth=-1; \n\n\n//point,radius\nv0 sphere(v2 u,v0 r){return length(u.xyz)-r;}\n//point,size\nv0 cube(v2 u, v0 s){return mav(abs(u)-s);}\nv0 box (v2 u, v2 s){return mav(abs(u)-s);}\n//point,radius,height\nv0 cylinderZ(v2 u,v0 r,v0 h){return max(length(u.xy)-r,abs(u.z)-h);}  \nv0 cylinderY(v2 u,v0 r,v0 h){return cylinderZ(u.xzy,r,h);}\nv0 cylinderX(v2 u,v0 r,v0 h){return cylinderZ(u.zyx,r,h);}\n\n//DopplerShift //col,shiftedFreq,targetFreq\nv0 dsf(v2 c,v2 s,v0 t \n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;return suv(c*max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.))  ;}\n #else\n ;return suv(c*max(v2(0),1.-abs(s)*3.))  ;}\n #endif\n\n//dopplerShiftFactor\nvec3 dsf(vec3 c,vec3 f//all values of f are identical.\n){f*=vec3(1.,1.257,1.58)\n ;vec3 r=vec3(1,2,4)/3.\n ;return vec3(dsf(c,f,0. )+dsf(c,f,1.)*.3+dsf(c,f,-r.x)*.2\n             ,dsf(c,f,r.x) \n             ,dsf(c,f,r.y)+dsf(c,f,1.)*.5+dsf(c,f,r.z)*.25);}\nvec3 dsf(vec3 c,float f){return dsf(c,vec3(f));}\n\n//Quaternion  //pushed up a lot by RE7\n/*\n//asserting that length of quaternions are close to 1\n//we can normalize() by dividing by the squaredLength dot(a,a)! \nvec4 qn(vec4 q){return q/dot(q,q);}\n/**/\nvec4 qn(vec4 q){return q/dot(q,q);}\nvec4 aa2q(float b,vec3 a// b must be normalized!\n){b*=.5;return qn(vec4(a*sin(b),cos(b)));}\n\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nvec4 q2aa(vec4 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nvec4 qm(vec4 a, vec4 b\n){vec4 res= vec4(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return normalize(res);}\nvec3 qr(vec4 q,vec3 v\n){vec3 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n\nvec4 Transform(int i,vec4 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(vec3(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\n\nvoid oCamSet(vec3 u,vec4 rot){objPos[oCam]=u;objRot[oCam]=rot;}\n\nfloat LorentzFactor(float v){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\n\nvoid ProcessLightValue(float t\n){oliPos[0]=vec3(6.,1.,sin(t))\n ;oliCol[0]=3.*vec4(0.2,1.,.2,1)\n ;oliPos[1]=vec3(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*vec4(1,1,0.5,1)\n ;oliPos[2]=vec3(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*vec4(1,.2,1,1);}\nvoid SetTime(float t){\n ;ProcessLightValue(t)//also called in final pass\n ;objPos[oCubeMy]=vec3(0) \n ;objRot[oCubeMy]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oCubeMy]=vec3(.8)\n ;objPos[oBlackHole]=vec3(5.,sin(t*0.2),-5.)\n ;objRot[oBlackHole]=aa2q(t*2.,vec3(0,1,0))\n ;objSca[oBlackHole]=vec3(1)\n ;objPos[oCubeChil]=vec3(1)\n ;objRot[oCubeChil]=aa2q(t*1.,normalize(objPos[oCubeChil]))\n ;objSca[oCubeChil]=vec3(.4)\n ;float trainV = 2.2\n ;objVel[oTrain]= vec3((floor(mod(trainV*t/16.,2.))*2.-1.)*trainV,0,0)\n ;float trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.\n ;objPos[oTrain]=vec3(abs(1.-mod(trainV*t/16.,2.))*16.-8.,-.8,9.)\n ;objRot[oTrain]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTrain]= vec3(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;objPos[oTunnel]=vec3(0,-.8,9.)\n ;objRot[oTunnel]=aa2q(pi*.5,vec3(0,1,0))\n ;objSca[oTunnel]=vec3(1.,1.,1)\n ;objPos[oTunnelDoor]=objPos[oTunnel]\n ;objRot[oTunnelDoor]=objRot[oTunnel]\n ;float open = sat((1.-abs(3.*objPos[oTrain].x))*2.)\n ;objSca[oTunnelDoor]= vec3(open,open,1);}\n\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n      \n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID==processedMaterial||processedMaterial==-1){nextMat=matID;lastrDist=o;\n#define endMaterial() } if (o != lastrDist) rayMat=nextMat;\n//marchlight() MarchPOV() do map(r.b,-1) , it marches the whole set\n//object groups are assigned to a materialID\n//defined as N of beginMaterial(N)\n//if map(r.b,-1) ray hits material of an id, rayMat stores that ID\n//a second pass can then march  ONLY against a subset geomety of a previously measured materialId\n//getDiffuse may do map(r.b,mat)\n//this is used to see how fast the hit object moves to the camera\n     //but that assumes that the same way will also hit the moved object\n     //and thats a VERY silly assumption, and also, it is disabled, and may have always been.\n     //this was likely a dubm idea of the maker of this, never completely edited out.\n\n//this is cute and all, but not compatible with my infiniteReflections\n//as my infiniteReflections loop accumulates on each reflection, there is no second pass\n//groups of materials may still be useful.\n\n//to be very clear, map() so far is ALWAYS called with second parameter set to -1\n//while other inpputs wozuld only trace a subset of the DF.\nfloat map(vec3 u, int processedMaterial\n){float o=0.//0. if first operation is a SUB(), 1e10 otherwise\n ;rayObj=0\n ;vec4 w=vec4(u,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(w.w*box(w.xyz-vec3(0),vec3(10,2.5,10)))\n ;ADD(w.w*cylinderY(w.xyz-vec3(-6,0,-2.),0.1,3.))\n ;ADD(w.w*cylinderY(w.xyz-vec3( 5,0,-2.),0.1,3.))\n ;endMaterial()     \n ;vec4 c=beginObj(oCubeMy,w)//cubespace, not color\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(c.w*sphere(c.xyz,1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;vec4 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(blackHoleSpace.w*sphere(blackHoleSpace.xyz,.5))\n ;endMaterial()\n ;vec4 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0, .5,0),vec3(.2,.1,1.5)))\n ;ADD(tunnelSpace.w*box(tunnelSpace.xyz-vec3(0,-.5,0),vec3(.2,.1,1.5)))\n ;endMaterial()\n ;vec4 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0, 1.4),vec3(.2,.4,0.1)))\n ;ADD(tunnelDoorSpace.w*box(tunnelDoorSpace.xyz-vec3(0,0,-1.4),vec3(.2,.4,0.1)))\n ;endMaterial()\n ;vec4 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.8),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,-.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,0),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.4),vec3(.1,.1,.18)))\n ;ADD(trainSpace.w*box(trainSpace.xyz-vec3(0,0,.68),vec3(.1,.1,.06)))\n ;ADD(trainSpace.w*cylinderZ(trainSpace.xyz-vec3(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;float temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;float tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0;L<3;L++\n ){ADD(w.w*sphere(w.xyz-oliPos[L],.001))\n  ;vec3 relPos=oliPos[L]-pos\n  ;oliHal[L]+=o*(0.02/(dot(relPos,relPos)+.01));}\n ;return o;}\n\nvec4 GetNormal(vec3 u//4tap derivative\n){vec2 e=vec2(.003,0.)\n ;float o=map(u,-1)\n ;return vec4(normalize(vec3(map(u+e.xyy,-1)\n                            ,map(u+e.yxy,-1)\n                            ,map(u+e.yyx,-1))-o),o);}\n\n\n\n/**///--end__: Relativity\n/**///--\n/**///--start: memo\n                      \n             \n//solving with linear equations (and not with perlendicular doorproduct rhombus)\n\n/*getting the linear function of a line (o,t) //2 points on a line\ny=m*x+b\nm=(o.y-t.y)/(o.x-t.x) //slpe == rate of change over one domain (x)\nb=t.y-m*t.x           //f(0)\n\nm=(o.x-t.x)/(o.y-t.y)  //is constant\neither enter o.xy or t.xy\no.y      =m*o.x+b    \nt.y      =m*t.x+b\nt.y-m*t.x=     +b   //b is f(0)\n\nm=(o.x-t.x)/(o.y-t.y) //slope\nb=t.y-m*t.x           //f(0)  (this is a vec2 in 3d)\n\n//the above is odd for barycentric coordinates.\n//theres no y=m*x+b pointSlope form\n//sure, the slope is simple\n//oh wait, i just assert a skewed 2d coordinate system.\n\n//where ever 2 things intersect, they are the same, there they are equal.\n//this equation is a linear equation system, with as mnany lines as domains\n//substract factors to get all constants on one side\n                      \n/*  solving lonear equations with inverse matrix:\nhttps://courses.lumenlearning.com/ivytech-collegealgebra/chapter/solving-a-system-of-linear-equations-using-the-inverse-of-a-matrix/\n\n  a*x=b\n    x=b/a\n    x=b*inverse(a)\n\na is a matrix\nx are coefficients (one foreach domain)\nb may be zero vector, usually only contains constanty.\n                      \nexample (2d line intersection)\nA linear function is visible as a line where f(x)=y\ncos(x)  =y\ncos(x)-y=0\n\nany intersection of 2 things may have an intersection, where both functions are equal\n3*a+ 8*b=5\n4*a+11*by7\n\nA=mat2(vec2(3,8),vec2(4,11)\nX=vec2(a,b)\nB=vec2(5,7)\nA*X=B\ninverse(A)==mat2(11,-8,-4,3)\ninverse(A)*B==vec2(-1,1)  \nBEWARE that matrix multiplication is not commutative  inverse(A)*B != b*inverse(A)\n->\nvec2(x,y)==vec2(-1,1)\n/**/\n                      \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n/*\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n/**/\n                      \n/*\ntodo\nget RE included\n\nfix duplicates with the hg_sdf segment\n\nfix vNNN struct incompatibles (is simple)\n\nfix all that relies on high domain su() functions. (incompatibility\n- hash noise errors  , re-copy from   https://www.shadertoy.com/view/XlVyDK\n\ninclude debugHg2() marcher from       https://www.shadertoy.com/view/XlVyDK\n\na lot of hg sdf uses higher doimkensional mod mo(), which fails here an is from  /XlVyDK\n*/\n                      \n/*\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n/**/\n                      \n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n\nfloat addToAverage(float a,float b,float l//remove b from incremental average a of length l\n){return ((a*l)+b)/(l+1.);}//assert l to be -=1\n\n//assume a stores an average of 2 and is 2 long, thats a*l=4\n//and b is a slow frame that is 3 long:\n//the 3 iframes long segment is 2+2+3\n//we divide by 3 for the new average\n      \n//assume a stores an average of 2 and is 2 long\n//and b is a slow frame that is 3 long\n//(2+3)/2\n  \n/**///-- start incrementalAveraging (for bayesian performance)\n      \n//[a] stores an average of [c] inputs of [t]\n//initially          a= 0\n//after first  call, a= t       /1\n//after second call, a=(t+t2   )/2\n//after second call, a=(t+t2+t3)/3 ...\n//incremental averaging //a==0 before the first call of ia()\nfloat ia(float a,float t,float c\n){return ((a*c)+t)/c;}//update average a by input t,c==number of function calls\n //assuming ia() is called every frame, and the initial frame has iFrame==0 :\n //c=1.+iFrame         accumulates a to the average of every frame\n //c=1.+min(iFrame,2.) keeps storing the averages of the 2 most recent calls\n //c=1.+min(iFrame,4.) keeps storing the averages of the 4 most recent calls\n\n//t=iTimeDelta,i=iFrame\n//a.xyzw stores 4 short term averages\nvoid performance(inout vec4 a,inout vec3 b,float t,float i){\n ;vec4 c=vec4(i)\n ;vec3 d=min(c.xyz,vec3(2,4,8))+1.  //+1 outside the () asserts initial iFrame==0\n ;     c=min(c,vec4(16,32,64,128))+1.\n ;ia(a.x,t,c.x)//a.y stores an average i of up to 2 most recent frames\n ;ia(a.y,t,c.y)//a.z stores an average i of up to 4 most recent frames\n ;ia(a.z,t,c.z)//a.w stores an average i of up to 8\n ;ia(a.w,t,c.w)  //b.x stores an average i of up to 16\n ;ia(b.x,t,d.x)  //b.y stores an average i of up to 32\n ;ia(b.y,t,d.y)  //b.z stores an average i of up to 64\n ;ia(b.z,t,d.z);}//b.w stores an average i of up to 128\n\n//now, instead of feeding the average of 60 fps to bayeps\n//or just iTimeDelta\n//we feed it the average of multiple average iTimeDeltas \n//the first frame it asserts the idela of 1/targetfps pperformance\n//the frames fter this it has averages of averages of iTimeDelta segments\n\n", "buffer_a_code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m){if(d<r){r=d;state.x=f;o=center-m;}}//for iDiegeticUI\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  ;addInit(.35*iResolution.x,.4 *iResolution.y)//initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.7 *iResolution.y)\n  ;addInit(.5 *iResolution.x,.1 *iResolution.y)\n  ;addInit(.4 *iResolution.x,.7 *iResolution.y)\n  ;addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=ds²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=ds³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      “farness”=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    “swiftness”=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure “nearness”.\n;\n     “nearness”=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    “forceness”=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25)   ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25)   ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n            \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;m=iMouseZwFix(m,false)\n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n     \n     \n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(smoothstep(c.xyzw,-c.xyzw,vec4(viewzoom/Aa(t,u,r,m))),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){v0 t=iTime\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;m=iMouseZwFix(m,false)\n #if (scene==3)\n ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n #elif (scene==2)\n ;O=in3d(t,u,r,m)\n #elif (scene==1)\n ;O=in2d(t,u,r,m)\n #elif (scene==0)\n ;O=in1d(t,u,r,m)\n #endif \n    \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//[Re]= [Relativity Engine] v8\n\n//parent  Re7 : https://www.shadertoy.com/view/tlf3zj    (BayesianEpsilon targetFPS)\n//parent  Re0 : https://www.shadertoy.com/view/tdfXDl\n//this seems to have brighter lights than the oldest parent Re0\n//but the diffuse calculation seems to be still identical between Re0 and Re8\n\n//press t to toggle pausing time\n//(note that telativistic effects are also paused\n//, moving closer to an object will fadstForward it to its present state\n//, moving away from an ovject, will have you see its state further in the past.\n\n//the DF still lacks boundingVolumes\n//to collide well with BVs (woth offset) we must add a summand to BV size\n//this optionally enlarges BVs, so we can calculate larger epsilon for collisons.\n//also. collisions should ee done in much hicher precision (small epsilon, small lipschitz stuff\n\n\n/*\nthis initially only rared for camera and cameraCollision\nbut now it may just buffer a lot more\n- some bayeps values\n- object properties for a UI\n- some bayeEps memory to average over (average of last few rendertimes)\n/**/\n\n\n\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\nfloat keyRe(float a){return texture(iChannel1,vec2(a,.5)).x;}//key released\nfloat keyDn(float a){return texture(iChannel1,vec2(a,.2)).x;}//key down\nfloat keyDn(vec2 a){return keyDn(a.x)-keyDn(a.y);}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\n\n\n/**///---\n/**///---start: fps counter\n\n//https://www.shadertoy.com/view/Ms2cWz\n//this is improving\n//https://www.shadertoy.com/view/lsjyzR#\n//in precision and performance\n//it dares to such the boundaries of floating point percission.\n//way past 5 decimals, \n//which is were reasonable people would stop using only 16 bit float.\n//got a performance boost with code from https://www.shadertoy.com/view/MtyXDV\n//this code is bad at displaying large values in the 2billions.\n//because it insists on tpe float for large values, \n//resulting in rounding such large integers down.\n//\n//this is becase i assume most fragment shader impllementations \n//will do type float FASTER than integer divisions of integers >1million.\n//and i just do not use type int anywhere in here.\n//this funcion is important to avoid SOME rounding errors \n//that can result in \"out of bound\" glyphs that will be caught by clamp(digit,0,9))\n//but then still display the wrong glyph due to \"cascading rounding up\".\n//at roughly the 5th decmal place of values like -78987.8889999999;\nfloat powf(float i){\n //if (i<-8.)return pow(10.,floor(i));\n //line makes makes no difference because for that range you have MUCH different issues first.\n if (i>-1.){\n  if(i>3.){\n   if(i>5.){\n    if(i>6.)return 1e7;return 1e6;}else{\n    if(i>4.)return 1e5;return 1e4;}}else{\n   if(i>1.){\n    if(i>2.)return 1e3;return 1e2;}else{\n    if(i>0.)return 1e1;return 1e0;}}}else{\n  if(i>-5.){\n   if(i>-3.){\n    if (i>-2.)return 1e-1;return 1e-2;}else{\n    if (i>-4.)return 1e-3;return 1e-4;}}else{\n   if(i>-6.){\n    if (i>-6.)return 1e-5;return 1e-6;}else{\n    if (i>-8.)return 1e-7;return 1e-8;}}}}\n//based on \n//https://www.shadertoy.com/view/XsfyDl          =leading zeroes, other precision boons\n//https://www.shadertoy.com/view/lsfcRX          =bufferless bitmap-font version\n//https://www.shadertoy.com/view/4ltXDf          =font texture\n//https://www.shadertoy.com/view/MsXyzX          =less branching for above\n//based on https://www.shadertoy.com/view/Mt2GWD =log10 stuff for decimal spacing\n//\n//core function is floatShow()\n//should be easy to modify to show cursor.xy or values of matrices.\n//\n//only shows [glyphs] decimals left of the decimal point.\n//only shows min(4,[glyphs]) decimals right of the decimal point. (5th rounds poorly)\nconst float glyphs =11.;//max glyphs\n//Sets loop iterations.\n//is used in 2 loops, cycling that often,\n//..once for whats left of the decimal point, once for whats right of the decimal point\n//\n//transparent border around glyphs that\n//replaces thin border of glyph with transparency, does not add whitespace.\nconst float marginT=1.;//if (marginG==1. && small text scale) neigbors can bleed trough.\n//marginT gets obsoleted by [p<-clamp(p,0.,1.)] within char()\n//\n//some compilers may just cry and may refuse to compile shit or just return a black screen.\n#ifdef div0\n//for openGl division by 0 case handling of type float.\nconst float NaN= 0./0.;\nconst float Inf= 1./0.;\nconst float NIn=-1./0.;\nconst float Po0= pow(0.,0.);\n//pow(0.,0.) should be \"ndef\" or \"NaN\", but is \"0.\" (or \"1.\") depending on hardware.\n#endif\n#define lt(a) lessThan(vec2(-1.),a)\nbool whiteRectangle(vec2 u){\n bvec2 a=lessThan(vec2(-1.),-abs(u));//bvec2 a=greaterThan(vec2(.1), uv); \n return (a.x&&a.y);}//inspired by https://www.shadertoy.com/view/ldScRm\n//bool whiteRectangle2(vec2 i){bvec2 a=lt(-i),b=lt(i);//symmetry--:\n// return (a.x&&a.y)&&(b.x&&b.y);}//inspired by https://www.shadertoy.com/view/ldScRm\nbool isInside3(vec2 p){return !whiteRectangle(p*2.-1.);}\n// --- access to the image of ascii code c\nvec4 char(vec2 p,float c){\n  if(isInside3(p*marginT))return vec4(0,0,0,1e5); //optional shortcut...\n    //+3fps max, boost declines over time down to +1 fps (base fps is 50 fps)\n  return texture(iChannel0,clamp(p,0.,1.)/16.+fract(floor(vec2(c,16.-(1e-6)-floor(c)/16.))/16.));\n}//via https://www.shadertoy.com/view/MtyXDV\n//p=fragment, n=float value\nvec4 print_number(vec2 p,float n){return char(p,clamp(mod(n,10.),0.,9.)+48.);}\n//#define logb(b,x) log(x)/log(b)\nconst float l10=(1./log(10.));//precalc for speed\n#define log10(x) log(x)*l10\n//#define log10(x) logb(10.,x)//would be slower, log() is slow.\n//http://stackoverflow.com/questions/14081024/opengl-using-a-logarithmic-coordinates-axis\n//return number of digits left of decimal point\nfloat getWholeDigits(float f){if(abs(f)==0.)return 0.;return floor(log10(max(abs(f),0.0000001)))+1.;}\n//see http://stackoverflow.com/questions/1068849/how-do-i-determine-the-number-of-digits-of-an-integer-in-c\n//to remember that dumb|raw solutions can often outperform smart solutions.\n#define ch(n) char(p,n).x;p.x-=.5;\n//left==digits left to the decimal point, relevant for other text being left-endian.\n//commonly left=getWholeDigits(abs(number));\n//and you can add one leading zero by \n// left=getWholeDigits(abs(number))+1.;\n//right==digits right of the decimal point (todo, fix pathethic rounding errors)\n//w returns the total width of the float in glyphs.\nvec4 floatShow(vec2 p,float f,float left,float right,out float w){vec4 o=vec4(0); \n w=p.x;\n#ifdef div0\n #define ro w-=p.x;return o;}\n if(f==NaN){     o+=ch( 78)o+=ch( 97)o+=ch( 78)ro//Nan //  0./0.\n else if(f==Inf){o+=ch( 73)o+=ch(110)o+=ch(102)ro//Inf // +1./0.;\n else if(f==NIn){o+=ch(126)o+=ch( 73)o+=ch(110)ro//~In // -1./0.\n#endif\n if(f<.0){f=abs(f);o+=ch(45.)}//negative number handling:\n float n=left;           \n for(float i=glyphs;i>-1.;i--){ \n  if(left<1.){o+=print_number(p,0.).x;p.x-=.5;break;}\n  float ex=-i-n+glyphs+1.;\n  //ex=max(0.,ex);\n  float n=pow(10.,ex);if(abs(n)>0.){\n   o+=print_number(p,f*n).x;p.x-=.5;}\n  left--;if(left<=0.)break;}\n //decimal point shifting,making \".\" non-fixedwidth:\n f=fract(f);//=mod(f,1.);//=1.-floor(f);//adds rounding errors.\n p.x+=.1;\n o+=char(p,46.).x;p.x-=2.5-.1; //44->\",\" :: 46->\".\"\n p.x+=2.;\n //digits right of the decimal point:\n float decimals=right;\n for(float i=decimals;i>0.;i--){\n  float n=\n  //pow(10.,decimals-i+1.);\n    powf(   decimals-i+1.);\n    //n=1e9;//this overwrite shows that above function is not the culpit.\n  o+=print_number(p,f*n).x;p.x-=.5;\n }w-=p.x;return o;}         \nvec4 fpsTopLeftCorner(vec4 o,vec2 p\n){p.y-=.94\n ;p.x+=.01\n ;p *= 16.2\n ;float w=0.\n ;float left=0.\n ;float fpsFrame=iTimeDelta\n ;if(abs(fpsFrame)>0.\n ){fpsFrame=1./fpsFrame\n  ;left=getWholeDigits(abs(fpsFrame))\n  ;o+=floatShow(p,fpsFrame,left,2.,w).x\n ;}else fpsFrame=0.000001;left=2.\n ;o*=.5*(smoothstep(0.,1.,o.w))\n ;o=max(o,vec4(0))\n ;o=sqrt(o)//cheap cubic bloom    \n ;return o;}\n/**/\n/*            \nvoid mainImage(out vec4 o,vec2 u\n){vec32i =u/iResolution.y\n ;if(i.x<.15&&i.y>.95){\n ;o=mainImage2(o,i);//number overlay\n ;}}\n/**///---end__: fps counter\n/**///\n/**///---start: BufferModifiers (camera movement) \n\nvoid mainImage(out vec4 o,in vec2 u\n){vec2 i=u/iResolution.y\n ;if(i.x<.15&&i.y>.95){o=fpsTopLeftCorner(o,i);return;}//number overlay\n ;if(u.y>1.||u.x>varWdth*10.){o=vec4(0.);return;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(iFrame<5//init\n ){if(Proc(ReTimE,v,w))o=vec4(0,1,iTimeDelta,0)//set speed of time to 1\n ;}else{\n ;vec2 edit =Get(ReEdit).xy\n ;pos       =Get(RePos).xyz\n ;dpos      =Get(RePosD).xyz\n ;vec4 quat =Get(ReQua)\n ;//vec4 dquat=Get(ReQuaD)\n ;vec4 time =Get(ReTime)//time stores 4 short term averages of iTimeDeltas\n                        //timE.xyz stores 3 long term averges of iTimeDeltas\n ;vec4 timE =Get(ReTimE)//timE.w stores cameraTime (is negative when time is paused\n ;performance(time,timE.xyz,iTimeDelta,float(iFrame))\n //accumulate 7 incremental averages of iTimeDelta\n //time.xyxz averages (up to) 2,4,8,16  most recent iTimeDelta\n //timE.xyz  averages (up to) 32,64,128 most recent iTimeDelta\n //the (non weighted) average of these 7 values smooths (most recent) performance holes?\n ;float deltaT=iTimeDelta\n ;float plf   =LorentzFactor(length(dpos))\n ;if(timE.w>=0.)timE.w+=deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(abs(timE.w))\n ;oCamSet(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir         =normalize(dpos)\n ;vec4 normDist  =GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm      =normDist.xyz\n ;float proxAlert=normDist.w\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n //2020-11 new imouse.zw fix\n ;vec4 mouse=iMouse;mouse=iMouseZwFix(mouse,true)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(mouse.xy-mouse.zw)/iResolution.yy\n ;if(mouse.x == 0. && mouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(!(mouse.w <=0.)//if mouse should have an effect\n ){if(edit.x>0.\n  ){ //edit mode mouse==march the scene at the mouse cursor direction\n   ;\n  ;}else{//mouse rotates camera\n   ;pitchYaw += joystick*deltaT\n   ;pitchYaw.y = clamp(pitchYaw.y,-pi*.5,pi*.5)\n ;}}//end of case, cause we can still move, while not rotating the camera\n ;quat =aa2q(pitchYaw.x,vec3(0,1,0))\n ;right=qr(quat,vec3(1.,0.,0.))\n ;quat =qm(aa2q(-pitchYaw.y,right),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))  \n ;acc+=keyDn(vec2(KEY_E,KEY_D)/255.)*groundForwardDir*thrustForce\n ;acc+=keyDn(vec2(KEY_F,KEY_S)/255.)*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;     if(Proc(RePos    ,v,w))o=vec4(pos,1.) //camPos\n ;else if(Proc(RePosD   ,v,w))o=vec4(dpos,1.)//camMovement\n ;else if(Proc(ReQua    ,v,w))o=quat         //camRotation\n //;else if(Proc(ReQuaD   ,v,w))o=dquat        //camRotationChange\n ;else if(Proc(RePosDD  ,v,w))o=vec4(acc,1.) //camAccelleration\n ;else if(Proc(ReCamR   ,v,w))o=vec4(pitchYaw,0,0)\n\n ;else{\n  ;float kG=keyRe(KEY_G/255.)\n      //if (G is not pressed && T is pressed) == !(G||(!T))\n  ;if(!(kG>0.||!(keyRe(KEY_T/255.)>0.)))timE.w=-timE.w //pausingTime always toggles independently\n  ;//this way you may press g and t at the same time\n  ;if(kG>0.\n  ){if(edit.x<1.){timE.w=-abs(timE.w);edit.x=1.//key-G overwrites the unpausing of T into pausing\n   ;}else edit.x=0.;}//if edit mode is entered, time also pauses\n                     //but if edit mode ends, time stays as it is\n  ;     if(Proc(ReTimE   ,v,w))o=timE          //store state of time\n  ;else if(Proc(ReTime   ,v,w))o=time          //store state of time\n  ;else if(Proc(ReEdit   ,v,w))o=vec4(edit,0,0)//store state of editMode\n ;}}}\n", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//iTR  TemporalReprojection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n", "buffer_d_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tffRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3307, 3307, 3338, 3338, 3402], [3403, 3403, 3421, 3421, 3440], [10963, 11379, 11410, 11410, 11435], [11435, 12293, 12321, 12321, 12340], [12358, 12408, 12438, 12438, 12472], [12473, 12539, 12566, 12566, 12587], [12597, 12622, 12649, 12649, 12672], [18072, 18072, 18100, 18100, 18143], [18412, 18412, 18476, 18476, 18625], [18627, 18627, 18666, 18677, 18822], [18874, 18874, 18972, 18972, 19159], [19161, 19217, 19245, 19245, 19368], [19386, 19386, 19415, 19415, 19965], [20275, 20275, 20308, 20308, 20319], [20724, 20724, 20738, 20738, 20776], [21011, 21453, 21563, 21563, 25298], [26474, 26474, 26528, 26528, 26611], [26613, 26613, 26674, 26674, 26848], [26850, 26850, 26918, 26918, 27185], [27187, 27296, 27409, 27409, 29500], [29516, 29516, 29619, 29619, 29668], [29670, 29792, 29817, 29817, 29847], [29848, 29848, 29887, 29887, 29924], [29925, 29925, 29997, 29997, 30154], [30234, 30316, 30381, 30381, 36072], [36074, 36074, 36112, 36112, 36588], [36591, 37029, 37092, 37092, 38956], [38960, 38960, 39046, 39046, 42247], [42255, 42255, 42292, 42292, 43442], [43449, 43585, 43671, 43768, 44107], [44109, 44264, 44349, 44349, 44650], [44652, 44652, 44698, 44698, 45651], [45653, 45653, 45729, 45729, 46856], [46864, 46864, 46927, 46927, 47548], [47550, 47946, 47970, 47970, 47996], [47997, 47997, 48022, 48022, 48359], [48994, 48994, 49036, 49036, 49192], [49193, 49193, 49232, 49232, 49268], [49270, 49291, 49385, 49385, 49683], [49685, 49685, 49742, 49765, 51742], [51744, 51744, 51814, 51814, 52193], [55144, 55144, 55186, 55186, 55495], [55497, 55497, 55535, 55601, 56507], [58369, 58369, 58395, 58395, 59177]], "test": "untested"}
{"id": "3lXfRH", "name": "3D Shockwave Effect faster", "author": "Leria", "description": "3D Shockwave effect with density alteration on the edges + deceleration with the distance to the center\nThe effect stops at itime = 13.\nHere, faster means better optimized than my previous version", "tags": ["noise", "raymarch", "shockwave", "energy"], "likes": 4, "viewed": 745, "published": 3, "date": "1595935264", "time_retrieved": "2024-07-30T20:53:25.853540", "image_code": "// Fork of \"3D Shockwave Effect\" by Leria. https://shadertoy.com/view/wtlBRn\n// 2020-07-28 10:39:36\n\n//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.2\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t0\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t0\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nfloat anim = 0.;\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif    \n    \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 5.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s <90; s++)\n    {               \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        float d = length(center)-RADIUS-.5-jit*k;\n        float size = length(center)/RADIUS;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR            \n            #if ANIM      \n            \tanim = iTime/10.;\n            \n            #endif\n            float n = fbm( ( \n                p/( clamp(0., RADIUS, length(center)) + cos(PI+snoise(p)) - 1./size*anim ) //shockwave stuff\n            \t\t\t) )  ;\n            \n\n            float mask = smoothstep(1.,\n                                   \t20.*RADIUS,\n                                  \tRADIUS/length(center));\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n);\n            \n           if(length(p-cam.pos) >(dist_center+m.radius) || \n           (k*dens  < -9.9))\n        \t{\n         \tbreak;\n        \t}\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 15. * dens, \n                      \tk * 10. * dens,\n              \t      \tk * 15. * 1./size * dens));    \n            \n            t_acc *= (rgb_t);           \n    \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n            #endif\n        }\n\n        //if it will never be in the shape anymore, return;        \n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1579, 1579, 1604, 1617, 1991], [1993, 1993, 2018, 2031, 2390], [2392, 2392, 2411, 2411, 2504], [2506, 2525, 2601, 2601, 2648], [2650, 2650, 2682, 2682, 2702], [2704, 2704, 2738, 2738, 2760], [2847, 2847, 2888, 2888, 2924], [2926, 2926, 3012, 3012, 3047], [3049, 3049, 3092, 3092, 3132], [3134, 3134, 3158, 3158, 3206], [3208, 3208, 3248, 3248, 3552], [3554, 3554, 3578, 3578, 3641], [3644, 3644, 3696, 3696, 6056], [6059, 6059, 6116, 6116, 6745]], "test": "untested"}
{"id": "3lfBz8", "name": "Interlocked Tetrahedra", "author": "dr2", "description": "Interlocked hollow tetrahedra with a little light and shadow (see Escher's Double Planetoid where things get more complicated)", "tags": ["tetrahedron", "shape"], "likes": 12, "viewed": 371, "published": 3, "date": "1595923196", "time_retrieved": "2024-07-30T20:53:26.706260", "image_code": "// \"Interlocked Tetrahedra\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrTetDf (vec3 p, float d);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.y *= k;\n    q.y -= -0.2;\n    q.xz = Rot2D (q.xz, - k * pi / 6.);\n    q.xy = Rot2D (q.xy, pi / 2. -0.5 * acos (1./3.));\n    q.xz = Rot2D (q.xz, pi / 4.);\n    d = abs (PrTetDf (q, 1.)) - 0.02;\n    d = max (d, - PrSphDf (q, 0.85));\n    DMIN (1);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = 0; j < 50; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;\n  float dstObj, at, nDotL, sh;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 1., 3.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. - 0.2 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 5., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.22 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vn = VaryNf (64. * ro, vn, 0.2);\n    dfTot = vec3 (0.);\n    spTot = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.6, 0.95, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro + 0.05 * vn, ltDir);\n      c = HsvToRgb (vec3 (0.9 - 0.25 * float (k), 0.9, 1.));\n      nDotL = max (dot (vn, ltDir), 0.);\n      dfTot += c * (0.05 + 0.95 * at * sh * nDotL * nDotL);\n      spTot += 0.2 * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    }\n    col = dfTot + spTot;\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 0.03 * pi * tCur;\n    el -= 0.05 * pi * sin (0.02 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 5.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e = vec2 (1., -1.);\n  return (max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d) / sqrt (3.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBz8.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[445, 445, 467, 467, 834], [836, 836, 869, 869, 1046], [1048, 1048, 1069, 1069, 1317], [1319, 1319, 1356, 1356, 1578], [1580, 1580, 1615, 1615, 2756], [2773, 2773, 2829, 2829, 3828], [3830, 3830, 3863, 3863, 3890], [3892, 3892, 3925, 3925, 4063], [4065, 4065, 4089, 4089, 4206], [4208, 4208, 4244, 4244, 4450], [4452, 4452, 4482, 4482, 4595], [4629, 4629, 4653, 4653, 4765], [4767, 4767, 4792, 4792, 4978], [4980, 4980, 5009, 5009, 5221], [5223, 5223, 5262, 5262, 5442]], "test": "untested"}
{"id": "3lfBR8", "name": "Double slit simulation", "author": "Pidhorskyi", "description": "Double slit experiment simulation using Schrödinger's quantum mechanical wave equation.", "tags": ["simulation", "quantum", "waveequation", "schrdinger"], "likes": 21, "viewed": 680, "published": 3, "date": "1595903473", "time_retrieved": "2024-07-30T20:53:27.729524", "image_code": "#define s_Im_pdt iChannel0\n#define s_Re_c iChannel1\n\nvec3 lab2xyz( vec3 c ) {\n    float fy = ( c.x + 16.0 ) / 116.0;\n    float fx = c.y / 500.0 + fy;\n    float fz = fy - c.z / 200.0;\n    return vec3(\n         95.047 * (( fx > 0.206897 ) ? fx * fx * fx : ( fx - 16.0 / 116.0 ) / 7.787),\n        100.000 * (( fy > 0.206897 ) ? fy * fy * fy : ( fy - 16.0 / 116.0 ) / 7.787),\n        108.883 * (( fz > 0.206897 ) ? fz * fz * fz : ( fz - 16.0 / 116.0 ) / 7.787)\n    );\n}\n\nvec3 xyz2rgb(vec3 c){\n\tconst mat3 mat = mat3(\n        3.2406, -1.5372, -0.4986,\n        -0.9689, 1.8758, 0.0415,\n        0.0557, -0.2040, 1.0570\n\t);\n    vec3 v = (c / 100.0) * mat;\n    vec3 r;\n    r.x = ( v.r > 0.0031308 ) ? (( 1.055 * pow( v.r, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.r;\n    r.y = ( v.g > 0.0031308 ) ? (( 1.055 * pow( v.g, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.g;\n    r.z = ( v.b > 0.0031308 ) ? (( 1.055 * pow( v.b, ( 1.0 / 2.4 ))) - 0.055 ) : 12.92 * v.b;\n    return r;\n}\n\nvec3 lab2rgb( vec3 c ) {\n    return xyz2rgb( lab2xyz( vec3(100.0 * c.x, 2.0 * 127.0 * (c.y - 0.5), 2.0 * 127.0 * (c.z - 0.5)) ) );\n}\n\t\t\nvoid mainImage(out vec4 outColor, vec2 uv)\n{\n    uv /= iResolution.xy;\n\tfloat Im_mdt = texture(s_Im_pdt, uv).x;\n\tfloat Re_c = texture(s_Re_c, uv).x;\n\t\t\t\t\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x);\n    pos = 2.0 * pos - vec2(1.0, iResolution.y / iResolution.x);\n\t\t\t\t\n\tvec3 phase = (vec3(0.5, 0.0, 0.5) + vec3(Re_c, 0, Im_mdt) * 0.5);\n\tvec3 module = vec3(length(vec2(Re_c, Im_mdt)));\n    float U = Potential(pos);\n    \n\t//outColor = vec4( mix(phase, module, u_phaseOrModule) + vec3(U),  1.0); \n    outColor = vec4(lab2rgb(vec3(module.x, phase.x, phase.z)),  1.0); \n    outColor += Potential(pos);\n}\n                    \n", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define dt  (0.10 * dx.x * dx.x)\n\nconst float Kx = 500.0;\nconst float Ky = 0.0;\nconst float omega = 0.1;\nconst float cx = -0.7;\nconst float cy = 0.0;\n\nfloat Potential(vec2 pos)\n{\n\treturn mix(0., 1.e6, float(abs(pos.x - 0.0) < 0.01)) * float(abs(pos.y - 0.1) > 0.01 && abs(pos.y + 0.1) > 0.01); \n}\n\nvec2 Psi0(vec2 pos)\n{\n    float s = pow(pos.x-cx,2.0)+pow(pos.y-cy,2.0);\n    float o = exp(-s / 2.0 / pow(omega, 2.0) ) / omega / 15.0;\n    float im = sin(Kx*pos.x+Ky*pos.y);\n    float re = cos(Kx*pos.x+Ky*pos.y);\n\treturn o * vec2(re, im);\n}\n", "buffer_a_code": "#define s_Im_mdt iChannel0\n#define s_Re_c iChannel1\n\t\t\t\nvoid mainImage(out vec4 outColor, vec2 uv)\n{\n    uv /= iResolution.xy;\n\tvec2 dx = vec2(1.0 / iResolution.x, 0.0);\n\tvec2 dy = vec2(0.0, 1.0 / iResolution.x);\n\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x);\n    pos = 2.0 * pos - vec2(1.0, iResolution.y / iResolution.x);\n\tfloat U = Potential(pos);\n\t\t\t\t\n\tfloat ImPsi_mdt   = texture(s_Im_mdt, uv).x;\n\tfloat RePsi_c     = texture(s_Re_c, uv).x;\n\tfloat RePsi_c_pdx = texture(s_Re_c, uv + dx).x;\n\tfloat RePsi_c_mdx = texture(s_Re_c, uv - dx).x;\n\tfloat RePsi_c_pdy = texture(s_Re_c, uv + dy).x;\n\tfloat RePsi_c_mdy = texture(s_Re_c, uv - dy).x;\n\n\tfloat ImPsi_pdt = \n\n\t(\n\t\t0.5 * (\n\n\t\t\t(RePsi_c_pdx + RePsi_c_mdx - 2.0 * RePsi_c) /dx.x / dx.x +\n\t\t\t(RePsi_c_pdy + RePsi_c_mdy - 2.0 * RePsi_c) /dy.y / dy.y\n\n\t\t)  - U * RePsi_c\n\n\t) * 2.0*dt + ImPsi_mdt;\n\n    if (iFrame < 1)\n    {\n        outColor = vec4(Psi0(pos).y, 0, 0, 0);\n    }\n    else\n    {\n        outColor = vec4(ImPsi_pdt, 0, 0, 0);\n    }\n}\n", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "#define s_Im_pdt iChannel0\n#define s_Re_c iChannel1\n\t\t\t\nvoid mainImage(out vec4 outColor, vec2 uv)\n{\n    uv /= iResolution.xy;\n\tvec2 dx = vec2(1.0 / iResolution.x, 0.0);\n\tvec2 dy = vec2(0.0, 1.0 / iResolution.x);\n\t\t\t\t\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x);\n    pos = 2.0 * pos - vec2(1.0, iResolution.y / iResolution.x);\n\tfloat U = Potential(pos);\n\n\tfloat RePsi_c = texture(s_Re_c, uv).x;\n\tfloat ImPsi_pdt = texture(s_Im_pdt, uv).x;\n\tfloat ImPsi_pdt_pdx = texture(s_Im_pdt, uv + dx).x;\n\tfloat ImPsi_pdt_mdx = texture(s_Im_pdt, uv - dx).x;\n\tfloat ImPsi_pdt_pdy = texture(s_Im_pdt, uv + dy).x;\n\tfloat ImPsi_pdt_mdy = texture(s_Im_pdt, uv - dy).x;\n\n\tfloat RePsi_ppdt = \n\n\t(\n\t\t-0.5 * (\n\n\t\t\t(ImPsi_pdt_pdx + ImPsi_pdt_mdx - 2.0 * ImPsi_pdt)/ dx.x/ dx.x +\n\t\t\t(ImPsi_pdt_pdy + ImPsi_pdt_mdy - 2.0 * ImPsi_pdt)/ dy.y/ dy.y\n\n\t\t)  + U * ImPsi_pdt\n\n\t) * 2.0*dt + RePsi_c;\n\n    if (iFrame < 1)\n    {\n        outColor = vec4(Psi0(pos).x, 0, 0, 0);\n    }\n    else\n    {\n        outColor = vec4(RePsi_ppdt, 0, 0, 0);\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define s_Im_mdt iChannel0\n#define s_Re_c iChannel1\n\t\t\t\nvoid mainImage(out vec4 outColor, vec2 uv)\n{\n    uv /= iResolution.xy;\n\tvec2 dx = vec2(1.0 / iResolution.x, 0.0);\n\tvec2 dy = vec2(0.0, 1.0 / iResolution.x);\n\t\t\t\t\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x);\n    pos = 2.0 * pos - vec2(1.0, iResolution.y / iResolution.x);\n\tfloat U = Potential(pos);\n\t\t\t\t\n\tfloat ImPsi_mdt   = texture(s_Im_mdt, uv).x;\n\tfloat RePsi_c     = texture(s_Re_c, uv).x;\n\tfloat RePsi_c_pdx = texture(s_Re_c, uv + dx).x;\n\tfloat RePsi_c_mdx = texture(s_Re_c, uv - dx).x;\n\tfloat RePsi_c_pdy = texture(s_Re_c, uv + dy).x;\n\tfloat RePsi_c_mdy = texture(s_Re_c, uv - dy).x;\n\n\tfloat ImPsi_pdt = \n\n\t(\n\t\t0.5 * (\n\n\t\t\t(RePsi_c_pdx + RePsi_c_mdx - 2.0 * RePsi_c) /dx.x / dx.x +\n\t\t\t(RePsi_c_pdy + RePsi_c_mdy - 2.0 * RePsi_c) /dy.y / dy.y\n\n\t\t)  - U * RePsi_c\n\n\t) * 2.0*dt + ImPsi_mdt;\n\n    if (iFrame < 1)\n    {\n        outColor = vec4(Psi0(pos).y, 0, 0, 0);\n    }\n    else\n    {\n        outColor = vec4(ImPsi_pdt, 0, 0, 0);\n    }\n}\n", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "#define s_Im_pdt iChannel0\n#define s_Re_c iChannel1\n\t\t\t\nvoid mainImage(out vec4 outColor, vec2 uv)\n{\n    uv /= iResolution.xy;\n\tvec2 dx = vec2(1.0 / iResolution.x, 0.0);\n\tvec2 dy = vec2(0.0, 1.0 / iResolution.x);\n\t\t\t\t\n    vec2 pos = uv * vec2(1.0, iResolution.y / iResolution.x);\n    pos = 2.0 * pos - vec2(1.0, iResolution.y / iResolution.x);\n\tfloat U = Potential(pos);\n\n\tfloat RePsi_c = texture(s_Re_c, uv).x;\n\tfloat ImPsi_pdt = texture(s_Im_pdt, uv).x;\n\tfloat ImPsi_pdt_pdx = texture(s_Im_pdt, uv + dx).x;\n\tfloat ImPsi_pdt_mdx = texture(s_Im_pdt, uv - dx).x;\n\tfloat ImPsi_pdt_pdy = texture(s_Im_pdt, uv + dy).x;\n\tfloat ImPsi_pdt_mdy = texture(s_Im_pdt, uv - dy).x;\n\n\tfloat RePsi_ppdt = \n\n\t(\n\t\t-0.5 * (\n\n\t\t\t(ImPsi_pdt_pdx + ImPsi_pdt_mdx - 2.0 * ImPsi_pdt)/ dx.x/ dx.x +\n\t\t\t(ImPsi_pdt_pdy + ImPsi_pdt_mdy - 2.0 * ImPsi_pdt)/ dy.y/ dy.y\n\n\t\t)  + U * ImPsi_pdt\n\n\t) * 2.0*dt + RePsi_c;\n\n    if (iFrame < 1)\n    {\n        outColor = vec4(Psi0(pos).x, 0, 0, 0);\n    }\n    else\n    {\n        outColor = vec4(RePsi_ppdt, 0, 0, 0);\n    }\n}\n", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBR8.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 77, 77, 465], [467, 467, 488, 488, 957], [959, 959, 983, 983, 1091], [1095, 1095, 1139, 1139, 1710]], "test": "untested"}
{"id": "tl2yDG", "name": "Procedurally generated world", "author": "vipiao", "description": "A procedurally generated planet.\nControls:\n    Translate: W, A, S, D\n    Rotate: Arrow Keys\n    Change velocity: hold C or V\n    Change seed: hold E or R", "tags": ["raymarching", "input", "proceduralgeneration"], "likes": 11, "viewed": 428, "published": 3, "date": "1595898408", "time_retrieved": "2024-07-30T20:53:28.826591", "image_code": "vec3 test = vec3(0);\nvec3 test2 = vec3(0);\n\nfloat mountainHeightMapTexture(in vec3 pos){\n    \n    vec3 cameraPosSampleA = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n    vec3 posA = pos - cameraPosSampleA;\n    float l = length(posA.xz);\n    if(l > 1.){\n    \tposA = posA/sqrt(l);\n    }\n    \n    posA = posA/MAP_WIDTH;\n    posA.z *= iResolution.x/iResolution.y;\n    posA += 0.5;\n    float heightA = texture(iChannel1, posA.xz).x;\n    \n    vec3 cameraPosSampleB = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE_2, 0), 0).xyz;\n    vec3 posB = pos - cameraPosSampleB;\n    l = length(posB.xz);\n    if(l > 1.){\n    \tposB = posB/sqrt(l);\n    }\n    \n    posB = posB/MAP_WIDTH;\n    posB.z *= iResolution.x/iResolution.y;\n    posB += 0.5;\n    float heightB = texture(iChannel1, posB.xz).y;\n    \n    float f = mod(iTime, TERRAIN_UPDATE_RATE)/TERRAIN_UPDATE_RATE;\n    //f = f*f*3.-f*f*f*2.; // Makes the transition smoother.\n    \n    float combined = heightB*(1.-f) + heightA*f;\n    \n    return combined;\n}\n\nfloat sdMountain(in vec3 pos){\n    vec3 flatPos = vec3(pos.x, 0., pos.z);\n    float height;\n    height = mountainHeightMap(/*in vec3 pos=*/flatPos);\n    \n\tfloat heightDiff = pos.y - height;\n    const float maxSlope = 2.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return nextDist;\n}\n\nfloat sdMountainTexture(in vec3 pos){\n    vec3 flatPos = vec3(pos.x, 0., pos.z);\n    float height;\n    height = mountainHeightMapTexture(/*in vec3 pos=*/flatPos);\n    \n\tfloat heightDiff = pos.y - height;\n    const float maxSlope = 3.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return nextDist;\n}\n\nvoid sdMountainNormal(in vec3 pos, inout vec3 normal, out float sd){\n\tsd = sdMountain(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.001;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdMountain(pos - e.xyy),\n    \tsdMountain(pos - e.yxy),\n    \tsdMountain(pos - e.yyx)\n    ));\n}\n\nvoid sdMountainNormalTexture(in vec3 pos, inout vec3 normal, out float sd){\n\tsd = sdMountainTexture(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.02;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdMountainTexture(pos - e.xyy),\n    \tsdMountainTexture(pos - e.yxy),\n    \tsdMountainTexture(pos - e.yyx)\n    ));\n}\n\nconst float WATER_HEIGHT = -7.;\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    const float f = 2.;\n    const float m = 0.05;\n    const vec3 vecs[size] = vec3[](\n        vec3( f*1.,  f*2.,  m*0.2),\n        vec3(f*0.5, f*0.5,  m*0.1),\n        vec3(f*-1., f*0.2,  m*0.1),\n        vec3( f*0.,f*-0.5,  m*0.5),\n        vec3( f*2., f*-2., m*0.01),\n        vec3(f*-2.,  f*5., m*0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude and wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+0.5*time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight + WATER_HEIGHT;\n}\n\nfloat sdWater(in vec3 pos){\n    const float maxWaveHeight = (.2+.1+.1+.5+.01+.01)*.05;\n    const float maxWaterHeight = maxWaveHeight + WATER_HEIGHT; // See waterFunction(.).\n    if(pos.y - maxWaterHeight > maxWaveHeight){\n    \treturn pos.y - maxWaterHeight;\n    }\n    \n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    float df = max(sqrt(length(cameraPos-pos)), 1.)*0.01;\n    vec2 e = vec2(df, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\nvoid marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    inout float dist, in float maxDist, in float minDist,\n    inout int numSteps, in int maxNumSteps,\n    inout vec3 color, out vec3 normal, out int returnCode\n){\n    //nearest = maxDist;\n    // Setup.\n    \n    // Trace.\n    for(int i=0; i<maxNumSteps; i++) {\n        //\n        numSteps++;\n        \n        // Mountain.\n        float sdMount = sdMountainTexture(/*in vec3=*/pos); // Signed distance.\n        float sdWater = sdWater(/*in vec3 pos=*/pos);\n        \n        float sd = min(sdMount, sdWater);\n        \n        if(dist + sd > maxDist){\n        \tsd = maxDist-dist;\n            dist += sd;\n            pos += dir*sd;\n            \n            returnCode = TOO_FAR;\n        \treturn;\n        }\n        if(sd <= minDist + dist*0.0003){\n            if(sdMount < sdWater){\n                // Mountain.\n            \tsdMountainNormalTexture(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*out float sd=*/sd);\n                \n                // Grass\n                color = vec3(51./255.,102./255.,41./255.);\n                \n                // Sand.\n                //color = mix(color, vec3(76./255.,70./255.,50./255.), max(1.-abs(pos.y-WATER_HEIGHT), 0.));\n                color = mix(color, vec3(153./255.,133./255.,92./255.), clamp(WATER_HEIGHT - pos.y + 2., 0., 1.));\n                \n                // Mountain.\n                color = mix(color, vec3(127./255.,127./255.,127./255.), clamp((pos.y - (1.))*0.2, 0., 1.));\n                \n                // Snow.\n                color = mix(color, vec3(255./255.,255./255.,255./255.), clamp(pos.y - 13. + normal.y*3., 0., 1.));\n                \n                returnCode = INTERSECTED;\n                return;\n            } else {\n                // Water.\n                sdWaterNormal(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*inout float sd=*/sd);\n                color = vec3(0.5, 0.5, 0.5);\n                \n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }\n        }\n        \n        //\n        dist += sd;\n        pos += dir*sd;\n       \t\n    }\n    returnCode = TOO_MANY_STEPS;\n    return;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Input.\n    //vec3 cameraPos = texture(iChannel0, vec2(float(CAMERA_POS)/iResolution.x, 0)).xyz;\n    vec3 cameraPos = texelFetch(iChannel0, ivec2(CAMERA_POS, 0), 0).xyz;\n    //vec3 forward = normalize(texture(iChannel0, vec2(float(CAMERA_DIRECTION)/iResolution.x, 0)).xyz);\n    vec3 forward = normalize(texelFetch(iChannel0, ivec2(CAMERA_DIRECTION, 0), 0).xyz);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    \n    //\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n    \n    vec3 camPos = vec3(cameraPos.x, cameraPos.y, cameraPos.z);\n    vec3 viewDir = normalize(forward + right * uv.x + up * uv.y);\n    \n    \n    //\n    vec3 pos = camPos;\n    vec3 dir = viewDir;\n    float dist = 0.;\n    float maxDist = 120.;\n    float minDist = 0.0001;\n    int numSteps = 0;\n    int maxNumSteps = 400;\n    vec3 color = vec3(0.);\n    vec3 normal;\n    int returnCode;\n\t//\n    \n    marchWorld(\n        /*inout vec3 pos=*/pos, /*inout vec3 dir=*/dir,\n        /*inout float dist=*/dist, /*in float maxDist=*/maxDist, /*in float minDist=*/minDist,\n        /*inout int numSteps=*/numSteps, /*in int maxNumSteps=*/maxNumSteps,\n        /*inout vec3 color=*/color, /*out vec3 normal=*/normal, /*out int returnCode=*/returnCode\n    );\n    \n    // Lights.\n    vec3 lightDir = normalize(vec3(10.,-1,1.));\n    \n    vec3 shaddowPos = pos-lightDir*minDist*100.;\n    vec3 shaddowDir = -lightDir;\n    float shaddowDist = 0.;\n    float shaddowMaxDist = 80.;\n    float shaddowMinDist = minDist;\n    int shaddowNumSteps = 0;\n    int shaddowMaxNumSteps = maxNumSteps/3;\n    vec3 shaddowColor = vec3(0.);\n    vec3 shaddowNormal;\n    int shaddowReturnCode;\n    float shaddowFactor;\n    if(returnCode == INTERSECTED){\n        marchWorld(\n            /*inout vec3 pos=*/shaddowPos, /*inout vec3 dir=*/shaddowDir,\n            /*inout float dist=*/shaddowDist, /*in float maxDist=*/shaddowMaxDist, /*in float minDist=*/shaddowMinDist,\n            /*inout int numSteps=*/shaddowNumSteps, /*in int maxNumSteps=*/shaddowMaxNumSteps,\n            /*inout vec3 color=*/shaddowColor, /*out vec3 normal=*/shaddowNormal, /*out int returnCode=*/shaddowReturnCode\n        );\n    \tshaddowFactor = (1.-min(1.*(shaddowMaxDist - shaddowDist), 1.));\n    } else {\n    \tshaddowFactor = 1.;\n    }\n    \n    vec3 finalViewDir = normalize(pos-camPos);\n    \n    // Ambient occlusion\n    vec3 occlusionColor = vec3(0.,0.,0.);\n    float occlusionFactor = float(numSteps)/log(dist+10.) * max(dot(-finalViewDir, normal), 0.);\n    occlusionFactor = max(1.-occlusionFactor*0.025, 0.);\n    \n    float diff = max(dot(-lightDir, normal), 0.);\n    \n    vec3 reflectDir = reflect(lightDir, normal); // reflect(I, N) = I - 2.0 * dot(N, I) * N.\n    float spec = pow(max(dot(reflectDir, -finalViewDir), 0.0), 8.);\n    \n    color = (color*diff + color*spec*0.2)*shaddowFactor + color*0.5*occlusionFactor;\n    \n    // Mist.\n    vec3 mistColor = vec3(0.5,0.6,0.9);\n    float mistFactor = max(float(numSteps)/float(maxNumSteps), float(dist)/float(maxDist));\n    color = mix(color, mistColor, mistFactor);\n    \n    // The sun.\n    float d = dist/maxDist * 2.*max(mistFactor*mistFactor*mistFactor-0.5, 0.)*min(pow(max(dot(dir, -lightDir), 0.), 1024.), 1.);\n    color = min(color + vec3(d), 1.);\n\n    // Output to screen\n    fragColor = vec4(color,0.1);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 prevColor = texelFetch(iChannel1, ivec2(fragCoord), 0).xyz;\n    \n    // Keep track of time.\n    if(ivec2(fragCoord) == ivec2(PREVIOUS_TIME,0)){\n        float prevTimeTemp = texelFetch(iChannel1, ivec2(PREVIOUS_TIME_TEMP, 0), 0).x;\n    \tprevColor.r = prevTimeTemp;\n    }\n    if(ivec2(fragCoord) == ivec2(PREVIOUS_TIME_TEMP,0)){\n    \tprevColor.r = iTime;\n    }\n    \n    // Zoom.\n    float sensitivity = texelFetch(iChannel1, ivec2(CAMERA_SENSITIVITY, 0), 0).x;\n    if(ivec2(fragCoord) == ivec2(CAMERA_SENSITIVITY,0)){\n        if(sensitivity == 0.){\n            sensitivity = 0.1;\n            prevColor.r = 0.1;\n        }\n        if(texelFetch( iChannel0, ivec2(KEY_C,0), 0 ).x > 0.5 && prevColor.r < 0.4){\n            prevColor.r *= 1.05;\n        }\n        if(texelFetch( iChannel0, ivec2(KEY_V,0), 0 ).x > 0.5 && prevColor.r > 0.001){\n            prevColor.r /= 1.05;\n        }\n    }\n    \n    // Rotate.\n    vec3 forward = texelFetch(iChannel1, ivec2(CAMERA_DIRECTION, 0), 0).xyz;\n    if(length(forward) == 0.){\n        forward = vec3(-1,0,0);\n    }\n    forward = normalize(forward);\n    vec3 right = normalize(cross(forward, vec3(0,1,0)));\n    vec3 up = cross(right, forward);\n    if(ivec2(fragCoord) == ivec2(CAMERA_DIRECTION,0)){\n        bool arrowRight = texelFetch( iChannel0, ivec2(KEY_RIGHT,0), 0 ).x > 0.5;\n        bool arrowLeft = texelFetch( iChannel0, ivec2(KEY_LEFT,0), 0 ).x > 0.5;\n        bool arrowUp = texelFetch( iChannel0, ivec2(KEY_UP,0), 0 ).x > 0.5;\n        bool arrowDown = texelFetch( iChannel0, ivec2(KEY_DOWN,0), 0 ).x > 0.5;\n        if(arrowRight){\n            forward = normalize(forward + right*0.02);\n        }\n        if(arrowLeft){\n            forward = normalize(forward - right*0.02);\n        }\n        if(arrowUp){\n            forward = normalize(forward + up*0.02);\n        }\n        if(arrowDown){\n            forward = normalize(forward - up*0.02);\n        }\n    \tvec3 right = normalize(cross(forward, vec3(0,1,0)));\n    \tvec3 up = cross(right, forward);\n        prevColor = normalize(forward);\n    }\n    \n    // Translate.\n    if(ivec2(fragCoord) == ivec2(CAMERA_POS,0)){\n        bool dDown = texelFetch( iChannel0, ivec2(KEY_D,0), 0 ).x > 0.5;\n        bool aDown = texelFetch( iChannel0, ivec2(KEY_A,0), 0 ).x > 0.5;\n        bool spaceDown = texelFetch( iChannel0, ivec2(KEY_SPACE,0), 0 ).x > 0.5;\n        bool shiftDown = texelFetch( iChannel0, ivec2(KEY_SHIFT,0), 0 ).x > 0.5;\n        bool wDown = texelFetch( iChannel0, ivec2(KEY_W,0), 0 ).x > 0.5;\n        bool sDown = texelFetch( iChannel0, ivec2(KEY_S,0), 0 ).x > 0.5;\n        if(wDown){\n        \tprevColor += forward*sensitivity;\n        }\n        if(sDown){\n        \tprevColor -= forward*sensitivity;\n        }\n        if(dDown){\n        \tprevColor += right*sensitivity;\n        }\n        if(aDown){\n        \tprevColor -= right*sensitivity;\n        }\n        if(spaceDown){\n        \tprevColor += up*sensitivity;\n        }\n        if(shiftDown){\n        \tprevColor -= up*sensitivity;\n        }\n        if(iTime < 1.){\n        \tprevColor = vec3(-.5,1.-iTime,0);\n        }\n    }\n    \n    // Change seed.\n    bool eIsDown = texelFetch(iChannel0, ivec2(KEY_E,0), 0).x > 0.5;\n    bool rIsDown = texelFetch(iChannel0, ivec2(KEY_R,0), 0).x > 0.5;\n    if(ivec2(fragCoord) == ivec2(CHANGE_SEED,0)){\n        if(eIsDown){\n        \tprevColor.r += 0.1;\n        }\n        if(rIsDown){\n        \tprevColor.r -= 0.1;\n        }\n    }\n    \n    // Global variables.\n    if(ivec2(fragCoord) == ivec2(TEXTURE_UPDATE,0)){\n\t\tprevColor.r = 0.;\n    }\n    float prevTimeTemp = texelFetch(iChannel1, ivec2(PREVIOUS_TIME_TEMP, 0), 0).x;\n    if(eIsDown || rIsDown || mod(iTime, TERRAIN_UPDATE_RATE) < mod(prevTimeTemp, TERRAIN_UPDATE_RATE)){\n    \t// Once a TERRAIN_UPDATE_RATE:\n\t\tif(ivec2(fragCoord) == ivec2(CAMERA_POS_SAMPLE_2,0)){\n            prevColor = texelFetch(iChannel1, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n        } else if(ivec2(fragCoord) == ivec2(CAMERA_POS_SAMPLE,0)){\n            prevColor = texelFetch(iChannel1, ivec2(CAMERA_POS, 0), 0).xyz;\n        }\n        if(ivec2(fragCoord) == ivec2(TEXTURE_UPDATE,0)){\n            prevColor.r = 1.;\n        }\n    }\n    \n    \n    \n    // Write data/color.\n    fragColor = vec4(prevColor, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n// --Global variables.\n\n// Math.\n# define PI 3.1415926538\n\n// Input.\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SHIFT = 16;\nconst int KEY_CTRL  = 17;\nconst int KEY_SPACE  = 32;\nconst int KEY_W  = 87;\nconst int KEY_A = 65;\nconst int KEY_S  = 83;\nconst int KEY_D  = 68;\nconst int KEY_C  = 67;\nconst int KEY_V  = 86;\nconst int KEY_E  = 69;\nconst int KEY_R  = 82;\n\n//\nconst int PREVIOUS_TIME = 0;\nconst int PREVIOUS_TIME_TEMP = 1;\n\nconst int CAMERA_POS = 2;\nconst int CAMERA_SENSITIVITY = 3;\nconst int CAMERA_DIRECTION = 4;\nconst int CHANGE_SEED = 5;\n\nconst int CAMERA_POS_SAMPLE = 6;\nconst int CAMERA_POS_SAMPLE_2 = 7;\nconst int TEXTURE_UPDATE = 8;\n\n// TerrainGen.\nconst float MAP_WIDTH = 40.;\nconst float TERRAIN_UPDATE_RATE = 1.;\n\n// --Hash function--\n/*\nInspired by Adam Smith.\nsource: https://groups.google.com/forum/#!msg/proceduralcontent/AuvxuA1xqmE/T8t88r2rfUcJ\n*/\n# define PRECISION 3\n// 2^32-1\n# define LARGEST_UINT 4294967295u\n# define LARGEST_UINT_AS_FLOAT 4294967295.\n// 2^31-1 = 2147483647\n# define LARGEST_INT 2147483647\n# define LARGEST_INT_AS_FLOAT 2147483647.\n# define SMALLEST_INT -2147483648\n# define SMALLEST_INT_AS_FLOAT -2147483648.\n// 2^32 = 4294967296\n# define LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT 4294967296.\n\nint rotate (int x, int b) {\n    return (x << b) ^ (x >> (32-b));\n}\n\nint pcg (int a) {\n    int b = a;\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a) {\n    return (float(pcg(a))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d), 5);\n    }\n    return a^b;\n}\n\nfloat pcgUnit (int a, int b) {\n    return (float(pcg(a,b))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\nint pcg (int a, int b, int c) {\n    for (int i = 0; i < PRECISION; i++) {\n        a = rotate((a^0xcafebabe) + (b^0xfaceb00c) + (c^0xcabba6e5), 23);\n        b = rotate((a^0xdeadbeef) + (b^0x8badf00d) + (c^0x0b5e55ed), 5);\n        c = rotate((a^0x5eaf00d5) + (b^0xdecea5ed) + (c^0xba5eba11), 16);\n    }\n    // https://www.dcode.fr/words-containing\n    return a^b^c;\n}\n\nfloat pcgUnit (int a, int b, int c) {\n    return (float(pcg(a,b,c))-SMALLEST_INT_AS_FLOAT) / LARGEST_SMALLEST_INT_DIFFERENCE_AS_FLOAT;\n}\n\n// --GPU dependent noise--\n// https://stackoverflow.com/questions/4200224/random-noise-functions-for-glsl\nfloat rand(vec3 co){\n    return fract(sin(dot(co.xyz, vec3(12.9893, 78.233, 35.537))) * 43758.5453);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy, vec2(12.9893, 78.233))) * 43758.5453);\n}\n\n// --Noise functions--\nfloat boxNoise(vec3 pos, int seed){\n\tivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    //return mix(mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+0), pcgUnit(ind.x+1, ind.y+0, ind.z+0), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+0), pcgUnit(ind.x+1, ind.y+1, ind.z+0), u.x), u.y),\n    //           mix(mix( pcgUnit(ind.x+0, ind.y+0, ind.z+1), pcgUnit(ind.x+1, ind.y+0, ind.z+1), u.x),\n    //               mix( pcgUnit(ind.x+0, ind.y+1, ind.z+1), pcgUnit(ind.x+1, ind.y+1, ind.z+1), u.x), u.y), u.z);\n    \n    // Optimized version.\n    // 15485863 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    return mix(mix(mix( pcgUnit(ind.x + yS.x + zS.x, seed), pcgUnit(ind.x+1 + yS.x + zS.x, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.x, seed), pcgUnit(ind.x+1 + yS.y + zS.x, seed), u.x), u.y),\n               mix(mix( pcgUnit(ind.x + yS.x + zS.y, seed), pcgUnit(ind.x+1 + yS.x + zS.y, seed), u.x),\n                   mix( pcgUnit(ind.x + yS.y + zS.y, seed), pcgUnit(ind.x+1 + yS.y + zS.y, seed), u.x), u.y), u.z);\n}\nfloat boxNoise(vec3 pos){\n    return boxNoise(pos, 0);\n}\n\nfloat layeredBoxNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * boxNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\nfloat perlinNoise(vec3 pos, int seed){\n    ivec3 ind = ivec3(floor(pos));\n    \n    vec3 f = fract(pos);\n    \n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    f = f;\n    \n    // 2038074743 and 179424673 are primes.\n    ivec2 yS = ivec2(ind.y*15485863, (ind.y+1)*15485863);\n    ivec2 zS = ivec2(ind.z*179424673, (ind.z+1)*179424673);\n    \n    float nf = 2./float(0x3ff);\n    \n    int x0y0z0H = pcg(ind.x + yS.x + zS.x, seed);\n    float x0y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z0H)*nf-1.),\n            (float((0x000ffc00 & x0y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z0H) >> 20)*nf-1.)\n        ),\n        f\n    );\n    \n    int x1y0z0H = pcg(ind.x+1 + yS.x + zS.x, seed);\n    float x1y0z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z0H)*nf-1.),\n            (float((0x000ffc00 & x1y0z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z)\n    );\n    \n    int x0y1z0H = pcg(ind.x + yS.y + zS.x, seed);\n    float x0y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z0H)*nf-1.),\n            (float((0x000ffc00 & x0y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z)\n    );\n    \n    int x1y1z0H = pcg(ind.x+1 + yS.y + zS.x, seed);\n    float x1y1z0 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z0H)*nf-1.),\n            (float((0x000ffc00 & x1y1z0H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z0H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z)\n    );\n    \n    int x0y0z1H = pcg(ind.x + yS.x + zS.y, seed);\n    float x0y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y0z1H)*nf-1.),\n            (float((0x000ffc00 & x0y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y, f.z-1.)\n    );\n    \n    int x1y0z1H = pcg(ind.x+1 + yS.x + zS.y, seed);\n    float x1y0z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y0z1H)*nf-1.),\n            (float((0x000ffc00 & x1y0z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y0z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y, f.z-1.)\n    );\n    \n    int x0y1z1H = pcg(ind.x + yS.y + zS.y, seed);\n    float x0y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x0y1z1H)*nf-1.),\n            (float((0x000ffc00 & x0y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x0y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x, f.y-1., f.z-1.)\n    );\n    \n    int x1y1z1H = pcg(ind.x+1 + yS.y + zS.y, seed);\n    float x1y1z1 = dot(\n        vec3(\n            (float(0x000003ff & x1y1z1H)*nf-1.),\n            (float((0x000ffc00 & x1y1z1H) >> 10)*nf-1.),\n            (float((0x3ff00000 & x1y1z1H) >> 20)*nf-1.)\n        ),\n        vec3(f.x-1., f.y-1., f.z-1.)\n    );\n    \n    return mix(mix(mix( x0y0z0, x1y0z0, u.x),\n                   mix( x0y1z0, x1y1z0, u.x), u.y),\n               mix(mix( x0y0z1, x1y0z1, u.x),\n                   mix( x0y1z1, x1y1z1, u.x), u.y), u.z);\n}\n\nfloat perlinNoise(vec3 pos){\n    return perlinNoise(pos, 0);\n}\n\nfloat layeredPerlinNoise(vec3 pos, int numLayers, int seed){\n    seed = pcg(seed);\n\tfloat result = 0.;\n    float scale = 1.;\n    float denominator = 0.;\n    for (int i = 0; i < numLayers; i++) {\n        result += scale * perlinNoise(pos, ++seed);\n        denominator += scale;\n        pos *= 2.;\n        pos += PI*0.;\n        scale *= 0.5;\n    }\n    return result/denominator;\n}\n\n// --Signed distance functions. (SDF)--\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, inout float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\n// --Terrain functions--\n//\nfloat mountainHeightMap(in vec3 pos){\n    \n    float noise = layeredPerlinNoise(/*vec3 pos=*/pos*0.05*0.2, /*int numLayers=*/14, /*int seed=*/30)*15.*5.;\n    \n    return noise;\n    \n    // Alternative mountain noise.\n    //vec3 shifted = vec3(\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/0),\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/1),\n    //    layeredPerlinNoise(/*vec3 pos=*/pos*0.005, /*int numLayers=*/12, /*int seed=*/2)\n    //);\n    //return perlinNoise(/*vec3 pos=*/pos*0.01 + shifted*5., /*int seed=*/3)*30.;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "buffer_b_code": "\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 prevColor = texelFetch(iChannel1, ivec2(fragCoord.x, fragCoord.y), 0);\n    \n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x * MAP_WIDTH;\n    // uv.x is between -MAP_WIDTH/2 and +MAP_WIDTH/2.\n    // uv's x and y coordinates represent world x and z coordinates.\n    \n    bool textureUpdate = texelFetch(iChannel0, ivec2(TEXTURE_UPDATE, 0), 0).x > 0.5;\n    if(textureUpdate){\n        float l = length(uv);\n        if(l > 1.){\n            uv = uv*l;\n        }\n\n        vec3 cameraPosSampleA = texelFetch(iChannel0, ivec2(CAMERA_POS_SAMPLE, 0), 0).xyz;\n        float yShift = texelFetch(iChannel0, ivec2(CHANGE_SEED, 0), 0).x;\n        vec3 wcA = vec3(uv.x + cameraPosSampleA.x, yShift, uv.y + cameraPosSampleA.z);\n    \t\n        float heightA = mountainHeightMap(/*in vec3 pos=*/wcA);\n        \n    \tfragColor = vec4(heightA, prevColor.r, 0, 0);\n    } else {\n        \n        fragColor = prevColor;\n    }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 88, 88, 1007], [1009, 1009, 1039, 1039, 1319], [1321, 1321, 1358, 1358, 1645], [1647, 1647, 1715, 1715, 2030], [2032, 2032, 2107, 2107, 2449], [3145, 3145, 3172, 3172, 3657], [3659, 3659, 3726, 3726, 4028], [4098, 4098, 4313, 4371, 6344], [6346, 6346, 6401, 6504, 9739]], "test": "untested"}
{"id": "3lSSDd", "name": "Archimedes Spiral", "author": "timeisbeautifulhere", "description": "The spiraling shape will make you go insane\nBut everyone wants to see that groovy thing", "tags": ["spiral", "archimedes", "hypno", "hypnotize"], "likes": 8, "viewed": 839, "published": 3, "date": "1595894176", "time_retrieved": "2024-07-30T20:53:29.725188", "image_code": "#define PI 3.1415\n\n#define SPIRAL_A 0.0\n#define SPIRAL_B 0.05\n\n#define SPIRAL_WIDTH 0.1\n#define MAX_RADIUS 2.0\n\n//Enable or disable color\n#define COLOR_ENABLED true\n\n#define SPIN_RATE 4.0\n#define COLOR_RATE 0.1\n#define COLOR_RATE2 0.001\n#define COLOR_CONST 0.1\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//If on spiral, return number of degrees (theta).\n//If not on spiral, return -1.0\nfloat checkOnSpiral(vec2 pc, float a, float b){\n    \n    //Solve for spiral theta, given the distance of the\n    //polar coordinate (r = a+b*theta)\n    float theta = (pc[1]-a)/b;\n    \n    //If polar coordinate angle is aligned with theta,\n    //it is on the spiral\n   \tif(abs(pc[0]-mod(theta,2.0*PI)) < SPIRAL_WIDTH)\n        return theta;\n   \telse\n        return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //(-1,1)\n    vec2 uv=(2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    //polar coordinates\n    vec2 pc=vec2(\n        atan(uv.y, uv.x),\n        length(uv)\n    );\n    \n    //Time to hypnotize the viewer B)\n    pc[0]+=SPIN_RATE*iTime;\n    pc[0]=mod(pc[0], 2.0*PI);\n\n    vec3 col = vec3(0,0,0);\n    float spiral_degrees = checkOnSpiral(pc, SPIRAL_A, SPIRAL_B);\n    if(spiral_degrees>=0.0){\n        if(COLOR_ENABLED){\n            \n            //Don't ask me to explain what I just did here\n        \tfloat rate = mod(COLOR_RATE+(iTime*COLOR_RATE2), 2.0*PI);\n        \tfloat r = fract(spiral_degrees*rate);\n        \tfloat g = fract(spiral_degrees*(rate+COLOR_CONST));\n        \tfloat b = fract(spiral_degrees*(rate+COLOR_CONST+COLOR_CONST));\n        \tcol = vec3(r,g, b);\n        }else{\n            col = vec3(1.0,1.0,1.0);\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSSDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[262, 395, 442, 542, 765], [767, 767, 824, 837, 1725]], "test": "untested"}
{"id": "tlsfRr", "name": "Black and White Shader", "author": "t420babe", "description": "ALL BLACK UP UNTIL 9.0s\n\nYoutube video: https://youtu.be/usVxTeldjT4\nYoutube video of live code: https://youtu.be/cJkWkwR7FUM\n\nMusic: Bright Lights in Silent Rooms by Home\n\nHUGE thanks to @FabriceNeyret2 for helping me with resolution & antialiasing", "tags": ["blackandwhite"], "likes": 0, "viewed": 339, "published": 3, "date": "1595890795", "time_retrieved": "2024-07-30T20:53:30.497124", "image_code": "#define SCENE(a, b, t) smoothfloor(t * 0.5 + a * t / b ) * b - a;\n#define CURVE(f) vec3(smoothstep(-0.75, 0.75, (f - 0.1) / fwidth(f)))\n#define SmoothWidth .2\n\n/* Smoothfloor function by FabriceNeyret2: https://www.shadertoy.com/view/4t3SD7 */\nfloat smoothfloor(float x) {\n#if 1\n    float F = floor(x), \n          f = clamp( 1.-(1.-fract(x))/SmoothWidth, 0.,1.);\n   \n    return F + smoothstep(0.,1., f) ;                    // C1   NB: 3.x^2 - 2.x^3\n#else\n  #define b(x) ( abs(x)>1. ? sign(x) : (x) * (3.-(x)*(x) ) /2. )  // (3x-x^3)/2\n  return floor(x-.5)+.5 + .5 * b( ( mod(2.*x-1.,2.) -1. ) / SmoothWidth ) ; // C1\n#endif\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n  // [-1, 1]\n  vec2 pos = (2.0 * fragCoord - iResolution.xy) /iResolution.y;\n\n\n  float song_duration = 193.0;  // seconds\n  float mod_time = mod(iTime, song_duration);\n  float time_scale = 0.5;\n  float time = tan(time_scale * mod_time);\n    \n  vec3 color = vec3(0.0);\n  float curve = 0.0;\n  \n  int N = 50;\n  float a = atan(pos.x, pos.y);\n  float b = 6.28319 / float(N);\n  float curve_param = SCENE(a, b, time);\n    \n\n  if ((mod_time >= 9.0 && mod_time < 26.0) || \n      (mod_time >= 80.0 && mod_time < 98.0)) {\n      \n    // Scene 0\n    curve = sin(curve_param) * length(pos.xy);\n        \n  } else if (mod_time >= 26.0 && mod_time < 44.0) {\n      \n    // Scene 1\n    curve = asin(curve_param) * length(pos.xy);\n        \n  } else if ((mod_time >= 44.0 && mod_time < 62.0) ||\n    \t\t(mod_time >= 98.0 && mod_time < 115.0) || \n   \t\t    (mod_time >= 169.0) ) {\n      \n    // Scene 2\n    curve = atan(curve_param) * length(pos.xy);\n        \n  } else if ((mod_time >= 62.0 && mod_time < 80.0) ||\n            (mod_time >= 115.0 && mod_time < 134.0)) {\n      \n    // Scene 3\n    curve = cos(curve_param) * length(pos.xy);\n        \n  } else if (mod_time >= 134.0 && mod_time < 169.0) {\n      \n    // Scene 4\n    curve = tan(curve_param) * length(pos.xy);\n        \n  }\n    \n  color = CURVE(curve);\t\n    \n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 23496, "src": "https://soundcloud.com/home-2001/bright-lights-in-silent-rooms", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsfRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[160, 244, 272, 272, 626], [629, 629, 686, 703, 2017]], "test": "untested"}
{"id": "wtsBRr", "name": "Purwins reaction diffusion balls", "author": "davidjonsson", "description": "Seed with mouse clicks. After 15 minutes 4 to 6 slowly moving red balls have formed around the green seed with faint green tails.", "tags": ["diffusion", "moving", "reaction", "solitons", "puwins"], "likes": 0, "viewed": 206, "published": 3, "date": "1595890163", "time_retrieved": "2024-07-30T20:53:31.329898", "image_code": "void mainImage( out vec4 Q, in vec2 U )\n{\n    Q = A(U)/3. + vec4(vec3(0.5), .0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*  From https://www.youtube.com/watch?v=QJB1Jsk_oTE\n*   C. P. Schenk, A. W. Liehr, M. Bode, and H.-G. Purwins (1999) \n*   \"Quasi-Particles in a Three-Dimensional Three-Component Reaction-Diffusion System\" \n*   High Performance Computing in Science and Engineering, pp. 354-364.\n*\n*   Seed with mouse clicks. After 15 minutes 4 to 6 slowly moving red balls have formed around the green seed\n*   with faint green tails.\n*/\n\nvoid mainImage( out vec4 Q, in vec2 U )\n{\n    // Lookup Field \n    Q = A(U);\n    // Mean Field \n\n    // Two way: horizontal, vertical\n    vec4 sum2 = A(U+vec2(0,1))+A(U+vec2(1,0))+A(U-vec2(0,1))+A(U-vec2(1,0));\n    \n    // Four way: both diagonals\n    vec4 sumDiagonals = A(U+vec2(1,1))+A(U+vec2(1,-1))+A(U+vec2(-1,1))+A(U+vec2(-1,-1));\n    \n    // dots 2 pixel away: adding quarter of the remaining 4 because of double distance\n    vec4 sum9to12closest = A(U+vec2(0,2))+A(U+vec2(2,0))+A(U+vec2(0,-2))+A(U+vec2(-2,0));\n   \n    // 13-20 closest point: adding 1/(1^2 + 2^2) of the remaining 8 because of increased distance\n    vec4 sum13to20closest = A(U+vec2(1,2))+A(U+vec2(2,1))+A(U+vec2(1,-2))+A(U+vec2(-2,1)) + \n                            A(U+vec2(-1,2))+A(U+vec2(2,-1))+A(U+vec2(-1,-2))+A(U+vec2(-2,-1));\n    vec4 mean20closest = 1. / (4. + 4./2. + 4./4. + 8./5.) * (sum2 + 1. / 2. * sumDiagonals + 1. / 4. * sum9to12closest + 1. /5. * sum13to20closest);\n\t// Laplacian \n    vec4 laplacian20closest = (mean20closest - Q);\n    \n    // Diffuse each variable differently : \n    Q.r += timestep * (D_a * laplacian20closest.r /dx/dx - A(U).g - k3 * A(U).b + lambda * A(U).r - A(U).r * A(U).r * A(U).r + k1);\n    Q.g += timestep * (D_b * laplacian20closest.g /dx/dx + A(U).r - A(U).g) / tau;\n    Q.b += timestep * (D_c * laplacian20closest.b /dx/dx + A(U).r - A(U).b) / theta;\n\n    // Mouse to seed\n    if (iMouse.z > 0.) {\n        Q += step(length(U - iMouse.xy), seedRadius) * vec4(1.3, 0., 0., 0.);\n        Q += step(length(U - iMouse.xy - vec2(seedRadius, 0)), seedRadius) * vec4(0., 1.3, 0., 0.);\n    }\n    if (iTime < 1.) {\n    \tQ.rgb = vec3(-.84);\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define A(U) texture(iChannel0,(U)/iResolution.xy)\n\n#define D_a 0.00015\n#define D_b 0.00015\n#define D_c 0.0096 /* N.B. typo in paper */\n#define k3 8.5\n#define lambda 2.0\n#define k1 -6.92\n#define theta 1.0\n#define tau 48.0\n#define dx 0.002 /* grid discretization */\n/*#define timestep 0.0001 */ /* time discretization */\n#define timestep 0.00062 /* time discretization */\n#define seedRadius 35.\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtsBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 82]], "test": "untested"}
{"id": "ttsBRr", "name": "Rainbow Warp", "author": "t420babe", "description": "Three modifications of rainbow using tangent and cosine functions. Each design runs for 10 seconds", "tags": ["rainbow"], "likes": 1, "viewed": 226, "published": 3, "date": "1595888333", "time_retrieved": "2024-07-30T20:53:32.168655", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 rainbow_warp(vec2 pos) {\n  vec3 color = vec3(0.0);\n\n  float speed = 1.0;\n  float zoom = 1.25;\n  pos *= zoom;\n\n  float mod_time = mod(iTime, 30.0);\n  vec2 denominator = vec2(2.0, 10.0);\n    \n   if (mod_time < 10.0) {\n        denominator =vec2(20.0, 100.0);\n   } else if(mod_time < 20.0) {\n        denominator = vec2(1.0, 1.0);\n   }\n  vec2 movement = vec2(13.0, iTime);\n\n  for (int i = 1; i < 3; i++) {\n    pos.x += 0.03 / float(i) * tan(float(i) * 5.0 * pos.y + iTime / speed) + movement.x/ denominator.x;\n    pos.y += 0.5 / float(i) * cos(float(i) * 3.0 * pos.x + iTime * speed) + movement.y / denominator.y;\n  }\n\n  float g = cos(pos.y + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.x + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x * pos.y) + tan(pos.y + pos.x)) * 0.5 + 0.5;\n\n  return vec3(g, b, r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_warp(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttsBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 73, 73, 856], [859, 859, 916, 969, 1087]], "test": "untested"}
{"id": "tllBRr", "name": "Rainbow Swirl Crinkle", "author": "t420babe", "description": "Rainbow swirl with tan and cos", "tags": ["rainbow"], "likes": 1, "viewed": 219, "published": 3, "date": "1595887338", "time_retrieved": "2024-07-30T20:53:33.113130", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\nvec3 rainbow_swirl_crinkle(vec2 pos) {\n  vec3 color = vec3(0.0);\n\n  float speed = 1.1;\n  float zoom = 1.0;\n  pos *= zoom;\n\n  vec2 movement = vec2(iTime, 1.0);\n\n  for (int i = 1; i < 3; i++) {\n    pos.x += 0.5 / float(i) * tan(float(i) * 5.0 * pos.y + iTime / speed) + movement.x/ 20.00;\n    pos.y -= 1.5 / float(i) * cos(float(i) * 15.5 * pos.x + iTime / speed) + movement.y / 30.0;\n  }\n\n  float g = cos(pos.y + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.x + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x * pos.y) + tan(pos.y + pos.x)) * 0.5 + 0.5;\n\n  return vec3(g, b, r);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_swirl_crinkle(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 82, 82, 625], [628, 628, 685, 738, 865]], "test": "untested"}
{"id": "ttlBRr", "name": "rotate0", "author": "pohy", "description": "rotate0", "tags": ["rotate0"], "likes": 0, "viewed": 190, "published": 3, "date": "1595886714", "time_retrieved": "2024-07-30T20:53:33.983802", "image_code": "vec2 rotate(vec2 v, float a) {\n    float s = sin(a);\n    float c = cos(a);\n    mat2 m = mat2(c, -s, s, c);\n    return m * v;\n}\n\nfloat posSin(float x) {\n    return sin(x) * .5 + .5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n    vec2 mouse = (iMouse.xy - iResolution.xy * .5) / iResolution.y;\n    \n    \n    //uv *= .5;\n\n    // Time varying pixel color\n    vec3 col;\n    \n    float c = 25.;\n    for (float i = 1.; i < c; i++) {\n\t\tfloat it = ((c - i) / c);\n        //vec2 pos = vec2(1. + float(i) * .1, .0);\n        //uv += pos;\n        float angle = posSin(iTime * .005) * 3.1415 * 4. * mod(i, 2.);//mouse.x * 3.1415;\n        vec2 rotUv = rotate(uv, angle);\n        \n        vec2 fractUv = uv;\n        fractUv *= 1.2;\n    \tfractUv = fract(fractUv) * sign(fractUv);\n        fractUv *= .9;\n        \n        //uv = mix(rotUv, fractUv, .1);\n        uv = rotUv;\n\n        float size = (i / c);// * (1. + posSin(iTime) * .2);\n        float d = length(uv - vec2(clamp(uv.x, -size, size), clamp(uv.y, -size, size)));\n        float rect = smoothstep(.001, .0, d) * it;\n        //vec3 color = vec3(it * posSin(iTime * i) * .1);\n        vec3 color = vec3(.1, .1 * mod(i, 2.), 1. * posSin(iTime * i * .1) * it);// * mod(iTime * .1, 1.);\n\n        col += color * rect;\n        //col += ((c - i) / c);\n    }\n    \n    \n    //col += d;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttlBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 126], [128, 128, 151, 151, 182], [184, 184, 241, 291, 1506]], "test": "untested"}
{"id": "wlsfzn", "name": "Rainbow Scales", "author": "t420babe", "description": "Rainbow with a tan overlay that reminds me of scales", "tags": ["rainbow"], "likes": 4, "viewed": 259, "published": 3, "date": "1595886081", "time_retrieved": "2024-07-30T20:53:34.809594", "image_code": "\n#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n\nvec3 rainbow_scales(vec2 pos) {\n\n  float speed = 0.5;\n  float zoom = 4.0;\n  pos *= zoom;\n    \n  // vec2 movement = u_mouse;\n  float mod_time = mod(iTime, 400.0);\n  vec2 movement = vec2(mod_time * 4.0, 500.0);\n\n  for (int i = 1; i < 5; i++) {\n    pos.x += 0.003 / float(i) * tan(float(i) * 3.0 * pos.y + iTime / speed) + movement.x/ 20.0;\n    //pos.y += 0.3 / float(i) * cos(float(i) * 3.0 * pos.x + iTime * speed) + movement.y / 1000.0;\n    pos.y += 0.003 / float(i) * tan(float(i) * 3.0 * pos.x + iTime / speed) + movement.y / 10.0;\n  }\n\n  float g = cos(pos.x + pos.y + 1.0) * 0.5 + 0.5;\n  float b = sin(pos.x + pos.y + 1.0) * 0.5 + 0.5;\n  float r = (tan(pos.x + pos.y) + tan(pos.x + pos.y)) * 0.5 + 0.5;\n\n  return vec3(r, g, b);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n \t// Normalized pixel coordinates (from 0 to 1)\n    vec2 pos = fragCoord/iResolution.xy;\n    \n    vec3 color = rainbow_scales(pos);\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsfzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 78, 78, 779], [783, 783, 840, 893, 1013]], "test": "untested"}
{"id": "3lXfzr", "name": "Center flow", "author": "michael0884", "description": "Obfuscated code and new rendering", "tags": ["particles", "ca"], "likes": 36, "viewed": 793, "published": 3, "date": "1595884427", "time_retrieved": "2024-07-30T20:53:35.661317", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n   \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    //how much mass falls into this pixel\n    vec4 rho = vec4(V, M, 1.)*GS((pos - X)/0.5); \n    vec3 dx = vec3(-3., 0., 3.);\n\n    float ang = atan(V.x, V.y);\n    float mag = 0. + 3.*length(V.xy)*rho.z;\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    // Output to screen\n    col.xyz += 0.2*a;\n    col.xyz += 0.5 - 0.5*cos(2.*vec3(0.3,0.5,1.)*mix(rho.w,rho.z,0.));\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5))) + hsv2rgb(vec3(5.*ang/PI, 1.2, mag));\n    col.w=1.0;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define T(p) texelFetch(iChannel0, ivec2(mod(p,R)), 0)\n#define P(p) texture(iChannel0, mod(p,R)/R)\n\n#define PI 3.14159265\n#define dt 1.5\n#define R iResolution.xy\n\n//mold stuff \n#define sense_ang 0.4\n#define sense_dis 2.5\n#define sense_force 0.1\n#define trailing 0.\n#define acceleration 0.01\n\n//SPH pressure\n#define Pressure(rho) 1.*rho\n#define fluid_rho 0.2\n\n//useful functions\n#define GS(x) exp(-dot(x,x))\n#define GS0(x) exp(-length(x))\n#define Dir(ang) vec2(cos(ang), sin(ang))\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n//data packing\n#define PACK(X) ( uint(round(65534.0*clamp(0.5*X.x+0.5, 0., 1.))) + \\\n           65535u*uint(round(65534.0*clamp(0.5*X.y+0.5, 0., 1.))) )   \n               \n#define UNPACK(X) (clamp(vec2(X%65535u, X/65535u)/65534.0, 0.,1.)*2.0 - 1.0)              \n\n#define DECODE(X) UNPACK(floatBitsToUint(X))\n#define ENCODE(X) uintBitsToFloat(PACK(X))", "buffer_a_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n    \n    vec2 X = vec2(0);\n    vec2 V = vec2(0);\n    float M = 0.;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = T(tpos);\n       \n        vec2 X0 = DECODE(data.x) + tpos;\n    \tvec2 V0 = DECODE(data.y);\n    \tvec2 M0 = data.zw;\n       \n        X0 += V0*dt; //integrate position\n\n        //particle distribution size\n        float K = 1.3;\n        \n        vec4 aabbX = vec4(max(pos - 0.5, X0 - K*0.5), min(pos + 0.5, X0 + K*0.5)); //overlap aabb\n        vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n        vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n        \n        //the deposited mass into this cell\n        float m = M0.x*size.x*size.y/(K*K); \n        \n        //add weighted by mass\n        X += center*m;\n        V += V0*m;\n      \n        //add mass\n        M += m;\n    }\n    \n    //normalization\n    if(M != 0.)\n    {\n        X /= M;\n        V /= M;\n    }\n    \n    //initial condition\n    if(iFrame < 1)\n    {\n        X = pos;\n        V = vec2(0.);\n        M = 1e-6;\n    }\n    \n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = T(pos); \n    vec2 X = DECODE(data.x) + pos;\n    vec2 V = DECODE(data.y);\n    float M = data.z;\n    \n    if(M != 0.) //not vacuum\n    {\n        //Compute the SPH force\n        vec2 F = vec2(0.);\n        vec3 avgV = vec3(0.);\n        range(i, -2, 2) range(j, -2, 2)\n        {\n            vec2 tpos = pos + vec2(i,j);\n            vec4 data = T(tpos);\n\n            vec2 X0 = DECODE(data.x) + tpos;\n            vec2 V0 = DECODE(data.y);\n            float M0 = data.z;\n            vec2 dx = X0 - X;\n            \n            float avgP = 0.5*M0*(Pressure(M) + Pressure(M0)); \n            F -= 0.5*GS(1.*dx)*avgP*dx;\n            avgV += M0*GS(1.*dx)*vec3(V0,1.);\n        }\n        avgV.xy /= avgV.z;\n\n        //slime mold sensors\n        float ang = atan(V.y, V.x);\n        vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n        vec2 sd = vec2(P(X + dir.xy).z, P(X + dir.zw).z);\n        F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n\n        //integrate velocity\n        V += F*dt/M;\n        \n        //acceleration for fun effects\n        V *= 1. + acceleration;\n        \n        //velocity limit\n        float v = length(V);\n        V /= (v > 1.)?1.*v:1.;\n    }\n    \n    //mass decay\n    M *= 0.99;\n    \n    //input\n    if(iMouse.z > 0.)\n    \tM = mix(M, 0.5, GS((pos - iMouse.xy)/13.));\n    else\n        M = mix(M, 0.5, GS((pos - R*0.5)/13.));\n    \n    //save\n    X = clamp(X - pos, vec2(-0.5), vec2(0.5));\n    U = vec4(ENCODE(X), ENCODE(V), M, 0.);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lXfzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [404, 404, 449, 449, 1125]], "test": "untested"}
{"id": "tlsBzn", "name": "Japanese Summer", "author": "butadiene", "description": "Japanese Summer, hurin", "tags": ["raymarching"], "likes": 9, "viewed": 355, "published": 3, "date": "1595880539", "time_retrieved": "2024-07-30T20:53:36.668623", "image_code": "float PI = 3.141592;\n\nmat2 rot(float r){\n  return mat2(cos(r),sin(r),-sin(r),cos(r));\n}\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    vec2 u = f * f * (3.0 - 2.0 * f);\n\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n#define OCTAVES 6\nfloat fbm (in vec2 st) {\n    float value = 0.0;\n    float amplitude = .5;\n    float frequency = 0.;\n\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitude * noise(st);\n        st *= 2.;\n        amplitude *= .5;\n    }\n    return value;\n}\n\nfloat cylin( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat hashira(vec3 p,vec2 s){\n  vec2 q = abs(p.xz);\n  vec2 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(m.x,m.y);\n}\n\nfloat box(vec3 p,vec3 s){\n  vec3 q = abs(p);\n  vec3 m = max(s-q,0.);\n  return length(max(q-s,0.))-min(min(m.x,m.y),m.z);\n}\n\nfloat cup(vec3 p){\n  p.xy *= rot(PI);\n  p.y += 0.4;\n  float sd = abs(length(p)-0.4)-0.01;\n  float bd = box(p-vec3(0,-0.45,0),vec3(0.9,0.2,0.9));\n  return max(sd,-bd);\n}\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\nfloat dot2( in vec2 v ) { return dot(v,v); }\nvec4 sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n    \n    // if perfectly straight\n    if( abs(a)<0.001 ) return vec4( length(p-vec3(0,clamp(p.y,0.0,l),0))-w, p );\n    \n    // parameters\n    vec2  sc = vec2(sin(a),cos(a));\n    float ra = 0.5*l/a;\n    \n    // recenter\n    p.x -= ra;\n    \n    // reflect\n    vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n\n    float u = abs(ra)-length(q);\n    float d2 = (q.y<0.0) ? dot2( q+vec2(ra,0.0) ) : u*u;\n    float s = sign(a);\n    return vec4( sqrt(d2+p.z*p.z)-w,\n                 (p.y>0.0) ? s*u : s*sign(-p.x)*(q.x+ra),\n                 (p.y>0.0) ? atan(s*p.y,-s*p.x)*ra : (s*p.x<0.0)?p.y:l-p.y,\n                 p.z );\n}\n\n\nvec4 rope1(vec3 p){\n     p.y += 1.;\n   p.x -= 1.;\n   p.yz *= rot(PI);\n\n   float an2 = 0.1*sin(iTime*1.9)*exp(fract(iTime*1.9/(PI*2.)))-0.2;\n   float le2 = 0.6;\n   float wi2 = 0.01;\n   vec4 d4 = sdJoint3DSphere(p, le2, an2, wi2 );\n   p.xy*= rot(-an2);\n   p -= vec3(0,le2/an2*sin(an2),0);\n   p.xy*= rot(-an2);\n   return vec4(p,d4.x);\n}\n\nvec4 cup1(vec3 p1){\n   vec4 rope1obj = rope1(p1);\n  vec3  p = rope1obj.xyz;\n   float d4 = rope1obj.w;\n   float scup = 1.6;\n   float d0 = cup(p*scup)/scup;\n   return vec4(p,min(d0,d4));\n}\n\nvec4 rope2(vec3 p1){\n  vec4 cupobj = cup1(p1);\n vec3  p = cupobj.xyz;\n  float d0 = cupobj.w;\n   p.xy *= rot(0.1*sin(iTime));\n   float an = 0.1*sin(iTime*2.)*exp(fract(iTime*2./(PI*2.)))-0.15;\n   float le = 1.2;\n   float wi = 0.01;\n   vec4 d1 = sdJoint3DSphere(p, le, an, wi );\n   p.xy*= rot(-an);\n   p -= vec3(0,le/an*sin(an),0);\n   p.xy*= rot(-an);\n   p.xz *= rot(iTime*4.+pow(abs(sin(iTime)),4.)*iTime*6.);\n   return vec4(p,min(d1.x,d0));\n}\n\nvec4 paper1(vec3 p1){\n     vec4 rope2obj = rope2(p1);\n  vec3 p = rope2obj.xyz;\n   float d1 = rope2obj.w;\n    float planex = 0.4;\n   float d2 = box(p-vec3(0,planex,0),vec3(0.01,planex,0.1));\n   return vec4(p,min(d2,d1));\n}\n\nfloat hurin(vec3 p){\n \n  \n\n vec4 paper1obj = paper1(p);\n p = paper1obj.xyz;\n float d2 = paper1obj.w;\n  //p.yz *= rot(time);\n  return d2;\n}\n\nfloat ueno(vec3 p){\n  vec3 sp = p;\n  sp.xy *=rot(0.5*PI);\n  sp.x = abs(sp.x)-0.8;\n  float d1 = hashira(sp,vec2(0.2,0.2));\n  sp = p;\n  float spkx = 2.6;\n  sp.x = mod(sp.x,spkx)-0.5*spkx;\n  float d2 = box(sp,vec3(0.1,0.8,0.2));\n  float d3 = box(p-vec3(0,1.8,0),vec3(100,0.2,3));\n  return min(min(d1,d2),d3);\n}\n\nfloat door(vec3 sp){\n  return box(sp-vec3(-7,-4,0),vec3(5,3,0.15));\n}\n\nfloat ana(vec3 p){\n  p.x += 0.2;\n  p.y +=0.15;\n  float k = 0.9;\n  p.xy = mod(p.xy,k)-0.5*k;\n  p.z = abs(p.z)-1.;\n  float d0 = box(p,vec3(0.38,0.38,0.95));\n  return d0;\n}\n\nfloat dist(vec3 p){\n  float d0 = ueno(p);\n  float d3 = door(p);\n  d3 = max(d3,-ana(p));\n\n  return min(min(d0,d3),hurin(p));\n}\n\nvec3 getNormal(vec3 p){\n  vec2 e = vec2(0.001,0.);\n  return normalize(vec3(\n    dist(p+e.xyy)-dist(p-e.xyy),\n    dist(p+e.yxy)-dist(p-e.yxy),\n    dist(p+e.yyx)-dist(p-e.yyx)\n    ));\n}\n\nvec3 woodoorlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(p.xy*1.+p.z*0.3);\n  float nof2 = fbm(20.+p.xy*2.+.4*p.z);\n  vec3 alb = vec3(218.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2||mod(nof2*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 wooduplight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .5;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  float nof = fbm(40.+p.xy*1.+p.z*0.3);\n  float nof2 = fbm(30.+p.xy*2.+.4*p.z);\n  vec3 alb = 0.4*vec3(288.,143.,143.)/255.*(0.2+0.8*nof);\n  if(mod(nof*10.0,2.0)<0.2){\n    alb =vec3(0,0,0);\n  }\n  return dif*alb;\n}\n\nvec3 paperlight(vec3 p,vec3 ld,vec3 normal,vec3 vd){\n  float alp = .1;\n  float dif = pow((alp*max(dot(normal,ld),0.)+(1.-alp)),2.);\n  vec3 alb = vec3(1.0);\n  return dif*alb;\n}\n\nvec3 sky(vec3 vd,vec3 ld){\n  float dalp = pow(dot(ld,vd),6.);\n  vec3 blue = normalize(vec3(0.1,0.2,1.));\n  vec3 white = vec3(1);\n  vec3 scol= mix(blue,white,dalp);\n  float fbmem = fbm(6.*vd.yx+iTime*0.1);\n  return mix(vec3(0.1,0.3,0.9),scol+fbmem,clamp(vd.y*2.,0.,1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\nvec2 uv = fragCoord/iResolution.xy;\n    \n    \nvec2 r=iResolution.xy,p=(fragCoord.xy*2.-r)/min(r.x,r.y);\nvec2 pix = vec2(min(iResolution.x,iResolution.y)/64.);\n//p = floor(p*pix)/pix;\nvec3 ta = vec3(0,-2,0);\nvec3 ro = vec3(2,-3,5);\nro -= 1.0*(ta-ro);\nvec3 cdir = normalize(ta-ro);\nvec3 side = cross(cdir,vec3(0,1,0));\nvec3 up = cross(side,cdir);\nfloat fov = 3.0;\nvec3 fcol = vec3(0);\nvec2 glv =vec2(0.0);//floor(gl_FragCoord.xy/2.);\n#define bokashi 8\nfor(int i = 0;i<bokashi;i++){\n  float fi = float(i);\n  vec3 rd = normalize(side*p.x+up*p.y+fov*cdir)+0.008*(vec3(random(vec2(glv+fi+200.)),random(vec2(glv+fi+100.)),random(glv+vec2(fi)))-vec3(0.5));\n  float d,t =0.;\n  float maxdis = 1000.;\n  float mindis = 0.001;\n  \n  for(int i = 0;i<34;i++){\n     d = dist(ro+rd*t);\n     t += d;\n     if(d<mindis||t>maxdis)break;\n  }\n   \n  vec3 col = vec3(0);\n  vec3 sp = ro+rd*t;\n  vec3 ld = normalize(vec3(0.5,1,-1));\n  vec3 vd = rd;\n  vec3 nor = getNormal(sp);\n  if(d<mindis){\n    col = abs(nor);\n    if(door(sp)<mindis){\n      col=woodoorlight(sp,ld,nor,vd);\n      if(0.1>abs(sp.z)&&(ana(sp)<mindis&&abs(nor.z)>0.9)){\n        col = paperlight(sp,ld,nor,vd);\n      }\n    };\n    if(ueno(sp)<mindis){\n    col=wooduplight(sp,ld,nor,vd);\n    }\n    if(rope1(sp).w<mindis){\n      col = clamp(mix(vec3(0.2,0.8,0.8),vec3(1,0.4,0.4),+0.25-rope1(sp).y),0.,1.);\n    }else if(cup1(sp).w<mindis){\n      vec3 scp = rope1(sp).xyz;\n      col = clamp(0.8-scp.yyy,0.,1.)*vec3(0.5,1.,1.5)+vec3(1,0,0)*step(fbm(scp.xy*20.),0.52);\n    }else if(rope2(sp).w<mindis){\n      col = vec3(0.2,0.8,0.8);\n    }else if(paper1(sp).w<mindis){\n      col = clamp(mix(vec3(1),vec3(1,0.4,0.4),paper1(sp).y),0.,1.);\n    }\n  }\n  else{\n    col = sky(vd,ld);\n  }\n  fcol += col;\n}\nfcol = fcol/float(bokashi);\n//col = abs(nor);\n//col = pow(col,vec3(1./2.2));\n\n\n\nfragColor=vec4(fcol,1);}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 87], [89, 89, 116, 116, 223], [225, 225, 251, 251, 595], [615, 615, 639, 639, 864], [866, 866, 907, 907, 966], [968, 968, 997, 997, 1088], [1090, 1090, 1115, 1115, 1212], [1214, 1214, 1232, 1232, 1382], [1384, 1437, 1462, 1462, 1481], [1482, 1482, 1552, 1586, 2167], [2170, 2170, 2189, 2189, 2503], [2505, 2505, 2524, 2524, 2691], [2693, 2693, 2713, 2713, 3135], [3137, 3137, 3158, 3158, 3358], [3360, 3360, 3380, 3380, 3498], [3500, 3500, 3519, 3519, 3807], [3809, 3809, 3829, 3829, 3878], [3880, 3880, 3898, 3898, 4049], [4051, 4051, 4070, 4070, 4176], [4178, 4178, 4201, 4201, 4361], [4363, 4363, 4417, 4417, 4725], [4727, 4727, 4780, 4780, 5072], [5074, 5074, 5126, 5126, 5249], [5251, 5251, 5277, 5277, 5523], [5525, 5525, 5582, 5632, 7464]], "test": "untested"}
{"id": "wllBRn", "name": "SlitScan Effect", "author": "flyingrub", "description": "Try at slit scan", "tags": ["slitscan"], "likes": 12, "viewed": 991, "published": 3, "date": "1595876470", "time_retrieved": "2024-07-30T20:53:40.354768", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 2.0;\n    float split = 0.5;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tvec4 video = texture(iChannel0, uv);\n    float pixel_w = 1.0 / iResolution.x;\n    \n    uv.x -= pixel_w * speed;\n\tvec4 buffer = texture(iChannel1, uv);\n       \n  \tfloat effect_mask = step(uv.x, split);\n    \n    fragColor = mix(buffer, video, effect_mask); \n}", "buffer_a_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wllBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 136]], "test": "untested"}
{"id": "wtlBRn", "name": "3D Shockwave Effect", "author": "Leria", "description": "3D Shockwave effect with density alteration on the edges\n", "tags": ["noise", "raymarch", "shockwave", "energy"], "likes": 2, "viewed": 508, "published": 3, "date": "1595875322", "time_retrieved": "2024-07-30T20:53:41.691194", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.2\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif    \n    \n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 5.0), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s <90; s++)\n    {               \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        float d = length(center)-RADIUS-.5-jit*k;\n        float size = length(center)/RADIUS;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR            \n            float anim = 0.;\n            #if ANIM\n            anim = iTime/4.;\n            #endif\n            float n = fbm( ( \n                p/( clamp(0., RADIUS, length(center)) + cos(PI+snoise(p)) - anim ) //shockwave stuff\n            \t\t\t) )  ;\n            \n\n            float mask = smoothstep(1.,\n                                   \t40.*RADIUS,\n                                  \tRADIUS/length(center));\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n);\n            \n           if(length(p-cam.pos) >(dist_center+m.radius) || \n           (k*dens  < -9.9))\n        \t{\n         \tbreak;\n        \t}\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 20. * dens, \n                      \tk * 10. * dens,\n              \t      \tk * 25. * dens));    \n            \n            t_acc *= (rgb_t);           \n    \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n            \n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;        \n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1460, 1460, 1485, 1498, 1872], [1874, 1874, 1899, 1912, 2271], [2273, 2273, 2292, 2292, 2385], [2387, 2406, 2482, 2482, 2529], [2531, 2531, 2563, 2563, 2583], [2585, 2585, 2619, 2619, 2641], [2728, 2728, 2769, 2769, 2805], [2807, 2807, 2893, 2893, 2928], [2930, 2930, 2973, 2973, 3013], [3015, 3015, 3039, 3039, 3087], [3089, 3089, 3129, 3129, 3433], [3435, 3435, 3459, 3459, 3523], [3526, 3526, 3578, 3578, 6137], [6140, 6140, 6197, 6197, 6826]], "test": "untested"}
{"id": "3lsfRn", "name": "pattern4", "author": "Ausfragezeichen", "description": "what", "tags": ["what"], "likes": 2, "viewed": 268, "published": 3, "date": "1595853761", "time_retrieved": "2024-07-30T20:53:42.662597", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //constants\n    float pi     = 3.14159265359;\n    //float piHalf = 1.57079632679;\n    \n    //variables\n    float zoom = 4.;\n    float speed = 0.125; //rotation speed\n    float space =3.;\n    float radius = 1.;\n    \n    \n    vec2 uv = (fragCoord *2. - iResolution.xy)/iResolution.y;\n    \n    uv *= zoom;\n    \n    vec2 gv = fract(uv);\n    \n    gv *= space;\n    gv -= space/2.;\n    \n    vec3 col = vec3(0.);\n       \n    float cycle = fract(iTime * speed); // from 0. to 1.\n    float alpha = cycle * 2. * pi; // alpha in rad from 0 to 2*pi\n    \n    vec3 coord3D = vec3(gv.x, gv.y, gv.x*gv.y); //start with slice at z=0.\n    //coord3D = vec3();\n    \n    float dist = coord3D.x * coord3D.x + coord3D.y * coord3D.y + coord3D.z * coord3D.z; //!? sqrt missing?\n    \n    float c1 = fract(iTime * speed);\n    float a1 = c1 * 2. * pi; \n    float f1 = sin(a1+gv.x)-cos(a1+gv.y);\n    coord3D.x += uv.x*f1;\n    coord3D.y += uv.y*f1;\n    coord3D.z *= coord3D.z+f1;\n    \n    float c2 = fract(iTime * speed * 0.5);\n    float a2 = c2 * 2. * pi; \n    float f2 = cos(a2+gv.x)+sin(a2+gv.y);\n    coord3D.x += uv.x*f2;\n    coord3D.y += uv.y*f2;\n    coord3D.z += coord3D.z*f2;\n    \n    float lenght3D = length(coord3D);\n    \n    if(lenght3D < radius){\n        col = vec3(coord3D.x, coord3D.y, coord3D.z);\n    }\n\n    //col += vec3(gv, 0.);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lsfRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 73, 1432]], "test": "untested"}
{"id": "3tlBRn", "name": "Retro Vibes: Cyber Ghosts", "author": "NoxWings", "description": "Some ghosts floating around on the Cyber Space. Huge thanks to iq, I got into this because of his work on demoscene and graphics. I am actually using quite a few of his work, the cylinder sdf, the ao...\n\nUse your mouse to rotate the around.", "tags": ["retro", "crt"], "likes": 18, "viewed": 732, "published": 3, "date": "1595843190", "time_retrieved": "2024-07-30T20:53:43.774624", "image_code": "#define USE_POST             1\n#define POST_INTENSITY       1.0 /* (sin(iTime)*0.5+0.5) */\n\n#define BARREL_DISTORTION    1\n#define SCAN_LINES\t\t\t 1\n#define CHROMATIC_ABERRATION 1\n#define VIGNETTE             1\n\n\nfloat crtCurve(in vec2 uv)\n{\n    float domeCurvature = 2.0;\n    float domex = 1.0 - pow(abs(uv.x), domeCurvature);\n    float domey = 1.0 - pow(abs(uv.y), domeCurvature);\n    return domex * domey;\n}\n\nvec2 crtDistortedUV(in vec2 uv, in float strength)\n{\n    vec2 s = 1.0/iResolution.xy;\n    vec2 offset = vec2(1, 0);\n    \n    float p = crtCurve(uv);\n    float h1 = crtCurve(uv + s * offset.xy);\n    float v1 = crtCurve(uv + s * offset.yx);\n       \n   \treturn uv - (p - vec2(h1, v1)) * strength;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord/iResolution.xy);\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv2 = uv * 2.0 - 1.0;\n    vec2 texUV = uv;\n    vec3 color = vec3(0);\n    \n#if USE_POST == 1\n    #if BARREL_DISTORTION == 1\n    {\n        float distortion = 30.0;\n        distortion = mix(0.0, distortion, POST_INTENSITY);\n        vec2 compression = distortion / vec2(300.0, 200.0);\n        \n        // Compression\n        uv2 *= 1.0 + compression;\n        // Distortion\n        uv2 = crtDistortedUV(uv2, distortion);\n        \n        if (abs(uv2.x) > 1.0 || abs(uv2.y) > 1.0) \n        {\n            fragColor = vec4(vec3(0), 1.0);\n            return;\n        }\n        \n        texUV = uv2 * 0.5 + 0.5;\n    }\n    #endif\n#endif\n      \n    vec4 buffer = texture(iChannel0, texUV);\n    color = buffer.rgb;\n\n#if USE_POST == 1\n    #if CHROMATIC_ABERRATION == 1\n    {\n\t\tfloat intensity = 0.00007 * POST_INTENSITY;\n        float lensDistortion = 0.4; \n        \n        float radialIntensity = pow(length(uv2), lensDistortion);\n    \tvec2 radialDirection = normalize(uv2);\n        \n\t    vec3 waveLengths = vec3(440, 575, 650);\n\t    vec3 offsets = (waveLengths.g - waveLengths) * intensity * radialIntensity;\n        \n        float mixed = clamp(length(uv2) + 0.1, 0.0, 1.0);\n               \n    \tcolor.r = mix(color.r, texture(iChannel0, texUV + radialDirection * offsets.r).r, mixed);\n    \tcolor.b = mix(color.b, texture(iChannel0, texUV + radialDirection * offsets.b).b, mixed);       \n    }\n    #endif\n    \n\t#if VIGNETTE == 1\n    {\n    \tfloat radial = 1.0 - clamp(-0.2 + pow(length(uv2 / 1.4), 2.2), 0.0, 1.0);\n        radial = mix(1.0, radial, POST_INTENSITY);\n    \tcolor.rgb *= vec3(radial);\n    }\n    #endif\n    \n    #if SCAN_LINES == 1\n    {\n        float lines = iResolution.y / 4.0;\n        float scan = smoothstep(0.03, 0.2, fract(uv.y * lines));\n        scan = mix(1.0, scan, POST_INTENSITY);\n\t    color *= scan;\t\n    }\n    #endif\n#endif\n    \n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color.rgb, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define FAR_PLANE 50.0\n#define EPSILON 0.01\n#define t iTime\n\n//#define DEBUG_TEXTURE_FILTERING\n\n// -----------------------------------------------------------------------------\n// Math\n\n#define PI 3.1416\n#define HALF_PI PI / 2.0\n#define TAU PI * 2.0\n#define DEG2RAD TAU/360.\n\n#define S(x, y, z) smoothstep(x, y, z)\n\nmat3 lookAtMatrix(in vec3 lookAtDirection) \n{\n\tvec3 ww = normalize(lookAtDirection);\n    vec3 uu = cross(ww, vec3(0.0, 1.0, 0.0));\n    vec3 vv = cross(uu, ww);\n    return mat3(uu, vv, -ww);\n}\n\n// -----------------------------------------------------------------------------\n// Camera\n\nstruct Camera {\n    vec3 position;\n\tvec3 direction;\n};\n\nCamera createOrbitCamera(vec2 uv, vec2 mouse, vec2 resolution, float fov, vec3 target, float height, float distanceToTarget)\n{\n    vec2 r = mouse / resolution * vec2(3.0 * PI, 0.5 * PI);\n    float halfFov = fov * 0.5;\n    float zoom = cos(halfFov) / sin(halfFov);\n    \n    vec3 position = target + vec3(sin(r.x), 0.0, cos(r.x)) * distanceToTarget + vec3(0, height, 0);\n    vec3 direction = normalize(vec3(uv, -zoom));\n    direction = lookAtMatrix(target - position) * direction;\n    \n    return Camera(position, direction);\n}\n\n// -----------------------------------------------------------------------------\n// Scene\n\n#define SKY 0\n#define FLOOR 1\n#define GHOST_EYE 2\n#define GHOST_PUPIL 3\n#define GHOST_BODY1 4\n#define GHOST_BODY2 5\n#define GHOST_BODY3 6\n\nstruct Entity {\n    int id;\n\tfloat d;\n};\n\nEntity emin(Entity a, Entity b)\n{\n    if (a.d < b.d) return a; return b;\n}\n\nEntity emax(Entity a, Entity b)\n{\n    if (a.d > b.d) return a; return b;\n}\n\nfloat sdSphere(in vec3 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane(in vec3 p, float height)\n{\n    return p.y + height;\n}\n\nEntity ghost(in vec3 p, in int bodyId) \n{        \n    float rand = float(bodyId * 3);\n    vec3 q = p + vec3(0, sin((rand-1.)*7. + t * 5.0) * 0.1, 0);\n    \n    // BODY\n    float body = sdCappedCylinder(q - vec3(0.0, -1.0, 0.0), 1.0, 1.0);\n    Entity ghost = Entity(bodyId, body);\n    float head = sdSphere(q, 1.0);\n    ghost.d = min(ghost.d, head);\n    \n    float bv = 0.5;\n    if (ghost.d > bv) {\n        ghost.d = ghost.d - bv * 0.5;\n        return ghost;\n    }\n    \n    // BODY FLUCTUATION\n    float majorModChangeFreq = 5.0;\n    float repeat = 6.5;\n    float fluctuationHeight = 2.0;\n    float fluctuationRaymarchSpeed = 0.5;\n    vec2 movement = normalize(vec2(1.0, 1.0)) * 15.0;\n    \n    float fluctuation = (0.9 + 0.2 * sin(rand + t * majorModChangeFreq))\n        \t* sin(rand + q.x * repeat + t * movement.x)\n            * sin(rand + q.z * repeat + t * movement.y)\n         \t* fluctuationHeight;\n    \n    float fluctuationPlane = sdPlane(q, 1.1 - 0.1 * fluctuation) * fluctuationRaymarchSpeed;\n    ghost.d = max(ghost.d, -fluctuationPlane);\n    \n    // EYES\n    vec3 eyesCoord = vec3(abs(q.x), q.yz);\n    Entity eyes = Entity(GHOST_EYE, sdSphere(eyesCoord - vec3(0.35, 0.2, 0.7), 0.3));\n    \n    ghost = emin(ghost, eyes);\n    \n    // PUPILS\n    \n    Entity pupils = Entity(GHOST_PUPIL, sdSphere(eyesCoord - vec3(0.37, 0.23, 0.82), 0.2));\n    ghost = emin(ghost, pupils);\n    \n    return ghost;\n}\n\nEntity scene(in vec3 p)\n{\n    Entity scene;\n    Entity plane = Entity(FLOOR, sdPlane(p, 1.0)); scene = plane;\n    Entity ghost1 = ghost(p - vec3(-2.0,  1.0, -1.5), GHOST_BODY1); scene = emin(scene, ghost1);\n    Entity ghost2 = ghost(p - vec3(0.0,  1.2,  0.0), GHOST_BODY2); scene = emin(scene, ghost2);\n    Entity ghost3 = ghost(p - vec3(2.0, 1.0, -1.5), GHOST_BODY3); scene = emin(scene, ghost3);\n    \n    return scene;\n}\n\n// -----------------------------------------------------------------------------\n// Normals\n\nvec3 sceneNormal(in vec3 p)\n{\n    vec2 offset = vec2(EPSILON, 0);\n    float d = scene(p).d;\n    return normalize(vec3(\n\t\td - scene(p - offset.xyy).d,\n        d - scene(p - offset.yxy).d,\n        d - scene(p - offset.yyx).d\n    ));\n}\n\n// -----------------------------------------------------------------------------\n// Shading\n\nfloat calcAO( in vec3 pos, in vec3 nor ) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ ) {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = scene( aopos ).d;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nfloat traceShadow(in vec3 ro, in vec3 rd, float hardness)\n{\n    float d = EPSILON * 2.0;\n    float k = hardness;\n    float res = 1.0;\n    \n    for (int i=0; i < 128 && d <= FAR_PLANE; i++)\n    {\n        vec3 p = ro + rd * d;\n        float stepDistance = scene(p).d;\n        \n        if (stepDistance < EPSILON) return 0.0;\n        \n        res = min(res, k * stepDistance / d);\n        d += stepDistance;\n    }\n    \n    return clamp(res, 0.0, 1.0);\n}\n\nvec3 shading(vec3 p, vec3 n, vec3 diffuseColor)\n{\n    vec3 sunColor = vec3(6.0);\n    vec3 sunDirection = normalize(vec3(1.0, 1.0, 1.0));\n    \n    float shadowOcclusion = traceShadow(p +  n * EPSILON * 2.0, sunDirection, 28.);\n    float ao = calcAO(p, n);\n    \n    vec3 ambientColor = vec3(0.1) * ao;\n    vec3 diffuse = clamp(dot(n, sunDirection), 0.0, 1.0) * sunColor;\n\n    return (ambientColor + shadowOcclusion * diffuse) * diffuseColor;\n}\n\nvec3 getFloorColor(vec2 uv)\n{\n    vec3 lineColor = vec3(0.43, 0.0, 0.5);\n    vec3 backgroundColor = vec3(0.0005, 0.001, 0.001);\n    float lineWidth = 0.05;    \n    float tiling = 0.2;\n    \n    vec2 cellUV = fract(vec2(0.5, t / 2.0) + uv * tiling) * 2.0 - 1.0;\n    \n    float grid = smoothstep(1.0 - lineWidth, 1.0, max(abs(cellUV.x), abs(cellUV.y)));\n    \n    float radialGradient = S(10.0, 50.0, length(uv));\n    \n    return grid * mix(lineColor, backgroundColor, radialGradient) + (1.0 - grid) * backgroundColor; \n}\n\n// https://iquilezles.org/articles/filtering\nvec3 getFloorFiltered(vec2 uv)\n{\n    float detail = 15.;\n    int maxSamples = 4;\n    \n    vec2 uvX = dFdx(uv);\n    vec2 uvY = dFdy(uv);\n    \n    int sx = 1 + int( clamp(detail * length(uvX), 0.0, float(maxSamples - 1)) );\n    int sy = 1 + int( clamp(detail * length(uvY), 0.0, float(maxSamples - 1)) );\n    \n    vec3 value = vec3(0);\n    for(int i=0; i<sx; i++)\n    for(int j=0; j<sy; j++) {\n        vec2 offset = vec2(float(i), float(j)) / vec2(float(sx), float(sy));       \n        value += getFloorColor(uv + offset.x * uvX + offset.y * uvY);\n    }\n    \n    #ifdef DEBUG_TEXTURE_FILTERING\n    return vec3(float(sx*sy) / float(maxSamples * maxSamples));\n    #endif\n    \n    return value / float(sx*sy);\n}\n\nvec3 getMaterialColor(Entity e, vec3 p, vec3 n)\n{\n    vec3 topColor = vec3(0.18, 0.05, 0.01);\n    vec3 botColor = vec3(0.10, 0.005, 0.001);\n    \n    vec3 color = vec3(0);\n    \n    if (e.id == FLOOR)\n    {\n        color = getFloorFiltered(p.xz);\n    }\n    else if (e.id == GHOST_BODY1)\n    {\n        color = mix(botColor.rbb, topColor.rbb, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_BODY2)\n    {\n        color = mix(botColor.bgr, topColor.bgr, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_BODY3)\n    {\n        color = mix(botColor.grb, topColor.grb, S(0.0, 1.5, p.y));\n    }\n    else if (e.id == GHOST_EYE)\n    {\n        color = vec3(0.18, 0.18, 0.18);\n    }\n    else if (e.id == GHOST_PUPIL)\n    {\n        color = vec3(0.01, 0.01, 0.01);\n    }\n    \n    return shading(p, n, color); \n}\n\n// -----------------------------------------------------------------------------\n// Raymarching - SphereTracing\n\nEntity trace(vec3 origin, vec3 direction)\n{\n    Entity res = Entity(SKY, 0.0);\n    \n    for (int i = 0; i < 512 && res.d <= FAR_PLANE; i++)\n    {\n        vec3 p = origin + direction * res.d;\n        Entity closestEntity = scene(p);\n        \n        res.id = closestEntity.id;\n        res.d += closestEntity.d;\n        \n        if (closestEntity.d < EPSILON) \n        {\n            return res;\n        }\n    }\n    \n    res.id = SKY;\n    res.d = FAR_PLANE;\n    return res;\n}\n\n// -----------------------------------------------------------------------------\n// Main\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float camHeight = 1.0;\n    float vFOV = 60.0 * DEG2RAD + cos(iTime) * 10.0 * DEG2RAD;\n    float distanceToTarget = 8.0 + sin(iTime) * 1.0;\n    vec3 target = vec3(0, 0.5, 0);\n    Camera cam = createOrbitCamera(uv, iMouse.xy, iResolution.xy, vFOV, target, camHeight, distanceToTarget);\n    \n    vec3 ro = cam.position;\n    vec3 rd = cam.direction;\n    \n    Entity e = trace(ro, rd);\n  \n    vec3 p = ro + rd * e.d;\n    vec3 n = sceneNormal(p);\n    \n    vec3 col = vec3(0);\n\n    if (e.id == SKY)\n    {\n        vec3 skyTopColor = vec3(0.05, 0.1, 1.0);\n        vec3 skyHorizonColor = vec3(0.7, 0.1, 0.8);\n        col = mix(skyTopColor, skyHorizonColor, exp(-8.0*rd.y));\n    } else {\n        col = getMaterialColor(e, p, n);\n    }\n    \n    fragColor = vec4(col, 0.0);\n}", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tlBRn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 239, 239, 408], [410, 410, 462, 462, 705], [707, 707, 762, 762, 2785]], "test": "untested"}
{"id": "ttfBzr", "name": "Tiny Ocean", "author": "kstyler", "description": "I have seen a lot of people on here writing 3d shaders in the smallest amount of code possible and I wanted to give it a shot.", "tags": ["3d", "raymarch", "ocean", "tiny"], "likes": 3, "viewed": 344, "published": 3, "date": "1595836966", "time_retrieved": "2024-07-30T20:53:44.539579", "image_code": "void mainImage(out vec4 f, vec2 c){\n    for(float i=0.;i<99.;i++){       \n        f=vec4(c/iResolution.y-.5,1,5)*i;  \n        if(f.y+9.-4.*length(texture(iChannel0,f.xy/i*vec2(.1,1))*sin(length(f)-iTime))<.1)break;\n    }\n\tf/=70.;\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfBzr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 231]], "test": "untested"}
{"id": "tlfBzr", "name": "Complex graph", "author": "Pidhorskyi", "description": "Complex graph", "tags": ["complex", "complexnumber"], "likes": 13, "viewed": 396, "published": 3, "date": "1595836927", "time_retrieved": "2024-07-30T20:53:45.374347", "image_code": "/* \"Complex graph\" by Stanislav Pidhorskyi - 2020\n * License Creative Commons Attribution 4.0 International License. */\n\n#define comp(re, im) mat2(vec2(re, im), vec2(-im, re))\nmat2 sqr(mat2 z) { return z * z; }\nfloat arg(mat2 z) { return atan(z[0][1], z[0][0]); }\nfloat modul(mat2 z) { return length(vec2(z[0][1], z[0][0])); }\nconst mat2 i = comp(0, 1.);\nconst mat2 _1 = comp(1., 0);\n\nmat2 func(mat2 x)\n{\n\treturn (x * x - _1) * sqr(x - 2. * _1 - i) * inverse(x * x + 2. * _1 + 2. * i);\n}\n\n// From https://www.shadertoy.com/view/XljGzV\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.yy;\n    uv.x -= (iResolution.x - iResolution.y) / iResolution.y * 0.5;\n    uv -= 0.5;\n    uv *= 5.0;\n    mat2 z = func(comp(uv.x, uv.y));\n    float phi = arg(z) + time * 1.0;\n    float r = modul(z);\n    float grid = 1.0 - (1.0 - smoothstep(0.85, 1.1, sin(phi * 20.0)))\n        * (1.0 - smoothstep(0.9, 1.1, sin(log(r) / log(2.) * 10.0 + time * 10.0 )));\n    \n    fragColor = vec4(grid + hsl2rgb(vec3(phi / 3.1415 / 2.0, 0.5, 0.5)), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlfBzr.jpg", "access": "api", "license": "cc-by-4.0", "functions": [[176, 176, 194, 194, 210], [211, 211, 230, 230, 263], [264, 264, 285, 285, 326], [385, 385, 404, 404, 487], [489, 535, 562, 562, 704], [706, 706, 763, 763, 1265]], "test": "untested"}
{"id": "3lfBzn", "name": "Waves v.6", "author": "pli", "description": "Now with shadows... ", "tags": ["learning"], "likes": 1, "viewed": 191, "published": 3, "date": "1595835063", "time_retrieved": "2024-07-30T20:53:46.230059", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define SHADOW_COLOR vec3(1.0)\n\n\n#define BOAT_INITIAL_X -0.25\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\tfloat initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\tvec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .6;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1., 5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.19, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch to the scene\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totalDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totalDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totalDist += dist;\n    }\n    \n    if(totalDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n    col = colorVariation * (1. + dot(normal, light));\n    \n    \n    // raymarch back toward the light to compute the shadows\n    light = normalize(vec3(1., 1.3, -3)); // tweak light to avoid the waves casting shadows on themselves\n\n    float shadow = 1.;\n    totalDist = 0.01;\n    dist = 0.0;\n\tfloat sv;\n    vec3 cv;\n    for(float s = 0.; s < STEPS; s++){\n        dist = distScene(pos + light * totalDist, cv, sv);\n        totalDist += dist;\n        shadow = min( shadow, 10.0*dist/totalDist );\n        if(shadow < 0.001 || totalDist > maxDist){\n            break;\n        }\n    }\n    shadow = clamp(shadow, 0., 1.);\n    col = col * (0.5 + 0.5*shadow);\n    \n    \n    //white highlight\n    if (shadow > 0.9) { // we don't want highlights in the shade, notably from the boat\n\t\tlight = normalize(vec3(1., 0.5, -3)); // tweak light to get higher shine\n        float shine = 10.;\n        vec3 refl = reflect(normalize(pos - light), normal);\n        float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n        spec = smoothstep(0.25, 0.45, spec - 0.4);\n        col = mix(col, vec3(1.), (shineVariation -  0.8 * colorVariation) * spec);\n    }\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lfBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[500, 500, 518, 518, 567], [569, 569, 612, 612, 720], [723, 723, 776, 776, 816], [819, 819, 851, 851, 876], [878, 878, 912, 912, 939], [941, 941, 974, 974, 1161], [1164, 1164, 1192, 1192, 1237], [1240, 1240, 1317, 1372, 4511], [4513, 4513, 4536, 4536, 4874], [4877, 4877, 4898, 4898, 7091], [7093, 7093, 7150, 7150, 7278]], "test": "untested"}
{"id": "WtScDt", "name": "Bandlimited Synthesis 1", "author": "iq", "description": "A simple way to prevent aliasing of cosine functions (the color palette in this case) by removing frequencies as oscillations become smaller than a pixel. You can think of it as an LOD system. Move the mouse to compare naive versus band-limited cos(x)", "tags": ["2d", "cos", "filtering", "lod", "frequency", "bandlimited"], "likes": 203, "viewed": 33192, "published": 3, "date": "1595832751", "time_retrieved": "2024-07-30T20:53:47.071808", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org/\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A simple way to prevent aliasing of cosine functions (the color\n// palette in this case is made of 8 layers) by attenuating them\n// when their oscillations become smaller than a pixel. Left is\n// direct use of cos(x), right is band-limited cos(x).\n//\n// Box-filtering of cos(x):\n//\n// (1/w)∫cos(t)dt with t ∈ (x-½w, x+½w)\n// = [sin(x+½w) - sin(x-½w)]/w\n// = cos(x)·sin(½w)/(½w)\n//\n// Can approximate smoothstep(2π,0,w) ≈ sin(w/2)/(w/2),\n// which you can also see as attenuating cos(x) when it \n// oscilates more than once per pixel. More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\n\n// box-filted cos(x)\nvec3 fcos( in vec3 x )\n{\n    vec3 w = fwidth(x);\n\t#if 1\n    return cos(x) * sin(0.5*w)/(0.5*w);       // exact\n\t#else\n    return cos(x) * smoothstep(6.2832,0.0,w); // approx\n\t#endif    \n}\n\n// pick raw cosine, or band-limited cosine\nbool  mode = false;\nvec3  mcos( vec3 x){return mode?cos(x):fcos(x);}\n\n// color palette, made of 8 cos functions\n// (see https://iquilezles.org/articles/palettes)\nvec3 getColor( in float t )\n{\n    vec3 col = vec3(0.6,0.5,0.4);\n    col += 0.14*mcos(6.2832*t*  1.0+vec3(0.0,0.5,0.6));\n    col += 0.13*mcos(6.2832*t*  3.1+vec3(0.5,0.6,1.0));\n    col += 0.12*mcos(6.2832*t*  5.1+vec3(0.1,0.7,1.1));\n    col += 0.11*mcos(6.2832*t*  9.1+vec3(0.1,0.5,1.2));\n    col += 0.10*mcos(6.2832*t* 17.1+vec3(0.0,0.3,0.9));\n    col += 0.09*mcos(6.2832*t* 31.1+vec3(0.1,0.5,1.3));\n    col += 0.08*mcos(6.2832*t* 65.1+vec3(0.1,0.5,1.3));\n    col += 0.07*mcos(6.2832*t*131.1+vec3(0.3,0.2,0.8));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.8*sin(iTime);\n    mode = (q.x<th);\n    \n    // deformation\n    vec2 p = 2.0*q/dot(q,q);\n\n    // animation\n    p.xy += 0.05*iTime;\n\n    // texture\n    vec3 col = min(getColor(p.x),getColor(p.y));\n\n    // vignetting\n    col *= 1.5 - 0.2*length(q);\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-th));\n    \n    // palette\n    if( q.y<-0.9 ) col = getColor( fragCoord.x/iResolution.x );\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScDt.jpg", "access": "api", "license": "mit", "functions": [[1911, 1932, 1956, 1956, 2119], [2184, 2184, 2204, 2204, 2232], [2234, 2326, 2355, 2355, 2855], [2857, 2857, 2913, 2932, 3526]], "test": "untested"}
{"id": "3tScWd", "name": "Bandlimited fbm (box, 2D)", "author": "iq", "description": "A cheap (and not so good) way to prevent aliasing of fbm by removing frequencies as oscillations become smaller than a pixel. You can think of it as an LOD system. Move the mouse to compare naive fbm versus band-limited fbm.", "tags": ["procedural", "2d", "noise", "filter", "bandlimited"], "likes": 41, "viewed": 2286, "published": 3, "date": "1595832316", "time_retrieved": "2024-07-30T20:53:47.842747", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A cheap (and not so good) way to prevent aliasing of fbm by \n// removing frequencies as oscillations become smaller than a pixel.\n// You can think of it as an LOD system. Move the mouse to compare\n// naive fbm (left) versus band-limited fbm (right). More info:\n//\n// https://iquilezles.org/articles/bandlimiting\n//\n// Related Shader:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n\nfloat noise( in vec2 p );\n\n// regular fbm\nfloat fbm( in vec2 p )\n{\n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p;\n    }\n    return 0.5+0.5*f;\n}\n\n// band limited fbm\nfloat blfbm( in vec2 p )\n{\n    float w = length(fwidth(p)); // filter width\n    \n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p)*smoothstep(1.0,0.5,w);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p; // keep p and\n        w = 2.01*w;                        // w in synch\n    }\n    return 0.5+0.5*f;\n}\n\n// band limited fbm, same as above, but with explicit gradients\nfloat blfbm( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    float w = max(length(dpdx),length(dpdy));\n    \n    float s = 0.5;\n    float f = 0.0;\n    for( int i=0; i<8; i++ )\n    {\n        f += s*noise(p)*smoothstep(6.0,0.5,w);\n        s *= 0.8;\n        p = 2.01*mat2(0.8,0.6,-0.6,0.8)*p; // keep p and\n        w = 2.01*w;                        // w in synch\n    }\n    return 0.5+0.5*f;\n}\n\n\n//===============================================================================================\n//===============================================================================================\n// sphere implementation\n//===============================================================================================\n//===============================================================================================\n\nfloat softShadowSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    vec3 oc = sph.xyz - ro;\n    float b = dot( oc, rd );\n\t\n    float res = 1.0;\n    if( b>0.0 )\n    {\n        float h = dot(oc,oc) - b*b - sph.w*sph.w;\n        res = smoothstep( 0.0, 1.0, 2.0*h/b );\n    }\n    return res;\n}\n\nfloat occSphere( in vec4 sph, in vec3 pos, in vec3 nor )\n{\n    vec3 di = sph.xyz - pos;\n    float l = length(di);\n    return 1.0 - dot(nor,di/l)*sph.w*sph.w/(l*l); \n}\n\nfloat iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n    float t = -1.0;\n\tvec3  ce = ro - sph.xyz;\n\tfloat b = dot( rd, ce );\n\tfloat c = dot( ce, ce ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h>0.0 )\n\t{\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn t;\n}\n\n//===============================================================================================\n//===============================================================================================\n// noise\n//===============================================================================================\n//===============================================================================================\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// simple (and bad!) value noise\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\tvec2 u = f*f*(3.0-2.0*f);\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n//===============================================================================================\n//===============================================================================================\n// scene\n//===============================================================================================\n//===============================================================================================\n\n\n// spheres\nconst vec4 sc0 = vec4(  3.0, 0.5, 0.0, 0.5 );\nconst vec4 sc1 = vec4( -4.0, 2.0,-5.0, 2.0 );\nconst vec4 sc2 = vec4( -4.0, 2.0, 5.0, 2.0 );\nconst vec4 sc3 = vec4(-30.0, 8.0, 0.0, 8.0 );\n\nfloat intersect( vec3 ro, vec3 rd, out vec3 pos, out vec3 nor, out float occ, out int matid )\n{\n    // raytrace\n\tfloat tmin = 10000.0;\n\tnor = vec3(0.0);\n\tocc = 1.0;\n\tpos = vec3(0.0);\n    matid = -1;\n\t\n\t// raytrace-plane\n\tfloat h = (0.01-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{ \n\t\ttmin = h; \n\t\tnor = vec3(0.0,1.0,0.0); \n\t\tpos = ro + h*rd;\n\t\tmatid = 0;\n\t\tocc = occSphere( sc0, pos, nor ) * \n\t\t\t  occSphere( sc1, pos, nor ) *\n\t\t\t  occSphere( sc2, pos, nor ) *\n\t\t\t  occSphere( sc3, pos, nor );\n\t}\n\n\n\t// raytrace-sphere\n\th = iSphere( ro, rd, sc0 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + h*rd;\n\t\tnor = normalize(pos-sc0.xyz); \n\t\tmatid = 1;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc1 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc1.xyz); \n\t\tmatid = 2;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc2 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc2.xyz); \n\t\tmatid = 3;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\th = iSphere( ro, rd, sc3 );\n\tif( h>0.0 && h<tmin ) \n\t{ \n\t\ttmin = h; \n        pos = ro + tmin*rd;\n\t\tnor = normalize(pos-sc3.xyz); \n\t\tmatid = 4;\n\t\tocc = 0.5 + 0.5*nor.y;\n\t}\n\n\treturn tmin;\t\n}\n\nvec2 texCoords( in vec3 pos, int mid )\n{\n    vec2 matuv;\n    \n    if( mid==0 )\n    {\n        matuv = pos.xz;\n    }\n    else if( mid==1 )\n    {\n        vec3 q = normalize( pos - sc0.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc0.w;\n    }\n    else if( mid==2 )\n    {\n        vec3 q = normalize( pos - sc1.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc1.w;\n    }\n    else if( mid==3 )\n    {\n        vec3 q = normalize( pos - sc2.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc2.w;\n    }\n    else if( mid==4 )\n    {\n        vec3 q = normalize( pos - sc3.xyz );\n        matuv = vec2( atan(q.x,q.z), acos(q.y ) )*sc3.w;\n    }\n\n\treturn 20.0*matuv;\n}\n\n\nvoid calcCamera( out vec3 ro, out vec3 ta )\n{\n\tfloat an = 0.1*sin(0.1*iTime);\n\tro = vec3( 5.0*cos(an), 0.5, 5.0*sin(an) );\n    ta = vec3( 0.0, 1.0, 0.0 );\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in float occ, in vec3 rd )\n{\n    float sh = min( min( min( softShadowSphere( pos, vec3(0.57703), sc0 ),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc1 )),\n\t\t\t\t              softShadowSphere( pos, vec3(0.57703), sc2 )),\n                              softShadowSphere( pos, vec3(0.57703), sc3 ));\n\tfloat dif = clamp(dot(nor,vec3(0.57703)),0.0,1.0);\n\tfloat bac = clamp(0.5+0.5*dot(nor,vec3(-0.707,0.0,-0.707)),0.0,1.0);\n    vec3 lin  = dif*vec3(1.50,1.40,1.30)*sh;\n\t     lin += occ*vec3(0.15,0.20,0.30);\n\t     lin += bac*vec3(0.10,0.10,0.10)*(0.2+0.8*occ);\n\n    return lin;\n}\n//===============================================================================================\n//===============================================================================================\n// render\n//===============================================================================================\n//===============================================================================================\n\nvoid calcRayForPixel( in vec2 pix, out vec3 resRo, out vec3 resRd )\n{\n\tvec2 p = (-iResolution.xy + 2.0*pix) / iResolution.y;\n\t\n     // camera movement\t\n\tvec3 ro, ta;\n\tcalcCamera( ro, ta );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n\tresRo = ro;\n\tresRd = rd;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord) / iResolution.y;\n\t\n    float th = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 0.0;\n    \n\tvec3 ro, rd, ddx_ro, ddx_rd, ddy_ro, ddy_rd;\n\tcalcRayForPixel( fragCoord + vec2(0.0,0.0), ro, rd );\n\tcalcRayForPixel( fragCoord + vec2(1.0,0.0), ddx_ro, ddx_rd );\n\tcalcRayForPixel( fragCoord + vec2(0.0,1.0), ddy_ro, ddy_rd );\n\t\t\n    // trace\n\tvec3 pos, nor;\n\tfloat occ;\n    int mid;\n    float t = intersect( ro, rd, pos, nor, occ, mid );\n\n\tvec3 col = vec3(0.9);\n\tif( mid!=-1 )\n\t{\n#if 1\n\t\t// -----------------------------------------------------------------------\n        // compute ray differentials by intersecting the tangent plane to the  \n        // surface.\t\t\n\t\t// -----------------------------------------------------------------------\n\n\t\t// computer ray differentials\n\t\tvec3 ddx_pos = ddx_ro - ddx_rd*dot(ddx_ro-pos,nor)/dot(ddx_rd,nor);\n\t\tvec3 ddy_pos = ddy_ro - ddy_rd*dot(ddy_ro-pos,nor)/dot(ddy_rd,nor);\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2     uv = texCoords(     pos, mid );\n\t\tvec2 ddx_uv = texCoords( ddx_pos, mid ) - uv;\n\t\tvec2 ddy_uv = texCoords( ddy_pos, mid ) - uv;\n#else\n\t\t// -----------------------------------------------------------------------\n        // Because we are in the GPU, we do have access to differentials directly\n        // This wouldn't be the case in a regular raytracer.\n\t\t// -----------------------------------------------------------------------\n\t\tvec2 uvw = texCoords( pos, mid );\n\n\t\t// calc texture sampling footprint\t\t\n\t\tvec2 ddx_uvw = dFdx( uvw ); \n        vec2 ddy_uvw = dFdy( uvw ); \n#endif\n        \n\t\t// shading\t\t\n\t\tvec3 mate = vec3(0.0);\n\n        if( p.x<th ) mate = vec3(1.0)*fbm( uv );\n        else         mate = vec3(1.0)*blfbm( uv, ddx_uv, ddy_uv );\n            \n        // lighting\t\n\t\tvec3 lin = doLighting( pos, nor, occ, rd );\n\n        // combine lighting with material\t\t\n\t\tcol = mate * lin;\n\t\t\n        // fog\t\t\n        col = mix( col, vec3(0.9), 1.0-exp( -0.00001*t*t ) );\n\t}\n\t\n    // gamma correction\t\n\tcol = pow( col, vec3(0.4545) );\n\n\tcol *= smoothstep( 1.0, 2.0, abs(p.x-th)/(2.0/iResolution.y) );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScWd.jpg", "access": "api", "license": "mit", "functions": [[1572, 1587, 1611, 1611, 1800], [1802, 1822, 1848, 1848, 2184], [2186, 2250, 2304, 2304, 2637], [3058, 3058, 3121, 3121, 3344], [3346, 3346, 3404, 3404, 3512], [3514, 3514, 3568, 3568, 3754], [4158, 4158, 4215, 4215, 4319], [4321, 4354, 4380, 4380, 4671], [5272, 5272, 5367, 5383, 6481], [6483, 6483, 6523, 6523, 7164], [7167, 7167, 7212, 7212, 7323], [7325, 7325, 7396, 7396, 7953], [8357, 8357, 8426, 8426, 8799], [8802, 8802, 8859, 8859, 11017]], "test": "untested"}
{"id": "wlXBzn", "name": "Glimmer of Hope", "author": "wyatt", "description": "I think digital art should be inspired by nature more, and less by technology. ", "tags": ["nature"], "likes": 18, "viewed": 507, "published": 3, "date": "1595815096", "time_retrieved": "2024-07-30T20:53:48.825120", "image_code": "Main \n{\n    vec4 b = B(U);\n    Q = A(U);\n    for (float j = 0.; j < 6.2; j += 6.2/3.)\n        for (float i = 0.; i < 7.; i++) {\n            vec4 a = A(U+vec2(i,0)*ei(j+.1*iTime));\n            Q += .5*a*(-1.+exp(8.*a))*gauss(i,3.);\n        }\n    Q = mix(vec4(.7,.7,.7,1)-b.zzzz+.1*Q,Q,2.*b.z);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\nvec4 pw (vec4 t, float p) {\n\treturn vec4(pow(t.x,p),pow(t.y,p),pow(t.z,p),1);\n}\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define gauss( i, std) 0.3989422804/(std)*exp(-.5*(i)*(i)/(std)/(std))\n", "buffer_a_code": "Main \n{\n    Q = vec4(0);\n\tfor (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 aa = A(U+u);\n        \n    \t#define q 1.5\n\t\tvec2 w1 = clamp(U+u+aa.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+aa.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q.xy += m*aa.z*aa.xy;\n        Q.z += m*aa.z;\n    }\n    if (Q.z>0.)\n    \tQ.xy/=Q.z;\n    if (iFrame < 1) \n    {\n        Q = vec4(0,0,0,0);\n        if (length(U/R-0.5)<0.4)Q.z = .8;\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)<10.) Q.xz = vec2(.5,.5);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main \n{\n    Q = A(U);\n    vec4 c = C(U), d = D(c.xy);\n    float f = -.5*(d.x*2.-1.)-.5;\n\tfor (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    if (x != 0||y!=0)\n    {\n        vec2 u = vec2(x,y);\n        vec4 aa = A(U+u), cc = C(U+u), dd = D(cc.xy);\n        float ff = dd.x*3.-dd.z*2.;\n        Q.xy -= 0.125*aa.z*normalize(u)*aa.z*(ff-.8+aa.z);\n    }\n    Q.xy*=1.-.005*(d.z+d.x);\n    Q.y += 5e-4*Q.z*(d.y*2.-1.);\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n\n    \n}", "buffer_b_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n    Q = vec4(0);\n    float w = 0.;\n\tfor (int x = -1; x<=1; x++)\n\tfor (int y = -1; y<=1; y++)\n    {\n        vec2 u = vec2(x,y);\n        vec4 aa = A(U+u), cc = C(U+u), dd = D(cc.xy);\n        \n    \t#define q 1.\n\t\tvec2 w1 = clamp(U+u+aa.xy-0.5*q,U - 0.5,U + 0.5),\n             w2 = clamp(U+u+aa.xy+0.5*q,U - 0.5,U + 0.5);\n        float m = (w2.x-w1.x)*(w2.y-w1.y)/(q*q);\n        Q += m*aa.z*cc;\n        w += m*aa.z;\n    }\n    if (w>0.)\n    \tQ/=w;\n    Q.xy = mix(Q.xy,U,1e-5);\n    if (iFrame < 1) Q = vec4(U,0,0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    vec4 a = A(U), c = C(U), d = D(c.xy);\n\tfloat std = d.x+d.y-2.*d.z;\n    \n  \tvec4\n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    vec3 norm = \n        normalize(vec3(e.z-w.z,n.z-s.z,-.01*(std*std)));\n    vec3 ref = reflect(vec3(0,0,1), norm);\n    Q = min(a.z,1.)*d*sqrt(d);\n    vec4 tx = texture(iChannel1,ref);\n    Q *= 0.5+0.5*tx+.1*norm.x;\n    Q *= exp(tx);\n    Q = atan(Q);\n}", "buffer_d_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlXBzn.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3lBcRz", "name": "Circling circles", "author": "h3nr1x", "description": "Saw this as an animated GIF a long time ago.", "tags": ["2d", "circles", "gif"], "likes": 6, "viewed": 295, "published": 3, "date": "1595810351", "time_retrieved": "2024-07-30T20:53:49.923184", "image_code": "const float speed = 2.5f;\n\nfloat circle(vec2 uv, vec2 center, float radious) {\n  float dist = length(uv - center);\n  return smoothstep(radious - 0.01f, radious, dist);\n}\n\nfloat circunference(vec2 uv, vec2 center, float radious, float thickness) {\n  float dist = length(uv - center);\n  // The |d - r| part below might be a bit confusing, \n  // to better understand it, I'd fully recommend \n  // https://www.youtube.com/watch?v=60VoL-F-jIQ  \n  return smoothstep(.0f, thickness, abs(dist - radious));\n}\n\nvoid mainImage(out vec4 frag_colour, in vec2 frag_coord) {\n  // These 2 lines:\n  // 1. Move the smaller dimension (usually Y) to [-1, 1]\n  // 2. Set (0, 0) at the center of the screen, and\n  // 3. Scale the larger dimension (usually X) accordingly \n  //    keeping the aspect ratio\n  // This make it all go to [-1.something, 1.something]\n  float m = min(iResolution.x, iResolution.y);\n  vec2 uv = (2.0f * frag_coord - iResolution.xy) / m; // (1)\n    \n  // To get min/max UV, replace frag_coord with 0 and W/H \n  // respectively in (1)\n  vec2 max_uv = iResolution.xy / m;\n  vec2 min_uv = -max_uv;\n\n  vec2 size = max_uv - min_uv;\n\n  float radious = size.x / 30.0f;\n  float dist_between_circles = radious + (radious / 10.0f);\n\n  vec3 colour = vec3(1.0f);\n\n  // Set a grid on top of our coordinate system and get the\n  // integers (i, j) for the quadrant our fragment is in\n  vec2 ij = (uv - min_uv) / dist_between_circles;\n  ij -= fract(ij);\n\n  const float thickness = 0.006;\n\n  // Visit the 8 surrounding quadrants (and ours at [i=0, jj=0]) \n  // to check if this fragment is part of a circuference from \n  // that quadrant, or the tiny moving circle. \n  for (int ii = -1; ii <= 1; ii++) {\n    for (int jj = -1; jj <= 1; jj++) {\n      vec2 iijj = ij + vec2(float(ii), float(jj));\n      vec2 center = min_uv + iijj * dist_between_circles;\n      colour *= circunference(uv, center, radious, thickness);\n \n      // The angle a for the moving little circle has an offset\n      // that depends on the cuadrant iijj\n      float offset = iijj.x * 0.5f - iijj.y * 0.5f;  \n      // The above can also be expressed as:\n      // float offset = dot(iijj, vec2(0.5f, -0.5f));\n        \n      // If you remove the offset below, all the\n      // circles will move in the same direction\n      float a = speed * -iTime - offset;\n      center += radious * vec2(cos(a), sin(a));\n      colour *= circle(uv, center, 0.02);\n    }\n  }\n\n\n  frag_colour = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 78, 78, 169], [171, 171, 246, 246, 499], [501, 501, 559, 838, 2448]], "test": "untested"}
{"id": "WtfBRr", "name": "Hyper Menger Tunnel", "author": "kstyler", "description": "Flying through a changing Menger sponge.", "tags": ["tunnel", "raymarch", "menger", "sponge"], "likes": 6, "viewed": 433, "published": 3, "date": "1595794368", "time_retrieved": "2024-07-30T20:53:50.697115", "image_code": "mat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    \n    \n    for(int i = 0; i < 4; i++){\n    \tvec3 q = mod(p+0.5*c,c)-0.5*c;\n        q.z*=sin(iTime/2.)+1.5;\n        float subt = cros(q*(crSiz/size))/(crSiz/size);  \n        res=max(-subt,res);\n        c/=3.;\n        crSiz*=3.;\n    }\n    return res;\n}\nfloat map(vec3 p){\n    float c = 5.4;\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    return sponge(q,4.);\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){\n    vec3 outLight = vec3(0.125);\n    outLight+=addLight(10.*vec3(0.7,0.2,0.3)*sin(iTime/4.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+=addLight(10.*vec3(0.1,0.3,0.7)*sin(iTime/4.),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-11.);\n    ro.z+=iTime*8.;\n    vec3 rd = normalize(vec3(uv,1));\n    rd.z*=sin(iTime/6.);\n    rd.xy*=rot(iTime/8.);\n    vec3 color = vec3(0);\n    vec3 accum = vec3(0);\n    float tot = 0.;\n    for(int i = 0; i<80;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n        vec3 n = normal(p);\n        if(dst>0.01){\n        \tcolor = skyColor(rd)/2.;\n        }\n        else{    \n        \tcolor  = vec3(tot/1000.);    \n        }\n        accum+=color*0.04;\n    }\n    fragColor = vec4(1.-(accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 98, 98, 191], [193, 193, 212, 212, 314], [316, 316, 349, 349, 683], [684, 684, 702, 702, 783], [785, 785, 805, 805, 976], [978, 978, 1030, 1030, 1198], [1200, 1200, 1223, 1223, 1471], [1473, 1473, 1529, 1529, 2142]], "test": "untested"}
{"id": "3tXBRr", "name": "luminance of pseudo-point", "author": "FabriceNeyret2", "description": "pixels are small but their luminosity is limited -> plotted stars can be barely visible since the pixel saturate compare to true star luminosity.\nBut you can draw a larger disk with same luminosity (and thus improve max renderable intensity, + improve AA)", "tags": ["luminance", "tuto", "astronomy", "short"], "likes": 8, "viewed": 431, "published": 3, "date": "1595793013", "time_retrieved": "2024-07-30T20:53:51.459078", "image_code": "#define D(v,r) smoothstep( s, -s, length(v) - r )  // draw AA disk\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy;\n    float s = 10./R.y;\n    vec2  U = s* u,\n          I = ceil(U),                             // cell id\n          D = s*cos(10.*iTime+vec2(0,11) + 6.3*fract(1e4*sin(dot(I,R)))), // random rotation\n          F = fract(U+D)*2.-1.;                    // local coordinates in cell\n    \n    O = vec4(   D(F,s*I.x)                         // disk of size = row\n              * min( 1., pow(1.6,I.y) /(I.x*I.x) ) // intensity = 1/area * col\n            );\n    \n    O = pow(O, vec4(1./2.2) );                     // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tXBRr.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 106, 106, 655]], "test": "untested"}
{"id": "tt2cDm", "name": "Mandelbulb - Interactive", "author": "AmarnathMurugan", "description": "Raymarched Interactive Mandelbulb\n\nControls: \nZ - Zoom In\nX - Zoom Out\nLeft/Right/Down/Up Arrow - Rotate\n", "tags": ["fractal"], "likes": 6, "viewed": 553, "published": 3, "date": "1595790688", "time_retrieved": "2024-07-30T20:53:52.339724", "image_code": "//https://iquilezles.org/articles/mandelbulb\n//http://blog.hvidtfeldts.net/index.php/2011/06/distance-estimated-3d-fractals-part-i/\n#define MAX_STEPS 25\n#define THRESHOLD 0.1\n#define MAX_DIST 10.0\n#define MAX_ITR 15\n#define ESCAPE_THRESHOLD 10.0\n#define PI 3.1415926538\n#define StartPoint vec4(0.0,0.0,-4.0,0.0);\nconst float Width = 2.0;\nconst float  FocalDistance = 1.0;\nconst float power = 8.0;\nvec3 Origin;\nfloat SphereSdf(vec3 p, vec4 sph)\n{\n\tfloat d = length(sph.xyz - p)-sph.w;\n    return d;\n}\n\nvec3 GetCartesianCoords(float len, float theta,float phi)\n{\n\treturn (len * vec3(sin(theta)*cos(phi),sin(theta)*sin(phi),cos(theta)));    \n}\n\nvec2 MandelbulbSdf(const in vec3 p)\n{\n    vec3 z = p;\n    float len = 0.0;\n    float derivative_len = 1.0;\n    float theta,phi;\n    int i;\n    for(i=0;i<MAX_ITR;i++)\n    {\n    \tlen = length(z);\n        if(len > ESCAPE_THRESHOLD) break;\n        theta = acos(z.z/len)+(iTime/10.0);\n        phi = atan(z.x/z.y);\n        derivative_len =  power * pow(len,power-1.0) * derivative_len + 1.0;\n        len = pow(len,power);\n        z = GetCartesianCoords(len,power*theta,power*phi) + p;        \n    }\n    return vec2(0.5 * log(len) * (len/derivative_len),i);\n}\n\nvec3 Raymarch(const in vec3 dir)\n{\n    float d=0.0;\n    vec3 p;\n    vec3 finalParams;\n    int i;\n\tfor(int i=0;i<MAX_STEPS;i++)\n    {\n        p = Origin + d * dir;\n        finalParams.xy = MandelbulbSdf(p);\n        d += finalParams.x;\n        if(d<=THRESHOLD || d>=MAX_DIST)\n            break;\n    }\n    finalParams.z = float(i);\n    return finalParams;\n}\n\nvec3 GetSkyColor(const in vec3 RayDirection)\n{\t\n    float t = 0.5 * (RayDirection.y + 1.0);\n    vec3 col = vec3(0.1)*(1.0 - t) + vec3(0.0) * t;\n    return col;\n}\n\n//source : https://www.shadertoy.com/view/ll2GD3\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 GetColorAtPoint(const in vec3 RayDirection)\n{\n    vec3 hitInfo = Raymarch(RayDirection);\n    float outline = hitInfo.x*20.0;\n    float col = (hitInfo.y/float(MAX_ITR));\n\tif(hitInfo.x*180.0 < MAX_DIST)\n    return pal( col, vec3(0.7,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) )+outline*vec3(1.0,2.0,3.5);\n   \n    return GetSkyColor(RayDirection);\n   \n}\n\nmat4 RotateY(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat4(Cos,0.0,-Sin,0.0,\n                0.0,1.0,0.0,0.0,\n                Sin,0.0,Cos,0.0,\n                0.0,0.0,0.0,1.0);\n}\n\nmat4 RotateX(float theta)\n{\n    float Cos = cos(theta);\n    float Sin = sin(theta);\n\treturn mat4(1.0,0.0,0.0,0.0,\n                0.0,Cos,Sin,0.0,\n                0.0,-Sin,Cos,0.0,\n                0.0,0.0,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n     vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x*= iResolution.x/iResolution.y;\n    vec4 PrevState = texelFetch(iChannel0,ivec2(0,0),0);     \n    vec4 ro1 = RotateY(-PrevState.x) * RotateX(-PrevState.y) * StartPoint;\n    Origin = ro1.xyz;\n \tvec3 lp = vec3(0.0);\n    vec3 forward = normalize(lp-Origin);\n    vec3 GlobalUp = vec3(0.0,1.0,0.0);\n    vec3 right = normalize(cross(forward,GlobalUp));\n    vec3 localUp = cross(right,forward);\n    vec3 rd = (Origin+forward*PrevState.z) + uv.x * right + uv.y * localUp - Origin;\n\tvec3 col = GetColorAtPoint(normalize(rd));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define PI 3.1415926538\nconst int KEY_Z  = 90;\nconst int KEY_X  = 88;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nvec3 offset = vec3(0.0,0.0,1.0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    offset = texelFetch(iChannel0,ivec2(0,0),0).xyz; \n    offset.x+= (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).x - texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).x)*0.02 ;\n    offset.y+= (texelFetch(iChannel1,ivec2(KEY_UP,0),0).x - texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).x)*0.02 ; \n    offset.z+= (texelFetch(iChannel1,ivec2(KEY_Z,0),0).x - texelFetch(iChannel1,ivec2(KEY_X,0),0).x)*0.01*offset.z ;\n    offset.xy%=2.0*PI;\n    float limit = PI/2.0-0.001;\n    offset.y = clamp(offset.y,-limit,limit);\n    offset.z = clamp(offset.z,1.0,15.0);    \n    fragColor = vec4(offset,1.0);\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2cDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[410, 410, 445, 445, 499], [501, 501, 560, 560, 640], [1715, 1764, 1832, 1832, 1875], [2256, 2256, 2283, 2283, 2472], [2474, 2474, 2501, 2501, 2690], [2692, 2692, 2749, 2749, 3355]], "test": "untested"}
{"id": "Wl2cWd", "name": "PathTracedSponge", "author": "kstyler", "description": "A path traced Menger sponge.", "tags": ["fractal", "pathtrace", "spongemenger"], "likes": 4, "viewed": 320, "published": 3, "date": "1595788709", "time_retrieved": "2024-07-30T20:53:53.111660", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor /= fragColor.w;\n    fragColor *= 1.5;\n    fragColor /= fragColor+1.;\n    fragColor = pow(fragColor, vec4(0.9));\n    fragColor = smoothstep(0.,1.,fragColor);\n    fragColor.rgb = mix(vec3(0,.03,.05),vec3(1,1,1),fragColor.rgb);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int MAX_D=100;\nconst float DELTA=0.01;\nint matId = 0;\nfloat fract2(float n){\n    if(n>=0.){\n    \treturn fract(n);\n    } \n    return -(fract(abs(n)));\n}\nfloat hash21(vec2 uv){\n\treturn fract2(tan(uv.x*4355.55+uv.y*343534.)*53.32);\n}\n\nvec3 randInSphere(vec2 seed){\n\tvec3 p;   \n     p = vec3(hash21(seed+fract(iTime)*22.),hash21(seed+fract(iTime)*43.),\n                     hash21(seed+fract(iTime)*97.));\n    return normalize(p);\n}\n\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    for(int i = 0; i < 4; i++){\n      vec3 q = mod(p+0.5*c,c)-0.5*c;\n      float subt = cros(q*(crSiz/size))/(crSiz/size);  \n      res=max(-subt,res);\n      c/=3.;\n      crSiz*=3.;\n    }\n    return res;\n}\n\nfloat map(vec3 p){\n    float sp = sponge(p,3.);\n    float lightb = box(p-vec3(0,9,0),vec3(9,0.2,9));\n    float lightb2 = box(p-vec3(0,-9.1,0),vec3(10,0.2,10));\n    float best = min(lightb,min(sp,lightb2));\n    if(best==sp){\n    \tmatId = 2;\n    }\n    if(best == lightb){\n    \tmatId=3;\n    }\n    if(best == lightb2){\n    \tmatId=4;\n    }\n    return best;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){ \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+= addLight(vec3(0.1,0.7,0.2),normalize(-vec3(-1.5,-0.5,1.)),rd);\n    outLight+= addLight(vec3(1.0,0.3,0.1),normalize(-vec3(1.5,0.9,-1.)),rd);\n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nfloat raymarch(vec3 ro, vec3 rd){\n    float tot = 0.1;\n    for(int i = 0; i < MAX_D;i++){\n        float dst = map(ro+rd*tot);\n        tot+=dst;\n        if(tot>float(MAX_D) || dst < DELTA)break;\n    } \n    return tot;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    fragColor = texture(iChannel0,fragCoord/iResolution.xy);\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(2.2,0,-16);\n    vec3 rd = normalize(vec3(uv,1));     \n    ro.xz*=rot(1.9);\n    rd.xz*=rot(1.9); \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    for(int i = 0; i<3;i++){\n        float tot = (raymarch(ro,rd+hash21(iTime*2.+uv)*0.0006));\n        vec3 p = ro+rd*tot;\n        vec3 n = normal(p);\n        if(tot>float(MAX_D)){\n            matId = 1;\n        }\n        if(matId ==1){\n            color = skyColor(rd);     \n        }\n        if(matId ==2){ \n            ro=p;\n            rd = (randInSphere(uv+iTime)+n)*0.5;\n        }\n        if(matId ==3){\n            color =1.*vec3(1.,0.4,0);\n            \n        } \n        if(matId ==4){   \n            color =2.*vec3(1.1,0.2,0.1);\n        }    \n        accum+=0.7*color;\n    }\n    if(iMouse.z>1.){\n    \tfragColor = vec4(0);\n    }\n    fragColor += vec4((accum),1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 358]], "test": "untested"}
{"id": "wljcDd", "name": "Memleak", "author": "kloumpt", "description": "Just experimented with a feedback technique idea :)", "tags": ["glitch", "feedback"], "likes": 12, "viewed": 615, "published": 3, "date": "1595775138", "time_retrieved": "2024-07-30T20:53:53.876614", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n    col = vec3(max(col.r, max(col.g, col.b)));\n    col = 1.0 - col;\n    col = min(vec3(1.0), col * 1.25);\n    col = pow(col, vec3(1.00 / 0.90));\n    //col = mix(col, vec3(1.0, 0.0, 1.0), step(1.0, max(col.r, max(col.g, col.b))));\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec3 col = texture(iChannel0, uv).rgb;\n\tvec3 bg_col = texture(iChannel1, uv).rgb;\n    vec3 top_col = 0.5 * (texture(iChannel1, uv - vec2(-1., -0.) / iResolution.xy).rgb + texture(iChannel1, uv - vec2(+7., -0.) / iResolution.xy).rgb);\n    vec3 bot_col = 0.5 * (texture(iChannel0, uv - vec2(-1., +1.) / iResolution.xy).rgb + texture(iChannel0, uv - vec2(+7., +1.) / iResolution.xy).rgb);\n    \n    col = mix(col, top_col, step(-bot_col * 1.2 - 0.25, -top_col) * step(bot_col * 1.0, top_col));\n    \n    col = max(vec3(0.0), min(col, vec3(1.0)));\n\tfragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23482, "src": "https://soundcloud.com/gurkeclub/iai-ouya", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 456]], "test": "untested"}
{"id": "wt2yDt", "name": "Waves v.5", "author": "pli", "description": "Nicer waves, and much better framerate.", "tags": ["learning"], "likes": 1, "viewed": 187, "published": 3, "date": "1595773147", "time_retrieved": "2024-07-30T20:53:54.720359", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z -0.3\n\n\n#define X_WAVE_SPACE 0.05\n#define Z_WAVE_SPACE 0.05\n\n#define WAVE_SMOOTH 0.01\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\treturn length(p-center) - radius;   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n    return grid / 10.;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n    return coords * 10.;\n}\n\nfloat waveDephthAt(vec3 coords) {\n    return 0.10 \n        + 0.03 * cos(0.5 * coords.x + 1.2 * sin(0.5*coords.z + iTime) + 5.*iTime) \n        + 0.002 * cos(cos(2.*coords.x) + sin(2.*coords.z) + 4. * iTime)\n        ;   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.01 + waveDephthAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    vec3 grid = gridFromCoords(pos);\n    vec3 nGrid = vec3(grid.x, 0., grid.z);\n    vec3 coords = coordsFromGrid(vec3(nGrid.x, 0., nGrid.z));            \n\n    float seaHeight = waveDephthAt(vec3(nGrid.x, 0., nGrid.z));\n    float dist = distSphere(pos, coords, seaHeight);\n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    \n\t// boat\n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\tfloat initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\tvec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    \n    //camera\n    vec3 eye = vec3(0., 1.,5.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.08) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.205, 0.20);\n    if (length(moonPosition - uv) < 0.12) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 5.8;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[548, 548, 566, 566, 615], [618, 618, 661, 661, 769], [772, 772, 825, 825, 865], [868, 868, 903, 903, 950], [952, 952, 993, 993, 1066], [1068, 1068, 1104, 1104, 1145], [1148, 1148, 1180, 1180, 1205], [1207, 1207, 1241, 1241, 1268], [1270, 1270, 1303, 1303, 1490], [1493, 1493, 1521, 1521, 1566], [1569, 1569, 1646, 1701, 4840], [4842, 4842, 4865, 4865, 5203], [5206, 5206, 5227, 5227, 6611], [6613, 6613, 6670, 6670, 6798]], "test": "untested"}
{"id": "wl2yDt", "name": "Cloth generator", "author": "michael0884", "description": "hm", "tags": ["hm"], "likes": 17, "viewed": 637, "published": 3, "date": "1595769350", "time_retrieved": "2024-07-30T20:53:55.550140", "image_code": "// Fork of \"Pseudo3D Fur\" by michael0884. https://shadertoy.com/view/tlBcRz\n// 2020-07-26 09:58:24\n\n#define R iResolution.xy\n#define PI 3.14159265\n\n#define center R*0.5\n#define L 1.\n#define P 50.\n\n#define A 100.\n#define light_dir normalize(vec3(0.36,0.6,0.7))\n\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat perlin(vec2 p, out vec2 grad)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 pfs = sin(pf*PI);\n   \n   const vec2 a = vec2(0.,1.);\n   \n   float a00 = hash12(pi+a.xx);\n   float a01 = hash12(pi+a.xy);\n   float a10 = hash12(pi+a.yx);\n   float a11 = hash12(pi+a.yy);\n   \n   float x1 = mix(a00, a01, pfc.y);\n   float x2 = mix(a10, a11, pfc.y);\n   float y1 = mix(a00, a10, pfc.x);\n   float y2 = mix(a01, a11, pfc.x);\n    \n   grad = vec2((x2 - x1)*pfs.x, (y2 - y1)*pfs.y);\n   \n   return 0.5 + 0.5*mix(x1, x2, pfc.x);\n}\n\nvec4 dir(vec2 p, vec2 freq, float phase)\n{\n    float x = dot(p, freq) + phase;\n    return vec4(cos(x), sin(x), -freq.x*sin(x), freq.y*cos(x));\n}\n\nvec4 wind(vec2 p, float t)\n{\n    t*=5.;\n    \n    vec4 dx = 0.04*dir(p, vec2(-0.3, -0.5), 1.133*t)+\n              0.1*dir(p, vec2(0.1, 0.11), 0.431*t)+\n              0.2*dir(p, vec2(-0.12, 0.1), 0.256*t);\n    return 0.6*dx;\n}\n\nvec3 clothl(vec2 p, out vec2 GRAD)\n{\n    vec3 f = vec3(0.);\n    vec3 d = vec3(0., 0., 1.);\n    GRAD = vec2(0.);\n    for(int i = 0; i < 2; i++)\n    {\n        vec2 grad;\n        f += perlin(d.z*p + d.xy + vec2(i)*1e3, grad)*vec3(1.);\n        GRAD += d.z*grad;\n        d = vec3(d.x,d.y,0.3)*d + vec3(2.64, 1.5446, 0.);\n    }\n    return f;\n}\n\n#define cell_s 0.2\nvec3 cloth_pattern(vec2 pos, out vec3 normal)\n{\n    //create the weaving pattern\n    vec2 g1, g2;\n    const vec2 strand = vec2(0.02, 1.5); \n \tvec3 a = vec3(1.,.7,0.)*clothl(strand*pos, g1);\n    vec3 b = 1.2*vec3(1.,0.2,0.25)*clothl(strand.yx*pos, g2);\n    //checker modulation\n    float M = (2.*smoothstep(-0.5,0.5,sin(PI*pos.x*cell_s)) - 1.)*\n        \t  (2.*smoothstep(-0.5,0.5,sin(PI*pos.y*cell_s)) - 1.);\n    float Ma = smoothstep(-0.2,0.2,M);\n    normal = normalize(vec3(2.*mix(g1*strand, g2*strand.yx, Ma),1.));\n    return 3.*mix(a,b,Ma);\n}\n\nvec4 cloth(vec2 p)\n{\n    vec4 col = vec4(0.);\n    vec4 dx = wind(p*0.1, iTime);\n    //displacement normal\n    vec3 normal = normalize(vec3(-A*dx.zw, 1.));\n  \t//diceplacement\n    vec2 pos = p + A*dx.xy; \n    \n    //texture\n    vec3 c, N;\n    c = cloth_pattern(pos, N);\n    \n    //cloth normal modulation\n    normal = normalize(1.6*normal + N);\n    \n    // magic shading stuff\n\tfloat d = clamp(dot(normal, light_dir), 0., 1.);\n    float s = pow(d, 20.);\n    float B = 0.08*d + 0.05 + 0.2*s; //brightness\n    col = vec4(B*c,1.); //blend\n   \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n   \t\n    fragColor = tanh(2.*cloth(0.5*fragCoord));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 283, 283, 400], [402, 402, 439, 439, 961], [963, 963, 1005, 1005, 1107], [1109, 1109, 1137, 1137, 1333], [1335, 1335, 1371, 1371, 1672], [1693, 1693, 1740, 1773, 2238], [2240, 2240, 2260, 2260, 2795], [2797, 2797, 2854, 2879, 2933]], "test": "untested"}
{"id": "WtjyWt", "name": "M_Sponge", "author": "kstyler", "description": "Practicing fractal geometry.", "tags": ["fractal", "raymarch", "menger", "sponge"], "likes": 3, "viewed": 307, "published": 3, "date": "1595718461", "time_retrieved": "2024-07-30T20:53:56.400865", "image_code": "mat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat cros(vec3 p){\n    return min(box(p.xyy,vec3(1,1,9999)),min(box(p.xxz,vec3(1,9999,1)),box(p.yyz,vec3(9999,1,1))));\n}\n\nfloat sponge(vec3 p, float size){\n    float res = box(p,vec3(size));\n    float c = 2.*size;\n    float crSiz =3.; \n    for(int i = 0; i < 4; i++){\n      vec3 q = mod(p+0.5*c,c)-0.5*c;\n      float subt = cros(q*(crSiz/size))/(crSiz/size);  \n      res=max(-subt,res);\n      c/=3.;\n      crSiz*=3.;\n    }\n    return res;\n}\nfloat map(vec3 p){\n    return sponge(p,1.7);\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,0.01);\n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n}\n\nvec3 skyColor(vec3 rd){\n    vec3 outLight = vec3(0.125);\n    outLight+=addLight(10.*vec3(0.7,0.2,0.3),normalize(-vec3(0.2,0.05,0.2)),rd);\n    outLight+=addLight(10.*vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-11.);\n    vec3 rd = normalize(vec3(uv,1));\n    rd.xy*=rot(iTime/8.);\n    ro.xz*=rot(iTime/8.);\n    rd.xz*=rot(iTime/8.);   \n    vec3 color = vec3(0);\n    vec3 accum = vec3(0);\n    float tot = 0.;\n    for(int i = 0; i<80;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n        vec3 n = normal(p);\n        if(dst>0.01){\n        \tcolor = skyColor(rd)/2.;\n        }\n        else{    \n        \tcolor  = vec3(tot/1000.);    \n        }\n        accum+=color*0.04;\n    }\n    fragColor = vec4(1.-(accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 67], [69, 69, 98, 98, 191], [193, 193, 212, 212, 314], [316, 316, 349, 349, 634], [635, 635, 653, 653, 681], [683, 683, 703, 703, 874], [876, 876, 928, 928, 1096], [1098, 1098, 1121, 1121, 1341], [1343, 1343, 1399, 1399, 2022]], "test": "untested"}
{"id": "Wl2cDt", "name": "Basic 2 pass AA", "author": "Nrx", "description": "Basic anti-aliasing using 2 buffers (1 buffer being shifted by 0.5 pixel, and fetched with linear filtering).\nClick to disable it.", "tags": ["aa"], "likes": 4, "viewed": 346, "published": 3, "date": "1595717776", "time_retrieved": "2024-07-30T20:53:57.396204", "image_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene normally\n\tfragColor = Render (fragCoord, iResolution.xy, iTime);\n\n\t// Mix with the scene shifted by half a pixel\n\t// Notes:\n\t// - Linear filtering has to be used to fetch the color\n\t// - A value of 0.8 for the mix returns the actual average of the 5 sampling points,\n\t//   while 0.5 acts more like a Gaussian filter\n\tif (iMouse.z < 0.5) {\n\t\tfragColor = mix (fragColor, texture (iChannel0, (fragCoord + 0.5) / iResolution.xy), 0.5);\n\t}\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\t// Render the scene shifted by half a pixel\n\tif (iMouse.z < 0.5) {\n\t\tfragColor = Render (fragCoord - 0.5, iResolution.xy, iTime);\n\t}\n}", "buffer_a_inputs": [], "common_code": "// Example: basic Mandelbrot set display (from https://www.shadertoy.com/view/tt2yWV)\n#define C vec2 (-0.743603, 0.1318205)\n#define N 900.0\n\nmat2 Rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat Mandelbrot (in vec2 c)\n{\n\tvec2 m = c;\n\tfor (float n = 0.0; n < N; ++n) {\n\t\tif (dot (m, m) > 4.0) {\n\t\t\treturn n / N;\n\t\t}\n\t\tm = vec2 (m.x * m.x - m.y * m.y, 2.0 * m.x * m.y) + c;\n\t}\n\treturn 1.0;\n}\n\nvec4 Render (in vec2 fragCoord, in vec2 resolution, in float time)\n{\n\tvec2 c = (2.0 * fragCoord - resolution) / resolution.y;\n\tfloat zoom = pow (0.5, 18.0 * (0.72 - 0.28 * cos (time * 0.2)));\n\tfloat m = Mandelbrot (zoom * Rotate (time * 0.3) * c + C);\n\treturn vec4 (m, pow (m, 0.6), pow (m, 0.3), 1.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 86, 514]], "test": "untested"}
{"id": "Wl2cWt", "name": "Mario Rotozoom", "author": "CelestialAmber", "description": "Mario sprite and sprite code taken from this shader: https://www.shadertoy.com/view/XtlSD7", "tags": ["mario", "rotozoom"], "likes": 2, "viewed": 472, "published": 3, "date": "1595713236", "time_retrieved": "2024-07-30T20:53:58.186093", "image_code": "#define SPRITE_DEC( x, i ) \tmod( floor( i / pow( 4.0, mod( x, 8.0 ) ) ), 4.0 )\n#define RGB( r, g, b ) vec3( float( r ) / 255.0, float( g ) / 255.0, float( b ) / 255.0 )\n#define pi 3.14159265\n\n\n\n\nvoid SpriteMario( inout vec3 color, float x, float y, float frame )\n{    \n    float idx = 0.0;\n\n\tif ( frame == 0.0 )\n    {\n        idx = y == 14.0 ? ( x <= 7.0 ? 40960.0 : 42.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 43008.0 : 2730.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 21504.0 : 223.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 56576.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 23808.0 : 16255.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 62720.0 : 1375.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 61440.0 : 1023.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 21504.0 : 793.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 22272.0 : 4053.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 23488.0 : 981.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43328.0 : 170.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43584.0 : 170.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 10832.0 : 42.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 16400.0 : 5.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 16384.0 : 21.0 ) : idx;\n\t}\n    else if ( frame == 1.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 25856.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 38208.0 : 22.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 42304.0 : 235.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 38208.0 : 170.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 62848.0 : 171.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 62976.0 : 42.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 43008.0 : 21.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 21504.0 : 85.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 21504.0 : 1.0 ) : idx;\n    }\n    else if ( frame == 2.0 ) \n    {\n        idx = y == 15.0 ? ( x <= 7.0 ? 43008.0 : 10.0 ) : idx;\n        idx = y == 14.0 ? ( x <= 7.0 ? 43520.0 : 682.0 ) : idx;\n        idx = y == 13.0 ? ( x <= 7.0 ? 54528.0 : 55.0 ) : idx;\n        idx = y == 12.0 ? ( x <= 7.0 ? 63296.0 : 1015.0 ) : idx;\n        idx = y == 11.0 ? ( x <= 7.0 ? 55104.0 : 4063.0 ) : idx;\n        idx = y == 10.0 ? ( x <= 7.0 ? 64832.0 : 343.0 ) : idx;\n        idx = y == 9.0 ? ( x <= 7.0 ? 64512.0 : 255.0 ) : idx;\n        idx = y == 8.0 ? ( x <= 7.0 ? 42320.0 : 5.0 ) : idx;\n        idx = y == 7.0 ? ( x <= 7.0 ? 42335.0 : 16214.0 ) : idx;\n        idx = y == 6.0 ? ( x <= 7.0 ? 58687.0 : 15722.0 ) : idx;\n        idx = y == 5.0 ? ( x <= 7.0 ? 43535.0 : 1066.0 ) : idx;\n        idx = y == 4.0 ? ( x <= 7.0 ? 43648.0 : 1450.0 ) : idx;\n        idx = y == 3.0 ? ( x <= 7.0 ? 43680.0 : 1450.0 ) : idx;\n        idx = y == 2.0 ? ( x <= 7.0 ? 2708.0 : 1448.0 ) : idx;\n        idx = y == 1.0 ? ( x <= 7.0 ? 84.0 : 0.0 ) : idx;\n        idx = y == 0.0 ? ( x <= 7.0 ? 336.0 : 0.0 ) : idx;\n    }\n\n    idx = SPRITE_DEC(x, idx);\n    \n\tcolor = idx == 1.0 ? RGB(106, 107, 4) : color;\n\tcolor = idx == 2.0 ? RGB(177, 52, 37) : color;\n\tcolor = idx == 3.0 ? RGB(227, 157, 37) : color;    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 pos = fragCoord;\n    pos = (pos - iResolution.xy/2.0) * 0.25*(sin(1.5*iTime) + 1.2);\n    float a = mod(iTime, 2.0*pi);\n    pos = vec2(pos.x*cos(a)-pos.y*sin(a),pos.x*sin(a)+pos.y*cos(a));\n    pos = floor(mod(pos,16.0));\n    \n    vec3 col = vec3(0.0);\n    \n    SpriteMario(col, pos.x, pos.y, floor(mod(8.0*iTime,3.0)));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[195, 195, 264, 264, 3559], [3563, 3563, 3620, 3670, 4072]], "test": "untested"}
{"id": "3ljyWt", "name": "star field 4 regolfed (311 ch)", "author": "FabriceNeyret2", "description": "regolfing \"star field 4 (433 chars)\" [url]https://shadertoy.com/view/ltBXDd[/url]\n\n", "tags": ["texture", "advection", "starfield", "short", "golf", "3tweets"], "likes": 6, "viewed": 702, "published": 3, "date": "1595706652", "time_retrieved": "2024-07-30T20:53:59.053772", "image_code": "// regolfing \"star field 4 (433 chars)\" by FabriceNeyret2. https://shadertoy.com/view/ltBXDd\n// ( more readable below )\n\n\n#define R  fract( 1e4* sin(  mat2(1234,-53,457,-17) * I//\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * (t.i+.75) / exp2(t.i*8.-5.) ),             \\\n     r = .13 + 6.* R +1.)),                                       \\\n\t r.x > .79 ? 1. : dot( V = ( .6*R))-.8 - V+I ) / r.x , V ) ) //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 U = u / iResolution.y - .5, I,V,r;\n    vec3 t = fract( iTime/8. + vec3(-1,0,1)/3.  ) -.5;\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) );} /*\n\n\n\n\n\n// --- 313 chars\n\n#define R  fract( 1e4* sin(  mat2(1234,-53,457,-17) * I//\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * (t.i+.75) / exp2(t.i*8.-5.) ),             \\\n     r = R +1.)),                                                 \\\n\t r.x > .11 ? 1. : dot( V = ( .6*R))-.8 - V+I ) / (.13+6.*r.x) , V ) ) //\n#define mainImage(O,u)                                            \\\n    vec2 U = u / iResolution.y - .5, I,V,r;                       \\\n    vec3 t = fract( iTime/8. + vec3(-1,0,1)/3.  ) -.5;            \\\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) ) /*\n\n\n\n\n\n// --- 327 chars\n\n#define R(U) fract( 1e4* sin(  U * mat2(1234,-53,457,-17) ) )    //\n#define M(U,i)  (                                                 \\\n     I = ceil( V = U * ( (t+6./D) /exp2(t*D-5.) ).i ),            \\\n     r = R(1.+I).x,                                               \\\n\t r > .11 ? 1. : dot( V = ( .6*R(I)-.8 - V+I ) / (.13+6.*r) , V ) ) //\n#define mainImage(O,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n    vec3 t = fract( iTime/D + vec3(-1,0,1)/3.  ) -.5;             \\\n    O += dot( 1.+cos(6.28*t) , .015/vec3( M(U,x), M(-U,y), M(U.yx,z) ) ) /*\n\n\n\n\n\n// --- 345 chars\n\n#define R(U) fract( 1e4* sin(  U*mat2(1234,-53,457,-17) ) )      //\n#define M(U,t)  (                                                 \\\n     I = ceil( V = U/exp2(t-8.) / D*(3.+t) ),                     \\\n     r = 9.* R(1.+I).x,                                           \\\n\t r > 1. ? 1. : length( .6*R(I)-.8 - V+I ) * 8./(1.+5.*r) )   //\n#define mainImage(O,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n    vec3 t = fract( iTime/D + vec3(-1,0,1)/3.  ) -.5,             \\\n         T = t*D+3.;                                              \\\n    T = vec3( M(U,T.x), M(-U,T.y), M(U.yx,T.z) );                 \\\n    O += dot( .5+.5*cos(6.28*t) , .03/T/T )                                          /*\n\n\n\n\n\n// --- 368 chars\n\n#define R(U,d) fract( 1e4* sin( d + U*mat2(1234,-53,457,-17) ) ) //\n#define M(U,t)  (                                                 \\\n     I = ceil( V = U/exp2(t-8.) / D*(3.+t)),                      \\\n     r = 9.* R(I,1.).x,                                           \\\n\t r > 1. ? 1. : length( .2+.6*R(I,) - fract(V) ) * 8./(1.+5.*r) ) //\n#define mainImage(o,u)                                            \\\n    float D=8.,r;                                                 \\\n    vec2 U = u / iResolution.y - .5, I,V;                         \\\n         t = fract( iTime/D + vec3(-1,0,1)/3. +.5 ) -.5,  T,      \\\n         w = .5+.5*cos(6.28*t);                                   \\\n    t = t*D+3.;                                                   \\\n    T.x = M(U,t.x),  T.y = M(-U,t.y),  T.z = M(U.yx,t.z);         \\\n    o += dot(w,.03/T/T)                                          /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[449, 449, 485, 485, 659]], "test": "untested"}
{"id": "wtBcWd", "name": "Waves v.4", "author": "pli", "description": "Same boat, now in 3d. Only realized how slow it was when I tried it on my old computer :)\nV.5 is much faster: https://www.shadertoy.com/view/wt2yDt", "tags": ["learning"], "likes": 0, "viewed": 185, "published": 3, "date": "1595702882", "time_retrieved": "2024-07-30T20:54:00.016199", "image_code": "// raymarching and lighting from https://www.shadertoy.com/view/MltcDB\n\n#define SKY_COLOR vec3(0.0, 0.18, 0.2)\n\n#define BASE_COLOR vec3(0.4, 0.6, 0.6)\n#define BOAT_COLOR vec3(1., 0.57, 0.0)\n#define HEAD_COLOR vec3(.7, .6, .4)\n#define EYE_COLOR vec3(0., 0.0, 0.0)\n\n#define BOAT_INITIAL_X 0.1\n#define BOAT_INITIAL_Z 0.3\n\n\n#define X_WAVES 10.\n#define Z_WAVES 10.\n#define X_WAVE_SPACE 0.15\n#define Z_WAVE_SPACE 0.1\n\n#define WAVE_SMOOTH 0.13\n#define BOAT_SMOOTH 0.03\n\n\n\n#define STEPS 64.\n#define STEPS_SHADOW 32.\n#define PI 3.14159\n#define EPS 0.0001\n#define EPSN 0.001\n#define EPSOUT 0.01\n\nmat2 rot(float a){\n\treturn mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\n\nfloat smoothmin(float a, float b, float k){\n\tfloat f = clamp(0.5 + 0.5 * ((a - b) / k), 0., 1.);\n    return (1. - f) * a + f  * b - f * (1. - f) * k;\n}\n\n\nfloat distSphere(vec3 p, vec3 center, float radius) {\n\t\treturn sqrt( (p.x-center.x) * (p.x-center.x) + (p.y-center.y) * (p.y-center.y) + (p.z-center.z) * (p.z-center.z)) - radius;   \n}\n\nfloat distPoints(vec2 p1, vec2 p2) {\n\treturn sqrt( (p1.x-p2.x) * (p1.x-p2.x) + (p1.y-p2.y) * (p1.y-p2.y));   \n}\n\n\nfloat heightAt(float xd, float z) {\n    return -0.1 + 0.01 * cos(13.*xd + 2.*z);\n}\n\nfloat boatHeight(vec3 pos, float delta) {\n    return -0.1 - 0.01 * cos(6. * pos.x + delta * 2. * 3.14159) + 0.1;\n}\n\nfloat sphereSize(float x, float z) {\n    return 0.1 + 0.02 * cos(4.*x - z);\n}\n\n\nvec3 coordsFromGrid(vec3 grid) {\n\tvec3 coords;\n    coords.x = -X_WAVE_SPACE * X_WAVES / 2. + grid.x * X_WAVE_SPACE;\n    coords.y = grid.y;\n    coords.z = grid.z * Z_WAVE_SPACE;\n    return coords;\n}\n\nvec3 gridFromCoords(vec3 coords) {\n\tvec3 grid;\n    grid.x = (coords.x + X_WAVE_SPACE * X_WAVES / 2.) / X_WAVE_SPACE;\n    grid.y = coords.y;\n    grid.z = coords.z / Z_WAVE_SPACE;\n    return grid;\n}\n\nfloat waveSizeAt(vec3 coords) {\n    return 0.10 + 0.03 * cos(coords.x + 2. * sin(0.5*coords.z) + 4.*iTime);   \n}\n\n\nfloat boatYAt(vec3 coords) {\n    return 0.04 + waveSizeAt(coords);   \n}\n\n\nfloat distScene(vec3 pos, out vec3 colorVariation, out float shineVariation){\n    // pos.xz = rot(1.5 * sin(0.25 * iTime)) * pos.xz;\n    pos.y += 0.35;\n    \n    colorVariation = vec3(1.);\n\n    // waves\n    float dist = 1.;\n    for (float x = 0. ; x < X_WAVES ; x+=1.) {\n        for (float z = 0. ; z < Z_WAVES ; z+=1.) {\n\n            vec3 coords = coordsFromGrid(vec3(x, 0., z));            \n            \n            float size = waveSizeAt(vec3(x, 0., z));\n\t\t\tfloat distSphere = distSphere(pos, coords, size);\n   \t\t \tdist = smoothmin(dist, distSphere, WAVE_SMOOTH); // 0.08\n        }\n    }\n    \n    colorVariation = BASE_COLOR;\n    shineVariation = 1.;\n    \n    float initialX = BOAT_INITIAL_X + 0.1 * cos(0.5*iTime) + 0.05 * cos(0.95*iTime);\n\n    float initialZ = BOAT_INITIAL_Z + 0.1 * cos(0.8*iTime);\n\n\n    // boat\n    vec3 boatPosition = vec3(initialX, 0.0, initialZ);\n\t\n    vec3 p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    float boatDist = distSphere(pos, p, 0.05);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n    \n\n    \n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n    boatPosition.x += 0.15;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    \n\n    boatPosition.x = initialX;\n    boatPosition.z += 0.05;\n\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n\n    p = vec3(boatPosition.x,boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n    boatPosition.x += 0.05;\n   \tp = vec3(boatPosition.x, boatYAt(gridFromCoords(boatPosition)), boatPosition.z);\n    boatDist = smoothmin(boatDist, distSphere(pos, p, 0.05), BOAT_SMOOTH);\n\n\n    if (boatDist < dist) {\n        dist = boatDist;\n   \t \tcolorVariation = BOAT_COLOR;\n        shineVariation = .5;\n    }\n    \n    \n    // head \n    boatPosition.x = initialX + 0.05;\n    boatPosition.y = 0.0;\n    boatPosition.z = initialZ + 0.05;\n    vec3 headPosition = boatPosition;\n    headPosition.x -= 0.05;\n    p = vec3(boatPosition.x, boatYAt(gridFromCoords(headPosition)) + 0.05, boatPosition.z);\n\n    float headDist = distSphere(pos, p, 0.02);\n    if (headDist < dist) {\n     \tdist = headDist;\n   \t \tcolorVariation = HEAD_COLOR;\n\t\tshineVariation = .0;\n    }\n\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p){\n    vec3 c;\n    float s;\n\treturn(normalize(vec3(distScene(p + vec3(EPSN, 0., 0.), c, s) - distScene(p - vec3(EPSN, 0., 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., EPSN, 0.), c, s) - distScene(p - vec3(0., EPSN, 0.), c, s),\n               \t\t\tdistScene(p + vec3(0., 0., EPSN), c, s) - distScene(p - vec3(0., 0., EPSN), c, s))));\n}\n\n\nvec3 render(vec2 uv){\n\tvec3 col = BASE_COLOR;\n    vec3 ink = vec3(0.15, 0.2, 0.3);\n    \n    //camera\n    vec3 eye = vec3(0., 1.,6.);\n    vec3 ray = normalize(vec3(uv, 1.) - eye);\n  \tray.yz = rot(0.12) * ray.yz;\n   \teye.yz = rot(0.12) * eye.yz;\n    \n    \n    // moon\n    vec2 moonPosition = vec2(0.23, 0.25);\n    if (distPoints(moonPosition, uv) < 0.2) {\n   \t \treturn vec3(0.9);\n    }\n\n\n   \t//raymarch\n    vec3 pos = eye;\n    vec3 colorVariation;\n    float shineVariation;\n    float s, prevDist, totDist = 0.;\n    float maxDist = 7.;\n        \n    float dist = distScene(pos, colorVariation, shineVariation);\n    for(float s = 0.; s < STEPS; s++){\n        prevDist = dist;\n    \tdist = distScene(pos, colorVariation, shineVariation);\n        if(abs(dist) < EPS || totDist > maxDist){\n            break;\n        }\n        pos += ray * dist;\n        totDist += dist;\n    }\n    \n    if(totDist > maxDist) {\n        return SKY_COLOR;\n    }\n\n    \n    vec3 normal = getNormal(pos);\n    vec3 light = normalize(vec3(1., 1., -3));\n    light.yz = rot(0.3) * light.yz;\n\n    col = colorVariation * (0.75 + dot(normal, light));\n    \n    //white highlight\n    float shine = 10.;\n    vec3 refl = reflect(normalize(pos - light), normal);\n    float spec = pow(clamp(dot(normalize(eye - pos), refl), 0., 1.), shine);\n    spec = smoothstep(0.45, 0.55, spec - 0.3);\n\tcol = mix(col, vec3(1.), (shineVariation -  0.5 * colorVariation) * spec);\n    \n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n    vec3 col = render(uv);\n\t\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[586, 586, 604, 604, 653], [656, 656, 699, 699, 807], [810, 810, 863, 863, 994], [996, 996, 1032, 1032, 1107], [1110, 1110, 1145, 1145, 1192], [1194, 1194, 1235, 1235, 1308], [1310, 1310, 1346, 1346, 1387], [1390, 1390, 1422, 1422, 1587], [1589, 1589, 1623, 1623, 1785], [1787, 1787, 1818, 1818, 1899], [1902, 1902, 1930, 1930, 1973], [1976, 1976, 2053, 2108, 5376], [5378, 5378, 5401, 5401, 5739], [5742, 5742, 5763, 5763, 7184], [7186, 7186, 7243, 7243, 7371]], "test": "untested"}
{"id": "wlSyDd", "name": "Colorful smoke noise", "author": "jaszunio15", "description": "Experimenting with cellular noise resulted with this smoke-like shader. I'm quite happy with the result, as it is just 2 layers of modified Worley noise.\n\nUse mouse to adjust cartoon effect :)\n\nLicense: CC BY 3.0\nAuthor: Jan Mróz (jaszunio15)", "tags": ["noise", "smoke", "domainwarp"], "likes": 22, "viewed": 1528, "published": 3, "date": "1595701779", "time_retrieved": "2024-07-30T20:54:00.824039", "image_code": "//License: CC BY 3.0\n//Author: Jan Mróz (jaszunio15)\n\n/*\n\tOriginally I wanted to make noise based on Voronoise by Inigo Quilez, \n\tbut without reading his code. \n\t(reference shader: https://www.shadertoy.com/view/Xd23Dh)\n\t\n\tMy shader quicky became something different. My concept wasn't\n\tnearly close to what Inigo did. Maybe next time :)\n*/\n\n#define TIME (iTime * 5.0)\n\nvec2 hash22(vec2 x)\n{\n \treturn fract(sin(x * mat2(43.37862, 24.58974, 32.37621, 53.32761)) * 4534.3897);\n}\n\nfloat hash12(vec2 x)\n{\n \treturn fract(sin(dot(x, vec2(43.37861, 34.58761))) * 342.538772);\n}\n\nvec2 getCellPoint(vec2 cell)\n{\n    float time = TIME * (hash12(cell + 0.123) - 0.5) * 0.5;\n    float c = cos(time), s = sin(time);\n    vec2 hash = (hash22(cell) - 0.5) * mat2(c, s, -s, c) + 0.5;;\n \treturn hash + cell;\n}\n\nfloat getCellValue(vec2 cell)\n{\n \treturn hash12(cell);\n}\n\nfloat makeSmooth(float x)\n{\n    float mouse = (iMouse.x / iResolution.x);\n    if (mouse == 0.0) mouse = 1.0 - (cos(iTime * 0.5) * 0.5 + 0.5);\n  \treturn mix(x * x * (3.0 - 2.0 * x), sqrt(x), mouse);\n}\n\nfloat modifiedVoronoiNoise12(vec2 uv)\n{\n \tvec2 rootCell = floor(uv);\n\n    float value = 0.0;\n\n    for (float x = -1.0; x <= 1.0; x++)\n    {\n     \tfor(float y = -1.0; y <= 1.0; y++)\n        {\n         \tvec2 cell = rootCell + vec2(x, y);\n            vec2 cellPoint = getCellPoint(cell);\n            float cellValue = getCellValue(cell);\n            float cellDist = distance(uv, cellPoint);\n            value += makeSmooth(clamp(1.0 - cellDist, 0.0, 1.0)) * cellValue;\n        }\n    }\n\n    return value * 0.5;\n}\n\nfloat layeredNoise12(vec2 x)\n{\n \tfloat sum = 0.0;\n    float maxValue = 0.0;\n\n    for (float i = 1.0; i <= 2.0; i *= 2.0)\n    {\n        float noise = modifiedVoronoiNoise12(x * i) / i;\n     \tsum += noise;\n        maxValue += 1.0 / i;\n    }\n\n    return sum / maxValue;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 stretchedUV = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.xy;\n\tfloat vignette = smoothstep(0.55, 0.0, length(stretchedUV));\n\tuv.y -= TIME * 0.05;\n    \n\tuv *= 6.0;\n    \n  \t//just simplified hue shifting stuff with uv based offset\n  \tvec4 col = sin(TIME * 0.1 + uv.y * 0.2 + vec4(0,2,4,6)) * 0.5 + 0.5;\n  \tvec4 col2 = sin(TIME * 0.1 + 0.6 + uv.y * 0.2 + vec4(0,2,4,6)) * 0.5 + 0.5;\n\n    uv += layeredNoise12(uv);\n    //uv -= layeredNoise12(uv + 43.0) * 0.5;\n  \tfloat noise = layeredNoise12(uv);\n  \tnoise *= vignette;\n  \tfragColor = mix(col, col2 * 0.2, 1.0 - noise * 2.0);\n    fragColor = smoothstep(-0.14, 1.1, fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyDd.jpg", "access": "api", "license": "cc-by-3.0", "functions": [[371, 371, 392, 392, 477], [479, 479, 501, 501, 571], [573, 573, 603, 603, 792], [794, 794, 825, 825, 850], [852, 852, 879, 879, 1051], [1053, 1053, 1092, 1092, 1562], [1564, 1564, 1594, 1594, 1832], [1834, 1834, 1891, 1891, 2598]], "test": "untested"}
{"id": "tlBcWd", "name": "Unicorn Torus (FieldFX)", "author": "blackle", "description": "coded in 25 minutes for shader showdown!", "tags": ["shadershowdown", "livecode"], "likes": 32, "viewed": 1773, "published": 3, "date": "1595694469", "time_retrieved": "2024-07-30T20:54:01.780482", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat box(vec2 p, vec2 d) {\n    p = abs(p)-d;\n    return length(max(p,0.))+min(0.,max(p.x,p.y));\n}\n\nfloat blob(vec3 p) {\n    p =asin(sin(p*10.))/10.;\n    return length(p);\n}\n\nfloat wallthing;\nfloat light;\nfloat t;\nfloat scene(vec3 p) {\n    vec2 tdim = vec2(3.,1.5);\n    float tdist = length(vec2(length(p.xy)-tdim.x,p.z))-tdim.y;\n    \n    vec3 pring = vec3(normalize(p.xy)*tdim.x,0);\n    vec3 pax = normalize(cross(pring,vec3(0,0,1)));\n    vec3 poff = p-pring;\n    float pang = atan(pring.x,pring.y);\n    float prot = sin(iTime+pang);\n    poff = erot(poff,pax,prot);\n    vec3 ploc = pring+poff;\n    vec3 pclos = pring+normalize(poff)*tdim.y;\n    \n    float wdth = dot(sin(pclos*2.),cos(pclos*2.))*.5+.3;\n    float blb = blob(pclos);\n    wallthing = box(vec2(blb,tdist), vec2(wdth,.2))-.05;\n    wallthing = min(wallthing, box(vec2(blb,tdist), vec2(.04,.4+sin(t*5.)*.2))-.01);\n    vec3 rtd=vec3(asin(sin(ploc.xy*2.))/2.,ploc.z);\n    float pillar = length(rtd.xy)-.02;\n    pillar = min(pillar, box(vec2(pillar,asin(sin(rtd.z*10.+t*6.))/10.),vec2(0.03,0.02))-.01);\n    light = length(vec2(wallthing,tdist))-.02;\n    light = min(light, box(vec2(pillar,asin(sin(rtd.z*10.+t*6.+11.))/10.),vec2(0.03,0.02))-.01);\n    \n    wallthing *= .9;\n    \n    return min(min(min(-tdist,wallthing), pillar),light);\n}\n\nvec3 norm (vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    t = iTime/60.*135.;\n    t = pow(sin(fract(t)*3.1415/2.)*.5+.5,10.)+floor(t);\n    vec3 cam = normalize(vec3(1.-dot(uv,uv)*.9+sin(t*1.5)*.4,uv));\n    vec3 init = vec3(-3.5,0,0)+cam*.1;\n    \n    cam = erot(cam, vec3(1,0,0), cos(t/2.)*.5);\n    cam = erot(cam, vec3(0,0,1), t/4.);\n    cam = erot(cam, vec3(0,0,1), .7+sin(t)*.5);\n    init = erot(init, vec3(0,0,1), t/4.);\n    \n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    float glo = 0.;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        glo += .05/(1.+abs(light)*30.);\n        p+=dist*cam*.7;\n    }\n    bool wt = wallthing == dist;\n    bool lt = light == dist;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float ro = smoothstep(-.1,.1,scene(p+r*.1));\n    float spec = length(sin(r*3.)*.5+.5)/sqrt(3.);\n    float diff = length(sin(n*2.)*.4+.6)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n    vec3 matcol = wt ? vec3(0.9,0.2,0.8) : vec3(0.04);\n    vec3 col = diff*matcol*ao + pow(spec,10.)*fres*ro;\n    col = abs(erot(col, normalize(sin(p*2.+iTime*2.+r)),1.));\n    if (lt) col = vec3(1);\n    fragColor.xyz = hit ? col : vec3(0.01);\n    fragColor.xyz = sqrt(fragColor.xyz+ glo*glo + glo*vec3(.2,.5,1));\n    fragColor.xyz *= 1.-dot(uv,uv)*.7;\n    fragColor.xyz *= 1.1;\n    fragColor.xyz = smoothstep(0.,1.,fragColor.xyz);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcWd.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 323, 323, 394], [396, 396, 416, 416, 469], [510, 510, 531, 531, 1591], [1593, 1593, 1613, 1613, 1726], [1728, 1728, 1785, 1785, 3260]], "test": "untested"}
{"id": "wtByDt", "name": "Single Sample Bicubic Sampling", "author": "TinyTexel", "description": "left: bicubic reference | right: single sample bicubic approximation", "tags": ["filter", "filtering", "bicubic", "cubic", "interpolation", "kernel", "reconstruction", "c2"], "likes": 16, "viewed": 1683, "published": 3, "date": "1595684300", "time_retrieved": "2024-07-30T20:54:03.014183", "image_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nleft: bicubic reference | right: single sample bicubic approximation\n\nThe following derivation builds on the one from \"Cubic Reconstruction\": https://www.shadertoy.com/view/3tfBzX.\n\nInstead of manually reading the data stored at the four vertices of a given 2x2 neighborhood and using them as weights for our bicubic reconstruction kernels \nwe can instead use the dedicated bilinear sampler of the GPU to do an approximate bicubic reconstruction with just single texture read.\n\nThe basic idea is this:\nGiven an RGBA texture where the four channels hold df/dx, df/dy, d^2f/dxdy, and f, respectively\n1. we remap the uvs local to a given neighborhood using a s-curve\n2. and then sample the texture bilinearly using these remapped uvs\n3. we multiply the interpolated derivative samples with a modulating signal to shape them into something resembling the ground truth kernel based reconstruction\n4. we add the four (in 1d just two) resulting partial signals together to get the final result\n\nSteps 1+2 are not at all new ideas. iq has an article describing doing exactly that for the purpose of getting rid of some bilinear artifacts (https://iquilezles.org/articles/texture).\nAnd in fact using smoothstep as s-curve, as iq suggests, is the ground truth choice if we were only concerned with interpolating the function values.\nThat's because the reconstruction kernel, kern_v, we would otherwise use for that purpose is simply an upside down smoothstep mirrored at the y-axis.\n\nkern_v: 1-x²(3-2|x|)\n1\n|▩◣\n|▩▩◣\n|▩▩▩\n|▩▩▩◣\n|▩▩▩▩◣▂\n0---------1\t\n\nHowever, the tricky part is getting the reconstruction of the derivatives based partial signals (approximately) right.\nThe ground truth reconstruction uses kern_d, which is a linear ramp windowed by a shifted parabola that is mirrored at the y-axis:\n\nkern_d: x(|x|-1)²\n1\n|\n|\n|  \n|  ◢◣\n|◢▩▩▩◣▂\n0---------1\n\n(A proper plot of these kernels can be found here: https://www.shadertoy.com/view/wlsfzX)\n\nThe partial signal we reconstruct with kern_d is zero at all vertices/integers while its derivative there matches our discrete derivative samples.\nSo we can't just interpolate the derivative samples with modified uvs and call it a day as is the case for the partial signal reconstructed from the value samples.\nAnd that brings us to step 3.\n\nFor now we will only consider the 1d case. Generalizing the 1d result to multiple dimensions is straightforward.\nLet's also assume that we sampled our texture using smoothstep-remapped texcoords as this already gives us the correct partial signal from the value channel.\nThis way, however, the derivative channel interpolates to a signal d(x) whose value at all vertices corresponds to what is supposed to be its derivative.\nAlso, since we used s-curve remapped texcoords to retrieve d(x) its derivative is zero at all vertices. \nSo what we want is to modify d(x) in way that if x ∈ integers its value gets turned into its derivative while the value itself gets mapped to zero.\nA simple way to do this is by multiplying d(x) with a modulating signal m(x):\n\ndm(x) = d(x) m(x),\n\nwhere if x ∈ integers\n\nd(x)' = 0,\n\nm(x)  = 0,\nm(x)' = 1,\n\nso that\n\ndm(x)  = 0,\ndm(x)' = d(x).\n\n\nUnder these constraints a natural choice for m(x) would be the cubic function \n\ncwave(x) = kern_d(fract(x)) - kern_d(1-fract(x)).\n\nFor the special case where all our derivative samples are of the same value, m(x) = cwave(x) would give us the ground truth result.\nHowever, if we now consider the special case where all our derivative samples are of the same value but with alternating signs we run into a problem.\nThe problem being that in this particular case d(x) has roots in the middle of each integer interval which cwave(x) can not get rid of.\nIn fact no well behaved choice for m(x) is able to clean up undesired mid-interval roots. \nBut it needs to be well behaved otherwise it has no chance to produce useful results in the general case.\n\nFortunately there is a simple solution. We can ensure that there are no mid-interval zero crossings in d(x) when they wouldn't occur in the ground truth signal.\nWe achieve that by alternatingly flipping the signs of our derivative samples before writing them to the texture and adapting m(x) to account for that:\n\n m(x)' =      (-1)^x,\ndm(x)' = d(x) (-1)^x,\n\nif x ∈ integers.\n\nLet's also introduce m0(x) as a convenient template to build modulators from:\n\nm(x) = m0(fract(x)) (-1)^floor(x),\n\ni.e. m(x) is now build by repeating a bump-like function m0(x) that gets flipped upside down on every second interval. \n\nThe natural choice for m0(x) is now \n\nqwave(x) = kern_d(x) + kern_d(1-x) = x - x^2,\n\ni.e. a simple quadratic bump that has its maximum at x=1/2:\n\nqwave(x):\n1\n|\n|\n|\n|▢◢▩▩◣\n|◢▩▩▩▩◣\n0---------1\n\n(ignore the ▢ it's just there for formatting purposes)\n\nIn this case one could see the resulting m(x) as a piecewise quadratic approximation of sin(xπ)/π (sin() itself is a pretty bad choice for m(x), btw).\n\n\nqwave(x) gives us the ground truth result for the special case of derivative samples of constant value with alternating signs.\nBut this doesn't necessarily mean that it performs well in the general case. \nIn particular with the current choice for the s-curve (s(x) = smoothstep) and the (modulator m0(x) = qwave) we are not even able to \nreconstruct linear signals correctly. This is quite disappointing considering that the ground truth reconstruction is exact for polynomial signals up to degree 3.\nIf we want our approximation to be able to handle linear signals correctly then the following must hold true on the interval [0,1]:\n\nx = lerp(0, 1, s(x)) + m0(x) lerp(1, -1, s(x)). // the -1 here resulting from the derivative sign flipping\n\nSolving for s(x) yields:  s(x) = (x - m0(x) / (1 - 2 m0(x)).\nSolving for m(x) yields: m0(x) = (x -  s(x) / (1 - 2  s(x)).\n\nThis means that under this constraint there is a (symmetrical) one-to-one relationship between the s-curve and the modulator, i.e they are dual to one another:\n\ndual(x, s_or_m0) = (x - s_or_m0(x)) / (1 - 2 s_or_m0(x)).\n\n\nHere is the dual modulator for smoothstep: \ndual(x, smoothstep) = (x^2 - x) / ((x^2 - x) 2 - 1)\n1\n|\n|\n|\n|  ▂▂▂\n|◢▩▩▩▩◣\n0---------1\n\nThis one is quite a bit flatter than qwave(x).\n\nAnd the dual s-curve for qwave is: \ndual(x, qwave) = x^2 / ((x^2 - x) 2 + 1).\n\nThis one looks like a slightly rounder version of smootherstep (not smoothstep); they even share the same derivative at x=1/2.\nIt is actually the pair qwave+dual that in comparison produces the overall better reconstruction approximations; not smoothstep+dual.\nWhich might be a bit surprising since using smoothstep, as mentioned before, is the ground truth choice if we only look at the interpolated value samples.\nBut I guess that doesn't count for much since the dual of smoothstep is generally a substantially worse modulator than qwave while \nthe dual of qwave is a pretty decent s-curve.\n\nNow there is obviously an infinite number of possible s(x)/m(x) pairs. So who is to say that there isn't a pair that is superior to qwave+dual?\nI did quite a bit of experimentation and while qwave did indeed turn out to be a pretty solid choice it seems that depending on the sampled signal \na slightly flatter version of qwave sometimes gives better results.\n\nFor experimentation purposes it is handy to have a modulator with a parameterized shape.\nHere is a polynomial one that is parameterized by the height h of its extremum at x=1/2:\n\nqiwave(x, h) = x + (x*x) * (a + x * (b + (c * x))),\n\nwith\n\na = -5.0 + 16.0 * h,\nb =  8.0 - 32.0 * h,\nc = -4.0 + 16.0 * h,\n\nand\n\nqiwave(1/2, h) = h,\n\nand the usual constraints for any m0(x):\n\nqiwave(0, h)  = 0,\nqiwave(1, h)  = 0,\nqiwave(0, h)' = 1,\nqiwave(1, h)' =-1.\n\nI found that in cases where qiwave(x, h) works better than qwave(x) good choices for h lie somewhere around 0.2.\n\nWe can justify h~0.2 formally by showing that this choice optimizes the resulting approximation of kern_d:\n\nerror[h_] := NIntegrate[(kern_d[x] - qiwave[x, h](1-dual[x, qiwave])))^2, {x, 0, 1}]\nFindMinimum[error, {h, 0.2}]\nh -> 0.220852\n\nMinimizing the integrated absolute differences instead of the squared ones gives:\n\nerror[h_] := NIntegrate[Abs[kern_d[x] - qiwave[x, h](1-dual[x, qiwave]))], {x, 0, 1}]\nFindMinimum[error, {h, 0.2}]\nh -> 0.214553\n\nConsidering that both these values produce very similar results I suggest h = 0.21875 as this allows us to optimize away one mad:\n\nqiwave(x, 0.21875) = ((x - x x) (-1/2) + 1) (x - x x) // mad, mad, mul: http://shader-playground.timjones.io/b09dbef230fefe19cc359bae2f408b5f\n                   = ( qwave(x) (-1/2) + 1)  qwave(x)\n\nI wasn't actually able to identify a clear pattern for when qiwave works better than qwave.\nBut since turning qwave into qiwave requires just a single additional line of code there is no real effort to simply trying both on a case by case basis. \n\n\nRelated:\n\n- https://www.shadertoy.com/view/3tfBzX | \"Cubic Reconstruction\"            (derivation of the ground truth bicubic reconstruction scheme)\n- https://www.shadertoy.com/view/WtsBDH | \"Bicubic C2 cont. Interpolation\"  (describes a pre-filtering approach to achieve C2 continuity)\n- https://www.shadertoy.com/view/tdtyzj | \"Single Sample Tricubic Sampling\" (3d generalization of the sampling approach described here)\n\n*/\n\n\nvec2 qiwave(vec2 x, float h)\n{\n    float a = -5.0 + 16.0 * h;\n    float b =  8.0 - 32.0 * h;\n    float c = -4.0 + 16.0 * h;\n    \n    return x + (x*x) * (a + x * (b + c * x));\n}\n\nfloat Sample(sampler2D channel, vec2 uv, vec2 texelCount)\n{\n    vec2 uv0 = uv;\n    \n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    vec2 mo = uvf - uvf*uvf;\n    \n   #if 0\n    mo = (mo * -0.5 + 1.0) * mo;// use this if it improves quality\n   #endif\n    \n    uvf = (uvf - mo) / (1.0 - 2.0 * mo);// map modulator to s-curve\n\n    uv = uvi + uvf + vec2(0.5);\n\n    vec4 v = textureLod(channel, uv / texelCount, 0.0);\n    \n    mo *= fract(uvi * 0.5) * 4.0 - 1.0;// flip modulator bump on every 2nd interval\n    \n    return dot(v, vec4(mo.xy, mo.x*mo.y, 1.0));\n}\n\n\nfloat kern_v(float x) { return 1.0-x*x*(3.0-2.0*abs(x)); }\nfloat kern_d(float x) { float o = abs(x)-1.0; return x*(o*o); }\n\nvec4 kern(vec2 p)\n{\n    return vec4(kern_d(p.x) * kern_v(p.y),\n                kern_v(p.x) * kern_d(p.y),\n                kern_d(p.x) * kern_d(p.y),\n                kern_v(p.x) * kern_v(p.y));\n}\n\nfloat SampleRef(sampler2D channel, vec2 uv)\n{\n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    ivec2 uv0 = ivec2(uvi);\n    \n    vec2 sn = vec2((uv0.x & 1) == 0 ? -1.0 : 1.0,\n                   (uv0.y & 1) == 0 ? -1.0 : 1.0);\n    \n    float r = 0.0;\n    for(int j = 0; j < 2; ++j)\n    for(int i = 0; i < 2; ++i)\n    {\n        vec4 c = texelFetch(channel, uv0 + ivec2(i, j), 0);\n        \n        vec2 l = uvf;\n        \n        vec2 sn0 = sn;\n        \n        if(i != 0) {l.x -= 1.0; sn0.x *= -1.0;}\n        if(j != 0) {l.y -= 1.0; sn0.y *= -1.0;}\n        \n        c.xyz *= vec3(sn0, sn0.x*sn0.y);// un-flip derivative sample signs; we usually don't need this for the ground truth reconstruction\n        \n        r += dot(c, kern(l));\n    }\n    \n\treturn r;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{\n    vec3 col = vec3(0.0);\n    \n    float s = 0.125*1.0;\n   \n   #if 1\n    vec4 h;\n    if(uv0.x < iResolution.x*0.5)\n    {\n        // bicubic reference\n    \tcol = SampleRef(iChannel0, uv0 * s) * vec3(1.0);\n    }\n    else\n    {\n        uv0.x -= iResolution.x*0.5;\n        \n        // single-sample approximation\n        col = Sample(iChannel0, uv0 * s, iResolution.xy) * vec3(1.0);\n        \n        //col = texture(iChannel0, uv0 * s / iResolution.xy).www;// bilinear\n    }\n    \n   #else\n    col = abs(SampleRef(iChannel0, uv0 * s) - \n              Sample   (iChannel0, uv0 * s, iResolution.xy)) * vec3(16.0);// abs error\n   #endif\n    \n    fragColor = vec4(GammaEncode(clamp01(col)), 0.0);\n}\n\n\n\n\n\n/*\n\nfloat Sample(sampler2D channel, vec2 uv, vec2 texelCount)\n{\n    vec2 uv0 = uv;\n    \n    uv -= vec2(0.5);\n    \n    vec2 uvi = floor(uv);\n    vec2 uvf = uv - uvi;\n\n    vec2 mo = uvf - uvf*uvf;\n    \n   #if 0\n    mo = (mo * -0.5 + 1.0) * mo;// use this if it improves quality\n   #endif\n    \n    //uvf = (uvf - mo) / (1.0 - 2.0 * mo);// map modulator to s-curve\n\n    uvf.y = cubic(uvf.y);\n    \n    uv = uvi + uvf + vec2(0.5);\n\n    vec4 v = textureLod(channel, uv / texelCount, 0.0);\n\n    if(false)\n    v.x = mix(mix(texelFetch(channel, ivec2(uvi)+ivec2(0,0), 0).x, texelFetch(channel, ivec2(uvi)+ivec2(1,0), 0).x, uvf.x),\n              mix(texelFetch(channel, ivec2(uvi)+ivec2(0,1), 0).x, texelFetch(channel, ivec2(uvi)+ivec2(1,1), 0).x, uvf.x), uvf.y);\n    \n    mo *= fract(uvi * 0.5) * 4.0 - 1.0;// flip modulator bump on every 2nd interval\n    \n    return v.x * mo.x;//exact \n    return dot(v, vec4(mo.xy, mo.x*mo.y, 1.0));\n}\n\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rsqrt inversesqrt\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define If(cond, resT, resF) mix(resF, resT, cond)\n\nconst float Pi = 3.141593;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\n\nfloat cubic(float x) { return x*x*(3.0-2.0*x); }\nvec2  cubic(vec2  x) { return x*x*(3.0-2.0*x); }\nvec3  cubic(vec3  x) { return x*x*(3.0-2.0*x); }\nvec4  cubic(vec4  x) { return x*x*(3.0-2.0*x); }\n\nfloat quintic(float x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec2  quintic(vec2  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec3  quintic(vec3  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}\nvec4  quintic(vec4  x){ return ((x * 6.0 - 15.0) * x + 10.0) * x*x*x;}", "buffer_a_code": "// Lincense: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\nThis is the pre-filtering routine from \"Bicubic C2 cont. Interpolation\": https://www.shadertoy.com/view/WtsBDH.\n*/\n\n#define FILTERING_MODE 0\n/*\n\t0: interpolating cubic kernel (produces C2 continuous signal without altering the sample values)\n\t1: generalized cubic BSpline (produces C2 continuous signal with smaller kernel but alters the sample values)\n\t2: central difference (reconstructed signal will not be C2 continuous; overall bad quality)\n*/\n\n#define FETCH(uv) pow(texelFetch(iChannel1, uv + ivec2(90, 50), 0).r, 2.2)\n\n\nvoid mainImage( out vec4 fragColor, in vec2 uv0 )\n{    \n    ivec2 uv = ivec2(uv0 - 0.5);\n    \n    vec4 col = vec4(0.0);\n    \n#if FILTERING_MODE == 0\n    // ======================================================= INTERPOLATING CUBIC KERNEL =======================================================\n    \n    // truncated kernel radii for 1st and 2nd derivatives respectively\n    int r1 = 5;\n    int r2 = 2;\n    \n    col.w = FETCH(uv);\n    \n   #if 1\n    // precomputed kernel\n    float kern[12];\n    kern[0] = 0.0         ; kern[1] = -0.803848    ; kern[ 2] = 0.21539       ; kern[ 3] = -0.0577137    ; \n    kern[4] = 0.0154643   ; kern[5] = -0.00414365  ; kern[ 6] = 0.00111029    ; kern[ 7] = -0.000297501  ; \n    kern[8] = 0.0000797152; kern[9] = -0.0000213596; kern[10] = 0.00000572329 ; kern[11] = -0.00000153355;\n   #else\n    // compute kernel at compile time\n    float kern[12];\n    {\n    \tkern[0] = 0.0;\n        \n        float sn = -1.0;\n    \tfor(uint i = 1u; i < 12u; ++i, sn = -sn)\n        \tkern[i] = sn * 3.0 * exp2(-float(i) * log2(2.0 + sqrt(3.0)));\n    }\n   #endif    \n    \n    // d/dx\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, 0));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.x += f * k;\n    }\n    \n    // d/dy\n    for(int i = -r1; i <= r1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(0, i));\n        \n        float k = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        \n        col.y += f * k;\n    }\n    \n    \n    // d^2/dxy\n    for(int j = -r2; j <= r2; ++j)\n    for(int i = -r2; i <= r2; ++i)\n    {\n        if(i == 0 || j == 0) continue;\n        \n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.z += f * (kx * ky);\n    }\n\n#elif FILTERING_MODE == 1\n    // ======================================================= GENERALIZED CUBIC BSPLINE =======================================================\n    \n    float kernD0[3];\n    float kernD1[3];\n    \n    kernD0[0] = 2.0/3.0; kernD0[1] = 1.0/6.0; kernD0[2] = 0.0;\n    kernD1[0] =     0.0; kernD1[1] =    -0.5; kernD1[2] = 0.0;\n    \n    float sw;// side lobes weight\n\n    sw = 0.0;// cubic BSpline\n    \n   #if 1\n   \n    sw = 0.25;// similar to 1/3 but less overshooting\n    \n   #elif 0\n   \n    sw = 1.0/3.0;// kernD0[0] == 1\n    \n   #elif 0\n    \n    sw = 0.186605;// max abs derivative == 1\n    \n   #elif 0\n    \n    sw = 1.0/6.0;// maximaly flat pass band\n    \n   #elif 0\n    \n    sw = -0.25;// spectrum falls off to 0 at Nyquist frequency\n    \n   #endif\n    \n    // add a pair of side lobes:\n    kernD0[0] += 1.0 * sw; kernD0[1] += -1.0/3.0 * sw; kernD0[2] += -1.0/6.0 * sw;\n    \t                   kernD1[1] += -1.0     * sw; kernD1[2] +=  0.5     * sw;\n    \n    int r = sw == 0.0 ? 1 : 2;\n    for(int j = -r; j <= r; ++j)\n    for(int i = -r; i <= r; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        int x = abs(i);\n        int y = abs(j);\n        \n        float kAx = kernD0[x];\n        float kAy = kernD0[y];\n        \n        float kBx = kernD1[x] * (i > 0 ? -1.0 : 1.0);\n        float kBy = kernD1[y] * (j > 0 ? -1.0 : 1.0);\n        \n        col += f * vec4(kBx * kAy, \n                        kAx * kBy, \n                        kBx * kBy,\n                        kAx * kAy);\n    }\n\n#else\n    // ======================================================= CENTRAL DIFFERENCE =======================================================\n    \n    col.w = FETCH(uv);\n    \n    float kern[2];\n    \n    kern[0] =  0.0;\n    kern[1] = -0.5;\n    \n    for(int j = -1; j <= 1; ++j)\n    for(int i = -1; i <= 1; ++i)\n    {\n    \tfloat f = FETCH(uv + ivec2(i, j));\n        \n        float kx = kern[abs(i)] * (i > 0 ? -1.0 : 1.0);\n        float ky = kern[abs(j)] * (j > 0 ? -1.0 : 1.0);\n        \n        col.xyz += f * vec3(kx * (j == 0 ? 1.0 : 0.0), \n                            ky * (i == 0 ? 1.0 : 0.0), \n                            kx * ky);\n    }\n    \n#endif    \n    \n    if((uint(uv.x) & 1u) == 0u) { col.xz *= -1.0; }\n    if((uint(uv.y) & 1u) == 0u) { col.yz *= -1.0; }\n    \n    // col = vec4(df/dx, df/dy, d^2f/dxy, f)\n    fragColor = col;\n}\n\n", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByDt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[9408, 9408, 9438, 9438, 9584], [9586, 9586, 9645, 9645, 10174], [10177, 10177, 10200, 10200, 10235], [10236, 10236, 10259, 10259, 10299], [10301, 10301, 10320, 10320, 10495], [10497, 10497, 10542, 10542, 11285], [11288, 11288, 11339, 11339, 12029]], "test": "untested"}
{"id": "ttjcRc", "name": "Subway", "author": "dean_the_coder", "description": "Inspired by visuals from 'Blender Guru' (https://youtu.be/nb6rSMAooDs), I was aiming for some realistic (by my standards!) lighting and atmosphere.\nI could do more, but alas my GPU can't handle it.\nAny visual or performance tips welcome!", "tags": ["3d", "raymarching", "glow", "subway"], "likes": 63, "viewed": 995, "published": 3, "date": "1595682030", "time_retrieved": "2024-07-30T20:54:04.162114", "image_code": "// 'Subway'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others\n// for sharing their knowledge!\n//\n// Comment-out 'MY_GPU_CAN_TAKE_IT' if your graphics card struggles.\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MY_GPU_CAN_TAKE_IT  // Enable reflections.\n#define ZERO min(iTime, 0.0)\n#define MIN_DIST 0.0015\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(vec3 p, float h, float r) {\n  vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h,r);\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h) - r;\n}\n\nfloat sdLink(vec3 p, float le, float r1, float r2) {\n  vec3 q = vec3(p.x, max(abs(p.y) - le, 0.0), p.z);\n  return length(vec2(length(q.xy) - r1, q.z)) - r2;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nvec2 cappedMod(vec2 p, float c, vec2 l1, vec2 l2) {\n    return p - c * clamp(round(p / c), -l1, l2);\n}\n\nvec3 mirrorX(vec3 p, float d) {\n    p.x = abs(p.x) - d;\n    return p;\n}\n\nvec3 repeatXZ(vec3 p, float c, vec2 l1, vec2 l2) {\n    p.xz = cappedMod(p.xz, c, l1, l2);\n    return p;\n}\n\nfloat sdTactileSlab(vec3 p) {\n    p.z -= 0.4;\n    \n    // Main slab - ISO standard 40x40cm ! :)\n    const float gap = 0.015;\n    float d = sdBox(p, vec3(0.40 - gap, 0.05, 0.4 - gap));\n    \n    // Add the dimples.\n    p.y -= 0.01;\n    p.xz = cappedMod(p.xz + vec2(0.06666), 0.06666 * 2.0, vec2(2.), vec2(3.));\n    return min(d, sdCylinder(p, 0.0225, 0.05));\n}\n\nfloat sdTactileSlabStrip(vec3 p) {\n    p.xz = cappedMod(p.xz, 0.8, vec2(3.0, 0.0), vec2(4.0, 0.0));\n    return sdTactileSlab(p);\n}\n\nfloat sdPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p, vec3(0.5 - gap, 0.05, 0.5 - gap));\n}\n\nfloat sdThinPavingSlab(vec3 p) {\n    const float gap = 0.015;\n    return sdBox(p - vec3(0.0, 0.0, 0.2), vec3(0.5 - gap, 0.05, 0.2 - gap));\n}\n\nconst vec2 stepToStep = vec2(0.36, 0.66);\nconst float centerToWall = 0.4 * 7.0;\nconst float ceilingHeight = 6.0;\n\nconst vec3 lightPos1 = vec3(0.0, 4.5, 4.3);\nconst vec3 lightPos2 = vec3(0.0, 4.5, -0.6);\n\nfloat glow = 0.0;\nfloat flicker = 1.0;\n\n#define WALL_ID          1.5\n#define RAIL_ID          2.5\n#define STAIR_STRIP_ID   3.5\n#define MARBLE_ID        4.5\n#define TACTILE_TILE_ID  5.5\n#define FLOOR_TILE_ID    6.5\n\nvec2 sdStep(vec3 p) {\n    const float gap = 0.015;\n    \n    // Top edge.\n    float d1 = sdBox(p, vec3(1.4, 0.02, 0.02));\n   \n    if (d1 > 1.0)\n        return vec2(d1, STAIR_STRIP_ID); // Too far away from the step to bother rendering further.\n    \n    // Front facing surface.\n    p.y += 0.16 + 0.02;\n    float d2 = sdBox(p, vec3(1.4 - gap, 0.16 - gap, 0.02));\n    \n    // Vertical grout.\n    d1 = min(d1, sdBox(p - vec3(0.0, 0.0, gap), vec3(1.4, 0.16, 0.02)));\n    \n    // Horizontal surface.\n    p.yz += vec2(0.16 + 0.02, 0.32);\n    d2 = min(d2, sdBox(p, vec3(1.4 - gap, 0.02, 0.32 - gap)));\n\n    // Horizontal grout.\n    d1 = min(d1, sdBox(p + vec3(0.0, gap, 0.0), vec3(1.4, 0.02, 0.32 - gap)));\n    \n    return min2(vec2(d1, STAIR_STRIP_ID), vec2(d2, MARBLE_ID));\n}\n\nvec2 sdSteps(vec3 p) {\n    float i = max(0.0, floor(-p.z / stepToStep.y));\n    return sdStep(p + i * vec3(0.0, stepToStep));\n}\n\nfloat sdRailHolder(vec3 p) {\n    p.x -= 0.35;\n    return max(sdLink(p.yxz, 0.1, 0.25, 0.06), p.y);\n}\n\nvec2 sdWalls(vec3 p) {\n    const float gap = 0.015;\n    \n    vec3 op = p;\n\n    // Wall tiles.\n    p.yz = mod(p.yz, vec2(0.16, 0.22));\n    float d = sdBox(mirrorX(p, centerToWall), vec3(0.02, 0.16 - gap, 0.22 - gap)) - gap;\n\n    // Hand rails.\n    vec3 pp = mirrorX(op, centerToWall);\n    pp.xy -= vec2(-0.3, 1.3);\n    float d2 = 1e10;\n    \n    if (pp.y < 3.0) { // Skip stair rails if point is too far away.\n        d2 = sdCapsule(pp, vec3(0.0, 0.0, 1.0), vec3(0.0), 0.1);\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, 0.75)), 0.025);\n        pp.yz *= rot(-atan(stepToStep.x / stepToStep.y));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -0.75)), 0.0255);\n        d2 = min(d2, sdCapsule(pp, vec3(0.0), vec3(0.0, 0.0, -length(stepToStep * 11.0)), 0.1));\n        d2 = smin(d2, sdRailHolder(pp - vec3(0.0, 0.0, -length(stepToStep * 11.0) + 0.75)), 0.025);\n    }\n\n    if (p.x > 0.0) {\n        // Remove the parts of the right wall.\n        const float nearEndZ = -stepToStep.y * 12.0;\n        float farEndZ = 2.9;\n        float middleZ = mix(nearEndZ, farEndZ, 0.5);\n        float depthToInclude = farEndZ - nearEndZ;\n        pp = op;\n        pp.z -= middleZ;\n        d = max(d, sdBox(pp, vec3(3.0, 1000.0, depthToInclude / 2.0)));\n    }\n    \n    return min2(vec2(d, WALL_ID), vec2(d2, RAIL_ID));\n}\n\nvec2 sdCorridorSection(vec3 p) {\n    // Walls.\n    vec2 d1 = sdWalls(p);\n    if (p.y > 2.0)\n        return d1; // Too far away from the floor to bother rendering further.\n    \n    // Steps.\n    vec2 d2 = sdSteps(repeatXZ(p, 2.8, vec2(1.0, 0.0), vec2(1.0, 0.0)));\n\n    // Pre-stairs half strip.\n    float d = sdThinPavingSlab(repeatXZ(p, 1.0, vec2(3.0, 0.0), vec2(3.0, 0.0)));\n\n    // Tactile slabs.\n    p.z -= 0.4;\n    float d3 = sdTactileSlabStrip(p);\n    d3 -= 0.006 * mix(0.8, 1.0, texture(iChannel0, p.xz * 1.7).r);\n\n    // Floor.\n    d = min(d, sdPavingSlab(repeatXZ(p - vec3(0.0, 0.0, 0.8 + 0.5), 1.0, vec2(3.0, 0.0), vec2(3.0, 5.0))));\n    \n    return min2(vec2(d, FLOOR_TILE_ID), min2(d1, min2(d2, vec2(d3, TACTILE_TILE_ID))));\n}\n\nvec2 map(vec3 p, bool useGlow) {\n    // Side wire cover.\n    float d = sdBox(p - vec3(centerToWall - 0.1, 0.0, 1.8), vec3(0.07, 10.0, 0.07)) - 0.01;\n\n    // Overhead beam.\n    d = min(d, sdBox(p - vec3(0.0, ceilingHeight - 1.0, 1.8), vec3(centerToWall, 1.0, 0.07)) - 0.01);\n    \n    // Overhead pipe.\n    vec3 v = vec3(centerToWall - 1.0, ceilingHeight - 1.5, 0.0);\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.9), v - vec3(0.0, 0.0, 100.0), 0.18));\n    d = min(d, sdCapsule(p, v + vec3(0.0, 0.0, 2.0), v + vec3(0.0, 0.0, 1.6), 0.22));\n    \n    // Overhead pipe clamps.\n    vec3 pp = p;\n    pp.z = abs(p.z - 1.8);\n    d = min(d, sdLink(pp - vec3(centerToWall - 1.0, ceilingHeight - 1.3, 0.9), 0.2, 0.2, 0.015));\n    d = min(d, sdLink(p - vec3(centerToWall - 1.0, ceilingHeight - 1.3, -2.0), 0.2, 0.2, 0.015));\n\n    // Ceiling lights.\n    pp -= vec3(0.0, ceilingHeight - 1.0, 2.5);\n    float lightFrame = max(sdBox(pp, vec3(1.0, 0.25, 0.06)), -sdBox(pp + vec3(0.0, 0.3, 0.0), vec3(0.95, 0.2, 0.1)));\n    d = min(d, lightFrame);\n    \n    // Only apply glow when marching, not calculating normals.\n    if (useGlow) {\n        float endFade = 1.0 - clamp((abs(p.x) - 0.8) / 0.2, 0.0, 1.0);\n        pp.y += 0.2;\n        float gd = sdCylinder(pp.yxz, 0.05, 0.92);\n        glow += endFade * 0.001 / (0.001 + gd * gd * 0.3) * mix(0.01, 1.0, p.z < 0.0 ? 1.0 : flicker);\n    }\n    \n    // Ceiling.\n    pp = p;\n    pp.xz *= rot(-3.1415 / 4.0);\n    float bump = texture(iChannel0, p.xz * 0.8).r * 0.01;\n    d = min(d, sdBox(pp - vec3(0.0, ceilingHeight, -20.0), vec3(10.0, 1.0, 20.0 + stepToStep * 12.0)) - bump);\n\n    // Base corridor.\n    vec2 d2 = sdCorridorSection(p);\n    \n    // Upper corridor.\n    p.yz -= stepToStep * 12.0;\n    p.z -= 9.0;\n    p.xz *= rot(-3.14159 / 4.0);\n    p.x -= 9.08;\n    \n    d2 = min2(d2, sdCorridorSection(p));\n    \n    return min2(vec2(d, WALL_ID), d2);\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0001;\n    return normalize(e.xyy * map(p + e.xyy, false).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx, false).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy, false).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx, false).x);\n}\n\nfloat calcAO(vec3 p, vec3 n, float d) {\n    return clamp(map(p + n * d, false).x / d, 0.0, 1.0);\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n    float d = distance(p, lightPos);\n    \n    float shadow = 1.0;\n    vec3 st = (lightPos - p) / 30.0 * 0.8;\n    float std = length(st);\n    p += normalize(lightPos - p) * 0.01;\n    for (float i = ZERO; i < 30.0; i++) {\n        p += st;\n        shadow = min(shadow, max(map(p, false).x, 0.0) / (std * i));\n    }\n    \n    float falloff = pow(d / 20.0 + 1.0, 2.0);\n    return shadow / falloff;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 getMaterial(vec3 p, vec3 rd, vec3 n, float id) {\n    vec3 lightDir1 = normalize(lightPos1 - p);\n    vec3 lightDir2 = normalize(lightPos2 - p);\n    vec3 lightCol = vec3(1.0, 1.0, 1.1);\n\n    float spec = pow(\n        max(\n            max(\n                dot(reflect(lightDir1, n), rd) * flicker,\n                dot(reflect(lightDir2, n), rd)\n            ),\n            0.0\n        ),\n        50.0);\n\n    vec3 mat;\n    if (id == STAIR_STRIP_ID) {\n        mat = vec3(0.1);\n    } else if (id == MARBLE_ID) {\n        mat = vec3(smoothstep(0.0, 0.6, texture(iChannel0, (abs(n.y) < 0.1 ? p.xy : p.xz) * 1.4125).r));\n    } else if (id == TACTILE_TILE_ID) {\n        mat = vec3(0.9, 0.75, 0.21); // Yellow.\n        spec *= 0.8; // Reduce specular contribution.\n    } else if (id == FLOOR_TILE_ID) {\n        mat = vec3(mix(0.3, 0.5, texture(iChannel0, p.xz * 1.743).r));\n    } else mat = vec3(1.0); // White (Tiles, etc)\n\n    // Diffuse color.\n    float diff = max(max(0.0, dot(lightDir1, n) * flicker), dot(lightDir2, n));\n\n    // Fake ambient occlusion.\n    float occ = min(1.0, 0.2 + calcAO(p, n, 0.15) * calcAO(p, n, 0.05));\n\n    // Shadows from two light sources.\n    float sha = (calcShadow(p, lightPos1) * flicker + calcShadow(p, lightPos2)) / 2.0;\n\n    vec3 col = mat * lightCol * ((diff + spec) * sha + occ * 0.025);\n    \n    // Global 'glow' variable accumulates color as the\n    // scene is marched.\n    return col + min(glow, 1.0);\n}\n\nvoid march(vec3 ro, vec3 rd, out vec3 p, out vec2 h) {\n    float d = 0.01;\n    for (float steps = ZERO; steps < 60.0; steps++) {\n        p = ro + rd * d;\n        h = map(p, true);\n        \n        if (abs(h.x) < MIN_DIST * d) break; // We've hit a surface - Stop.\n        d += h.x * 0.9; // No hit, so keep marching.\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    flicker = step(0.25, sin(iTime) * texture(iChannel0, vec2(iTime * 0.1)).r);\n\n    // Camera.\n    float ft = fract(iTime / 5.0);\n    float phase = mod(floor(iTime / 5.0), 3.0);\n    \n    vec3 ro;\n    vec3 lookAt = vec3(0.0, 1.0, 0.0);\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(0.0, -0.5, ft) * -3.0 - 1.0,\n                  -1.0 + -6.0 * mix(0.5, 0.4, ft),\n                  -10.0);\n    } else if (phase == 1.0) {\n        ro = vec3(-3.0 * mix(0.0, 0.5, ft) - 1.0, 3.0, -4.0);\n        lookAt = lightPos2;\n    } else if (phase == 2.0) {\n        ro = vec3(0.5, -1.0 + -6.0 * (mix(0.25, 0.0, ft) - 0.5), -1.0);\n        lookAt = lightPos1 - mix(vec3(5.0, 3.5, -1.0), vec3(0.0), ft);\n    }\n    \n    vec3 rd = getRayDir(ro, lookAt, uv);\n    \n    // Raymarch.\n    vec2 h;\n    vec3 p;\n\tmarch(ro, rd, p, h);\n\n    // Materials and lighting.\n\tvec3 n = calcNormal(p);\n    vec3 col = getMaterial(p, rd, n, h.y);\n\n#ifdef MY_GPU_CAN_TAKE_IT\n    // Reflect on hand rails.\n    if (h.y == RAIL_ID) {\n        rd = reflect(rd, n);\n        march(p, rd, p, h);\n        col = mix(col, getMaterial(p, rd, n, h.y), 0.75);\n    }\n#endif\n    \n    // Fog.\n    col *= exp(-pow(distance(ro, p) / 30.0, 3.0) * 5.0);\n    \n    // Output to screen.\n    col = vignette(pow(col, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjcRc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[383, 383, 422, 422, 525], [527, 527, 546, 546, 622], [624, 624, 653, 653, 748], [750, 750, 794, 794, 905], [907, 907, 957, 957, 1080], [1082, 1082, 1134, 1134, 1240], [1242, 1242, 1289, 1289, 1494], [1496, 1496, 1523, 1523, 1555], [1557, 1557, 1608, 1608, 1659], [1661, 1661, 1692, 1692, 1732], [1734, 1734, 1784, 1784, 1839], [1841, 1841, 1870, 1870, 2199], [2201, 2201, 2235, 2235, 2331], [2333, 2333, 2361, 2361, 2447], [2449, 2449, 2481, 2481, 2589], [3010, 3010, 3031, 3031, 3779], [3781, 3781, 3803, 3803, 3907], [3909, 3909, 3937, 3937, 4009], [4011, 4011, 4033, 4033, 5324], [5326, 5326, 5358, 5372, 6063], [6065, 6065, 6097, 6121, 7945], [7947, 7947, 7972, 7972, 8200], [8202, 8202, 8241, 8241, 8300], [8302, 8302, 8343, 8343, 8737], [8825, 8825, 8866, 8866, 9007], [9009, 9009, 9062, 9062, 10449], [10451, 10451, 10505, 10505, 10775], [10777, 10777, 10834, 10834, 12217]], "test": "untested"}
{"id": "WlSyDd", "name": "Reflected Box Innards", "author": "kstyler", "description": "The inside of a ray marched box with reflections.", "tags": ["reflection", "sdf", "box", "mirror", "crystal"], "likes": 1, "viewed": 290, "published": 3, "date": "1595661041", "time_retrieved": "2024-07-30T20:54:05.104594", "image_code": "const int MAX_D=100;\nconst float DELTA=0.01;\nint matID = 0;\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat box( vec3 p, vec3 b ) {\n     vec3 d = abs(p) - b;\n     return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat map(vec3 p){\n    return box(p,vec3(sin(iTime)+1.5));\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    \n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n\n}\nvec3 skyColor(vec3 rd){\n    \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    \n    \n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(0.,0.,-0.01);\n    vec3 rd = normalize(vec3(uv,1));\n  \n    rd.xz*=rot(iTime/8.);\n    rd.xy*=rot(iTime/8.);\n   \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    float tot = 0.;\n    for(int i = 0; i<50;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n      \n        vec3 n = normal(p);\n      \n        if(dst>0.01){\n         color = skyColor(rd);\n        }\n       \n        else{\n            \n            color += skyColor(reflect(rd,n));\n            ro=p;\n            rd = reflect(rd,n);\n            \n        }\n        \n        accum+=0.02*color;\n    }\n \n    fragColor = vec4((accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSyDd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 78, 78, 127], [129, 129, 158, 158, 251], [254, 254, 272, 272, 314], [316, 316, 336, 336, 513], [515, 515, 567, 567, 736], [737, 737, 760, 760, 987], [989, 989, 1045, 1045, 1755]], "test": "untested"}
{"id": "WtBcWd", "name": "Sierpinski Split Tone", "author": "kstyler", "description": "Exploring fractal sdfs", "tags": ["raymarching", "fractal", "reflection", "sierpinski"], "likes": 3, "viewed": 344, "published": 3, "date": "1595642243", "time_retrieved": "2024-07-30T20:54:06.288429", "image_code": "const int MAX_D=100;\nconst float DELTA=0.0065;\nmat2 rot(float a){\n    return mat2(cos(a),-sin(a),sin(a),cos(a));\n}\n\nfloat serpinski(vec3 p){\n    float Scale = 2.;\n    vec3 a1 = vec3(1,1,1);\n    vec3 a2 = vec3(-1,-1,1);\n    vec3 a3 = vec3(1,-1,-1);\n    vec3 a4 = vec3(-1,1,-1);\n    vec3 c;\n    int n = 0;\n    float dist, d;\n    while (n < 6) {\n        c = a1; \n        dist = length(p-a1);\n        d = length(p-a2);\n        if (d < dist) { \n            c = a2; \n            dist=d; \n        }\n        d = length(p-a3); \n        if (d < dist) { \n            c = a3; \n            dist=d; \n        }\n        d = length(p-a4); \n        if (d < dist) { \n            c = a4; \n            dist=d; \n        }\n        p = Scale*p-c*(Scale-1.0);\n        n++;\n    }\n\n    return length(p) * pow(Scale, float(-n));\n}\n\nfloat map(vec3 p){\n    return serpinski(p)-0.0135;\n}\n\nvec3 normal(vec3 p){\n    vec2 e = vec2(0,DELTA);\n    \n    return normalize(vec3(map(p+e.yxx)-map(p-e.yxx),\n                map(p+e.xyx)-map(p-e.xyx),\n                map(p+e.xxy)-map(p-e.xxy))); \n}\n\nvec3 addLight(vec3 lightCol, vec3 lightdir,vec3 rd){\n    vec3 light = vec3(0.);\n    float li = max(dot(lightdir,rd),0.);\n    light+=pow(lightCol,vec3(2))*pow(li,2.);\n    light+=lightCol*pow(li,200.9);\n    return light;\n\n}\nvec3 skyColor(vec3 rd){\n    \n    vec3 outLight = vec3(0.125);\n    outLight+= addLight(vec3(0.7,0.5,0.),normalize(-vec3(0.2,0.05,0.2)),rd);\n    \n    \n    outLight+=addLight(vec3(0.1,0.3,0.7),normalize(-vec3(-0.2,0.05,-0.2)),rd);\n    return outLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord.xy-0.5*iResolution.xy)/iResolution.x;\n    vec3 ro = vec3(sin(iTime/2.)/3.,cos(iTime/4.)/2.1,sin(iTime/4.)/3.);\n    vec3 rd = normalize(vec3(uv,1));\n   \n    rd.xz*=rot(iTime/8.);\n    rd.xy*=rot(iTime/8.);\n   \n    vec3 color = vec3(0); \n    vec3 accum = vec3(0); \n    float tot = 0.;\n    for(int i = 0; i<MAX_D;i++){\n        vec3 p = ro+rd*tot;\n        float dst = map(p);\n        tot+=dst;\n      \n        vec3 n = normal(p);\n      \n        if(dst>DELTA){\n         color = skyColor(rd);\n        }\n        \n        else{\n            \n            color += skyColor(reflect(rd,n));\n            ro=p;\n            rd = reflect(rd,n);  \n        }\n        \n        accum+=0.013*color;\n        \n    }\n    \n    fragColor = vec4((accum),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 65, 65, 114], [116, 116, 140, 140, 802], [804, 804, 822, 822, 856], [858, 858, 878, 878, 1055], [1057, 1057, 1109, 1109, 1278], [1279, 1279, 1302, 1302, 1529], [1531, 1531, 1587, 1587, 2345]], "test": "untested"}
{"id": "3tByWd", "name": "♫ 82 attoseconds", "author": "patu", "description": "#makeYourShadersPublic, This one is 3.5 year old. \nNo code cleanup", "tags": ["raymarching", "drumbass", "makeyourshaderspublic"], "likes": 55, "viewed": 4936, "published": 3, "date": "1595634046", "time_retrieved": "2024-07-30T20:54:07.321667", "image_code": "#define T texture(iChannel0, uv\n#define W vec2\n\n#define BLOOM\n\n#define time iTime\n    float alpha;\n#define res iResolution\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.001*8./6.,.001, 0) * .05;\n\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n// \tsimplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    float bc = 1.;\n\tfor (int j=0;j<60;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        vec4 col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (intensity(col) > .8) {            \n\t\t\tbloom += col; \n            //bc++;\n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n    //bloom /= bc;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = (\n        texture(iChannel0,uv) \n    \t+ (texture(iChannel0,uv + pixel.xz)\n        \t+ texture(iChannel0,uv + pixel.zx)\n        \t+ texture(iChannel0,uv - pixel.xz)\n        \t+ texture(iChannel0,uv - pixel.zx)\n         ) * .25\n    ) / 2.,\n        \n    oo = orgColor;\n    \n    alpha = texture(iChannel0,uv).a;\n    \n    dof(iChannel0,uv, 40., orgColor);\n    \n    #ifdef BLOOM\n    \n    orgColor += bloom * 0.03;\n    #endif\n    \n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., 1. - pow(abs(alpha - .6) * 2., 2.)),\n            0.,\n            1.\n        )\n    );\n    \n    \n    orgColor = mix(\n        orgColor, \n        blur.bgra, \n        clamp(\n        \tmin(1., pow(length(uv -.5) * 1.4, 2.)),\n            0.,\n            1.\n        )\n    );\n    \n\n    \n    \n    \n    \n \t//fragColor = oo;\n    fragColor = orgColor;    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "\n#define V vec3\n#define W vec2\n#define F float\n\nconst float BMP = 124.;\nfloat BEAT_COUNT ;\nfloat BEATN ;\n\nfloat hash12(vec2 p) {\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453123);\n}\n\nfloat scene;\n\n#define FAR 570.\n#define INFINITY 1e32\n#define t iTime\n#define mt iChannelTime[1]\n#define FOV 100.0\n#define FOG .06\n\n#define PI 3.14159265\n#define TAU (2*PI)\n#define PHI (1.618033988749895)\n\nfloat vol = 0.;\nF \n    Z = 0., \n    J = 1.;\n\nfloat B(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nvec3 fromRGB(int r, int g, int b) {\n \treturn vec3(float(r), float(g), float(b)) / 255.;   \n}\n    \nvec3 \n    light = vec3(0.0),\n    p = vec3(0.),\n    p2 = vec3(0.),\n\tlightDir = vec3(0.);\n\n\nvec3 lightColour = normalize(vec3(1.8, 1.0, 0.3)); \n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\n// Repeat only a few times: from indices <start> to <stop> (similar to above, but more flexible)\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\nvec4 fold1(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p, z.w);\n}\n\nvec4 fold2(vec4 z) {\n    vec3 p = z.xyz;\n    p = p - 2.0 * clamp(p, -1.0, 1.0);\n    return vec4(p * 2.0, 2.0 * z.w);\n}\n\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nvec3 opU2( vec3 d1, vec3 d2 ) {\n    if (d1.x < d2.x) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    vec3 space;\n    vec3 hit;\n    vec3 sn;\n    int material;\n    int iterations;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\ngeometry geoI(geometry g1, geometry g2) {\n    if (g1.dist > g2.dist) return g1;\n    return g2;\n}\n\nfloat opS2( float d1, float d2 )\n{\t\n    if (-d2 > d1) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\nfloat vmax(vec4 v) {\n\treturn max(max(v.x, v.y), max(v.z, v.w));\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n\n// Repeat space along one axis. Use like this to repeat along the x axis:\n// <float cell = pMod1(p.x,5);> - using the return value is optional.\nfloat pMod1(inout float p, float size) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p + halfsize, size) - halfsize;\n\treturn c;\n}\n\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n// Mirror at an axis-aligned plane which is at a specified distance <dist> from the origin.\nfloat pMirror (inout float p, float dist) {\n\tfloat s = sgn(p);\n\tp = abs(p)-dist;\n\treturn s;\n}\n\nvec2 pMirrorOctant (inout vec2 p, vec2 dist) {\n\tvec2 s = sgn(p);\n\tpMirror(p.x, dist.x);\n\tpMirror(p.y, dist.y);\n\tif (p.y > p.x)\n\t\tp.xy = p.yx;\n\treturn s;\n}\n\nfloat fCylinder(vec3 p, float r, float height) {\n\tfloat d = length(p.xz) - r;\n\td = max(d, abs(p.y) - height);\n\treturn d;\n}\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\nfloat fBox2Cheap(vec2 p, vec2 b) { return vmax(abs(p)-b); }\n\nfloat fCross(vec3 p, vec3 size) {\n    float obj = fBox(p, size);\n    obj = opU2(obj, fBox(p, size.zxy));\n    obj = opU2(obj, fBox(p, size.yzx));\n    return obj;\n}\n\n\nfloat fSphere(vec3 p, float r) { return length(p) - r; }\n\ngeometry DE(vec3 p)\n{\n \tfloat scale = 4.5;\n\tconst float offset = 14.;\n    const int FRACTALITERATIONS = 5;\n    vec3 modifier = vec3(4., 1.5, .4 );\n\n    for(int n=0; n< FRACTALITERATIONS; n++)\n\t{\n        \n\tp = abs(p);        \n        \n\t\tp.xy = (p.x - p.y < 0.0) ? p.yx : p.xy;\n\t\t//p.xz = (p.x - p.z < 0.0) ? p.zx : p.xz;\n\t\tp.zy = (p.y - p.z < 0.0) ? p.yz : p.zy;\n\n\n\t\tp.y -= 9.9;\n\n        p.y += 2.;\n        p.x -= 14.;\n        p.xy = scale* p.xy - offset*(scale-1.4) * modifier.xy;\n        \n\t}\n \tgeometry obj;\n    obj.dist = length(p.xz) * (pow(scale, -float(FRACTALITERATIONS))) - .5; \n\tobj.space = p;\n    return obj;\n}\nfloat smin( float a, float b, float k ){\n    \n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n    \n}\nfloat ring(vec3 p, float w, float h) {\n    return opS2(\n        fCylinder(p, w, h),\n        fCylinder(p, w - 2., h + 1.)\n        );\n}\ngeometry map(vec3 p) {\n    float t = pow(iTime * 0.1, 2.);\n    vec3 bbp = p;\n    p.xz /= 1. + vol * 0.4;\n    p += sin(vol * 4.+ t);\n    pR(p.zy, t * .4 + vol * .1);\n    \n    vec3 bp = p;\n    \n    vec3 h = vec2(0., pow(B(vec2(0, -iTime * 5.).xxy + p * .5) * 3., 4.)).yyy * 0.007;\n    \n    \n    \n    geometry obj, obj2;\n\n    //pR(p.xy, t * 2.);\n    obj.dist = ring(p, 20., 1.);\n\n    pModPolar(p.yx, 1. + ceil(t * .1 + vol));\n    //obj.dist = opU2(obj.dist, fBox(p, vec3(20., 1.0, 1.) ));\n    //obj.dist = opU2(obj.dist, fBox(p, vec3(1., 10., 20.)));\n    pR(p.xy, .3 + t);\n    obj.dist = opU2(obj.dist, ring(p, 22., 3.));\n    pR(p.zy, .4 + 3. * t);\n    obj.dist = opU2(obj.dist, ring(p, 24., 4.));\n    p = bp;\n    pR(p.zy, .5 + t * 2.4);\n    obj.dist = opU2(obj.dist, ring(p, 26., 5.));\n    \n    pR(p.zy, .5 + t * 2.4);\n    obj.dist = opU2(obj.dist, ring(p, 46., 10.));\n    \n\n    obj.material = 1;\n    obj.space = p;\n    \n    pR(bp.zx,  + B(vec3(t)) * 13.);\n    pModPolar(bp.zx, 3.);\n\n    pR(bp.zx, 2. * PI / 3. / 2.);\n    pModPolar(bp.xy, 5.);    \n    \n    \n    obj2.dist = fBox(bp, vec3(20., .1, .1) + h * 9.);\n    obj2.material = 2;\n    obj2.space = bp;\n    \n    obj.dist = opU2(obj.dist, fSphere(bp, 5.));\n\n    obj = geoU(obj, obj2);\n    \n    return obj;\n}\n\n\nfloat t_min = 0.1;\nfloat t_max = FAR;\nconst int MAX_ITERATIONS = 80;\n\ngeometry trace(vec3 o, vec3 d) {\n    float omega = 1.3;\n    float t = t_min;\n    float candidate_error = INFINITY;\n    float candidate_t = t_min;\n    float previousRadius = 0.;\n    float stepLength = 0.;\n    float pixelRadius = 0.003;\n    \n    geometry mp = map(o);\n    mp.glow = 0.;\n    \n    float functionSign = mp.dist < 0. ? -1. : +1.;\n    float minDist = 1e32;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i) {\n\n        mp = map(d * t + o);\n\t\t//mp.iterations = i;\n        //if (mp.material == 2) {\n\t\t\t//minDist = min(minDist, mp.dist * 3.); \n\t\t//\tmp.glow = pow( 1. / minDist, .5);\n        //}\n        float signedRadius = functionSign * mp.dist;\n        float radius = abs(signedRadius);\n        bool sorFail = omega > 1. &&\n        (radius + previousRadius) < stepLength;\n        if (sorFail) {\n            stepLength -= omega * stepLength;\n            omega = 1.;\n        } else {\n        stepLength = signedRadius * omega;\n        }\n        previousRadius = radius;\n        float error = radius / t;\n        if (!sorFail && error < candidate_error) {\n            candidate_t = t;\n            candidate_error = error;\n        }\n        if (!sorFail && error < pixelRadius || t > t_max) break;\n        t += stepLength;\n   \t}\n    \n    mp.dist = candidate_t;\n    //if (mp.material != 2) mp.glow = 0.;\n    \n    if (\n        (t > t_max || candidate_error > pixelRadius)\n    \t) mp.dist = INFINITY;\n    \n    \n    return mp;\n}\n\n\nfloat softShadow(vec3 ro, vec3 lp, float k) {\n    const int maxIterationsShad = 8;\n    vec3 rd = (lp - ro);\n    float shade = .3;\n    float dist = 4.5;\n    float end = max(length(rd), 0.01);\n    float stepDist = end / float(maxIterationsShad);\n\n    rd /= end;\n    for (int i = 0; i < maxIterationsShad; i++) {\n        float h = map(ro + rd * dist).dist;\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k * h / dist)); \n        dist += min(h, stepDist * 2.); \n        if (h < 0.001 || dist > end) break;\n    }\n    return min(max(shade, 0.15), 1.0);\n}\n\nvec3 applyFog( in vec3  rgb,      // original color of the pixel\n               in float distance, // camera to point distance\n               in vec3  rayOri,   // camera position\n               in vec3  rayDir, vec3 fc )  // camera to point vector\n{\n    float c = .5;\n    float b = .06;\n    \n    float fogAmount = c * exp(-rayOri.y*b) * (1.0-exp( -distance*rayDir.y*b ))/rayDir.y;\n    //vec3  fogColor  = vec3(1.,0.5, 0.);\n    return mix( rgb, fc, saturate(fogAmount) );\n}\n\nvec3 normal(vec3 pos) {\n    F eps=0.0001, d=map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));\n}\n\n\nfloat getAO(vec3 hitp, vec3 normal, float dist)\n{\n    vec3 spos = hitp + normal * dist;\n    float sdist = map(spos).dist;\n    return clamp(sdist / dist, 0.0, 1.0);\n}\n\n\n\n\nvec3 getObjectColor(vec3 p, vec3 n, geometry obj) {\n    vec3 col = vec3(.0);\n\n    if (obj.material == 1) { \n        col = fromRGB(128,128,128) * 3. + pow(vol, 4.) * .2;\n            //boxmap(iChannel1, obj.space / 10., 1.).rgb;\n    }\n    \n    if (obj.material == 2) { \n        col = vec3(1.) * 3. - length(obj.space) * .2;// - B(obj.space* .1 - vec3(0., 0., t * 10.));\n        \n    };\n    \n    return col ;\n\n}\n\nvec3 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 sceneCol = vec3(0.0);\n    lp = sp + lp;\n    vec3 ld = lp - sp; // Light direction vector.\n    float lDist = max(length(ld / 4.), 0.1); // Light to surface distance.\n    ld /= lDist; // Normalizing the light vector.\n\n    // Attenuating the light, based on distance.\n    float atten = 1. / (1.0 + lDist * 0.025 + lDist * lDist * 0.2);\n\n    // Standard diffuse term.\n    float diff = max(dot(sn, ld), 2.);\n    // Standard specualr term.\n    float spec = pow(max(dot(reflect(-ld, sn), rd), .7), 3.);\n\n    // Coloring the object. You could set it to a single color, to\n    // make things simpler, if you wanted.\n    vec3 objCol = getObjectColor(sp, sn, obj);\n\n    // Combining the above terms to produce the final scene color.\n    sceneCol += (objCol * (diff + .15) * spec * .2);// * atten;\n\n    // Return the color. Done once every pass... of which there are\n    // only two, in this particular instance.\n    \n    return sceneCol;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    BEAT_COUNT = iTime /  60. * BMP / 8.;\n    BEATN = fract(BEAT_COUNT);\n    scene = mod(floor(BEAT_COUNT / 2.), 4.);\n    vec2 ouv = fragCoord.xy / iResolution.xy;\n        \n    vec2 uv = ouv - .5;\n\tfloat n = hash12(ceil(uv.yy * 8.));\n    vol = pow((texture(iChannel0, vec2(.42, .25)).r) * 2., 2.);\n    \n//uv.x += n * .02;\n    //uv *= tan(radians (FOV) / 2.0) * 1.1;\n    \n  //uv += hash12(uv / 20.) * 0.01;\n    float t2 = 140. - 35.;\n\tfloat t = iTime;   \n    float \n        sk = sin(-t * 3.2) * 24.0, \n        ck = cos(-t * 1.2) * 24.0,\n        \n        mat = 0.;\n     \n    light = vec3(0., 170., 150.);        \n    lightDir = light;\n    \n\n    \n    vec3 \n        vuv = vec3(0., 1., 0.), // up\n    \tro = vec3(10, 50, 0);// + vec3(iMouse.x / 20.,iMouse.y / 10. - 1., 10.); // pos\n\n    //scene = floor(scene + fract(ouv.y - BEATN) * 2.);\n    \n    /*if (scene == 0.) ro.y = 55.;\n    if (scene == 1.) ro.z = 528.;\n    if (scene == 2.) ro.z = 228.;\n    if (scene == 3.) {\n        ro.x = 34.; ro.z = 490.;\n    }\n    */\n   \n         \n    \n    vec3\n        vrp =  vec3(0., 0., 0.) , // lookat    */\n\t\t\n    \tvpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),\n    \tv = cross(vpn, u),\n    \tvcv = (ro + vpn),\n    \tscrCoord = (vcv + uv.x * u * iResolution.x/iResolution.y + uv.y * v),\n    \trd = normalize(scrCoord - ro);        \n\t\n    vec3 sceneColor = vec3(0.), \n         fogCol = vec3(1., .3, 0.);\n    \n    vec3 oro = ro, ord = rd;\n    \n    geometry tr = trace(ro, rd);    \n    \n    tr.hit = ro + rd * tr.dist;\n\n    tr.sn = normal(tr.hit);\t\n    \n    float \n        sh = softShadow(tr.hit, tr.hit + light, 10.),\n    \tao = getAO(tr.hit, tr.sn, 1.),\n        a = 0.;\n    \n    vec3 sky = (\n        vec3(\n            pow(B(rd * 5. + t * .2) * 1., 3.) * 2. + .5 \n        //    + ceil(fract(-rd.x * 3. + rd.z * 4. - t * 2.1 ) - .5) * .04\n        ) * vec3(1., .5, .0)) * .5;\n    \n    if (tr.dist < FAR) { \n        \n        sceneColor = doColor(tr.hit, rd, tr.sn, light, tr);\n        sceneColor *= 1. + vec3(length(\n            max(\n                vec2(0.),\n                1. * max(\n                    0.,\n                    length(normalize(light.z) * max(0., tr.sn.z))\n                )\n            )\n        ));\n        if (tr.material == 1) sceneColor *= ao; \n        sceneColor *= sh;\n       \n        sceneColor = applyFog(sceneColor, tr.dist, oro, ord, fogCol);\n        a = tr.dist / FAR;\n    } else {\n\n    \tsceneColor = sky;\n    }\n\t//sceneColor += tr.glow;// * B(tr.space);\n    //a += (sceneColor.r + sceneColor.g + sceneColor.b) / 190.;\n    fragColor = vec4(clamp(sceneColor * (1.4 - length(uv) / 1.), 0.0, 1.0), a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.4));\n\n   // fragColor += scene;\n    \n}\n", "buffer_a_inputs": [{"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30633, "src": "https://soundcloud.com/neurofunksocietyofpoland/effect-xara-clip?in=neurofunksocietyofpoland/sets/effect-existentialism-lp", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByWd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[285, 285, 312, 312, 366], [368, 412, 467, 467, 816], [818, 912, 966, 966, 1884]], "test": "untested"}
{"id": "WlBcDt", "name": "Wobbling box", "author": "Jakowlew", "description": "-", "tags": ["jakowlew"], "likes": 4, "viewed": 349, "published": 3, "date": "1595629529", "time_retrieved": "2024-07-30T20:54:08.180371", "image_code": "const int MAX_MARCHING_STEPS = 60;\nconst float MIN_DIST = 0.1;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.0001;\n\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n// Operations\nfloat opUnion( float d1, float d2 )\n{\n    return min(d1,d2);\n}\n\nfloat opSubtraction( float d1, float d2 )\n{\n    return max(d1,-d2);\n}\n\nfloat opIntersection( float d1, float d2 )\n{\n    return max(d1,d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\n// Primitives\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdScene(vec3 p)\n{\n    p = rotateY(iTime / 2.0) * p;\n    \n    float res = MAX_DIST;\n    \n    { // Box\n    float box = sdBox(p, vec3(.9) +  + 0.1*sin(3.*iTime)) - .1;\n    \n    float clipSphere = sdSphere(p, 1.5 + 0.1*sin(3.*iTime));\n    res = opUnion(res, opIntersection(box, clipSphere));\n    \n    float subSphere = sdSphere(p, 1.3);\n    res = opSubtraction(res, subSphere);\n    }\n    \n    { // Center ball\n    float sphere = sdSphere(p, .4);\n    res = opUnion(res, sphere);   \n    }\n    \n    { // Side balls   \n    float angle = 6.28 / 4.;\n    float sector = round(atan(p.z, p.x) / angle);\n    \n    vec3 q = p;\n    float an = sector * angle;\n    q.xz = mat2(cos(an), -sin(an), sin(an), cos(an)) * q.xz;\n    \n    \n    float sphere = sdSphere(q + vec3(-1.5 + 0.5*sin(3.*iTime), 0, 0), .4 - 0.1*sin(3.*iTime));\n    res = opUnion(res, sphere);\n    }\n    \n    // Wobble\n    res *= inversesqrt(p.x*p.x + p.y*p.y + p.z*p.z);\n    // Displacement\n    res += .3*sin(sin(1.*iTime)*25.*p.x)*.3*sin(sin(1.*iTime)*25.*p.y)*.3*sin(sin(1.*iTime)*25.*p.z);\n    return res;\n} \n\n\n// Raymarching\nfloat rayMarch(vec3 eye, vec3 marchingDirection, float start, float end, int maxSteps) {\n    float depth = start;\n    for (int i = 0; i < maxSteps; ++i) {\n        float dist = sdScene(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n\n// Lightning\nvec3 estimateNormal(vec3 p)\n{\n    float pDist = sdScene(p);\n    return normalize(vec3(\n        sdScene(vec3(p.x + EPSILON, p.y, p.z)) - pDist,\n        sdScene(vec3(p.x, p.y + EPSILON, p.z)) - pDist,\n        sdScene(vec3(p.x, p.y, p.z  + EPSILON)) - pDist\n    ));\n}\n\nvec3 phongIllumination(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity)\n{\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = clamp(dot(L, N),0.,1.); \n    //float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 lightScene(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0 * sin(iTime),\n                          2.0,\n                          4.0 * cos(iTime));\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongIllumination(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37 * iTime),\n                          2.0 * cos(0.37 * iTime),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongIllumination(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup camera\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\tvec3 eye = vec3(8.0, 5.0 * sin(0.2 * iTime), 7.0);    \n    //vec3 eye = vec3(0., 0., 10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    // Calc SDF\n    float dist = rayMarch(eye, worldDir, MIN_DIST, MAX_DIST, MAX_MARCHING_STEPS);\n    \n    if (dist > MAX_DIST - EPSILON)\n    {\n\t\tfragColor = vec4(0);\n        return;\n    }\n    \n    vec3 p = eye + dist * worldDir;\n    \n    //vec3 K_a = vec3(1.0, .19, .0);\n    vec3 K_a = 0.5 + 0.5*cos(iTime+p.xyx+vec3(0,2,4));\n    //vec3 K_a = (estimateNormal(p) + vec3(1.0)) / 2.0;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = lightScene(K_a, K_d, K_s, shininess, p, eye);\n    \n    // gamma correction\n    color = pow(color, vec3(0.4545));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[124, 124, 151, 151, 298], [300, 300, 327, 327, 474], [476, 476, 503, 503, 650], [652, 666, 703, 703, 728], [730, 730, 773, 773, 799], [801, 801, 845, 845, 870], [872, 872, 924, 924, 1023], [1025, 1025, 1083, 1083, 1183], [1185, 1185, 1244, 1244, 1343], [1345, 1359, 1392, 1392, 1420], [1422, 1422, 1453, 1453, 1540], [1542, 1542, 1575, 1575, 1640], [1642, 1642, 1665, 1665, 2705], [2709, 2724, 2812, 2812, 3107], [3109, 3109, 3174, 3174, 3306], [3308, 3308, 3357, 3392, 3523], [3526, 3539, 3568, 3568, 3803], [3805, 3805, 3942, 3942, 4577], [4579, 4579, 4657, 4657, 5451], [5453, 5453, 5510, 5530, 6467]], "test": "untested"}
{"id": "ttBcW3", "name": "Random Symbols", "author": "BackwardsCap", "description": "Randomly generated symbols", "tags": ["procedural", "circle", "random"], "likes": 7, "viewed": 353, "published": 3, "date": "1595603847", "time_retrieved": "2024-07-30T20:54:08.966269", "image_code": "#define R iResolution.xy\n#define PI 3.1415927\n#define SS(U) smoothstep(.05,0.,U)\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1283,8941.1283)))*(12893.128933));\n}\n\nbool removed(float h, vec2 p)\n{\n    float h2 = rand(vec2(20.+h*(+floor(p.y))+10.84));\n    return h*dot(h,h2)*5.<=.5;\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    c.rgb = vec3(0);\n    vec2 p = ((2.0*f-R)/R.y),u=p;\n    p = vec2(log(length(p.xy)), atan(p.y,p.x));\n    p*= (6.0/PI)*10.;\n    p+=vec2(p.y/3.34-iTime*3.,6.);    \n    vec2 lp = fract(p);\n    p=floor(p);\n    float hash = rand(p),\n          size = 4.;\n    vec3 col = vec3(0.);\n    if(!removed(hash, p))col=vec3(SS(length(lp-.5)-.4));       \n    p=mod(p+2.,vec2(size+2.*4.,10.));    \n    col*=min(length(u)*4.,1.);\n    if(abs(p.x)<=size&&abs(p.y)<=size)c.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 82, 103, 103, 181], [183, 183, 214, 214, 301], [303, 303, 344, 344, 808]], "test": "untested"}
{"id": "tljyWc", "name": "The dunnos", "author": "z0rg", "description": "A fun experiment with not so much code.\n", "tags": ["2d", "idunno", "dunnos", "theydunno"], "likes": 8, "viewed": 346, "published": 3, "date": "1595602142", "time_retrieved": "2024-07-30T20:54:09.729229", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\n\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\n\nfloat sat(float a)\n{\n    return clamp(a, 0., 1.);\n}\n\nfloat cir(vec2 p, float r)\n{\n    return length(p)-r;\n}\n\n// Thanks IQ :)\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    col = mix(vec3(33, 75, 166)/255., vec3(0.1), sat(length(uv)));\n    \n    int i = 0;\n    while (i < 4)\n    {\n        float xPos = float(i)*.2-.25;\n        \n        float yPos = (sin(float(i)*15.)*.2+.5)*mix(-1.,-8., sat(pow(sin(float(i)+iTime*0.9), 5.)));\n        float body = (sdSegment(uv, vec2(xPos*1.5, -1.), vec2(xPos,.3*yPos))-.05);\n        col = mix(vec3(0.), col, sat(body*200.));\n\t\tvec2 headP = vec2(xPos, .3*yPos);\n        vec2 blink = vec2(1., 1.-max(pow(sin(iTime*4.-float(i)*1.2), 50.), 0.1));\n        float eyes = min(cir((uv-headP-vec2(0.02, 0.002*abs(uv.x)))/blink,.01), cir((uv-headP-vec2(-0.02, 0.02*(uv.x)))/blink, .01));\n        col = mix(vec3(235, 202, 19)/255., col, sat(eyes*400.));\n        ++i;\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\t \n    vec3 col = rdr(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyWc.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 506], [509, 509, 529, 529, 560], [562, 562, 590, 590, 616], [618, 634, 686, 686, 805], [807, 807, 826, 826, 1595], [1597, 1597, 1654, 1654, 1786]], "test": "untested"}
{"id": "wtBcDc", "name": "Waves v.1", "author": "pli", "description": "First shader test, very basic 2d stuff.", "tags": ["learning"], "likes": 1, "viewed": 184, "published": 3, "date": "1595601654", "time_retrieved": "2024-07-30T20:54:10.580952", "image_code": "#define SHADOW 0.03\n\n\nfloat covered(vec2 uv, float speed, float height, float vOffset) {\n    float distance = height * cos(speed * iTime + uv.y * 2.0 + uv.x * 300.0 * height)\n        \t+ 0.3 * height * cos(speed * iTime + uv.x * 100.0 * height)\n        \t+ vOffset - uv.y;\n    \n    float covered;\n    if (distance < 0.0) {\n        covered = 1.0;\n    } else if (distance < SHADOW) {\n        covered = 1.0 - distance / SHADOW;\n    } else {\n        covered = 0.0;\n    }\n    return covered;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 result;\n    float c = covered(uv, 1.5, 0.02, 0.2);\n    if (c > 0.0) {\n        result = vec4(0.0, 0.18, 0.2 ,1.0) * sqrt(c);\n    } else {\n        c = covered(uv, 2.5, 0.04, 0.0);\n        if (c > 0.0) {\n        \tresult = vec4(0.14, 0.37, 0.4 ,1.0) * sqrt(c);\n        } else {\n            c = covered(uv, 4.0, 0.05, -0.25);\n            if (c > 0.0) {\n                result = vec4(0.25, 0.47, 0.51 ,1.0) * sqrt(c);\n            } else {\n                result = vec4(0.41, 0.58, 0.61 ,1.0);\n            }\n        }\n    }\n    \n    // Output to screen\n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 88, 88, 486], [488, 488, 545, 595, 1266]], "test": "untested"}
{"id": "3ljcDc", "name": "Waves v.2", "author": "pli", "description": "Still 2d, some textures and a boat.", "tags": ["learning"], "likes": 1, "viewed": 209, "published": 3, "date": "1595599866", "time_retrieved": "2024-07-30T20:54:11.371837", "image_code": "#define SHADOW 0.03\n#define MULTIPLIER 0.6\n#define BASE_COLOR vec4(0.0, 0.18, 0.2 ,1.0)\n#define SHOW_TEXTURES true\n\n#define BOAT_COLOR vec4(1., 0.57, 0.0 ,1.0)\n#define HEAD_COLOR vec4(.7, .6, .4 ,1.0)\n#define EYE_COLOR vec4(0., 0.0, 0.0 ,1.0)\n\nfloat hash(vec2 p)  // replace this by something better\n{\n    p  = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 p )\n{\n    // from https://www.shadertoy.com/view/lsf3WH\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat heightAt(vec2 uv, float speed, float height, float vOffset) {\n    return height * cos(speed * iTime + uv.y * 2.0 + uv.x * 300.0 * height)\n        \t+ 0.3 * height * cos(speed * iTime + uv.x * 100.0 * height)\n        \t+ vOffset;\n}\n\nfloat covered(vec2 uv, float speed, float height, float vOffset) {\n    float distance = heightAt(uv, speed, height, vOffset) - uv.y;\n    \n    float covered;\n    if (distance > SHADOW) {\n        covered = 1.0;\n    } else if (distance > 0.) {\n        covered = distance / SHADOW;\n    } else {\n        covered = 0.0;\n    }\n    return covered;\n}\n\nfloat dist(vec2 p1, vec2 p2) {\n\treturn sqrt( (p1.x-p2.x) * (p1.x-p2.x) + (p1.y-p2.y) * (p1.y-p2.y));   \n}\n\nvec4 drawCircle(vec4 pixel, vec2 uv, vec2 position, float size, vec4 color) {\n    if (dist(uv, position) < size) {\n    \tpixel = color;   \n    }\n    return pixel;    \n}\n\nvec4 drawBoat(vec4 pixel, vec2 uv, vec2 position, float size) {\n\n\n    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .015, HEAD_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x + 0.007, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)) + 0.03, .002, EYE_COLOR);\n\n    pixel = drawCircle(pixel, uv, vec2(position.x, heightAt(vec2(position.x, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.02, heightAt(vec2(position.x+0.02, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.04, heightAt(vec2(position.x+0.04, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n    pixel = drawCircle(pixel, uv, vec2(position.x+0.06, heightAt(vec2(position.x+0.06, 0), 2.5, 0.04, 0.0)), .025, BOAT_COLOR);\n\n    return pixel;\n}\n\nvec4 drawWave(vec4 pixel, vec2 uv, float speed, float height, float vOffset) {\n    float c = covered(uv, speed, height, vOffset);\n    if (c == 1.) {\n\t\tpixel += BASE_COLOR * MULTIPLIER;\n        \n        if (SHOW_TEXTURES) {\n            vec2 nUv = uv;\n            nUv.x += iTime * sqrt(speed) * 0.1;\n            nUv.y -= heightAt(uv, speed, height, vOffset);\n            pixel += .015 * noise(nUv * 20.);\n    \t}\n    } else if (c > 0.) {\n\t\tpixel *= vec4(vec3(sqrt(1.-c)) ,1.0);\n    }\n    \n\treturn pixel;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec4 result;\n\tresult = vec4(0.0, 0.18, 0.2 ,1.0);\n\n    \n    result = drawWave(result, uv, 1.5, 0.02, 0.2);\n    vec2 boatPosition = vec2(.2 + 0.2 * cos(0.5*iTime) + 0.1 * cos(0.95*iTime), 0.);\n    result = drawBoat(result, uv, boatPosition, .025);\n\n//    vec2 boatPosition2 = vec2(.1 + 0.2 * cos(1.5*iTime) + 0.2 * cos(0.35*iTime), 0.);\n//    result = drawBoat(result, uv, boatPosition2, .025);\n\n    result = drawWave(result, uv, 2.5, 0.04, 0.0);\n    result = drawWave(result, uv, 5.0, 0.05, -0.25);\n\n    \n    // Output to screen\n    //result = vec4(vec3(noise(uv * 100.)), 1.);\n    fragColor = result;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[244, 244, 301, 301, 405], [407, 407, 433, 483, 777], [779, 779, 846, 846, 1013], [1015, 1015, 1081, 1081, 1356], [1358, 1358, 1388, 1388, 1463], [1465, 1465, 1542, 1542, 1632], [1634, 1634, 1697, 1697, 2480], [2482, 2482, 2560, 2560, 2984], [2986, 2986, 3043, 3093, 3791]], "test": "untested"}
{"id": "3t2cDc", "name": "\"A\" Scribble", "author": "sirjofri", "description": "quick shader.", "tags": ["quick"], "likes": 3, "viewed": 283, "published": 3, "date": "1595583864", "time_retrieved": "2024-07-30T20:54:12.140781", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= .5;\n    float f = pow((1.-length(uv)), 1.5);\n    uv.x *= 25.;\n    uv.y *= 0.7;\n    \n    vec2 d = vec2(\n        sin(iTime+uv.y*10.+uv.x*.3+2.*cos(iTime+uv.x*2.)),\n        sin(iTime-uv.x-uv.y*30.-3.*sin(iTime-uv.y*30.))\n        );\n    \n    uv += d*0.005;\n    \n    float a = sin(uv.y + iTime + cos(abs(uv.x) + uv.y*10.))*0.5+0.5;\n    float b = cos(uv.y + iTime*5. + tan(abs(uv.x) + uv.y*10.));\n    float c = cos(uv.y + iTime + sin(abs(uv.x) - uv.y*10.))*0.5+0.5;\n    \n    vec3 x = vec3(1., 0., 0.) * a;\n    vec3 y = vec3(0., 0., 1.) * c;\n    vec3 z = vec3(0., 1., 0.) * b;\n    \n    vec3 r = mix(x+y, vec3(0., 1., 0.), b);\n    \n    fragColor = vec4(r*f, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 765]], "test": "untested"}
{"id": "WljcDc", "name": "Necker Cube", "author": "dr2", "description": " Dynamic generalization of the Necker Cube (mouse restores sanity)", "tags": ["illusion", "projection", "paradox"], "likes": 12, "viewed": 342, "published": 3, "date": "1595579728", "time_retrieved": "2024-07-30T20:54:13.161053", "image_code": "// \"Necker Cube\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Dynamic generalization of the Necker Cube (mouse restores sanity)\n\n// (Appears in Escher's Belvedere - the original, not the shader)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat Minv3 (vec3 p);\nvec2 Rot2D (vec2 q, float a);\n\nvec4 sLen;\nvec3 qHit, ltDir, vuDir;\nfloat tCur, dstFar, eWid;\nint idObj;\nbool isBg, doFg;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isBg) {\n    q = abs (p);\n    q = abs (p) - sLen.wyz;\n    d = PrBoxDf (q, sLen.xww + eWid);\n    DMINQ (1);\n    q = abs (p) - sLen.xwz;\n    d = PrBoxDf (q, sLen.wyw + eWid);\n    DMINQ (2);\n    q = abs (p) - sLen.xyw;\n    d = PrBoxDf (q, sLen.wwz + eWid);\n    DMINQ (3);\n    q = p;\n    q.y -= - sLen.y - eWid - 0.03;\n    d = q.y;\n    DMINQ (6);\n  } else {\n    q = p - (sLen.xwz - 10. * vuDir);\n    d = PrBoxDf (q, sLen.wyw + eWid * vec3 (1., -1., 1.));\n    DMINQ (4);\n    q = p - (sLen.xyw * vec3 (1., -1., 1.) - 10. * vuDir);\n    d = PrBoxDf (q, sLen.wwz + eWid * vec3 (1., 1., -1.));\n    DMINQ (5);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0002 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0001, -0.0001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 roo, col, vn;\n  vec2 s;\n  float dstObj, dstObjF, c;\n  sLen = vec4 (vec3 (3., 2., 4.), 0.);\n  eWid = 0.2;\n  isBg = true;\n  roo = ro;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    c = 99.;\n    if (idObj <= 3) {\n      col4 = (Minv3 (max (abs (ro) - sLen.xyz + eWid, 0.)) > 0.) ?\n         vec4 (1., 1., 0.7, 0.3) : vec4 (0.9, 0.6, 0., 0.);\n      if (idObj == 1 && abs (qHit.x) < sLen.x - eWid) c = (abs (vn.z) > 0.5) ? qHit.y : qHit.z;\n      else if (idObj == 2 && abs (qHit.y) < sLen.y - eWid) c = (abs (vn.x) > 0.5) ? qHit.z : qHit.x;\n      else if (idObj == 3 && abs (qHit.z) < sLen.z - eWid) c = (abs (vn.y) > 0.5) ? qHit.x : qHit.y;\n    } else {\n      col4 = vec4 (0.6, 0.6, 0.65, 0.);\n      s = abs (qHit.xz) - sLen.xz;\n      col4 *= 0.7 + 0.3 * smoothstep (-0.1, 0., max (length (max (s - eWid - 0.1, 0.)) - 0.05,\n         - length (max (s + eWid + 0.1, 0.))));\n    }\n    if (doFg) {\n      isBg = false;\n      ro = roo;\n      dstObjF = ObjRay (ro, rd);\n      if (dstObjF < dstObj) {\n        ro += dstObjF * rd;\n        vn = ObjNf (ro);\n        col4 = vec4 (0.9, 0.6, 0., 0.);\n        if (idObj == 4 && abs (qHit.y) < sLen.y - eWid) c = (abs (vn.x) > 0.5) ? qHit.z : qHit.x;\n        else if (idObj == 5 && abs (qHit.z) < sLen.z - eWid) c = (abs (vn.y) > 0.5) ? qHit.x : qHit.y;\n      }\n    }\n    if (c != 99.) col4 *= 0.9 + 0.1 * cos (12. * pi * c);\n  }\n  col = col4.rgb * (0.3 + 0.7 * max (dot (vn, ltDir), 0.)) +\n     col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  return clamp (col, 0., 1.);\n}\n\n#define AA  1   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr;\n  vec3 ro, col, vx, vy;\n  vec2 canvas, uv, uvv, mSize, fgLim;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  az = 0.3 * pi + 0.05 * pi * sin (0.1 * pi * tCur);\n  el = -0.07 * pi + 0.02 * pi * cos (0.1 * pi * tCur);\n  ro = vec3 (0., 0., -12.);\n  ro.yz = Rot2D (ro.yz, - el);\n  ro.xz = Rot2D (ro.xz, - az);\n  vuDir = normalize (- ro);\n  mSize = vec2 (0.7, 0.5);\n  fgLim = abs (uv) - mSize;\n  doFg = (max (fgLim.x, fgLim.y) < 0.);\n  if (mPtr.z > 0.) doFg = false;\n  vx = normalize (vec3 (vuDir.z, 0., - vuDir.x));\n  vy = vec3 (0., 1., 0.) - vuDir.y * vuDir;\n  zmFac = 0.22;\n  dstFar = 100.;\n  ltDir = normalize (vec3 (-1., 3., -0.3));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n    col += (1. / naa) * ShowScene (ro + vec3 (uvv.x * vx + uvv.y * vy) / zmFac, vuDir);\n  }\n  uv *= vec2 (canvas.y / canvas.x, 1.);\n  uv *= uv;\n  uv *= uv;\n  col *= 1. - 0.3 * smoothstep (0.5, 1., dot (uv, uv));\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcDc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[531, 531, 553, 553, 1222], [1224, 1224, 1257, 1257, 1434], [1436, 1436, 1457, 1457, 1707], [1709, 1709, 1744, 1744, 3337], [3381, 3381, 3437, 3437, 4753], [4755, 4755, 4787, 4787, 4887], [4889, 4889, 4911, 4911, 4949], [4951, 4951, 4981, 4981, 5094]], "test": "untested"}
{"id": "Wl2cWc", "name": "Raymarcher - Test 3: Terrain", "author": "SpinningCube", "description": "Infinite procedurally generated terrain produced with raymarching. Hopefully not as many artifacts show up now.\n\nMy newer, improved terrain ray marcher: https://www.shadertoy.com/view/sdVfD3", "tags": ["raymarching"], "likes": 3, "viewed": 575, "published": 3, "date": "1595565808", "time_retrieved": "2024-07-30T20:54:14.141432", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Filmic Transform curve by milesWaugh\n// Fractal brownian motion function found in: https://www.shadertoy.com/view/MdX3Rr\n// Based on this article: https://iquilezles.org/articles/terrainmarching\n\n\nconst int maxSteps = 850;\nconst float epsilon = 0.01;\nconst float focalLength = 1.;\nconst float renderDist = 32.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfShininess;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = .8*vec3(.5, .8, 1.2);\nvec3 sky;\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\nconst mat2 m2 = mat2(0.8,-0.6,0.6,0.8);\n\nfloat fbm( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*texture( iChannel0, p/256.0 ).x; p = m2*p*2.02;\n    f += 0.2500*texture( iChannel0, p/256.0 ).x; p = m2*p*2.03;\n    f += 0.1250*texture( iChannel0, p/256.0 ).x; p = m2*p*2.01;\n    f += 0.0625*texture( iChannel0, p/256.0 ).x;\n    return f/0.9375;\n}\n\n// SDF's\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(mod(ray, 150.), pos ) - radius;\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float shininess ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfShininess = shininess;\n        }\n    }\n}\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    //addSDF( Ground(ray, sin(ray.x)+sin(ray.z)), colx, 0., 0. );\n    \n    float offset = 1.*fbm(ray.xz);\n    offset = offset + .1;\n    offset = offset * offset * offset - 0.1;\n    \n\t\n    addSDF( Ground(ray, offset*0.1), 0.8*sky, 1.5, 512. );\n    addSDF( Ground(ray, offset), vec3(0.15,0.4,0.1), 0., 0. );\n    \n    //addSDF( Sphere( ray, vec3(100, 100, 100), 15.), colx, 1.5, 512. );\n    \n    return SDE;\n}\n// Normal Approximation\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\n// The Ray\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    ray = start;\n    float stepSize = 3.;\n    float rayLength = 0.;\n    \n    float prevDist;\n    float prevY;\n    \n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        scene( ray, renderDist );\n        \n        rayLength += stepSize;\n        ray = rayDir * rayLength + start;\n        \n        if ( SDE < 0. ) {\n            float finalRayLength = rayLength;\n            //float finalRayLength = rayLength - stepSize + stepSize*(-prevDist)/(ray.y-prevY+(SDE+ray.y)-(prevDist+ray.y));\n            return vec4(1., rayDir * finalRayLength + start);\n        }\n        \n        prevDist = SDE;\n        prevY = ray.y;\n        \n        stepSize = 0.003 * rayLength;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n    }\n    return vec4(0., ray);\n}\n\n// Lighting\n\nvoid phongLighting(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * 1.), lightDist, false).x == 0. ) {\n        \n        diffuse += max(intensity * dot(surfNormal, lightDir), 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n    \tspecular += max(intensity * surfSpecular * pow(dot(surfNormal, halfway), surfShininess), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    phongLighting( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    phongLighting( ray, rayDir, normalize(vec3(-1,.3,0)), surfNormal, 3., 50. );\n}\n\nvec3 filmicTransform(vec3 color) {\n    //color = 1.1*color;\n    //return color;\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    fog = pow(15., fog-1.);\n    //fog = fog*fog;\n    vec3 finalCol = (diffuse * surfCol) + (ambient * surfCol) + specular;\n    finalCol = mix(finalCol, sky, fog);\n    \n    return filmicTransform(finalCol);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = vec3(1.*iTime, 1.5, 2.*iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    float sky2 = abs(1.5*rayDir.y)-2.;\n    sky2 = 0.1*(sky2*sky2+0.5);\n    \n    sky = vec3(sky2*1., sky2*2., sky2*3.);\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = filmicTransform(sky);\n        //col = ambient;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cWc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[612, 612, 655, 655, 698], [741, 741, 762, 762, 1045], [1057, 1057, 1107, 1107, 1161], [1163, 1163, 1198, 1198, 1222], [1224, 1224, 1293, 1293, 1472], [1474, 1474, 1517, 1517, 2066], [2067, 2091, 2118, 2118, 2489], [2503, 2503, 2584, 2584, 3408], [3423, 3423, 3532, 3532, 3855], [3857, 3857, 3948, 3948, 4089], [4091, 4091, 4149, 4149, 4232], [4234, 4234, 4268, 4313, 4484], [4486, 4486, 4541, 4541, 4904], [4909, 4909, 4966, 4966, 5678]], "test": "untested"}
{"id": "3l2cWc", "name": "Lovers, the Lord has left us.", "author": "kstyler", "description": "Red hearts in groups of three falling down.", "tags": ["2d", "heart", "polar", "love", "throuple"], "likes": 1, "viewed": 334, "published": 3, "date": "1595565750", "time_retrieved": "2024-07-30T20:54:14.913368", "image_code": "vec2 toPolar(vec2 rct){  \n    return vec2(length(rct),atan(rct.y,rct.x));\n}\nvec2 toRect(vec2 pol){\n    return vec2(pol.x*cos(pol.y),pol.x*sin(pol.y));\n}\nfloat heart(vec2 uv){\n    return pow((uv.x*uv.x) + (uv.y*uv.y) - 1.,3.)- uv.x*uv.x*uv.y*uv.y*uv.y;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 uv = (fragCoord.xy-0.5* iResolution.xy)/iResolution.x;\n    uv.y+=iTime*0.2;\n    uv*=4.0;\n   \n    uv=mod(uv,-1.);\n    \n    uv+=0.5;\n \n    uv = toPolar(uv);\n    \n    uv.y = mod(uv.y-iTime,3.14159*2./3.);\n    \n    uv=toRect(uv);\n    \n    uv-=0.140;\n    \n  \n    vec3 col = vec3(heart(uv*8.)+.01);\n    \n      \n    col = step(0.01,col);\n    col = 1.-col;\n    col*=vec3(1,0,0);\n    if(col==vec3(0)){\n        col = vec3(1);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 75], [76, 76, 98, 98, 152], [153, 153, 174, 174, 253], [255, 255, 309, 309, 773]], "test": "untested"}
{"id": "3t2yW3", "name": "Vinyl makeover Dangerzone", "author": "Davy_Jones444", "description": "Nice Shader for nice german Streamer Dangerzone DJ", "tags": ["microfone"], "likes": 1, "viewed": 400, "published": 3, "date": "1595538183", "time_retrieved": "2024-07-30T20:54:15.901726", "image_code": "#define BARS 12.\n\n#define PI 3.14159265359\n\n// rotation transform\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance function of half of an ark\n// parameters: inner radius, outer radius, angle\nfloat sdArk(vec2 p, float ir, float or, float a) {\n    \n    // add outer circle\n    float d = sdCircle(p, or);\n        \n    // substract inner circle\n    d = opS(d, sdCircle(p, ir));\n    \n    // rotate with angle\n    tRotate(p, -a * PI / 2.);\n    \n    // clip the top\n    d = opS(d, -p.y);\n    \n    // add circle to the top\n    d = opU(d, sdCircle(p - vec2((or + ir) / 2., 0.), (or - ir) / 2.));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    // I wanted it to look good on my phone vertically :P\n    if (iResolution.x > iResolution.y) uv.x *= iResolution.x / iResolution.y; else uv.y *= iResolution.y / iResolution.x;\n    \n    // little white padding\n    uv *= 1.05;\n    \n    // add circles\n    float d = sdCircle(uv, 1.);\n    d = opS(d, sdCircle(uv, .34));\n    d = opU(d, sdCircle(uv, .04));\n    \n    // calculate position of the bars\n    float barsStart = .37;\n    float barsEnd = .94;\n    float barId = floor((length(uv) -barsStart) / (barsEnd - barsStart) * BARS);\n    \n    // only go forward if we're in a bar\n    if (barId >= 0. && barId < BARS) {\n        \n        float barWidth = (barsEnd - barsStart) / BARS;\n        float barStart = barsStart + barWidth * (barId + .25);\n        float barAngel = texture(iChannel0, vec2(1. - barId / BARS, .25)).x * .5;\n\n        // add a little rotation to completely ruin the beautiful symmetry\n        tRotate(uv, -barAngel * .2 * sin(barId + iTime));\n        \n        // mirror everything\n    \tuv = abs(uv);\n        \n        // add the bars\n        d = opS(d, sdArk(uv, barStart, barStart + barWidth / 2., barAngel));\n    }\n    \n    // use the slope to render the distance with antialiasing\n    float w = min(fwidth(d), .01);\n    fragColor = vec4(.90,.890,d/.001, 1.0);\n\t\n\n}", "image_inputs": [{"id": 19, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 32, "src": "/presets/mic.png", "ctype": "mic", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 66, 107, 107, 176], [178, 197, 230, 230, 258], [260, 269, 298, 298, 322], [324, 340, 369, 369, 394], [396, 484, 534, 563, 895], [897, 897, 954, 954, 2294]], "test": "untested"}
{"id": "WlBcD3", "name": "Somewhere In Colorado.", "author": "Plento", "description": "I'm a little bit rock and roll", "tags": ["2d", "mountains", "house", "recreation", "southpark"], "likes": 20, "viewed": 542, "published": 3, "date": "1595535519", "time_retrieved": "2024-07-30T20:54:16.823262", "image_code": "// Cole Peterson (Plento)\n\n#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvec3 hash31(float p){\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\nfloat sdBox( in vec2 p, in vec2 b ){\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\nfloat box(vec2 uv, vec2 dim, float b){\n    uv = abs(uv);\n    float bx = ss(b, -b, uv.y - dim.y );\n    bx *= ss(b, -b, uv.x - dim.x);\n    return bx;\n}\n\nvec3 frameCol = 0.9*vec3(0.4, 0.3, 0.1);\nvec3 winCol = .8*vec3(0.3, 0.9, 0.9);\n\nvec4 ground(vec2 uv){\n    float y = uv.y + 0.5;\n    float a = 1.-step(.21, y);\n    float sw = .6 * ss(-.1, 0.1, abs(cos(10.*(-uv.x + uv.y*2. + .12))));\n    vec3 col = mix(vec3(.16), mix(vec3(.34), vec3(sw), step(.115, y)), step(.1, y));\n    col = mix(col, vec3(1), step(.21, y));\n    return vec4(col, a);\n}\n\n\nvec4 fence(vec2 uv){\n    float a = ss(.0543,.054, abs(uv.y+.05));\n \tvec3 col = .9*vec3(0.9, 0.76, 0.6) * a;   \n    col *= ss(-.3, .3, abs(sin(uv.x*140.)));\n    return vec4(col, a);\n}\n\n\n\nvec4 mountains(vec2 uv){\n    uv.y -= .12;\n    vec3 col = vec3(0);\n    float a = 0.;\n    float snow = 0.;\n    \n    for(float i = 0.; i < 2.; i++){ \n        uv.x += iTime*.05;\n        \n        float ht = texture(iChannel0, uv*16.).x;\n        \n        float nse = cos(uv.x*14. + i*345.)*.01 + cos(uv.x*44. + i*123.)*.003\n            + cos(uv.x*2. + i*654.)*.01;\n        \n        vec2 p = uv + nse;\n        float t = (1.3-i*.02)*p.x*.8 + i*9.;\n        float h = .06*asin(sin(6.*t + 2.5*i)*0.999);\n        float c = ss(.104,.1, p.y - h - i*.01 + .02);\n    \ta = mix(a, 1., c);\n        \n    \tcol = mix(col, mix(vec3(.2, .3, .3),1.3*vec3(0.13, 0.26, 0.18),i), c);\n        col +=ht*.06;\n    \tsnow = ss(.66, .674, (uv.y + 0.522)+nse*1.4);\n    \tcol = mix(col, vec3(3), snow); \n    }\n    return vec4(col, a);\n}\n\n\nfloat snow(vec2 uv){\n    float nse = cos(uv.x*60.)*.001 + cos(uv.x*170.)*.0006 + cos(uv.x*10. + 24.32)*.003\n        + cos(uv.x*30. + 65.32)*.003;\n    uv.y += nse;\n \tfloat a = ss(.1,.1038, abs(uv.y+.2));   \n    vec3 col = vec3(0);\n    return a;\n}\n\nfloat houseShape(vec2 uv, vec2 dim){\n    float ox = dim.x;\n    dim.x -= uv.y;\n    dim.x = min(ox, dim.x);                      \n    return box(uv, dim, .001);\n}\n\nvec4 roofShape(vec2 uv){\n    float p = uv.x;\n    \n    uv.x = abs(uv.x);\n    uv *= rot(7.05);\n    \n    float a = box(uv-vec2(-0.13, .32), vec2(.2, .01), .0001);\n    vec3 col = frameCol * a;\n    \n    if(uv.y < 0.321)\n    \tuv.y -= (cos(p*171.)*.01 + cos(p*50.)*.003 + cos(p*70.)*.005);\n    \n    float snow = box(uv-vec2(-0.13, .33), vec2(.21, .008), .005);\n    col += vec3(6.) * snow;\n    \n    a += snow;\n    return vec4(col, a);\n}\n\n\nvec4 house(vec2 uv, vec3 hc, bool front){\n    vec3 col = hc;\n    \n    float a = houseShape(uv-vec2(0., .21), vec2(0.24, 0.35));\n    vec2 p = (uv - vec2(0., 0.17)) * 6.5;\n    \n    vec2 b = vec2(0.91, 1.3);\n    vec2 wv = mod(p + 0.5*b, b) - 0.5*b;\n    \n    if(front){\n    \tfloat glass = box(wv, vec2(.26, .28), .001);\n    \tfloat frame = box(wv, vec2(.22, .24), .001);\n    \tframe *= step(.01, abs(wv.x))*step(.01, abs(wv.y));\n    \n        glass += frame;\n    \n    \tvec3 window = mix(frameCol, winCol, step(2., glass));\n    \n    \tglass *= 1.-step(.26, uv.y);\n    \n    \tcol = mix(col, window, min(glass*3., 1.));\n    \n    \tfloat dr = box(uv-vec2(0., -0.04), vec2(.048, .076), .001);\n    \tfloat doorframe = box(uv-vec2(0., -0.04), vec2(.04, .07), .001);\n    \tfloat des = sdBox(uv-vec2(-0.02, 0.), vec2(.01, .02));\n        des = min(des, sdBox(uv-vec2(0.02, 0.), vec2(.01, .02)));\n        des = min(des, length(uv-vec2(0.02, -0.045))-.005);\n    \tcol = mix(col, .7*vec3(0.9, 0.8, 0.7), doorframe);\n    \tcol *= max(ss(.0,.0005, abs(des) - .001), 0.7);\n        \n    \tdr -= doorframe;\n    \tcol = mix(frameCol, col, 1.-dr);\n    \n    \tfloat steps = box(uv - vec2(0., -.137), vec2(.1, .005), .001);\n    \tsteps += box(uv - vec2(0., -.126), vec2(.08, .005), .001);\n   \t \tsteps += box(uv - vec2(0., -.115), vec2(.06, .005), .001);\n    \n    \tcol = mix(col, vec3(.5), steps);\n    }\n    \n    return vec4(col, a);\n}\n\n\nvec4 garage(vec2 uv, vec3 hc){\n    vec3 col = hc;\n \tfloat a = houseShape(uv-vec2(0.55, .068), vec2(0.20, 0.22));   \n    float door = box(uv-vec2(0.55, -0.05), vec2(.15, .1), .001);\n    col = mix(col, frameCol*ss(-.5, .5,abs(sin(uv.y*150. + 1.5))), door);\n    col *= max(min(abs((uv.y-.07)*310.), 1.), .8);\n    return vec4(col, a);\n}\n \n\nvec4 walkway(vec2 uv){\n    vec3 col = vec3(0);\n \t\n    vec2 p = uv-vec2(0.48, 0.08);\n    vec2 def = cos(uv*30.) * .01 + cos(uv*60. + 123.32) * .005 + cos(uv*250. + 123.32)*.0018;\n    p += def;\n    \n    p.x -= sin(p.y*8.)*.5;\n    p.y += cos(p.x*4.)*.1;\n    \n    float a = box(p - vec2(0.0, -0.2), vec2(.085, .1), .005);\n    \n    col = vec3(.65) * a;\n    \n    uv += def;\n    float w2 = box(uv - vec2(0.55, -0.22), vec2(.1 - uv.y*.4, .175), .002);\n    \n    a = min(a+w2, 1.);\n    col = mix(col, vec3(.65), a);\n    \n    return vec4(col, a);\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec2 p = uv;\n    \n    uv.x += iTime*.2;\n    \n    vec3 col = vec3(.7, 0.9, 1.0);\n    \n    float spc = 1.8;\n    vec2 b = vec2(spc, 0.0);\n    vec2 ruv = mod(uv + 0.5*b, b) - 0.5*b;\n    ruv.x += .3;\n    float id = floor((uv.x - .5)/spc);\n    \n    \n    float ht = texture(iChannel0, uv*16.).x;\n    \n    // Mountains\n    vec4 mnt = mountains(p);\n    col = mix(col, mnt.rgb, mnt.a);\n    \n    \n   \n    float spc2 = 1.1;\n    vec2 b2 = vec2(spc2, 0.0);\n    vec2 p2 = p-vec2(0.0, 0.);\n    p2.x += iTime*.13;\n    vec2 ruv2 = mod(p2 + 0.5*b2, b2) - 0.5*b2;\n    ruv2.x += .3;\n    float id2 = floor((p2.x - .5)/spc2);\n    \n    float ht2 = texture(iChannel0, p2*16.).x;\n    \n    vec3 hcb = .2 + .5 * hash31(id2*223.32 + 88.);\n    hcb += ht2*.15;\n    \n    vec4 bhse = house((ruv2 - vec2(0.0, 0.))*1.8, hcb, false);\n    col = mix(col, bhse.rgb*.8, bhse.a);\n    vec4 rf3 = roofShape(ruv2*1.9);\n    col = mix(col, rf3.rgb, rf3.a);\n        \n    \n    // Fence\n    vec4 fnc = fence(uv);\n    col = mix(col, fnc.rgb, fnc.a);\n    \n    \n    // Snowy yard\n    float snw = snow(uv);\n    col = mix(vec3(1), col, snw);\n    \n    \n    // walkway/ driveway\n    vec4 wlk = walkway(ruv);\n    col = mix(col, wlk.rgb, wlk.a);\n    \n    \n    // Sidewalk and road\n    vec4 gnd = ground(uv);\n    col = mix(col, gnd.rgb, gnd.a);\n    \n    // house color\n    vec3 hc = .2 + .5 * hash31(id*623.32 + 5.);\n    hc += ht*.15;\n    \n    // house\n    vec4 hse = house(ruv, hc, true);\n    col = mix(col, hse.rgb, hse.a); \n    \n    vec2 pc = ruv;\n    pc.xy += cos(uv.yx*40.+3.)*.005 + cos(uv.yx*80.+324.3)*.002 + cos(uv.yx*180.+324.3)*.001;\n    float det = box(pc-vec2(-0.42, -.18), vec2(.33, .05), .002);\n    det += box(-pc-vec2(-0.17, .143), vec2(.07, .01), .002);\n    col = mix(col, vec3(1), det);\n    \n    \n    // roof\n    vec4 roof = roofShape(ruv);\n    col = mix(col, roof.rgb, roof.a);\n    \n    // garage\n    vec4 grg = garage(ruv, hc);\n    col = mix(col, grg.rgb, grg.a); \n    \n    // garage roof\n    vec4 groof = roofShape(1.2*ruv-vec2(0.66, -0.13));\n    col = mix(col, groof.rgb, groof.a);\n    \n    \n    f = vec4(col, 1.0);\n    \n}\n\n\n\n\n\n\n", "image_inputs": [{"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 112, 112, 164], [166, 166, 187, 187, 320], [321, 321, 357, 357, 437], [438, 438, 476, 476, 587], [669, 669, 690, 690, 975], [978, 978, 998, 998, 1160], [1164, 1164, 1188, 1188, 1962], [1965, 1965, 1985, 1985, 2210], [2212, 2212, 2248, 2248, 2372], [2374, 2374, 2398, 2398, 2802], [2805, 2805, 2846, 2846, 4199], [4202, 4202, 4232, 4232, 4534], [4538, 4538, 4560, 4560, 5075], [5077, 5077, 5117, 5117, 7248]], "test": "untested"}
{"id": "wlScWc", "name": "Electric beams", "author": "sympou", "description": "a cellular automata I made a long time ago\ni don't remember the idea behind it !", "tags": ["automata"], "likes": 19, "viewed": 449, "published": 3, "date": "1595529967", "time_retrieved": "2024-07-30T20:54:17.649054", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    float val = texelFetch( iChannel0, ivec2(fragCoord), 0 ).r;\n    \n    float val2 = abs(val-0.5)*2.0;\n    \n    fragColor = vec4( vec3(val2), 1.0 );\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// cell and hash functions by iq\n// https://www.shadertoy.com/view/XstGRf#\n\nfloat hash1( float n ) {\n    return fract(sin(n)*138.5453123);\n}\n\nfloat Cell( in ivec2 p ) {\n    ivec2 r = ivec2(textureSize(iChannel0, 0));\n    p = (p+r) % r;    \n    return texelFetch(iChannel0, p ,0).r;\n}\n\nfloat myLerp( float p1, float p2 ) {\n\tfloat a = fract(p2 - p1);\n\treturn fract(p1 + (fract(2.0*a) - a)*0.5);\n}\n\nfloat prox2(in float n, in float n2) {\n\tfloat p = min(n,n2);\n\tfloat g = max(n,n2);\n\treturn max(g-p,p-(g-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    ivec2 px = ivec2( fragCoord );\n\n\tfloat pixel = Cell(px);\n    vec4 n = vec4(Cell(px-ivec2(1,0)),\n\t\t\t\t  Cell(px+ivec2(1,0)),\n\t\t\t\t  Cell(px-ivec2(0,1)),\n\t\t\t\t  Cell(px+ivec2(0,1)));\n\n\tfloat truc = myLerp(myLerp(n[0],n[1]),myLerp(n[2],n[3]));\n\tfloat truc2 = prox2(truc,pixel)*1.39 - 0.36;\n   \n    float f = fract(truc*truc2);\n\n\tfragColor = vec4(fract(truc*truc2),0,0,1);\n\n    if( iFrame==0 ) fragColor = vec4(hash1(fragCoord.x*13.0+hash1(fragCoord.y*71.1)),0.,0.,1.);\n    \n    if(iMouse.z>0.5 && length(iMouse.xy-vec2(px))<30.) fragColor = vec4(1.);\n\n} ", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 210]], "test": "untested"}
{"id": "wlByWc", "name": "Analytic Raster Triangle, Pt II", "author": "Schrompf", "description": "Another attempt at analytically rasterizing a triangle, much simpler than previous attempt. Calculate exactly how much area of a (rectangular) pixel is covered by a triangle, and therefore get perfect antialiasing. I think UnrealEngine5 is doing this", "tags": ["antialiasing"], "likes": 0, "viewed": 265, "published": 3, "date": "1595525137", "time_retrieved": "2024-07-30T20:54:18.398051", "image_code": "const float GridSize = 32.0f;\n\nfloat saturate( float t) { return max( 0.0f, min( 1.0f, t)); }\nvec2 saturate( vec2 v) { return max( vec2( 0), min( vec2( 1), v)); }\nvec3 saturate( vec3 v) { return max( vec3( 0), min( vec3( 1), v)); }\nvec4 saturate( vec4 v) { return max( vec4( 0), min( vec4( 1), v)); }\n\nfloat triangleIntegral( vec2 pa, vec2 pb, vec2 pc, vec2 rectMin, vec2 rectMax, vec2 fragCoord, out vec4 debugColour)\n{\n    vec4 rectCenterSize = vec4( 0.5f * (rectMin + rectMax), rectMax - rectMin);\n    \n    // there has been a sorting here, but it was unnecessary\n    vec2 p1 = pa, p2 = pb, p3 = pc;\n    \n    // from left to right: enter of AB and AC, either leave of AB, AC or end of AB, enter of BC, leave of BC and AC\n    vec2 d12 = p2 - p1, d23 = p3 - p2, d31 = p1 - p3; \n    \n    // where d12 enters and leaves the area\n    vec4 p12Step = mix( (rectCenterSize - vec4( p1, 0, 0)) / d12.xyxy, vec4( 0, 0, 1000, 1000), equal( d12.xyxy, vec4( 0)));\n    vec4 p12EnterExit = saturate( p12Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p12Step.zwzw));\n    float p12LatestEnter = max( p12EnterExit.x, p12EnterExit.y);\n    float p12EarliestExit = min( p12EnterExit.z, p12EnterExit.w);\n\n    // and where d23 enters and leaves\n    vec4 p23Step = mix( (rectCenterSize - vec4( p2, 0, 0)) / d23.xyxy, vec4( 0, 0, 1000, 1000), equal( d23.xyxy, vec4( 0)));\n    vec4 p23EnterExit = saturate( p23Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p23Step.zwzw));\n    float p23LatestEnter = max( p23EnterExit.x, p23EnterExit.y);\n    float p23EarliestExit = min( p23EnterExit.z, p23EnterExit.w);\n    \n    // and finally where d31 enters and leaves\n    vec4 p31Step = mix( (rectCenterSize - vec4( p3, 0, 0)) / d31.xyxy, vec4( 0, 0, 1000, 1000), equal( d31.xyxy, vec4( 0)));\n    vec4 p31EnterExit = saturate( p31Step.xyxy + vec4( -0.5f, -0.5f, 0.5f, 0.5f) * abs( p31Step.zwzw));\n    float p31LatestEnter = max( p31EnterExit.x, p31EnterExit.y);\n    float p31EarliestExit = min( p31EnterExit.z, p31EnterExit.w);\n\n    // Calculate world positions of those crossing points, separated for X and Y\n    vec4 enterExitF123 = vec4( p12LatestEnter, p12EarliestExit, p23LatestEnter, p23EarliestExit);\n    vec2 enterExitF31 = vec2( p31LatestEnter, p31EarliestExit); \n    vec4 posX123 = vec4( p1.xx, p2.xx) + enterExitF123 * vec4( d12.xx, d23.xx);\n    vec4 posY123 = vec4( p1.yy, p2.yy) + enterExitF123 * vec4( d12.yy, d23.yy);\n    vec4 posXY31 = p3.xyxy + enterExitF31.xxyy * d31.xyxy;\n    \n    // limit everything to the pixel area\n    posX123 = max( rectMin.xxxx, min( rectMax.xxxx, posX123));\n    posY123 = max( rectMin.yyyy, min( rectMax.yyyy, posY123));\n    posXY31 = max( rectMin.xyxy, min( rectMax.xyxy, posXY31));\n\n    float t = fract( iTime);\n    debugColour = \n          vec4( 1, 0, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.x, posY123.x), vec2( posX123.y, posY123.y), t)))\n        + vec4( 1, 1, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.y, posY123.y), vec2( posX123.z, posY123.z), t)))\n        + vec4( 0, 1, 0, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.z, posY123.z), vec2( posX123.w, posY123.w), t)))\n        + vec4( 0, 1, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( vec2( posX123.w, posY123.w), posXY31.xy, t)))\n        + vec4( 0, 0, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( posXY31.xy, posXY31.zw, t)))\n        + vec4( 1, 0, 1, 1) * saturate( 1.0f - 0.3f * length( fragCoord - mix( posXY31.zw, vec2( posX123.x, posY123.x), t)));\n    \n    if( rectMin.x != 416.0f || rectMin.y != 192.0f ) \n        debugColour = vec4( 0);\n    \n    posY123 -= rectMin.yyyy; \n    posXY31.yw -= rectMin.yy;\n    \n\t// determine difference of every value to the following value at the triangle's edges\n    vec4 stepX123 = vec4( posX123.yzw, posXY31.x) - posX123.xyzw;\n    vec4 stepY123 = vec4( posY123.yzw, posXY31.y) - posY123.xyzw;\n    vec4 stepXY31 = vec4( posXY31.zw, posX123.x, posY123.x) - posXY31.xyzw;        \n    \n    // calculate area below these edges: quad + diagonal part. Quad part is signed with xstep, diagonal is signed with both X and Y\n    // The segments from ExitCurrent to EntryNext are not allowed to go diagonal. They either need to be ramped up to full quad\n    // or reduced to zero depending on direction of that segment\n    vec3 cornerClipSegCorrection = mix( vec3( 1.0f), vec3( 0.0f), lessThan( vec3( stepX123.yw, stepXY31.z) * vec3( stepY123.yw, stepXY31.w), vec3( 0.0f)));\n    vec4 segArea123 = stepX123 * posY123 + vec4( 0.5f, cornerClipSegCorrection.x, 0.5f, cornerClipSegCorrection.y) * stepX123 * stepY123;\n    vec2 segArea31 = stepXY31.xz * posXY31.yw + vec2( 0.5f, cornerClipSegCorrection.z) * stepXY31.xz * stepXY31.yw;\n    \n\tfloat summedArea = dot( segArea123, vec4( 1, 1, 1, 1)) + dot( segArea31, vec2( 1, 1));\n    float coverage = summedArea / (rectCenterSize.z * rectCenterSize.w);\n    \n    return saturate( coverage);\n}\n\nfloat drawTriangle( in vec2 fragCoord, in vec2 pa, in vec2 pb, in vec2 pc)\n{\n    vec2 papb = pb - pa, papc = pc - pa;\n    vec2 pafr = fragCoord - pa;\n    \n    float den = papb.x * papc.y - papc.x * papb.y;\n    float t1 = (pafr.x * papc.y - papc.x * pafr.y) / den;\n    float t2 = (papb.x * pafr.y - pafr.x * papb.y) / den;    \n    return t1 >= 0.0f && t2 >= 0.0f && (t1 + t2) < 1.0f ? 1.0f : 0.0f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // construct an edge from some point at the left and some angle\n    vec2 pa = vec2( iMouse.x, iMouse.y);\n    float angleToPb = 8.0f * (iMouse.x / iResolution.x - 0.5f);\n    vec2 dirToPb = vec2( cos( angleToPb), -sin( angleToPb));\n    vec2 pb = pa + 0.4f * iResolution.x * dirToPb;\n\n    float angleToPc = angleToPb + 0.4f;\n    vec2 dirToPc = vec2( cos( angleToPc), -sin( angleToPc));\n    vec2 pc = pa + 0.5f * iResolution.x * dirToPc;\n    \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    \n    vec4 debugColour = vec4( 0.0f);\n    float tri = triangleIntegral( pa, pb, pc, rectMin, rectMax, fragCoord, debugColour);\n    \n    float groundTruth = drawTriangle( fragCoord, pa, pb, pc);\n    vec3 resColour = \n          saturate( tri * vec3( 1, 1, 1))\n//        + saturate( (tri > 0.0f ? 0.2f : 0.0f) * vec3( 1, 0, 0))\n        ;\n    resColour = mix( resColour, vec3( 0, 0, 1), 0.3f * groundTruth);\n    \n    resColour = resColour + debugColour.xyz;\n    fragColor = vec4( resColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlByWc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 57, 57, 93], [94, 94, 118, 118, 162], [163, 163, 187, 187, 231], [232, 232, 256, 256, 300], [302, 302, 420, 420, 4942], [4944, 4944, 5020, 5020, 5342], [5344, 5344, 5400, 5468, 6526]], "test": "untested"}
{"id": "wtByD3", "name": "Gram-Schmidt orthonormalization ", "author": "jeyko", "description": "This is a demonstration of the Gram-Schmidt orthonormalization process.", "tags": ["linear", "maths", "orthonormal", "method"], "likes": 19, "viewed": 685, "published": 3, "date": "1595518944", "time_retrieved": "2024-07-30T20:54:19.327566", "image_code": "// This is a demonstration of the Gram-Schmidt orthonormalization process.\n// Feel free to just copy and use the gramSchmidt() function.\n\n// The purple vectors are the input, and the green ones are the output. \n\n// If you would like to play around with the positions and stuff - they are in the demoGramSchmidt() function.\n\n// Thanks to IQ for triangle and line intersections.\n\nvec3 project(vec3 a, vec3 b){\n\treturn dot(a,b)/dot(b,b)*(b);\n}\n\nvoid gramSchmidt(vec3 A, vec3 B, vec3 C, out vec3 Ao, out vec3 Bo, out vec3 Co ){\n    Ao = A;\n    \n    Bo = B - project(B,A);\n    \n    Co = C - project(C,Bo) - project(C,Ao);\n    \n    Ao = normalize(Ao);\n    Bo = normalize(Bo);\n    Co = normalize(Co);\n}\n\n\n\nvec3 ro, rd, N, glow = vec3(0);\nvec2 d;\nbool assertion = true;\n\nvec4[7] materials = vec4[](\n\tvec4(0.6,1.,0.4,1.),\n\tvec4(0.,.0,0.,1.),      // background\n\tvec4(0.1,0.2,0.4,0.9),  // guidelines\n\tvec4(0.,0.4,0.7,1.),    // diff A\n\tvec4(0.4,0.,0.2,0.8),\n\tvec4(0.,1.,0.,0.6),\n\tvec4(0.5,0.,1.,1.)   \t// diff B\n);\n\nvoid assert(bool);\nvec2 dmin(vec2 , float , vec4 );\nvec2 dmax(vec2 , float , vec4 );\n\n\n\nvoid demoGramSchmidt(vec3 ro, vec3 rd){\n\t\n    vec3 A = vec3(-0.4,0.6,-0.4);\n    vec3 B = vec3(-0.7,0.3,0.1);\n    vec3 C = vec3(-0.4,-0.2,-0.7);\n    \n    \n    A = normalize(A)*0.5;\n    B = normalize(B)*0.5;\n    C = normalize(C)*0.5;\n    \n    \n    float t = iTime*0.5; \n    B += vec3(sin(t),cos(t),sin(t))*0.2;\n    C += vec3(cos(t),sin(t),sin(t))*0.2;\n    A.xz *= rot(sin(t)*0.2);\n    \n    vec3 Ao, Bo, Co;\n    \n\tgramSchmidt( A, B, C, Ao, Bo, Co );\n\t\n    assert(abs(dot(Ao,Bo)) < 0.001);\n    assert(abs(dot(Co,Bo)) < 0.001);\n    assert(abs(dot(Bo,Co)) < 0.001);\n    assert(abs(dot(Ao,Co)) < 0.001);\n    \n    \n    float r = 0.02;\n    \n    vec4 sphere = intersectSphere(ro, rd, r,1.);\n    \n    d = dmin(d,3.,sphere);\n    \n    d = dmin(d,6.,intersectSphere(ro - A, rd, r,1.));\n    d = dmin(d,6.,intersectSphere(ro - B, rd, r,1.));\n    d = dmin(d,6.,intersectSphere(ro - C, rd, r,1.));\n    \n    d = dmin(d,5.,intersectSphere(ro - Ao, rd, r,1.));\n    d = dmin(d,5.,intersectSphere(ro - Bo, rd, r,1.));\n    d = dmin(d,5.,intersectSphere(ro - Co, rd, r,1.));\n    \n    \n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),A, r*0.3));\n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),B, r*0.3));\n    d = dmin(d,6.,intersectLine( ro, rd,vec3(0),C, r*0.3));\n    \n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Ao, r*0.5));\n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Bo, r*0.5));\n    d = dmin(d,5.,intersectLine( ro, rd,vec3(0),Co, r*0.5));\n    \n    d = dmin(d,4.,intersectTri( ro, rd, Bo, vec3(0), Ao ));\n    d = dmin(d,4.,intersectTri( ro, rd, Co, vec3(0), Ao ));\n    d = dmin(d,4.,intersectTri( ro, rd, Co, vec3(0), Bo ));\n}\n\n\n\n\nvec3 shade( float id, float d, vec3 n){\n\tvec3 col = vec3(0);\n\t\n    vec4 m = materials[int(id)];\n    \n    vec3 p = ro + rd*d;\n    \n    if( id == 2.){\n    \t\n        float ld = 10e4;\n        \n        vec3 q = p;\n        \n        q = pmod(q,0.5);\n\t\t\n        float eps = 0.01;\n       \tif(abs(p.y) < eps){\n            ld = min(ld,abs(q.x));\n            ld = min(ld,abs(q.z));\n        } else if(abs(p.x) < eps){ \n            ld = min(ld,abs(q.y));\n            ld = min(ld,abs(q.z));\n        } else if(abs(p.z) < eps){ \n            ld = min(ld,abs(q.y));\n            ld = min(ld,abs(q.x));\n        }\n        \n        \n        col = mix(col,vec3(0.2),smoothstep(0.01,0.,ld ));\n        \n        \n        col *= smoothstep(1.,0.,d*0.16);\n        \n    } else {\n    \tvec3 l = normalize(vec3(1,0.25,-1.));\n\n        vec3 lcol = vec3(1,0.8,0.3);\n\n        col = m.xyz + n*0.2;\n\n        float diff = sin( dot(n,l) );\n        diff += mix(length(asin(sin(n*1.)*.9)*0.5+0.5)/sqrt(3.),0.,.0)*0.1; // um ok blackle thx, I have no clue what this is tho lol\n        float fres = pow(max( 1. - dot(n,-rd), 0.001), 5.);  \n\n        vec3 r = reflect(rd,n);\n\n        float spec1 = length(asin(sin(r*4.)*.9)*0.5+0.5)/sqrt(3.);\n\n        \n        vec3 hsv = rgb2hsv(col);\n\n        vec3 darkened = hsv2rgb(vec3(hsv.x,hsv.y*2.,hsv.z*0.6));\n\n        col += spec1*0.7*lcol;\n        col = mix(col,darkened,1.-diff);;\n\t\tcol = max(col,0.);\n        col *= m.w;\n    }\n    \n    \n    return col;\n}\n\n\n\n\n\nvec3 get( vec2 U ){\n\t\n    glow -= glow;\n    vec2 uv = (U - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    d = vec2(10e4);\n    \n    ro = vec3(0);\n    \n    float xz = sin(T*0.4)*0.4 - iMouse.x/iResolution.x*2. + 5. ;\n    float y = sin(iTime)*0.25 + iMouse.y/iResolution.x*4. + 0.4;\n    ro.xz += vec2(sin(xz), cos(xz))*3.;\n    ro.y += y + 1.;\n    \n    ro *= 0.7;\n    \n    vec3 lookAt = vec3(0);\n    \n    rd = getRd(ro, lookAt, uv);\n    \n    \n    \n    float pipew = 0.01;\n\t\n    // background\n    d = dmin(d,1.,intersectSphere(ro, rd, 25.2,0.)); \n\n    \n    // guidelines\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(0,0,-6),vec3(0,0,1150), pipew));\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(-6,0,0),vec3(1150,0,0), pipew));\n    d = dmin(d,3.,intersectLine( ro, rd,vec3(0,-10,0),vec3(0,150,0), pipew));\n    \n    // guideplanes\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(0.,-1,0.)));\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(1.,0.,0.)));\n    d = dmin(d,2.,intersectPlane(ro, rd, vec3(0.,0,1.)));\n    \n    \n\n\tdemoGramSchmidt( ro, rd);\n    \t \n    \n    vec3 p = ro + rd*d.x;\n    \n   \n    col += shade( d.y, d.x, N);\n    \n    \n    col += glow;\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    vec2 uv = (U - 0.5*R)/R.y;\n    vec3 col = vec3(0);\n    for(float i =0.; i < AA*AA + min(float(iFrame),0.)   ; i++){\n    \tcol += get(U + vec2(mod(i,AA),floor(i/AA))/AA - .5);\n    }\n    col /= AA*AA;\n    \n    \n    if(!assertion){\n        col = mix(col,vec3(1,0.,0),smoothstep(dFdy(uv.y),0.,sdBox(uv - 0.5,vec2(0.1))));\n    }\n    \n    col = max(col, 0.);\n    C.xyz = pow(col.xyz,vec3(0.454545));\n        \n    C = vec4(col,1.0);\n}\n\n\nvec2 dmin(vec2 a, float id, vec4 b ){\n\tvec4 m = materials[int(id)];\n    if (a.x < b.x ||  b.x == NO_INTERSECTION){\n    \treturn a;\n    } else if (  m.w < 1. ){\n\t\tglow += shade(id,b.x,b.yzw);\n        return a;\n    } else {\n        N = b.yzw;\n        return vec2(b.x,id);\n    }\n    \n}\nvoid assert(bool thing){\n\tif(!thing)\n        assertion = false;\n}\n", "image_inputs": [], "common_code": "\n#define R iResolution.xy\n#define T iTime\n#define AA 4.\n#define NO_INTERSECTION -1.\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pmod(p,j) mod(p - 0.5*j, j) - 0.5*j\n\n// _________________________________________ //\n\nvec3 solveQuadratic(float a, float b, float c);\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n);\nvec4 intersectLine( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra );\nvec2 intersectCylinder( vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr );\nvec4 intersectSphere(vec3 ro, vec3 rd, float r, float first);\nvec4 intersectTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 );\n\nfloat sdBox(vec2 p, vec2 s);\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv);\n\nvec3 hsv2rgb( in vec3 c );\nvec3 rgb2hsv( in vec3 c);\n\n// _________________________________________ //\n\n\nvec4 intersectPlane(vec3 ro, vec3 rd, vec3 n){\n    n = normalize(n);\n    //dot(n, ro + rd*t) = 0;\n    //(ro.x + rd.x*t)*n.x + (ro.y + rd.y*t)*n.y + (ro.z + rd.z*t)*n.z = 0\n    //ro.x*n.x + rd.x*t*n.x + ro.y*n.y + rd.y*t*n.y + ro.z*n.z + rd.z*t*n.z = 0\n    // t  = - (ro.x*n.x +  ro.y*n.y  + ro.z*n.z)/( rd.x*n.x + rd.y*n.y + rd.z*n.z ) \n    //return vec4(-(dot(ro,n))/dot(rd,n), n);\n    \n    float dron = dot(ro, n); \n    if(dron > 0.){\n    \tro -= n * dron*2.;\n    \trd = -rd;\n    }\n    \n    float nominator = dot(ro,n); \n        \n    float denominator = dot(rd,n);\n        \n    if (denominator > 1e-9) { \n        return vec4( -nominator / denominator, n); \n    \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\n\nvec3 solveQuadratic(float a, float b, float c){\n\t// returns vec3(xa,xb,solutions)\n\t\n    float disc = b*b - 4.*a*c;\n\n    float xa = (-b + sqrt(disc)) / (2. * a);\n\n    float xb = (-b - sqrt(disc)) / (2. * a);\n\n    if(disc >= 0.){\n        return vec3(xa,xb,2);\n    } else {\n        return vec3(0);\n    }    \n}\n\nvec4 intersectLine( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, float ra )\n{\n    vec3 ca = pb-pa;\n    vec3 oc = ro-pa;\n    float caca = dot(ca,ca);\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = caca - card*card;\n    float b = caca*dot( oc, rd) - caoc*card;\n    float c = caca*dot( oc, oc) - caoc*caoc - ra*ra*caca;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(NO_INTERSECTION); //no intersection\n    h = sqrt(h);\n    float t = (-b-h)/a;\n    // body\n    float y = caoc + t*card;\n    if( y>0.0 && y<caca ) return vec4( t, (oc+t*rd-ca*y/caca)/ra );\n    // caps\n    t = (((y<0.0)?0.0:caca) - caoc)/card;\n    if( abs(b+a*t)<h ) return vec4( t, ca*sign(y)/caca );\n    return vec4(NO_INTERSECTION); //no intersection\n}\n\nvec2 intersectCylinder( vec3 ro, vec3 rd, vec3 cb, vec3 ca, float cr )\n{\n    vec3  oc = ro - cb;\n    float card = dot(ca,rd);\n    float caoc = dot(ca,oc);\n    float a = 1.0 - card*card;\n    float b = dot( oc, rd) - caoc*card;\n    float c = dot( oc, oc) - caoc*caoc - cr*cr;\n    float h = b*b - a*c;\n    if( h<0. ) return vec2(NO_INTERSECTION); //no intersection\n    h = sqrt(h);\n    return vec2(-b-h,-b+h)/a;\n}\n\n\nvec4 intersectSphere(vec3 ro, vec3 rd, float r, float first){\n\t// x^2 + y^2 = r\n    \n    // (ro.x + rd.x*w)^2 + (ro.y + rd.y*w)^2 + (ro.z + rd.z*w)^2 = r  \n    // F = ro.x\n    // G = ro.y\n    // H = ro.z\n    // F*F + 2*F*rd.x*w + (rd.x*w)^2 + G*G + 2*G*rd.y*w + (rd.y*w)^2 = r  \n    // w^2(rd.x^2 + rd.y^2 + rd.z^2 ) + w(2*F*rd.x + 2*G*rd.y + 2*H*rd.z) + (F*F + G*G + H*H - r) = 0\n\n    \n    float F = ro.x;\n    float G = ro.y;\n    float H = ro.z;\n    \n    float a = rd.x*rd.x + rd.y*rd.y + rd.z*rd.z;\n    float b = 2.*F*rd.x + 2.*G*rd.y + 2.*H*rd.z;\n    float c = F*F + G*G + H*H - r*r;\n    \n    \n    vec3 Q = solveQuadratic(a, b, c);\n    \n    vec3 p;\n    \n    \n    float d; \n    \n    if( length(ro) < r){\n        d = Q.x;\n    } else {\n        d = min(Q.x,Q.y);\n    }\n    vec3 n = normalize( (ro + rd*d) );\n    \n    if(Q.z > 0.){\n\t\t\n        return vec4( d , n );\n        \n    } else {\n    \treturn vec4(NO_INTERSECTION);\n    }\n}\n\nvec4 intersectTri( in vec3 ro, in vec3 rd, in vec3 v0, in vec3 v1, in vec3 v2 )\n{\n    vec3 v1v0 = v1 - v0;\n    vec3 v2v0 = v2 - v0;\n    vec3 rov0 = ro - v0;\n    vec3  n = cross( v1v0, v2v0 );\n    vec3  q = cross( rov0, rd );\n    float d = 1.0/dot( rd, n );\n    float u = d*dot( -q, v2v0 );\n    float v = d*dot(  q, v1v0 );\n    float t = d*dot( -n, rov0 );\n    if( u<0.0 || u>1.0 || v<0.0 || (u+v)>1.0 ) t = NO_INTERSECTION;\n    \n    vec3 normal = normalize(cross(v0 - v1, v2 - v1));\n    return vec4( t, normal );\n}\n\n\nfloat sdBox(vec2 p, vec2 s){\n\tp = abs(p) - s;\n    return max(p.x,p.y);  \n}\n\n\nvec3 getRd(vec3 ro, vec3 lookAt, vec2 uv){\n\tvec3 dir = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0,1,0),dir));\n    vec3 up = normalize(cross(dir, right));\n\treturn normalize(dir + right*uv.x + up*uv.y);\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 rgb2hsv( in vec3 c)\n{\n    float eps = 0.01;\n    vec4 k = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);\n    vec4 p = mix(vec4(c.zy, k.wz), vec4(c.yz, k.xy), (c.z<c.y) ? 1.0 : 0.0);\n    vec4 q = mix(vec4(p.xyw, c.x), vec4(c.x, p.yzx), (p.x<c.x) ? 1.0 : 0.0);\n    float d = q.x - min(q.w, q.y);\n    return vec3(abs(q.z + (q.w - q.y) / (6.0*d+eps)), d / (q.x+eps), q.x);\n}\n\n    \n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 378, 407, 407, 440], [442, 442, 523, 523, 695], [1095, 1095, 1134, 1134, 2709], [2714, 2714, 2753, 2753, 4167], [4173, 4173, 4192, 4192, 5366], [5369, 5369, 5410, 5410, 5841], [5844, 5844, 5881, 5881, 6125], [6126, 6126, 6150, 6150, 6191]], "test": "untested"}
{"id": "3tScDc", "name": "Truchet Waves", "author": "dr2", "description": "Based on \"Cookie Waves\" but with Truchet-like tiles (color scheme  from \"Hexagonal Truchet Flow\")", "tags": ["wave", "hexagon", "truchet"], "likes": 7, "viewed": 365, "published": 3, "date": "1595494241", "time_retrieved": "2024-07-30T20:54:20.162334", "image_code": "// \"Truchet Waves\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0    // optional antialiasing\n\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat HexEdgeDist (vec2 p);\nfloat Minv3 (vec3 p);\nfloat SmoothMin (float a, float b, float r);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\n\nmat3 flMat;\nvec3 ltDir, flPos;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, wavHt, cDir, trWidf, trHt;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, w;\n  vec2 s, r;\n  float dMin, d, h, b;\n  dMin = dstFar;\n  p.xz -= cMid;\n  q = p;\n  q.xz = Rot2D (q.xz, 2. * pi * (floor (6. * atan (q.z, - q.x) / (2. * pi) + 0.5)) / 6.);\n  d = abs (q.x) - 0.86 * hgSize;\n  r = p.xz / hgSize;\n  s = vec2 (0., - cDir);\n  b = dot (s - r, s - r);\n  w = vec3 (s, b);\n  s = 0.5 * vec2 (sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  s = 0.5 * vec2 (- sqrt3, cDir);\n  b = dot (s - r, s - r);\n  if (b < w.z) w = vec3 (s, b);\n  h = - trHt * smoothstep (0.5 * trWidf, trWidf, abs (sqrt (w.z) - 0.5));\n  d = max (d, abs (q.y - wavHt + h) - 0.15 + h);\n  DMIN (1);\n  q = p;\n  q.y -= wavHt - 2.;\n  d = PrCylDf (q.xzy, 0.5, 2.);\n  DMIN (2);\n  return 0.8 * dMin;\n}\n\nvoid SetTrConf ()\n{\n  vec2 u;\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n  u = mod (0.1 * vec2 (cMid.x + cMid.y, cMid.x - cMid.y) * (1. + 0.3 * sin (0.2 * 2. * pi * cMid)) +\n    0.1 * tCur, 1.) - 0.5;\n  wavHt = 0.4 * dot (exp (-100. * u * u), vec2 (1.));\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = 0; j < 160; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0005, -0.0005);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = 0; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += 0.05;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 TruchCol (vec2 p)\n{\n  vec3 col, w;\n  vec2 s;\n  float a, d, b;\n  p -= cMid;\n  p /= hgSize;\n  s = vec2 (0., - cDir);\n  b = dot (s - p, s - p);\n  w = vec3 (s, b);\n  s = 0.5 * vec2 (sqrt3, cDir);\n  b = dot (s - p, s - p);\n  if (b < w.z) w = vec3 (s, b);\n  s = 0.5 * vec2 (- sqrt3, cDir);\n  b = dot (s - p, s - p);\n  if (b < w.z) w = vec3 (s, b);\n  w.z = abs (sqrt (w.z) - 0.5);\n  d = HexEdgeDist (p);\n  col = vec3 (0.5, 0.5, 1.) * mix (1., 0.7 + 0.3 * smoothstep (0.2, 0.8, d), smoothstep (0.02, 0.03, d));\n  if (w.z < trWidf) {\n    col = vec3 (1., 1., 0.);\n    w.xy = Rot2D (w.xy - p, 0.5 * cDir * tCur);\n    a = mod (3. * atan (cDir * w.y, - w.x) / pi, 1.) - 0.5;\n    for (float s = 0.01; s >= 0.; s -= 0.01) {\n      d = 1.;\n      if (abs (a) - 0.15 < s) d = min (d, smoothstep (0., 0.005,\n         w.z - 0.045 * (1. - a / 0.15) - 0.5 * s));\n      if (abs (a + 0.3) - 0.15 < s) d = min (d, smoothstep (0., 0.005, w.z - 0.02 - s));\n      if (abs (mod (2. * a + 0.5, 1.) - 0.5) - 0.4 < s)\n         d = min (d, smoothstep (0., 0.005, abs (w.z - 0.135) - 0.01 - s));\n      col = mix (vec3 (0., 1. - 70. * s, 0.), col, d);\n    }\n  }\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  float dstObj, sh;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = (vn.y > 0.01) ? vec4 (TruchCol (ro.xz), 0.1) :\n         vec4 (0.8, 0.8, 0.9, 0.3) * (0.8 + 0.2 * cos (18. * pi * (ro.y - wavHt)));\n    } else if (idObj == 2) {\n      col4 = vec4 (0.3, 0.3, 0.4, 0.1);\n    }\n    sh = ObjSShadow (ro, ltDir);\n    col = col4.rgb * (0.2 + 0.8 * sh * max (dot (vn, ltDir), 0.)) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n  } else col = vec3 (0.3, 0.3, 0.3);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return t * vec3 (0.1, 0., sqrt (0.99)) + vec3 (2. * cos (0.1 * t), 0., 0.);\n}\n\nvoid VuPM (float t)\n{\n  vec3 fpF, fpB, vel, acc, va, ort, cr, sr;\n  float dt;\n  dt = 1.;\n  flPos = TrackPath (t);\n  fpF = TrackPath (t + dt);\n  fpB = TrackPath (t - dt);\n  vel = (fpF - fpB) / (2. * dt);\n  vel.y = 0.;\n  acc = (fpF - 2. * flPos + fpB) / (dt * dt);\n  acc.y = 0.;\n  va = cross (acc, vel) / length (vel);\n  ort = vec3 (0.2, atan (vel.z, vel.x) - 0.5 * pi, 5. * length (va) * sign (va.y));\n  cr = cos (ort);\n  sr = sin (ort);\n  flMat = mat3 (cr.z, - sr.z, 0., sr.z, cr.z, 0., 0., 0., 1.) *\n     mat3 (1., 0., 0., 0., cr.x, - sr.x, 0., sr.x, cr.x) *\n     mat3 (cr.y, 0., - sr.y, 0., 1., 0., sr.y, 0., cr.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 dateCur;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.) + 11.1;\n  hgSize = 2.;\n  trWidf = 0.3;\n  trHt = 0.07;\n  VuPM (1. * tCur);\n  az = 0.;\n  el = -0.1 * pi;\n  vuMat = StdVuMat (el, az);\n  flPos.y += 10.;\n  ro = flPos;\n  zmFac = 6. + 3. * sin (0.02 * 2. * pi * tCur);\n  dstFar = 100.;\n  ltDir = normalize (vec3 (1., 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * rd;\n    rd = rd * flMat;\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat HexEdgeDist (vec2 p)\n{\n  p = abs (p);\n  return (sqrt3/2.) - p.x + 0.5 * min (p.x - sqrt3 * p.y, 0.);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScDc.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[660, 660, 682, 682, 1401], [1403, 1403, 1422, 1422, 1696], [1698, 1698, 1731, 1731, 2999], [3001, 3001, 3022, 3022, 3272], [3274, 3274, 3311, 3311, 3718], [3720, 3720, 3744, 3744, 4866], [4868, 4868, 4903, 4903, 5549], [5551, 5551, 5577, 5577, 5657], [5659, 5659, 5680, 5680, 6278], [6280, 6280, 6336, 6336, 7366], [7368, 7368, 7410, 7410, 7461], [7463, 7463, 7487, 7487, 7717], [7719, 7719, 7743, 7743, 7803], [7805, 7805, 7833, 7833, 7913], [7915, 7915, 7937, 7937, 7975], [7977, 7977, 8022, 8022, 8125], [8127, 8127, 8163, 8163, 8369], [8371, 8371, 8401, 8401, 8514], [8548, 8548, 8572, 8572, 8632]], "test": "untested"}
{"id": "WtjyWV", "name": "Niantic Airship", "author": "emmasteimann", "description": "Niantic Airship, with Balloon Pikachu and Harry Potter flying as escorts through the clouds.", "tags": ["pikachu", "niantic", "airship", "harrypotter"], "likes": 17, "viewed": 529, "published": 3, "date": "1595487533", "time_retrieved": "2024-07-30T20:54:21.182606", "image_code": "vec2 witch(vec3 pos) {\n    vec3 pr1 = pos;\n    pr1 = tX(pr1, vec3(0,0,0));\n    float pointy = sdCone(pr1, vec2(0.5, 0.2), 0.15);\n    \n    pr1 = tX(pr1, vec3(0,-0.15,0));\n    float cappypart = sdCappedCylinder(pr1,vec2(0.2, 0.01));    \n    pointy = min(pointy,cappypart);\n    \n    pr1 = tX(pr1, vec3(0,-0.05,0));\n    float head = sdSphere(pr1, .1);\n    pointy = min(pointy,head);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.05);\n    pr1 = tX(pr1, vec3(0,-0.5,0));\n    float body = sdRoundCone(pr1, 0.14,0.05, 0.2);\n    pointy = min(pointy,body);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0,-0.55,0.1));\n    pr1.yz = rX(pr1.yz,-0.5);\n    float broom = sdCappedCylinder(pr1,vec2(0.02, 0.4));    \n    pointy = min(pointy,broom);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.05,-0.5,.05));\n    pr1.yz = rX(pr1.yz,0.25);\n    pr1.xy = rX(pr1.xy,0.075);\n    float arm = sdCappedCylinder(pr1,vec2(0.02, 0.125));\n   \tpointy = min(pointy,arm);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.05,-0.6,-.15));\n    pr1.yz = rX(pr1.yz,-0.35);\n    pr1.xy = rX(pr1.xy,0.075);\n    float leg = sdCappedCylinder(pr1,vec2(0.02, 0.125));\n   \tpointy = min(pointy,leg);\n    \n    vec2 witchBody = vec2(pointy*.5, 7.0);\n    \n    pr1 = pos;\n    pr1.xz *= .5;\n    pr1 = tX(pr1, vec3(0,-0.55,-.25));\n    pr1.yz = rX(pr1.yz,-0.5);\n    float sweep = sdRoundCone(pr1, 0.075,0.05, 0.05);\n    pointy = min(pointy,sweep);\n    add(witchBody, vec2(sweep*.5, 8.0));\n    return witchBody;\n}\n\nvec2 balloonPika(vec3 pos) {\n    vec3 pr1 = tX(pos, vec3(0,0,-.1));\n    pr1.yz = rX(pr1.yz, -0.5);\n    vec2 body = vec2(sdRoundCone(pr1, 0.125,0.075, 0.2)*.5, 10.0);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.1,0,0.1));\n    pr1.xz = rX(pr1.xz, -0.25);\n    vec2 arm = vec2(sdEllipsoid(pr1,vec3(.15,.05,.055))*.5, 10.0);\n    add(body, arm);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0,0.06,.17));\n    vec2 head = vec2(sdSphere(pr1, .11)*.5, 10.0);\n    add(body,head);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.1,0,-0.15));\n    pr1.xz = rX(pr1.xz, 0.4);\n    vec2 leg = vec2(sdEllipsoid(pr1,vec3(.15,.05,.065))*.5, 10.0);\n    add(body, leg);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n  \tpr1 = tX(pr1, vec3(.05,0.15,0.2));\n    pr1.xy = rX(pr1.xy, 0.6);\n    pr1.xz = rX(pr1.xz, 0.15);\n    vec2 ears = vec2(sdEllipsoid(pr1,vec3(.15,.025,.025))*.5, 11.0);\n    add(body, ears);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(.0,0.18,-0.175));\n    pr1.xz = rX(pr1.xz, 0.5);\n    pr1.xy = rX(pr1.xy, 0.15);\n    float tail = sdHexPrism(pr1, vec2(.1,.015));\n    float tailRm = sdHexPrism(tX(pr1, vec3(.1,0.,-0.)), vec2(.11,.03));\n    diff(tail, tailRm);\n    vec2 tailPiece = vec2(tail*.5, 10.);\n    add(body,tailPiece);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\n    pr1.z = abs(pr1.z);\n    pr1.xy = rX(pr1.xy, 0.075+.02*abs(cos(iTime*.5)));\n    pr1.yz = rX(pr1.yz, -0.1+.02*abs(sin(iTime*.3)));\n    pr1 = tX(pr1, vec3(0,0.3,0.0));\n    vec2 string = vec2(sdCappedCylinder(pr1,vec2(0.005, 0.2))*.5, 6.);    \n    add(body,string);\n    \n    pr1 = tX(pr1, vec3(0,0.1,0.));\n    vec2 exit = vec2(sdCone(pr1, vec2(0.5, 0.15), 0.1)*.5, 12.);\n    add(body,exit);\n    \n    vec2 balloom = vec2(sdRoundCone(pr1, 0.05,0.095, 0.05)*.5, 12.);\n    add(body,balloom);\n    \n\treturn body; \n}\n\n// Thank you @blackle for the balloon seed!!\nfloat hotair(vec3 p) {\n  p.z -= .4;\n  float ht = length(p)-.8;\n  float dimpl = linedist(p, vec3(0,0,0), vec3(0,0,-0.95))-.18;\n  float hollow = linedist(p, vec3(0), vec3(0,0,-1.2))-.18;\n  p.xy = abs(p.xy);\n  float lines = linedist(p, vec3(0.1,0.1,-.5), vec3(.1,.1,-1.3))-.01;\n  return -smin(-smin(ht, dimpl, 0.3),hollow,.01);\n}\n\nvec2 balloon(vec3 pos) {\n    float offsetTwist = 3.1459*2.;\n    \n    pos.xy = rX(pos.xy, -.2);\n    vec3 pA = tX(pos, vec3(0,0.02,.5));\n    vec2 ring1 = vec2(sdTorus(erot(pA,vec3(1,0,0),1.), vec2(1.2,0.05)), 2.0);\n    \n    vec3 pB = tX(pos, vec3(0,-0.01,.4));\n    vec2 ring2 = vec2(sdTorus(erot(pB,vec3(1,0,0),-1.65), vec2(1.1,0.05)), 2.0);\n    pos.xy = rX(pos.xy, .2);\n    pos.xy = rX(pos.xy, offsetTwist);\n    vec3 pC = tX(pos, vec3(0,-0.0,.4));\n    vec2 ropeTop1 = vec2(sdTorus(erot(pC,vec3(0,0,1),-0.), vec2(0.825,0.03)), 2.0);\n    vec2 ropeSlice = vec2(sdPlane(tX(pos,vec3(0,0.,-0.10)), normalize(vec4(0,0,1,0))), 4.0);\n    diff(ropeTop1, ropeSlice);\n    \n    vec3 pD = tX(pos, vec3(0,-0.0,.4));\n    vec2 ropeTop2 = vec2(sdTorus(erot(pD,vec3(0,0,1),1.5708), vec2(0.825,0.03)), 2.0);\n    ropeSlice = vec2(sdPlane(tX(pos,vec3(0,0.,-0.10)), normalize(vec4(0,0,1,0))), 4.0);\n    diff(ropeTop2, ropeSlice);\n    \n    //vec2 hA = vec2(99999.0, 2.0);\n    vec2 hA = vec2(hotair(pos), 3.0);\n    \n    vec3 pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.4,-0.9,-0.));\n    pr1.xy = rX(pr1.xy, 0.1);\n    vec2 rope = vec2(sdCappedCylinder(pr1, vec2(0.03,0.9)), 2.0);\n    add(hA, rope);\n   \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1.xz = rX(pr1.xz,-0.5);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.4,-0.9,-0.));\n    pr1.xy = rX(pr1.xy, 0.1);\n    rope = vec2(sdCappedCylinder(pr1, vec2(0.03,0.9)), 2.0);\n    add(hA, rope);\n\n    add(hA, ring1);\n    add(hA, ring2);\n    \n    add(hA, ropeTop1);\n    add(hA, ropeTop2);\n    \n    // reset\n    pos.xy = rX(pos.xy, -offsetTwist);\n    \n \tpr1 = pos;\t\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.0,-1.75,-.1));\n    vec2 bigSail = vec2(onion(sdEllipsoid(pr1, vec3(0.25,0.5,0.6)), 0.015), 4.0);\n\tvec2 sliced = vec2(sdPlane(tX(pos,vec3(0,0.,-1.4)), normalize(vec4(0,-1,0.2,0))), 2.0);\n    diff(bigSail, sliced);\n    sliced = vec2(sdPlane(tX(pos,vec3(0,-0.1,-1.8)), normalize(vec4(0,.2,1,0))), 2.0);\n    diff(bigSail, sliced);\n    add(hA, bigSail);\n    \n    pr1 = pos;\n    pr1.x = abs(pr1.x);\t\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.2,-1.7,-0.3));\n    vec2 smallSail = vec2(onion(sdEllipsoid(pr1, vec3(0.15,0.3,0.3)), 0.015), 4.0);\n\tsliced = vec2(sdPlane(tX(pr1,vec3(0,0.,-0.0)), normalize(vec4(0,1,0.1,0))), 2.0);\n    diff(smallSail, sliced);\n    sliced = vec2(sdPlane(pr1, normalize(vec4(0,0.1,1,0))), 2.0);\n    diff(smallSail, sliced);\n    add(hA, smallSail);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.5);\n    pr1 = tX(pr1, vec3(0.0,-2.,-0.25));\n    vec2 backThing = vec2(sdRoundCone(pr1, 0.125, 0.275, 0.2), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.2,-0.0)), normalize(vec4(0,-1,-.2,0))), 2.0);\n    diff(backThing, sliced);\n    sliced = vec2(sdPlane(pr1, normalize(vec4(0,0,-1,0))), 2.0);\n    diff(backThing, sliced);\n    add(hA, backThing);\n    \n    pr1 = pos;\n    pr1 = tX(pr1, vec3(0.0,-0.2,-1.9));\n    backThing = vec2(sdRoundCone(pr1, 0.25, 0.325, .2), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.2,-0.0)), normalize(vec4(0,-1,-.2,0))), 2.0);\n    sliced = vec2(sdPlane(tX(pr1,vec3(0,0.,0.)), normalize(vec4(0,0,-1,0))), 2.0);\n    diff(backThing, sliced);\n    add(hA, backThing);\n    \n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,0.075);\n    pr1 = tX(pr1, vec3(0.0,-0.2,-2.));\n    backThing = vec2(sdRoundCone(pr1, 0.015, 0.045, 0.25), 2.0);\n    add(hA, backThing);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.4);\n    pr1.x = abs(pr1.x);\n    pr1 = tX(pr1, vec3(0.1,-1.75,-0.7));\n    pr1.xy = rX(pr1.xy, 0.1);\n    vec2 pillar = vec2(sdCappedCylinder(pr1, vec2(0.04,0.2)), 2.0);\n    add(hA, pillar);\n    \n    pr1 = pos;\n    pr1.yz = rX(pr1.yz,-0.6);\n    pr1 = tX(pr1, vec3(0.,-1.7,0.8));\n\n    pillar = vec2(sdCappedCylinder(pr1, vec2(0.04,0.2)), 2.0);\n    add(hA, pillar);\n    \n    return hA;\n}\n\n// Thank you @evvvvil for the cloudy day!!\nfloat t,tt,b,de,cr=1.;vec3 np,bp,cp,po;vec4 cc,su=vec4(0);\nfloat bo(vec3 p,vec3 r){vec3 q=abs(p)-r;return max(max(q.x,q.y),q.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb(vec3 p)\n{\n  vec2 h,g=vec2(bo(abs(p)-vec3(4.3,0,0),vec3(3.5,0.4,0.4)),3);\n  h=vec2(bo(abs(p)-vec3(4.,0,0),vec3(3.,0.2,0.6)),5);\n  h.x=min(bo(abs(p)-vec3(0,0,1.),vec3(30,0.2,0.2)),h.x);\n  h.x=min(bo(p,vec3(30,0.2,0.2)),h.x);\n  h.x=min(bo(abs(p)-vec3(6,0,0),vec3(0.2,100.,0.2)),h.x);\n  g=(g.x<h.x)?g:h;\n  g.x*=0.7;\n  return g;\n}\n\nfloat noise(vec3 p){\n  vec3 ip=floor(p),s=vec3(7,157,113);\n  p-=ip; vec4 h=vec4(0,s.yz,s.y+s.z)+dot(ip,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\n\nfloat c_noise(vec3 p)\n{\n    float f = 0.0;\n    p = p + vec3(0.0,1.0,0.0)*tt*0.3;    \n    f += 0.5*noise(p);\n    p=2.1*p;\n    f+=0.25*noise(p+1.);\n    p=2.2*p;\n    f += 0.125*noise(p+2.); \n    p=2.3*p;\n    f+=0.0625*noise(p);\n    return f;\n}\n\nvec2 scene(vec3 point) {\n    vec2 base;\n    \n    vec3 pikePoint = tX(point, vec3(-1.+.25*cos(iTime*.7),0.75*sin(iTime*.2),.5*sin(iTime*.5)));\n    pikePoint.yz = rX(pikePoint.yz, 0. + .1 *cos(iTime*.2));\n    pikePoint.xy = rX(pikePoint.xy, 0. + .1 *cos(iTime*.3));\n    vec2 pika = balloonPika(pikePoint/.5);\n    \n    vec3 witchPoint = tX(point, vec3(1.+.25*sin(iTime*.5),.5*cos(iTime*.5),.5*sin(iTime*.5)));\n    witchPoint.yz = rX(witchPoint.yz, 0. + .1 *sin(iTime*.5));\n    base = witch(witchPoint/.5);    \n    \n    point = tX(point, vec3(0,1.5+0.1*cos(iTime),0));\n    point.yz = rX(point.yz, 0.5);\n    point.xz = rX(point.xz, 0.025*cos(iTime));\n    vec2 goose = balloon(point);\n    \n    add(base, goose);\n    add(base, pika);\n    return base;\n}\n\nvec3 GetNormal(vec3 hitPoint) {\n    vec3 e=vec3(1e-2,0,0);\n    float d = scene(hitPoint).x;\n    return normalize(vec3(scene(hitPoint + e.xyy).x - d,\n                          scene(hitPoint + e.yxy).x - d,\n                          scene(hitPoint + e.yyx).x - d));\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; ++i)\n    {\n        float h = scene(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n    \n}\n\nvec3 GetColorFromSDF(vec2 distAndMaterial, vec3 hitPoint) {\n    vec3 hitNormal = GetNormal(hitPoint);\n    float mat = 0.0;\n    mat = distAndMaterial.y;\n    \n    vec3 lightPos = vec3(25,3,-5);\n    float light = dot(hitNormal, normalize(lightPos))*.5+.5;\n    \n    vec3 baseColor = vec3(0,0,0);\n    vec3 color = baseColor;\n    if (mat == 3.0) {\n        if (light*2. > 1.8) {\n        \tbaseColor = vec3(120./255.,120./255.,90./255.)*light*2.;\n        }\n    }else if (mat == 4.0) {\n       \tbaseColor = vec3(120./255.,120./255.,90./255.)*light*1.25;\n    } else if (mat == 8.0) {\n        baseColor = vec3(100./255.,73./255.,23./255.)*light;\n    } else if (mat == 10.0) {\n        baseColor = vec3(100./255.,64./255.,0./255.)*light;\n    } else if (mat == 11.0) {\n       \tbaseColor = vec3(90./255.,54./255.,0./255.)*light;\n    } else if (mat == 12.0) {\n       \tbaseColor = vec3(90./255.,0./255.,0./255.)*light;\n    }\n    \n    color = baseColor;\n    \n    return color;\n}\n\nvec3 GetColorFromBackground(vec2 uv) {\n    return vec3(0,1,0);\n}\n\nvec2 Trace(vec2 uv, vec3 cam, vec3 dir) {\n    float h =  MIN_HIT_DIST * 2.0;\n    float t = 0.0;\n    float finalDist = -1.0;\n    float id = -1.0;\n    \n    for(int i = 0; i < MAX_NUM_STEPS; ++i)\n    {\n        if(h < MIN_HIT_DIST || t > MAX_TRACE_DIST) break;\n        \n        vec2 distToClosest = scene(cam + dir * t);\n        h = distToClosest.x;\n        id = distToClosest.y;\n        t += h;\n    }\n    \n    if(t < MAX_TRACE_DIST) finalDist = t;\n    if(t > MAX_TRACE_DIST) id = -1.0;\n    return vec2(finalDist, id);\n}\n\n\nvec3 render(in vec3 ro, in vec3 rd, in vec2 uv)\n{\n    float ssDistToCenter = length(uv);\n    vec3 bgColor1 = vec3(0.6, 0.2, 0.9);\n    vec3 bgColor2 = vec3(0.0, 0.2, 0.8);\n    vec3 surfaceColor = vec3(0.7, 0.9, .7) + rd.y * 0.8;\n    \n    vec2 results = Trace(uv, ro, rd);\n    float t = results.x;\n    float id = results.y;\n    \n    if(t > -0.5)\n    {\n        vec3 lightPos = vec3(0.0, 2.0, 0.0);\n        vec3 pos = ro + rd * t;\n        \n        vec3 n = GetNormal(pos);\n        vec3 diffColor = GetColorFromSDF(results, pos);\n\n        vec3 l = normalize(lightPos - pos);\n        float diffStrength = max(dot(n, l), 0.4);\n        float ambientStrength = clamp(0.5 + 0.5 * n.y, 0.0, 1.0);\n        vec3 ambientColor = vec3(0.50,0.50,0.50);\n        \n        \n        ambientColor *= ambientStrength * 0.3;\n        \n        surfaceColor = diffStrength * diffColor + ambientColor;\n        surfaceColor /= 0.75;\n    }\n    \n    return surfaceColor;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 cam = vec3(0,0.85,-4.5);\n    vec3 dir = normalize(vec3(uv,1));\n    mat3 rot = rotationXY(vec2(0.0,0.42-iTime*.5));\n    \n    if (iMouse.z > 0.0) {\n        rot = rotationXY( ( iMouse.xy - iResolution.xy * 0.5 ).yx * vec2( 0.01, -0.01 ) );\n    }\n    \n    dir = rot * dir;\n    cam = rot * cam;\n    \n    vec3 color = vec3(0);\n    \n    vec2 results = Trace(uv, cam, dir);\n    float t = results.x;\n    float id = results.y;\n    \n    if(t > -0.5)\n    {\n        vec3 pos = cam + dir * t;\n        color = GetColorFromSDF(results, pos);\n    }\n    \n    color = render(cam, dir, uv);\n    \n    for (int i=0;i<60;i++) {\n    \tcp=cam+dir*(cr+=(0.3-length(cp-cam)*0.01));\n        cp.xz*=r2(sin(cp.y*0.1+iTime)*.5);\n        if (su.a>0.99||cr<=t) break;\n        de=clamp(-1.5+2.8*c_noise(cp*.5),0.,1.);\n        cc=vec4(mix(vec3(1),color,de*.9)*de,de);\n        su+=cc*(1.-su.a);\n    } \n    \n    su=clamp(su,0.,1.);\n   \tfragColor=vec4(pow(mix(su.xyz,color,(1.-su.r)*smoothstep(-1.,1.,length(cp-po))),vec3(.45)),1);\n}\n\n", "image_inputs": [], "common_code": "const float MAX_TRACE_DIST = 20.0;\nconst float MIN_HIT_DIST = 0.001;\nconst int MAX_NUM_STEPS = 100;\nconst float PI = acos(-1.);\n\nvec3 tX(vec3 p, vec3 d) {\n    return p - d;\n}\n\nmat3 rotationXY( vec2 angle ) {\n    vec2 c = cos( angle );\n    vec2 s = sin( angle );\n    \n    return mat3(\n                c.y      ,  0.0, -s.y,\n                s.y * s.x,  c.x,  c.y * s.x,\n                s.y * c.x, -s.x,  c.y * c.x\n                );\n}\n\nvec2 rX(const in vec2 p, const in float ang) {\n    float newAng = ang * PI;\n    float c = cos(newAng), s = sin(newAng);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat dot2( in vec2 v ) { return dot(v,v); }\n\nvoid diff(inout vec2 d1, in vec2 d2) {\n    if (-d2.x > d1.x) {\n        d1.x = -d2.x;\n        d1.y = d2.y;\n    }\n}\n\nvoid diff(inout float d1, in float d2) {\n    if (-d2 > d1) {\n        d1 = -d2;\n    }\n}\n\nvoid add(inout vec2 d1, in vec2 d2) {\n    if (d2.x < d1.x) d1 = d2;\n}\n\nvoid intersect(inout vec2 d1, in vec2 d2) {\n    if (d1.x < d2.x) d1 = d2;\n}\n\nfloat opSmoothUnion(inout float d1, inout float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n    // n must be normalized\n    return dot(p,n.xyz) + n.w;\n}\n\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdGround(vec3 p) {\n    return p.y+1.5;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n    \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    float q = length(p.xy);\n    return dot(c,vec2(q,p.z));\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat linedist(vec3 p, vec3 a, vec3 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)-.1));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  float k = dot(p-a,b-a)/dot(b-a,b-a);\n  return distance(p, mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat onion( in float d, in float h )\n{\n    return abs(d)-h;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 1499], [1501, 1501, 1529, 1529, 3308], [3310, 3355, 3377, 3377, 3681], [3683, 3683, 3707, 3707, 7507], [7611, 7611, 7635, 7635, 7681], [7682, 7682, 7699, 7699, 7742], [7743, 7743, 7760, 7760, 8076], [8078, 8078, 8098, 8098, 8321], [8323, 8323, 8346, 8346, 8563], [8565, 8565, 8589, 8589, 9310], [9312, 9312, 9343, 9343, 9578], [9580, 9580, 9654, 9654, 9934], [9936, 9936, 9995, 9995, 10894], [10896, 10896, 10934, 10934, 10960], [10962, 10962, 11003, 11003, 11478], [11481, 11481, 11530, 11530, 12422], [12426, 12426, 12481, 12481, 13583]], "test": "untested"}
{"id": "3tSyDc", "name": "spheres sim", "author": "wyatt", "description": "Self-organizing knot.", "tags": ["organization"], "likes": 8, "viewed": 363, "published": 3, "date": "1595484484", "time_retrieved": "2024-07-30T20:54:21.949555", "image_code": "Main // post\n{\n    Q = A(U);\n    for (float j = 0.; j < 6.2; j += 6.2/3.)\n        for (float i = 0.; i < 20.; i++) {\n            vec4 a = A(U+vec2(i,0)*ei(iTime+j));\n            Q += .1*a*(-1.+exp(3.*a))*gauss(i,5.+1.*a.x);\n        }\n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 150.\n#define R iResolution.xy\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n#define ei(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define Main void mainImage( out vec4 Q, in vec2 U)\n#define gauss( i, std) 0.3989422804/(std)*exp(-.5*(i)*(i)/(std)/(std))\n\n#define charge(i) (sign(cos(i)))", "buffer_a_code": "Main // v+=f p+=v+f\n{\n    U = floor(U);\n    if (U.x>N||U.y>=2.) {discard;return;}\n    \n    vec3 pos = A(vec2(U.x,0)).xyz,\n         vel = A(vec2(U.x,1)).xyz,\n         frc = B(vec2(U.x,0)).xyz;\n    vel += frc;\n    pos += frc + vel*sqrt(1./(1.+dot(vel,vel)));\n    if (length(vel)>.1) vel = .1*normalize(vel);\n    \n    if (pos.x<-1.) {pos.x=-1.; vel.x*=-.5;}\n    if (pos.y<-1.) {pos.y=-1.; vel.y*=-.5;}\n    if (pos.z<-1.) {pos.z=-1.; vel.z*=-.5;}\n    if (pos.x>1.) {pos.x=1.; vel.x*=-.5;}\n    if (pos.y>1.) {pos.y=1.; vel.y*=-.5;}\n    if (pos.z>1.) {pos.z=1.; vel.z*=-.5;}\n    \n    if (iFrame < 1) {\n    \tpos = vec3(sin(U.x),cos(U.x),sin(sqrt(5.)*U.x));\n        vel = vec3(0);\n    }\n    \n    \n    if (U.y<1.) \n    \tQ.xyz = pos;\n    else if (U.y < 2.) \n    \tQ.xyz = vel;\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main // calculate forces\n{\n    U = floor(U);\n    vec3 f = vec3(0);\n    vec3 pos = A(vec2(U.x,0)).xyz;\n\tif (U.x>N||U.y>=1.) {discard;return;}\n    for (float i = 0.; i < N; i++) {\n    \tvec4 a = A(vec2(i,0));\n        vec3 r = a.xyz-pos.xyz;\n        float l = length(r);\n        float ch = charge(U.x)*charge(i);\n        if (l>1e-2) \n        f += (.01-ch)*r/l/l-.01*(1.5+ch)*r/l/l/l/l/l;\n    }\n    vec3 r = (pos-vec3(0));\n    float l = length(r);\n    if (l>1e-1) \n        f += -r/length(r);\n    f = 1e-4*f;\n    if (length(f)>1.) f = normalize(f);\n    Q.xyz = f;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main \n{\n\tvec4 \n        n = A(U+vec2(0,1)),\n        e = A(U+vec2(1,0)),\n        s = A(U-vec2(0,1)),\n        w = A(U-vec2(1,0));\n    Q.xyz = normalize(vec3(\n        length(e.xyz)-length(w.xyz),\n       \tlength(n.xyz)-length(s.xyz),\n    \t5\n    ));\n}", "buffer_c_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 triplanar (vec3 p, vec3 n, out vec3 norm) {\n    p = (p-0.5)* .5*iChannelResolution[3].x;\n\tvec4\n        a = D(p.xy+0.5*iChannelResolution[3].xy),\n        b = D(p.yz+0.5*iChannelResolution[3].xy),\n        c = D(p.zx+0.5*iChannelResolution[3].xy);\n    vec3\n        an = B(p.xy+0.5*iChannelResolution[3].xy).xyz,\n        bn = B(p.yz+0.5*iChannelResolution[3].xy).yzx,\n        cn = B(p.zx+0.5*iChannelResolution[3].xy).zxy;\n    norm = (an*n.z+bn*n.x+cn*n.y);\n    return a*n.z*n.z+b*n.x*n.x+c*n.y*n.y;\n}\nvec2 sphere (vec3 p, vec3 d, float r){\n    float C = dot(p,p)-r*r,\n        B = 2.*dot(p,d),\n        det = B*B-4.*C;\n    if (det < 0.) return vec2(-1,0);\n    float i = 0.5*(-B-sqrt(det));\n    if (i>0.) return vec2(i,1); \n    else return vec2(0.5*(-B+sqrt(det)),-1);\n}\nMain\n{\n\tQ = vec4(0);\n    vec3 \n        light = vec3(1,1,-4),\n        p = vec3(0,0,-1.5),\n        d = normalize(vec3(2.*(U-0.5*R)/R.y,1)),\n        pp = p, dd = d, nn = vec3(0);\n    p.xz *= ei(.1-6.2*iMouse.x/R.x);\n    d.xz *= ei(.1-6.2*iMouse.x/R.x);\n    light.xz *= ei(.1-6.2*iMouse.x/R.x);\n    p.zy *= ei(.1-6.2*iMouse.y/R.y);\n    d.zy *= ei(.1-6.2*iMouse.y/R.y);\n    light.zy *= ei(.1-6.2*iMouse.y/R.y);\n    vec4 qq = Q;\n    vec2 xx = vec2(1e3);\n    for (float i = 0.; i < N; i++) {\n        vec4 a = A(vec2(i,0));\n        vec2 x = sphere(p-a.xyz,d,.066+.05*abs(charge(i)));\n        if (x.x>0.&&x.x<xx.x) {\n            xx = x;\n        \tpp = p+x.x*d;\n            nn = normalize(pp-a.xyz);\n            qq = triplanar(pp-a.xyz,nn,nn);\n        \tqq *= 0.5+0.5*sin((charge(i))+iTime+vec4(1,2,3,4));\n            dd = reflect(d,nn);\n            \n        }\n    }\n    /*float w = plane(p-vec3(0,0,1),d,vec3(0,0,1));\n\tif (w>0.&&w<xx.x) {\n        xx.x = w;\n        pp = p+w*d;\n        nn = vec3(0,0,1);\n        qq = triplanar(pp,nn,nn);\n        dd = reflect(d,nn);\n\n    }*/\n    \n    vec4 tx = texture(iChannel2,dd);\n    Q.xyz = 0.5*qq.xyz+0.5*tx.xxx;\n    xx = vec2(1e3);\n    p = pp;\n    d = normalize(light-p);\n    for (float i = 0.; i < N; i++) {\n        vec4 a = A(vec2(i,0));\n        vec2 x = sphere(p-a.xyz,d,.05+.05*abs(charge(i)));\n        if (x.x>0.&&x.x<xx.x) {\n            Q *= .5;\n            \n        }\n    }\n}", "buffer_d_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 3, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 24, "src": "/media/a/488bd40303a2e2b9a71987e48c66ef41f5e937174bf316d3ed0e86410784b919.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyDc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WlByD3", "name": "Tangled branches", "author": "jarble", "description": "This fractal is based on a [url=https://www.shadertoy.com/view/tl2yDz]\"cave fractal.\"[/url]\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "thorns"], "likes": 9, "viewed": 497, "published": 3, "date": "1595458915", "time_retrieved": "2024-07-30T20:54:22.898019", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 1.0;\n    float t1 = iTime*speed;\n\tvec3 eye = vec3(-t1*9.0-15.0,t1*9.0-15.0,-t1*9.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t*t/3/4096)%3+(t/7/4096)%7-(t/2/4096)%2)))|t>>4|t>>5&t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n\n\n/*\n// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t*t/3/4096)%3+(t/7/4096)%7-(t/2/4096)%2)))|t>>4|t>>5&t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.1+sin(time)/16000.0;\n    }\n    return result/100.0;\n}\n*/", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/1.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1)+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 5; k++){\n        p = p*3.0;\n    \tresult += planet_surface(p)/(i);\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/4.0;\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 1.0;\n    float t1 = iTime*speed;\n\tvec3 eye = vec3(-t1*9.0-15.0,t1*9.0-15.0,-t1*9.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n\n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByD3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 206], [209, 630, 721, 721, 1087], [1102, 1356, 1421, 1421, 1553], [1555, 1644, 1673, 1673, 1983], [1985, 2477, 2617, 2617, 3227], [3229, 3599, 3684, 3684, 4099], [4101, 4428, 4477, 4512, 4643], [4645, 4645, 4672, 4672, 4821], [4823, 4823, 4880, 4880, 5622]], "test": "untested"}
{"id": "Wt2yDV", "name": "ReTrAdUi amalgations4 ad36", "author": "ollj", "description": "move points to modify cellular3d.\n\nparent: https://www.shadertoy.com/view/wl2cRt#\ntime co clean up my noise functions again, by reimporting them. old ones had incompatible structure, bad scopes and doo much matrix nonsense.", "tags": ["filter", "gradient", "ik", "barycentric", "derivative", "ui", "ad", "automaticdifferentiation", "superprim", "calculus", "csgsuperprim"], "likes": 2, "viewed": 388, "published": 3, "date": "1595454432", "time_retrieved": "2024-07-30T20:54:25.135038", "image_code": "/*\nReTrAdUi\n=Relativistic Epsilon\n,Temporal     Reprojection\n,Automatic    Differentiation\n,User         Interface\n\nthis amalgation is a bit messy, it can only go uphill from here.\nthe CommonTab has toggles between 3 scenes; Temporal Reprojection, Automatic Differentiation, and a 2d UI-focused Scene.\nbelow test is mostly about the [automatic differentiation] scene\nthe Image-MainImage function on the bottom here toggles between Re7 (relativityEngine) and all else.\nThe goal here is to unify concepts of 4 other shaders, where ever that makes sense and evades conflicts.\n*/\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\nRE,RelativityEngine,TargetFps\nTR,TemporalReprojection\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nself UI2TARD38: https://www.shadertoy.com/view/3l2GDR (amalgations2)\nparent UI2AD37: https://www.shadertoy.com/view/3tSGDz (slow progress)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.x is the inner bound of a dot's black border\n //e.y is the outer bound of a dot's black border \n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n//iCanBez (iCanvas iBezieer merged in UI2AD37)\n/*\niChannel0=BuffA\niChannel1=BuffB\niChannel2=BuffC\niChannel3=BuffD\n*/\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bézier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n//#define viewzoom  (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;v1 p3\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;//c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n ;v1 p4\n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;//c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,vec2(0),vec2(0))\n    \n    /* \n ;c.x=min(c.x,segment(u,(p1-p0)*.5-p0,p2))\n ;c.x=min(c.x,segment(u,(p2-p1)*.5-p1,p0))\n ;c.x=min(c.x,segment(u,(p0-p2)*.5-p2,p1))\n     /**/\n //this is too naive. makes more sense to get the longest side first.\n ;//vec3 penismeasure=vec3(dd(p0-p1),dd(p1-p2),dd(p2-p0))\n ;//int cookie=getPosSmall(penismeasure)\n  //   ;if(cookie==2){vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1));c.x=min(c.x,segment(u,aa,p2));}\n ;//vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2));c.x=min(c.x,segment(u,bb,p0)) \n ;//vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0));c.x=min(c.x,segment(u,cc,p1))\n     /**/\n     \n ;//float aa=dot(p1-p0,p2-p0)\n ;//float bb=dot(p2-p1,p0-p1)\n ;//float cc=dot(p0-p2,p1-p2)  \n// ;vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2))\n ;//vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0))\n// ;vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1))\n //;if(true//min(bb,cc)>0.\n //   ){vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2));c.x=min(c.x,line(u,p0,bb));} \n// ;if(true //min(aa,cc)>0.\n//    ){vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0));c.x=min(c.x,line(u,p1,cc));} \n// ;if(true//min(aa,bb)>0.\n//    ){vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1));c.x=min(c.x,line(u,p2,aa));}\n ;//vec2 orthocenter=gLLxX(p2,aa,p0,bb)\n ;//c.x=min(c.x,line(u,orthocenter,p0))\n ;//c.x=min(c.x,line(u,orthocenter,p1))\n ;//c.x=min(c.x,line(u,orthocenter,p2))\n     \n ;float h=line(u,p0,p1)-.01\n ;h=min(h,line(u,p1,p2)-.01)\n ;h=min(h,line(u,p2,p0)-.01)\n ;c.w=min(h,ray(u,p3,p4)-.01) //draw ray and triangle\n \n ;c.x=h\n ;c.y=1.\n ;c.z=1.\n   \n ;float carthesianDet=c2bdet(p0,p1,p2)\n\n ;vec3 uu=c2b(u,p0,p1,p2,carthesianDet)\n ;vec3 ssu=sat(sign(uu))\n ;float uus=suv(ssu)\n ;//c.xyz=ssu\n ;mat3 n=mat3(p0,0,p1,0,p2,0)\n ;float ddd=0.\n ;float gpl=float(getPosLarge(ssu))\n ;c.z=sdTriangle(p0,p1,p2,u)-.04\n\n     \n\n ;vec3 oo=c2b(p3,p0,p1,p2,carthesianDet)\n ;vec3 tt=c2b(p4,p0,p1,p2,carthesianDet) //ray points transformed from carthesian to barycentric\n ;vec3 vs=oo-tt\n     \n ;vec3 l=vec3(dd(p1-p2),dd(p2-p0),dd(p0-p1))//squared side length\n ;float radius=sqrt(lengthBary(oo-tt,l))//vector (oo-tt) length from barycentric vector\n\n //;vec3 vv=c2b(p4-p3,p0,p1,p2)\n\n ;float center=sqrt(lengthBary(oo-uu,l))//vector (oo-uu) length from barycentric vector\n ;c.w=min(c.w,abs(center-radius))//;c.w=min(c.w,abs(length(u-p3)-radius))\n //;c.w=min(h,ray(u,p3,p4)-.01)\n \n ;vec3 os=sat(floor(oo+1.))\n ;vec3 ts=sat(floor(tt+1.))//sat is needed for scale (large distances to the triangle are cheap)\n ;float ooo=suv(os)\n ;float ttt=suv(ts)//sum of vector components now points at 7 different segments:\n     //1* insideTriangle\n     //3* largeBorderTile(adjacent) \n     //3* cornerBorder   (only touches triangle corners)\n         \n ;vec3 linesToCheck=vec3(0)\n \n ;if(ooo==2.//case 2: origin is in largeBorderTile\n ){if(ttt<2.&&os!=1.-ts)linesToCheck=vec3(0)\n  ;else{linesToCheck=getPosSmallV(os)//this one is simple, either misses all, or hits only one.\n      //nope nope nope,(vs) doesnt ALWAYS work HERE: \n      //but sure, there are other ways to do this, removed for now\n ;}}else if(ooo==1.){//case 1: origin is in cornerBorder\n  ;if(ttt<2.&&os!=ts)linesToCheck=vec3(0)//only the other 2 outer corners miss the triangle\n  ;else if(ttt==2.&&os!=1.-ts)linesToCheck=getPosSmallV(ts)//from cornerBorder to ADJACENT largeBorderTile, has 1 border\n      ;else{linesToCheck=1.-getPosLargeV(os);\n      ;if(1.-getPosLargeV(vs)!=linesToCheck)linesToCheck=vec3(0.)\n ;}}else //if(os==vec3(1) )//case 0: origin is in insideTriangle\n  {if(ttt==2.)linesToCheck=1.-getPosSmallV(ts) //target is in any largeBorderTile /single border)\n  ;else linesToCheck=1.-getPosSmallV(-vs)//target is anywhere outside (2 borders)\n ;}\n /**/\n  \n ;if(linesToCheck.x>0.)c.y=min(c.y,segment(u,p1,p2)-.04)//indicating segments that are hit.\n ;if(linesToCheck.y>0.)c.y=min(c.y,segment(u,p2,p0)-.04)//indicating segments that are hit.\n ;if(linesToCheck.z>0.)c.y=min(c.y,segment(u,p1,p0)-.04)//indicating segments that are hit.\n\n //the faces that are still in may only return the NEAR intersection.\n //there is no case where there is a far intersection, the firt positive intersection can be returned as nearest.\n //i have not implemented a function that takes (linesToCheck), to trace this triangle/prism.   \n //on tracing a triangle/prism efficiently.\n //triangles imply barycentric coordinates, converters exist, but they are not too fast, and should be avoided.\n //just start in barycentric coordinates\n     //how about one moore domain, doing a 3d simplex (skewable triangle pyramid)\n\n //;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;//c.y=BezierQuadParabola(u,p0,p1,p2)           //green shows parabola\n ;m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;//c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;vec3 j=vec3(fract(abs(p1.x*2.)),1./7.,1./6.)\n \n ;u*=3.\n ;p4*=4.\n ;p4.y=-p4.y\n ;p2*=2.\n ;//p3*=sign(-p4)\n  ;if(mav(abs(u))<.75){\n         ; c.xyz+=.5*(simplexRotD(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   ;//c.y  +=.5*(simplexRot(u/p3.xy+p4,floor(p1*19.)*2.,p2.x+p2.y)*.2)*.5+.5\n   //above 2 have periodic tiling.xy, below not:\n   ;//c.xyz+=.5*((simplexRotD(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n   ;//c.y  +=.5*((simplexRot(u/p3.xy+p4,p2.x)*.2)*.5+.5)\n }else if(u.x<0.\n ){vec2 cel\n  ;if(u.y>0.)cel=cellular(     u/p3.xy      +     p4.xy      ,j)\n  ;else      cel=cellular(vec3(u/p3.xy,p2.x)+vec3(p4.xy,p2.y),j) \n  ;//c.x=snoise(u/p3.xy*2.+p4.xy*9.)*.5+.5;\n  ;c.xy+=cel.xy*.6\n ;}else{\n  ;if(u.y>0.\n  ){     c.y+=.6*(snoise(     u/p3.xy+p4           )*.5+.5)\n  ;}else c.y+=.6*(snoise(vec3(u/p3.xy+p4,p2.x+p2.y))*.5+.5)\n ;}\n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point on line\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c.x=min(c.x,segment(u,p0,p10))-.01\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){//o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=demoProject(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;//o=sat(o)\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n\n\n\n\n//below code is: RE7 [[BayesianEpsilon targetFPS] [Image]]\n//iRe refers to the ichannel buffer locale of [relativistic camera movement]\n//the type of camera mkovement where [time slows down, reciprocal to the speed of light].\n//that is, reaching the speed of light is impossible, because that halts the speed of time.\n//and any 2 observers with no relative movement hate time between them pass with the speedOfLight.\n\n#define iRe iChannel2\n\n//tags:\n//lod,blackhole,redshift,relativity,compatibility,dilation,bayesian,simultaneouity,bayeEps\n//bayemode =0 has a period of 1 second\n//bayemode =1 has a period of 1 frame, which keeps failing me, always.\n#define BayeMode 0\n/*\nself    RE7 : https://www.shadertoy.com/view/tlf3zj\nparent0 RE6 : https://www.shadertoy.com/view/WtfGRj\nparent1 RE5?: https://www.shadertoy.com/view/tdfXDl\n/**/\n//todo, hide thes BaeysTheorem-oscillations in \n//- temporal reprojection\n//- a screenspace noisy-offset of parameters (uv stays unaffected)\n//- - 16x16BayerMatrix should be good enoug here\n//- all of the above\n//- a lower  FPStarget causes lessfps and better images\n//- a higher FPStarget causes higher and worse images\n//enter target fps as base below, and see it oscillate till it hopefully approaches the target fps\n//its a kind of magic of the logn() core function:\n//#define FPStarget pow(10.,1.68)   //<20 fps is only significant on higher resolutions||maxStepRayMarching\n//#define FPStarget pow(20.,1.68) //this integer fraction of 60 seems fine\n#define FPStarget pow(30.,1.68) //avoid [integer fractions of 60] as fps, they conmverge the slowest\n//#define FPStarget pow(40.,1.68)\n//#define FPStarget pow(50.,1.68)\n//testing sclaing of resolutions is hard. the fps dispolay is a big overheat\n//, that tends to cost -5% of the fps.\n//the fun part, FPStarget is INDEPENDENT from the parameter below\n#define maxStepRayMarching 2000\n// within maxStepRayMarching[50..200], which mostly depends on the average scene curvature\n//which is hard to estimate becuase it has a black hole inside of it!!!\n//thats right, you enter 200 maxSteps, and   FPStarget pow(40.,1.68), and iut will reach 40 fps!\n//\"as you qishh milord\"\n//initially FPStarget mapped to a targetFPS one to one (esponent was initially close to 1), \n//so yo you could enter what fps you wanted, and it would almost reach it.\n//but the more complex this gets, the worse your scales and estimates become\n//andd the overhead accumulates, and has problems to estimate its own cost.\n//currently the overhead is roughly an exponent of 1.6 to 1.7 ?\n//nonetheless, all the DIRECTIONS of the interpolations and bijections are correct\n//and with that exponent, you can enter the target fos as basis\n//it is optimized for the 500px-wide preview, may not scale too well to larger resolutions\n//i tried, this is VERY twittly.\n//this really needs BoundingVolumes, so that not all viewing angles have roughly the same complexity!!!\n//so yeah, if there ever was a shader that needed lobeps added to it...\n//but fitst let me fix compatibility iassues of this shader...\n/*\ncore idea here is, you set a target fps, and the renderer tries to just reach that FPS count.\nit may increase epsilon, if it was overperforming previously (fps was above FPStarget)\nit may decrease epsilon, if it was underperforming previously (fps was below FPStarget)\nstill, there exists a clamp() to the epsilon values\n, and a lot of of smoothened interpolation ramps and logarythms.\n, because an extreley huge epsilon makes little sense in 60fps\n, because an extremely tiny epsilon makes little sense, just to stay at a lower FPStarget\nThis begs for a better [BayesTheorem over time], but i have yet to implkement the necessary state for that.\nit does not just do this for epsilon, but also for [ReciprocalLipschitz]\n, ==[the amount you understep by]\n, ==[the interval of your volumeMarching]\nIt has a bias in vafor of the ScreenCenter \n- smaller reciprocalLipschitz near screencenter than near screen corner\n- smaller epsilon near screencenter than near screen corner\n- - the epsolon oscillations in a 1 second interval are more noticable near screen corners\n- - damnit this is inverse fovea!\nthis might be much more useful in a set with\n- Proper (axis aligned)BoundingVolume(hierarchy), may be great with fractals with simple escapeTime conditions\n- very different sceneries, a long beach horiton and a small simple box.\n- logatythmic epsilon marching\n- SoC marching\nnegative side effect;\n- id goes into the right directions, but it fails to estimate any half decent taylor series, and therfore misses the target a lot\n- , unles you add more exponents to twiddle with.\n- in too high resolutions (or at 15 or 30fps) , It may heavily oscillate between 2-4 states where it keeps being [too fast] , [too slow]\n- without proper [bayes theorem over time with buffer states] i fail to twiddle parameters to work with multiple resolutions/settings.\nbut so far the proof of concept holds up for this set, and it kinda works\n,while in     512.*384. px resolution\nmost of its magic comes from its bijective subroutine: (r2l2Ws(logn()))\n*/\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log(x)/log(base);}//log2(x)/log2(base) has any utility? possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n//nope, i did not gain anything too useful from sucstituting for log2(x)/log2(bae), so far, i tried here, its just not pretty.\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}          //a[  0..1] <= a[1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //a[1/b..b] <= a[  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n//bayesEps concept\n//use BayesTheorem to adjust epsilon over time, to reach a target FPS\n//if you look along the horizon, expect epxsilon to increase, to maintain fps\n//if you look into a small box, expect epsilon to derase, for more precision\n//input current epsilon and TATGET fps\n//return an epsilon, in hopes to adjust epsilon, to get [[f] fps] with the next frames.\nfloat getEpsToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.75\n //.75 is a pretty high max epsilon, but its the easiest way to get performance\n //, especially further away from the camera or behind an occuder or near a black hole\n ;mie=.00085*.25 //.00085 is artefact free mie with recLipschitz==1.\n                //mie<.00085 needs small recLipschitz, or walls look ugly.\n                //mie<.00085 makes the blackh hole looks smoother, but distant flat walls look worse.\n                //mie>=.00085 seems to be a lower bound for this scene, lower Mie cause black dots, where roots are never reached.\n ;//mie*=2.\n ;float N=6.\n ;//i=i/f\n ;//i=i*iResolution.x/512.\n ;//i=clamp(i,1./N,N)//this could need a special acos()-like function\n ;//i=1./iFrameRate\n ;float i=pow(iResolution.x/512.,2.5)\n     #if BayeMode ==1   \n   ;float tt=pow(FPStarget,1./1.68)\n   ;tt=pow(tt*300./40.,1.68)\n ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n   ;i*=tt/60.\n      #else\n ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n      ;i*=FPStarget/60.\n     #endif\n ;e=r2l(i                 \n        //r2l(iFrameRate/iTimeDelta)  //is nonsense on too many levels, so a good hint at what combos to avoid\n     \n                   //this segment tries to be clearvoy about what type of GPU you have to support resolutions\n           //and estimates how a deviation from an ideal resolution may affect GPU performance\n           //i am not fgood at this:\n        \n    //     r2l(iResolution.x/512./iFrameRate) //surprisingly simple anf dunctional\n            // i //this seems to be a good estzimate, it oscilates a bit and approaches a limit FAST\n\n\n    //r2l(1./iFrameRate) good and siomple\n    // iTimeDelta   /60.   //offly slow\n           \n       // *iResolution.x/512. //seems utterly wrong, way too strong oscillations\n          // r2l(1.iFrameRate/sqrt(iResolution.x*iResolution.y)/sqrt(384.*512.))//not too good \n    //   *512.*384./iResolution.x/iResolution.y //this like feels false\n        ,N)//we expect to get fps in range[1./9000,9000]\n     //a 1/N ratio maps to 0\n     //a 1/1 ratio maps to 1\n     //a N/1 ratio maps to 2, so, this transforms a ratio into something to mix with:\n ;e=e//pow(e,2.)//sqrt(e)\n ;//e=log(e)\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae)\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\n//the rotating fractal is evil here, because smaller epsilon result in BETTER lipschitz continuty AND better performance\n//so, some shapes are exceptions to general rules of optimitation-flow, with a shitty local extrema!\n//a minor drawbeck to the overall greatness of Naesian methods in sphertrackers.\n//or maybe just a bug to be fixed.\n#define rayEps getEpsToFps()\nfloat getEpsToFps(){//return 1.\n   ; return getEpsToFps(.001,FPStarget)\n    ;}\n//the fun of the above is, worst case is that it oscilates a bit\n//now, we can have 2 parameters independently modified in this way\n//both likely oscillate differently, and not the same (which woulc link them inapropriattrly)\n//so, lets also modify reciprocalLipschitz just like that:\n/**/\nfloat getReLipschitzToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.8//just do not make  mae>1., unless you are in logeps() marching territory.\n ;mie=.6 //mie<.5 will likely just result in getting you a larger epsilon, not worth it.\n     //mie>.6 is already too large, for shapes\n     //, that move with [half the speed of light][near a black hole]\n     //- yes, these are my quality merasures for lipschitz continuity by now.\n     //- once you have logeps()-marched a double [tensor] with lipschitz>5 \n     //- with no continuity or performance problems\n     //- , you kinda run out of challenges.\n ;float N=6.\n ;float i=pow(iResolution.x/512.,2.5)\n     #if BayeMode ==1   \n   ;float tt=pow(FPStarget,1./1.68)\n   ;tt=pow(tt*300./40.,1.68)\n ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n   ;i*=tt/60.\n      #else\n   ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n     ;i*=FPStarget/60.\n     #endif     \n ;i=clamp(i,1./N,N)//worksave bound\n ;e=r2l(i,N)\n     //a 1/N ratio maps to 0\n     //a 1/1 ratio maps to 1\n     //a N/1 ratio maps to 2 , so, this transforms a ratio into something to mix with:\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae);\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\nfloat getReLipschitzToFps(){//return 1.\n   ;return getReLipschitzToFps(.25,FPStarget);}\n//our baseline is still a targetPFS\n//#define dd(a) dot(a,a)\n//now, lets make it better near the screen center\n//lets weight them over how oval-distant they are to screenspace center\n//of course the oval is scaled by sqrt(2) and is a smoothstep and all the good stuff\nfloat getEpsToFps(float sscoc){\n    //here it makes sense, i suppose\n    ;sscoc=mix(FPStarget*.25,FPStarget*4.,sscoc)//larger epsilon neart screenspace borders, smaller near center\n        ;return getEpsToFps(.001,sscoc);}\nfloat getReLipschitzToFps(float sscoc){//return 1.\n   ;sscoc=mix(FPStarget*.25,FPStarget,sscoc)//lefr value near corner, right value near center\n   ;return getReLipschitzToFps(.25,FPStarget);}\n#define reciprocalLipschitz getReLipschitzToFps()\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float matID\n){if(matID>7.)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*matID*2.)*fakeOA\n ;}\nvoid MarchLight(float sscoc,inout Ray r, float startTime, float maxDist//relkativistic raymarcher\n){float totalDist = 0.0\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;totalDist += r.dist*getReLipschitzToFps(sscoc)\n  ;r.b+=r.dir*(r.dist)\n  ;if(abs(r.dist)<getEpsToFps(sscoc)||totalDist>maxDist)break;}}\nvoid MarchPOV(inout Ray r, float startTime,float sscoc\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])//es100 error , no array of class allowed\n  ;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  //\n  // t' = Y(t-v*(x/Y)/c²)\n  // t' = Y(0-v*(x/Y)/c²)\n  // t' = Y(v*x/Y)/c²\n  // t' = vx/c²\n  ;float relativeInstantEvents = SimultaneousEvents*dDirDpos*camDist/(cSpe*cSpe)\n  ;r.time = startTime\n  ;r.time += mix(relativeInstantEvents,photonDelay,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection=(objPos[oBlackHole]-r.b)//es100 error , no array of class allowed\n  ;r.dir+=(1./RayPrecision)*r.dist*reciprocalLipschitz\n      *normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<getEpsToFps(sscoc))break\n  ;r.b+= (1./RayPrecision)*(r.dist)*reciprocalLipschitz*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\nvec3 GetDiffuse(float sscoc, Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -r.b)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -r.b//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -r.b)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-r.b)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   #define basicBug \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif    \n  #endif\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(sscoc,shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(r.b,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(r.b,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;cDiff+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n/*\nvec3 GetDiffuse(Ray r\n){Ray tmpRay = r\n ;vec3 surfPos = r.b\n ;float accretion = vma\n ;vec3 diffuseCol = vec3(0)\n ;//accretion disk\n ;int mat = rayMat\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -surfPos)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -surfPos//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -surfPos)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-surfPos)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = surfPos + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-surfPos) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(surfPos,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(surfPos,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;diffuseCol+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  diffuseCol+(lHalo+accretion)*(1.-diffuseCol);}\n*/\nvec3 GetSampleColor(float sscoc,vec2 uv\n){    \n ;Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]//es100 error , no array of class allowed\n ;r.dir = qr(objRot[oCam],r.dir)//es100 error , no array of class allowed\n ;MarchPOV(r,playerTime,sscoc)\n ;return GetDiffuse(sscoc,r);}\n\nvec4 mainImageRe7(vec4 o, in vec2 u\n){//vec2 u=fra(uv,iResolution)//(uv/iResolution.xy+.5)/iResolution.y\n ;float sscoc=length(u/iResolution.xy-.5) //length(u/iResolution.xy*+.5)/sqrt(2.)\n ;sscoc=smoothstep(.75,0.,sscoc)//full btight in the center, pitch black at the cotner, oval\n ;vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime = Get(ReTime).x\n ;//vec3 LZZ = dpos\n ;//vec3 LZY = vec3(0,1,0)\n ;//vec3 LZX = cross(LZY,normalize(LZZ))\n ;//LZY = cross(LZZ,LZX)\n ;//LZLgthContract = mat3x3(LZX,LZY,LZZ)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;ProcessCamPos(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(sscoc,v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iRe,u/iResolution.xy).rgba );\n ;return o;}\n\n\n//below is a very basic toggle-wrapper, showing what 2 shaders have been hodgepodged\n//this completes step2, fixing all namespace conflicts. (was easy for once)\n//step 2 is to clean up mainImageRe7() and its subroutines.\n//step 3 is trckier\n//all these buffers store properties, an array of vec4 \n//and I need them to evade any conflict between them\n//so I can merge thzem into a single buffer\n//- (lets exclude BufferD for being a screenspace incrementalAveraging buffer)\n\n\n#define Scene2D\n\n//#if 1\nvec4 mainImageUI2AD37(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n ;return o      /**/\n ;}\n/*\n//#else\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}\n//#endif\n/**/\n\nvec4 spin(vec4 o,vec2 u\n){vec2 v=fra(iTime,u,iResolution,iMouse)\n ;o=vec4(0)\n   \n    \n ;//o=pdOver(iDiegeticUIshow(u),o)//ui dots\n ;//o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n ;v*=rot2D(u5(cos(iTime/9.)*99.))\n ;if(v.x>0.){if(v.y>.0){\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;//o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n   ;return o;\n   ;}\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n  ;//o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  ;return o\n  ;}\n ;if(v.y>0.){\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d drawing\n  ;return o\n ;}\n ;return o\n //;return mainImageRe7(o,u)\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){\n //;o=spin(o,u)\n    \n #if 1\n ;o=mainImageUI2AD37(o,u)\n #else\n ;o=mainImageRe7(o,u)\n #endif\n/**/\n ;}\n\n\n/*\nI like my code modular, evading namespace conflicts, while having short namespaces.\nI heavily advocate for compatibility, performance and diegetic UI.\nIO see this ignored too often\nThe acronym \"ReTrAdUi\" makes fun of bad UI design, namespaces and typos.\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n#define phi (sqrt(5.)*.5+.5)\n\n\n/**///--start: iDiegeticUI v2:\n/*\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos  = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n/**///--end__: iDiegeticUI v2:\n/**///--\n/**///--start: iChannel-Buffer-pattern\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**///--end__: iChannel-Buffer-pattern\n/**///--\n/**///--start: compatibilityCore \n\n\n/*\ntodo, all the trigonometry functions with glES100 to gles300 porting\nseems to be prettyx fine\n*/\n\n\n#define tiny .00001\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n#define u2(a) su(mu(a,2.), 1.)\n#define u3(a) su(mu(a,2.),-1.)\n#define u5(a) su(mu(a,.5),.5)\n#define u5cos(a) (u5(cos(a))\n//below is needed for old code, that i failed to update so that su() and mu() work on the right inpout types.\n#define u5cos2(a) ((cos(a))*.5+.5)\n//#define cosu5(a) u5(co(a))\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\nconst vec3 vs=vec3(-1,0,1);\nv1 perp(v1 a){return a.yx*vs.xz;}\nv1 perp2(v1 a,v1 b){return vec2(a.x*b.y,-a.y*b.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\nv0 perpdot(v1 a,v1 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//every 2d determinant has a perpendicular dotproduct\n\n//nul function is needed for cases, where the same function is defined 2 times\n//eg: once with sat and once without sat (with nul instead of with sat) => difference between segment() and line()\n#define nUl(b) b nul(b a){return a;}\nnUl(v0)\nnUl(v1)\nnUl(v2)\nnUl(v3)\n    \n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\n\n/**///--end__: compatibilityCore\n/**///--\n/**///--start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created #.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**///--end__: openGl NaN-precision\n/**///--\n/**///--start: AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n\nstruct d(v0 a;);//just use v0 instead of a [d]  struct\nthe whole DA set is pretty consistent, and i tried domain/ds the other way around and that sucked.\nthe first value is a float, because thats what the function returns, a length.\nAND most shapes apply the same functions to a value (no branching, all domains are NOT independent functionWise)\nbut many functions over 2d or 3d should be independent, and can be branching!\n...as a result, the d*** structs are nonsense, and i may need a BIG rewrite.\n\nso, what we may utilize here (to format an UV.xyz to give to any distanceField) is something like:\nc22 da_domain2(v2 p){return c22\n (d22(p.x,v2(1,0,0),v2(1,0,0))\n ,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n ,d22(p.y,v2(0,0,1),v2(0,0,1)));}\n//so the c22 struct first seperates by number of domains, seperating into 3 sub scructs, one foreach domain.\n//each derivative VECTOR has as many domains as the whole struct.\n//i actually wonder, WHY this is not always a type float.\n*/\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00   D00(v2   a){return d00(a.x,a.y,a.z);}\nv2     V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0     D0(v1   a){return d0(a.x,a.y);}\nv1     V1(d00  a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\n//the c* structs are used by the uv inputs, c2 is for 3d, with 1 derivative\n//a distance field is itterated over by: DAMValue s=df(da_domain1(o+i*t))\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt²\nST c000{d000 x                     ;};//1 domains t,dt²dt³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//the weirdness, that the first value is always a float, is based on the output of the function, with a scalar distance\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\n//v2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\n//the da_domain*() functions orhtogonally proiject the derivatives onto an matrix.\n//the inpput point o is spread among as many d*** structs as there are domains.\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.z,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0 da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n\n/**///--end__: AD structure\n/**///--\n/**///--start: AD functions \n\n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\n//AD uses these prexisNotation Namespaces and is defined for these domains):\n//[d0..d333] means, it is defined for up..3 derivatives over up..4 domains (but also any lesser permutation)\n//[c...] are some extended struct special cases (higher dimensional)\n//\n//ne()       0-a ,[d0..d333], also [c0..c333]\n//fl() floor(a  ),[d0..d333]\n//fr() fract(a  ),[d0..d333] <= su(1.,fl(a))==mod(a,1.) //complement..floor()\n//mo()   mod(a,b),[d0..d333] <= su(a,mu(b,fl(di(a,b)))) (true_basis_modulo)\n//si()   sin(a  ),[d0..d333]\n//co()   cos(a  ),[d0..d333]\n//ex()   exp(a  ),[d0..d333] //inverse of log()\n//ln()   log(a  ),[d0..d333]\n//sg()  sign(a  ),[d0..d333]\n//ab()   abs(a  ),[d0..d333],[c2]\n//su()        a-b,[d0..d333],[c0..c3]\n//ad()        a+b,[d0..d333],[c0..c3] <== su(a,ne(b))\n//mu()        a*b,[d0..d333],[c0..c3]\n//di()        a/b,[d0..d333]\n//po()   pow(a,b),[d0..d333] <= ex(mu(ln(x),x))\n//mi()   min(a,b),[d0..d333],[c2]\n//sr()  sqrt(a  ),[d0..d333]\n//p2()   pow(a,2),[d0..d333],[c0..c2] <=mu(a,a)\n//p3()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),a)\n//p4()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),mu(a,a))  //because for AD, mu() recursion is faster than pow(a,b)\n//dt()   dot(a,b),[d0..d333],[c0..c3] <=ad(mu(),mu()...)\n//dd()   dot(a,a),[d0..d333],[c0..c3] <= dt(a,a)\n//sd()  length(a),[d0..d333] <=po(dd(a),1./2.) == sq(dd(a))\n//cd()           , <=po(dd(a),1./3.)\n//qd()           , <=po(dd(a),1./4.)   \n//ud()           , <=po(dd(a),1./5.)\n//ata()          ,[d0..d333]\n//cl()  clamp()               <=mi(ma(a.,0.),1.)\n//st()   sat()                <=clamp(a.,0.,1.)\n//suab()         , [d0..d333] <=ab(sub(a))\n//\n//ab derivatives may be false/naive (3rd derivative is most likely nonsense)\n/**/\n\n//max(a,b)=-min(-a,-b), requires ne()\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n\n//floor(a) is a basis-function for mod() and fract() (all complement each other)\n//calculus on floor() is simpler than on fract() or mod() , so we defien fract() as 1.-floor(), and not as mod(a,1.)\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies automaticDiffernetiation (and it fixes mod())\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to multiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n//mod(a,1.) NEVER returns 1 (its a halfopen interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\nd00 AD(d00 a,v2 o){v0 O=a.c*o.x\n ;return D00(o.xyy*v2(1.,a.b,a.c)\n +v2(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\nv3 siD(v0 a){return v3(si(a),co(a),-si(a),-co(a));}//because derivatives of cin/cos have a periodicity of 4 derivatives,\nv2 siD2(v0 a){return v2(si(a),co(a),-si(a));}      //but we may also want just 2 derivatives (+base)\n\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\nd00 si(d00 a){return AD(a,siD2(a.a));}//sin()dxdxdx\nd00 co(d00 a){return AD(a,siD2(a.a).yzx);}//cos()dxdxdx\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\n\nd11 si(d11 a){d00 Omg(si,x);d00 Omg(si,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 si(d22 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 si(d33 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z);d00 Omg(si,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 si(d111 a){d000 OMg(si,x);d000 OMg(si,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 si(d333 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z);d000 OMg(si,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd11 co(d11 a){d00 Omg(co,x);d00 Omg(co,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 co(d22 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 co(d33 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z);d00 Omg(co,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 co(d111 a){d000 OMg(co,x);d000 OMg(co,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 co(d222 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 co(d333 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z);d000 OMg(co,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//once more a clear sign of my structure extending poorly HERE\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n\n\n//single parameter operations are MUCH simpler here:\n\n//ex(d000) seems to be fine\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n//ex(d00) seems to be fine\nd00  ex(d00  a){return d00 (ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c);}//(tripple) productRule\nd000 ex(d000 a){return d000(ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}//3rd derivative\nd11 ex(d11 a){d00 Omg(ex,x);d00 Omg(ex,y)              ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);d00 Omg(ex,w)\n    ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ln seems to be fine\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd00 ln(d00 a){return d00(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtdt\nd000 ln(d000 a){return d000(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtdt\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))/(a.a*a.a*a.a*a.a)//dtdtdt\n //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() is a special case of di() == one antiderivative higher.\nd1 ln(d1 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));return d1(x.a,v1(x.b,y.b));}\nd2 ln(d2 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z))\n ;return d2(x.a,v2(x.b,y.b,z.b));}\nd3 ln(d3 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z));d0 w=ln(d0(a.a,a.b.z))\n ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd11 ln(d11 a){d00 Omg(ln,x);d00 Omg(ln,y)              ;return d11(x.a,v1(x.b,y.b)    ,v1(x.c,y.c));}\nd22 ln(d22 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ln(d33 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);d00 Omg(ln,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//sg() seems to be fine\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\nd1 sg(d1 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;return d1(x.a,v1(x.b,y.b));}\nd2 sg(d2 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))\n   ;return d2(x.a,v2(x.b,y.b,z.b));}//this one is needed by sdUnterprim()\nd3 sg(d3 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z));d0 w=sg(d0(a.a,a.b.z))\n   ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd11 sg(d11 a){d00 Omg(sg,x);d00 Omg(sg,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 sg(d22 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 sg(d33 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z);d00 Omg(sg,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ab() 3rd derivative seems nonsensical, to check through!\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}//i am a bit suspicious about the derivatives here,not sure if it is THAT simple.\nd11 ab(d11 a){d00 Omg(ab,x);d00 Omg(ab,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ab(d22 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ab(d33 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z);d00 Omg(ab,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nc0   ab(c0   a){return c0  (ab(a.x));}\nc00  ab(c00  a){return c00 (ab(a.x));}\nc000 ab(c000 a){return c000(ab(a.x));}\nc1   ab(c1   a){return c1  (ab(a.x),ab(a.y));}\nc11  ab(c11  a){return c11 (ab(a.x),ab(a.y));}\nc111 ab(c111 a){return c111(ab(a.x),ab(a.y));}\nc2   ab(c2   a){return c2  (ab(a.x),ab(a.y),ab(a.z));}\nc22  ab(c22  a){return c22 (ab(a.x),ab(a.y),ab(a.z));}\nc222 ab(c222 a){return c222(ab(a.x),ab(a.y),ab(a.z));}\nc3   ab(c3   a){return c3  (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc33  ab(c33  a){return c33 (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc333 ab(c333 a){return c333(ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n//su() ad() seem to be fine\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\n#define oMg(f,x) f(d00(a.a,a.b.x,a.c.x),d00(b.a,b.b.x,b.c.x))\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)\nv0 su(v0 a,v0 sux\n//v1 su(v1 a,v0 sux\n//v1 su(v0 a,v1 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\nd00 su(d00 a,d00 b){return d00(a.a-b.a,a.b-b.b,a.c-b.c);}\nd11 su(d11 a,d11 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd22 su(d22 a,d22 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd33 su(d33 a,d33 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z);d00 wa=oMg(su,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd333 su(d333 a,d333 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z);d000 wa=omG(su,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\n      \nd33 su(d33 p,v3 s){return su(p,d33(s.x,v3(0),v3(0)));}\nd22 su(d22 p,v2 s){return su(p,d22(s.x,v2(0),v2(0)));}\nd11 su(d11 p,v1 s){return su(p,d11(s.x,v1(0),v1(0)));}\nd00 su(d00 p,v0 s){return su(p,d00(s  ,v0(0),v0(0)));}//this seems VERY nonsensical, to only store .x\n\nd33 su(d33 p,v0 s){return su(p,d33(s,v3(0),v3(0)));}\nd22 su(d22 p,v0 s){return su(p,d22(s,v2(0),v2(0)));}\nd11 su(d11 p,v0 s){return su(p,d11(s,v1(0),v1(0)));}\n      \n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\n\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd3 mu(d3 a,v0 b){return d3(atb\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nd00  mu(d00  a,d00  b){return d00 (a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b);}//dxdx\nd000 mu(d000 a,d000 b){return d000(a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b//dxdx\n,a.c*b.b+a.b*b.c+a.b*b.c+a.a*b.d+a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c);}//dxdxdx\nd11 mu(d11 a,d11 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mu(d22 a,d22 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mu(d33 a,d33 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z);d00 wa=oMg(mu,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mu(d333 a,d333 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z);d000 wa=omG(mu,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}    \nd00  mu(d00  a,v0 b){return mu(a,d00 (b,0.,0.));}\nd000 mu(d000 a,v0 b){return mu(a,d000(b,0.,0.,0.));}\nd11  mu(d11  a,v0 b){return mu(a,d11 (b,v1(0),v1(0)));}\nd111 mu(d111 a,v0 b){return mu(a,d111(b,v1(0),v1(0),v1(0)));}\nd22  mu(d22  a,v0 b){return mu(a,d22 (b,v2(0),v2(0)));}\nd222 mu(d222 a,v0 b){return mu(a,d222(b,v2(0),v2(0),v2(0)));}\nd33  mu(d33  a,v0 b){return mu(a,d33 (b,v3(0),v3(0)));}\nd333 mu(d333 a,v0 b){return mu(a,d333(b,v3(0),v3(0),v3(0)));}//multiply by constant, needed for sqrt()\nc3 mu(c3 p,v3 s){return c3(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z),mu(p.w,s.w));}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//special utility cases come last\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\n    \n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n\n//di() seems to be fine()\nd00  di(d00  a,d00  b){return d00 (a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a));}//dxdx\nd000 di(d000 a,d000 b){return d000(a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a) \n,((((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a)//dxdx\n+(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b)\n+(a.b*b.a-a.a*b.b)*(b.b*b.b+b.a*b.c)))*(b.a*b.a*b.a*b.a)\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n*4.*(b.b*b.a*b.a*b.a))/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a));}//dxdxdx //3rd derivative quotient rule sure is something\nd11 di(d11 a,d11 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 di(d22 a,d22 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 di(d33 a,d33 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z);d00 wa=oMg(di,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}                          \nd333 di(d333 a,d333 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z);d000 wa=omG(di,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\nd00  di(d00  a,v0 b){return di(a,d00 (b,0.,0.));}//needed for min()\nd000 di(d000 a,v0 b){return di(a,d000(b,0.,0.,0.));}//needed for min()\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),y))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define ma2(a,b,c) ma(ma(a,b),c)\n#define ma3fffff(a,b,c,d) ma(ma(a,b),ma(c,d))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n//min(x,y) = (x+y-abs(x-y))/2 == di(ad(x,su(y,ab(su(x,y)))),2.)\n//max(x,y) = (x+y+abs(x-y))/2 == di(ad(x,ad(y,ab(su(x,y)))),2.)\nd00  mi(d00  a,d00  b){return di(ad(a,su(b,ab(su(a,b)))),2.);}\nd000 mi(d000 a,d000 b){return di(ad(a,su(b,ab(su(a,b)))),2.);}     \nd11 mi(d11 a,d11 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mi(d22 a,d22 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mi(d33 a,d33 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z);d00 wa=oMg(mi,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mi(d333 a,d333 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z);d000 wa=omG(mi,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n//dot() takes vectors as input, so we take this one differently, dot() is only defined for c1(vec2) c22(vec3) c33(vec4)\n//dot()always returns a d0(float)\n//the function is ad( (ad(mu(),mu()),  ad(mu(),mu()) )\n//the function is ad( (ad(mu(),mu()),     mu()       )\n//the function is      ad(mu(),mu())\n//and multiplied terms are of type v0\n\n//ST c1  {d1   x;d1   y              ;};//2 domains t,dt   \n//ST d1  {v0   a;v1   b              ;};//2 domains t,dt\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n      \n//the c* inputs can be da_domain1(v*) outputs\nd0   dt(c0   a,c0   b){return       mu(a.x,b.x);}//dotproduct in 2d with 1 derivative (is just mu())\nd00  dt(c00  a,c00  b){return       mu(a.x,b.x);}//dotproduct in 2d with 2 derivative\nd000 dt(c000 a,c000 b){return       mu(a.x,b.x);}//dotproduct in 2d with 3 derivative   \nd1   dt(c1   a,c1   b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 1 derivative\nd11  dt(c11  a,c11  b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 2 derivative\nd111 dt(c111 a,c111 b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 3 derivative   \nd2   dt(c2   a,c2   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 1 derivative\nd22  dt(c22  a,c22  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 2 derivative\nd222 dt(c222 a,c222 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 3 derivative\nd3   dt(c3   a,c3   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 1 derivative\nd33  dt(c33  a,c33  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 2 derivative\nd333 dt(c333 a,c333 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 3 derivative\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\n#define dd(a) dt(a,a)\n//explicit dd() dual type (for uberprim)\n#define dd2(a,b) ad(p2(a),p2(b))\n//multi-dd() (muliple lengths at once)\n#define d2d(a,b)    v1(   dd(a),dd(b))\n#define d3d(a,b,c)  v2(d2d(a,b),dd(c))\n#define d4d(a,b,c,d)v3(d2d(a,b),d2d(c,d))\n         \nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\nv0 sr(v0 a){return sqrt(a);}v1 sr(v1 a){return sqrt(a);}v2 sr(v2 a){return sqrt(a);}v3 sr(v3 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\nd3 sr(d3 a){v0 q=sqrt(a.a);return d3(q,.5*rec(q)*a.b);}//first derivative shortcut is near\nd00  sr(d00  a){return ex(mu(ln(a),.5));}//2nd and 3rd derivative i do not bother with.,\nd000 sr(d000 a){return ex(mu(ln(a),.5));}\nd11  sr(d11  a){return ex(mu(ln(a),.5));}\nd111 sr(d111 a){return ex(mu(ln(a),.5));}\nd22  sr(d22  a){return ex(mu(ln(a),.5));}\nd222 sr(d222 a){return ex(mu(ln(a),.5));}\nd33  sr(d33  a){return ex(mu(ln(a),.5));}\nd333 sr(d333 a){return ex(mu(ln(a),.5));}\n\n/**///--end__: AD functions                    \n/**///--\n/**///--start: analysis common subroutines\n\n\n//compare [a] with [0.0] to return [b]==true or [c]==false\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n  #define    more(a,b,c) ((a> 0.)?b:c)\n//#define    more(a,b,c)             mix(a,b,step(c,0.))\n  #define    less(a,b,c) ((a< 0.)?b:c)\n//#define    less(a,b,c)             mix(a,b,step(0.,c))\n  #define   equal(a,b,c) ((a==0.)?b:c)\n//#define   equal(a,b,c)             mix(b,a,step2\n  #define unequal(a,b,c) ((a!=0.)?b:c)\n//#define unequal(a,b,c)             mix(a,b,step2\n  #define  unless(a,b,c) ((a>=0.)?b:c) \n//#define  unless(a,b,c)             mix(b,a,step(0.,c)) //==greater OR equal\n  #define  unmore(a,b,c) ((a<=0.)?b:c)\n//#define  unmore(a,b,c)             mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n/**///--end__: analysis common subroutines                  \n/**///--\n/**///--start: analysis Hue Gradient Gamma \n\n//rgba colorspace matrices\n      \n#define ut(a,b) (a*(1.-b))          \nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n      \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\n                      \n/**///--end__: analysis Hue Gradient Gamma \n/**///--\n/**///--start: analysis smin      \n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\n//w11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n//);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\n                      \n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(-(a)))  \n                      \nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(1./(a.x+a.y));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;//d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n/**///--end__: analysis smin \n/**///--           \n/**///--start: analysis sabs smoothstep windowfunction hulls\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/**///--end__: analysis sabs smoothstep windowfunction hulls \n/**///--           \n/**///--start: pattern debug\n                               \n//todo,, wallpaper tiling\n                               \n//needed to debug complex (number) functions.\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\n                      \n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n \n\n#define sm(a,b)smoothstep(a-10./500.,a,b)\nfloat PatternCircles(vec2 p,float m//giraffe bubbles of\n){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n              \n/**///--end__: pattern debug\n/**///--\n/**///--start: pattern hash  \n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(v0 a){return vec3(a);}                        \nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(v0 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos2,p.zy),perm2(u5cos2,p.zx),perm2(u5cos2,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+      spd);b*=1.8;z*=1.5;p*=1.2\n//;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos2,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//voronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\n\n// Salt is added to limit the x,y values. No matter what you input,\n// it returns a float [0-5900]\n// may not be a great hash\nfloat salt(float seed){float a=mod(seed,5901.); //coords=vec3(vec2(seed(1.)),0)\n float b=mod(a,2.)==.0?-.01:.11;return a+4179./sqrt(a*5.)*b+1001.*a/seed;}\n      \n/**///--end__: pattern hash            \n/**///--\n/**///--start: pattern noise\n\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL. #version 120\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo without a division\nvec3 mod7(vec3 x){return x-floor(x*(1./7.))*7.;}\nvec4 mod289(vec4 x){return x-floor(x*(1./289.))*289.;}\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec2 mod289(vec2 x){return  x-floor(x*(1./289.))*289.;}\nfloat mod289(float x){return x-floor(x*(1./289.))*289.;}\nvec3 permute(vec3 x){return mod289((34.*x+1.)*x);}//(34*x*34*x+x)mod 289\nfloat permute(float x){return mod289((34.*x+1.)*x);}\nvec4 permute(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n      \n      \n//simplex noise:\nfloat snoise(vec2 v\n){const vec4 C=vec4(.211324865405187 //(3.-sqrt(3.))/6.\n                  , .366025403784439 //sqrt(3.0)*.5-.5\n                  ,-.577350269189626 //C.x*2.-1.\n                  , .024390243902439)//1./41.\n ;vec2 i=floor(v+dot(v,C.yy))\n ;vec2 x0=v-i+dot(i,C.xx)\n ;vec2 ii1=(x0.x>x0.y)?vec2(1,0):vec2(0,1)\n ;vec4 x12=x0.xyxy+C.xxzz\n ;x12.xy-=ii1\n ;i=mod289(i)\n ;vec3 p=permute(permute(i.y+vec3(0,ii1.y,1))+i.x+vec3(0, ii1.x,1))\n ;vec3 m=max(.5-vec3(dd(x0),dd(x12.xy),dd(x12.zw)),0.)\n ;m*=m;m*=m\n ;// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n ;// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n ;vec3 x=2.*fract(p*C.www)-1.\n ;vec3 h=abs(x)-.5\n ;vec3 ox=floor(x+.5)\n ;vec3 a0=x-ox\n ;//Normalise gradients implicitly by scaling m\n ;//Approximation of: m *= inversesqrt( a0*a0 + h*h )\n ;m*=1.79284291400159-.85373472095314*(a0*a0+h*h);\n ;a0=vec3(a0.x*x0.x+h.x*x0.y,a0.yz*x12.xz+h.yz*x12.yw)\n ;return 130.*dot(m,a0);}\n     \n\nfloat snoise(vec3 v\n){const vec2 C=vec2(1,2)/6.\n ;const vec4 D=vec4(0,.5,1,2)\n ;vec3 i=floor(v+dot(v,C.yyy))\n ;vec3 x0=v-i+dot(i,C.xxx)\n ;vec3 g=step(x0.yzx,x0.xyz)\n ;vec3 l=1.-g\n ;vec3 j1=min(g.xyz,l.zxy)\n ;vec3 i2=max(g.xyz,l.zxy)\n ;vec3 x1=x0-j1+C.xxx\n ;vec3 x2=x0-i2+C.yyy\n ;vec3 x3=x0-D.yyy\n ;i=mod289(i)\n ;vec4 p=vec4(0)\n ;p=permute(p+i.z+vec4(0,j1.z,i2.z,1))\n ;p=permute(p+i.y+vec4(0,j1.y,i2.y,1)) \n ;p=permute(p+i.x+vec4(0,j1.x,i2.x,1))\n ;//Gradients: 7x7 points over a square, mapped onto an octahedron.\n ;//ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n ;float n_=1./7.\n ;vec3 ns=n_*D.wyz-D.xzx\n ;vec4 j=p-49.*floor(p*ns.z*ns.z)\n ;vec4 x_=floor(j*ns.z);\n ;vec4 y_=floor(j-7.*x_)\n ;vec4 x =x_*ns.x+ns.yyyy\n ;vec4 y =y_*ns.x+ns.yyyy\n ;vec4 h =1.-abs(x)-abs(y)\n ;vec4 b0=vec4(x.xy,y.xy)\n ;vec4 b1=vec4(x.zw,y.zw)\n ;vec4 s0=u3(floor(b0))\n ;vec4 s1=u3(floor(b1))\n ;vec4 sh=-step(h,vec4(0))\n ;vec4 a0=b0.xzyw+s0.xzyw*sh.xxyy\n ;vec4 a1=b1.xzyw+s1.xzyw*sh.zzww\n ;vec3 p0=vec3(a0.xy,h.x)\n ;vec3 p1=vec3(a0.zw,h.y)\n ;vec3 p2=vec3(a1.xy,h.z)\n ;vec3 p3=vec3(a1.zw,h.w)\n ;a0=taylorInvSqrt(vec4(dd(p0),dd(p1),dd(p2),dd(p3)))\n ;p0*=a0.x;\n ;p1*=a0.y;\n ;p2*=a0.z;\n ;p3*=a0.w\n ;vec4 m=max(.6-vec4(dd(x0),dd(x1),dd(x2),dd(x3)),0.)\n ;m*=m\n ;return 42.*dot(m*m,vec4(dot(p0,x0),dot(p1,x1),dot(p2,x2),dot(p3,x3)));}\n\n//fbm around 3d simplex  https://www.shadertoy.com/view/ldByDy\nfloat snoiseFbm(int octaves,float persistence,float freq,vec3 coords){\n float amp=1.,maxamp=0.,sum=0.;for(int i=0;i<octaves;++i){\n  sum+=amp*snoise(coords*freq);freq*=2.;maxamp+=amp;amp*=persistence;}\n return(sum/maxamp)*.5+.5;}\n      \n//Cellular noise (Worley noise) in 3D in GLSL.\n//returni F1 and F2 (closest and second closest)of Cellular noise (3er neighborhood)\n//subroutines\nvoid twosmolS(inout vec3 a,inout vec3 b,inout vec3 c\n){vec3 d=min(a,b);b=max(a,b);a=min(d,c);c=max(d,c);b=min(b,c);}\nvoid twosmolC(inout vec3 a\n){a.xy=(a.x<a.y)?a.xy:a.yx;a.xz=(a.x<a.z)?a.xz:a.zx;}\nvec2 twosmolE(inout vec3 a,vec3 b\n){a.yz=min(a.yz,b.xy);a.y=miv(vec3(a.yz,b.z));return a.xy;}\nvec2 twoSmallest(vec3 a,vec3 b,vec3 c\n){twosmolS(a,b,c);twosmolC(a);return twosmolE(a,b);}                      \nvec2 twoSmallest(vec3 a,vec3 b,vec3 c,vec3 d,vec3 e,vec3 f,vec3 g,vec3 h,vec3 i\n){twosmolS(a,b,c);twosmolS(d,e,f);twosmolS(g,h,i)\n ;twosmolS(a,d,g);twosmolC(a)\n ;b=min(b,min(min(d,e),min(g,h)));return twosmolE(a,b);}                      \nvec2 twoSmallest(mat3 a,mat3 b,mat3 c\n){return twoSmallest(a[0],a[1],a[2],b[0],b[1],b[2],c[0],c[1],c[2]);}\n\nvec3 makeC(vec3 u,vec2 f,vec3 o,float g,vec3 j){u*=j.y\n ;vec3 x=f.x-g+j.x*(     fract(u)     -j.z)\n ;     u=f.y-o+j.x*(mod7(floor(u))*j.y-j.z);return x*x+u*u;}\n//above makeC() is for 2d, below makeC()&makeB() are for 3d\n//u is permuted hash\n//f,g,w is shift a along (sub)domain\n//o is heretic dark magic\n//j,k are modifiable scalars; j.x sets straightness, range [0..1]\nvec3 makeC(vec3 u,vec2 f,vec3 o,vec3 k,vec3 j){vec3 l=u*k.x   \n ;vec3 a=o  +j.x*     fract(l)        -k.z;\n ;vec3 b=f.x+j.x*mod7(floor(l)   )*k.x-k.z;\n ;vec3 c=f.y+j.x*     floor(u*k.y)*j.y-j.z; \n ;return a*a+b*b+c*c;}\nmat3 makeB(vec3 u,vec4 f,vec3 x,vec3 w,vec3 k,vec3 j\n){vec3 a=makeC(permute(u+w.x),f.wx,x,k,j)\n ;vec3 b=makeC(permute(u+w.y),f.wy,x,k,j)\n ;vec3 c=makeC(permute(u+w.z),f.wz,x,k,j)//3d has one more permute() iteration\n ;return mat3(a,b,c);}\n\n//j.x==straightmess[0..] j.y is like 1/7 j.z is like 1/6\nvec2 cellular(vec2 u,vec3 j\n){vec2 m=mod289(floor(u));u=fract(u)\n ;vec3 w=vec3(-1,0,1)\n ;vec3 v=vec3(-1,1,3)*.5\n ;vec3 r=permute(m.x+w)+m.y\n ;vec3\n  p=permute(r.x+w);vec3 a=makeC(p,u,v,v.x,j)\n ;p=permute(r.y+w);vec3 b=makeC(p,u,v,v.y,j)\n ;p=permute(r.z+w);     p=makeC(p,u,v,v.z,j)\n ;return sqrt(twoSmallest(a,b,p));}              \n//above is 2d, below is 3d vellular noise with 2 shortest distances in 3x neigborhood\nvec2 cellular(vec3 u,vec3 j \n){vec3 k=vec3(j.y,j.y*j.y,.5-j.y)    //this param comes with 2 derivatives\n ;     j=vec3(j.x,j.z,.5*(1.-j.z))//jitter and 1 other param (and one derivative of it)\n ;vec3 m=mod289(floor(u));u=fract(u)-.5\n ;vec3 w=vec3(-1,0,1)\n ;vec3 x=u.x-w;vec3 y=u.y-w;u=u.z-w\n ;vec3 p=permute(m.x+w)+m.y\n ;mat3 a=makeB(permute(p+w.x)+m.z,vec4(u,y.x),x,w,k,j)\n ;mat3 b=makeB(permute(p+w.y)+m.z,vec4(u,y.y),x,w,k,j)     \n ;mat3 c=makeB(permute(p+w.z)+m.z,vec4(u,y.z),x,w,k,j)\n ;return sqrt(twoSmallest(a,b,c));}\n\n// Periodic (tiling) 2-D simplex noise (hexa lattice gradient noise)\n// with rotating gradients and analytic derivatives.\n// Variants also without the derivative (no \"d\" in the name), without\n// the tiling property (no \"p\" in the name) and without the rotating\n// gradients (no \"r\" in the name).\n// axis-aligned and stretched in the y direction for rectangular tiling.\n//\n// periods (p) should be EVEN integers\n// ODD periods for y will automatically be doubled.\n//\n// (rd) makes \"flow noise\" effects\n//\n// vec3 {p}s{r}dnoise(vec2 pos {, vec2 per} {, float rot})\n// \"pos\" is the uv\n// \"per\" is the x and y period, where per.x is a positive integer\n//    and per.y is a positive even integer\n// \"rot\" is the angle to rotate the gradients (any float value,\n//    where 0.0 is no rotation and 1.0 is one full turn)\n//\n//  return.yz are .xy derivatives\n//\n// Copyright (c) 2016 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/stegu/webgl-noise                \n// Author: Stefan Gustavson (stefan.gustavson@gmail.com)\n// Version 2016-05-10.\n// Many thanks to Ian McEwan of Ashima Arts for the\n// idea of using a permutation polynomial.\n//\n// TODO: One-pixel wide artefacts used to occur due to precision issues with\n// the gradient indexing. This is specific to this variant of noise, because\n// one axis of the simplex grid is perfectly aligned with the input x axis.\n// The errors were rare, and they are now very unlikely to ever be visible\n// after a quick fix was introduced: a small offset is added to the y coordinate.\n// A proper fix would involve using round() instead of floor() in selected\n// places, but the quick fix works fine.\n// (If you run into problems with this, please let me know.)\n\n      \n// Hashed 2-D gradients with an extra rotation.\n// (The constant 0.0243902439 is 1/41)\nvec2 rgrad2(vec2 p,float rot){\n#if 0\n  float u = permute(permute(p.x) + p.y) * 0.0243902439 + rot;\n  u=4.*fract(u)-2.;\n  // (This vector could be normalized, exactly or approximately.)\n  return vec2(abs(u)-1.,abs(abs(u+1.)-2.)-1.);}\n#else\n  float u = permute(permute(p.x)+p.y)*.0243902439+rot;\n  u = fract(u) * 2.*pi; // 2*pi\n  return vec2(cos(u), sin(u));}\n#endif\n                      \nfloat NoiseNoDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec3 w=vec3(dot(rgrad2(vec2(iuw.x,ivw.x),rot),a)\n             ,dot(rgrad2(vec2(iuw.y,ivw.y),rot),b)\n             ,dot(rgrad2(vec2(iuw.z,ivw.z),rot),c))     \n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c));t*=t\n ;return 11.*dot(t*t,w);}\n//above and below are TAIL subroutines, wuith or without derivatives       \nvec3 NoiseDer(vec3 iuw,vec3 ivw,float rot,vec2 a,vec2 b,vec2 c\n){vec2 d=rgrad2(vec2(iuw.x,ivw.x),rot)\n ;vec2 e=rgrad2(vec2(iuw.y,ivw.y),rot)\n ;vec2 f=rgrad2(vec2(iuw.z,ivw.z),rot)\n ;vec3 w=vec3(dot(d,a),dot(e,b),dot(f,c))\n ;vec3 t=.8-vec3(dd(a),dd(b),dd(c))\n ;if(t.x<0.){a.x=0.;a.y=0.;t.x=0.;}\n ;if(t.y<0.){b.x=0.;b.y=0.;t.y=0.;}\n ;if(t.z<0.){c.x=0.;c.y=0.;t.z=0.;}\n ;vec3 t3=t*t*t;t*=t;t*=t\n ;a=a*8.*t3.x;a=t.x*d-a*w.x\n ;b=b*8.*t3.y;b=t.y*e-b*w.y\n ;c=c*8.*t3.z;c=t.z*f-c*w.z\n ;return 11.*vec3(dot(t,w),a+b+c);;}\n\nvoid NoiseHead(vec2 u,inout vec3 x,inout vec3 y\n       ,inout vec2 d0,inout vec2 d1,inout vec2 d2\n       ,inout vec2 p0,inout vec2 p1,inout vec2 p2\n){u.y+=.001\n ;vec2 uv=vec2(u.x + u.y*0.5, u.y)\n ;vec2 j0=floor(uv)\n ;vec2 f0=fract(uv)\n ;vec2 j1=(f0.x>f0.y)?vec2(1,0):vec2(0,1)\n ;p0=vec2(j0.x-j0.y*.5,j0.y)\n ;p1=vec2(p0.x+j1.x- j1.y*.5,p0.y+j1.y)\n ;p2=vec2(p0.x+.5,p0.y +1.)\n ;j1=j0+j1\n ;vec2 i2 = j0 + vec2(1)\n ;d0=u-p0;d1=u-p1;d2=u-p2\n ;x=vec3(p0.x, p1.x, p2.x)\n ;y=vec3(p0.y, p1.y, p2.y);}\n\n//4 comboinations with rotation\nvec3 simplexRotD(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nvec3 simplexRotD(vec2 u,float rot\n){vec2 d0,d1,d2,p0,p1,p2;vec3 x,y;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)        //without TilingPeriod \n ;return NoiseDer(x,y,rot,d0,d1,d2);}     //with    Detivatives  (.yz)\nfloat simplexRot(vec2 u, vec2 p, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=mod(vec3(p0.x,p1.x,p2.x),p.x)\n ;y=mod(vec3(p0.y,p1.y,p2.y),p.y);x=x+.5*y//with    TilingPeriod (p)\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}   //without Detivatives               \nfloat simplexRot(vec2 u, float rot\n){vec3 x,y;vec2 d0,d1,d2,p0,p1,p2;NoiseHead(u,x,y,d0,d1,d2,p0,p1,p2)\n ;x=x+.5*y;x=mod289(x);y=mod289(y)       //without TilingPeriod\n ;return NoiseNoDer(x,y,rot,d0,d1,d2);}  //without Detivative   (.yz)\n//without rotation\nvec3  simplexRotD(vec2 u,vec2 p){return simplexRotD(u,p,0.);}//tiling derivative\nvec3  simplexRotD(vec2 u       ){return simplexRotD(u  ,0.);}//       derivative\nfloat simplexRot (vec2 u,vec2 p){return simplexRot (u,p,0.);}//tiling\nfloat simplexRot (vec2 u       ){return simplexRot (u  ,0.);}\n\n/**///--end__: pattern noise\n/**///--                         \n/**///--start: complex triginometry \n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c22(c)-(c.a-c.b*i)\n#define c22(a)c4(anaa(a)).xy  //namespace conflict\nvec2 cs(v1 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(v0 a){return cs(vec2(a,a));}    \n                               \n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\nd000 ata(d000 a){v0 b=a.a*a.a+1.;v0 c=b*b;return d000(atan(a.a),a.a/b,-(b-2.)/b,2.*a.a*(a.a-4.)/(b*c));}\nd00  ata(d00  a){v0 b=a.a*a.a+1.;v0 c=b*b;return d00 (atan(a.a),a.a/b,-(b-2.)/b);}\nd0   ata(d0   a){v0 b=a.a*a.a+1.;v0 c=b*b;return d0  (atan(a.a),a.a/b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}\n\n/*\nd00 atand(d00 x,d00 y){//return atan(y,x);//2 branches, goes full circle.\n if(x.a >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}/**/\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\nv0 su(v1 a){return a.x-a.y;}\n\n#define le(a) sqrt(dd(a))\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2  \n//real and imaginary parts for polar z\nv0 arg(v1 a){return atan(a.y,a.x);}\nv1 p2c(v1 a){return v1(co(a.x),si(a.x))*a.y;}     //return carthesian of polar\nv1 c2p(v1 a){return v1(arg(a),le(a));}            //return polar      of carthesian\nv0 real(v1 z){return p2c(z).x;return z.s*co(z.t);}//return real       of carthesian\nv0 imag(v1 z){return p2c(z).y;return z.s*si(z.t);}//return imaginary  of carthesian\n\nv1 crCo(v1 a){return sqrt(length(a)+c22(a.x));}//core of complex root function,lacks sign adjustment and scaling!\n\nv1 ciCo(v1 u,v1 z,v0 r){return v1(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nv1 sqc(v1 a){v0 n=a.x+length(a);return v1(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nv3 sqc(v3 a){v3 c=v3(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nv1 po2c(v1 c){v1 d=c*c;return v1(d.x-d.y,2.*c.x*c.y);}//v1 po2c(v1 a){return muc(a,a);return v1(sub(a*a),2.*a.x*a.y);}//complex square\nv1 po3c(v1 z){v0 p=z.x*z.x,q=z.y*z.y;return z*v1(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nv1 recc(v1 a){if(a.x==0.)return v1(1e10);return c22(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nv1 lgc(v1 a){a=c2p(a);a.x=log(a.x);return a;}//return v1(log(dd(a))*.5,arg(a));}\nv3 lgc(v3 a){return v3(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nv1 suc(v1 a,v1 b){return a-b;}v1 adc(v1 a,v1 b){return a+b;}///complex addition is trivial\nv1 muc(v1 a,v1 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nv1 muc(v1 a,v1 b,v1 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nv1 muc(v3 a){return muc(a.xy,a.zw);}//parallel mult\nv1 dic(v1 a,v1 b){if(a.x==0.)return v1(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nv1 lgc(v1 a,v1 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nv1 lgc(v1 a,v0 c){return v1(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nv1 exc(v1 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//v1 lgc(v1 a,v0 c){a=c2p(a);return v1(log(a.x),a.y+c*tau);}//should be the same!\nv1 poc(v1 a,v1 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nv1 poc(v1 w,v1 z,v0 c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nv1 lgc(v1 a,v1 b,v0 c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nv1 wrtc(v1 a,v1 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nv1 wrtc(v1 a,v1 b,v0 c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//v1 sqc(v1 z){v1 c=sqrt((length(z)+c22(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\n\nv1 sic(v1 z){return .5*cs(z.x).yx*(exp(z.y)+c22(exp(-z.y)));}//v1 sic(v1 z){return v1(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  v1 sic(v1 c){v1 d=exp(c2(c.y));return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 si2c(v1 c){v1 d=v1(exp(c.y),1);return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 coc(v1 z){return .5*c22(cs(z.x))*(exp(z.y)+c22(exp(-z.y)));}\n\n//obsoleted v1 coc(v1 z){ return v1(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted v1 coc(v1 c){v1 d=exp(c2(c.y));return v1(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nv1 ta2c(v1 c){v1 d=exp(c22(c.y));v0 e=cos(c.x),s=(d.x-d.y)*.5;return v1(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nv1 tac(v1 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nv1 cotc(v1 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nv1 sihc(v1 z){return .5*cs(z.y)*(exp(z.x)+c22(exp(-z.x)).yx);}//v1 sinh(v1 z){ return 0.5*v1((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//v1 sinh2c(v1 z){z=c22(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nv1 cohc(v1 z){return coc(c22(z.yx));}//v1 cosh(v1 z){ return v1(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 v1 tahc(v1 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 v1 cothc(v1 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(v1 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 v1 cschc(v1 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nv1 arsic(v1 z){return c22(lgc(perp(z)+sqc(c22(po2c(z.yx)))+v1(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//v1 arsic(v1 z){v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(-z.y+a.x,z.x+a.y));return v1(a.y,-a.x);}\nv1 arcoc(v1 z){return-c22(lgc(z+c22(sqc(po2c(z.yx)+v1(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//v1 arcoc(v1 z){ v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(z.x+a.y,z.y-a.x));return v1(-a.y,a.x);}\nv1 csec(v1 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nv1 ccsc(v1 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nv1 arcotc(v1 z){v0 r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((v3(z.yx,-z.yx)+v3(r,0,r,0)).yxzw/r)))*.5;}//v1 arcotc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=lgc(v1(p+q-z.y,-z.x)/r);v1 b=lgc(v1(p+q+z.y,z.x)/r);return v1(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nv1 artac(v1 z){return sub2(c4(lgc(v3(1,0,1,0)-c22(z.yx).xyxy).yxwz))*.5;}//v1 artac(v1 z){ v1 a=lgc(v1(1.0+z.y,-z.x));v1 b=lgc(v1(1.0-z.y,z.x));return v1(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nv1 arcsec(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(sub2(c4(v3(z,sqc(ciCo(u,z,r)).yx)))).yx)+v1(0.,log(r));}//v1 arcsec(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(z.x-a.y,a.x-z.y));return v1(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nv1 arccsc(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+v1(0.,log(r));}//v1 arccsc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(a.x+z.y,a.y+z.x));return v1(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nv1 arcsch(v1 z){v1 u=z*z;v0 r=su(u);return lgc(c22(z)+sqc(ciCo(u.yx,z,r)))-v1(0,log(r));}//v1 arcsch(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r+p-q,-2.0*z.x*z.y));a=lgc(v1(a.x+z.x,a.y-z.y));return v1(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nv1 arsinh(v1 z){return lgc(z+sqc(po2c(z)+v1(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nv1 arcosh(v1 z){return lgc(z+muc(sqc(z.xyxy+v3(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nv1 artanh(v1 z){v0 r=1.-su(z*z);z*=2.;return .5*lgc(-v1(r,z.y)/(r+z.x));}//v1 artanh(v1 z){v0 r=z.x*z.x+z.y*z.y;return lgc(v1(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nv1 arcoth(v1 z){;v0 r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(v1(r,z.y)/(r+2.+z.x));}//v1 arcoth(v1 z){ v0 r=z.x*z.x+z.y*z.y;return lgc(v1(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nv1 arsech(v1 z){v0 r=su(z*z);return lgc(c22(z)+muc(sqc(v3(-r,0,r,0)+c22(z).xyxy)))-v1(log(r),0);}//ok-ollj\n                \nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a;}                         \n                               \n\n/**///--end__: complex triginometry \n/**///--\n/**///--start: sort\n                               \n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nint getPosLarge(vec3 a//return position of largest  value [0..2]          \n){if(a.x>a.y){if(a.x>a.z)return 0;if(a.y>a.z)return 1;return 2\n       ;}else{if(a.y>a.z)return 1;return 3;}}\nint getPosSmall(vec3 a//return position of smallest value [0..2]          \n){if(a.x<a.y){if(a.x<a.z)return 0;if(a.y<a.z)return 1;return 2\n       ;}else{if(a.y<a.z)return 1;return 2;}}\nint getPosMid(vec3 a//return position of middle value [0..2]          \n){if(a.x<a.y){if(a.y<a.z)return 1;if(a.z<a.x)return 0;return 1  \n       ;}else{if(a.z<a.y)return 1;if(a.x<a.z)return 1;return 3;}}\nvec3 getPosLargeV(vec3 a){vec3 r=vec3(0);r[getPosLarge(a)]=1.;return r;}//return vector that indicates smalles value with a [1]   \nvec3 getPosSmallV(vec3 a){vec3 r=vec3(0);r[getPosSmall(a)]=1.;return r;}//return vector that indicates smalles value with a [1]\n//vec3 getPosMidV  (vec3 a){return vec3(1)-getPosLargeV(a)-getPosSmallV(a);}//dumb and slow but works\n      \n\n      \nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n\n                 \n//project point [a] onto line trough vecN(0) and vecN([b])\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\n\nd3 suab(d3 p,v0 s){return su(ab((p)),s);}\nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\nd33 suab(d33 p,d33 s){return su(ab((p)),s);}           \nd22 suab(d22 p,d22 s){return su(ab((p)),s);}\nd11 suab(d11 p,d11 s){return su(ab((p)),s);}\nd00 suab(d00 p,d00 s){return su(ab((p)),s);}\nd333 suab(d333 p,d333 s){return su(ab((p)),s);}           \nd222 suab(d222 p,d222 s){return su(ab((p)),s);}\nd111 suab(d111 p,d111 s){return su(ab((p)),s);}\nd000 suab(d000 p,d000 s){return su(ab((p)),s);}\n//suab extendsions have been frustrating and halted                    \n                      \nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z),suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//c22 suab(c22 p,v2 s){return c22(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\n\n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}\n      \n/**///--end__: common aliases\n/**///\n/**///--start: linear hulls smoothstep\n\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n      \n#define fsaa 2.\n//#define fsaa 2, (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n/**///--end__: linear hulls smoothstep\n/**///\n/**///--start: Reflect and rotate            \n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\nv1 r4(v1 r){return v1(r.y,-r.x);}//perpendicular quater rotation\n                      \nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\n\n//return distance to 1/24th rotated axis (for super fast arrow shape)\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(v0 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(v0 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n        \n//modify inputs to abs(.x) == mirror vertically\nvoid mirror(inout vec2 u,inout vec2 m){m.x=abs(m.x);u.x=abs(u.x);}\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r1(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n//float angleBetween(v1 a,v1 b){return acos(dt(a,b);}\n\n//Quaternion\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dd(a)! \nv3 qn(v3 q){return q/dd(q);}\n/**/\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n                      \n/**///--end__: Reflect and rotate  \n/**///--\n/**///--start: analytic closed-form  solutions \n\nv0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n\n//(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}//used to get closest point on ellipse: https://www.shadertoy.com/view/XttyWN\n\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n \n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n/**///--end__: analytic solutions  \n/**///--\n/**///--start: euclidean tracing\n\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection of lines AB and CD; http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n    \n//return how far (p) is in front of ray/normal (ut), [>0],or on (u)[=0], or behind (u)[<0] (along the ray)\nfloat isInfront(vec2 u,vec2 t,vec2 p){return dot(p-u,t-u);}\n//isInfront doesnt care for zFar,isWithin asserts (t] to be zfar\n//use isWithin to check if a lineLineIntersection is within a segment.   [<]0for false, >=0 true\nfloat isWithin(vec2 u,vec2 t,float r\n){if(r>=0.){\n ;if(dd(t-u)<=r*r)return r;\n };return -1.;}\n//above already has a cached dotproduct.\nfloat isWithin(vec2 u,vec2 t,vec2 r){r.x=isInfront(u,t,r);return isWithin(u,t,r.x);}\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his mit licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n//The MIT License\n//Copyright © 2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 vv0,vec3 vv1,vec3 vv2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=vv0-vv1\n ;vec3 b=vv2-vv0\n ;vec3 p=vv0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright © 2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(miv(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n// Slightly improved version of a Trapezoid primitive without flicking.\nfloat sdTrapezoidFixed(vec2 u,vec2 a,vec2 b,float ra,float rb\n){u-=a;b-=a;float c=dd(b)\n ;a=vec2(abs(dot(perp(u),b))/sqrt(c),dot(u,b)/c)\n ;b.x=rb-ra;b.y=sat((b.x*(a.x-ra)+a.y*c)/(b.x*b.x+c))\n ;vec4 r=vec4(ma0(a.x-((a.y<.5)?ra:rb)),abs(a.y-.5)-.5,a.x-ra-b.y*b.x,a.y-b.y)\n ;a.x=sign(mav(r.zy));r*=r;r.yw*=c;r.xz+=r.yw\n ;return a.x*sqrt(miv(r.xz));}//https://www.shadertoy.com/view/wtSyWc\n\n      \n/**///--end__: euclidean tracing\n/**///--\n/**///--start: AD-/mercury.sexy/hd_sdf\n\n//euclidean tracing[line line intersection] is needed for some shapes here\n                      \n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n           \n                      \n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n\n//pmod() got killed by su() incompatibility\n//#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\n////frflpm(v00,c00)  frflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)  //high domain su() incompatibility\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n                      \n//float ma(vec4 a){return 0.;}\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\n     /* killed by incompatibility                 \nfloat Blob(vec3 p){p=abs(p);p=mix(p,p.yzx,step(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n/**/\n#define fPlane(p,n,d) ad(dt(p,n),d)\n      \n      \n      \nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\n/*  old struct fr() incompatibility\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fr(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}*/\n\n           \n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\n\nconst float eRm=.0001;\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n\n//https://en.wikipedia.org/wiki/Moss%27s_Egg\n#define EarVagEgg moss\n#define CylEarVagEgg cylMoss\n//moss() is still far from standardized. rac is the central radius, should be parametric.\nfloat moss(vec2 u,vec3 m//m.x+m.xy<=1. is relevant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //cylMoss() is capped cylinder to extrude it to 3d.\nfloat moss(vec2 u,vec2 m){return moss(u,vec3(m,mix(.5,3.,sin(1.)*.5+.5)));} //ain(1.) was iTime\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(moss(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//cylMoss() is capped cylinder to extrude it to 3d.\nfloat cylMoss(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\n//distance from (u) to lenss nut hourglass (rd) (radius,circleCenterDistances)\nfloat vesica(vec2 u,float r,float d\n){u=abs(u);float b=(r*r-d*d);vec2 a=vec2(u.y*d,u.x+d);a*=a*sign(a)\n ;return((a.x/b>a.y))?length(u-vec2(0,sqrt(b)))*sign(d)\n                     :length(u+vec2(d,0))-r;}//https://www.shadertoy.com/view/XtVfRW\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat sdHorseshoe(vec2 p,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;p.x=abs(p.x)\n ;float l=length(p)\n ;p=mat2(-c.x,c.y,c.y,c.x)*p\n ;p=vec2((p.y>0.)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l )\n ;p=vec2(p.x,abs(p.y-r))-w.xy\n ;return length(max(p,0.)+min(mav(p),0.))   -w.z;\n ;//return length(ma0(p))+mi0(mav(p))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n\n      \n                      /*\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n/**/\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}  \n\n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n\n){float s=r/n\n ;float u=b-r\n ;return mi(mi(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\n      \n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n\n\n/**///--end__: AD mercury.sexy/hd_sdf\n/**///--\n/**///--start: projections\n                      \n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv22 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=vec2(0)//-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*1.)//autopilot //*iTime\n ;m=vec2(1)//mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v22(pos,dir);}\n\n//Phong+debugPlanes\n//todo (fix df() nonsense\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n                      \n                      \n/**///--end__: projections  \n/**///--\n/**///--start: AD Superprims\n      \nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//odsoleted by cir()\n/*\n#define abm(a,b) (abs(a)-b)  //ditance taxicap   -b\n#define lbm(a,b) (length(a)-b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))   //==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a)) //i am not convinced by this one\n//#define box(a,b) roundit(abm(a,b))\n/**/\n      \n//cir()  return distance of (u) to (rounded) box/circle/AxisAlignedLineSegment\n//yes, thats a lot of basic shapes\n//called cir() because all lowest LOD are boxes.\n//cirS() seperates polynomials to allow to delay the sqrt() \n//       of ALL boxes with the same thickness (if tree-branch-thicknesses are uniform)\n//       by getting sqrt(min(multiple squared values))\n//cirS() header exists with and without stretching(&automatic offset)\n//\n//u=uv point\n//b.x=thickness\n//b.y=cornerRoundness [0..1] interpolates between circle and boxRounded\n//lod=LoD lod==0 is always a square\nvec2 cirCore(vec2 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\nvec2 cirCore(vec3 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\n\n//cir header without stretch\nvec2 cirS(vec2 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\n\n//cir header with stretch option\n//s=size stretch\n//positibes are useful for segments/boxes\n//negative inputs create ray/wedge (wedge interiors (2 negative domains) are only good within +-b.x)\n//s=vec2(0,-1) creates an upwards ray, af moves the base up, till vec2(0) touches the bottom\n//s=vec2(1,0) stretches by 1 along .x and moves to the right till vec2(0) is on the surface.\n//any s>0 will create a line segment, where vec2(0) is on the surface, iff one other domain of s==0\nvec2 cirS(vec2 u,vec2 b,float l,vec2 s\n){bvec2 e=lessThan(s,vec2(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;e=greaterThan(s,vec2(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l,vec3 s\n){bvec3 e=lessThan(s,vec3(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;if(e.z){u.z-=b.y*.5;s.z=0.;u.z=min((u.z),0.);}\n ;e=greaterThan(s,vec3(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;if(e.z)u.z-=(s.z+b.y)*.5 \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\n\nfloat cir(vec2 u,vec2 b,float l,vec2 s){u   =cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec2 u,vec2 b,float l       ){u   =cirS(u,b,l  );return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l,vec3 s){u.xy=cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l       ){u.xy=cirS(u,  b,l);return more(u.x,sqrt(u.x),0.)+u.y;}\n\n//without LoD (default to 1.)\nfloat cir(vec2 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec2 u,vec2 b,vec2 s){return cir(u,b,1.,s);}\nfloat cir(vec3 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec3 u,vec2 b,vec3 s){return cir(u,b,1.,s);}\n\n//without lod & with maximum roundness (b and s swapped to avoid namespace conflict with self)\nfloat cir(vec2 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec2 u,float b,vec2 s){return cir(u,vec2(b,1.),s);}\nfloat cir(vec3 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec3 u,float b,vec3 s){return cir(u,vec2(b,1.),s);}\n//cir was tested in 2d, but 3d may have typos?)\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat horseshoe(vec2 u,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;float circle=length(u)-w.z\n ;u.x=abs(u.x)\n ;u=mat2(-c.x,c.y,c.y,c.x)*u\n ;float l=length(u)\n ;u=vec2((u.y>0.)?u.x:l*sign(-c.x),(u.x>0.)?u.y:l)\n ;u=vec2(u.x,abs(u.y-r))-w.xy;\n ;return length(max(u,0.))+ min(0.,max(u.x,u.y))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n      \n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=vec2(0)//iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(mav(dt(p,y))-o.x*3.,sqrt(miv(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\n                      \nstruct v14{float a;vec4 b;};\n                      \nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//guessing this was what this one does\n                      \nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=.5 //iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n                      \n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n             \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\n\n                      //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r){return max(box(u,vec3(r)),fOctahedron(u,r));}\n\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\n //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n                      \n/**///--end__: AD Superprims\n/**///--\n/**///--start: Glyphs\n\nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n                      \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n/**///--end__: Glyphs\n/**///--\n/**///--start: AD march RayMarchingPrimitivesBasic                 \n                      \n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}\n\n//#u,o,t) distance between (u) and segment  from   (o) to     (t)   (strethed dot always does sqrt)\n//    ray(u,o,t) distance between (u) and ray      from   (o) trough (t)   \n//   line(u,o,t) distance between (u) and line     though (o) trough (t)  \n//    ray(u)     distance between (u) and ray      from (0,0) trough (0,1) \n#define segment2(a,c,d) dd(su(a,mu(c,d(di(dt(a,c),dd(c))))))      \n#define segments(u,o,t,d) (segment2(su(u,o),su(t,o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n#define    line(u,o,t) sqrt(segments(u,o,t,nul))\n#define rAy(c) float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}\nrAy(v0)rAy(v1)rAy(v2)rAy(v3)\nfloat ray(v1 u){if(u.x>0.)return length(u);return u.y;}   \n\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\n/**///--end__: march RayMarchingPrimitivesBasic\n/**///follows:\n/**///--start: march bezier \n\n//[follows], because segment() is special case of bezier()\n   \n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n                      \n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b));}\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L){v1 l=p2-p0;float s=L*L//https://www.shadertoy.com/view/4ltyWr\n ;return .5*((p0+p2)+sqrt(max(0.,s-dot(l,l)))*sign(L)*norma(v1(-l.y,l.x)));}\n\n/**///--end__: march bezier \n/**///--\n/**///--start: RE mach RayMarchingPrimitivesBasic (with global for relativity)                  \n\n                      \nv0 maxGISize;//what is this?\n                      \nv0 sphere(v3 ray,v2 u, v0 radius\n){maxGISize = max(maxGISize,radius*ray.w)\n ;return ray.w*(length(ray.xyz-u)-radius);}\nv0 cylinderY(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize=max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xz-u.xz)\n -radius, abs(ray.y-u.y)-height));}\nv0 cylinderZ(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize = max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xy-u.xy)\n -radius, abs(ray.z-u.z)-height));}\nv0 cube(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n\nv0 REbox(v3 ray, v2 u, v2 size\n){maxGISize = max(maxGISize,length(size)*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}   \n\n//c.xy=sin/cos of angle. r is the radius //uppr segment is always round\nfloat pieSlice(vec2 u,vec2 c,float r //a simple packman\n){u.x=abs(u.x)\n ;v0 l=length(u)-r\n ;v0 m=length(u-c*clamp(dot(u,c),0.,r) )\n ;return max(l,m*sign(c.y*u.x-c.x*u.y));}//https://www.shadertoy.com/view/3l23RK\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he\n){vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dd(k2), 0., 1. );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0\n   ;return s*sqrt( min(dd(ca),dd(cb)));}//https://www.shadertoy.com/view/MlycD3\n\n//polygon distance does crossingCumbers, has better (rounded) interios than windingnumbers.\nconst int N = 5;\nfloat sdPoly(vec2[N] v, in vec2 p\n){const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }return s*sqrt(d);}//https://www.shadertoy.com/view/wdBXRW\n      \n/**///--end__: RayMarchingPrimitivesBasic\n/**///--\n/**///--start: Relativity\n\n\n//bellow code is RE7:\n                          /*\nrelativistic engine, with mutable/slower speedOfLight\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\nblatantly false\n- shadows are unaffected by gravity\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow\nDoes not simulate:\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- Mass of object\n/**/\n//ESDF keyboard layout is more compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//light settings\n#define cSpe 2.5\n//SpeedOfLight in meter/second\n//divides by /(cSpe*cSpe), so do not make it too large!\n#define cLag 1.\n//PhotonLatency [0..1]; zero=instant vision,makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1.\n//take relative velocity of photons to camera & distort field of view\n//optical settings\n#define dopplerFactor .5\n//take player/object/light vel to shift color\n#define repeatDoppler 0\n//relativity\n#define LgthContraction  1.\n//shrink map along velocity vector at high speed\n#define TimeDilation 1.\n//speed map frame time at high speed\n#define SimultaneousEvents 1.\n//see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2\n//take light source speed into account and their own time dilation\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n//player and cam\n#define fishEye false\n#define FOV 1.3\n//1.57 = 90\n#define maxSpeed 2.4\n//do not go over speed of light it breaks time & space\n#define thrustForce 15.\n//player acceleration\n#define RayPrecision 1.\n#define MaxRayDist 9.0\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n#define gravity v2(0.,-3.,0.)\n                      \n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = o;\n#define endMaterial() } if (o != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\ni0 nextMat;\ni0 rayMat;\ni0 rayObj;\nv0 matSize;\nv0 lastrDist;\nv0 lastrDistObj;\nv3 volumetricCol;\n//BuffCoords of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer]\n//- 0<=x<Resolution.xy\n#define RePos   0.\n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n#define ReTime  5.\n#define ReCol   6.  //not used by Image\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\nv0 varWdth=1.;\n//#define ReTraT  9.  \n//v0 PROPER_D_POS = 8.;\n//v0 TRAIN_TIME = 9.;\n\n                      /*\n//v0 varWdth = 5.;\n/*\nv0 POS = 0.;\nv0 D_POS = 1.;\nv0 DD_POS = 2.;\nv0 QUAT = 3.;\nv0 D_QUAT = 4.;\nv0 TIME = 5.;\nv0 COLLISION = 6.;\nv0 CAM_PITCHYAW = 7.;\nv0 PROPER_D_POS = 8.;\nv0 TRAIN_TIME = 9.;\n*/\n\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays of structparams: \n#define objNum 7\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n//for below object properties;\nv3 [objNum] objRot;//rotation\nv2 [objNum] objPos;//position\nv2 [objNum] objVel;//velocity\nv2 [objNum] objSca;//scale\n//v0[objNum] objRad;//radius optimization\n//\n                      \n//lights have no labels\nv3[numLights] oliCol;//colorIntensity;\nv2[numLights] oliPos;//position\nv0[numLights] oliHal;//HaloResult\n//v0[numLights] oliSiz;//size\nv0 lorentzF;\n//mat3x3 LZLgthContract;\nv2 pos;\n//v2 dpos;\nv0 playerTime;\nint curObj = 0;//es100 error , first class array\nint minObjDepth = -1; \n                      \n//DopplerShift\nv0 GetMatch(v2 c,v2 s,v0 t //col,shiftedFreq,targetFreq\n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;c*=max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.)\n #else\n ;c*=max(v2(0),1.-abs(s)*3.)\n #endif\n ;return c.x+c.y+c.z;}\n//dopplerShiftFactor\nv2 dsf(v2 c,v2 f//all values of f are identical.\n){f*=v2(1.,1.257,1.58)\n ;v2 r=v2(1,2,4)/3.\n ;return v2(GetMatch(c,f,0. )+GetMatch(c,f,1.)*.3+GetMatch(c,f,-r.x)*.2\n             ,GetMatch(c,f,r.x) \n             ,GetMatch(c,f,r.y)+GetMatch(c,f,1.)*.5+GetMatch(c,f,r.z)*.25);}\nv2 dsf(v2 c,v0 f){return dsf(c,v2(f));}\n//v2 DopplerShift(v2 c,v0 s//color,speed\n//){return dsf(c,v2(cSpe/(cSpe-s*dopplerFactor)));}\nv3 Transform(int i,v3 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(v2(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\nvoid ProcessCamPos(v2 u, v3 rot\n){objPos[oCam]= u\n ;objRot[oCam]=rot;}//es100 error , no array of class allowed\nv0 LorentzFactor(v0 v//velocity\n){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\nv2 dpos;//relevant for each pixel of [RE] and [Image] \nvoid ProcessObjectPos(v0 time\n){objPos[oCubeMy]=v2(0) \n ;objRot[oCubeMy]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oCubeMy]=v2(.8)//es100 error , no array of class allowed\n ;objPos[oBlackHole]=v2(5.,sin(time*0.2),-5.)//es100 error , no array of class allowed\n ;objRot[oBlackHole]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oBlackHole]=v2(1)//es100 error , no array of class allowed\n ;objPos[oCubeChil]=v2(1)//es100 error , no array of class allowed\n ;objRot[oCubeChil]=aa2q(time*1.,norma(objPos[oCubeChil]))//es100 error , no array of class allowed\n ;//o_myCubeChildren.rot = v3(0,0,0,1)\n ;objSca[oCubeChil]=v2(.4)//es100 error , no array of class allowed\n ;v0 trainV = 2.2\n ;objVel[oTrain]= v2((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0)//es100 error , no array of class allowed\n ;v0 trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.//es100 error , no array of class allowed\n ;objPos[oTrain]=v2(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTrain]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTrain]= v2(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;//objects[o_train].b.x = 0.//es100 error , no array of class allowed\n ;objPos[oTunnel]=v2(0,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTunnel]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTunnel]=v2(1.,1.,1)//es100 error , no array of class allowed\n ;objPos[oTunnelDoor]=objPos[oTunnel]//es100 error , no array of class allowed\n ;objRot[oTunnelDoor]=objRot[oTunnel]//es100 error , no array of class allowed\n ;v0 open = clamp((1.-abs(3.*objPos[oTrain].x))*2.,0.,1.)//es100 error , no array of class allowed\n ;objSca[oTunnelDoor]= v2(open,open,1);}//es100 error , no array of class allowed\n//es100 error , no array of class allowed\nvoid ProcessLightValue(v0 t\n){oliPos[0]=v2(6.,1.,sin(t))\n ;oliCol[0]=3.*v3(0.2,1.,.2,1)\n ;oliPos[1]=v2(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*v3(1,1,0.5,1)\n ;oliPos[2]=v2(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*v3(1,.2,1,1);}\nvoid SetTime(v0 t){ProcessLightValue(t);ProcessObjectPos(t);}//es100 error , no array of class allowed\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n#define VOL(func)  if (func < rDist)\n//volume marching accumulator, used for blackHoleAccretionDisk\nv0 vma=0.;\nv0 map(v2 pos, int processedMaterial\n){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise\n ;maxGISize = 0.\n ;rayObj = 0\n ;v3 w = v3(pos,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(REbox(w,v2(0,0,0),v2(10,2.5,10)))\n ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))\n ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))\n ;endMaterial()\n ;v3 c=beginObj(oCubeMy,w)//cubespace, not color\n ;//ADD(REbox(c,v2(0,0,0),v2(1)))\n ;//c.xz = abs(c.xz)\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(sphere(c,v2(0,0,0),1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;v3 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))\n ;endMaterial()\n ;v3 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(REbox(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))\n ;ADD(REbox(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))\n ;endMaterial()\n ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(REbox(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))\n ;ADD(REbox(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))\n ;endMaterial()\n ;v3 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(REbox(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0)      ,v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))\n ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0; L<3; L++\n ){\n  ;ADD(sphere(w,oliPos[L]\n              //o_lights[L].b\n              ,0.001))\n  ;\n  ;v2 relPos = oliPos[L]-pos//o_lights[L].b\n  ;oliHal[L]//o_lights[L].haloResult \n      += o*(0.02/(dot(relPos,relPos)+0.01))\n  ;}\n ;return o;}\nv3 GetNormal(v2 u\n){v1 e = v1(0.003,0.)\n ;v0 o=map(u,-1)\n ;return v3(norma(v2(map(u+e.xyy,-1)\n                    ,map(u+e.yxy,-1)\n                    ,map(u+e.yyx,-1))-o),o);}\n\n//--end__: Relativity\n//--\n//--start: barycentric\n\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant\nfloat c2bdet(vec3 X,vec3 Y){return 1./suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//return barycentric of carthesian point (l) over triangle (a,b,c)==(X,Y)\nvec3 c2b(vec2 p,vec3 X,vec3 Y,float d){p-=vec2(X.z,Y.z)\n ;vec4 a=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*p.xyxy\n ;p=vec2(suv(a.xy),suv(a.zw))*d;return vec3(p,1.-p.x-p.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\n      vec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}\n\n//return 3 squared lengths of triangle sides of triangle (a,b,c)\nvec3 getSqoaredLengths(vec2 a,vec2 b,vec2 c){return d3d(a-b,b-c,c-a);}\n//return SQUARED length of vector (p) in barycentric coordinates\n//t=getSqoaredLengths(a,b,c) is intended to be buffered\nfloat lengthBary(vec3 p,vec3 t){return -suv(t*p.yxx*p.zzy);}\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Distance_between_points               \n\n     \n//shortest carthesian distance may be different than euclidean. even to the 3 points??\n//anyways, this is buggy, and i cant find the bug.\n\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\n      \nfloat segmentB(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\n\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){const float twothirds=2./3.\n   ;if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float carthesianDet=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //carthesianDet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //carthesianDet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,carthesianDet)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segmentB(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n /*\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{/**/\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segmentB(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}\n  //min of 3 line distances only inside the triangle\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}\n/**///--end__: barycentric\n/**///--\n/**///--start: memo\n                      \n             \n//solving with linear equations (and not with perlendicular doorproduct rhombus)\n\n/*getting the linear function of a line (o,t) //2 points on a line\ny=m*x+b\nm=(o.y-t.y)/(o.x-t.x) //slpe == rate of change over one domain (x)\nb=t.y-m*t.x           //f(0)\n\nm=(o.x-t.x)/(o.y-t.y)  //is constant\neither enter o.xy or t.xy\no.y      =m*o.x+b    \nt.y      =m*t.x+b\nt.y-m*t.x=     +b   //b is f(0)\n\nm=(o.x-t.x)/(o.y-t.y) //slope\nb=t.y-m*t.x           //f(0)  (this is a vec2 in 3d)\n\n//the above is odd for barycentric coordinates.\n//theres no y=m*x+b pointSlope form\n//sure, the slope is simple\n//oh wait, i just assert a skewed 2d coordinate system.\n\n//where ever 2 things intersect, they are the same, there they are equal.\n//this equation is a linear equation system, with as mnany lines as domains\n//substract factors to get all constants on one side\n                      \n/*  solving lonear equations with inverse matrix:\nhttps://courses.lumenlearning.com/ivytech-collegealgebra/chapter/solving-a-system-of-linear-equations-using-the-inverse-of-a-matrix/\n\n  a*x=b\n    x=b/a\n    x=b*inverse(a)\n\na is a matrix\nx are coefficients (one foreach domain)\nb may be zero vector, usually only contains constanty.\n                      \nexample (2d line intersection)\nA linear function is visible as a line where f(x)=y\ncos(x)  =y\ncos(x)-y=0\n\nany intersection of 2 things may have an intersection, where both functions are equal\n3*a+ 8*b=5\n4*a+11*by7\n\nA=mat2(vec2(3,8),vec2(4,11)\nX=vec2(a,b)\nB=vec2(5,7)\nA*X=B\ninverse(A)==mat2(11,-8,-4,3)\ninverse(A)*B==vec2(-1,1)  \nBEWARE that matrix multiplication is not commutative  inverse(A)*B != b*inverse(A)\n->\nvec2(x,y)==vec2(-1,1)\n/**/\n                      \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n/*\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n/**/\n                      \n/*\ntodo\nget RE included\n\nfix duplicates with the hg_sdf segment\n\nfix vNNN struct incompatibles (is simple)\n\nfix all that relies on high domain su() functions. (incompatibility\n- hash noise errors  , re-copy from   https://www.shadertoy.com/view/XlVyDK\n\ninclude debugHg2() marcher from       https://www.shadertoy.com/view/XlVyDK\n\na lot of hg sdf uses higher doimkensional mod mo(), which fails here an is from  /XlVyDK\n*/\n                      \n/*\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n/**/\n                      \n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n", "buffer_a_code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m){if(d<r){r=d;state.x=f;o=center-m;}}//for iDiegeticUI\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  ;addInit(.35*iResolution.x,.4 *iResolution.y)//initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.7 *iResolution.y)\n  ;addInit(.5 *iResolution.x,.1 *iResolution.y)\n  ;addInit(.4 *iResolution.x,.7 *iResolution.y)\n  ;addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=ds²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=ds³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      “farness”=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    “swiftness”=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure “nearness”.\n;\n     “nearness”=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    “forceness”=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25)   ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25)   ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n            \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n     \n     \n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(smoothstep(c.xyzw,-c.xyzw,vec4(viewzoom/Aa(t,u,r,m))),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){v0 t=iTime\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n    \n #if (scene==3)\n ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n #elif (scene==2)\n ;O=in3d(t,u,r,m)\n #elif (scene==1)\n ;O=in2d(t,u,r,m)\n #elif (scene==0)\n ;O=in1d(t,u,r,m)\n #endif \n    \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//[RE]= [Relativity Engine] v6\n\n//parent  RE7 : https://www.shadertoy.com/view/tlf3zj    (BayesianEpsilon targetFPS)\n\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\n\nfloat keyDif(vec2 a){a/=255.\n ;return texture(iChannel1,vec2(a.x,.2)).x\n        -texture(iChannel1,vec2(a.y,.2)).x;}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\n/*\nbool Processing(float c, float d\n){//float a=d-c*varWdth\n ;//float b=varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (abs(d-c*varWdth-.5*varWdth)*2.<varWdth)//(0.<a&&a<b)\n ;}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingold(float c, float d\n){float a=d-c*varWdth\n ;float b=(c*varWdth+varWdth)-c*varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (0.<a&&a<b);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingolderstill(float c, float d\n){return  (d-c*varWdth>0.)\n        &&(d-c*varWdth<(c+1.)*varWdth-c*varWdth);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)*/\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){if(u.y>1.||u.x>varWdth*10.\n ){o=vec4(0.);return;}\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;vec4 quat = Get(ReQua)\n ;vec4 dquat = Get(ReQuaD)\n ;float time = Get(ReTime).x\n ;float deltaT = min(0.1,iTimeDelta)\n ;float plf = LorentzFactor(length(dpos))\n ;time += deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(time)\n ;ProcessCamPos(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir = normalize(dpos)\n ;vec4 normDist = GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm = normDist.xyz\n ;float proxAlert = normDist.a\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(iMouse.xy-iMouse.zw)/iResolution.yy\n ;if(iMouse.x == 0. && iMouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(iMouse.z <= 0.)joystick = vec2(0)\n ;pitchYaw += joystick*deltaT\n ;pitchYaw.y = clamp(pitchYaw.y,-pi*.45,pi*.45)\n ;quat = aa2q(pitchYaw.x,vec3(0,1,0))\n ;right =qr(quat,vec3(1.,0.,0.))\n ;quat = qm(aa2q(-pitchYaw.y,right),quat)\n ;//quat = MulQuat(aa2q(-deltaT*joystick.x,forward),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))\n //;float thurst=keyDif(vec2(KEY_E,KEY_D)) \n// ;float strafe=keyDif(vec2(KEY_F,KEY_S))\n ;acc+=keyDif(vec2(KEY_E,KEY_D))*groundForwardDir*thrustForce\n ;acc+=keyDif(vec2(KEY_F,KEY_S))*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(Proc(RePos         ,v,w))o=vec4(pos,1.)\n ;if(Proc(RePosD       ,v,w))o=vec4(dpos,1.)\n ;if(Proc(ReQua        ,v,w))o=vec4(quat)\n ;if(Proc(ReQuaD      ,v,w))o=vec4(dquat)\n ;if(Proc(RePosDD      ,v,w))o=vec4(acc,1.)\n ;if(Proc(ReTime        ,v,w))o=vec4(time)\n ;if(Proc(ReCol   ,v,w))o=vec4(proxAlert)\n ;if(Proc(ReCamR,v,w))o=vec4(pitchYaw,0,0);\n    \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//iTR  TemporalReprojection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n", "buffer_d_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3564, 3564, 3662, 3662, 3849], [3851, 3907, 3935, 3935, 4058], [4076, 4076, 4105, 4105, 4655], [5083, 5083, 5116, 5116, 5127], [5532, 5532, 5546, 5546, 5584], [5588, 5588, 5674, 5674, 13618], [13626, 13626, 13663, 13663, 14794], [14802, 14938, 15024, 15121, 15460], [15462, 15617, 15702, 15702, 16003], [16005, 16005, 16051, 16051, 17004], [17006, 17006, 17082, 17082, 18209], [18217, 18217, 18280, 18327, 18897], [18899, 19295, 19319, 19319, 19345], [19346, 19346, 19371, 19371, 19708], [21651, 25282, 25313, 25313, 25338], [25338, 26196, 26224, 26224, 26243], [26261, 26311, 26341, 26341, 26375], [26376, 26442, 26469, 26469, 26490], [26500, 26525, 26552, 26552, 26575], [30749, 30749, 30769, 30780, 30827], [32988, 33181, 33209, 33220, 33268], [33269, 33537, 33568, 33605, 33759], [33760, 33760, 33799, 33810, 33952], [34003, 34003, 34022, 34022, 34088], [34213, 34213, 34255, 34255, 34411], [34412, 34412, 34456, 34456, 34607], [34608, 34608, 34708, 34708, 35003], [35004, 35004, 35061, 35084, 37198], [40637, 43474, 43516, 43516, 43914], [43916, 43916, 43954, 44020, 44839], [46087, 46087, 46113, 46113, 46895]], "test": "untested"}
{"id": "tljcWy", "name": "Life-Like Cellular Automata", "author": "KaWiz", "description": "i'm learning shaders and read a blog on game-of-life-style automata (https://kylehovey.github.io/blog/automata-nebula) and figured i could do it pretty easy in a shader so i did and it was not that easy but i figured it out\n\n(configuration in \"Buffer A\")", "tags": ["game", "automata", "life", "cellular", "conway", "ca", "lifelike"], "likes": 1, "viewed": 857, "published": 3, "date": "1595453202", "time_retrieved": "2024-07-30T20:54:26.077519", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0); }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/* ============================\n\nthese two tables define the ruleset\nand are pre-set with Game of Life rules\n(create if 3 neighbors, survive if 2 or 3)\n\nother popular ones to try:\n\nDay and Night (c 3678  s 34678)\nAnneal \t\t  (c 4678  s 35678)\nMaze-Finder   (c 138   s 12357)\nDiamoeba      (c 35678 s 5678)\nMorley \t\t  (c 368   s 245)\n\n================================ */\n\n// creation table (create if ONE neighbor, TWO neighbors, etc...)\n#define cONE   0\n#define cTWO   0\n#define cTHREE 1\n#define cFOUR  0\n#define cFIVE  0\n#define cSIX   0\n#define cSEVEN 0\n#define cEIGHT 0\n\n\n// survival table (survive if ONE neighbor, TWO neighbors, etc...)\n#define sONE   0\n#define sTWO   1\n#define sTHREE 1\n#define sFOUR  0\n#define sFIVE  0\n#define sSIX   0\n#define sSEVEN 0\n#define sEIGHT 0\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 tex = ivec2(fragCoord);\n    ivec2 res = ivec2(iResolution.xy);\n    \n    // let's parse the user defines every frame because why not\n    int createTable  = 0 | 1 & cONE * 1 | 2 & cTWO * 2 | 4 & cTHREE * 4 | 8 & cFOUR * 8 | 16 & cFIVE * 16 | 32 & cSIX * 32 | 64 & cSEVEN * 64 | 128 & cEIGHT * 128;\n    int surviveTable = 0 | 1 & sONE * 1 | 2 & sTWO * 2 | 4 & sTHREE * 4 | 8 & sFOUR * 8 | 16 & sFIVE * 16 | 32 & sSIX * 32 | 64 & sSEVEN * 64 | 128 & sEIGHT * 128;\n    \n    int neighborCount = 0;\n    for(int i=-1;i<2;++i)\n        for(int j=-1;j<2;++j)\n            neighborCount = texelFetch(iChannel0, ivec2((tex.x+i+res.x)%res.x,(tex.y+j+res.y)%res.y), 0).x > 0.5 ? neighborCount+1 : neighborCount;\n    \n    if( texelFetch(iChannel0, tex, 0).x > 0.5 )\n    {\n        neighborCount--; // if this cell is alive, we counted it during neighbor check, correct that now\n        bool survives = false;\n        for(int i=0;!survives && i<9;++i)\n            survives = ( surviveTable & int( pow(2.,float(i)) ) ) > 0 && (neighborCount == (i+1) );\n        \n        fragColor = survives ? vec4(1.) : vec4(0.);\n    }\n    else\n    {\n        bool creates = false;\n        for(int i=0;!creates && i<9;++i)\n            creates = ( createTable & int( pow(2.,float(i)) ) ) > 0 && (neighborCount == (i+1) );\n        \n        fragColor = creates ? vec4(1.) : vec4(0.);\n    }\n    \n    fragColor = iTime < 0.5 ? texelFetch(iChannel1, tex % 256, 0).xxxx : fragColor;\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 115]], "test": "untested"}
{"id": "3tScW3", "name": "Golfing Kaleidoscope 136 chars", "author": "GregRostami", "description": "Golfing Fabrice's beautiful Kaleidoscope 2 shader.\nThe Mouse enabled version is in my original golfed version.\nI like this animated version the best.", "tags": ["2d", "short", "onetweet", "golf"], "likes": 8, "viewed": 544, "published": 3, "date": "1595452433", "time_retrieved": "2024-07-30T20:54:27.019999", "image_code": "// Fork of \"Kaleidoscope 2 ( 151 chars ) \" by FabriceNeyret2. https://shadertoy.com/view/3ds3RH\n// 2020-07-22 21:06:19\n\n// 136 chars - Subtracted 2 more chars by using the o.xy=iResolution.xy trick.\nvoid mainImage(out vec4 o, vec2 u){\n    u = abs(u - .5*(o.xy = iResolution.xy))/o.y;\n    o = texture(iChannel0, (u.x>u.y ? u : u.yx) + sin( iTime*vec2(.02,.03) )  );\n}\n\n/*\n// Fabrice shaved 9 chars from the animation code.\n// 138 chars:\nvoid mainImage(out vec4 O, vec2 u)\n{\n    vec2 R = iResolution.xy,\n         U = abs(u - .5*R)/R.y;\n    O = texture(iChannel0, (U.x>U.y ? U : U.yx) + sin(iTime*vec2(.02,.03))  );\n}\n\n\n\n// My favorite version with animation ...\n// 131 chars:\n#define mainImage( O, u )                \\\n    vec2 R = iResolution.xy,             \\\n         U = abs(u - .5*R)/R.y;          \\\n    O = texture(iChannel0, (U.x>U.y ? U : U.yx) + sin(vec2(O.a=iTime*.1, O.a*.17) ) )\n\n\n// Golfing Fabrice's original shader\n// 114 chars\n\n#define mainImage( O, u )                \\\n    vec2 R = iResolution.xy,             \\\n         U = abs(u - .5*R)/R.y - .5;     \\\n    O = texture(iChannel0, (U.x>U.y ? U : U.yx) + iMouse.xy/R )\n\n\n// Fabrice's original shader\n// 151 chars:\n\n#define mainImage( O, u )                                   \\\n    vec2 R = iResolution.xy, U = u+u - R ;                  \\\n    O = texture(iChannel0, .5                               \\\n             // - vec2(.2*iTime,0)                          \\\n                - iMouse.xy/R.y                             \\\n                +.55 * length( U / R.y )  // 3/pi: .477: 4/2pi: .637  \\\n                     * cos( abs( fract( atan(U.y,U.x)*.637 - .5 ) - .5 )/.637 +vec2(0,11)) )\n*/", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScW3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[120, 199, 234, 234, 366]], "test": "untested"}
{"id": "3tSyW3", "name": "Color Grid 2", "author": "iq", "description": "Some sort of undefined colored grid thingy. Clearly inspired by [url]https://www.shadertoy.com/view/wl2yDV[/url], and [url]https://www.shadertoy.com/view/4dBSRK[/url]", "tags": ["procedural", "2d", "grid"], "likes": 32, "viewed": 1114, "published": 3, "date": "1595449292", "time_retrieved": "2024-07-30T20:54:27.968463", "image_code": "// Created by inigo quilez - iq/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n// A blend between \n//  https://www.shadertoy.com/view/4dBSRK\n// and\n//  https://www.shadertoy.com/view/wl2yDV\n\n\n// 0: triangles\n// 1: squares\n#define SHAPE 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = 4.0*(2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    #if SHAPE==0\n    p.x += 0.5*p.y;\n    #endif\n    \n    vec2 f = fract(p);\n    vec2 i = floor(p);\n    \n    float id = fract(fract(dot(i,vec2(0.436,0.173))) * 45.0);\n    #if SHAPE==0\n    if( f.x>f.y ) id += 1.3;\n\t#endif\n    \n    vec3  col = 0.5+0.5*cos(0.7*id  + vec3(0.0,1.5,2.0) + 4.0);\n    float pha = smoothstep(-1.0,1.0,sin(0.2*i.x + 0.2*iTime + id*1.0));\n    \n    #if SHAPE==0\n\tvec2  pat = min(0.5-abs(f-0.5),abs(f.x-f.y)) - 0.3*pha;\n    #else\n\tvec2  pat = 0.5-abs(f-0.5) - 0.5*pha;\n    #endif\n    \n\tpat = smoothstep( 0.04, 0.07, pat );\n\n    fragColor = vec4( col*pat.x*pat.y, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyW3.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[286, 286, 343, 343, 1001]], "test": "untested"}
{"id": "wlVXRV", "name": "Goatrance trip !", "author": "z0rg", "description": "A shader made on new song from Agneton !", "tags": ["psy", "psytrance", "goatrance", "agneton", "nithzogoa"], "likes": 10, "viewed": 467, "published": 3, "date": "1595444128", "time_retrieved": "2024-07-30T20:54:28.839135", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\nvec2 repeat(vec2 p, vec2 sp)\n{\n  return mod(p,sp)-sp/2.;\n}\nfloat _cir(vec2 uv, float sz)\n{\n  return length(uv)-sz;\n}\n\n float sdf_rect(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nfloat _union(float a, float b)\n{\n  return min(a,b);\n}\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\n\n\nvec3 rdrPsy(vec2 uv)\n{\n  vec3 cols[4];\n\n  cols[0] = vec3(196.,1.,44.)/255.;\n  cols[1] = .0*vec3(1.,44.,196.)/255.;\n  cols[2] = vec3(1.,196.,153.)/255.;\n  cols[3] = vec3(196.,153.,1.)/255.;\n  float fidx= mod(-iTime+length(uv)*4.+.2*-abs(sin(50.*atan(uv.y,uv.x)/PI))\n    +abs(0.1*sin(iTime*5.+sin(uv.x*5.)*179.7*atan(uv.y,uv.x)/PI))\n      ,4.);\n  int curIdx=int(fidx);\n  vec3 bubbles = vec3(uv,.5)*(1.-sat(50.*_cir(repeat(uv*(sin(iTime*.5)*.2+.5)*r2d(.5*sin(uv.y*2.+iTime*.5)),vec2(.1)),.02)));\n  return bubbles+vec3(.3)+mix(cols[curIdx], cols[int(mod(float(curIdx)+1.,4.))], fract(fidx));\n}\n\nvec3 rdrScn(vec2 uv)\n{\n  vec2 uvc = vec2(abs(uv.x),uv.y*sign(uv.x));\n  vec2 uvcir =uvc- vec2(.0);\n  float acir = atan(uvcir.y,uvcir.x)/PI;\n  vec2 pcir = vec2(sin(iTime),cos(iTime*.7))*.5;\n  float cir = (1.-sat(_cir(uv+pcir,.5)*200.))*float(acir<.7*sin(10.*-iTime+length(uvcir)*20.));;\n\n\n  return vec3(abs(uv),.5)*cir*2.;\n}\n\nvec3 rdrDot(vec2 uv, float szmin, float szmax)\n{\n  vec2 ouv = uv;\n  uv = vec2(int(uv.x/szmax),int(uv.y/szmax))*szmax;\n  vec3 col = rdrScn(uv);\n\n  return col*(1.-sat((length(ouv-uv-vec2(.5*szmax*sign(uv.x),.5*szmax*sign(uv.y)))-mix(szmin,(szmax-.1*szmax)*.5,col.x))*200.*(col.x+.1)));\n}\n\nfloat sdCross(vec2 p, float sz)\n{\n  vec2 sz2 = vec2(sz,sz/3.);\n  float a = sdf_rect(p,sz2);\n  float b = sdf_rect(p,sz2.yx);\n\n  return _union(a,b);\n}\n\nvec3 rdrCross(vec2 uv)\n{\n  vec3 acc;\n\n  for (int i = 0;i<16;++i)\n  {\n    float fi = float(i);\n    float px = sin(fi)*.5;\n    vec2 pos= vec2(px,sin(px*2.+iTime)+mod((fi-4.)*5.,.53));\n    vec2 p = (uv-vec2(pos))*r2d(sin(iTime*.5+float(i)));\n\n    float sd = sat(sdCross(p,.1*fi*.3)*200.);\n    float sdHalo = sat(sdCross(p,.1*(fi*.2))*5.);\n    float sd2 = sat(sdCross(p,.08*(fi*.3))*200.);\n\n    acc*= sd;\n    acc+= vec3(1.)*(sd2*(1.-sd))+(1.-sdHalo)*sd*vec3(uv.xyx*.5+.5);\n  }\n  return acc;\n}\n\nvec3 rdr(vec2 uv)\n{\n  vec3 opsy = rdrPsy(uv*r2d(-iTime));\n  uv = abs(uv);\n  uv = uv*r2d(20.*atan(uv.y,uv.x)/PI);\n  uv= uv+(vec2(.1)*r2d(-iTime));\n  float sel = float(mod(iTime,.4)<.2);\n  vec3 col = rdrDot((uv+vec2(.3))*r2d(iTime),.02,mix(.05,.01,sel));\n  vec3 c2 = rdrCross(uv);\n\n  return mix(col,c2,c2.x)+rdrPsy(uv).yxz-opsy.zyx*.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\nuv*=2.+(sin(iTime)*.5+.5);\n  vec3 col = rdr(uv);\n    //uv.x += .5;\n    float rad = length(uv)-.1;\n    float an = abs(atan(uv.y, uv.x)/PI);\n    vec3 col2 = col*float(rad < texelFetch(iChannel0, ivec2(int((an)*512.), 0), 0).x)*.5;\n    vec3 outcol = sat(1.-lenny(uv*.5))*col.zxy*.5+col2.zxy;\n//    outcol = pow(outcol, vec3(1./2.2));\n    \n    float fadeIn = clamp(iTime,0.,3.)/3.;\n  fragColor = vec4(outcol*fadeIn, 1.0);\n}", "image_inputs": [{"id": 23055, "src": "https://soundcloud.com/agneton/agneton-fire-in-the-sky", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlVXRV.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[426, 426, 444, 444, 505], [507, 507, 528, 528, 558], [559, 559, 579, 579, 606], [607, 607, 625, 625, 671], [672, 672, 702, 702, 730], [731, 731, 762, 762, 788], [791, 791, 825, 825, 873], [875, 875, 907, 907, 928], [929, 929, 959, 959, 981], [984, 984, 1006, 1006, 1573], [1575, 1575, 1597, 1597, 1897], [1899, 1899, 1947, 1947, 2184], [2186, 2186, 2219, 2219, 2334], [2336, 2336, 2360, 2360, 2824], [2826, 2826, 2845, 2845, 3161], [3164, 3164, 3221, 3221, 3732]], "test": "untested"}
{"id": "tt2yWV", "name": "Basic Mandelbrot set display", "author": "Nrx", "description": "Basic Mandelbrot set display.\n\nAn anti-aliased version can be seen [url=https://www.shadertoy.com/view/Wl2cDt]here[/url].", "tags": ["mandelbrot"], "likes": 0, "viewed": 288, "published": 3, "date": "1595439666", "time_retrieved": "2024-07-30T20:54:29.661935", "image_code": "#define C1\tvec2 (0.2, 0.55)\n#define C2\tvec2 (-0.743644, 0.131826)\n#define N\t900.0\n#define PI\t3.14159265358979\n\nmat2 Rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat Mandelbrot (in vec2 c)\n{\n\tvec2 m;\n\n\t#ifndef NO_OPTIM\n\tm = vec2 (c.x + 1.0, c.y);\n\tif (dot (m, m) < 0.0625) {\n\t\treturn 1.0;\n\t}\n\n\tm = vec2 (c.x - 0.25, c.y);\n\tfloat l = dot (m, m);\n\tif (c.x < sqrt (l) - 2.0 * l + 0.25) {\n\t\treturn 1.0;\n\t}\n\t#endif\n\n\tm = c;\n\tfor (float n = 0.0; n < N; ++n) {\n\t\tif (dot (m, m) > 256.0) {\n\t\t\treturn n / N;\n\t\t}\n\t\tm = vec2 (m.x * m.x - m.y * m.y, 2.0 * m.x * m.y) + c;\n\t}\n\treturn 1.0;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 c = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n\tfloat time = iTime * 0.1;\n\tfloat zoom = 1.5 * pow (0.5, 18.0 * (0.5 - 0.5 * cos (time * 2.0)));\n\tfloat angle = PI * 6.0 * cos (time);\n\tvec2 translate = mix (C1, C2, smoothstep (-0.4, 0.4, sin (time)));\n\n\tc = zoom * Rotate (angle) * c + translate;\n\tfloat m = Mandelbrot (c);\n\tfragColor = vec4 (m, pow (m, 0.6), pow (m, 0.3), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yWV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 141, 141, 219], [221, 221, 251, 251, 638], [640, 640, 696, 696, 1092]], "test": "untested"}
{"id": "3t2cDK", "name": "Extruded Pentagon Tiling", "author": "Shane", "description": "Precalculating 2D distance field values and height field values then storing them in the faces of the cube map in order to produce an extruded Cairo based pentagonal tiling arrangement in realtime.", "tags": ["grid", "tiling", "pentagon", "extrude", "cairo"], "likes": 54, "viewed": 1256, "published": 3, "date": "1595423473", "time_retrieved": "2024-07-30T20:54:30.869706", "image_code": "/*\n\n\n    Extruded Pentagon Tiling\n    ------------------------\n\n\n\tMost people know that a regular pentagon alone can't tile the Euclidean\n    plane, but there are plenty of irregular ones that can. This is part of\n\ta Cairo tiling setup, which is pretty simple to put together in 2D form.\n\tThe extruded version is doable also, as you can see here, but with eight \n\tpentagon renderings, it can get slow... You might be able to get away \n\twith fewer taps, but it's still a slow process. Either way, it can be\n\tovercome by encoding some of the heavier calculations into buffers, like\n    the pentagon distance fields and height map values. This can reduce the\n\traymarching function down to a bit of setup and some texture reads, which\n\tmost GPUs can do pretty efficiently these days.\n\n\tAnyway, this is more of a proof of concept than anything else. There are \n    probably better ways to get the job done, like encoding heights into all \n    four channels to reduce the number of texture reads but this seems to be\n    working well enough... providing your computer is happy reading from the \n    cube map faces, which mine is. In fact, my laptop can run this in \n    fullscreen, but it's probably better when run in window form.\n\n    There's a couple of defines to play with. There's a SHIM_VALUE define in\n\tthe common tab that will display different arrangements and a\n    QUANTIZE_HEIGHT option that forces the height to display 16 discreet\n    values, which can look neater. However, since things are precalculated,\n    it's necessary to reset each time. There are also PENTAGON_MAP_2D and \n    WIREFRAME defines in the \"Common\" tab to try as well. In fact, I almost\n\twent with the wireframe look with quantized heights by default, but \n    untimately decided less is more, and all that. :)\n\n    \n\n\tCairo and pentagonal tiling:\n    \n    \n    // Nimitz was doing this stuff way before it was cool. :D\n    // Quite an old shader, this one, and nicely done, as always. \n    Cairo tiling - nimitz\n\thttps://www.shadertoy.com/view/4ssSWf\n\n\t// 2D Cairo tiling. Very nice.\n    Pentagonal Tessellations - MLA\n\thttps://www.shadertoy.com/view/XlBBWG\n\n    // Fabrice's version.\n    pentagonal tiling - FabriceNeyret2\n\thttps://www.shadertoy.com/view/ltBBzK\n\n    // I love this both aesthetically, and for the mathematical\n    // story behind it.\n\t15th Pentagonal Tiling - tomkh\n\thttps://www.shadertoy.com/view/4lBXRV\n\n    // Not the easiest of tilings to pull off, and Rory's done it in\n    // two tweets. I'd like to see the expanded version.\n\t[SH17A] Pentagons - rory618\n\thttps://www.shadertoy.com/view/4sjfRm\n\n\n*/\n\n\n\n// Max ray distance.\n#define FAR 20.\n\n// Scene object ID to separate the mesh object from the terrain.\nfloat objID;\n\n\n// Hacky global to stored the height of the closest pylon.\nfloat gh;\n\n// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed square pylons.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\nvec4 blocks(vec3 q3){\n    \n    \n    // Pulling in the 8 precalculated pentagon values from their respective\n    // cube map faces. Four from the first face, and four from the last.\n    // Those two faces were chosen because calculations are a little quicker.\n    //\n    // By the way, calculating the minimum 2D face distance, then using it to\n    // render the extruded block doesn't work... It'd be nice, but you have to\n    // compare all 8 extruded blocks... It's obvious, yet if I haven't done this\n    // for a while, it's the first thing I try. :D\n    vec2 uv = (floor(q3.xy*1024.) + .5)/1024.;\n    vec4 p41 = tx0(iChannel0, uv);    \n    vec4 p42 = tx5(iChannel0, uv);   \n    \n    \n    // Scale.\n\tconst vec2 scale = GSCALE;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n    \n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // For block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, vec2(l.x, -l.y), -l);\n     \n    float boxID = 0.; // Box ID. Not used in this example, but helpful.\n    \n    \n    // By the way, I'm making 8 height map calls. They're in the form of\n    // precalculated textures reads, which most GPUs can handle quite\n    // easily, even within a raymarching loop. However, with a bit of \n    // effort, it'd be possible to store four loop values in each channel,\n    // then get away with just two texture reads instead of eight.\n    // Unfortunately, I couldn't make that happen in the short time I had\n    // to put this together. Anyway, just know that it'd be possible if \n    // someone less slow was writing this. :D\n    // \n\n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n\n\n        // Local coordinates and local tile ID.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; \n    \n       \n        // Correct positional individual tile ID.\n        vec2 idi = ip*s + cntr;\n \n        // The pentagonal block central face offse, base on block dimension,\n        // and block orientation.\n        vec2 offs = vec2(l.x/4., 0.);\n        if((i&1) == 1){ //if(i == 1 || i == 3){\n             // Reorient for blocks one and three.\n             offs = offs.yx*vec2(-1, 1);\n        }\n \n        \n        // Height scale. Heigher is more dramatic, but can be prone to arifacts,\n        // which has to do with a bunch of things.\n        const float hs = .5;\n     \n        \n        // Here's a brief summary of one Cairo tiling method: Put a square grid together.\n        // Cut grid blocks in half horizontally on one checker portions and vertically\n        // across the other. Set \"shim\" to zero (an reset) for a visual reference.\n        // Add mid points to all the edges, then move the right ones in or out depending\n        // on the pentagonal tile configuration you wish to produce. The following effects\n        // that.\n\n        // Shimming variable to move the midpoints in or out. This is by a constant amount,\n        // but I guess you could go to a lot of trouble to make irregular tiles, which \n        // would be pretty cool... I might do that later.\n        float shim = SHIM_VALUE; // Range: [-1, 1].\n        \n        // Moving the central offset position by 1.5 times the shimming amount. I honestly\n        // can't remember why I chose this value, but it seems to work. :)\n        offs *= 1. + shim/2.;\n       \n       \n        // Using the precalcuted pentagon values to consrtuct the extuded pentagon blocks.\n\n        // Central block position (doubling as an ID), which is used to read into the \n        // height map.\n        vec2 idi1 = idi + offs;\n        // Pentagonal top face.\n        float pent1 =  p41[i];\n        // Extruded block height.\n        float h1 = tx1B(iChannel0, (idi1)/64.).x;\n        //h1 = floor(h1*15.999)/15.; // Or just, \"h1 *= .15,\" for nondiscreet heights.\n        h1 *= hs;\n        // One of two extruded block distances for this pass.\n        float pent1Ext = opExtrusion(pent1 + .0*scale.x, (q3.z + h1), h1);\n\n        // The same as above, but for the second extruded block.\n        vec2 idi2 = idi - offs;\n        float pent2 = p42[i]; \n        float h2 = tx1B(iChannel0, (idi2)/64.).x;\n        //h2 = floor(h2*15.999)/15.;\n        h2 *= hs;\n        // The extruded distance function value.\n        float pent2Ext = opExtrusion(pent2 + .0*scale.x, (q3.z + h2), h2);\n        \n        // Adding a touch of the 2D values for extra height. This points the pointy\n        // cone-like tips on the faces.\n        pent1Ext += pent1*.25;\n        pent2Ext += pent2*.25;\n       \n        // Choose the closest block, then return it's central position ID and a number\n        // telling us whether it's on the top or bottom.\n        vec4 di = pent1Ext<pent2Ext? vec4(pent1Ext, idi1, 0) : vec4(pent2Ext, idi2, 4);\n  \n\n\n        // If applicable, update the overall minimum distance value, ID, and box ID. \n        if(di.x<d){\n            \n            d = di.x;\n            id = di.yz;\n            // There are 8 possible blocks, so give each an ID. \n            // Not used in this example, but it's there.\n            boxID = float(i) + di.w;\n            \n            // This is a last minute global hack to return the block\n            // heights, which are used to render the black block rims.\n            // I wouldn't recommend trying this at home. :D\n            gh = pent1Ext<pent2Ext? h1 : h2;\n            \n        }\n        \n    }\n    \n    // Return the distance, position-base ID and box ID.\n    return vec4(d, id, boxID);\n}\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Floor. Not really used here, but if you changed the block dimensions,\n    // the you'd want this.\n    float fl = -p.z + .1;\n\n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded image\n    return  min(fl, d4.x);\n \n}\n\n \n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n    \n    for(int i = 0; i<64; i++){\n    \n        d = map(ro + rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(d)<.001*(1. + t*.25) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.), etc.\n        \n        //t += i<32? d*.75 : d; \n        t += d*.8; \n    }\n\n    return min(t, FAR);\n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical.\nvec3 getNormal(in vec3 p, float t) {\n\tconst vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // So, what's this mess then? Glad you asked. :) Apparently, if there's a break, things\n    // won't get unrolled, so the idea is that this will cut down on the number of unrolled\n    // map calls which can add to compile time... As to whether it works or not, I can't say,\n    // but it seems to cut compile time down on my machine. If you know of something better,\n    // feel free to let me know. In case it needs to be said, from a code perspective, I \n    // do not like this. :)\n    float sgn = 1.;\n    vec3 n = vec3(0);\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = min(iFrame, 0); i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test \n    // machine, anyway.\n    const int maxIterationsShad = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the \n    // lowest number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<maxIterationsShad; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        // Subtle difference. Thanks to IQ for this tidbit.\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); \n        // So many options here, and none are perfect: dist += min(h, .2), \n        // dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for(int i = 0; i<5; i++){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n// Just the 2D Cairo pentagon value. Pull in all 8 stored values\n// and send back the minimum. Technically, we should be using a \n// 2D interpolated technique which involves more texture calls,\n// but we're just using this to draw outlines.\n//\n// Also, for normal 2D, we wouldn't need 8 pentagon calls. You could\n// get away with four or even two.\nfloat pent2D(vec2 p){\n    \n    vec2 uv = (floor(p*1024.) + .5)/1024.;\n    \n    vec4 p1 = tx0(iChannel0,uv);\n    float d1 = min(min(p1.x, p1.y), min(p1.z, p1.w));\n    \n    vec4 p2 = tx5(iChannel0,uv);\n    float d2 = min(min(p2.x, p2.y), min(p2.z, p2.w));\n    \n    return min(d1, d2);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, iTime, -1.5); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, .2, .25);//vec3(0, -.25, iTime);  // \"Look At\" position.\n \n    // Light positioning. One is just in front of the camera, and the other is in front of that.\n \tvec3 lp = ro + vec3(.5, .5, .25);// Put it a bit in front of the camera.\n    #ifdef GREYSCALE\n    lp.y += 1.; // Move the light to show the colored specular component more.\n    #endif\n\t\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.333; // FOV - Field of view.\n    vec3 fwd = normalize(lk-ro);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    // \"right\" and \"forward\" are perpendicular, due to the dot product being zero. Therefore, I'm \n    // assuming no normalization is necessary? The only reason I ask is that lots of people do \n    // normalize, so perhaps I'm overlooking something?\n    vec3 up = cross(fwd, rgt); \n\n    // rd - Ray direction.\n    //vec3 rd = normalize(fwd + FOV*uv.x*rgt + FOV*uv.y*up);\n    vec3 rd = normalize(uv.x*rgt + uv.y*up + fwd/FOV);\n    \n    // Swiveling the camera about the XY-plane.\n\trd.xy *= rot2(sin(iTime/12. - cos(iTime/16.))/2.);\n\n\n    \n\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID and object ID.\n    vec3 svGID = gID;\n    \n    float svObjID = objID;\n    \n    float svGH = gh;\n  \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp, t);\n        \n          \n        // Setting the object color to zer. \n\t    vec3 objCol = vec3(0);  \n        \n        // Specular color.\n        vec3 sCol = vec3(1, .5, .2);\n        \n        // 2D pentagon variables for dark lines, decoration, etc.\n        float pentLn = 1e5, pentRng = 1e5, pent = 1e5;\n        \n        // Some color variables.\n        vec3 tCol1 = vec3(0), tCol2 = vec3(0);\n\n        // The extruded pentagonal grid. The coloring is made up on the spot. All of it\n        // is based off of simple 2D techniques.\n        if(svObjID<.5){\n            \n       \n            // See the scaling factor in distance the function.\n            float rnd = tx1B(iChannel0, svGID.xy/64.).x*1.5;\n            vec2 pl = sp.xy - svGID.xy;\n            // Using the tile ID to rotate the angle to align correctly with the pentagonal\n            // sides. I did this in a hurry, so it's not my best work. :) There'd have to be \n            // a nicer way to do this.\n            float[8] rt = float[8](1., 0., 1., 0., 3., 2., 3., 2.);\n            pl *= rot2(rt[int(svGID.z)]*3.14159/10.);\n            \n            // Tangential palette colors and colors based on the height map. The cos palette\n            // function comes from IQ. It's really clever and very versatile.\n            float ia = (floor(atan(pl.x, pl.y)/6.28318*5.) + .5)/5.;\n            tCol1 = .55 + .45*cos(-6.2831*rnd + vec3(0, 1, 2));\n            tCol2 = .55 + .45*cos(6.2831*ia + vec3(0, 1, 2));\n            \n            // Setting the specular color to the tangential colors. There's no science behind \n            // it. Giving the facets a pearlescent appearance seemed like a fun thing to do.\n            sCol = tCol2;\n            \n            // Setting the object color to the height map color.\n            objCol = tCol1;\n            #ifdef GREYSCALE\n            // Greyscale.\n            objCol = vec3(1)*dot(objCol, vec3(.299, .587, .114));\n            #endif\n            \n            // Mixing things up.\n            //objCol = objCol/2. + objCol*tCol2*2.;\n           \n            \n            // Putting in some dark lines to give it a slight cartoon look. It's more hassle\n            // that using a distance map-based edge formula, but it's way cheaper, easier on\n            // the compiler and gives you more control.\n            \n            // Pentagonal lines.\n            pentLn = abs(fract(atan(pl.x, pl.y)/6.2831853*5. + .5) - .5)*2. - min(.007/length(pl), 1.);\n        \n            // 2D pentagon.\n            pent = pent2D(sp.xy);\n            // Pentagon lines, not including the pentagon face itself. Commenting this out will produce\n            // a wireframe looking exterior.\n            #ifndef WIREFRAME\n            pentLn = max(pentLn, -pent);\n            #endif\n            // The pentagonal ring that surrounds the face edges.\n            pentRng = max(abs(pent) - .001, (sp.z + svGH*2.));\n            \n            // Brightening up the inner face edges a bit. It's a 2D photoshop inner stroke trick.\n            // Comment it out to see what it does.\n            objCol = mix(objCol, mix(objCol*2., vec3(1), .1), \n                         (1. - smoothstep(0., .01, -(sp.z + svGH*2.)))*.5);\n   \n\n   \n        }\n        /*\n        else {\n            \n            // The dark floor in the background. Not really used here, as it's hidden\n            // behind the pylons, but if you changed the block dimensions, you'd want this.\n            objCol = vec3(0);\n        }\n        */\n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .001);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.25, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 1./(1. + lDist*.05);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        //diff = pow(diff, 4.)*2.; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 16.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        //float fre = pow(clamp(1. + dot(sn, rd), 0., 1.), 4.);\n        //float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 2.);\n        \n\t\t// Schlick approximation. I use it to tone down the specular term. It's pretty subtle,\n        // so could almost be aproximated by a constant, but I prefer it. Here, it's being\n        // used to give a hard clay consistency... It \"kind of\" works.\n\t\t//float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.);\n\t\t//float freS = mix(.15, 1., Schlick);  //F0 = .2 - Glass... or close enough.        \n        \n         \n        // Combining the above terms to procude the final color.\n        \n       \n        #ifdef GREYSCALE\n        // In greyscale mode, focus more on the specular.\n        col = objCol*(diff*.7 + ao*.1 + sCol*spec*8.) + sCol*sqrt(spec); \n        #else\n        col = objCol*(diff + ao*.3 + sCol*spec*8.);\n        #endif\n        \n        \n        // Apply the dark pentagonal ring and lines to the extruded pentagon edges.\n        // I've found through trial and error that applying dark edges after performing\n        // the lighting calculations is more artifact free. Codewise, it doesn't look \n        // as neat and tidy, unfortunately.\n        float alpha = 1.;\n        #ifdef WIREFRAME\n        alpha = .8;\n        #endif\n        col = mix(col, vec3(0), (1. - smoothstep(0., .007, min(pentLn, pentRng)))*alpha);\n\n\n        #ifdef RANDOM_TOPS\n        // Extra decoration: Interesting, but a little too much, I think, so it's not on by default.\n        if(hash21(svGID.xy)<.35){\n            col = mix(col, vec3(0), 1. - smoothstep(0., .01, pent + .035));\n            col = mix(col, mix(tCol1, tCol2, .5), 1. - smoothstep(0., .01, pent + .035 + .01));\n        }\n        #endif        \n        \n        \n        \n        \n        // Just the texture color.\n        //col = objCol;// + sCol*spec; \n        \n        // Shading.\n        col *= ao*sh*atten;\n        \n        \n\t\n\t}\n    \n    // Usually, you'd put fog here, but the camera is up close, and the horizon is not in\n    // view, so we're saving the calculations.\n\n    \n    #ifdef PENTAGON_MAP_2D\n    // Just the 2D pentagons.\n    float pent1 = pent2D(uv + iTime/6.) + .007;\n    float pent2 = pent2D(uv + iTime/6. + vec2(.004)) + .007;\n    float b = max(pent2 - pent1, 0.)/.004*.7;\n    b *= max(-pent1/.2, 0.) + .5;\n    col = mix(vec3(1), vec3(1, .9, .85)*b, 1. - smoothstep(0., 4./iResolution.y, pent1));\n    #endif\n    \n    \n    // Showing the preculated height field in the second cube face.\n    //col = tx1(iChannel0, uv/2. + iTime/4.).xyz;\n    \n    // Rought gamma correction.\n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n} \n", "image_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// The Cairo tile midpoint shimming value: Range: [-1, 1].\n// Different values produce different tile configurations. A value of zero\n// will produce the basic double brick arrangement. By the way, a reset is\n// necessary each time. Ie. Hit the back button.\n#define SHIM_VALUE .57735\n\n// This sets the scale of the extruded shapes. Because of the way I've calculated\n// things, the scale needs to be even divisors and each term needs to be equal --\n// I use it in other applications where I can use two different numbers though. \n// As above, if you choose this option, a reset will be necessary. Ie. Hit the \n// back button.\n#define GSCALE vec2(1./4.)\n\n// Give the height field discreet heights. It's not necessary, but it can look\n// a little neater, especially with wireframe mode turned on. If you choose \n// this option, a reset will be necessary. Ie. Hit the back button.\n//#define QUANTIZE_HEIGHT\n\n// Display the 2D pentagonal Cairo tiles that are encoded in two of the\n// cube map faces.\n//#define PENTAGON_MAP_2D\n\n// Gives things a polygonized wireframe look. It only works with the default\n// SHIM_VALUE and looks better with the QUANTIZE_HEIGHT define turned on. I'll\n// reformulate the logic later to work with all values.\n//#define WIREFRAME\n\n// Greyscale. Its main purpose is to show the colored angular specular lighting.\n//#define GREYSCALE\n\n// Random indeed, and probably a little too random for my liking. :D\n//#define RANDOM_TOPS\n\n\n\n\n// Grid pattern repeat scale. Baking wrapped distance fields into textures can be \n// a little fiddly. Basically, the pattern is wrapped on a 64 by 64 unit basis.\nfloat repSc = 64.;\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n/*\nvec2 hash22(vec2 p) {\n    //return vec2(0);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n\n// IQ's vec2 to float hash, but with a repeat factor. If you repeat random\n// textures to wrap, then you need to wrap the random functions.\nfloat hash21Rep(vec2 p){ \n    p = mod(p, repSc); \n    return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); \n}\n\nvec2 hash22Rep(vec2 p) {\n    //return vec2(0);\n    p = mod(p, repSc);\n    return fract(sin(vec2(dot(p, vec2(12.989, 78.233)), dot(p, vec2(41.898, 57.263))))\n                      *vec2(43758.5453, 23421.6361));\n}\n*/\n\n\n// Reading from various cube map faces.\nvec4 tx0(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(-.5, fract(p.yx) - .5), 0.);\n    //return texture(tx, vec3(-.5, fract(p.yx) - .5));\n}\n\nvec4 tx1(samplerCube tx, vec2 p){    \n\n    p = fract(p) - .5;\n    return textureLod(tx,  vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\nvec4 tx5(samplerCube tx, vec2 p){    \n\n    return textureLod(tx, vec3(fract(p) - .5, .5), 0.);\n    //return texture(tx, vec3(fract(p) - .5, .5));\n}\n\nvec4 tx1B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(.5, p.y, -p.x), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\nvec4 tx2B(samplerCube tx, vec2 p){    \n\n    p = (floor(p*1024.) + .5)/1024.;\n    p = fract(p) - .5;\n    \n    return textureLod(tx, vec3(p.x, -.5, p.y), 0.);\n    //return texture(tx, vec3(.5, p.y, -p.x));\n}\n\n/*\n\n// Reading into one of the cube faces, according to the face ID. To save on cycles,\n// I'd hardcode the face you're after into all but the least costly of situations.\n// This particular function is used just once for an update in the \"CubeA\" tab.\n//\n// The four cube sides - Left, back, right, front.\n// NEGATIVE_X, POSITIVE_Z, POSITIVE_X, NEGATIVE_Z\n// vec3(-.5, uv.yx), vec3(uv, .5), vec3(.5, uv.y, -uv.x), vec3(-uv.x, uv.y, -.5).\n//\n// Bottom and top.\n// NEGATIVE_Y, POSITIVE_Y\n// vec3(uv.x, -.5, uv.y), vec3(uv.x, .5, -uv.y).\nvec4 tx(samplerCube tx, vec2 p, int id){    \n\n    //vec4 rTx;\n    \n    vec2 uv = fract(p) - .5;\n    // It's important to snap to the pixel centers. The people complaining about\n    // seam line problems are probably not doing this.\n    //p = (floor(p*cubemapRes) + .5)/cubemapRes; \n    \n    vec3[6] fcP = vec3[6](vec3(-.5, uv.yx), vec3(.5, uv.y, -uv.x), vec3(uv.x, -.5, uv.y),\n                          vec3(uv.x, .5, -uv.y), vec3(-uv.x, uv.y, -.5), vec3(uv, .5));\n \n    \n    return texture(tx, fcP[id]);\n}\n*/\n\n\n// vec2 to vec2 hash.\nvec2 hash22B(vec2 p) { \n\n    p = mod(p, repSc);\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(27, 57)));\n    return fract(vec2(262144, 32768)*n)*2. - 1.; \n    \n    // Animated.\n    //p = fract(vec2(262144, 32768)*n);\n    //return sin(p*6.2831853 + iTime); \n    \n}\n\n// Based on IQ's gradient noise formula.\nfloat n2D3G( in vec2 p ){\n   \n    vec2 i = floor(p); p -= i;\n    \n    vec4 v;\n    v.x = dot(hash22B(i), p);\n    v.y = dot(hash22B(i + vec2(1, 0)), p - vec2(1, 0));\n    v.z = dot(hash22B(i + vec2(0, 1)), p - vec2(0, 1));\n    v.w = dot(hash22B(i + 1.), p - 1.);\n\n#if 1\n    // Quintic interpolation.\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\n#else\n    // Cubic interpolation.\n    p = p*p*(3. - 2.*p);\n#endif\n\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\n    \n}\n\n/*\n\n// Getting the video texture. I've deliberately stretched it out to fit across the screen,\n// which means messing with the natural aspect ratio.\n//\n// By the way, it'd be nice to have a couple of naturally wider ratio videos to choose from. :)\n//\nvec3 getTex(sampler2D txCh, vec2 p){\n    \n    // Strething things out so that the image fills up the window. You don't need to,\n    // but this looks better. I think the original video is in the oldschool 4 to 3\n    // format, whereas the canvas is along the order of 16 to 9, which we're used to.\n    // If using repeat textures, you'd comment the first line out.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(txCh, (p/8.)).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, based on a texture's greyscale value.\nfloat hm(sampler2D txCh, in vec2 p){ \n   \n    return dot(getTex(txCh, p), vec3(.299, .587, .114));\n    \n}\n*/\n\n\n// Height map. Just a couple of gradient noise layers. \n// By the way, because this is precalculated, you could\n// make this as extravagent as you wished.\nfloat hm(in vec2 p){ \n    \n    // We're going for simplicity, so just a couple of\n    // noise layers. The bottom layer is hollowd out a\n    // bit to give a basin like feel.\n    float h = smoothstep(.08, 1., n2D3G(p)*.5 + .5);\n    h = mix(h, n2D3G(p*2.)*.5 + .5, .33);\n    #ifdef QUANTIZE_HEIGHT\n    h = floor(h*15.999)/15.; // Discreet heights.\n    #endif\n    \n    return h;\n    \n}\n\n// IQ's extrusion formula.\nfloat opExtrusion(in float sdf, in float pz, in float h){\n    \n    vec2 w = vec2( sdf, abs(pz) - h );\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.));\n\n    /*\n    // Slight rounding. A little nicer, but slower.\n    const float sf = .025;\n    vec2 w = vec2( sdf, abs(pz) - h) + sf;\n  \treturn min(max(w.x, w.y), 0.) + length(max(w, 0.)) - sf;\n    */\n}\n\n/*\n// Based on IQ's signed distance to a 2D triangle.\nfloat pent(in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2, in vec2 p3, in vec2 p4){\n\n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p3 - p2;\n\tvec2 e3 = p4 - p3;\n\tvec2 e4 = p0 - p4;\n\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 v3 = p - p3;\n\tvec2 v4 = p - p4;\n\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n\tvec2 pq3 = v3 - e3*clamp( dot(v3,e3)/dot(e3,e3), 0.0, 1.0 );\n\tvec2 pq4 = v4 - e4*clamp( dot(v4,e4)/dot(e4,e4), 0.0, 1.0 );\n    \n    float s = sign( e0.x*e4.y - e0.y*e4.x );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), s*(v0.x*e0.y-v0.y*e0.x) ),\n                       vec2( dot( pq1, pq1 ), s*(v1.x*e1.y-v1.y*e1.x) )),\n                       vec2( dot( pq2, pq2 ), s*(v2.x*e2.y-v2.y*e2.x) ));\n    \n    d = min(d, vec2( dot( pq3, pq3 ), s*(v3.x*e3.y-v3.y*e3.x)));\n    d = min(d, vec2( dot( pq4, pq4 ), s*(v4.x*e4.y-v4.y*e4.x)));\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n*/\n\n// IQ's distance to a regular pentagon, without trigonometric functions. \n// Other distances here:\n// https://iquilezles.org/articles/distfunctions2d\n//\n#define N 5\n//\nfloat sdPoly(in vec2 p, in vec2[N] v){\n\n    const int num = v.length();\n    float d = dot(p - v[0],p - v[0]);\n    float s = 1.0;\n    for( int i = 0, j = num - 1; i < num; j = i, i++){\n    \n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp(dot(w, e)/dot(e, e), 0., 1. );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n", "cube_a_code": "// A regular extruded block grid.\n//\n// The idea is very simple: Produce a normal grid full of packed objects.\n// That is, use the grid cell's center pixel to obtain a height value (read in\n// from a height map), then render a pylon at that height.\n\n// For a 2D extruded block tiling four objects are needed. For the Cairo tiling,\n// each block needs to be subdivided into two seperate pentagonal pieces, so \n// that's eight pentagon distances all up. Since there are no vec8 containers in \n// WebGL, we need to make one. By the way, for regular 2D Cairo tiles, you only \n// need four or even two, depending what you're trying to do.\n//\nstruct Cairo{ vec4 distA; vec4 distB; };\n\n\nCairo df(vec2 q3){\n    \n    // Scale.\n\tconst vec2 scale = GSCALE;\n\n    // Brick dimension: Length to height ratio with additional scaling.\n\tconst vec2 l = vec2(scale);\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = l*2.;\n\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n     \n    // For block corner postions.\n    vec2[4] ps4 = vec2[4](vec2(-l.x, l.y), l, vec2(l.x, -l.y), -l);\n    \n    // Cairo tile container.\n    Cairo tile;\n   \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        vec2 cntr = ps4[i]/2. -  ps4[0]/2.;\n\n\n        // Local coordinates.\n        p = q3.xy - cntr;\n        ip = floor(p/s) + .5; // Local tile ID.\n        p -= ip*s; // New local position.\n\n       \n        // Here's a brief summary of one Cairo tiling method: Put a square grid together.\n        // Cut grid blocks in half horizontally on one checker portions and vertically\n        // across the other. Set \"shim\" to zero (an reset) for a visual reference.\n        // Add mid points to all the edges, then move the right ones in or out depending\n        // on the pentagonal tile configuration you wish to produce. The following effects\n        // that.\n\n        // Shimming variable to move the midpoints in or out. This is by a constant amount,\n        // but I guess you could go to a lot of trouble to make irregular tiles, which \n        // would be pretty cool... I might do that later.\n        float shim = SHIM_VALUE; // Range: [-1, 1].\n        \n        // Is the block configuration cut across the horizontal or vertical?\n        int horiz = 1;\n    \n        // Left and right, or top and bottom block dimension.\n        vec2 dim = vec2(l.x/1., l.y);\n        if((i&1) == 1){  //if(i == 1 || i == 3)\n            // Reorient, flag, etc, on blocks one an three.\n            dim = dim.yx;\n            horiz = 0;\n            shim = -shim;\n        }\n\n        // Square vertices and mid points. Standard stuff.\n        vec2[4] vert = vec2[4](vec2(-.5, .5)*dim, vec2(.5)*dim, vec2(.5, -.5)*dim, vec2(-.5)*dim);  \n        vec2[4] mid = vec2[4](mix(vert[0], vert[1], .5), mix(vert[1], vert[2], .5),\n                              mix(vert[2], vert[3], .5), mix(vert[3], vert[0], .5));  \n        \n        \n        // Move the mid point vertices in or out, depending on the above.\n        mid[0] -= mid[0]*shim;\n        mid[2] -= mid[2]*shim;\n\n        mid[1] += mid[1]*shim;\n        mid[3] += mid[3]*shim; \n        \n          \n        // Construct block one: Its orientation depends on the above.\n        vec2[5] v = vec2[5](mid[3], vert[0], mid[0], vert[1], mid[1]); \n        if(horiz == 1) v = vec2[5](mid[0], vert[1], mid[1], vert[2], mid[2]); \n       \n       \n        // Even though the pentagons are identical and concave, this will work \n        // with non concave polygons, so we're making use of IQ's all round \n        // polygon formula. It's slower that the specialized version, but these \n        // values are being precalculated, so it doesn't matter.\n        // \n        float pent1 =  sdPoly(p, v); \n        //float pent1 =  pent(p, v[0], v[1], v[2], v[3], v[4]); \n        \n        \n        // Construct block two: Its orientation depends on the above.\n        v = vec2[5](mid[3], mid[1], vert[2], mid[2], vert[3]); \n        if(horiz == 1) v = vec2[5](mid[0], mid[2], vert[3], mid[3], vert[0]); \n      \n        // Pentagon two.\n        float pent2 = sdPoly(p, v);\n        //float pent2 =  pent(p, v[0], v[1], v[2], v[3], v[4]); \n\n        // Set the eight pentagon distances. These will be used the main \n        // raymarching function in the \"Image\" tab in the form of texture calls. \n        // Trust me, a texture call is much faster than contstucting a 2D \n        // Cairo style pentagon.\n        tile.distA[i] = pent1;\n        tile.distB[i] = pent2;\n \n       \n    }\n    \n    // Return the eight pentagon distances.\n    return tile;\n\n}\n\n\n// Cube mapping for face identification - Adapted from one of Fizzer's routines. \nint CubeFaceCoords(vec3 p){\n\n    // Elegant cubic space stepping trick, as seen in many voxel related examples.\n    vec3 f = abs(p); f = step(f.zxy, f)*step(f.yzx, f); \n    \n    ivec3 idF = ivec3(p.x<.0? 0 : 1, p.y<.0? 2 : 3, p.z<0.? 4 : 5);\n    \n    return f.x>.5? idF.x : f.y>.5? idF.y : idF.z; \n}\n\n\nvoid mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir){\n    \n    \n    // UV coordinates.\n    //\n    // For whatever reason (which I'd love expained), the Y coordinates flip each\n    // frame if I don't negate the coordinates here -- I'm assuming this is internal, \n    // a VFlip thing, or there's something I'm missing. If there are experts out there, \n    // any feedback would be welcome. :)\n    vec2 uv = fract(fragCoord/iResolution.y*vec2(1, -1));\n    \n    // Adapting one of Fizzer's old cube mapping routines to obtain the cube face ID \n    // from the ray direction vector.\n    int faceID = CubeFaceCoords(rayDir);\n  \n    // Pixel storage.\n    vec4 col;\n   \n    // Initial conditions -- Performed just the once upon initialization.\n    //if(abs(tx(iChannel0, uv).w - iResolution.y)>.001){\n    //\n    // IQ gave me the following tip, which saved me a heap of trouble and an extra channel. \n    // I'm not sure how he figured this out, but he pretty much knows everything. :D\n    //\n    // If the texture hasn't loaded, or if we're on the first frame, initialize whatever \n    // you wish to initialize. In this case, I'm precalculating an expensive distance\n    // field and storing it in some of the cube map faces.\n    if(textureSize(iChannel0, 0).x<2 || iFrame<1){\n        \n        // INITIALIZING.\n        \n        // Construct a distance field, then store it.\n    \tCairo d = df(uv);\n        \n        if(faceID == 0) col = d.distA; //d// Distance field in X, and object IDs in YZ.\n    \n        if(faceID == 5) col = d.distB;//vec4(ln);\n    \n        \n        repSc = 64.;\n        if(faceID == 1) {\n            col = vec4(1)*hm(uv*repSc);//hm(iChannel1, uv*repSc)\n        }\n     \n    }\n    else {\n        if(faceID == 0) col = tx0(iChannel0, uv);\n        if(faceID == 5) col = tx5(iChannel0, uv);\n        if(faceID == 1) col = tx1(iChannel0, uv);\n    }\n\n\n    // Store in the cube map.\n    fragColor = col;\n    \n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cDK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[8902, 8925, 8943, 9053, 9325], [9329, 9350, 9386, 9435, 9906], [11027, 11218, 11270, 11395, 12723], [12726, 12878, 12914, 12914, 13156], [13159, 13507, 13528, 13528, 13791]], "test": "untested"}
{"id": "3tjcWV", "name": "Sierpinski Star", "author": "dr2", "description": "Stellated octahedron from two sierpinskified tetrahedra", "tags": ["fractal", "tetrahedron", "kifs"], "likes": 14, "viewed": 397, "published": 3, "date": "1595408725", "time_retrieved": "2024-07-30T20:54:31.640644", "image_code": "// \"Sierpinski Star\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrTetDf (vec3 p, float d);\nvec3 HsvToRgb (vec3 c);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\n\nfloat tCur, dstFar;\nint idObj;\nconst float pi = 3.1415927;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat Sierp3 (vec3 p)\n{\n  float s;\n  s = 1.;\n  for (int k = 0; k < 8; k ++) {\n    p.xy = (p.x + p.y > 0.) ? p.xy : - p.yx; \n    p.yz = (p.y + p.z > 0.) ? p.yz : - p.zy; \n    p.zx = (p.z + p.x > 0.) ? p.zx : - p.xz; \n    p = 2. * p - 1.;\n    s *= 0.5;\n  }\n  return s * PrSphDf (p, 2.5);\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  for (float k = -1.; k <= 1.; k += 2.) {\n    q = p;\n    q.y *= k;\n    q.xz = Rot2D (q.xz, - k * pi / 6.);\n    q.xy = Rot2D (q.xy, pi / 2. -0.5 * acos (1./3.));\n    q.xz = Rot2D (q.xz, pi / 4.);\n    d = Sierp3 (q);\n    DMIN (1);\n    d = PrTetDf (q, 0.25);\n    DMIN (2);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = 0; j < 80; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = 0; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = 0; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 ltPos[4], ltDir, col, vn, c, dfTot, spTot;\n  float dstObj, at, vDotL, sh;\n  for (int k = 0; k < 3; k ++) {\n    ltPos[k] = vec3 (0., 1., 3.);\n    ltPos[k].xz = Rot2D (ltPos[k].xz, float (k) * 2. * pi / 3. -0.1 * pi * tCur);\n  }\n  ltPos[3] = vec3 (0., 3., 0.);\n  ltPos[3].xy = Rot2D (ltPos[3].xy, pi * (0.05 + 0.04 * sin (0.14 * pi * tCur)));\n  ltPos[3].xz = Rot2D (ltPos[3].xz, 0.1 * pi * tCur);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) col4 = vec4 (1., 1., 1., 1.);\n    else col4 = vec4 (1., 1., 0.5, 0.2);\n    dfTot = vec3 (0.);\n    spTot = vec3 (0.);\n    for (int k = 0; k < 4; k ++) {\n      ltDir = normalize (ltPos[k]);\n      at = smoothstep (0.7, 0.95, dot (normalize (ltPos[k] - ro), ltDir));\n      sh = ObjSShadow (ro, ltDir);\n      c = HsvToRgb (vec3 (0.25 * float (k), 1., 1.));\n      vDotL = max (dot (vn, ltDir), 0.);\n      dfTot += col4.rgb * c * at * sh * vDotL * vDotL;\n      spTot += col4.a * c * at * step (0.95, sh) * pow (max (dot (normalize (ltDir - rd), vn), 0.), 64.);\n    }\n    col = dfTot + spTot;\n  } else {\n    col = vec3 (0.1);\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, t, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.2 * pi;\n  el = -0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    t = floor (tCur / 5.) + smoothstep (0.9, 1., mod (tCur / 5., 1.));\n    az += 0.22 * pi * t;\n    el += 0.2 * pi * sin (0.1 * pi * t);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -10.);\n  zmFac = 5.5;\n  dstFar = 20.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = 0.; a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrTetDf (vec3 p, float d)\n{\n  vec2 e = vec2 (1., -1.);\n  return (max (max (dot (p, e.yxx), dot (p, e.xyx)), max (dot (p, e.xxy), dot (p, e.yyy))) - d) / sqrt (3.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcWV.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[399, 399, 422, 422, 686], [688, 688, 710, 710, 1045], [1047, 1047, 1080, 1080, 1256], [1258, 1258, 1279, 1279, 1527], [1529, 1529, 1566, 1566, 1788], [1790, 1790, 1825, 1825, 3011], [3055, 3055, 3111, 3111, 4164], [4166, 4166, 4199, 4199, 4226], [4228, 4228, 4261, 4261, 4399], [4401, 4401, 4425, 4425, 4542], [4544, 4544, 4580, 4580, 4786], [4788, 4788, 4818, 4818, 4931]], "test": "untested"}
{"id": "wdKXRR", "name": "Horse Game", "author": "wessles", "description": "horse game", "tags": ["horse"], "likes": 6, "viewed": 667, "published": 3, "date": "1595383070", "time_retrieved": "2024-07-30T20:54:32.508325", "image_code": "float horseDist(const vec2 p, vec2 feet){\n    float t = iTime*17.;\n    \n    vec2 uv = translate(p, feet);\n    uv *= 2.;\n    vec2 body = vec2(0., 100.);\n    vec2 behind = body + vec2(-100., 20.);\n    vec2 front = body + vec2(100., 0.);\n    \n    front += 20.*sin(t);\n    behind += 30.*cos(t)*vec2(0.2, 1.3);\n    \n    vec2 tail_start = behind+vec2(-70., 5.);\n    vec2 tail_end = tail_start + vec2(-70., 35.*cos(t*1.2));\n    vec2 tail_mid = (tail_start+tail_end)/2. + vec2(0.,1.)*50.*sin(t*1.2);\n    \n    vec2 backleg_top = behind;\n    vec2 backleg_mid = backleg_top+vec2(50.*cos(-t), -150.);\n    vec2 backleg_bottom = backleg_mid + vec2(50.*sin(t), -70.*sin(t));\n    \n    float ft = t+1.9;\n    vec2 frontleg_top = front;\n    vec2 frontleg_mid = frontleg_top+vec2(50.*cos(-ft), -150.);\n    vec2 frontleg_bottom = frontleg_mid + vec2(50.*sin(ft), -70.*sin(t));\n    \n    vec2 head = front+vec2(100., 70.);\n    vec2 nose = head+vec2(100., -50.);\n    \n    head.y += 15.*sin(t*1.3-1.5);\n    nose += 30. * sin(t*1.1);\n    \n    vec2 eye_p = head;\n    vec2 ears = head+vec2(-20., 30.);\n    vec2 ears_end = head+vec2(-70., 50.)+sin(t*1.1)*10.*vec2(0., 1.);\n    \n    eye_p += sin(t)* vec2(-5., -5.);\n    \n    float d1 = sdCircle(uv, behind, 70.);\n    float d2 = sdCircle(uv, front, 50.);\n    float d3 = sdBox(uv,body, vec2(50., 50.));\n    \n    float tail = sdBezier(uv, tail_start, tail_mid, tail_end)-5.;\n    \n    float backleg = sdBezier(uv, backleg_top, backleg_mid, backleg_bottom)-15.;\n    float frontleg = sdBezier(uv, frontleg_top, frontleg_mid, frontleg_bottom)-15.;\n    \n    float neck = sdLine(uv, front, head)-20.;\n    float nasal = sdLine(uv, head, nose)-15.;\n    float eye = sdCircle(uv, eye_p, 10.);\n    \n    float ear = sdLine(uv, ears, ears_end)-4.;\n    \n    float d = smin(d1, d2, 50.);\n    d = smin(d, d3, 100.);\n    d = smin(d, backleg, 30.);\n    d = smin(d, frontleg, 30.);\n    d = smin(d, neck, 70.);\n    d = smin(d, nasal, 100.);\n    d = max(d, -eye);\n    d = smin(d, tail, 40.);\n    d = smin(d, ear, 30.);\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 uv )\n{   \n    uv /= iResolution.y;\n    uv = uv*2.-1.;\n    uv = uv*500.;\n    \n    uv = rotate(uv, sin(iTime)*0.06);\n    uv *= 1.+sin(iTime*9.)*0.05;\n    \n    float d;\n    \n    // calculate backdrop color\n    float d_backdrop = uv.y+50.\n        + 30.*sin(uv.x/300. + iTime*1.)\n        + 1.*sin(uv.x/50.  + iTime*1.)\n        + 100.*sin(iTime);\n    d_backdrop = 1.-smoothstep(0.1, 0.5, d_backdrop);\n    vec3 c_backdrop = hueShift(vec3(0.1, 0.1, 0.05), iTime)*d_backdrop;\n    \n    // calculate floor color\n    float d_floor = uv.y+200.\n        + 50.*sin(uv.x/300. + iTime*9.)\n        + 5.*sin(uv.x/50.  + iTime*9.);\n    d_floor = 1.-step(0.1, d_floor);\n    vec3 c_floor = hueShift(vec3(0.2, 0.2, 0.1), iTime)*d_floor;\n    \n    // calculate horse color\n    float d_horse = horseDist(uv, vec2(sin(iTime)*100., -300.));\n    d_horse = 1.-step(0.1, d_horse);\n    vec3 c_horse = vec3(1., 1., 0.)*d_horse;\n    \n    float ct = iTime*0.5;\n    vec3 col = vec3(0.);\n    // additive color blending / layering\n    if(d_horse>0.)\n        col += c_horse;\n    else if (d_floor > 0.)\n    \tcol += c_floor;\n    else if (d_backdrop > 0.)\n        col += c_backdrop;\n    else {\n        col += hueShift(vec3(1., 0., 0.),iTime*0.1);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "vec3 hueShift( vec3 color, float hueAdjust ){\n\n    const vec3  kRGBToYPrime = vec3 (0.299, 0.587, 0.114);\n    const vec3  kRGBToI      = vec3 (0.596, -0.275, -0.321);\n    const vec3  kRGBToQ      = vec3 (0.212, -0.523, 0.311);\n\n    const vec3  kYIQToR     = vec3 (1.0, 0.956, 0.621);\n    const vec3  kYIQToG     = vec3 (1.0, -0.272, -0.647);\n    const vec3  kYIQToB     = vec3 (1.0, -1.107, 1.704);\n\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I       = dot (color, kRGBToI);\n    float   Q       = dot (color, kRGBToQ);\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    hue += hueAdjust;\n\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    vec3    yIQ   = vec3 (YPrime, I, Q);\n\n    return vec3( dot (yIQ, kYIQToR), dot (yIQ, kYIQToG), dot (yIQ, kYIQToB) );\n\n}\n\nfloat sdBezier( in vec2 pos, in vec2 A, in vec2 B, in vec2 C )\n{    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n    float kk = 1.0 / dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n    float res = 0.0;\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n    if( h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t)*t;\n        res = dot(qos,qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n        vec2 qos = d + (c + b*t.x)*t.x;\n        res = dot(qos,qos);\n        qos = d + (c + b*t.y)*t.y;\n        res = min(res,dot(qos,qos));\n        qos = d + (c + b*t.z)*t.z;\n        res = min(res,dot(qos,qos));\n    }\n    return sqrt( res );\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nfloat sdCircle(vec2 p, vec2 c, float r) {\n    return length(p-c)-r;\n}\n\nfloat sdBox( vec2 p, vec2 c, vec2 b )\n{\n    p -= c;\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdLine( vec2 p, vec2 a, vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sdParabola( in vec2 pos, in float k )\n{    \n    pos.x = abs(pos.x);\n    \n    float p = (1.0-2.0*k*pos.y)/(6.0*k*k);\n    float q = -abs(pos.x)/(4.0*k*k);\n    \n    float h = q*q + p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        pow(-q+r,1.0/3.0) - pow(abs(-q-r),1.0/3.0)*sign(q+r) :\n        2.0*cos(atan(r,-q)/3.0)*sqrt(-p);\n    \n    return length(pos-vec2(x,k*x*x)) * sign(pos.x-x);\n}\n\nvec2 translate(vec2 p, vec2 t) {\n    return p-t;\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKXRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 2035], [2037, 2037, 2087, 2087, 3324]], "test": "untested"}
{"id": "4sGfz1", "name": "Digiverse - Planet", "author": "patu", "description": "Prototype o scene used in \"Digiverse\"\nhttp://www.pouet.net/prod.php?which=76719", "tags": ["retro", "planet", "synthwave"], "likes": 18, "viewed": 687, "published": 3, "date": "1595379612", "time_retrieved": "2024-07-30T20:54:33.393957", "image_code": "float alpha;\n#define res iResolution\n\nvec4\n     bloom = vec4(0),\n     blur = vec4(0);\n\n#define GA 2.399\nmat2 rot = mat2(cos(GA),sin(GA),-sin(GA),cos(GA));\nvec3 pixel=vec3(.0003*8./6.,.04, 0);\n\nfloat intensity(vec4 col) {\n\treturn dot(col.rgb, vec3(0.2126, 0.7152, 0.0722));\n}\n\n//  based on simplyfied version of Dave Hoskins blur\nvoid dof(sampler2D tex, vec2 uv, float rad, vec4 org)\n{\n\tvec2 angle=vec2(0,rad);\n    rad=1.;\n    vec4 col=texture(tex,uv);\n    float a = col.a;\n\n\tfor (int j=0;j<96;j++)\n    {  \n        rad += 1./rad;\n\t    angle*=rot;\n        \n        col=texture(tex,uv+pixel.xy*(rad-1.)*angle);\n        if (col.a > .9) {            \n\t\t\tbloom += col;  \n            \n        }\n        blur += col;\n\t}\n\tblur /= 96.;\n}\n\n//-------------------------------------------------------------------------------------------\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord)\n{\n\tvec2 uv = gl_FragCoord.xy / res.xy;\n    \n    vec4 orgColor = \n        texture(iChannel0,uv) \n    \t+ texture(iChannel0,uv + pixel.xz) * .5\n        + texture(iChannel0,uv + pixel.zx) * .5\n        + texture(iChannel0,uv - pixel.xz) * .5\n        + texture(iChannel0,uv - pixel.zx) * .5;\n    \n    dof(iChannel0,uv, 3., orgColor / 3.);\n    \n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., 1. - pow(abs(texture(iChannel0,uv).w - .5) * 2., 2.)),        \t\t\n            0.,\n            1.\n        )\n    );\n\n    orgColor = mix(\n        orgColor, \n        blur, \n        clamp(\n        \tmin(1., pow(length(uv -.5) * 1.8, 1.)),\n            0.,\n            1.\n        )\n    );\n \t\n    fragColor = mix(orgColor, bloom / 40., .5);    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define getNormal getNormalHex\n#define FAR 2900.\n#define INFINITY 1e32\n\n//#define FOG 1.\n\nfloat hash12(vec2 p) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\n#define PI 3.14159265\n#define PHI (1.618033988749895)\n\nvec3 ro;\n \n#define H(P) fract(sin(dot(P,vec2(127.1,311.7)))*43758.545)\n// \t3D noise function (IQ)\nfloat n(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(1,18,8);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    // linear\n    //p=p*p*(3.-2.*p);  \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    \n    return mix(h.x,h.y,p.z); \n}\n\n// \t3D noise function (IQ)\nfloat rand(vec3 p){ \n    float n = sin(dot(p, vec3(234, 7, 157)));    \n    return fract(length(vec3(123123, 2097152, 262144)*n)); \n}\n\nfloat Noise3D(vec3 p)\n{\n    vec2 e = vec2(0.0, 1.0);\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    \n    float x0 = mix(rand(i + e.xxx), rand(i + e.yxx), f.x);\n    float x1 = mix(rand(i + e.xyx), rand(i + e.yyx), f.x);\n    float x2 = mix(rand(i + e.xxy), rand(i + e.yxy), f.x);\n    float x3 = mix(rand(i + e.xyy), rand(i + e.yyy), f.x);\n    \n    float y0 = mix(x0, x1, f.y);\n    float y1 = mix(x2, x3, f.y);\n    \n    float val = mix(y0, y1, f.z);\n    \n    val = val * val * (3.0 - 2.0 * val);\n    return val;\n}\n\nfloat SmoothNoise(vec3 p)\n{\n    float amp = 1.0;\n    float freq = 1.0;\n    float val = 0.0;\n    \n    for (int i = 0; i < 4; i++)\n    {   \n        amp *= 0.5;\n        val += amp * Noise3D(freq * p - float(i) * 11.7179);\n        freq *= 2.0;\n    }\n    \n    return val;\n}\n\n#define fromRGB(a, b, c) vec3(F(a), F(b), F(c)) / 255.;\n    \nvec3 \n    light = vec3(0. ,0., 1.),\n\tlightDir;\n\nvec4 lightColour = normalize(vec4(0.0, .0, .0, 1.) ); \n\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat opU2( float d1, float d2 ) {\n    if (d1 < d2) return d1;\n    return d2;\n}\n\nstruct geometry {\n    float dist;\n    float materialIndex;\n    float specular;\n    float diffuse;\n    vec4 color;  \n    vec3 space;\n    float mirror;\n    float i;\n    float glow;\n};\n\ngeometry geoU(geometry g1, geometry g2) {\n    if (g1.dist < g2.dist) return g1;\n    return g2;\n}\n\nfloat opS2( float d1, float d2 ){\t\n    if (-d2 > d1) return -d2;\n    return d1;\n}\n\nvec3 opI2( vec3 d1, vec3 d2 ) {\n \tif (d1.x > d2.x) return d1;\n    return d2;\n}\n\n// Maximum/minumum elements of a vector\nfloat vmax(vec2 v) {\n\treturn max(v.x, v.y);\n}\n\nfloat vmax(vec3 v) {\n\treturn max(max(v.x, v.y), v.z);\n}\n\n// Sign function that doesn't return 0\nfloat sgn(float x) {\n\treturn (x<0.)?-1.:1.;\n}\n\nvec2 sgn(vec2 v) {\n\treturn vec2((v.x<0.)?-1.:1., (v.y<0.)?-1.:1.);\n}\n\n// Repeat in two dimensions\nvec2 pMod2(inout vec2 p, vec2 size) {\n\tvec2 c = floor((p + size*0.5)/size);\n\tp = mod(p + size*0.5,size) - size*0.5;\n\treturn c;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\ngeometry map(vec3 p) {\n    vec3 bp = p;\n    \n    geometry box, s;\n    \n    float nn = n(vec3(p.x * abs(.01 ), p.z * 0.01, 0.)) * (max(4., abs(p.x * .01)));\n    //nn = min(nn, 8.);\n    nn *= smoothstep(0., 1., iTime) / 2.;\n    nn *= smoothstep(0., 1., abs(p.x) * .002);\n    \n    nn *= sin(p.x * .004);\n\n    p.y += 71.;\n    p.y *= .46;\n    p.y -= mix(0., 50., nn);\n\n    s.dist = fBox(p, vec3(1e9, .2, 1e9));\n    s.color = vec4(0.0, 0., .0,0.);\n    \n    s.specular = .5;\n    s.diffuse = 1.5;\n    s.materialIndex = 0.;\n    s.glow = 0.;\n    \n    bp.x += 175.;\n    \n    vec2 gr = pMod2(bp.xz, vec2(800.));\n    \n    bp += rand(gr.xyy) * 200.;\n    \n    box = s;\n    box.color = vec4[](\n        vec4(1., 0., 0., 0.),\n        vec4(0., 0.8, 1., 0.)\n    )[int(floor(rand(gr.xyx) + .5))];\n    \n    box.diffuse = 1.;\n    box.specular = 0.0;\n    box.materialIndex = 1.;\n    box.dist = fBox(bp, vec3(20., 3320., 20.));\n    box.glow = 1.;\n    \n    s = geoU(s, box);   \n    \n    return s; \n}\n\n// \tstandard sphere tracing inside and outside\ngeometry trace(vec3 ro,vec3 rd) \n{\n    geometry mp = map(ro);\n    mp.glow = 0.;\n    float minDist = INFINITY;\n    float function_sign=(mp.dist<0.)?-1.:1.;\n    float precis=.001;\n    float h=precis*1.;\n    float t=-0.0;\n    \n\tfor(int i=0;i<170;i++) \n\t{\n        if(abs(h)<precis||t>FAR)break;\n\t\tmp = map(ro+rd*t);\n        mp.i = float(i);\n        h=function_sign*mp.dist;\n        t+=h * .4;\n\t}\n    mp.dist = t;\n    return mp;\n}\n\nvec4 clouds(vec3 rd, vec3 ro) {\n    vec2 uv = rd.xz / rd.y * .4;\n   \n    vec4 clouds = vec4(\n        SmoothNoise(rd * 3.) * vec4(0., 0., 1., 1.) + \n        SmoothNoise(rd) * vec4(1., 1., 0., 1.)\n\t\n\n    ) - rd.y;\n \treturn clouds * max(1., rd.y) * 1.;\n}\n\nfloat SphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n\nvec4 Sky(in vec3 rd, bool showSun, vec3 lightDir, vec3 ro)\n{\n   \n    float sunSize = 0.;\n    float sunAmount = max(dot(rd, lightDir), 1.);\n    float v = pow(1. - max(rd.y, 0.0), 12.);\n    vec4 cl = mix(vec4(1., 0., 0., 1.), vec4(0., 0., 1., 1.), rd.y);\n    vec4 sky = mix(cl, vec4(.0, .0, 0., 1.), v);\n \tvec3 lightColour = vec3(.1, .2, .3);\n    \n    sky += cl * sunAmount * sunAmount + vec4(1., 1., 0., 1.) *  min(pow(sunAmount, 120.0) * sunSize, 1. * sunSize);\n    \n    vec3 moon = vec3(0., 0., 22000. + iTime * 320.);\n    \n    float planetDist = SphereIntersect(ro, rd, vec4(moon, 17000.));\n\n    sky += clouds(rd, ro);\n    \n    \n    vec3 moo = ro + planetDist * rd;\n    vec3 nor = normalize(moo-moon);    \n\n    if (planetDist > 0.) {\n        vec3 nr = nor;\n        vec3 lp = normalize(light);\n\n\t\tpR(nr.xy, .3);\n        pR(nr.xz, iTime * .1);\n        \n\t\tpR(nr.xz, n(nr * 10. - nr.yxz * 3.) * 2.);\n        moo = mix(vec3(1., 1., 1.), vec3(1., .5, 0.), n(nr * vec3(.2, 9., .5) * 11.));            \n\n        sky.rgb = moo * pow(abs(dot(rd, lp)), 3.);        \n    } else {\n\t\tsky += clouds(rd, ro);\n\t}\n    \n    sky += clouds(rd, ro);\n    \n    return clamp(sky, 0.0, 1.0) ;\n}\n\nvec4 doColor( in vec3 sp, in vec3 rd, in vec3 sn, in vec3 lp, geometry obj) {\n\tvec3 ld = lp;\n    float lDist = max(length(ld / 2.), 0.01);\n    ld /= lDist;\n\n    float diff = max(dot(sn, ld), obj.diffuse);\n    float spec = pow(max(dot(reflect(ld, sn), rd), 1.), obj.specular);\n    \n    vec4 objCol = obj.color;\n\n    return objCol * (diff) + spec * .001;\n}\n\n//\tnormal calculation\nvec3 normal(vec3 pos)\n{\n    float eps=0.01;\n\tfloat d=map(pos).dist;\n\treturn normalize(vec3(map(pos+vec3(eps,0,0)).dist-d,map(pos+vec3(0,eps,0)).dist-d,map(pos+vec3(0,0,eps)).dist-d));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  \n    float \n        mat = 0.,\n        camShY = 0.;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy - .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    uv *= 2.4;\n    light = vec3(20.,40., 132.);        \n    \n    vec3 \n        vuv = vec3(0., 1., 0. );\n    \t\n    ro = vec3(0., -50., 0. + iTime * 320.);\n    \n    vec3 vrp =  vec3(0., 0., 120.) + ro;\n    vec3 vpn = normalize(vrp - ro),\n    \tu = normalize(cross(vuv, vpn)),        \n    \trd = normalize(vec3(uv * 2., 1.)),        \n        hit;\n    \n    vec3 oro = ro;\n       \n    vec4 sceneColor = vec4(0., 0., 0., 0.);\n    \n    geometry tr = trace(ro, rd);    \n    geometry otr = tr;\n    \n    hit = ro + rd * tr.dist;\n    \n    vec3 ohit = hit;\n    float odist = tr.dist;\n    vec3 sn = normal(hit);\t\n\t\n\tvec4 sky = Sky(rd, true, normalize(light), ro) * 1.;\n    vec4 osky = sky;\n    float glow = 0.;\n    \n    if (tr.dist < FAR) { \n        sceneColor = (doColor(hit, rd, sn, light, tr) * 1.) * 1.;\n\t    glow = tr.glow;\n        \n        if (tr.materialIndex == 0.) {\n            sceneColor = mix(\n                vec4(1., 1., 1., 1.),\n                sceneColor,\n                smoothstep(.0, .075, abs(fract(ohit.x * .01) * 2. - 1.)) *                \n                smoothstep(.0, .075, abs(fract(ohit.z * .003) * 2. - 1.)) \n            );\n            sceneColor += length(cross(sn, normal(sn.zyx + 1.5)) * .5);\n        }\n        \n        sceneColor.a = pow(abs(sceneColor.a - .5) * 1.2, 4.) * 9.;\n\t\t\n        if (tr.materialIndex == 0.) {\n            sceneColor *= 1.-max(0., dot(sn, -light)) * .01;\n\t\t\trd = reflect(-rd, sn);\n            sceneColor += Sky(rd, true, normalize(light), ro) * .1 * sn.y;\n        }\n        \n        sceneColor = mix(sceneColor, sky, otr.dist / FAR/ 4.);\n    } else {\n        sceneColor = sky;\n    }\n \t\n    fragColor = vec4(clamp(sceneColor * (1. - length(uv) / 3.5), 0.0, 1.0));\n    fragColor.a = glow;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.5));\n}\n", "buffer_a_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sGfz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 193, 220, 220, 274], [276, 329, 384, 384, 727], [729, 823, 877, 877, 1636]], "test": "untested"}
{"id": "3tjyWK", "name": "More Shiny Circles", "author": "goncalopalaio", "description": "Glowy circles\n\nThis is mostly a copy/variation of Shiny Circle by phil https://www.shadertoy.com/view/ltBXRc\n ", "tags": ["2d", "circles"], "likes": 7, "viewed": 450, "published": 3, "date": "1595371906", "time_retrieved": "2024-07-30T20:54:34.220746", "image_code": "// Inspired by Shiny Circle by phil (https://www.shadertoy.com/view/ltBXRc)\n\nfloat variation(vec2 v1, vec2 v2, float variationStrength) {\n return sin(dot(normalize(v1), normalize(v2))* variationStrength + iTime * 2.0) / 100.0;\n}\n\nmat2 rotate2d(float angle) {\n\treturn mat2(cos(angle), -sin(angle),\n                sin(angle),  cos(angle));\n}\n\nvec3 paintCircle(vec2 uv, vec2 center, float radius, float width, float variationStrength) {\n \n    vec2 diff = center - uv;\n    float len = length(diff);\n    \n    // Make resulting line all wobly by adding some variation based on the dot product of the direction from center with both axis. \n    len += variation(diff, vec2(0.0, 1.0), variationStrength);\n    len -= variation(diff, vec2(1.0, 0.0), variationStrength);\n    \n    \n    // Add a circle in the middle\n    float circle = smoothstep(radius - width, radius, len);\n    // Add a circle on the outside, leaving a white line in the middle between both circles \n    circle -= smoothstep(radius, radius + width, len);\n    \n    return vec3(circle);\n}\n\nvec3 paintOne(vec2 uv, vec2 center, float radius, float variationStrength) {\n\t\n    // Full white circle in the middle\n\tvec3 col = paintCircle(uv, center, radius, 0.05, variationStrength);\n    \n    // Add white circle will be outside of the previous one\n    col += paintCircle(uv, center, radius, 0.01, variationStrength);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // hacky way of having this rendered proportionally\n    vec2 uv = fragCoord/iResolution.xx;\n    vec2 center = vec2(0.5, 0.28);\n    float radius = 0.15;\n\n    vec3 col = paintOne(uv, center, radius, 5.0);\n    col += paintOne(uv, center, radius * 1.2, 0.0);\n    \n    // Color with gradient that pulses around\n    // vec2 v = rotate2d(iTime) * uv;\n    // col *= vec3(v.y, v.x, 0.8 - v.y * v.x);\n \tcol *= 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 77, 137, 137, 228], [230, 230, 258, 258, 340], [342, 342, 434, 434, 1043], [1045, 1045, 1121, 1162, 1384], [1386, 1386, 1443, 1499, 1951]], "test": "untested"}
{"id": "wlBcDV", "name": "Drunk Stars", "author": "timeisbeautifulhere", "description": "These stars will help mellow you out.\n\nMess around with some constants, PALETTE, or STARS to change behavior.", "tags": ["lines", "intersection", "star", "rotating", "expanding"], "likes": 3, "viewed": 362, "published": 3, "date": "1595371362", "time_retrieved": "2024-07-30T20:54:34.971738", "image_code": "\n//Grab a slice\n#define PI 3.14159\n\n//How thicc the lines are.\n#define LINE_WIDTH 0.01\n\n//How fast the stars expand.\n//Higher value is more \"explosive\"\n#define EXPAND_RATE 0.1\n\n//Decide when stars should start to loop back.\n//Affects how close each star renders.\n#define MAX_RADIUS 8.0\n\n//How fast the stars spin.\n#define ROTATION_RATE 0.25\n\n//Arrays of stars, in order, to display\n#define NUM_STARS 6\nint STARS[NUM_STARS] = int[](5,6,7,8,9,10);\n\n//Color palette to cycle through for lines.\n#define PALETTE_LENGTH 7\nvec3[PALETTE_LENGTH] PALETTE = vec3[](\n    vec3(1.0,0.0,0.0),\n    vec3(0.0,1.0,0.0),\n    vec3(0.0,0.0,1.0),\n    vec3(1.0,1.0,0.0),\n    vec3(0.0,1.0,1.0),\n    vec3(1.0,0.0,1.0),\n    vec3(1.0,1.0,1.0)\n);\n\n//Equations for finding coefficients for line\n//ax + by + c = 0\n//https://math.stackexchange.com/questions/637922/how-can-i-find-coefficients-a-b-c-given-two-points\nfloat line_a(vec2 pa, vec2 pb){\n    return pa.y-pb.y;\n}\nfloat line_b(vec2 pa, vec2 pb){\n    return (-1.0) * (pa.x-pb.x);\n}\nfloat line_c(vec2 pa, vec2 pb){\n    return (pa.x*pb.y)-(pb.x*pa.y);\n}\n\n//True if (x,y) is on a line between pa and pb\nbool onLine(float x, float y, vec2 pa, vec2 pb){\n    float a = line_a(pa,pb),\n        b = line_b(pa,pb),\n        c = line_c(pa,pb);\n    \n    if(abs(a)<0.0001 && abs(b)>0.0001){\n        //Horizontal line\n        return abs(pa.y-y) < LINE_WIDTH;\n    }\n    \n    if(abs(b)<0.0001){\n    \t//Vertical line\n        return abs(pa.x-x) < LINE_WIDTH;\n    }\n    \n    //Distance from line: |ax0+by0+c| / sqrt(a^2 + b^2)\n    float dist = abs(a*x + b*y + c) / sqrt((a*a)+(b*b));\n    \n    return dist < LINE_WIDTH;\n}\n\n//Expect [-1,1]\nvec2 to_polar(vec2 uv){\n    return vec2(\n        atan(uv.y/uv.x), //degree\n        length(uv) //radius\n    );\n}\n\nvec2 to_cartesian(vec2 pc){\n    return vec2(\n        pc.y * cos(pc.x),\n        pc.y * sin(pc.x)\n    );\n}\n\n//Get point x of a star defined by n points around the origin,\n//with a certain radius.\nvec2 star_point(int total_points, int current_point, float radius, float rotation){\n    float angle = (2.0*PI*float(current_point))/float(total_points);\n    \n    vec2 point = vec2(\n        angle + rotation,\n        radius\n    );\n    \n    return to_cartesian(point);\n}\n\n//Get the color of a point if it happens to be on a star\n//defined by n points around the origin, of a specified radius.\n//Expect uv to be normalized [-1,1].\n//Returns a color if it collides with a star point, with nonzero alpha.\n//Returns black, with 0 alpha if no collision.\nvec4 star_collision(vec2 uv, int total_points, float radius, float rotation){\n    vec4 col = vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0; i<total_points; i++){\n        int target = (i+2)%total_points;\n        \n        vec2 p1 = star_point(total_points, i, radius, rotation);\n        vec2 p2 = star_point(total_points, target, radius, rotation);\n        \n        if(onLine(uv.x,uv.y,p1,p2)){\n            col = vec4(PALETTE[i%PALETTE_LENGTH], 1.0);\n            \n            float combined_dist =\n                distance(uv, p1) +\n                distance(uv, p2);\n            \n            col*=(1.0/pow(combined_dist*1.0, 2.0));\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    //vec2 uv = ((2.0)*fragCoord)/iResolution.xy - 1.0;\n    vec2 uv = (2.0*fragCoord - iResolution.xy) / iResolution.y;\n    \n    // How large of a radius between each star rendered.\n    float dist_between_stars = MAX_RADIUS / float(NUM_STARS);\n    \n    float first_radius = iTime*EXPAND_RATE;\n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    //Check each star in STARS for an intersection\n    for(int i=0; i<NUM_STARS; i++){\n        int cur_points = STARS[i];\n        float cur_radius = first_radius - (float(i)*dist_between_stars);\n        \n        if(cur_radius<0.0)\n            break;\n        \n        cur_radius = mod(cur_radius, MAX_RADIUS);\n        \n        float cur_rotation = mod(iTime*ROTATION_RATE, 2.0*PI);\n        if(i%2==1)\n            cur_rotation*=-1.0;\n        \n        vec4 result = star_collision(uv, cur_points, cur_radius,cur_rotation);\n        vec4 result2 = star_collision(uv, cur_points, cur_radius,(-1.0)*cur_rotation);\n        if(result.a > 0.0)\n            col = result.xyz;\n        if(result2.a > 0.0)\n            col = result2.xyz;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBcDV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[719, 884, 915, 915, 939], [940, 940, 971, 971, 1006], [1007, 1007, 1038, 1038, 1076], [1078, 1125, 1173, 1173, 1625], [1627, 1643, 1666, 1666, 1754], [1756, 1756, 1783, 1783, 1860], [1862, 1950, 2033, 2033, 2217], [2219, 2496, 2573, 2573, 3162]], "test": "untested"}
{"id": "wtScWV", "name": "semiBarycentric triangle dist", "author": "ollj", "description": "using Barycentric coordinates and pointers to predict, what line.segments are closest to a point.\n\norange+teal= correct\nred/purple has false interior, looks like a \"hole\" but ALWAYS needs less divisions.", "tags": ["2d", "triangle", "distance", "barycentric", "predict"], "likes": 5, "viewed": 787, "published": 3, "date": "1595360190", "time_retrieved": "2024-07-30T20:54:35.733701", "image_code": "//sibling   (interactive): https://www.shadertoy.com/view/wl2cRt#\n//parent (smaller canvas): https://www.shadertoy.com/view/XsXSz4\n//but still:\n// The MIT License\n// Copyright © 2014 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n/*\nPointDistanceToStriangle naively has [3 divisions] and [9 dot()] for 3 line distances.\nsemiBaricentric quite efficiently uses barycentric coordinates to exclude\nthe triangle borders that are NOT nearest to the uv, with lots of if(a>b)\n,that are still quite similar within most branching paths\n\nconverting to barycentric adds 1 division\n, to get the same BaricentricDeterminantReciprocal for every fragment \n(this is a fragment shader precomputing task\n;1 determinant foreach unique triangleShape)\n\nThan semiBaricentric has [1 to 3 divisions] and [3 to 9 dot].\nThe inside of the triangle is the only place with the highest complexity.\nMost of the area outside of the triangle will only do 1 division and 3 dot.\n\nsemiBaricentric        is roughly 16 to 22 substractions/additions (and lots of swivels and negations)\nparent (common method) is         13       substractions/additions\nBoth only ned 1 deferred sqrt()\nsemiBaricentric is one less sign()\n*/\n\n//addendum 2020-11\n//me dumb, if(inside  triangle) the smallest barycentricCoord value tells me what line is closest to the point\n//me dumb, if(outside triangle && only one <1) the only barycentricCoordinate that is <0 tells me the closest line\n//me dumb, if(outside triangle && only one >0) the only barycentricCoordinate that is >0 tells the the closest corner\n\n\nconst float twothirds=2./3.;//is not a division on runtime.\n\nconst vec3 vs=vec3(-1,0,1);\nvec2 perp(vec2 a){return a.yx*vs.xz;}\nvec3 sat(vec3 a){return clamp(a,vec3(0),vec3(1));}\nfloat suv(vec3 a){return a.x+a.y+a.z;}\nfloat suv(vec2 a){return a.x+a.y;}\nfloat sat(float a){return clamp(a,0.,1.);}\n\n#define dd(a) dot(a,a)\n/*\n//segment(() is a very general distance to line segment (Uv Origin Target):\n#define segment2(a,c,d) dd((a-(c*d((dot(a,c)/dd(c))))))      \n#define segments(u,o,t,d) (segment2((u-o),(t-o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n*/\n//same as above, but in batches, too have less sqrt()\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\nfloat segment(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segment(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segment(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n//carthesian transform, duped for transposed-inputs variants\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant, you may want to buffer this more globally\nfloat c2bdet(vec3 X,vec3 Y){return 1./suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//return barycentric of carthesian point (l) over triangle (a,b,c)==(X,Y)\nvec3 c2b(vec2 p,vec3 X,vec3 Y,float d){p-=vec2(X.z,Y.z)\n ;vec4 a=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*p.xyxy\n ;p=vec2(suv(a.xy),suv(a.zw))*d;return vec3(p,1.-p.x-p.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float carthesianDet=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //carthesianDet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //carthesianDet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,carthesianDet)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segment(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segment(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segment(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segment(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}}\n  //min of 3 line distances only inside the triangle\n\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}//put corners in matrix, to point at them\n\nvoid mainImage(out vec4 fragColor,vec2 fragCoord\n){vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n ;vec2 v1=cos(iTime+vec2(0.,2.00)+0.)\n ;vec2 v2=cos(iTime+vec2(0.,1.50)+1.5)\n ;vec2 v3=cos(iTime+vec2(0.,3.00)+4.)\n ;float d=sdTriangle(v1,v2,v3,p)\n ;vec3 blue=vec3(1,4,7)*.1\n ;if(mod(iTime*.3,2.)<1.)blue=vec3(6,2,6)*.1\n ;vec3 c=vec3(1)-sign(d)*blue\n ;c*=1.-exp(-2.0*abs(d))\n ;c*=.8+.2*cos(120.*d)\n ;c=mix(c,vec3(1),1.-smoothstep(0.,.02,abs(d)))\n ;fragColor=vec4(c,1)\n ;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtScWV.jpg", "access": "api", "license": "mit", "functions": [[2631, 2631, 2649, 2649, 2668], [2669, 2669, 2686, 2686, 2719], [2720, 2720, 2738, 2738, 2758], [2759, 2759, 2777, 2777, 2793], [2794, 2794, 2813, 2813, 2836], [2861, 3160, 3198, 3198, 3269], [3270, 3270, 3306, 3306, 3339], [3340, 3340, 3394, 3394, 3476], [3477, 3477, 3547, 3547, 3664], [3780, 3926, 3954, 3954, 3996], [3997, 3997, 4032, 4032, 4057], [4058, 4132, 4171, 4171, 4324], [4325, 4325, 4356, 4356, 4387], [4388, 4388, 4434, 4434, 4460], [4461, 4461, 4499, 4499, 4523], [4733, 4986, 5006, 5006, 5054], [5055, 5055, 5075, 5075, 5123], [5124, 5124, 5144, 5144, 5208], [5385, 5461, 5494, 5494, 6795], [6850, 7005, 7055, 7055, 7098], [7141, 7141, 7192, 7192, 7619]], "test": "untested"}
{"id": "WtBcWK", "name": "Better SDF shadows with CSG.", "author": "palash", "description": "Small changes to traditional shadow technique to get softer and more accurate shadow for interior sdf objects. \nMove mouse up/down to see the difference.\nMove mouse left/right to change the sun radius.", "tags": ["mouse", "raymarch", "sdf", "csg", "pbr", "subtract", "disney"], "likes": 2, "viewed": 387, "published": 3, "date": "1595332976", "time_retrieved": "2024-07-30T20:54:36.495664", "image_code": "//code adapted from shader by romainguy: https://www.shadertoy.com/view/XlKSDR\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define PI 3.14159265359\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdPlane(in vec3 p) {\n    return p.y;\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t) {\n    return length(vec2(length(p.xz) - t.x, p.y)) - t.y;\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nvec2 scene(in vec3 position) {\n    vec3 pos = position - vec3(0.0, 0.4, 0.0);\n    vec3 pos2 = position - vec3(1.0, 0.4, 0.0);\n    vec2 scene = opUnion(\n          vec2(sdPlane(position), 1.0),\n          vec2(opSubtraction(\n              sdSphere(pos+vec3(0.,-0.1,-0.1), 0.4), sdBox(pos, vec3(0.27))), 12.0)\n    );\n    return scene;\n}\n\n//------------------------------------------------------------------------------\n// Ray casting\n//------------------------------------------------------------------------------\n\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    float k = (iMouse.x/iResolution.x)/5.; //sort of sun radius\n    bool new = iMouse.y/iResolution.y<0.5;\n\n    for (int i = 0; i < 1000; i++) {\n        float h = scene(origin + direction * t).x;\n        if(new) h+=t*k;\n        if (h < 0.001) return 0.0;\n        hit = min(hit, h / (max(0.02, t)*(k+k) ));\n        if(new) h*=inversesqrt(t+1.);\n        t += max(h, 0.02);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n\nvec2 traceRay(in vec3 origin, in vec3 direction) {\n    float material = -1.0;\n\n    float t = 0.02;\n    \n    for (int i = 0; i < 1000; i++) {\n        vec2 hit = scene(origin + direction * t) ;\n        if (hit.x < 0.002 || t > 20.0) break;\n        t += hit.x;\n        material = hit.y;\n    }\n\n    if (t > 20.0) {\n        material = -1.0;\n    }\n\n    return vec2(t, material);\n}\n\nvec3 normal(in vec3 position) {\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          scene(position + epsilon.xyy).x - scene(position - epsilon.xyy).x,\n          scene(position + epsilon.yxy).x - scene(position - epsilon.yxy).x,\n          scene(position + epsilon.yyx).x - scene(position - epsilon.yyx).x);\n    return normalize(n);\n}\n\n//------------------------------------------------------------------------------\n// BRDF\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / PI;\n}\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n//------------------------------------------------------------------------------\n// Rendering\n//------------------------------------------------------------------------------\n\nvec3 render(in vec3 origin, in vec3 direction, out float distance) {\n    // Sky gradient\n    vec3 color = vec3(0.65, 0.85, 1.0) + direction.y * 0.72;\n\n    // (distance, material)\n    vec2 hit = traceRay(origin, direction);\n    distance = hit.x;\n    float material = hit.y;\n\n    // We've hit something in the scene\n    if (material > 0.0) {\n        vec3 position = origin + distance * direction;\n\n        vec3 v = normalize(-direction);\n        vec3 n = normal(position);\n        vec3 l = normalize(vec3(0.6, 0.7, -0.7));\n        vec3 h = normalize(v + l);\n        vec3 r = normalize(reflect(direction, n));\n\n        float NoV = abs(dot(n, v)) + 1e-5;\n        float NoL = saturate(dot(n, l));\n        float NoH = saturate(dot(n, h));\n        float LoH = saturate(dot(l, h));\n\n        vec3 baseColor = vec3(0.0);\n        float roughness = 0.0;\n        float metallic = 0.0;\n\n        float intensity = 2.0;\n        float indirectIntensity = 0.64;\n\n        if (material < 4.0)  {\n            // Checkerboard floor\n            float f = mod(floor(6.0 * position.z) + floor(6.0 * position.x), 2.0);\n            baseColor = 0.4 + f * vec3(0.6);\n            roughness = 0.1;\n        } else if (material < 16.0) {\n            // Metallic objects\n            baseColor = vec3(0.3, 0.0, 0.0);\n            roughness = 0.2;\n        }\n\n        float linearRoughness = roughness * roughness;\n        vec3 diffuseColor = (1.0 - metallic) * baseColor.rgb;\n        vec3 f0 = 0.04 * (1.0 - metallic) + baseColor.rgb * metallic;\n\n        float attenuation = shadow(position, l);\n\n        // specular BRDF\n        float D = D_GGX(linearRoughness, NoH, h);\n        float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n        vec3  F = F_Schlick(f0, LoH);\n        vec3 Fr = (D * V) * F;\n\n        // diffuse BRDF\n        vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n\n        color = Fd + Fr;\n        color *= (intensity * attenuation * NoL) * vec3(0.98, 0.92, 0.89);\n\n        // diffuse indirect\n        vec3 indirectDiffuse = Irradiance_SphericalHarmonics(n) * Fd_Lambert();\n\n        vec2 indirectHit = traceRay(position, r);\n        vec3 indirectSpecular = vec3(0.65, 0.85, 1.0) + r.y * 0.72;\n        \n\t\tif (indirectHit.y > 0.0) {\n            if (indirectHit.y < 4.0)  {\n                vec3 indirectPosition = position + indirectHit.x * r;\n                // Checkerboard floor\n                float f = mod(floor(6.0 * indirectPosition.z) + floor(6.0 * indirectPosition.x), 2.0);\n                indirectSpecular = 0.4 + f * vec3(0.6);\n            } else if (indirectHit.y < 16.0) {\n                // Metallic objects\n                indirectSpecular = vec3(0.3, 0.0, 0.0);\n            }\n        }\n\t\t\n\n        // indirect contribution\n        vec2 dfg = PrefilteredDFG_Karis(roughness, NoV);\n        vec3 specularColor = f0 * dfg.x + dfg.y;\n        vec3 ibl = diffuseColor * indirectDiffuse + indirectSpecular * specularColor;\n\n        color += ibl * attenuation;\n    }\n\n    return color;\n}\n\n//------------------------------------------------------------------------------\n// Setup and execution\n//------------------------------------------------------------------------------\n\nmat3 setCamera(in vec3 origin, in vec3 target, float rotation) {\n    vec3 forward = normalize(target - origin);\n    vec3 orientation = vec3(sin(rotation), cos(rotation), 0.0);\n    vec3 left = normalize(cross(forward, orientation));\n    vec3 up = normalize(cross(left, forward));\n    return mat3(left, up, forward);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized coordinates\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    // Aspect ratio\n    p.x *= iResolution.x / iResolution.y;\n\n    // Camera position and \"look at\"\n    vec3 origin = vec3(0.0, 0.8, 0.0);\n    vec3 target = vec3(0.0);\n\n    origin.x += 1.7 * cos(iTime * 0.2);\n    origin.z += 1.7 * sin(iTime * 0.2);\n\n    mat3 toWorld = setCamera(origin, target, 0.0);\n    vec3 direction = toWorld * normalize(vec3(p.xy, 2.0));\n\n    // Render scene\n    float distance;\n    vec3 color = render(origin, direction, distance);\n\n    // Tone mapping\n    color = Tonemap_ACES(color);\n\n    // Exponential distance fog\n    color = mix(color, 0.8 * vec3(0.7, 0.8, 1.0), 1.0 - exp2(-0.011 * distance * distance));\n\n    // Gamma compression\n    color = OECF_sRGBFast(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 177, 177, 264], [266, 266, 292, 292, 310], [312, 312, 348, 348, 376], [378, 378, 415, 415, 473], [475, 475, 507, 507, 543], [545, 545, 588, 588, 610], [612, 612, 642, 642, 944], [1124, 1124, 1173, 1173, 1656], [1658, 1658, 1708, 1708, 2032], [2034, 2034, 2065, 2065, 2385], [2558, 2558, 2579, 2579, 2627], [2629, 2629, 2690, 2775, 2972], [2974, 2974, 3047, 3139, 3339], [3341, 3341, 3383, 3463, 3517], [3519, 3519, 3568, 3568, 3616], [3618, 3618, 3691, 3748, 3961], [3963, 3963, 3983, 3983, 4006], [4192, 4192, 4242, 4326, 4684], [4686, 4686, 4741, 4798, 5058], [5262, 5262, 5295, 5351, 5537], [5539, 5539, 5578, 5578, 5621], [5799, 5799, 5867, 5887, 8800], [8988, 8988, 9052, 9052, 9304], [9306, 9306, 9361, 9391, 10180]], "test": "untested"}
{"id": "wtjyWy", "name": "Sea Of Sweets", "author": "Plento", "description": "A concoction of sugary sticky confection", "tags": ["2d", "wave", "sinusoidal", "sweets"], "likes": 10, "viewed": 408, "published": 3, "date": "1595306047", "time_retrieved": "2024-07-30T20:54:37.256629", "image_code": "#define R iResolution.xy\n#define ss(a, b, t) smoothstep(a, b, t)\n\n\nfloat h(float p){\n\treturn cos(p*5.)*.04 + cos(p*7. + 4.)*.07 + cos(p*10. + 6.)*.05 + cos(p*15.)*.03\n        +cos(p*20. + 2.)*.017;\n}\n\nvoid mainImage( out vec4 f, in vec2 u ){\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    uv.y += .5;\n    uv.y+=abs(sin(iTime*.08))*1.66;\n    \n    vec3 col = vec3(0);\n    \n    for(float i = 28.; i > 0.; i--){\n        uv.y += cos(43.3+i*46. + iTime*4.5)*.005;\n        float t = uv.x + i+4. + iTime*.1;\n        vec3 c = .61 + .33*cos(vec3(0.7, 2., 0.9)*(t*1.1 + uv.y) - vec3(8., 6., 6.7));\n        float val = h(t);\n        col = mix(c, col,  ss(.0, .01, uv.y - val - i*.1));\n    \tcol = mix(vec3(0.), col,  ss(.0038, .009, abs(uv.y - val - i*.1)));\n    }\n    col *= .7;\n    \n    col = pow(col, vec3(2.))*3.5;\n    col = 1.-exp(-col);\n    col *= ss(.0, .25, 1.-abs(uv.x));\n    \n    f = vec4(col, 1.0);\n}\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjyWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 67, 84, 84, 199], [201, 201, 241, 241, 896]], "test": "untested"}
{"id": "wtBcWG", "name": "Cyclic randomized diffusion", "author": "ciphered", "description": "When playing with Cyclic DLA, I realized that a simplification to my system could be made with some sort of randomized diffusion. Nice patterns emerge from this solution that reminds me of the Belousov-Zhabotinsky reaction.", "tags": ["random", "diffusion", "pattern", "belousov", "zhabotinsky", "growth"], "likes": 19, "viewed": 5916, "published": 3, "date": "1595299451", "time_retrieved": "2024-07-30T20:54:38.018592", "image_code": "// @author ciphrd https://instagram.com/ciphrd\n// @license MIT\n//\n// When I was exploring Diffusion-Limited Aggregation, I tried to generate patterns that evolve over\n// time rather than a finite structure. I called this variation the Cyclic DLA, and I describe the \n// idea on my blog:\n// https://ciphered.xyz/2020/07/21/cyclic-diffusion-limited-aggregation/\n//\n// In this variation, the aggregate is subject to decay over time. Once a particle is in contact to\n// enough amount of aggregate, it gets added to it and then its position is randomized within the grid.\n// The particle can still play its role in the aggregation. \n//\n// I realized that when the ratio particles / cells in the aggregation grid gets close to 1, bsacially\n// any cell of the grid can be subject to aggregation. Therefore, it is possible to simulate the same\n// effect without particles, just by considering that a cell has a certain chance to \"aggregate\" at each\n// iteration.\n//\n\n\nfloat hash21 (vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float R = texture(iChannel0, uv).r;\n    vec3 col = vec3(R);\n    col.b*= length(col);\n    col.g*= length(col) - 1.;\n    col+= hash21(uv) * .12;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define DECAY 0.93\n\n\nfloat rand(vec2 n) { return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453); }\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 res = 1. / iResolution.xy;\n\tvec2 uv = fragCoord * res;\n    \n    float T = min(iTime/60., 1.);\n    \n    if (iFrame < 20) {\n     \tfloat C = smoothstep(0.1, 0.09, length(uv-.5));\n        fragColor = vec4(C, 0., 0., 1.);\n        return;\n    }\n\t\n\tfloat r = 0.0;\n\tr+= texture(iChannel0, uv + vec2(-1,-1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(0,-1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(1,-1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(1,0) * res).r;\n\tr+= texture(iChannel0, uv + vec2(1,1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(0,1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(-1,1) * res).r;\n\tr+= texture(iChannel0, uv + vec2(-1,0) * res).r;\n\t\n\t\n\tfloat tr = rand(uv + vec2(iTime*3., iTime*.2));\n\t\n\tvec4 color = texture(iChannel0, uv);\n\tfloat cr = color.r;\n\tcolor.r*= DECAY;\n\tif (r > 0.2 + 0.7*T && tr > .5 + 0.45 * min(T+.3, 1.) * -cos(uv.x*3.+iTime*.5) && cr < .0005) {\n\t\tcolor.r = 1.0;\n\t}\n    \n\tfragColor = color;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWG.jpg", "access": "api", "license": "mit", "functions": [[960, 960, 983, 983, 1048], [1050, 1050, 1107, 1107, 1352]], "test": "untested"}
{"id": "wl2cWG", "name": "Another fractal cave system", "author": "jarble", "description": "This cave system is generated using trigonometric functions.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 2, "viewed": 317, "published": 3, "date": "1595286772", "time_retrieved": "2024-07-30T20:54:38.771578", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat caves(vec3 p,float size1){\n    float i = size1;\n    //p = ((cos(p/size1)/i))*i;\n    vec3 s1 = sin(p.yzx/50.0);\n    p += s1*50.0;\n    p = (sin(p/vec3(50.0+length(s1))))*size1;\n    return size-length(p);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*10.0;\n\tp -= 100.0;\n    float size1 = 1000.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3; k++){\n        p /= i;\n        result = min(caves(p*i,size1),result);\n        i *= 5.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (-result-200.0)*scale/4.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return vec3(.8,.3,.3)*(sin(vec3(sceneSDF(p*5.0))))/4.0+vec3(.5,.4,.4);\n}\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t1 = iTime/2.0;\n    vec3 eye = vec3(7.0+cos(t1),-7.0-sin(t1),2.0+sin(t1));\n    \n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2cWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[590, 590, 622, 622, 799], [801, 801, 825, 825, 1149], [1151, 1151, 1179, 1179, 1288], [1292, 1713, 1804, 1804, 2116], [2131, 2385, 2450, 2450, 2582], [2584, 2673, 2702, 2702, 3012], [3014, 3506, 3646, 3646, 4256], [4258, 4628, 4713, 4713, 5060], [5062, 5389, 5438, 5473, 5604], [5606, 5606, 5663, 5663, 6808]], "test": "untested"}
{"id": "3ljcWy", "name": "Rope", "author": "fizzgig", "description": "ropes are made of sierpinski gaskets right", "tags": ["rope"], "likes": 21, "viewed": 503, "published": 3, "date": "1595274659", "time_retrieved": "2024-07-30T20:54:39.608341", "image_code": "struct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Light {\n    vec3 position;\n    float strongth;\n    vec3 color;\n};\n\n#define PI 3.1415926\n    \nmat4 euler(float x, float y, float z) {\n    mat4 xmat = mat4(vec4(1.0,  0.0,    0.0,    0.0),\n                     vec4(0.0,  cos(x), sin(x), 0.0),\n                     vec4(0.0, -sin(x), cos(x), 0.0),\n                     vec4(0.0,  0.0,    0.0,    1.0));\n    mat4 ymat = mat4(vec4( cos(y), 0.0, sin(y), 0.0),\n                     vec4( 0.0,    1.0, 0.0,    0.0),\n                     vec4(-sin(y), 0.0, cos(y), 0.0),\n                     vec4( 0.0,    0.0, 0.0,    1.0));\n    mat4 zmat = mat4(vec4( cos(z),  sin(z), 0.0, 0.0),\n                     vec4(-sin(z),  cos(z), 0.0, 0.0),\n                     vec4( 0.0,     0.0,    1.0, 0.0),\n                     vec4( 0.0,     0.0,    0.0, 1.0));\n    \n    return xmat*ymat*zmat;\n}\n\nmat4 transform(float x, float y, float z) {\n    return mat4(vec4(1.0, 0.0, 0.0, 0.0),\n                vec4(0.0, 1.0, 0.0, 0.0),\n                vec4(0.0, 0.0, 1.0, 0.0),\n                vec4(x,   y,   z,   1.0));\n}\n\nfloat sphereSDF(vec3 center, float radius, vec3 point) {\n    return length(point - center) - radius;\n}\n\nfloat planeSDF(vec3 origin, vec3 normal, vec3 point) {\n    return dot(point - origin, normal);\n}\n\nfloat ropeSDF(float coiledness, uint n, vec3 point) {\n    for (uint i = 0u; i < n; ++i) {\n        float r = length(point.xz);\n    \tfloat t = atan(-point.x, -point.z) + PI;\n        \n        t -= 2.0*PI*coiledness;\n        t = mod(t, 2.0*PI/3.0) + 2.0*PI/3.0;\n        \n        point.x = r*sin(t);\n        point.z = r*cos(t);\n        \n        point.z += 1.0;\n        point.xz *= 1.0 + 1.0/sin(PI/3.0);\n        //point.z *= -1.0;\n    }\n    \n    point.xz /= 1.0 + sin(PI/3.0);\n    \n    float lpxz = length(point.xz);\n    \n    vec2 d = vec2(lpxz, abs(point.y + 0.5)) - vec2(1.0,0.5);\n    \n    for (uint i = 0u; i < n; ++i) d.x /= 1.0 + 1.0/sin(PI/3.0);\n    \n    d.x *= 1.0 + sin(PI/3.0);\n    \n    return min(max(d.x,d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sceneSDF(vec3 point) {\n    point.y /= 20.0;\n    return ropeSDF(1.0-(0.5*sin(iTime*0.2)+0.5)*(point.y+1.0), 6u, point);\n   /*return min(\n       min(\n           min(\n               sphereSDF(vec3(-0.7, 0.7, 0.0), 0.5, point),\n               sphereSDF(vec3(0.7, 0.7, 0.0), 0.5, point)\n           ),\n           sphereSDF(vec3(0.0), 1.0, point)\n       ),\n       planeSDF(vec3(0.0), vec3(0.0, 1.0, 0.0), point)\n     );\n   */\n}\n\nvec3 sceneSDFGradient(vec3 point, float epsilon) {\n    vec3 xe = vec3(epsilon, 0.0, 0.0)/2.0;\n    vec3 ye = vec3(0.0, epsilon, 0.0)/2.0;\n    vec3 ze = vec3(0.0, 0.0, epsilon)/2.0;\n    \n    return vec3(\n        (sceneSDF(point + xe) - sceneSDF(point - xe)) / epsilon,\n        (sceneSDF(point + ye) - sceneSDF(point - ye)) / epsilon,\n        (sceneSDF(point + ze) - sceneSDF(point - ze)) / epsilon\n      );\n}\n\nvec3 sceneSDFNormal(vec3 point) {\n    return normalize(sceneSDFGradient(point, 0.01));\n}\n\nvec3 rayPoint(Ray ray, float dist) {\n    return ray.origin + dist * ray.direction;\n}\n\nvec3 screen(vec3 a, vec3 b) {\n    return vec3(1.0) - (vec3(1.0) - a)*(vec3(1.0) - b);\n}\n\nvec3 lightPoint(Light light, vec3 point, vec3 normal, vec3 camera, vec3 diffuse, vec3 bounce, vec3 current) {\n    vec3 lightchord = light.position - point;\n    \n    vec3 lightcolor = light.color * 1.0 / pow(length(lightchord/3.0)/light.strongth+1.0, 2.0);\n    \n    vec3 colour = diffuse * lightcolor * max(dot(normal, normalize(lightchord)), 0.0);\n    colour = screen(colour, bounce * lightcolor * max(vec3(1.0) - 5.0*(vec3(1.0) - dot(normalize(lightchord), reflect(normalize(point - camera), normal))), 0.0));\n    \n    return screen(current, colour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float lightangle = iTime;\n    \n    Light light1 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(1.0, 0.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light2 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 1.0, 0.0));\n    \n    lightangle += PI*2./3.;\n    \n    Light light3 = Light(vec3(2.0*cos(lightangle), 2.0, 2.0*sin(lightangle)), 10.0, vec3(0.0, 0.0, 1.0));\n    \n    float disttoscreen = 1.0;\n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 camorigin = vec3(-6.0, 6.0, 0.0);\n    \n    mat4 camtoscene = transform(camorigin.x, camorigin.y, camorigin.z)*euler(PI*0.5, -PI*0.18, 0.0);\n    \n    Ray ray = Ray((camtoscene*vec4(vec3(0.0),1.0)).xyz,\n                  normalize(camtoscene*vec4(uv.x, uv.y, disttoscreen, 0.0)).xyz);\n    \n    vec3 point = camorigin;\n    \n    float scenedist = sceneSDF(point);\n    float raydist = 0.0;\n    \n    float epsilon = 0.001;\n    float end = 100.0;\n    \n    while (scenedist > epsilon) {\n        if (raydist > end) {\n            fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n            return;\n        }\n        \n        point = rayPoint(ray, raydist);\n        \n        scenedist = sceneSDF(point);\n        \n        raydist += scenedist;\n    }\n    \n    vec3 normal = sceneSDFNormal(point);\n    vec3 diffuse = vec3(1.0);\n    vec3 bounce = vec3(1.0);\n        \n    vec3 colour = lightPoint(light1, point, normal, camorigin, diffuse, bounce, vec3(0.0));\n    colour = lightPoint(light2, point, normal, camorigin, diffuse, bounce, colour);\n    colour = lightPoint(light3, point, normal, camorigin, diffuse, bounce, colour);\n\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[154, 154, 193, 193, 882], [884, 884, 927, 927, 1098], [1100, 1100, 1156, 1156, 1202], [1204, 1204, 1258, 1258, 1300], [1302, 1302, 1355, 1355, 2047], [2049, 2049, 2077, 2077, 2475], [2477, 2477, 2527, 2527, 2883], [2885, 2885, 2918, 2918, 2973], [2975, 2975, 3011, 3011, 3059], [3061, 3061, 3090, 3090, 3148], [3150, 3150, 3259, 3259, 3703], [3705, 3705, 3762, 3762, 5501]], "test": "untested"}
{"id": "3tjyWy", "name": "Mitchell-Netravali Filter", "author": "TinyTexel", "description": "https://de.wikipedia.org/wiki/Mitchell-Netravali-Filter", "tags": ["filter", "filtering", "interpolation", "reconstruction"], "likes": 0, "viewed": 534, "published": 3, "date": "1595268741", "time_retrieved": "2024-07-30T20:54:40.620635", "image_code": "// License: CC0 (https://creativecommons.org/publicdomain/zero/1.0/)\n\n/*\n\thttps://de.wikipedia.org/wiki/Mitchell-Netravali-Filter\n*/\n\n#define PARAMS 0\n\n#if PARAMS == 0\n\n// cubic B-Spline\nconst float MN_B = 1.0;\nconst float MN_C = 0.0;\n\n#elif PARAMS == 1\n\nconst float MN_B = 1.0/3.0;\nconst float MN_C = 1.0/3.0;\n\n#elif PARAMS == 2\n\n// Rom-Spline\nconst float MN_B = 0.0;\nconst float MN_C = 1.0/2.0;\n\n#endif\n#undef PARAMS\n\nfloat MNKern(float x)\n{\n    const float B = MN_B;\n    const float C = MN_C;\n    \n    x = abs(x);\n    \n    float a = x < 1.0 ?   1.0 -  2.0/6.0*B         :   8.0/6.0*B + 4.0*C;\n    float b = x < 1.0 ?   0.0                      :     - 2.0*B - 8.0*C;\n    float c = x < 1.0 ? - 3.0 +      2.0*B + 1.0*C :       1.0*B + 5.0*C;\n    float d = x < 1.0 ?   2.0 -      1.5*B - 1.0*C :  -1.0/6.0*B - 1.0*C;\n    \n    return a + x * (b + x * (c + x * d));\n}\n\nvec2 MNKern2(float x)\n{\n    const float B = MN_B;\n    const float C = MN_C;\n    \n    float sn = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x);\n    \n    float a = x < 1.0 ?   1.0 -  2.0/6.0*B         :   8.0/6.0*B + 4.0*C;\n    float b = x < 1.0 ?   0.0                      :     - 2.0*B - 8.0*C;\n    float c = x < 1.0 ? - 3.0 +      2.0*B + 1.0*C :       1.0*B + 5.0*C;\n    float d = x < 1.0 ?   2.0 -      1.5*B - 1.0*C :  -1.0/6.0*B - 1.0*C;\n    \n    float d0 = (a + x * (b + x * (    c + x *      d)));\n    float d1 =           b + x * (2.0*c + x * (3.0*d));\n    \n    return vec2(sn * d1, d0);\n}\n\nvec3 MNKern3(float x)\n{\n    const float B = MN_B;\n    const float C = MN_C;\n    \n    float sn = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x);\n    \n    float a = x < 1.0 ?   1.0 -  2.0/6.0*B         :   8.0/6.0*B + 4.0*C;\n    float b = x < 1.0 ?   0.0                      :     - 2.0*B - 8.0*C;\n    float c = x < 1.0 ? - 3.0 +      2.0*B + 1.0*C :       1.0*B + 5.0*C;\n    float d = x < 1.0 ?   2.0 -      1.5*B - 1.0*C :  -1.0/6.0*B - 1.0*C;\n    \n    float d0 = (a + x * (b + x * (    c + x *      d)));\n    float d1 =           b + x * (2.0*c + x * (3.0*d));\n    float d2 =                    2.0*c + x * (6.0*d);\n    \n    return vec3(d2, sn * d1, d0);\n}\n\nfloat MNKernD1(float x)\n{\n    const float B = MN_B;\n    const float C = MN_C;\n        \n    float sn = x < 0.0 ? -1.0 : 1.0;\n    \n    x = abs(x);\n    \n    float a = x < 1.0 ?                  0.0 : -2.0*B -  8.0*C;\n    float b = x < 1.0 ? -6.0 + 4.0*B + 2.0*C :  2.0*B + 10.0*C;\n    float c = x < 1.0 ?  6.0 - 4.5*B - 3.0*C : -0.5*B -  3.0*C;\n    \n    return sn * (a + x * (b + x * c));\n}\n\n\nvec4 MNKern2(vec2 p)\n{\n    vec2 kernX = MNKern2(p.x);\n    vec2 kernY = MNKern2(p.y);\n    \n    return vec4(kernX.x * kernY.y,  // d/dx\n                kernX.y * kernY.x,  // d/dy\n                kernX.x * kernY.x,  // dd/dxdy\n                kernX.y * kernY.y); // f\n}\n\nvoid mainImage( out vec4 outCol, in vec2 uv0 )\n{\n\tvec2 uv = uv0 - 0.5;\n    uv0 += 0.0;\n    \n    vec2 tex = uv0;\n    tex -= iResolution.xy * 0.5;\n    tex /= iResolution.xx * 0.125;\n\n    tex *= 0.5;\n    \n\n    vec3 col = vec3(0.0);\n    \n\tcol = mix(vec3(1.0), vec3(0.9), Grid(tex.xy * 4.0, 0.0));        \n\tcol = mix(col, vec3(0.5), Grid(tex.xy * 1.0, 0.0));        \n\tcol = mix(col, vec3(0.125), Cross(tex.xy * 1.0, 0.)); \t\n    \n    \n    col = mix(col, vec3(0.0, 1.0, 0.5), Graph(MNKern3(tex.x).x*0.5 - tex.y, 0.5)*0.5);       \n    col = mix(col, vec3(0.0, 0.5, 1.0), Graph(MNKern3(tex.x).y - tex.y, 0.5));       \n    col = mix(col, vec3(1.0, 0.0, 0.0), Graph(MNKern3(tex.x).z - tex.y, 0.5)); \n    \n    #if 1\n    vec2 s = (uv0/iResolution.xy*2.0-1.0);\n    s.x = 1.0-Pow2(s.x);    s.y = 1.0-Pow2(s.y);\n    col *= mix(1.0, 0.4, Pow2(1.0-sqrt(s.x*s.y)));\n    #endif\n    \n    outCol = vec4(GammaEncode(clamp01(col)), 1.0);    \n\n}", "image_inputs": [], "common_code": "\n#define PixelCount iResolution.xy\n#define clamp01(x) clamp(x, 0.0, 1.0)\n#define rsqrt inversesqrt\n\nconst float Pi = 3.14159265359;\nconst float Pi05 = Pi * 0.5;\nconst float Pi2  = Pi * 2.0;\nconst float RcpPi= 1.0 / Pi;\n\nfloat Pow2(float x) {return x*x;}\nfloat Pow3(float x) {return x*x*x;}\nfloat Pow4(float x) {return Pow2(Pow2(x));}\n\nfloat GammaEncode(float x) {return pow(x, 1.0 / 2.2);}\nvec2 GammaEncode(vec2 x) {return pow(x, vec2(1.0 / 2.2));}\nvec3 GammaEncode(vec3 x) {return pow(x, vec3(1.0 / 2.2));}\nvec4 GammaEncode(vec4 x) {return pow(x, vec4(1.0 / 2.2));}\n\nfloat ddxyLen(float v) { return length(vec2(dFdx(v), dFdy(v))); }\nfloat ddxyRcpLen(float v) { return rsqrt( Pow2(dFdx(v)) + Pow2(dFdy(v)) ); }\n\n\nfloat rescale(float v) { return v * ddxyRcpLen(v); }\n\nfloat Graph(float f, float b)\n{\n    return clamp01(1.0 - (abs(rescale(f))-0.5-b)); \n}\n\n\nfloat Line(float u, float b) { return Graph(u, b); }\nfloat Lines(float u, float b) { return Graph(sin(u * Pi), b); }\n\nfloat Grid(vec2 uv, float b)\n{\n    float xl = Lines(uv.x, b);    \n    float yl = Lines(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Cross(vec2 uv, float b)\n{\n    float xl = Line(uv.x, b);    \n    float yl = Line(uv.y, b);\n\n    return max(xl, yl);\n}\n\nfloat Dot(vec2 sp, vec2 dp, float dr)\n{\n    float v = length(sp - dp) - dr;\n    \n    if(v > dr) return 0.0;\n    \n    v *= ddxyRcpLen(v);\n    v = 1.0 - clamp(v * 1.0, 0.0, 1.0);\n    \n    return v;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyWy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[420, 420, 443, 443, 866], [868, 868, 891, 891, 1462], [1464, 1464, 1487, 1487, 2117], [2119, 2119, 2144, 2144, 2506], [2509, 2509, 2531, 2531, 2776], [2778, 2778, 2826, 2826, 3698]], "test": "untested"}
{"id": "3l2cWG", "name": "360 to Tiny Planet", "author": "DavidLi", "description": "360 cubemap or equirectangular to Tiny Planet", "tags": ["tinyplanet"], "likes": 3, "viewed": 428, "published": 3, "date": "1595260687", "time_retrieved": "2024-07-30T20:54:41.563115", "image_code": "#define PI 3.1415926535\n#define USE_CUBEMAP\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n   \tvec2 mouseUv = iMouse.xy/iResolution.xy; \n   \n    vec2 uv2 = (fragCoord - iResolution.xy/2.0)/iResolution.y;\n\n    float u = atan(uv2.y, uv2.x);\n    u = mod(u + 2.0 * mouseUv.x + 2.0 * PI, 2.0 * PI) / (2.0 * PI);\n    float v = length(uv2);\n    v = clamp(pow(v, 0.5 + 0.5 * mouseUv.y), 0.0, 1.0);\n    \n#ifdef USE_CUBEMAP\n    vec2 uv3 = vec2(u * 2.0 * PI, v * PI - PI/2.0);\n    vec3 rayDirection = vec3(cos(uv3.y) * cos(uv3.x), sin(uv3.y), cos(uv3.y) * sin(uv3.x));\n    vec3 col = texture(iChannel0, rayDirection).xyz;\n#else\n    vec3 col = texture(iChannel0, vec2( u, v)).xyz;\n#endif\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 102, 152, 835]], "test": "untested"}
{"id": "tlBcWy", "name": "4-point linear gradient", "author": "dukesoft_official", "description": "simple example code for glassbeaver", "tags": ["gradient", "linear", "smooth"], "likes": 2, "viewed": 656, "published": 3, "date": "1595246665", "time_retrieved": "2024-07-30T20:54:42.414838", "image_code": "// Linear function for replacing smoothstep\nfloat linstep(float edge0, float edge1, float x) {\n    return clamp((x-edge0)/(edge1-edge0), 0., 1.);\n}\n\n\nfloat calcPos(float a, vec4 pts) {\n    return smoothstep(pts.x,pts.y,a)*smoothstep(pts.w,pts.z,a);\n}\n\nfloat calcPosLinear(float a, vec4 pts) {\n    return linstep(pts.x,pts.y,a)*linstep(pts.w,pts.z,a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord.xy / iResolution.xy;\n    \n    \n    // if initial points are not in range of 0 - 1 you can multiply each component by the scale factor of the outer points\n    \n\tvec4 pts = vec4(0.2, 0.3, 0.6, 1.0); // middle part returns 1, outside parts are smooth gradients\n    \n    //xy.x is the input variable (point on the line)\n\n    //fragColor = vec4(calcPos(xy.x, pts)); // This is a smoother version (smoothstep)\n    fragColor = vec4(calcPosLinear(xy.x, pts)); // Linear falloff\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 44, 94, 94, 147], [150, 150, 184, 184, 250], [252, 252, 292, 292, 352], [354, 354, 411, 411, 912]], "test": "untested"}
{"id": "ttBcWy", "name": "球面坐标和平面坐标", "author": "limengfan", "description": "黎曼几何下，球面的平铺坐标和球面坐标的变换", "tags": [], "likes": 1, "viewed": 241, "published": 3, "date": "1595246144", "time_retrieved": "2024-07-30T20:54:43.384246", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float pi = 3.14159265359;\n    \n    float theta = uv.y*pi;\n    float phi = uv.x*pi*2.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(vec3(theta,phi/2.0,0));\n    vec3 bcol = col;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //float x = sin(theta)*cos(phi);\n    //float y = sin(theta)*sin(phi);\n    //float z = cos(theta);\n    \n    vec2 newuv = fragCoord/iResolution.yy;\n    if (newuv.x>1.0) {\n        fragColor = vec4(bcol,1.0);\n    }\n    else {\n        newuv *= 2.0;\n        newuv -= vec2(1,1);\n        if (length(newuv)>1.0 ){\n        \tfragColor = vec4(bcol,1.0);\n        }\n        else {               \n        \ttheta = acos(newuv.y);\n            //https://blog.csdn.net/zghforever/article/details/88644499\n            float c = newuv.x;\n            float a = cos(iTime) * sin(theta);\n            float b = sin(iTime) * sin(theta);\n            if (sin(iTime)>0.0) {\n                float t = (b+sqrt(b*b+a*a-c*c))/(a+c);\n                phi = 2.0*atan(t);\n            }\n            else {\n                float t = (b-sqrt(b*b+a*a-c*c))/(a+c);\n                phi = 2.0*atan(t);\n            }\n            \n    \t\t//phi = asin(newuv.x/sin(theta));\n    \t\tcol = 0.5 + 0.5*cos(vec3(theta,phi/2.0,0));\n    \t\tfragColor = vec4(col,1.0);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1441]], "test": "untested"}
{"id": "wlScWy", "name": "Bugs in the Shrubs", "author": "dr2", "description": "Flight of the humongous dragonfly (mouseable)", "tags": ["tree", "forest", "flight", "dragonfly"], "likes": 14, "viewed": 363, "published": 3, "date": "1595246109", "time_retrieved": "2024-07-30T20:54:44.515222", "image_code": "// \"Bugs in the Shrubs\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat PrEllips2Df (vec3 p, vec2 r);\nfloat Minv3 (vec3 p);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nvec2 Hashv2v2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nmat3 bugMat;\nvec3 bugPos, sunDir, qHit, trOff;\nvec2 gId;\nfloat tCur, tCyc, dstFar, hgSize, trSzFac, trTwist, trTrunk, trLeaf, bgSzFac, bgAngW[2], bgFreqW;\nint idObj;\nbool trCore;\nconst float trLay = 4.;\nconst int idWing = 11, idEye = 12, idBod = 13, idTail = 14, idMth = 15, idAnt = 16;\nconst float pi = 3.1415927, sqrt3 = 1.732051, phi = 1.618034;\n\n#if 0\n#define VAR_ZERO min (iFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvec3 TrackPos (float t)\n{\n  return vec3 (10. * cos (0.1 * t) + 0.1 * t, 0., t);\n}\n\nvec3 TrackVel (float t)\n{\n  return vec3 (-0.1 * 10. * sin (0.1 * t) + 0.1, 0., 1.);\n}\n\nvec3 TrackAcc (float t)\n{\n  return vec3 (-0.1 * 0.01 * 10. * cos (0.1 * t), 0., 0);\n}\n\nfloat PathDst (vec2 p)\n{\n  float s;\n  s = abs (p.x - TrackPos (p.y).x) - 1.5;\n  return s * step (0., s) * step (0.5, Fbm2 (0.5 * p));\n}\n\nvoid SetTrConf ()\n{\n  vec2 hc;\n  if (PathDst (HexToPix (gId * hgSize)) == 0.) trSzFac = 0.;\n  else {\n    hc = Hashv2v2 (16.1 * gId + 0.3);\n    trSzFac = hgSize * 0.5 * sqrt3 * (0.8 - 0.4 * hc.x);\n    trTwist = phi * (1. + smoothstep (0.3, 0.7, hc.y));\n    hc = Hashv2v2 (17.1 * gId + 0.3);\n    trLeaf = 9. + floor (3. * hc.x);\n    trTrunk = 0.3 + 0.3 * hc.y;\n    hc = Hashv2v2 (18.1 * gId + 0.3);\n    trCore = (hc.x > 0.2);\n    trOff.xz = max (0., hgSize * 0.5 * sqrt3 - 1.1 * trSzFac) *\n       sin (2. * pi * hc.y + vec2 (0.5 * pi, 0.));\n    trOff.y = 0.;\n  }\n}\n\nfloat ObjCDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, h, w, s, rMax, rMin;\n  dMin = dstFar;\n  if (trSzFac > 0.) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= trOff;\n    dMin /= trSzFac;\n    p /= trSzFac;\n    p.y -= 1.3 + 2. * trTrunk;\n    rMax = 1.;\n    rMin = 0.5;\n    if (trCore) {\n      q = p;\n      d = PrEllips2Df (q.xzy, vec2 (rMin, 1.3));\n      DMINQ (1 + int (trLay));\n    }\n    for (float k = float (VAR_ZERO); k < trLay; k ++) {\n      s = k / trLay;\n      r = mix (rMax, rMin, s);\n      h = 0.9 * s + 0.3;\n      q = p;\n      q.xz = Rot2D (q.xz, trTwist * s);\n      q.xz = Rot2D (q.xz, 2. * pi * floor (trLeaf * atan (q.z, - q.x) / (2. * pi) + 0.5) / trLeaf);\n      w = 0.5 * (1. - 0.3 * s) * r;\n      d = SmoothMax (abs (PrEllips2Df (q.xzy, vec2 (r, 1.3))) - 0.05 * (1. - 0.2 * q.y),\n         min (length (vec2 (q.y + w - h, abs (q.z) - w)) - w, q.y + w - h), 0.04 * (1. - 0.5 * s));\n      DMINQ (1 + int (k));\n    }\n    p.y -= - (1.3 + 2. * trTrunk);\n    q = p;\n    q.y -= trTrunk;\n    d = PrCylDf (q.xzy, 0.25 * (1. + 0.05 * sin (2. * pi * q.y / trTrunk)), trTrunk);\n    DMINQ (2 + int (trLay));\n    dMin *= 0.8 * trSzFac;\n  }\n  return dMin;\n}\n\nfloat ObjCRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjCDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjCNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjCDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjCSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  gIdP = vec2 (-999.);\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    if (trSzFac > 0.) {\n      h = ObjCDf (p);\n      sh = min (sh, smoothstep (0., 0.05 * d, h));\n      d += clamp (h, 0.1, 0.3);\n    } else d += 0.2 / max (0.1, length (rd.xz));\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 b;\n  float dMin, d, bLen, wSpan, wr, tr, u;\n  bLen = 1.8;\n  wSpan = 3.;\n  p = bugMat * (p - bugPos);\n  dMin = dstFar / bgSzFac;\n  p /= bgSzFac;\n  p.z -= 0.2 * bLen;\n  b = vec2 (14., 3.) * max (0., abs (p.x) - 0.12 * bLen) / wSpan;\n  q = p;\n  q.yz -= bgAngW[0] * b;\n  d = PrEllCylDf (q.xzy, vec2 (0.96 * wSpan, 0.35), 0.01);\n  DMINQ (idWing);\n  q = p;\n  q.yz -= bgAngW[1] * b;\n  q.z -= 0.42 * bLen;\n  d = PrEllCylDf (q.xzy, vec2 (wSpan, 0.35), 0.01);\n  DMINQ (idWing);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.18, 0.07, bLen);\n  d = PrSphDf (q, 0.15);\n  DMINQ (idEye);\n  q = p;\n  wr = q.z / bLen;\n  if (wr > 0.5) {\n    u = 2. * (wr - 0.5);\n    tr = 0.17 - 0.11 * u * u;\n  } else {\n    u = clamp (0.67 * (wr - 0.5), -1., 1.);\n    u *= u;\n    tr = 0.17 - u * (0.34 - 0.18 * u); \n  }\n  d = PrCapsDf (q, tr * bLen, bLen);\n  DMINQ (idBod);\n  q.yz -= bLen * vec2 (0.1 * (wr + 1.) * (wr + 1.), -1.8);\n  d = PrCylDf (q, 0.018, 0.8 * bLen);\n  DMINQ (idTail);\n  q = p;\n  q.yz -= vec2 (-0.06, 1.03 * bLen);\n  d = PrSphDf (q, 0.06);\n  DMINQ (idMth);\n  q = p;\n  wr = q.y / bLen;\n  q.x = abs (q.x) - 0.1;\n  q.xz -= 1.5 * wr * wr;\n  q.yz -= vec2 (0.34, 0.9 * bLen);\n  d = PrCylDf (q.xzy, 0.025 - 0.25 * wr * wr, 0.2);\n  DMINQ (idAnt);\n  return 0.8 * dMin * bgSzFac;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 100; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.001 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.1;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.1, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat WingPat ()\n{\n  vec4 b;\n  vec2 bb;\n  float ds;\n  b = (8. * (vec4 (-1.2, -0.5, -0.18, -0.05) * abs (qHit.x) +\n     max (qHit.z, - qHit.z)) + vec4 (1.65, 0.725, 0.225, 0.1)) /\n     vec4 (0.1, 0.075, 0.075, 0.075);\n  bb = b.xz + step (abs (b.yw), abs (b.xz)) * (b.yw - b.xz);\n  ds = bb.x + step (abs (bb.y), abs (bb.x)) * (bb.y - bb.x);\n  ds = sqrt (max (0., 1. - ds * ds)) * sign (ds);\n  return ds;\n}\n\nvec4 BugCol (float ds)\n{\n  vec4 col4;\n  vec4 wCol = vec4 (0.9, 0.9, 0.7, 0.3);\n  vec4 bCol = vec4 (0., 0.2, 1., 0.2);\n  if (idObj == idWing) {\n    col4 = wCol * (1. + 0.2 * abs (ds));\n  } else if (idObj == idEye) {\n    col4 = (qHit.z < 0.05) ? bCol : vec4 (0.8, 0.8, 0.9, -1.);\n  } else if (idObj == idBod) {\n    col4 = bCol;\n    if (qHit.y > 0.) col4 = mix (col4, vec4 (0.9, 0.3, 0., 0.1), \n       smoothstep (-1., -0.5, qHit.z) * (1. - smoothstep (0., 0.1, abs (qHit.x))));\n    else col4 = mix (col4, wCol, smoothstep (-1., -0.5, qHit.z) *\n       (1. - smoothstep (0., 0.1, abs (qHit.x)))) *\n       (0.5 + 0.5 * smoothstep (0.01, 0.02, abs (qHit.x)));\n  } else if (idObj == idTail) {\n    col4 = bCol;\n    if (qHit.z < -1.3) col4 = vec4 (0.9, 0., 0., -1.);\n  } else if (idObj == idMth) {\n    col4 = vec4 (0.9, 0.6, 0.2, 0.1);\n  } else if (idObj == idAnt) {\n    col4 = vec4 (0.3, 0.8, 0.3, 0.1);\n  }\n  return col4;\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.1, 0.35, 0.1), vec3 (0.3, 0.35, 0.35),\n       smoothstep (-0.02, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  }\n  return col;\n}\n\nvec3 GrndCol (vec3 p, float dh, vec3 rd, vec3 roo)\n{     // aliasing reduced by smoothing - see iq's \"Filtering procedurals\"\n  vec4 c;\n  vec3 rdx, rdy, dp;\n  rdx = rd + 0.0005 * vec3 (normalize (vec3 (- roo.z, 0., roo.x)).x, 0., 0.);\n  rdy = rd + 0.0005 * vec3 (0., normalize (cross (vec3 (- roo.z, 0., roo.x), roo)).y, 0.);\n  rdx = dh * (rdx * rd.y / rdx.y - rd);\n  rdy = dh * (rdy * rd.y / rdy.y - rd);\n  c = vec4 (0.);\n  for (float k = float (VAR_ZERO); k < 5.; k ++) {\n    dp = (k == 0.) ? vec3 (0., 0., 1.) : vec3 (2. * mod (k, 2.) - 1., sign (k - 2.5), 0.25);\n    dp.xy = dp.x * rdx.xz + dp.y * rdy.xz;\n    c += dp.z * vec4 (mix (vec3 (0.25, 0.25, 0.), vec3 (0.1, 0.5, 0.2),\n       smoothstep (0.4, 0.6, Fbm2 (2. * (p.xz + dp.xy)))), 1.);\n  }\n  return c.xyz / c.w;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, roo, vn, q;\n  vec2 hc, b, cs, vf;\n  float dstObj, dstObjC, dstObjB, dstGrnd, dFac, sh, ao, ds, f;\n  int idObjC;\n  bool isSky;\n  isSky = false;\n  bgFreqW = 10.;\n  bgAngW[0] = 0.1 * (cos (bgFreqW * tCur) + 0.3);\n  bgAngW[1] = 0.12 * (cos (bgFreqW * tCur + 0.3 * pi) + 0.3);\n  dstObjC = ObjCRay (ro, rd);\n  idObjC = idObj;\n  roo = ro;\n  dstGrnd = dstFar;\n  dstObjB = ObjRay (ro, rd);\n  dstObj = min (dstObjB, dstObjC);\n  vf = vec2 (0.);\n  ao = 1.;\n  sh = 1.;\n  if (dstObj < dstFar) {\n    dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n    if (dstObjB < dstObjC) {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      ds = (idObj == idWing) ? WingPat () : 0.;\n      col4 = BugCol (ds);\n      if (idObj == idWing && ds != 0.) {\n        vn = bugMat * vn;\n        vn.yz = clamp (vn.yz - 0.2 * vec2 (sqrt (1. - ds * ds), ds), -1., 1.);\n        vn = normalize (vn) * bugMat;\n      }\n    } else {\n      ro += dstObj * rd;\n      vn = ObjCNf (ro);\n      q = ro;\n      q.xz -= HexToPix (gId * hgSize);\n      hc = Hashv2v2 (27.1 * gId + 0.1);\n      b = q.xz - trOff.xz;\n      idObj = idObjC;\n      if (idObj < 1 + int (trLay)) {\n        f = float (idObj) / trLay;\n        col4 = mix (vec4 (HsvToRgb (vec3 (0.15 * hc.x, 0.8, 0.6)), 0.),\n           vec4 (HsvToRgb (vec3 (0.2 + 0.3 * hc.y, 0.8, 1.)), 0.1), f);\n        if (dot (b, vn.xz) > 0.) {\n          b = Rot2D (b, trTwist * (float (idObj - 1) / trLay));\n          cs = sin (4. * trLeaf * atan (b.y, - b.x) + vec2 (0.5 * pi, 0.)) * dFac;\n          col4 *= 0.95 - 0.05 * cs.x;\n          vn.xz = Rot2D (vn.xz, 0.1 * pi * cs.y);\n        } else col4 *= 0.3;\n        if (dFac > 0.) vf = vec2 (32., 0.8 - 0.6 * smoothstep (0.1, 0.7, f));\n      } else if (idObj == 1 + int (trLay)) {\n        col4 = vec4 (HsvToRgb (vec3 (0.2 + 0.3 * hc.y, 1., 1.)), 0.1);\n      } else  if (idObj == 2 + int (trLay)) {\n        col4 = vec4 (0.3, 0.2, 0.1, 0.) * (0.85 + 0.15 * sin (32. * atan (b.y, - b.x) +\n           0.2 * pi * sin (4. * pi * ro.y)));\n        vf = vec2 (32., 1.);\n      }\n    }\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    if (dstGrnd < dstFar) {\n      vf = vec2 (2., 3. * (1. - smoothstep (0.1, 0.15, dstGrnd / dstFar)));\n      col4 = vec4 (GrndCol (ro, dstGrnd, rd, roo), 0.05);\n      gId = PixToHex (ro.xz / hgSize);\n      SetTrConf ();\n      if (trSzFac > 0.) ao = 0.5 + 0.5 * smoothstep (0.3, 1.,\n         length (ro.xz - HexToPix (gId * hgSize) - trOff.xz) / trSzFac);\n      else col4 += 0.7 * pow (Noisefv2 (64. * ro.xz), 32.) * \n         (1. - smoothstep (0.12, 0.15, dstGrnd / dstFar));\n    } else col4 = vec4 (0.1, 0.35, 0.1, 0.);\n  } else isSky = true;\n  if (! isSky) {\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    sh = min (ao, min (ObjCSShadow (ro, sunDir), ObjSShadow (ro, sunDir)));\n    f = dot (vn, sunDir);\n    if (col4.a >= 0.) {\n      col = col4.rgb * (ao * (0.15 + 0.15 * max (- f, 0.)) + 0.8 * sh * max (f, 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      rd = reflect (rd, vn);\n      rd.yz = Rot2D (rd.yz, 0.1);\n      col = mix (col4.rgb * (0.8 - 0.2 * dot (vn, rd)), SkyHrzCol (ro, rd), 0.6);\n    }\n    col = mix (col, SkyHrzCol (roo, rd), smoothstep (0.8, 0.95, min (dstGrnd, dstObj) / dstFar));\n  } else col = SkyHrzCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvoid BugPM (float t, float s)\n{\n  vec3 vd, cb, sb;\n  float flPit, flYaw, flRol, a;\n  bugPos = TrackPos (t);\n  vd = TrackVel (t);\n  a = SmoothBump (0.35, 0.65, 0.1, mod (tCur / tCyc, 1.));\n  flPit = 0.05 * pi * s;\n  flYaw = 0.5 * pi - atan (vd.z, - vd.x);\n  flRol = 60. * TrackAcc (t).x + 0.7 * (Fbm1 (2. * tCur) - 0.5);\n  if (s > 0.) {\n    flYaw += pi * a * sign (mod (tCur / tCyc, 2.) - 1.);\n    flRol *= (2. * a - 1.);\n  }\n  cb = cos (vec3 (flPit, flYaw, flRol));\n  sb = sin (vec3 (flPit, flYaw, flRol));\n  bugMat = mat3 (1., 0., 0., 0., cb.x, - sb.x, 0., sb.x, cb.x) *\n          mat3 (cb.z, - sb.z, 0., sb.z, cb.z, 0., 0., 0., 1.) *\n          mat3 (cb.y, 0., - sb.y, 0., 1., 0., sb.y , 0., cb.y);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, spd, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur, 2400.) + 30. * floor (dateCur.w / 7200.);\n  hgSize = 1.;\n  bgSzFac = 0.1;\n  tCyc = 10.;\n  az = 0.;\n  el = -0.02 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  el = clamp (el, -0.2 * pi, 0.1 * pi);\n  spd = 1.;\n  ro = TrackPos (spd * tCur);\n  ro.y = 1.2 + 0.3 * sin (2. * pi * (0.04 * tCur));\n  vd = TrackVel (spd * tCur);\n  az += atan (vd.x, vd.z);\n  s = abs (az) > 0.5 * pi ? -1. : 1.;\n  BugPM (spd * tCur + (3. - 2. * SmoothBump (0.35, 0.65, 0.1, mod (tCur / tCyc, 1.))) * s, s);\n  bugPos.y = 1.2 + 0.35 * sin (2. * pi * (0.04 * tCur + 0.05 * s)) + 0.05 * (Fbm1 (tCur) - 0.5);\n  vuMat = StdVuMat (el, az);\n  zmFac = 3.5;\n  sunDir = normalize (vec3 (0., 1., -0.7));\n  dstFar = 100.;\n  rd = vuMat * normalize (vec3 (uv, zmFac));\n  col = ShowScene (ro, rd);\n  fragColor = vec4 (pow (col, vec3 (0.8)), 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat PrEllips2Df (vec3 p, vec2 r)\n{\n  return (length (p / r.xxy) - 1.) * min (r.x, r.y);\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScWy.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1269, 1269, 1294, 1294, 1350], [1352, 1352, 1377, 1377, 1437], [1439, 1439, 1464, 1464, 1524], [1526, 1526, 1550, 1550, 1661], [1663, 1663, 1682, 1682, 2225], [2227, 2227, 2250, 2250, 3384], [3386, 3386, 3420, 3420, 4693], [4695, 4695, 4717, 4717, 4973], [4975, 4975, 5013, 5013, 5500], [5502, 5502, 5524, 5524, 6795], [6797, 6797, 6830, 6830, 7013], [7015, 7015, 7036, 7036, 7291], [7293, 7293, 7330, 7330, 7597], [7599, 7599, 7617, 7617, 8002], [8004, 8004, 8028, 8028, 8920], [8922, 8922, 8957, 8957, 9709], [9711, 9711, 9763, 9835, 10483], [13921, 13921, 13952, 13952, 14622], [14624, 14624, 14680, 14680, 15839], [15841, 15841, 15874, 15874, 15901], [15903, 15903, 15945, 15945, 15996], [15998, 15998, 16041, 16041, 16105], [16107, 16107, 16143, 16143, 16198], [16200, 16200, 16244, 16244, 16319], [16321, 16321, 16366, 16366, 16469], [16471, 16471, 16516, 16516, 16554], [16556, 16556, 16613, 16613, 16696], [16698, 16698, 16734, 16734, 16940], [16942, 16942, 16964, 16964, 17002], [17004, 17004, 17028, 17028, 17258], [17260, 17260, 17284, 17284, 17344], [17346, 17346, 17376, 17376, 17489], [17491, 17491, 17515, 17515, 17632], [17666, 17666, 17690, 17690, 17750], [17752, 17752, 17776, 17776, 17829], [17831, 17831, 17855, 17855, 17967], [17969, 17969, 17994, 17994, 18140], [18142, 18142, 18167, 18167, 18353], [18355, 18355, 18377, 18377, 18531], [18533, 18533, 18554, 18554, 18709], [18711, 18711, 18740, 18740, 18952], [18954, 18954, 18993, 18993, 19173]], "test": "untested"}
{"id": "3lSyDG", "name": "Sine SDF (No Root-Finding)", "author": "blackle", "description": "finally, maybe, cracked the sine SDF problem, in the most ad-hoc way possible", "tags": ["2d", "sdf", "sine", "distance", "curve", "cosine"], "likes": 32, "viewed": 1014, "published": 3, "date": "1595219145", "time_retrieved": "2024-07-30T20:54:45.323062", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//this is a method of computing the distance to a sine function\n//it works by creating a rough estimate for the closest point,\n//then checking if there's a closer point by creating a line\n//segment that is tangent to the curve, and finding the closest\n//point on that segment, becoming the new closest point\n//\n//because this works on the idea of finding the closest point,\n//we can also return that point from the function alongside\n//the distance. unfortunately, the point is a little jittery\n//especially when far from the curve. oh well...\n//\n//other solutions:\n//  iq:      https://www.shadertoy.com/view/3t23WG\n//  fabrice: https://www.shadertoy.com/view/tsXXRM\n\n#define PI 3.141592653\n\nvec2 closest_on_line(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return mix(a,b,clamp(k,0.,1.));\n}\n\nvec3 sine_SDF(vec2 p, float freq) {\n    float wavelen = PI/freq;\n\n    //map p to be within the principal half cycle\n    float cell = round(p.x/wavelen)*wavelen;\n    float sgn = sign(cos(p.x*freq));\n    p.x = (p.x-cell)*sgn;\n\n\t//sloppy initial estimate to the closest point using a line\n    //inexplicably, setting the height of the line to be proportional\n    //to the point's y position gives a *really* good estimate when \n    //far away from the curve.\n    float correction = max(1.,abs(p.y));\n    vec2 estimateline = vec2(wavelen/2.,correction);\n    vec2 cp = closest_on_line(p, -estimateline, estimateline);\n\n    //any less than 2 iterations looks bad, any more does not improve it\n    for(int i = 0; i < 2; i++) {\n        //refine the closest point by checking if there's a closer point on the tangent line\n    \tcp.y = sin(cp.x*freq);\n        float derivative = freq*cos(cp.x*freq);\n        vec2 localline = vec2(1,derivative)/freq/correction*.25;\n    \tcp = closest_on_line(p, cp-localline, cp+localline);\n        cp.x = clamp(cp.x, -wavelen/2., wavelen/2.);\n    }\n\n    cp.y = sin(cp.x*freq);\n    float dist = length(p-cp)*sign(p.y-sin(p.x*freq));\n\n    //map the closest point back to global coordinates\n    cp.x *= sgn; cp.x += cell;\n    return vec3(dist, cp);\n}\n\nvec3 shadeDistance(float d) {\n    d *= .5;\n    float dist = d*120.;\n    float banding = max(sin(dist), 0.0);\n    float strength = sqrt(1.-exp(-abs(d)*2.));\n    float pattern = mix(strength, banding, (0.6-abs(strength-0.5))*0.3);\n    \n    vec3 color = vec3(pattern);\n    \n    color *= d > 0.0 ? vec3(1.0,0.56,0.4) : vec3(0.4,0.9,1.0);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\tfloat scale = 5.;\n    uv*=scale; mouse*=scale;\n    float pixel_size = scale/iResolution.y;\n    \n    float t = sin(iTime)*.5+.5;\n    float freq = mix(20.,.5,sqrt(t));\n\n    vec3 mousedist = sine_SDF(mouse, freq);\n    vec3 col = shadeDistance(sine_SDF(uv, freq).x);\n    if (iMouse.z > 0.) {\n        col *= smoothstep(-pixel_size,pixel_size, distance(mouse, uv) - abs(mousedist.x)) *.5 +.5;\n        col = mix(vec3(.8,.9,.4), col, smoothstep(-pixel_size,pixel_size, distance(mousedist.yz, uv) - .05));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyDG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[887, 887, 933, 933, 1012], [1014, 1014, 1049, 1049, 2283], [2285, 2285, 2314, 2314, 2639], [2641, 2641, 2698, 2698, 3359]], "test": "untested"}
{"id": "tljcRd", "name": "Sphere over water", "author": "vipiao", "description": "Animated water and sphere over water", "tags": ["reflection", "water", "animated"], "likes": 10, "viewed": 439, "published": 3, "date": "1595215987", "time_retrieved": "2024-07-30T20:54:46.073056", "image_code": "\n# define INTERSECTED 0\n# define TOO_FAR 1\n# define TOO_MANY_STEPS 2\n# define PI 3.1415926538\n/******************************************************************************/\n\nfloat waterFunction(in vec3 pos, in float time){\n\tconst int size = 6;\n    vec3 vecs[size] = vec3[](\n        vec3(1,2, 0.2),\n        vec3(0.5,0.5, 0.1),\n        vec3(-1.,0.2, 0.1),\n        vec3(0.,-0.5, 0.5),\n        vec3(2.,-2., 0.01),\n        vec3(-2.,5., 0.01)\n    );\n    float waveHeight = 0.;\n    for(int i=0; i<size; i++) {\n        // The speed of waves on water is independent on amplitude or wavelength.\n    \twaveHeight += sin(pos.x*vecs[i].x+pos.z*vecs[i].y+time*length(vecs[i].xy))*vecs[i].z;\n    }\n    return waveHeight;\n}\n\nfloat sdWater(in vec3 pos){\n    float waveHeight = waterFunction(pos, iTime);\n    \n\tfloat heightDiff = pos.y - waveHeight;\n    const float maxSlope = 1.;\n    float nextDist = heightDiff/sqrt(maxSlope*maxSlope + 1.);\n    \n    float maxWaterHeight = 0.91; // 0.2+0.1+0.1+0.5+0.01+0.0. See waterFunction(.).\n    return max(nextDist, pos.y-maxWaterHeight);\n}\n\nvoid sdWaterNormal(in vec3 pos, inout vec3 normal, inout float sd){\n\tsd = sdWater(pos);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdWater(pos - e.xyy),\n    \tsdWater(pos - e.yxy),\n    \tsdWater(pos - e.yyx)\n    ));\n}\n\nfloat sdSphere(in vec3 pos, in vec3 center, in float radius){\n   \treturn length(pos-center) - radius;\n}\n\nvoid sdSphereNormal(in vec3 pos, in vec3 center, in float radius, inout vec3 normal, out float sd){\n\tsd = sdSphere(pos, center, radius);\n    vec2 e = vec2(0.01, 0.);\n    normal = normalize(sd - vec3(\n    \tsdSphere(pos - e.xyy, center, radius),\n    \tsdSphere(pos - e.yxy, center, radius),\n    \tsdSphere(pos - e.yyx, center, radius)\n    ));\n}\n\nfloat marchWorld(\n    inout vec3 pos, inout vec3 dir,\n    inout float dist, in float maxDist, in float minDist, out float nearest,\n    inout int numSteps, in int maxNumSteps,\n    inout vec3 color, out vec3 normal, out int returnCode\n){\n    float colorFrac = 1.;\n    float transparency = 0.75;\n    vec3 backgroundColor = vec3(0.1,0.2,0.5);\n    vec3 sphereColor = vec3(0,0,0);\n    vec3 waterColor = vec3(0,0,0.5);\n    vec3 lightDir = normalize(vec3(1,1,1));\n    nearest = maxDist;\n    \n    vec3 spherePosition = vec3(0,0,20);\n    spherePosition.y = waterFunction(spherePosition, iTime-0.5)+5.;\n    float sphereRadius = 4.;\n    for(int i=0; i<maxNumSteps; i++) {\n        float sdToWater = sdWater(pos);\n        float sdToSphere = sdSphere(pos, spherePosition, sphereRadius);\n        float sd = min(sdToWater, sdToSphere);\n        if(sd < nearest){\n        \tnearest = sd;\n        }\n        \n        numSteps++;\n        if(dist + sd + minDist > maxDist){\n            // Fill the remaining color.\n    \t\tcolor = mix(color, backgroundColor, colorFrac);\n            sd = maxDist-dist-sd-minDist;\n            dist += sd;\n            pos += dir*sd;\n            \n            returnCode = TOO_FAR;\n        \treturn sd;\n        }\n        if(sd <= minDist){\n            if(sdToWater < sdToSphere){\n            \tsdWaterNormal(/*in vec3 pos=*/pos, /*inout vec3 normal=*/normal, /*inout float sd=*/sd);\n                color = mix(color, waterColor*dot(lightDir, normal), colorFrac);\n                colorFrac *= transparency;\n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }else{\n            \tsdSphereNormal(\n                    /*in vec3 pos=*/pos, /*in vec3 center=*/spherePosition, /*in float radius=*/sphereRadius,\n                    /*inout vec3 normal=*/normal, /*out float sd=*/sd\n                );\n                color = mix(color, sphereColor*dot(lightDir, normal), colorFrac);\n                colorFrac *= transparency;\n                \n                if(dot(normal, dir) < 0.){\n                    dir = reflect(dir, normal);\n                    sd = max(sd, minDist*2.);\n                }\n            }\n        }\n        dist += sd;\n        pos += dir*sd;\n    }\n    \n    // Fill the remaining color.\n    color = mix(color, backgroundColor, colorFrac);\n    \n    //\n    returnCode = TOO_MANY_STEPS;\n    return -1.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 camPos = vec3(0.2, 3., 0.);\n    vec3 viewDir = normalize(vec3(uv.x, uv.y, 1.));\n    \n    vec3 col = vec3(0.);\n    vec3 pos = camPos;\n    float dist = 0.;\n    float maxDist = 1000.*100.;\n    float minDist = 0.01;\n    int numSteps = 0;\n    int maxNumSteps = 400;\n    vec3 normal;\n    int returnCode;\n    float nearest;\n    \n    marchWorld(\n        /*vec3 pos=*/camPos, /*vec3 dir*/viewDir,\n        /*float dist=*/dist, /*float maxDist=*/maxDist, /*float minDist=*/minDist, /*out float nearest=*/nearest,\n        /*int numSteps=*/numSteps, /*int maxNumSteps=*/maxNumSteps,\n        /*vec3 color=*/col, /*vec3 normal=*/normal, /*int returnCode=*/returnCode\n    );\n    \n    // Mist.\n    //col = mix(col, vec3(0,0,1), 1. / (1. + exp(-float(numSteps)*0.1 + float(maxNumSteps) - 380.)));\n    \n    //col = vec3(dist/100.);\n    \n    // Ambient occlusion.\n    float factor = float(numSteps)/float(maxNumSteps);\n    col = mix(col, vec3(0.5,0.5,0.7), factor);\n    \n    float fieldPace = 0.2;\n    if(mod(iTime*fieldPace,4.0) <= 1.){\n        float fieldFrac = mod(iTime*fieldPace,1.0);\n        float fieldSmooth = 30.*fieldFrac+5.;\n        float depth = (float(maxNumSteps)+fieldSmooth*2.)*fieldFrac-fieldSmooth*2.;\n        float field = max(fieldSmooth-float(abs(numSteps - int(depth))), 0.)/fieldSmooth;\n        field *= (1.-fieldFrac);\n    \tcol.g += field;\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[710, 710, 737, 737, 1064], [1066, 1066, 1133, 1133, 1306], [1308, 1308, 1369, 1369, 1411], [1413, 1413, 1512, 1512, 1753], [1755, 1755, 1990, 1990, 4187]], "test": "untested"}
{"id": "wtScWG", "name": "have you been drinking again?", "author": "tjak", "description": "you've been drinking again", "tags": ["webcam"], "likes": 3, "viewed": 644, "published": 3, "date": "1595212325", "time_retrieved": "2024-07-30T20:54:46.834022", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(texture(iChannel0, uv));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 cam = texture(iChannel0, uv);\n    vec4 self = texture(iChannel1, uv);\n   \n    fragColor = mix(cam, self, step(1.0, float(iFrame)) * 0.8);\n\n}", "buffer_a_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtScWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 220]], "test": "untested"}
{"id": "3tjyRK", "name": "Burnish Flame", "author": "oofydoodle", "description": "Simulation of Burnish flames from the movie Promare.", "tags": ["procedural", "2d", "triangle"], "likes": 1, "viewed": 351, "published": 3, "date": "1595210514", "time_retrieved": "2024-07-30T20:54:47.667793", "image_code": "#define PI 3.14159\n\n// Flame colors\nconst vec3 MAGENTA = vec3(1.0, 0.0, 1.0);\nconst vec3 CYAN = vec3(0.0, 1.0, 1.0);\n\n// Triangle Wave\nfloat triWave(float x) {\n    return (3.0 / PI) * asin(sin(PI * x));\n}\n\n// Determine if a point is part of the flame\nbool inFlame(vec2 o, vec2 p, float radius, float height, float rise)\n{\n    // Within circle\n    if (distance(o, p) <= radius) return true;\n    \n    // Within point\n    vec2 top = vec2(o.x, o.y + rise + height);\n    vec2 bottom = vec2(o.x, o.y + rise);\n    \n    bool inYRange = p.y < top.y && p.y > bottom.y;\n    \n    float t = (p.y-bottom.y)/(top.y-bottom.y);\n\n    float botRad = radius * 0.7;\n    \n    float x = botRad * (1.0 - t) + 5.0;\n    float xRadiusAtY = clamp(x*x / 30.0, 0.0, botRad);\n    \n    bool inXRange = p.x < o.x + xRadiusAtY && p.x > o.x - xRadiusAtY;\n\n    if (inXRange && inYRange) return true;\n\n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fc )\n{\n    // Point at center of flame\n    vec2 flameOrigin = vec2(iResolution.x / 2.0, (iResolution.y / 2.0) * 0.8);\n\n    // Move flame left/right\n    flameOrigin = vec2(flameOrigin.x + sin(iTime * 2.0) * 20.0, flameOrigin.y);\n\n    // Inner/outer flame radius\n    float baseRadius = 80.0;\n    float nshift = 2.0 * noise(fc + vec2(0, iTime));\n    float outerRadius = baseRadius - nshift + noise(vec2(iTime, 0)) * 2.0;\n    float innerRadius = baseRadius / 2.0 - nshift + noise(vec2(0, iTime)) * 2.0;\n\n    // Inner/outer flame height\n    float outerHeight = 150.0 + noise(vec2(iTime, 0)) * 10.0;\n    float innerHeight = 70.0 + noise(vec2(0, iTime)) * 10.0;\n    float outerRise = 0.0 + noise(vec2(iTime, 0)) * 2.0;\n    float innerRise = 30.0 + noise(vec2(0, iTime)) * 2.0;\n\n    // fragCoord gets shifted using a triangle wave\n    fc = vec2(fc.x + (triWave(iTime * 0.2) * fc.y / 10.0) + triWave(fc.y / 25.0 + iTime * 4.0) * 8.0, fc.y);\n\n    vec3 col = inFlame(flameOrigin, fc, outerRadius, outerHeight, outerRise) ? MAGENTA : vec3(0.0);\n    col = inFlame(flameOrigin, fc, innerRadius, innerHeight, innerRise) ? CYAN : col;\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "\n// rand and noise functions taken from:\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\n\treturn res*res;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyRK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 135, 159, 159, 204], [206, 251, 321, 342, 884], [886, 886, 936, 968, 2107]], "test": "untested"}
{"id": "3lByDy", "name": "Mug Torus Homeomorphism", "author": "Roninkoi", "description": "I couldn't find this classic bit of topology on here, so I decided to make it! [url]https://en.wikipedia.org/wiki/File:Mug_and_Torus_morph.gif[/url]", "tags": ["torus", "morph", "topology", "mug", "homeomorphism"], "likes": 6, "viewed": 416, "published": 3, "date": "1595201996", "time_retrieved": "2024-07-30T20:54:48.465659", "image_code": "#define PI 3.14159265\n#define MAXIT 200\n#define EPSILON 0.001\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n \nfloat t;\n \nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n\nfloat mug(vec3 r, float m)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - vec2(2.);\n    float cyl = (min(max(p.x, p.y), 0.0) + length(max(p, 0.)));\n    \n\tp = abs(vec2(length(r.xz), r.y - 1. - 4. * (1. - m)*4.)) - vec2(1.5 - (1.-m)*3., 3.);\n    float icyl = (min(max(p.x, p.y), 0.0) + length(max(p, 0.)));\n    \n    vec3 rr = r;\n    rr.x += 1.5;\n    p = vec2(length(rr.xy) - 1.5, rr.z);\n    float tor = (length(p) - 0.25);\n\t\n\treturn min(max(-icyl, cyl), max(-icyl, tor)) * m;\n}\n\nfloat torusm(vec3 r, float m)\n{\n    vec3 rr = r;\n    rr.x += 1.5;\n    vec2 p = vec2(length(rr.xy) - 1.5, rr.z);\n    float tor = (length(p) - 0.25);\n\t\n    return tor * m;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n)\n{\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r)\n{\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat box(vec3 r, vec3 a)\n{\t\n    vec3 p = (abs(r) - a);\n    \n    return length(max(p, 0.));\n}\n\nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n    obj = rotY(t) * rotX(sin(t*0.33) * 0.1 - 0.1);\n    \n    r = obj * r;\n    \n    float m = (sin(t * 0.5) + 1.) * 0.5;\n        \n    r.x -= (1.-m) * 1.5;\n    \n    float d = torusm(r, 1. - m);\n    d += mug(r, m);\n    \n    return vec2(d, 1.);\n}\n\nvec3 matCol(vec2 o)\n{\n    return vec3(1.0, 0.5, 0.);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.5);\n       \n    vec3 ro = vec3(0., 3.0, -5.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.0, (1.+uv.y)*0.5, (1.+uv.y*0.5)*0.5)*2. + vec3(0.5);\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\t\t\tmatCol(d), \n\t\t\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.05, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.6 - 0.1 * hash(uv);\n\t\tr += rd * d.x;\n        \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    \n\tcol.rgb *= exp(-sh * 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByDy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 181, 181, 283], [286, 286, 306, 306, 410], [413, 413, 433, 433, 535], [549, 549, 580, 580, 608], [611, 611, 640, 640, 714], [716, 716, 744, 744, 1187], [1189, 1189, 1220, 1220, 1360], [1363, 1363, 1400, 1400, 1428], [1430, 1430, 1462, 1462, 1564], [1566, 1566, 1586, 1586, 1658], [1660, 1660, 1687, 1687, 1753], [1755, 1755, 1785, 1785, 1840], [1843, 1843, 1885, 1885, 1925], [1938, 1938, 1956, 1956, 2202], [2204, 2204, 2225, 2225, 2258]], "test": "untested"}
{"id": "3lBcWy", "name": " Solskogen 2020 Semifinal", "author": "Alkama", "description": "My semifinal Shader Showdown result @ Solskogen 2020 demoparty.\n25 minutes round.\n(I ultimately got defeated by the great evvvvil)", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 11, "viewed": 463, "published": 3, "date": "1595195826", "time_retrieved": "2024-07-30T20:54:49.282475", "image_code": "float pi=acos(-1.),t,d;\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat cube(vec3 p, vec3 s) { vec3 b=abs(p)-s; return max(max(b.x,b.y),b.z); }\nfloat scene(vec3 p) {\n  vec3 pp=p;\n  float s=1.;\n  float a=1.5;\n  for(int i=0; i<5; i++) {\n    p = 2.*clamp(p,-a,a)-p;\n    float r=max(1., .4/dot(p,p));\n    p*=r;\n    s*=r;\n  }\n  p.xz*=rot(t*10.);\n  return cube(p, vec3(.2, 2., .2))/s;\n}\nvec3 norm(vec3 p) { vec2 e=vec2(.0001,0); return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx))); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)*vec2(iResolution.x / iResolution.y, 1);\n    t=mod(.1*iTime,10.*pi);\n    vec2 uv2=uv;\n    uv/=1.5-length(uv);\n    vec3 o,tg,f,s,u,dir,col;\n    o.y+=.02+.02*sin(t);\n    o+=.04*vec3(sin(t),sin(t),cos(t));\n    tg.y=-.02*sin(t);\n    f=normalize(tg-o);\n    s=normalize(cross(vec3(.5*sin(t*5.),1,0),f));\n    u=normalize(cross(f,s));\n    dir=normalize(f*.8+uv.x*s+uv.y*u);\n    vec3 lp=vec3(.1);\n    lp.xz+=vec2(sin(t*10.),cos(t*10.));\n    vec3 p=o;\n    float side=sign(scene(p));\n    for(int i=0;i<200;i++) {\n        float h=scene(p)*side*.5;\n        if(h<.0001*d) {\n            vec3 n=norm(p)*side;\n            vec3 ld=normalize(lp-p);\n            float df=max(0.,dot(n,ld));\n            float sp=pow(max(0.,dot(dir,reflect(ld,n))), 5.);\n            float fr=pow(abs(1.-dot(n,-dir)), .5);\n            vec3 fromage=acos(normalize(dir-p));\n            col+=.5*vec3(.1*df+fromage*sp*fr);\n            p-=n*.005;\n            side*=-1.;\n        }\n        if(d>.2) break;\n        d+=h;\n        p+=dir*h;\n    }\n    col= mix(col,.09*vec3(.9,.9,1.),5.-exp(-d));\n    col*=pow(1.5-length(uv2),3.);\n    fragColor = vec4(pow(col,vec3(1./1.7)),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 43, 43, 93], [94, 94, 122, 122, 171], [172, 172, 193, 193, 408], [409, 409, 428, 428, 531], [532, 532, 589, 589, 1762]], "test": "untested"}
{"id": "WlScWy", "name": " Solskogen 2020 Quarterfinal", "author": "Alkama", "description": "My quarterfinal Shader Showdown result @ Solskogen 2020 demoparty.\n15 minutes round.\n(I won that round :D)", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 10, "viewed": 524, "published": 3, "date": "1595195545", "time_retrieved": "2024-07-30T20:54:50.097297", "image_code": "float pi=acos(-1.0), t, g, d;\nmat2 rot(float a) { float c=cos(a),s=sin(a); return mat2(c,s,-s,c); }\nfloat tr(vec3 p, float l, float s) { return length(vec2(length(p.xy)-l,p.z))-s; }\nfloat scene(vec3 p) {\n    float dd,d=1000.,s=3.;\n    for(float i=0.;i<s;i+=1./s) {\n        vec3 pp = p;\n        float ii=s+1./s-i;\n        float w=ii*abs(sin(t+i));\n        int alt=int(i*s)%2;\n        pp.yx*=rot(ii*(sin(t)+pi*3.));\n        pp.yz*=rot(ii*(cos(t)+pi*5.));\n        if(alt==1) {\n            pp+=.08*(texture(iChannel0, t+pp.xz*.02).r*2.-1.);\n            dd=tr(pp,i, .01*w);\n            g+=1./(1.+abs(dd));\n            dd=max(.005,dd);\n        } else {\n            dd=tr(pp,i, .08*w);\n        }\n        d=min(d,dd);\n    }\n    return d;\n}\nvec3 norm(vec3 p) { vec2 e=vec2(.001,0); return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx))); }\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)*vec2(iResolution.x / iResolution.y, 1);\n    t = mod(iTime,10.*pi);\n    vec3 col,p,dir=normalize(vec3(uv+.2*vec2(sin(t),cos(t)),.7+.1*sin(t*2.)));\n    p.z=-4.;\n    for(int i=0;i<50;i++) {\n        float h=scene(p)*.8;\n        if(abs(h)<.001) {\n            col+=dir*abs(dot(norm(p),-vec3(1)));\n            break;\n        }\n        if(d>10.) {\n            col+=.05*acos(dir);\n            break;\n        }\n        d+=h;\n        p+=dir*h;\n    }\n    col+=pow(g*.018+(.1*sin(t*100.)),5.)*vec3(.1,.2,1.5);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScWy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 49, 49, 99], [100, 100, 136, 136, 181], [182, 182, 203, 203, 731], [732, 732, 751, 751, 853], [854, 854, 911, 911, 1485]], "test": "untested"}
{"id": "WtBcDG", "name": "My virtual slime molds", "author": "michael0884", "description": "Virtual biological stuff, much slime, so wow *doge.png*", "tags": ["particles", "ca"], "likes": 121, "viewed": 3446, "published": 3, "date": "1595194901", "time_retrieved": "2024-07-30T20:54:50.900150", "image_code": "// Fork of \"Everflow\" by michael0884. https://shadertoy.com/view/ttBcWm\n// 2020-07-19 18:18:22\n\n// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    //border render\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n   \n    vec4 data = texel(ch0, pos);\n    particle P0 = getParticle(data, pos);\n\n    vec2 x0 = P0.X; //update position\n    //how much mass falls into this pixel\n    vec4 rho = vec4(P0.V, P0.M)*G((pos - x0)/0.75); \n    vec3 dx = vec3(-3., 0., 3.);\n \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.7, 0.7);\n    vec3 col1 = vec3(0., 0.9, 1.);\n    // Output to screen\n    col.xyz = vec3(0.2*a); \n    col.xyz += 0.5 - 0.5*cos(8.*vec3(0.2,0.8,0.6)*rho.w);\n    //col.xyz += vec3(1,1,1)*bord;\n    col.xyz = tanh(4.*pow(col.xyz,vec3(1.5)));\n    col.w=1.0;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 2.\n\n#define fluid_rho 0.2\n\n\n//mold stuff \n#define sense_ang 0.4\n#define sense_dis 2.5\n#define sense_force 0.1\n#define trailing 0.\n#define acceleration 0.01\n\n\n//SPH stuff\nfloat Pf(vec2 rho)\n{\n    return 1.*rho.x + 0.*rho.y; //gas\n    return 0.02*rho.x*(rho.x/fluid_rho - 1.); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(1.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(0., 0.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.3\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    P.X *= 0.;\n    P.V *= 0.;\n    P.M.x *= 0.;\n    \n    P.M.y *= trailing;\n    \n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n      \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n    }\n    //pheromone trail\n    P.M.y = P.M.x;\n}\n\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n   \t//sensors\n    float ang = atan(P.V.y, P.V.x);\n    vec4 dir = sense_dis*vec4(Dir(ang+sense_ang), Dir(ang - sense_ang));\n    vec2 sd = vec2(pixel(ch, P.X + dir.xy).w, pixel(ch, P.X + dir.zw).w);\n    F += sense_force*(Dir(ang+PI*0.5)*sd.x + Dir(ang-PI*0.5)*sd.y); \n    \n    //gravity\n    F -= 0.001*P.M.x*vec2(0,1);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.01*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    P.V *= 1. + acceleration;\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?1.*v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        rand.z = distance(pos, R*0.5)/R.x;\n        if(rand.z < 0.1) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + 0.*vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.);\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcDG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[197, 197, 224, 224, 402], [404, 404, 440, 440, 490], [492, 492, 508, 508, 536], [538, 538, 583, 583, 1435]], "test": "untested"}
{"id": "wl2cRt", "name": "ReTrAdUi amalgations3 ad35", "author": "ollj", "description": "parent: https://www.shadertoy.com/view/3l2GDR\nhttps://www.shadertoy.com/view/MtdyzM\n,barycentric tracing code: see the function: getPosSmallV()\ntriangles imply barycentric, so i may rule out prism face intersections with barycentric adjacency.", "tags": ["filter", "gradient", "ik", "barycentric", "derivative", "ui", "ad", "automaticdifferentiation", "superprim", "calculus", "csgsuperprim"], "likes": 1, "viewed": 398, "published": 3, "date": "1595192091", "time_retrieved": "2024-07-30T20:54:53.023473", "image_code": "/*\nReTrAdUi\n=Relativistic Epsilon\n,Temporal     Reprojection\n,Automatic    Differentiation\n,User         Interface\n\nthis amalgation is a bit messy, it can only go uphill from here.\nthe CommonTab has toggles between 3 scenes; Temporal Reprojection, Automatic Differentiation, and a 2d UI-focused Scene.\nbelow test is mostly about the [automatic differentiation] scene\nthe Image-MainImage function on the bottom here toggles between Re7 (relativityEngine) and all else.\nThe goal here is to unify concepts of 4 other shaders, where ever that makes sense and evades conflicts.\n*/\n\n/* \ndrag dots to see effect of dotPosition.xy\nclick screenspace-void to add a dot (dot params overwrite (animated) default parames)\nerase dots by moving them into the red square\n- Erasing a dot that is not the last dot may cause confusion (no LinkedList structure)\n-, because dots will stay in place, but their indexes may decrease by -1\n- , and the effect of a dot is set by its index, with parameters from its position. \n\ntodo: if(dot gets ersed) properrly rearrange dot indizies)\n\ndot[0] is left dot, sets camera position|angle marameters (naive dumb camera matrix)\ndot[1] is top Left, sets object0 scale.xy\ndot[2] is bottom  , sets object0 scale.z and hole-parameter.y  (klick to add dot)\ndot[3] sets object0 2 roundness parameters (torus/lathe like)\ndot[4] sets object1 scale.xy\ndot[5] sets object1 scale.z and hole-parameter.y  (klick to add dot)\ndot[6] sets object1 2 roundness parameters (torus/lathe like)\ndot[6] sets object1 offset.xy\ndot[7] sets object1 offset.z and a UnionRoundness\n\nSurface normals are analytic [automatic differentiation] \nfirst derivatives over 3 domains, faster and more precise (near sharp corners)\nDebugging of [AD] just needs a merger with [UI], so here it is:\nan easly release of an incomplete merger of [AD26] with [AD33]\n\n- - tags:\n- 4 tabs are 4 plugins, with a shared commonTab library.\n\nAD,UI,IK,superprim,CSGsuperprim,calculus,filter,gradient,derivative,automaticdifferentiation\nsuperprim,uberprim\nUI,diegetic,mouse,parametric,ui,widget,draganddrop,spartial,canvas\nAD,calculus,filter,partialDerivative,TotalDerivative,normal,curvature,laplache\nIK,parabola,bezier,root,projection,\nCA,arclength,calligraphy,sweepAmt,EliteBeatAgents,OsuTatakaeOuendan\nRE,RelativityEngine,TargetFps\nTR,TemporalReprojection\n\n/WtfGDM screenshots:\nhttps://twitter.com/ollj/status/1123090411814379520\n\nself UI2TARD38: https://www.shadertoy.com/view/3l2GDR (amalgations2)\nparent UI2AD37: https://www.shadertoy.com/view/3tSGDz (slow progress)\nparent UI2AD36: https://www.shadertoy.com/view/ttfGRB (skippable)\nparent UI2AD35: https://www.shadertoy.com/view/WtfGRS (milestone)\nparent UI2AD26: https://www.shadertoy.com/view/WtfGDM (4d 3rd derivatives & dragAndDropUi)\nparent    AD33: https://www.shadertoy.com/view/ttX3D8 (1d 3rd derivatives)\nparent    AD26: https://www.shadertoy.com/view/WtXGW4 (3d 1st derivatives)\nparent UI1    : https://www.shadertoy.com/view/Xt3BzX (dragAndDropUi)\nparent UI0    : https://www.shadertoy.com/view/4dtSRn (dragAndDropUi origin)\n\nThe image tab only cares to explain the final composition\nand on very abstract descriptions of the amalgation:\n\nThis is an amalgation of multiple plugins.\nWhos (shared) components mix mostly into the CommonTab\nand into some (remote) compositing/debugging calls from the imageTab.\nJust like a [frankensteins monster] has only one brain and one heart.\n\nEach plugin has its own family tree history and context/tags\nBut these often overlap a lot.\ntherefore all of that is moved to the CommonTab, over time.\n*/\n\nvoid drawDragDots(inout vec4 s,vec2 u,inout vec2 e//loop trough all dots and accumulate colors.\n){v0 f=0.\n ;for(v0 i=0.;i<maxCount;++i\n ){if(i>=s.y)break//bound by number of instantiated UIDots\n  ;f=dd(u-bufDrag(i).xy)\n  ;e=vec2(mix(e.x,i,step(abs(f),(e.y*e.y))),mi(e.y,sqrt(f)));}\n ;}\n\n//ESSENTIAL instant feedback: highlight what is dragged\nvec4 dotColor(vec4 s,v0 r\n){if (r==s.x)return mix(vec4(.5,1,1,1),vec4(0,1,0,1),step(0.,s.z))//highlight last klicked/dragged\n ;return vec4(.5,.5,1,1);}//all other dots\n\nvec4 iDiegeticUIshow(vec2 u){\n ;vec4 c=vec4(0),s=bufDrag(statePos)\n ;vec2 e=vec2(0.,UiDotRadius+UiDotBorder)\n //e.x is the inner bound of a dot's black border\n //e.y is the outer bound of a dot's black border \n ;drawDragDots(s,u,e)\n ;if(e.y<UiDotRadius+UiDotBorder\n ){e.y-=UiDotRadius\n  ;     c=vec4(0,0,0,1)  *smoothstep( UiDotBorder,0.         ,(abs(-e.y)))\n  ;vec4 d=dotColor(s,e.x)*smoothstep(-UiDotBorder,UiDotBorder,     -e.y)\n  ;c=pdOver(c,d)*.4\n ;}//else return vec4(1,0,0,1)//to debug above boundary\n ;if(inRect(u,deleteRect))c.xyz=mix(c.xyz,vec3(1,0,0),.3)\n ;return c;}\n\n\n//iCanBez (iCanvas iBezieer merged in UI2AD37)\n/*\niChannel0=BuffA\niChannel1=BuffB\niChannel2=BuffC\niChannel3=BuffD\n*/\n\n/*\ntags:\nbezier,quadratic,parabola,\n\nnote:\nhttps://math.stackexchange.com/questions/12186/arc-length-of-bézier-curves\nis tricky but usseful\n*/\n\n//set a viewFrame zoom/FoV-factor, has all turm() parameters, but is often a constant\n//convention insists on parameters, yo that you can set zoom by other data\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n//#define viewzoom  (1./(cos(iTime)*.5+.75))\n\n//restructure of https://www.shadertoy.com/view/XtdyDn\n//this reuses inout values, instead of declating new variables, where posisble\n//this splits BezierQuadParabola() off of BezierQuad()\n\n\n//#define sat(a) clamp(a,0.,1.)\n\n\n//bool rea(v0 s,v0 b,v0 e){b-=s;return(abs(s-.5*b)*e<abs(b));}\n\n\n\n//#define Aa min(iResolution.x,iResolution.y)\n\nv1 sort(v1 a){return v1(min(a.x,a.y),max(a.x,a.y));}\n\n\n\nv3 demoBezierQuad(v0 t,v1 u,v2 r,v3 m//iCanBez (iCanvas iBezieer merged in UI2AD37)\n){v3 c=v3(0,0,0,1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y      \n ;if(m.z<=0.)m.xy=v1(cos(t),sin(t*1.61))\n ;v3 o=v3(0,0,0,1)\n ;v1 p0=v1(-cos(t*.5),sin(t*0.9))*.4\n ,p1=v1(-cos(t*2.3),sin(t*1.1))\n ,p2=v1(cos(t*1.3)*.4,-sin(t*.3)*.3)*.5\n ;p0*=rot(sin(t)-t)\n ;p1*=rot(sin(t*.7))\n ;p2*=rot(cos(t*1.8)+t)\n ;//lines above are a lot like parent: https://www.shadertoy.com/view/XtdyDn \n ;//liney below may overwrite values from above.\n ;//lines below set 3 CVs by bufDrag , pointCount is number ot points that are set by bufDrag\n ;//and 2 more parameters that define an closed interval along the defined bezier/parabola\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;//if (one point exist) it overwrites p0\n ;if(pointCount >0.)p0=fra(t,bufDrag(0.).xy,r,m)*viewzoom//this bijection is painful\n ;//if(2 points exist) 2nd point overwrites p1\n ;if(pointCount >1.\n ){p1=fra(t,bufDrag(1.).xy,r,m)*viewzoom//... Buffa should just store local coordinates!\n ;} \n //if(3 points exist) 3rd point overwrites p2\n ;if(pointCount >2.\n ){p2=fra(t,bufDrag(2.).xy,r,m)*viewzoom\n ;}  \n //if (4 points exist) 4th points .y overwrites m.y\n ;v1 p3\n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){\n  ;p3=fra(t,bufDrag(3.).xy,r,m)*viewzoom\n  ;m.x=mix(.5,1.,p3.y/viewzoom+.5)\n  ;//m.x=(m.x*2.)\n  ;//c.w=segment(u,p3,mix(p0,p2,p3.y/viewzoom+.5))//c.w for a yellow line for an  associative connection\n  ;//c.w=segment(u,p3,v1(0))//c.w for a yellow line for an  associative connection\n  ;} \n ;v1 p4\n //if (5 points exist) 5th point overwrites m.z\n ;if(pointCount>4.\n ){p4=fra(t,bufDrag(4.).xy,r,m)*viewzoom\n  ;m.y=mix(.5,1.,p4.y/viewzoom+.5)\n  ;//c.w=min(c.w,segment(u,p4,mix(p0,p2,p4.y/viewzoom+.5)))//c.w for a yellow line for an  associative connection\n ;}\n ;c.x=segment(u,vec2(0),vec2(0))\n    \n    /* \n ;c.x=min(c.x,segment(u,(p1-p0)*.5-p0,p2))\n ;c.x=min(c.x,segment(u,(p2-p1)*.5-p1,p0))\n ;c.x=min(c.x,segment(u,(p0-p2)*.5-p2,p1))\n     /**/\n //this is too naive. makes more sense to get the longest side first.\n ;//vec3 penismeasure=vec3(dd(p0-p1),dd(p1-p2),dd(p2-p0))\n ;//int cookie=getPosSmall(penismeasure)\n  //   ;if(cookie==2){vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1));c.x=min(c.x,segment(u,aa,p2));}\n ;//vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2));c.x=min(c.x,segment(u,bb,p0)) \n ;//vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0));c.x=min(c.x,segment(u,cc,p1))\n     /**/\n     \n ;//float aa=dot(p1-p0,p2-p0)\n ;//float bb=dot(p2-p1,p0-p1)\n ;//float cc=dot(p0-p2,p1-p2)  \n// ;vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2))\n ;//vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0))\n// ;vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1))\n //;if(true//min(bb,cc)>0.\n //   ){vec2 bb=gLLxX(p1,p2,p0,p0-r4(p1-p2));c.x=min(c.x,line(u,p0,bb));} \n// ;if(true //min(aa,cc)>0.\n//    ){vec2 cc=gLLxX(p2,p0,p1,p1-r4(p2-p0));c.x=min(c.x,line(u,p1,cc));} \n// ;if(true//min(aa,bb)>0.\n//    ){vec2 aa=gLLxX(p0,p1,p2,p2-r4(p0-p1));c.x=min(c.x,line(u,p2,aa));}\n ;//vec2 orthocenter=gLLxX(p2,aa,p0,bb)\n ;//c.x=min(c.x,line(u,orthocenter,p0))\n ;//c.x=min(c.x,line(u,orthocenter,p1))\n ;//c.x=min(c.x,line(u,orthocenter,p2))\n     \n ;float h=line(u,p0,p1)-.01\n ;h=min(h,line(u,p1,p2)-.01)\n ;h=min(h,line(u,p2,p0)-.01)\n ;c.w=min(h,ray(u,p3,p4)-.01) //draw ray and triangle\n \n ;c.x=h\n ;c.y=1.\n ;c.z=1.\n   \n ;float carthesianDet=c2bdet(p0,p1,p2)\n\n ;vec3 uu=c2b(u,p0,p1,p2,carthesianDet)\n ;vec3 ssu=sat(sign(uu))\n ;float uus=suv(ssu)\n ;//c.xyz=ssu\n ;mat3 n=mat3(p0,0,p1,0,p2,0)\n ;float ddd=0.\n ;float gpl=float(getPosLarge(ssu))\n ;c.z=sdTriangle(p0,p1,p2,u)-.04\n\n     \n\n ;vec3 oo=c2b(p3,p0,p1,p2,carthesianDet)\n ;vec3 tt=c2b(p4,p0,p1,p2,carthesianDet) //ray points transformed from carthesian to barycentric\n ;vec3 vs=oo-tt\n     \n ;vec3 l=vec3(dd(p1-p2),dd(p2-p0),dd(p0-p1))//squared side length\n ;float radius=sqrt(lengthBary(oo-tt,l))//vector (oo-tt) length from barycentric vector\n\n //;vec3 vv=c2b(p4-p3,p0,p1,p2)\n\n ;float center=sqrt(lengthBary(oo-uu,l))//vector (oo-uu) length from barycentric vector\n ;c.w=min(c.w,abs(center-radius))//;c.w=min(c.w,abs(length(u-p3)-radius))\n //;c.w=min(h,ray(u,p3,p4)-.01)\n \n ;vec3 os=sat(floor(oo+1.))\n ;vec3 ts=sat(floor(tt+1.))//sat is needed for scale (large distances to the triangle are cheap)\n ;float ooo=suv(os)\n ;float ttt=suv(ts)//sum of vector components now points at 7 different segments:\n     //1* insideTriangle\n     //3* largeBorderTile(adjacent) \n     //3* cornerBorder   (only touches triangle corners)\n         \n ;vec3 linesToCheck=vec3(0)\n \n ;if(ooo==2.//case 2: origin is in largeBorderTile\n ){if(ttt<2.&&os!=1.-ts)linesToCheck=vec3(0)\n  ;else{linesToCheck=getPosSmallV(os)//this one is simple, either misses all, or hits only one.\n      //nope nope nope,(vs) doesnt ALWAYS work HERE: \n      //but sure, there are other ways to do this, removed for now\n ;}}else if(ooo==1.){//case 1: origin is in cornerBorder\n  ;if(ttt<2.&&os!=ts)linesToCheck=vec3(0)//only the other 2 outer corners miss the triangle\n  ;else if(ttt==2.&&os!=1.-ts)linesToCheck=getPosSmallV(ts)//from cornerBorder to ADJACENT largeBorderTile, has 1 border\n      ;else{linesToCheck=1.-getPosLargeV(os);\n      ;if(1.-getPosLargeV(vs)!=linesToCheck)linesToCheck=vec3(0.)\n ;}}else //if(os==vec3(1) )//case 0: origin is in insideTriangle\n  {if(ttt==2.)linesToCheck=1.-getPosSmallV(ts) //target is in any largeBorderTile /single border)\n  ;else linesToCheck=1.-getPosSmallV(-vs)//target is anywhere outside (2 borders)\n ;}\n /**/\n  \n ;if(linesToCheck.x>0.)c.y=min(c.y,segment(u,p1,p2)-.04)//indicating segments that are hit.\n ;if(linesToCheck.y>0.)c.y=min(c.y,segment(u,p2,p0)-.04)//indicating segments that are hit.\n ;if(linesToCheck.z>0.)c.y=min(c.y,segment(u,p1,p0)-.04)//indicating segments that are hit.\n\n //the faces that are still in may only return the NEAR intersection.\n //there is no case where there is a far intersection, the firt positive intersection can be returned as nearest.\n //i have not implemented a function that takes (linesToCheck), to trace this triangle/prism.   \n //on tracing a triangle/prism efficiently.\n //triangles imply barycentric coordinates, converters exist, but they are not too fast, and should be avoided.\n //just start in barycentric coordinates\n     //how about one moore domain, doing a 3d simplex (skewable triangle pyramid)\n     \n //;c.x=min(c.x,segment(u,p0,p2))                //red triangle shows 3 CVs \n ;//c.y=BezierQuadParabola(u,p0,p1,p2)           //green shows parabola\n ;m.xy=sort(m.xy)                               //m.x<m.y for BezierQuadGeneral()\n ;//c.z=BezierQuadGeneral (u,p0,p1,p2,2.*m.xy-1.)//blue shows bezier segment of parabola\n ;//c.z=BezierQuad        (u,p0,p1,p2)         //blue shows bezier segment of parabola\n ;//o.z+=.2*smoothstep(1.5,0.,(c.x-10./r.y)/fwidth(c.x))//this is just worse; https://www.shadertoy.com/view/XtdyDn\n ;c.z -=9./Aa(t,u,r,m) //line thickness\n ;c.xw-=2./Aa(t,u,r,m) \n ;c.y -=4./Aa(t,u,r,m)\n ;c=smoothstep(2./Aa(t,u,r,m),-2./Aa(t,u,r,m),c) //checking if gradient is fine (and not a squared distance or something distorted/taxicap)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n \n ;return c;}\n\n/**/\n\nv3 demoProject(v0 t,v1 u,v2 r,v3 m\n){u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v3 c=v3(1)\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 p0=v1(.5,-.5)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;}\n ;//l0=v1(0)\n ;v0 d=segment(p0,l0,l1)     //distance of p3 to line segment\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;c.y=length(u-p0)//green dots\n ;v1 p10=projectS(p0-l0,l1-l0)+l0//projected point on line\n ;c.x=length(u-p10)//red projected point\n ;v1 p11=project(p0-l0,l1-l0)+l0//projected point on line (not clamped)\n ;c.x=min(c.x,length(u-p11))//red projected point\n ;c.y-=d\n ;//c.z-=.01  \n ;c.x-=.05\n ;c.x=min(c.x,segment(u,p0,p10))-.01\n ;c=abs(c-.02)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.4\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\n//catch fails to care for sign== sides of the linesegment!\n  //my usecase likely never cares for that. its cute to shine trough a wall?\nbool catch(v1 rs,v1 r2,v1 ls,v1 le//return if ray r* moves closer to line l; or not\n){//return (segments(rs,ls,le)>segments(r2,ls,le))//there should be a way way with less segments()!\n ;//above does NOT cach adiv0 case for ls==le\n ;v1 ll=le-ls\n ;v0 c= dd(ll);if (c==0.)return false ;//if(zero-length line segment) //means its unhittable, which is odd!\n ;return (dd((rs-ls-(ll*sat((dot(rs-ls,ll)/c)))))\n         >dd((r2-ls-(ll*sat((dot(r2-ls,ll)/c))))))//segment2(r22,ll)\n  //there possibly is no more precise way here.\n ;}\n\n//this is NOT correct iff Rayorigin is closer to linesegment than RayTarget\n//it needs to  ckech for signs, needs sign-biased distance to line (segment())\nv1 InterWall(v1 rs,v1 r2,v1 ls,v1 le//rayStart, RayPoint2, segmentStart,SegmenrEnd\n){if(catch(rs,r2,ls,le))return r2\n ;v1 j=(ls+le)*.5//midpoint\n ;v1 i=gLLxX0(rs,r2,ls,le)//interssecion of LINES\n ;if(length(i-j)>length(ls-le)*.5)i=rs  //there should be a way way with les sqrt()!\n ;//and i dont think that a coordinate-rotation is good here (low precision from trig/dot() )\n ;return i;}\n\nv3 demoLineIntersection(v0 t,v1 u,v2 r,v3 m\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 l0=v1(-.4)\n ;v1 l1=v1( .7)\n ;v1 r0=v1(.5,-.5)\n ;v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){r0=fra(t,bufDrag(+0.).xy,r,m)*2.\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){r1=fra(t,bufDrag(+1.).xy,r,m)*2.\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+2.).xy,r,m)*2.\n ;} \n ;if(pointCount >3.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+3.).xy,r,m)*2.\n ;}\n ;c.x=segment(u,l0,l1)\n ;c.y=segment(u,r0,r1)\n ;c.z=length(u-mix(l0,l1,.5))\n ;c.w=length(InterWall(r0,r1,l0,l1)-u)\n ;c.xy-=.02\n ;//c.z=abs(c.z-.05)-.02\n ;//c.w=abs(c.w-.1)-.03\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=1.\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n\nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;//c=mix(ss(c.xyzw,viewzoom/Aa(t,u,r,m)),fract(c.xyzw*9.),.2)\n ;c=smoothstep(4./Aa(t,u,r,m),-4./Aa(t,u,r,m),c)\n ;c*=.3\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,1)*c.w))\n ;return c;}\n/**/\n\n\nvec4 iCB(out v3 o,v1 u //wrapper for bezier +appolonean demo\n){//o+=demoBezierQuad(iTime,u,iResolution,iMouse)\n ;//o=ltj3Wc(o,u,iResolution,iMouse)//previously called iCanvas\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;     if(pointCount< 7.)o=(demoBezierQuad   (iTime,u,iResolution,iMouse))//,o)\n ;else if(pointCount< 9.)o=(demoProject      (iTime,u,iResolution,iMouse))//,o)                  \n ;else                   o=(demoIkBezier     (iTime,u,iResolution,iMouse))//,o)\n ;//o=demoLineIntersection(iTime,u,iResolution,iMouse)\n ;//o=demoProject(iTime,u,iResolution,iMouse)//not correct for many cases, sign-ignorant\n ;//o=sat(o)\n ;return o\n ;}\n\n//temporal reprojection  MainImage\n//self  : https://www.shadertoy.com/view/wlf3RB\n//parent: https://www.shadertoy.com/view/Xd2fzR\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\nvec4 mTR(vec4 o,vec2 u\n){vec3 c=tf3(u,iResolution.xyz).xyz\n ;float g=dot(c,vec3(.3333))// burn highlights\n ;c=mix(c,vec3(g),min(g*.15,1.))\n ;c=pow(c,vec3(.4545))// gamma\n ;c=1.15*pow(c,vec3(.9,.95,1.))+vec3(1,1,0)*-.04 // instafilter\n ;//vignete    \n ;//vec2 q=u/iResolution.xy\n ;//c*= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n ;return vec4(c,1);}\n\n#define pDoOver(a) pdOver(o,texture(a,u/iResolution.xy, -100.0 ))\n\n\n\n\n\n//below code is: RE7 [[BayesianEpsilon targetFPS] [Image]]\n//iRe refers to the ichannel buffer locale of [relativistic camera movement]\n//the type of camera mkovement where [time slows down, reciprocal to the speed of light].\n//that is, reaching the speed of light is impossible, because that halts the speed of time.\n//and any 2 observers with no relative movement hate time between them pass with the speedOfLight.\n\n#define iRe iChannel2\n\n//tags:\n//lod,blackhole,redshift,relativity,compatibility,dilation,bayesian,simultaneouity,bayeEps\n//bayemode =0 has a period of 1 second\n//bayemode =1 has a period of 1 frame, which keeps failing me, always.\n#define BayeMode 0\n/*\nself    RE7 : https://www.shadertoy.com/view/tlf3zj\nparent0 RE6 : https://www.shadertoy.com/view/WtfGRj\nparent1 RE5?: https://www.shadertoy.com/view/tdfXDl\n/**/\n//todo, hide thes BaeysTheorem-oscillations in \n//- temporal reprojection\n//- a screenspace noisy-offset of parameters (uv stays unaffected)\n//- - 16x16BayerMatrix should be good enoug here\n//- all of the above\n//- a lower  FPStarget causes lessfps and better images\n//- a higher FPStarget causes higher and worse images\n//enter target fps as base below, and see it oscillate till it hopefully approaches the target fps\n//its a kind of magic of the logn() core function:\n//#define FPStarget pow(10.,1.68)   //<20 fps is only significant on higher resolutions||maxStepRayMarching\n//#define FPStarget pow(20.,1.68) //this integer fraction of 60 seems fine\n#define FPStarget pow(30.,1.68) //avoid [integer fractions of 60] as fps, they conmverge the slowest\n//#define FPStarget pow(40.,1.68)\n//#define FPStarget pow(50.,1.68)\n//testing sclaing of resolutions is hard. the fps dispolay is a big overheat\n//, that tends to cost -5% of the fps.\n//the fun part, FPStarget is INDEPENDENT from the parameter below\n#define maxStepRayMarching 2000\n// within maxStepRayMarching[50..200], which mostly depends on the average scene curvature\n//which is hard to estimate becuase it has a black hole inside of it!!!\n//thats right, you enter 200 maxSteps, and   FPStarget pow(40.,1.68), and iut will reach 40 fps!\n//\"as you qishh milord\"\n//initially FPStarget mapped to a targetFPS one to one (esponent was initially close to 1), \n//so yo you could enter what fps you wanted, and it would almost reach it.\n//but the more complex this gets, the worse your scales and estimates become\n//andd the overhead accumulates, and has problems to estimate its own cost.\n//currently the overhead is roughly an exponent of 1.6 to 1.7 ?\n//nonetheless, all the DIRECTIONS of the interpolations and bijections are correct\n//and with that exponent, you can enter the target fos as basis\n//it is optimized for the 500px-wide preview, may not scale too well to larger resolutions\n//i tried, this is VERY twittly.\n//this really needs BoundingVolumes, so that not all viewing angles have roughly the same complexity!!!\n//so yeah, if there ever was a shader that needed lobeps added to it...\n//but fitst let me fix compatibility iassues of this shader...\n/*\ncore idea here is, you set a target fps, and the renderer tries to just reach that FPS count.\nit may increase epsilon, if it was overperforming previously (fps was above FPStarget)\nit may decrease epsilon, if it was underperforming previously (fps was below FPStarget)\nstill, there exists a clamp() to the epsilon values\n, and a lot of of smoothened interpolation ramps and logarythms.\n, because an extreley huge epsilon makes little sense in 60fps\n, because an extremely tiny epsilon makes little sense, just to stay at a lower FPStarget\nThis begs for a better [BayesTheorem over time], but i have yet to implkement the necessary state for that.\nit does not just do this for epsilon, but also for [ReciprocalLipschitz]\n, ==[the amount you understep by]\n, ==[the interval of your volumeMarching]\nIt has a bias in vafor of the ScreenCenter \n- smaller reciprocalLipschitz near screencenter than near screen corner\n- smaller epsilon near screencenter than near screen corner\n- - the epsolon oscillations in a 1 second interval are more noticable near screen corners\n- - damnit this is inverse fovea!\nthis might be much more useful in a set with\n- Proper (axis aligned)BoundingVolume(hierarchy), may be great with fractals with simple escapeTime conditions\n- very different sceneries, a long beach horiton and a small simple box.\n- logatythmic epsilon marching\n- SoC marching\nnegative side effect;\n- id goes into the right directions, but it fails to estimate any half decent taylor series, and therfore misses the target a lot\n- , unles you add more exponents to twiddle with.\n- in too high resolutions (or at 15 or 30fps) , It may heavily oscillate between 2-4 states where it keeps being [too fast] , [too slow]\n- without proper [bayes theorem over time with buffer states] i fail to twiddle parameters to work with multiple resolutions/settings.\nbut so far the proof of concept holds up for this set, and it kinda works\n,while in     512.*384. px resolution\nmost of its magic comes from its bijective subroutine: (r2l2Ws(logn()))\n*/\n//[from 0 to zFar or 1./zFar and within]\n//i got bored of infinity and infinitessimals and with the assertion of [infinity=zFar] you get [infinitessimal=1/zfar]\n//now, if only we could translate these 2 ratios into one single linear scale, //this has great potential in improving spheretracking logeps():\n//we use logn():\n//logN(x) to logE(x)=log(x) (conversion by division), log(n) is a log() in any EXPLICIT base \nfloat logn(float base,float x){return log(x)/log(base);}//log2(x)/log2(base) has any utility? possibly slower or less precise or both, just test it!\n//as long as base=zFar is constant, we only do 1 runtime log() here; else use a LookUpTable of a list of log([zfar0,zFar2,zFar2...]) as divisor\n//nope, i did not gain anything too useful from sucstituting for log2(x)/log2(bae), so far, i tried here, its just not pretty.\n//4 functions below convert bijectively between a 2d-Ratio [from infinitessimal to infinity] and a 1d-linear scale [from  0 to 1]\n//its top 2/4 are subroutines of its bottom 2/4 (with different InOut scaling)\n//[b] is a [bijective constant] that is [uniform within its context] (to uphold a bijection in 2 directions)\n//here: b=zFar>0  (or our lookup table of zFar values)\n//b can be large, because b is always wrapped within log(b) these functions are fast and precise 1x pow() is its slowest\nfloat l2r2(float a,float b){return pow(b,a)/b;}                  //[  0..2] <= [1/b..b] //read this like F# syntax\nfloat r2l2Ws(float a,float b){return logn(b,clamp(a,1./b,b)*b);} //[1/b..b] <= [  0..2] //we explicitly use a worksafe[a] function\nfloat l2r(float a,float b){return l2r2(a*2.,b);}          //a[  0..1] <= a[1/b..b]\nfloat r2l(float a,float b){return r2l2Ws(a,b)/2.;}        //a[1/b..b] <= a[  0..1]\n//just like carthesian2polar()&&polar2carthesian() (BUT it deals with [zFar and 1/zFar] instead)\n//, you may apply the above bijection to the gratient and bake both into a faster/specific (sub) form, that somehow incooperates 1/x\n//bayesEps concept\n//use BayesTheorem to adjust epsilon over time, to reach a target FPS\n//if you look along the horizon, expect epxsilon to increase, to maintain fps\n//if you look into a small box, expect epsilon to derase, for more precision\n//input current epsilon and TATGET fps\n//return an epsilon, in hopes to adjust epsilon, to get [[f] fps] with the next frames.\nfloat getEpsToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.75\n //.75 is a pretty high max epsilon, but its the easiest way to get performance\n //, especially further away from the camera or behind an occuder or near a black hole\n ;mie=.00085*.25 //.00085 is artefact free mie with recLipschitz==1.\n                //mie<.00085 needs small recLipschitz, or walls look ugly.\n                //mie<.00085 makes the blackh hole looks smoother, but distant flat walls look worse.\n                //mie>=.00085 seems to be a lower bound for this scene, lower Mie cause black dots, where roots are never reached.\n ;//mie*=2.\n ;float N=6.\n ;//i=i/f\n ;//i=i*iResolution.x/512.\n ;//i=clamp(i,1./N,N)//this could need a special acos()-like function\n ;//i=1./iFrameRate\n ;float i=pow(iResolution.x/512.,2.5)\n     #if BayeMode ==1   \n   ;float tt=pow(FPStarget,1./1.68)\n   ;tt=pow(tt*300./40.,1.68)\n ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n   ;i*=tt/60.\n      #else\n ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n      ;i*=FPStarget/60.\n     #endif\n ;e=r2l(i                 \n        //r2l(iFrameRate/iTimeDelta)  //is nonsense on too many levels, so a good hint at what combos to avoid\n     \n                   //this segment tries to be clearvoy about what type of GPU you have to support resolutions\n           //and estimates how a deviation from an ideal resolution may affect GPU performance\n           //i am not fgood at this:\n        \n    //     r2l(iResolution.x/512./iFrameRate) //surprisingly simple anf dunctional\n            // i //this seems to be a good estzimate, it oscilates a bit and approaches a limit FAST\n\n\n    //r2l(1./iFrameRate) good and siomple\n    // iTimeDelta   /60.   //offly slow\n           \n       // *iResolution.x/512. //seems utterly wrong, way too strong oscillations\n          // r2l(1.iFrameRate/sqrt(iResolution.x*iResolution.y)/sqrt(384.*512.))//not too good \n    //   *512.*384./iResolution.x/iResolution.y //this like feels false\n        ,N)//we expect to get fps in range[1./9000,9000]\n     //a 1/N ratio maps to 0\n     //a 1/1 ratio maps to 1\n     //a N/1 ratio maps to 2, so, this transforms a ratio into something to mix with:\n ;e=e//pow(e,2.)//sqrt(e)\n ;//e=log(e)\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae)\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\n//the rotating fractal is evil here, because smaller epsilon result in BETTER lipschitz continuty AND better performance\n//so, some shapes are exceptions to general rules of optimitation-flow, with a shitty local extrema!\n//a minor drawbeck to the overall greatness of Naesian methods in sphertrackers.\n//or maybe just a bug to be fixed.\n#define rayEps getEpsToFps()\nfloat getEpsToFps(){//return 1.\n   ; return getEpsToFps(.001,FPStarget)\n    ;}\n//the fun of the above is, worst case is that it oscilates a bit\n//now, we can have 2 parameters independently modified in this way\n//both likely oscillate differently, and not the same (which woulc link them inapropriattrly)\n//so, lets also modify reciprocalLipschitz just like that:\n/**/\nfloat getReLipschitzToFps(float e,float f   //f>0.\n){//float i=iFrameRate //better average\n ;//if(i==0.)i=iTimeDelta*60.//worse choice, except for all frames of the 1st second\n ;//if(i==0.)return 0.001 //first few frames do not calculate anything\n ;//f=60.\n ;//mie and mae ideally are  artbitiary bounds, except for now, they are [moredately reasonable constants]\n ;//[machineEpsilon] == expected upper found of an error of any type float operation.\n ;float exponentBits=8.\n ;float mantissaBits=31.\n ;float mie=exp2(exponentBits-mantissaBits)//this is a reasonable iminal epsilon\n ;float mae=.8//just do not make  mae>1., unless you are in logeps() marching territory.\n ;mie=.6 //mie<.5 will likely just result in getting you a larger epsilon, not worth it.\n     //mie>.6 is already too large, for shapes\n     //, that move with [half the speed of light][near a black hole]\n     //- yes, these are my quality merasures for lipschitz continuity by now.\n     //- once you have logeps()-marched a double [tensor] with lipschitz>5 \n     //- with no continuity or performance problems\n     //- , you kinda run out of challenges.\n ;float N=6.\n ;float i=pow(iResolution.x/512.,2.5)\n     #if BayeMode ==1   \n   ;float tt=pow(FPStarget,1./1.68)\n   ;tt=pow(tt*300./40.,1.68)\n ;i=i*iTimeDelta/30. //experimental, nah this keeps failing me but hard to ballance\n   ;i*=tt/60.\n      #else\n   ;i=i/iFrameRate  //works better ,but oscillatesin 1 second interval\n     ;i*=FPStarget/60.\n     #endif     \n ;i=clamp(i,1./N,N)//worksave bound\n ;e=r2l(i,N)\n     //a 1/N ratio maps to 0\n     //a 1/1 ratio maps to 1\n     //a N/1 ratio maps to 2 , so, this transforms a ratio into something to mix with:\n ;//it seems i need a good simoid function here, maybe even hust atan1()\n ;e=mix(mie,mae,e)\n ;e=clamp(e,mie,mae);\n ;return e\n ;//return mix(mae,mie,r2l2Ws(f,iFrameRate))\n ;//return .001;\n ;}//without bayes theorem, this has limited utility, is a lot more twiddly\n//this just has too many unknown dependencies\n//i just can not triddle-account for many unknowns, without BayesTheorem.\nfloat getReLipschitzToFps(){//return 1.\n   ;return getReLipschitzToFps(.25,FPStarget);}\n//our baseline is still a targetPFS\n//#define dd(a) dot(a,a)\n//now, lets make it better near the screen center\n//lets weight them over how oval-distant they are to screenspace center\n//of course the oval is scaled by sqrt(2) and is a smoothstep and all the good stuff\nfloat getEpsToFps(float sscoc){\n    //here it makes sense, i suppose\n    ;sscoc=mix(FPStarget*.25,FPStarget*4.,sscoc)//larger epsilon neart screenspace borders, smaller near center\n        ;return getEpsToFps(.001,sscoc);}\nfloat getReLipschitzToFps(float sscoc){//return 1.\n   ;sscoc=mix(FPStarget*.25,FPStarget,sscoc)//lefr value near corner, right value near center\n   ;return getReLipschitzToFps(.25,FPStarget);}\n#define reciprocalLipschitz getReLipschitzToFps()\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.2)/iResolution.xy);}\nstruct Ray\n {vec3 dir\n ;vec3 b\n ;vec3 surfaceNorm\n ;int iter\n ;float time\n ;float dist\n ;int object\n ;vec3 closestObject;};\nvec3 GetMaterialsColor(Ray r, int matID\n){if(matID>7)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*float(matID*2))*fakeOA\n ;}\nvec3 GetMaterialsColor(Ray r, float matID\n){if(matID>7.)return vec3(0)\n ;float fakeOA = pow((1.-float(r.iter)/float(maxStepRayMarching)),.7)\n ;return rainbow((sqrt(5.)*.5+.5)*matID*2.)*fakeOA\n ;}\nvoid MarchLight(float sscoc,inout Ray r, float startTime, float maxDist//relkativistic raymarcher\n){float totalDist = 0.0\n ;vec3 origin = r.b\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){r.time = startTime\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;totalDist += r.dist*getReLipschitzToFps(sscoc)\n  ;r.b+=r.dir*(r.dist)\n  ;if(abs(r.dist)<getEpsToFps(sscoc)||totalDist>maxDist)break;}}\nvoid MarchPOV(inout Ray r, float startTime,float sscoc\n){//dpos = vec3(-2.2,0,0)\n ;//lorentzF = LorentzFactor(length(dpos))\n ;float speedC = length(dpos)/cSpe\n ;vec3 nDpos = vec3(1,0,0)\n ;if(length(dpos)>0.)nDpos = normalize(dpos)\n ;//shrink space along vel axis (length contraction of field of view)\n ;float cirContraction = dot(nDpos,r.dir)*(LorentzFactor(length(LgthContraction*dpos)))\n ;vec3 newDir = (r.dir - nDpos*dot(nDpos,r.dir)) + cirContraction*nDpos\n ;r.dir = normalize(newDir)\n ;float dDirDpos = dot(dpos,r.dir)\n ;// Aberration of light, at high speed (v) photons angle of incidence (a) vary with lorenz factor (Y) :\n ;// tan(a') = sin(a)/(Y*(v/c + cos(a)))\n ;// velComponentOfRayDir' = Y*(velComponentOfRayDir+v/c)\n ;float lightDistortion = lorentzF*(dot(-nDpos,r.dir)+speedC)\n ;r.dir=mix(r.dir\n           ,normalize((r.dir-nDpos*dot(nDpos,r.dir))-lightDistortion*nDpos)\n           ,FOVAberrationOfLight)\n ;//Classical Newtown Mechanic instead would be\n ;//r.dir = normalize(r.dir-dpos/cSpe)\n ;for (r.iter=0;r.iter<maxStepRayMarching;r.iter++\n ){float camDist = length(r.b - objPos[oCam])//es100 error , no array of class allowed\n  ;float photonDelay = -camDist*cLag/cSpe\n  //takes dilated distance x/Y and find the time in map frame with :\n  // v = -dDirDpos (dot product of direction & velocity, because we want to transform from cam frame to map frame)\n  // Y = lorentzFactor\n  //\n  // t' = Y(t-v*(x/Y)/c²)\n  // t' = Y(0-v*(x/Y)/c²)\n  // t' = Y(v*x/Y)/c²\n  // t' = vx/c²\n  ;float relativeInstantEvents = SimultaneousEvents*dDirDpos*camDist/(cSpe*cSpe)\n  ;r.time = startTime\n  ;r.time += mix(relativeInstantEvents,photonDelay,cLag)\n  ;SetTime(r.time)\n  ;r.dist = map(r.b,-1)\n  ;//Gravitational lens\n  ;vec3 blackHoleDirection=(objPos[oBlackHole]-r.b)//es100 error , no array of class allowed\n  ;r.dir+=(1./RayPrecision)*r.dist*reciprocalLipschitz\n      *normalize(blackHoleDirection)*BlackHoleMassFactor/(length(blackHoleDirection)*cSpe*cSpe)\n  ;r.dir = normalize(r.dir)\n  ;if(abs(r.dist)<getEpsToFps(sscoc))break\n  ;r.b+= (1./RayPrecision)*(r.dist)*reciprocalLipschitz*(r.dir);}\n ;//r.b = origin + r.dir*min(length(r.b-origin),maxDist)\n ;r.surfaceNorm = GetNormal(r.b).xyz;}\nvec3 GetDiffuse(float sscoc, Ray r\n){vec3 cDiff=vec3(0)\n ;Ray tmpRay = r\n ;float vma2=vma;//accretion disk before recalculation\n ;float mat=float(rayMat)//trippy bug caused by copying/moving this linefurther down.\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -r.b)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -r.b//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -r.b)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-r.b)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  #ifdef CauseMaterialColoredShadowsBug\n   #define basicBug \n   #ifdef basicBug\n   ;mat=float(rayMat) //trippy bug-> shadows in ID.color\n   #else\n    //might want to floor because mat sets hue on a goldenSpiral\n    //floor()not needed above , while rayMat is type int\n    //above is simple bug case\n    //below oscilates the effect over [player time]==Get(ReTime).x\n   ;//mat=mix(float(mat),float(rayMat),cos(Get(ReTime).x)*.5+.5)\n       //might want to floor because mat sets hue on a goldenSpiral\n   ;mat=floor(mix(float(mat),float(rayMat),cos(Get(ReTime).x*.3)))\n   #endif    \n  #endif\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = r.b + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(sscoc,shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-r.b) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(r.b,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(r.b,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;cDiff+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  cDiff+(lHalo+vma2)*(1.-cDiff);}\n/*\nvec3 GetDiffuse(Ray r\n){Ray tmpRay = r\n ;vec3 surfPos = r.b\n ;float accretion = vma\n ;vec3 diffuseCol = vec3(0)\n ;//accretion disk\n ;int mat = rayMat\n ;vec3 objVel = objVel[rayObj]//es100 error , no array of class allowed\n ;vec3 lHalo = vec3(0)\n ;float[numLights] halos//es100 error , no 1st class array\n ;for(int L=0;L<numLights;L++)halos[L]=oliHal[L]\n ;for (int L=0;L<numLights;L++\n ){float lightLate\n  ;for (int i=0; i<10; i++\n  ){lightLate=cLag*length(oliPos[L]\n      -surfPos)/cSpe\n   ;ProcessLightValue(r.time-lightLate);}\n  ;vec3 lightRelPos = oliPos[L]//o_lights[L].b\n      -surfPos//es100 error , no array of class allowed\n  ;vec3 camLightDir = normalize(oliPos[L]\n                                -pos)//es100 error , no array of class allowed\n  ;vec3 lightColor = oliCol[L].rgb      //o_lights[L].colorIntensity.rgb\n      //es100 error , no array of class allowed\n  ;ProcessLightValue(r.time-lightLate+0.01)\n  ;vec3 lightVel = ((\n      oliPos[L]//o_lights[L].b\n                     -surfPos)-lightRelPos)/0.01//es100 error , no array of class allowed\n  ;vec3 lightRelVel = lightVel - objVel\n  ;vec3 lightDir = normalize(lightRelPos)\n  ;vec3 camDir = normalize(pos-surfPos)\n  ;vec3 camRelVel = dpos - objVel\n  ;float lightLorentzF = LorentzFactor(length(lightVel))\n  ;float halo = halos[L]//es100 error , no array of class allowed\n  ;float camDirLightSpeed = dot(camLightDir,lightVel)\n  ;float camDirCamSpeed = dot(camLightDir,dpos)\n  ;float haloRelativisticRelSpeed = (camDirCamSpeed-camDirLightSpeed)/(1.-(camDirCamSpeed*camDirLightSpeed/(cSpe*cSpe)))\n  ;SetTime(r.time)\n  ;vec3 matCol = GetMaterialsColor(tmpRay,mat)\n  ;Ray shadow\n  ;shadow.b = surfPos + lightDir*.1\n  ;shadow.dir = lightDir\n  ;float dropShadowAtten = 1.\n  ;MarchLight(shadow, r.time, length(lightRelPos))\n  ;if(length(shadow.b-surfPos) < (length(lightRelPos)-.5))dropShadowAtten=.4;\n  ;//SetTime(r.time)\n  ;//float distTime = map(surfPos,mat)\n  ;//SetTime(r.time+0.01)\n  ;//distTime = map(surfPos,mat) - distTime\n  ;//float speed = -distTime*100.0\n  ;float speed=0.\n  ;//speed += LorentzFactor(lightRelativisticRelSpeed)\n  ;speed += dot(lightDir,-lightRelVel)\n  ;speed += dot(camDir,-camRelVel)\n  ;float atten = max(0.,dot(lightDir,r.surfaceNorm))\n  ;//atten *= min(1.,dot(r.surfaceNorm,-r.dir)*100.0)\n  ;atten *= 1./(0.5*length(lightRelPos)+1.)\n  ;//atten *= min(1.,(1.5-float(shadow.iter)/float(maxStepRayMarching))*1.)\n  ;atten *= dropShadowAtten\n  ;diffuseCol+=dsf(lightColor*matCol*atten\n                  ,(cSpe/(cSpe-speed*dopplerFactor))\n                   *lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler))\n  ;lHalo+=halo*dsf(lightColor,(cSpe/(cSpe-(haloRelativisticRelSpeed)*dopplerFactor))\n                   *(lorentzF/mix(lorentzF,lightLorentzF,relativisticDoppler)))\n  ;}\n ;return  diffuseCol+(lHalo+accretion)*(1.-diffuseCol);}\n*/\nvec3 GetSampleColor(float sscoc,vec2 uv\n){    \n ;Ray r\n ;r.dir = vec3(0,0,1)\n ;if (fishEye\n ){vec3 crossv=cross(r.dir,vec3(uv,0))\n  ;r.dir=qr(aa2q(length(uv)*FOV,normalize(crossv)),r.dir)\n  ;}else r.dir = vec3(uv.xy*FOV,1.)\n ;//apply look dir\n ;r.b = objPos[oCam]//es100 error , no array of class allowed\n ;r.dir = qr(objRot[oCam],r.dir)//es100 error , no array of class allowed\n ;MarchPOV(r,playerTime,sscoc)\n ;return GetDiffuse(sscoc,r);}\n\nvec4 mainImageRe7(vec4 o, in vec2 u\n){//vec2 u=fra(uv,iResolution)//(uv/iResolution.xy+.5)/iResolution.y\n ;float sscoc=length(u/iResolution.xy-.5) //length(u/iResolution.xy*+.5)/sqrt(2.)\n ;sscoc=smoothstep(.75,0.,sscoc)//full btight in the center, pitch black at the cotner, oval\n ;vec2 v=(u-iResolution.xy*0.5)/iResolution.yy\n ;//int tuu=6%5\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;playerTime = Get(ReTime).x\n ;//vec3 LZZ = dpos\n ;//vec3 LZY = vec3(0,1,0)\n ;//vec3 LZX = cross(LZY,normalize(LZZ))\n ;//LZY = cross(LZZ,LZX)\n ;//LZLgthContract = mat3x3(LZX,LZY,LZZ)\n ;lorentzF = LorentzFactor(length(dpos))\n ;SetTime(playerTime)\n ;ProcessCamPos(Get(RePos).xyz,Get(ReQua))\n ;vec3 color = GetSampleColor(sscoc,v)\n ;//float ao = 1.-float(r.iter)/float(maxStepRayMarching)\n ;o = vec4(color*1.5,1)\n ;//o *= length(Get(D_POS).xyz)/SpeedOfLight //differential debug\n ;o+=(texture(iRe,u/iResolution.xy).rgba );\n ;return o;}\n\n\n//below is a very basic toggle-wrapper, showing what 2 shaders have been hodgepodged\n//this completes step2, fixing all namespace conflicts. (was easy for once)\n//step 2 is to clean up mainImageRe7() and its subroutines.\n//step 3 is trckier\n//all these buffers store properties, an array of vec4 \n//and I need them to evade any conflict between them\n//so I can merge thzem into a single buffer\n//- (lets exclude BufferD for being a screenspace incrementalAveraging buffer)\n\n\n#define Scene2D\n\n//#if 1\nvec4 mainImageUI2AD37(out vec4 o, in vec2 u\n){o=vec4(0)\n #ifdef Scene2D\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d srawing\n #else\n  #ifdef SceneTR\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  #else\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n  #endif\n #endif\n ;return o      /**/\n ;}\n/*\n//#else\nvoid mainImage(out vec4 o,vec2 u\n){o=mTR(o,u)//temporal reprojection\n;}\n//#endif\n/**/\n\nvec4 spin(vec4 o,vec2 u\n){vec2 v=fra(iTime,u,iResolution,iMouse)\n ;o=vec4(0)\n   \n    \n ;//o=pdOver(iDiegeticUIshow(u),o)//ui dots\n ;//o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n ;v*=rot2D(u5(cos(iTime/9.)*99.))\n ;if(v.x>0.){if(v.y>.0){\n   ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n   ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n   ;//o=pDoOver(iAD)  //backfrop is marched 3d scene (automatic Differentiation)\n   ;return o;\n   ;}\n  ;o=pdOver(iDiegeticUIshow(u),o)//ui dots\n  ;o=pdOver(o,iCB(o,u))//bezier+appolonean stuff\n  ;//o=pdOver(o,mTR(o,u)) //backfrop is traced 3d scene (TemporalReprojection+brdf)\n  ;return o\n  ;}\n ;if(v.y>0.){\n  ;o=pdOver(o,iCB(o,u))//iCB(o,u)\n  ;//o=pdOver(o,ltj3Wc(o,u,iResolution,iMouse))//backsrop is a 2d drawing\n  ;return o\n ;}\n ;return o\n //;return mainImageRe7(o,u)\n ;}\n\nvoid mainImage( out vec4 o, in vec2 u\n){\n //;o=spin(o,u)\n    \n #if 1\n ;o=mainImageUI2AD37(o,u)\n #else\n ;o=mainImageRe7(o,u)\n #endif\n/**/\n ;}\n\n\n/*\nI like my code modular, evading namespace conflicts, while having short namespaces.\nI heavily advocate for compatibility, performance and diegetic UI.\nIO see this ignored too often\nThe acronym \"ReTrAdUi\" makes fun of bad UI design, namespaces and typos.\n*/", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/**/ //start plugin notes:\n/*\n\npluginName= iDiegeticUI v2\n\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n- scale inout to storage data by iResolution.xy (or your scaling will just be off)\n\n\nThese plugin specific subroutines of this shader are only used in this shader:\n-   addInit() //initial state == onInit() dot[x] positions\n- clickLoop()\n-   branchi()\nShared Common Subroutines\n- see CommonTab: modifiables for diecetic_UI_2\n- const v3 deleteRect  AxisAlignedBound (red deletion rectangle)\n- inRect(uv,deleteRect) //contextBoundFilter\niDiegeticUI has lots of visualization code, likely only needed in ImageTab\n- drawDragDots()\n\n--- pseudocode structure:\nmainImage(){\n ;//...\n ;if (iFrame==0\n ){v0 count=0.//init\n  ;addInit()\n  ;}\n ;//...\n ;     if(max(state.z,-iMouse.z)<0.)clickLoop(...)\n ;else if(min(state.z,-iMouse.z)>0.&&inRect(iMouse.xy,deleteRect\n ){branchi(...)\n  ;//...\n  ;}\n ;}\n\niDiegeticUI buffers a list of dot[x]\n, for a dragAndDrop UI (in screenspace)\n, and one fragment buffers [number of dots]\n\nAny other shader can read these dot-coordinates\n, commonly used to modify parameters of parametricFunctions:\n- parametric CSG (debug/demo frustrumCulling or AutomaticDifferentiation)\n- - [megaprm]\n- - \"implicit\" splines/isosurfaces\n\nthis buffer stors states that set:\n- number of stored states\n-.xy coordinate of points for [diecetic UI]\n\n/**/ //end__ plugin notes:\n\n\n/*\ndiecetic /screenspace UI = reusable drag&drop\n, as basis for some non-screenspace diegetic-UI\n, like in a FlightSim, [BattleTech], [DeathSpace] or [Astroneer]\n\nparent     : https://www.shadertoy.com/view/Xt3BzX\nparent     : https://www.shadertoy.com/view/4dtSRn\nInspired by: https://www.shadertoy.com/view/MdKGRw\nreusable drag and drop framework; by mhnewman\n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\nbuffOfDot(v0(floor(x))) function returns parameters of dot[x]\n- THIS shader should not contain buffOfDot()\n- , but instead most likely just the [ImageTab] for a screenspace UI\n\nmaxCount := the maximum number of objects that can be represented.\nBuffer pixels (0, 0) to (maxCount - 1, 0) := the coordinates of each object.\n  * .x := the object's x coordinate.\n  * .y := the object's y coordinate.\n\n Buffer pixel (maxCount, 0) := the current state.\n  * .x := the index of the currently selected object.\n  * .y := the number of active objects.\n  * .z := the mouse state.\n\n Buffer pixel (maxCount + 1, 0) := the mouse offset from the center of the current object.\n\n/**/\n\n//alias for an initial state:\n#define addInit(xPos, yPos) {if(u.x==count)o=v3((xPos),(yPos),0.,0.);count+=1.;}\nvoid rToD(v0 d,inout v0 r,inout v3 state,inout v0 f,inout v3 o,v3 center,v3 m){if(d<r){r=d;state.x=f;o=center-m;}}//for iDiegeticUI\n\nvoid  clickLoop(inout v3 state,v3 o,v3 m\n){v0 r=clickPointRadius+1.\n ;for(v0 i=0.;i<maxCount;++i\n ){v0 f=i\n  ;if(f>=state.y)break\n  ;v3 center=texture(iDiegeticUI ,v1(.5+f,.5)/iResolution.xy)\n  ;rToD(length(m.xy-center.xy),r,state,f,o,center,m);\n ;}if(r>clickPointRadius)state.xy=mix(v1(2.*statePos,state.y),state.yy+v1(0,1),step(state.y,statePos));}\n\nvoid branchi(inout v3 o, v1 u,v0 S,v3 s,v1 U//out,uv,statepos,state,U\n){     if(u.x==S )o=v3(2.*S,s.y-1.,iMouse.z,1)\n ;else if(u.x<s.x)o=texture(iDiegeticUI, U/iResolution.xy)\n ;else            o=texture(iDiegeticUI,(U+v1(1,0))/iResolution.xy);}\n\nvoid mainImage(out v3 o,in v1 U\n){v1 u=U-.5\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;if(u.y>0.||u.x>offsetPos){o=v3(0);return;}\n ;if(iFrame==0\n ){v0 count=0.//init\n  ;addInit(.35*iResolution.x,.4 *iResolution.y)//initial iFrame==0 dot placement\n  ;addInit(.75*iResolution.x,.7 *iResolution.y)\n  ;addInit(.5 *iResolution.x,.1 *iResolution.y)\n  ;addInit(.4 *iResolution.x,.7 *iResolution.y)\n  ;addInit(.5*iResolution.x,.3*iResolution.y)\n  ;if(u.x==statePos)o=v3(2.*statePos,count,0.,0.);return;}\n ;v3 s=texture(iDiegeticUI,v1(.5+ statePos,.5)/r.xy)\n ;     o=texture(iDiegeticUI,v1(.5+offsetPos,.5)/r.xy)\n ;     if(max(s.z,-m.z)<0.)clickLoop(s,o,m)\n ;else if(min(s.z,-m.z)>0.&&inRect(m.xy,deleteRect)\n ){branchi(o,u,statePos,s,U);return\n ;}if(u.x==statePos)o=v3(s.xy,m.z,s.w)\n ;else if(u.x==offsetPos)o=o\n ;else if(u.x==s.x&&m.z>0.)o=m+o\n ;else o=texture(iDiegeticUI,U/iResolution.xy)\n ;}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "//pluginName= iAD\n/*\niChannel0=BuffA,iChannel1=BuffB,iChannel2=BuffC,iChannel3=BuffD\n*/\n\n/**/ //--- srart AD-Modifiers \n//these can be twiddled with, without breaking much\n\n#define SuperPrim\n\n#define thick .1\n//line thickness\n\n#define scene 2\n//scene: theres 2 scene-layers, a 2d scene and a 3d scene:\n//domains 1 <-> 2d\n//domains 2 <-> 3d\n//domains 3 <-> mix(3d,2d)\n\n#define IterRm 64.\n//max raymarch iterations|steps\n\n#define IterSh 16.\n//softshadow iterations\n \n#define ReciprocalAbsLipschitz 1.\n//if(lipschitzConstant>1., distance is overestimated.\n//multiplying by ReciprocalAbsLipschitz is a \n//... lazy fix for that is scaling stepDistance*=ReciprocalAbsLipschitz\n//higher precision with a smaller ReciprocalAbsLipschitz AND epsilon=0.\n//meaning, a surface will NEVER really be reached.\n//maybe todo: eps=log(eps*b)*a\n\n#define camLens 2.\n//fieldOfView\n\n#define camRoll 0.\n//camera lens and roll for camera projection matrix (is not a quaternion camera)\n\n\n//below code can be twiddled, easily breaking more things\n\nv0 viewZoom(v0 t,v1 u,v2 r,v3 m){return 1.;}\n#define viewzoom 1.\n\n/**/ //--- end__ AD-Modifiers\n     //\n/**/ //--- start AD-calculus-Intro\n/*\n\nThis demoes [AutomaticDifferentiation]==[AD]\n-,that automatically calculates the NthDerivative of (m)any function(s)\n- , by implementing:\n- -    chainRule (top level function)\n- -  productRule (arises out of chainRule 2nd derivative)\n- - quotientRule (reciprocal productRule)\n- -    powerRule:\n\nself   AD35 : https://www.shadertoy.com/view/WtfGRS\nparent AD26c: https://www.shadertoy.com/view/WtXGW4\nparent AD34 : https://www.shadertoy.com/view/Wlf3WN\nparent AD26 : https://www.shadertoy.com/view/MsffRs\ngranny AD24 : https://www.shadertoy.com/view/XdXfRl\nuncle       : https://www.shadertoy.com/view/XlV3Dy (goursat)\naunt        : https://www.shadertoy.com/view/MsXBRB (simpler shapes)\ngranddad    : https://www.shadertoy.com/view/4dVGzw (swiveled)\n\ngeneral automatic differentiation is:\n- based on    : https://www.shadertoy.com/view/4dVGzw\n- inspired by : https://www.shadertoy.com/view/Mdl3Ws \n- explained at: http://blog.demofox.org/2014/12/30/dual-numbers-automatic-differentiation/\n- wiki        : https://en.m.wikipedia.org/wiki/Automatic_differentiation\n- summary:    : https://www.reddit.com/r/math/comments/68st6p/the_wikipedia_article_on_automatic/\n\nThe details/axiomes/rules of this are explained in the CommonTab implementation\nYou do not need to know ALL its rules to know how to use it\nBut it helps oif you are good in physics, and know what [Inertia] means/models.\n\nThis likely makes much more sense\n, if you first calculate the (double) integral of your function\n, with something like:    https://www.integral-calculator.com/\n, And then use AD to derive that precalculated integral back to its original, for:\n- precise/analytic [filter] [anti-alasing] (by starting from a DoubleIntegral)\n- https://en.wikipedia.org/wiki/Contour_integration\n-Fluid dynamics, pressure waves (With a buffer over time)\n-EM-fields: https://en.wikipedia.org/wiki/Surface_integral\nSpecific analytic filters are done regularily by InigoQuilez\n, mostly noise with analytic first derivatives:\n-  iquilezles.org/articles/morecheckerfiltering\n-  https://iquilezles.org/articles/filtering\n-  https://iquilezles.org/articles/filterableprocedurals\n-  https://iquilezles.org/articles/gradientnoise\n-  https://iquilezles.org/articles/morenoise\n- - IQ stateless (no LookUpTable/texture/VBO) 2d and 3d noise (with analytic derivatives) \n  - - Value    Noise 2d 1st Derivative:  https://www.shadertoy.com/view/4dXBRH\n  - - Gradient Noise 2d 1st Derivative:  https://www.shadertoy.com/view/XdXBRH\n  - - Value    Noise 3d 1st Derivative:  https://www.shadertoy.com/view/XsXfRH\n  - - Gradient Noise 3d 1st Derivative:  https://www.shadertoy.com/view/4dffRH\n  - - Value    Noise 2d 0th Derivative:  https://www.shadertoy.com/view/lsf3WH\n  - - Value    Noise 3d 0th Derivative:  https://www.shadertoy.com/view/4sfGzS\n  - - Gradient Noise 2d 0th Derivative:  https://www.shadertoy.com/view/XdXGW8\n  - - Gradient Noise 3d 0th Derivative:  https://www.shadertoy.com/view/Xsl3Dl\n  - - Simplex  Noise 2d 0th Derivative:  https://www.shadertoy.com/view/Msf3WH\n- - \nAD allows you to automate this, with up to a 3th derivative, over up to 4 domains.\nYou calculate thedouble Integral of any function, and AD calculates you 3 derivatves for a [filter]\nThis works over up to 4 domains, this is multivariate-calculis, right?\n\nI mean, tthis can solve for optimization problems of a\n  https://en.wikipedia.org/wiki/Partial_derivative\n, right?\n\n[AD]==[Automatic Differentiation] implies the\nhttps://en.wikipedia.org/wiki/Chain_rule\nto cheaply calculate derivatives as byproduct of a set of operands\nwith specific data types\n\n- - All derivatives let you smoothen line-thickness without multi-tapping.\n- - All derivatives let you better esttimate AO or shadows\n\n1st derivative is useful for\n- precise surface normals\n- more precise surface normals. (better normals on corners)\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- precise surface curvature (better scatter/subsurface\n- some adcanced-spheretracking optimizazions\n2nd derivative is useful for \n- well its 3d equivalent [instant changeRate of curvature] lacks a name...\n- and some adcanced-spheretracking optimizazions\n\nprecision or performance increases more\n- near sharp corners\n- with shapes|functions, that lack C0|C1-continuity but have C1|C2-continuity.\n- - https://en.wikipedia.org/wiki/Smoothness\n\nThe \"art\" here is to define an implicit isosurface\n https://en.wikipedia.org/wiki/Implicit_surface\n https://en.wikipedia.org/wiki/Isosurface\n https://www.youtube.com/watch?v=qb40J4N1fa4\nThat way you get all the Contour lines, gradients, normals...\n https://en.wikipedia.org/wiki/Contour_line\n https://en.wikipedia.org/wiki/Gradient\n https://en.wikipedia.org/wiki/Surface_normal\n...along all the domains (dimensions) of a surface\n https://en.wikipedia.org/wiki/Surface_%28topology%29\n...very cheaply, because the contour is orthogonal to the gradient.\n\nhow about some fast lacplachians:\nhttps://en.wikipedia.org/wiki/Laplace_operator\n\n2nd derivatives (of the ChainRule) have tricky property\nthat it likely adds a product or fraction, which implies a\nhttps://en.wikipedia.org/wiki/Product_rule\nor\nhttps://en.wikipedia.org/wiki/Quotient_rule\nas subroutine\n\nWe commonly differentiate over [t] so any \"dx\" is replaced by \"dt\"\nthis evades confusion beween [t]th derivatives and [.x] as domain space\nwhere displacement over time is most common:\n\ntodo. list [differentials of displacement over time]\n\neg: absement=antiderivative of position over time == distance*time == homesickness\neg: a [long shortDistance relationship] \n   == [short longDistance relationship] in terms of [abserment]\nBUT t may also be a spartial domain\neg: the [antiderivative of position over space] actually makes sense\n\n\n/**/ //--- end__ AD-calculus-Intro\n     //\n/**/ //--- start AD-calculus-Overview\n/*\n\nr=f(a); is the general form of a function f(a), something like:\nv0 f(v0 a){return 3.*a*a*a+2.*a*a-a+7.;}\n;\nAutomaticDifferentiation calculates the derivatives of f(a):\n;\nA [deritative of [f(a)] over [a]]\nis the INSTANTANEOUS [rate of change] of [f(a)] over [a]\nThe lazy approach is to measure different 2 points of f(a)\nand calculate the slope between these points\n- This is how most shaders on shadertoy calculate a surfaceNormal\n- - They commonly measure 2x3 points, 2 points along each of the 3 orrthogonal axes in 3d\n- - - That is not the INSTANTANEOUS [rate of change], but more like a lowPrecisionAverage [rate of change]\nA [deritative of [f(a)] is the limit of this slope-angle when length(slope) approaches 0.\n;\nA [derivative of a [    derivative]] is a [2nd derivative], aka [gradient]\nA [derivative of a [2nd derivative]] is a [3nd derivative]\n;\nexmaple speed_velocity:\nA function, that returns the position of something for any time-input\n, returns a [pos=position(time) over [time]]:\nv0 position(v0 t){return 3.*a*a*a+2.*a*a-a+7.;}//input time returns position\n;\nThe derivative of the position() function returns the speed(time) (or velocity in more than 1d)\nv0 speed(v0 t){return  9.*a*a+4.*a-1.;}//input time returns speed\n;\nThe derivative of the speed() function returns the Accelleration(time)\nv0 speed(v0 t){return 18.*a+4;}//input time returns Accelleration\n;\nThe derivative of the Accelleration() function returns the Jounce(time) (the rate of change of accelleration)\nv0 speed(v0 t){return 18.;}//input time returns Jounce\n\n\"Jounce\" is by far not the strangest derived-SI-unit's properNoun here:\n\n/**/ //--- end__ AD-calculus-Overview\n     //\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives.\n/*\n\nWhen we derive over something, we derive over (compositions of)\nhttps://en.wikipedia.org/wiki/International_System_of_Units\nhttps://en.wikipedia.org/wiki/SI_derived_unit\n\nIt helps to define common properNouns\n, to talk about concepts/predictions and correlations\nI shortened some terms (to single-glyph-length), for better monospaced-text\nUppercase labels [T,L,M,I,K,N,J] are nameOfDomain\nLowercase labels [s,m,g,a,e,o,c] are nameOfInitial\nSorted, by how commonly we derive ofer these units:\n-       time()SIunit==[T]==[s]Second\n-     length()SIunit==[L]==[m]Meter\n-       mass()SIunit==[M]==[g](kilo)Gramm  //aka [linear inertia]\n-    current()SIunit==[I]==[a]Ampere\n-temperature()SIunit==[K]==[e]kElvin       //[K] may also be [capitalized \"omega\"]\n-     amount()SIunit==[N]==[o]mOle\n-luminousity()SIunit==[J]==[c]Candela\n\nhttps://en.wikipedia.org/wiki/Metrology#Legal_metrology\n\n/**/ //--- start AD-common-derived-[SIunit]s, sorted by derivatives\n     //\n/**/ //--- start AD-common-derivatives over time,dT,T^(n-1)\n/*\nSome labels are only scalar, or only linear, or only angular\nThe lists below do not care much about that, for now it is a hot mess\n, and it is up to you to properly calculate in carthesian or polar space.\n\nSometimes some notations/labels are more intuitive than others\nFor a simple start, we assert that \n- Time is scalar and measured in seconds=[s]\n- Time has only one dimension (at least true for past experiences)\n- - Otherwise causality is an [arbitiary field] and math of that gets a bit too [statistic]al\n;\nfor simpler syntax, we first to derive over [s] and label [Nth derivatives over s] as:\n[0th derivative of f(s)]= s =f(s)         =f   (s)=f0(s)=a.a=b.a=c.a\n[1th derivative of f(s)]=ds =f(s)*ds      =f'  (s)=f1(s)=a.b=b.b=c.b\n[2th derivative of f(s)]=ds²=f(s)*ds*ds   =f'' (s)=f2(s)=a.c=b.c=c.c\n[3th derivative of f(s)]=ds³=f(s)*ds*ds*ds=f'''(s)=f3(s)=a.d=b.d=c.d\nThe above may seem trivial, but this gets messy VERY fast\nto a point where you MUST know \n- how many derivatives a struct/function calculates\n- what derivative of what else you are currently looking at\n- what that value means in context to a unit of measure\n- what domain you derive over\n\nutility:\nwhile(we only derive over time|s (or over ONE space-domain) (up to 3 times)\n){//we can differentiate any TERM below (into an up to 3lines-Lower-TERM)\n ;//and then a higher-TERM can be used to [filter] a lower-TERM\n ;//  https://www.shadertoy.com/results?query=filter\n ;//this is done (without AD or calculus) in many shaders about motionBlur\n ;//  https://www.shadertoy.com/results?query=blur\n;}\n;\nITIT*==[double integral   over time   of[*]]\n  IT*==       [integral   over time   of[*]]\n  DT*==       [derivative over time   of[*]]\n  DL*==       [derivative over length of[*]]\n  RE*==                   [reciprocal of[*]]\n\n--- position|displacement-integrals (over time|s) are:  \n\nITITtime =1.*s*s*s //[double integral over time of [time]]\n  ITtime =1.*s*s   //       [integral over time of [time]]\n    time =1.*s     //                              [time]\n     unit=1.       //     [derivative over time of [time]]\nfrequency=1./s     //     [derivative over time of [unit]]            aka[becquerel] aka [[fluxion]==initially proposed term for [dt]]\n    phase=1./s/s   //     [derivative over time of [frequency]] ==IADMtesla aka[frequencyDrift] https://en.wikipedia.org/wiki/Instantaneous_phase\n  DTphase=1./s/s/s //     [derivative over time of [phase]]\n;\nsee: (Janzen et al. 2014) and:\nhttp://www.thespectrumofriemannium.com/2012/11/10/log053-derivatives-of-position/\n;\n(wave)length ==1.*m      //beware: [relativistic length-contraction]\n      Speed  ==1.*m/s    //beware: the [speed of information]==[speed of light]==min(AnySpeed,[speed of light]) \n;\nhttps://en.wikipedia.org/wiki/Velocity#Distinction_between_speed_and_velocity\n;\nlength|speed are implicitly scalar,single-dimensional; length(a)=sqrt(dot(a,a)) projections onto a single domain.\nbelow are implicitly defined as VECTORS, with more than 1domain (of space)\nlength-vector == Displacement|position\n speed-vector == Velocity\n- They include a relative direction; length()*(angles|UnitQuaternion)\n- They include all angular reference points\n- ,as a polar transformation implies 2 dimensions.\n- - linear/carthesian vectors are identified by starting with [ 1.*] or [ 1./]\n- - polar /complex    vectors are identified by starting with [rad*] or [rad/]\n- - - This often does NOT care wether you are in carthesian or polar coordinates (sometimes the labels are just mixed up)\n- - - sorry, this first version of the list likely mixes terms that are not to be mixed into the same context/bucket.\n- This is quite a messy collection of many nouns, some contexts are lost, some identities are typos.\n- They include all issues of periodic/circular displacement\n- ,where you can do a lot of work, and can end up exactly where you started, plus some entropy\n- - https://en.wikipedia.org/wiki/Directional_derivative#Normal_derivative\n;\n      “farness”=1.*m*s*s*s*s*s*s*s*s*s*s*s*s\n         absput=1.*m*s*s*s*s*s*s*s*s*s*s*s\n         abshot=1.*m*s*s*s*s*s*s*s*s*s*s\n         absrop=1.*m*s*s*s*s*s*s*s*s*s\n         absock=1.*m*s*s*s*s*s*s*s*s\n          absop=1.*m*s*s*s*s*s*s*s\n      absrackle=1.*m*s*s*s*s*s*s\n       absounce=1.*m*s*s*s*s*s\n         abserk=1.*m*s*s*s*s\n   abseleration=1.*m*s*s*s\n         absity=1.*m*s*s \n       absement=1.*m*s        = [maintenance cost] of [long distance communication]\n   displacement=1.*m           //beware: [relativistic length-contraction]\n       velocity=1.*m/s\n  accelleration=1.*m/s/s\n           snap=1.*m/s/s/s        aka[jounce]\n        crackle=1.*m/s/s/s/s\n            pop=1.*m/s/s/s/s/s \n           lock=1.*m/s/s/s/s/s/s\n           drop=1.*m/s/s/s/s/s/s/s \n           shot=1.*m/s/s/s/s/s/s/s/s\n            put=1.*m/s/s/s/s/s/s/s/s/s\n    “swiftness”=1.*m/s/s/s/s/s/s/s/s/s/s\n;\n[Reciprocals of position/displacement] and their time integrals.\n- Integrals of reciprocal displacement over time measure “nearness”.\n;\n     “nearness”=1./m*s*s*s*s*s*s*s*s*s*s*s*s\n        presput=1./m*s*s*s*s*s*s*s*s*s*s*s\n        preshot=1./m*s*s*s*s*s*s*s*s*s*s\n        presrop=1./m*s*s*s*s*s*s*s*s*s\n        presock=1./m*s*s*s*s*s*s*s*s\n         presop=1./m*s*s*s*s*s*s*s\n      presackle=1./m*s*s*s*s*s*s\n      presounce=1./m*s*s*s*s*s\n        preserk=1./m*s*s*s*s\n  preseleration=1./m*s*s*s\n        presity=1./m*s*s\n      presement=1./m*s\n      placement=1./m             ==REdisplacement\n     REvelocity=1./m/s         [velocity reciprocal]\nREaccelleration=1./m/s/s\n         REsnap=1./m/s/s/s \n;\n              ?=1.*g*m*s*s*s*s\n  spectralPower=1.*g*m*s*s*s\n              ?=1.*g*m*s*s \n              ?=1.*g*m*s\n              ?=1.*g*m\n        impulse=1.*g*m/s          aka[momentum]\n          force=1.*g*m/s/s        aka [weight,Newton,torque,action|actergy]\n           yank=1.*g*m/s/s/s      aka [Joule,NewtonMetre,linear work]\n            tug=1.*g*m/s/s/s/s    aka [linear power]\n         snatch=1.*g*m/s/s/s/s/s\n          shake=1.*g*m/s/s/s/s/s/s\n    “forceness”=1.*g*m/s/s/s/s/s/s/s\n;\nabove are \"real vectors\" of below \"pseudo vectors\"\nThe difference between [linear] and [angular] vector(derivative)s is a [coreolis effect]\n- commonly experienced as wind/twister/hurricanes/tensor\nrad=radians, where acos(-1.)*2.==1 full rotation indicate PolarCoordinates via c2p() transformation\nbeware, a [spinor] has a period of 2 full rotations\nbeware, below lists mix lot of things together, disregards coordinateSystem, as long as they have the same SI-derivative\n, which quite often may have some typos or OutOfContext errors.\n, you can just pretend that a straight vector is just a VERY large radius with a tiny angle.\nbeware, I confuse [nouns] for [nouns of quanitities], because i really do not care for now\n;\n    angularDisplacement=rad\n        angularVelocity=rad/s     [radial velocity],  [angular speed] is WRONG, because speed is only 1d!\n    angularAcceleration=rad/s/s\n            angularJerk=rad/s/s/s\n;\n                   area= 1.*m*m\nspecificAngularMomentum= 1.*m*m/s     [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n                   gray= 1.*m*m/s/s   aka [sievert]\n       absorbedDoseRate= 1.*m*m/s/s/s  \n;\n                   mass= 1.*g\n           massFlowRate= 1.*g/s\n         surfaceTension= 1.*g/s/s    aka [stiffness ,radiantExposure]\n               radiance= 1.*g/s/s/s  aka [irradiance, energyflux density,heat flux density]\n;\n         angularRotatum=rad*g*m*s*s*s    aka [spectralPower, spectral intensity]\n                Inertia=rad*g*m*m*s      \n        MomentOfInertia=rad*g*m*m        [action] https://en.wikipedia.org/wiki/Moment_of_inertia\n                   spin=rad*g*m*m/s      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\n          angularEnergy=rad*g*m*m/s/s    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n           angularPower=rad*g*m*m/s/s/s  [watt] [radiant  intensity]\n;\nangularMomentum|Impulse=rad*g*m/s \n      linearMassDensity=rad*g/m \n       dynamicViscosity=rad*g/m/s\n          energyDensity=rad*g/m/s/s     [pascal] ???\n           powerDensity=rad*g/m/s/s/s    aka: [spectral irradiance]\n;\n                coulomb= 1.*a*s\n                 charge= 1.*a\n                current= 1.*a/s\n;\n                  weber= 1./a*g*m*m/s/s\n                   volt= 1./a*g*m*m/s/s/s\n;\n                  henry= 1./a/a*g*m*m/s/s\n                    ohm= 1./a/a*g*m*m/s/s/s\n;\n                  farad= 1./g*a*a/m/m*s*s*s*s\n                siemens= 1./g*a*a/m/m*s*s*s\n;\n        compressibility= 1./g*m*s*s\n      DTcompressibility= 1./g*m*s\n;\n     ITspectralRadiance= 1.*g/m/s/s\n       spectralRadiance= 1.*g/m/s/s/s\n;\n                    mol= 1.*o\n                  katal= 1.*o/s\n;\n            molarVolume= 1./o*m*m*m\n    catalyticEfficiency= 1./o*m*m*m/s\n;\n                 volume= 1.*m*m*m\n     VolumetricFlowRate= 1.*m*m*m/s     //Rate of change of volume with respect to time \t\n\n\n/**/ //--- end__ AD-common-derivatives over time,dT,T^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over space|length,dL,L^(n-1)\n/*\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\nvolumetricFlowRate= 1./s*m*m*m\n         viscosity= 1./s*m*m   [diffusionCoefficient,specific energy,KinematicViscosity,Diffusivity,specific angular momentum]\n;\n  absorbedRoseRate= 1./s/s/s*m*m\nDLabsorbedRoseRate= 1./s/s/s*m\n;\n              gray= 1./s/s*m*m  =ILILphase  aka[sievert] \n            DLgray= 1./s/s*m    =  ILphase\n             phase= 1./s/s      =DLDLgray\n;\n                 ?= 1.*m*m*m*m*m\n       hyperVolume= 1.*m*m*m*m\n            volume= 1.*m*m*m\n              area= 1.*m*m\n      displacement= 1.*m    (displacement or SCALAR length)\n              unit= 1.\n         placement= 1./m    aka [curvature,wavenumber,opticalPower,spatialFrequency]\n            REarea= 1./m/m      //copied from stranger online places\n          REvolume= 1./m/m/m\n;\n   momentOfInertia= 1.*g*m*m \n                 ?= 1.*g*m\n              mass= 1.*g\n linearMassDensity= 1.*g/m\n;\n            ITArea= 1.*s*m*m\n          absement= 1.*s*m\n              time= 1.*s\n            DLtime= 1.*s/m  [reciprocal of velocity]\n;\n    angularRotatum= 1.*g/s/s/s*m\n   weber, radiance= 1.*g/s/s/s      aka[energy|heat flux density, irradiance,]\n  spectralRadiance= 1.*g/s/s/s/m    aka[spectral power]\n   radiantUntertua= 1.*g/s/s/s/m/m\n;\n              spin=rad*g/s*m*m [angular torque  |moment] [energy density] [action]\n   angularMomentum=rad*g/s*m   [angular Impulse]\n      massFlowRate=rad*g/s\n  dynamicViscosity=rad*g/s/m\n;\n     angularEnergy=rad*g/s/s*m*m   aka [specific energy] [spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                 ?=rad*g/s/s*m\n    SurfaceTension=rad*g/s/s       aka [spring constant, stiffness]\n;\n             joule= 1.*g/s/s*m*m\n           DLjoule= 1.*g/s/s*m\n   radiantExposure= 1.*g/s/s\n;\n       AreaDensity= 1.*g/m/m\n       Massdensity= 1.*g/m/m/m \n\n   MomentOfInertia= 1.*g*s*m*m\n DLMomentOfInertia= 1.*g*s*m\n\n    specificVolume= 1./g*m*m*m\n      specificArea= 1./g*m*m\n    DLspecificArea= 1./g*m\n\n   compressibility= 1./g*s*s*m\n DLcompressibility= 1./g*s*s\n\n    ILpowerDensity= 1.*g/s/s/s\n      powerDensity= 1.*g/s/s/s/m   aka: [spectral irradiance]\n;\n           ILILlux= steradian*cd\n             ILlux= steradian*cd/m\n               lux= steradian*cd/m/m\n\n\nfor relativistic stuff, use:\nhttps://en.wikipedia.org/wiki/Four-velocity\n\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dL,L^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mass,dM,M^(n-1)\n/*\n                 IMmass= 1.*g*g\n                   mass= 1.*g\n                   unit= 1.\n                 REmass= 1./g\n;\n               radiance= 1./s/s/s*g  aka[irradiance,weber,energy|heat flux density]\n                DTphase= 1./s/s/s    [derivative over time of [phase]]\n;\n         SurfaceTension= 1./s/s*g     aka [stiffness ,radiant exposure]==[integral of [tesla] over Ampere]\n                  Phase= 1./s/s       ==IADMtesla\n;\n           massFlowRate= 1./s*g\n              frequency= 1./s\n;\n                      ?= 1.*m*g\n           displacement= 1.*m\n;\n        momentOfInertia= 1.*m*m*g\n                   area= 1.*m*m\n;\n                 volume= 1.*m*m*m\n         specificvolume= 1.*m*m*m/g\n;\n                impulse= 1.*m/s*g       aka[momentum,dynamicViscosity]\n               velocity= 1.*m/s\n;\n                  force= 1.*m/s/s*g        aka [Newton,weight,action,actergy,torque]\n          accelleration= 1.*m/s/s\n;\n                   yank= 1.*m/s/s/s*g\n                   snap= 1.*m/s/s/s       aka[Jounce]\n;\n                    tug= 1.*m/s/s/s/s*g    aka [linear power]\n                crackle= 1.*m/s/s/s/s\n;\n                   spin= 1.*m*m/s*g      [diffusionCoefficient, specific energy,KinematicViscosity,Diffusivity]\nspecificAngularMomentum= 1.*m*m/s\n;\n          angularEnergy= 1.*m*m/s/s*g    [joule, work, heat, specific energy, spinConnection]  https://en.wikipedia.org/wiki/Spin_connection\n                   gray= 1.*m*m/s/s      [sievert]\n;\n                   watt= 1.*m*m/s/s/s*g   [angular power] [radiant  intensity]\n       absorbedDoseRate= 1.*m*m/s/s/s\n;\n                 absity= 1.*m*s*s \n        compressibility= 1.*m*s*s/g\n;\n           spectralPower=1.*m*s*s*s*g\n            abseleration=1.*m*s*s*s\n;\n                Inertia= 1.*m*m*s*g      https://en.wikipedia.org/wiki/Moment_of_inertia\n                 ITarea= 1.*m*m*s\n;\n      linearMassDensity= 1./m*g\n              placement= 1./m\n;\n       dynamicViscosity= 1./m/s*g\n             REvelocity= 1./m/s         [reciprocal of velocity]\n;\n          energyDensity= 1./m/s/s*g     [pascal] ???\n        REaccelleration= 1./m/s/s\n;\n           powerDensity= 1./m/s/s/s*g   aka: [spectral(Ir)Radiance|power|intensity,angularRotatum]\n                 REsnap= 1./m/s/s/s\n;\n        radiantUntertua= 1./m/m/s/s/s*g\n      DMradiantUntertua= 1./m/m/s/s/s*\n;\n            areaDensity= 1./m/m*g\n          REarea       = 1./m/m\n;\n            massDensity= 1./m/m/m*g\n               REvolume= 1./m/m/m\n;\n                   mole= 1.*o\n               molality= 1.*o/g  [==molarMassRec]\n;\n                 REmole= 1./o\n              molarMass= 1./o*g  [==molalityRec] \n;\n    molarHeatCapacityIN= 1./e*m*m/s/s*g   aka[molar entropy]\n  DMmolarHeatCapacityIN= 1./e*m*m/s/s\n\n\n\n\n/**/ //--- end__ AD-common-derivatives over mass,dM,M^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over ampere,dA,A^(n-1)\n/*\n\n          watt= 1.*g*m*m/s/s/s\n          volt= 1.*g*m*m/s/s/s/a\n           ohm= 1.*g*m*m/s/s/s/a/a\n;\n angularEnergy= 1.*g/s/s*m*m\n         weber= 1.*g/s/s*m*m/a\n         henry= 1.*g/s/s*m*m/a/a\n;\n     coulombIA= 1.*s*a*a\n       coulomb= 1.*s*a\n          Time= 1.*s\n;\n         farad= 1./g/m/m*s*s*s*s*a*a\n       DAfarad= 1./g/m/m*s*s*s*s*a\n     DADAfarad= 1./g/m/m*s*s*s*s\n;\n       siemens= 1./g/m/m*s*s*s*a*a\n     DAsiemens= 1./g/m/m*s*s*s*a\n;\n      TeslaRec= 1./g*s*s*a   //                [reciprocal of [tesla]]\n       PhaseDM= 1./g*s*s     // [derivative of [reciprocal of [tesla]] over mass] == PhaseDM == [derivative of [Phase] over mass]\n;\nSurfaceTension= 1.*g/s/s       aka [stiffness ,radiantExposure]==[integral of [tesla] over Ampere]\n         tesla= 1.*g/s/s/a\n       DAtesla= 1.*g/s/s/a/a\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dA,A^(n-1)\n     //\n/**/ //--- start AD-common-derivatives over mole,dN,N^(n-1)\n/*\n\nall terms that I find with an [o] for mOle in it, are in this section\neven if the derivative chains of it are short\nIn that case i derive my orn term with *D* or *I*\n\nmole              =1.*o\n;\n     Mass         =1.*g\nmolarMass         =1.*g/o  [molalityRec]\n;\nmolality          =1.*o/g  [molarMassRec]\n;\nmolarity          =1./m/m/m*o\nmolarityDN        =1./m/m/m      //its odd that we have no proper noun for this\n;\nangularEnergyIN    =1.*g*m*m/s/s*o\nangularEnergy      =1.*g*m*m/s/s\n  molarEnergy      =1.*g*m*m/s/s/o\n;\nmolarHeatCapacityIN=g/e*m*m/s/s\nmolarHeatCapacity  =g/e*m*m/s/s/o   aka[molar entropy]\n;\nINmolarConductivity=a*a/g*s*s*s\n  molarConductivity=a*a/g*s*s*s/o\n\n\n/**/ //--- end__ AD-common-derivatives over space|length,dN,N^(n-1)\n     //\n/**/ //--- start AD-demo\n/*\n\nAD converts ALL operands into their prefix-notation\nto be more monadic (output type of same functionName depends on input type)\nand most common functions are crunched into 2-glyph-initials:\nc=   a+   b*pow(c,d) \n      ==\nc=ad(a,mu(b,po(c,d)))\n      ==\nc=po(c,d);c=mu(c,b);c=ad(c,a)\n\ngoodbye to the infix_notation with [+*-/%^] operands\nand replace it with a proper prefix_notation, like writing in Lisp.:\nhttps://en.wikipedia.org/wiki/Polish_notation\n\n//and then it gets more and more tricky: \n// Chain rule Derivative of dot() appears tricky: this should work, untested:\nd2 dotd(c2 a, c2 b){d2 t0=mu(a.x,b.x),t1=mu(a.y,b.y),t2=mu(a.z,b.z); \n return ad(ad(t0,t1),t2);}\n\n/**/\n\n//using the above, we define distance functions \n//...that automatically also return the gradient at [p].\n//the gradient is multiple first derivatives along multiple domains\n//... like Dfdx() and Dfdy(), and we also have Dfdz()...\n//... except much cheaper, due to many things canceling out each other.\n//This makes surfaces that are C0-discontinuous, like y=fract(x), \n//...at least have their first derivate calculated continuously,\n//... as long as they are C1-continuous,\n//which can be useful for raymarching:\n             \n//A more readable version of a very parametric implicit surface.\n//...that does not look as much like LISP code, but at its core is just like that.\n//One operation per line keeps it BASIC and modifiable.\nd2 sdSuperPrim(c2 p, v3 s,v1 r\n){//v1 r=v1(.2,.5);\n  //v3 s=v3(1.5,.5,1.5,.5);\n  //v3 dx,dy,dz,d,e,f,q,a,b,c;\n  //dy=v3(0);dz=v3(0);d=v3(0);\n  //e=v3(0);f=v3(0);q=v3(0);\n  //a=v3(0);b=v3(0);c=v3(0);\n ;d2 dx=suab(p.x,s.x)\n ;d2 dy=suab(p.y,s.y)\n ;d2 dz=suab(p.z,s.z)\n ;d2 d=ad(dx,r.x);d=ma(d,0.)\n ;d2 e=ad(dy,r.x);e=ma(e,0.)\n ;d2 q=sd(d,e)\n ;d2 f=ma(dx,dy);f=mi(-r.x,f)\n ;q=ad(q,f)\n ;q=ad(q,s.w)\n ;q=ab(q)\n ;q=su(q,s.w)\n ;///return...\n ;d2 a=ad(q ,r.y);a=ma(a,0.)\n ;d2 b=ad(dz,r.y);b=ma(b,0.);a=sd(a,b)\n ;d2 c=mi(-r.y,ma(q,dz));c=ad(a,c)\n ;return c;}\n\n//getfactor() cycles trough example input parameters for sdSuperprim() \n#define SHAPE_COUNT 10.0\nvoid getfactor (int i,out v3 s,out v1 r\n){     if(i==0){s=v3(1)           ;r=v1(0)     ;//cube\n }else if(i==1){s=v3(v2(1),.25)   ;r=v1(0)     ;//corridor\n }else if(i==2){s=v3(v2(1),.25)   ;r=v1(1)     ;//pipe\n }else if(i==3){s=v3(1)           ;r=v1(1,0)   ;//cylinder\n }else if(i==4){s=v3(1,1,2,1)     ;r=v1(1)     ;//pill\n }else if(i==5){s=v3(1)           ;r=v1(1)     ;//sphere\n }else if(i==6){s=v3(1,1,.25,1)   ;r=v1(1,.25) ;//pellet\n }else if(i==7){s=v3(1,1,.25,.25) ;r=v1(1,.25) ;//torus\n }else if(i==8){s=v3(2,.5,.25,.25);r=v1(.5,.25);//sausage mouth\n }else if(i==9){s=v3(.7,1,1,.25)  ;r=v1(.125)  ;//beveled O\n}}//  https://www.shadertoy.com/results?query=superprim\n            \n\n\n#define ss01(a) smoothstep(0.,1.,a) \n#define imsc(a) int(mod(a,SHAPE_COUNT))\n\nstruct DAMValue{d2 d;v0 m;};//to paint the gradient on a plane.\nDAMValue min2(DAMValue a, DAMValue b){if(a.d.a>b.d.a)return b;return a;}\nDAMValue plane(c2 p){return DAMValue(ad(p.y,1.),1.);}\n//DAMValue add_plane(DAv2 p,DAMValue m){return min2(plane(p),m);}\n//return distance to surface of DistanceField\n\n\n\nDAMValue df(c2 p\n){d2 D\n ;v0 t=iTime//u=ss01(ss01(fract(t)))\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount,0.)+.5)/iResolution.xy).y  \n //p.x.a=point.x\n //p.y.a=point.y\n //p.z.a=point.z\n //p.w.a=point.w\n //p.x.a=1\n //p.y.b=1\n //p.z.c=1\n //p.w.d=1\n //all other.b are ==0\n #ifndef SuperPrim\n //simpler more static parametric surfaces\n ;//m.x=cos(iTime)*r.x\n     \n ;//if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)*r.xy;} \n ;D=sdGoursat(p,r,m)\n     //aBool(p)\n ;//r=fSphere(p)\n ;//r=fBox(p,v2(1))\n ;//r=fBoxCheap(p,v2(1))\n ;//v0 holesize=mix(.6,5.,sin(iTime*3.)*.5+.5)\n ;//d2 s=fSphere(mu(p,v2(holesize)))\n ;//r=ma(r,ne(s))//nope way too bad lipschitz, got to fix this shit!\n //scaling by holesize is bad for lipschitz constant.\n #else\n //superprim() is a very parametric implicit surface.\n ;v3 a,b,c,d;v1 e,f,g,h\n     \n     \n ;getfactor(imsc(t   ),a,e);getfactor(imsc(t+1.),b,f)//params for superprim0\n ;getfactor(imsc(t+2.),c,g);getfactor(imsc(t+3.),d,h)//params for superprim1\n ;v0 v=ss01(fract(t))\n ;a=mix(a,b,v);e=mix(e,f,v)//params for superprim0\n ;c=mix(c,d,v);g=mix(g,h,v)//params for superprim1\n //above getfacvtor sets v3 a,b and v1 c,d into a cyclic mix\n //below overwrites these parameters with iUI data  \n//#define bufDrag(x) texture(iDiegeticUI,(v1(x,0.)+.5)/iResolution.xy)\n  \n ;v1 sdUberprimZ=v1(cos(iTime)*.5)\n //UIdots overwrite superprim params             \n ;if(pointCount>1.){a.xy=(fra(t,bufDrag(+1.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>2.){a.zw=(fra(t,bufDrag(+2.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>3.){e.xy=(fra(t,bufDrag(+3.).xy,r,m)*viewzoom*2.+1.);} \n  //above is 6 params for superprim0, below is 6 params for superprim1\n ;if(pointCount>4.){c.xy=(fra(t,bufDrag(+4.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>5.){c.zw=(fra(t,bufDrag(+5.).xy,r,m)*viewzoom*2.+1.);} \n ;if(pointCount>6.){g.xy=(fra(t,bufDrag(+6.).xy,r,m)*viewzoom*2.+1.);}\n                    //below are 2 more params for offset and CSGunion\n ;v3 o=v3(1,2,1,.3)//offset of one of the shapes  and .z uis Union-parameter\n ;if(pointCount>7.){o.xy=(fra(t,bufDrag(+7.).xy,r,m)*viewzoom*2.+1.);}\n ;if(pointCount>8.){v1 O=(fra(t,bufDrag(+8.).xy,r,m)*viewzoom*2.+1.)\n     ;o.zw=O.xy;}\n ;if(pointCount>10.){sdUberprimZ=(fra(t,bufDrag(+10.).xy,r,m)*viewzoom*2.+1.);}\n\n ;//debug corner cases\n  /* ;a.x=1. ;a.y=1. ;a.z=1.*/\n    \n ;//struct for AD, 2 points to 2 shapes.\n ;c2 q=c2(   su(p.y,0.)     ,   p.z     ,   p.x     )\n ;c2 Q=c2(su(p.x,o.y),su(p.y,o.z),su(p.z,o.x))//offset and swivel\n  \n     \n  \n  // a,c: (width, height, depth, thickness)\n  // e,g: (xy corner radius, z corner radius, bottom radius offset (sdUberprim Only))\n ;D     =sdSuperPrim(q,a,e)//superprim0 \n\n ;\n ;d2 box=sdUberprim(Q,c,v2(g,sdUberprimZ.x))\n ;//d2 box=sdSuperPrim(Q,c,g)//superprim1\n ;//box=su(box,o.w)//use o.w to offset shape thickness.\n     \n     //fBoxCheap(su(p,v2(-1.,1,-.5)),v2(.61))\n ;//p=su(p,v2(-1,1,1))//p.x=addd(p.x,1.);p.y=subd(p.y,1.);p.z=subd(p.z,1.);\n ;//D=box2=fBox(p,v2(1))\n ;//D=mind(box,box2);//(box or     box2)\n ;//D=maxd(box,box2);//(box and     box2)\n ;//D=maxd(box,-box2);//(box and not box2)\n ;D=fOpUnionRound(D,box,o.w*3.)\n ;//D=fOpIntersectionRound(box,box2,o.w)\n ;//D=fOpDifferenceRound(box,box2,o.w)\n ;//D=box   \n ;//v0 holesize=mix(2.5,.97,sin(iTime*3.)*.5+.5)//damn i made reciprocal hole size\n ;//d2 s=di(((fSphere(mu(mi(p,v2(.5,.61,-.4)),v2(holesize))))),holesize)\n ;//D=ma(D,ne(s))  //hole(unionround())==bad lipschitz!\n \n     \n  ;if(pointCount>9.){m.xy=(fra(t,bufDrag(+9.).xy,r,m)*viewzoom*2.+1.)\n                    ;m.x=1.-m.x\n                    ;v0 scaleT=1./.5\n                    ;v2 o=v2(sdUberprimZ.y+1.,0,-3)/scaleT\n                    ;p=su(p,o) //yep. the offset must be scaled,too\n                    ;c2 q=c2(   p.y ,   p.z  ,  p.x  )\n                        \n                    ;//q=ad(q,v2(sdUberprimZ.y))\n                  \n                    ;q=mu(p,scaleT)\n  \n                    ;d2 G=sdGoursat(q,m)\n                    ;G.a*=scaleT\n                    ;D=fOpUnionRound(D,G,m.y)\n                     ;}\n /**/     \n #endif\n ;//return DAMValue(r,0.);\n ;return min2(plane(p),DAMValue(D,0.));}\n\n\n\n\n\n\n//return distance & materialID\nv1 dm(v2 p){DAMValue d=df(da_domain1(p));return v1(d.d.a,d.m);}\n//return material at p with normal n\nv3 material(v2 p,v2 n ){d2 d=df(da_domain1(v2(p.x,0.,p.z))).d\n ;return mix(v3(n*.5+.5,.1)\n            ,v3(d.b*.5 +.5,.0)*abs(mod(d.a,.1)/.1-.5)\n            ,sat(dm(p).y));} \n\n//return soft shadow of light source at [o], \n//... with light direction [i] pointing from [o] to surface point [p]\nv0 shadow(v2 o,v2 i\n){const v0 a=32.//shadow hardnes\n ;v0 r=1.,h =1.,t=.0005//t=(self)intersection avoidance distance\n ;const v0 it=clamp(IterSh,0.,64.)\n ;for(v0 j=0.;j<it;j++\n ){h=dm(o+i*t).x\n  ;r=min(r,h*a/t)\n  ;t+=clamp(h,.02,2.);}//limit max and min stepping distances\n ;return clamp(r,0.,1.);}\n//iquilezles.org/articles/rmshadows\n\n//return p, modified by light , shadow, envMap...\nv2 light(v2 p,v2 n,v2 i,v0 d,v3 m\n){v2 l=normalize(v2(1.,.7,.9))//light direction\n ;v0 o=max(0.,dot(n,l))\n ,c=max(0.,dot(n,normalize(l-i)))\n ,s;if(c>.01)s=shadow(p+.01*n,l)\n ;const v2 LigCol=v2(1.)//light color\n ;v2 r=m.rgb*(LigCol+o*v2(.8,.7,.6)*s*3.+v2(.2,.3,.3))\n ;r+=s*c*pow(o,40.)//specular\n ;//r+=m.x*texture(iChannel0, reflect(i,n)).rgb;//environment map\n ;r*=exp(-.01*d*d)//fog  \n ;return r;}\n\n//return distance along ray (raymarch till surface)\nv0 rm(v2 o,v2 i\n){const v0 m=20.//distance.Max\n ;v0 e=.0,h=e,t=0.//intersection.precission\n ;const v0 irm=clamp(IterRm,1.,256.)\n ;for(v0 j=0.;j<irm;j++\n ){if(h<e)break;if(t>m)return -1.\n  ;//wait a moment, do i not have the lipschitz for the point\n  ;//or at least 3 for 3 domains of the point, by using [AD]?\n  ;//i mean, i could really insert this here, right?\n  ;//and substitute ReciprocalAbsLipschitz with \"1/da_length(dm(o+i*t).yzw)\"\n  ;//i am pretty sure that i am missing a dotproduct here\n  ;//the gradient must be dorproducted onto the ray direction?\n  ;//above is as old as AD26, late 2017 stuff\n  ;//2019 comment: oh hey, abvoe line almost described [drungFluttershy] marching.\n  ;DAMValue s=df(da_domain1(o+i*t))\n  ;v0 r=ReciprocalAbsLipschitz\n  ;//r=1./length(dot(s.d.yzw,i));//overwriting with a VERY LOCAL lipschitz constant\n  ;//its not a good estimate, but it is a LOT better?\n  ;//nah it totally fails for concave isosurfaces.\n  ;h=s.d.a*r;t+=h;}return t;}\n \n  //return camera matrix\n  mat3 calcLookAtMatrix(in v2 o,in v2 i,in v0 r ){\n   v2 w=normalize(i-o);v2 u=normalize(cross(w,v2(sin(r),cos(r),0.)) );\n   return mat3(u,normalize(cross(u,w)),w);} \n\n//return surface normal\nv2 getDt1(in v2 p){DAMValue d=df(da_domain1(p));return d.d.b;}\n //d.d.d stores the first derivatives on the 3 domains, (is also an awesopme pointer label)\n //this is equivalent to the gradient at p.\n //If (p is near a surface) the gradient is a surface normal\n //d.d.* addresses a v3. where *.yzw==gradient\n //d.m.* addresses a material\n//#elif (domains==1||domains==3)\n //is a lot like \n //  https://www.shadertoy.com/view/XdffzB\n\n//draw ripples on a plane:\nd0 getd(v0 u){return ad(ab(D0(u)),si(D0(u)));}\n//f(x) = abs(x)+sin(x) = add(abs(x),sin(x))\n\n//set camera position & target\n//first rotate around vertical axis bny t\n//then loop up/down by m\nvoid setCam(out v2 o,out v2 i,v0 t,v0 m\n){\n o=v2(4.*sin(t),m*9.-2.,4.*cos(t));i=v2(0);}\n                               \nv3 in3d(v0 t,v1 u,v2 r,v3 m\n){\n ;v1 v=(u   -r.xy*.5)/r.y\n ;v3 n=v3((m.xy-r.xy*.5)/r.y,(m.zw-r.xy*.5)/r.y)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;v1 zo=v1(t,cos(t)*.5+.5)\n ;if(pointCount >0.//this point sets camera parameters (2 angles)\n ){zo=v1(fra(t,bufDrag(0.).xy,r,n))\n  ;zo=v1(-zo.x*acos(-1.)*2.,cos(clamp(zo.y*2.-1.,-1.65,1.)))//bufDrag(+0.).xy\n ;}\n ;u=(-iResolution.xy+2.*u.xy)/iResolution.y\n ;//v1 zo=v1(iMouse.xy/iResolution.xy)  //mouse\n ;v2 o,i,c=v2(0)\n ;setCam(o,i,zo.x,zo.y+.2)//camMovement\n ;v2 d=normalize(calcLookAtMatrix(o,i,camRoll)*v2(u.xy,camLens))//ray.direction\n ;v0 T=rm(o,d)//Distance.raymarched\n ;if(T>-.5\n ){v2 p=o+T*d,n=getDt1(p)//position & normal\n  ;v3 ma=material(p,n)  //material\n  ;c=light(p,n,d,T,ma);}  //light\n ;c=ff_filmic_gamma3(c*.6)//gamma\n ;//c=pow( clamp(col,0.0,1.0), v2(0.4545) )\n ;return v3(c,1.);}                          \n                                    \n//v3 in2d(v1 u){}   got a bit meessy and its 2 \"scenes\"                        \n//seperated into \n// v3 ovalEyes(v1 u,v0 h,v0 g){     //version 026    \n//and\n//linearGraph(v1 u,v0 h,v0 g){      //version 025\n                                    \n                                    \n \n//2d domain space parent: https://www.shadertoy.com/view/XdffzB        \nv3 ovalEyes(v1 u,v0 h,v0 g\n){v1 m=fra(iTime,iMouse.xy,iResolution.xyz,iMouse)\n ;m*=9.\n ;m=abs(m)\n ;m=1./m\n ;//https://www.shadertoy.com/view/MdfGWn    (derivative ellipse approximation)\n ;//... coverted to derivative arithmetic. \n ;//it think it can be more than a approximation, by using more than 1 domain.\n ;//but how?\n ;c1 f=da_domain1(u)\n ;f=mu(f,m)\n ;f.x=sd(f)//so, we completely distegard one of 2 domains here?\n ;//like we project doen to -1 dimension within a torus, 2 times?\n ;//above (and below) line is like u.x=length(u)-1;\n ;//i am pretty sure, utilizing the other domain will fix a lot of stuff!\n ;f.x=su(f.x,1.)   \n //#define FilledEllipse\n #ifndef FilledEllipse\n  ;f.x=ab(f.x)//makes ellipse ring instead of filled ellipse\n #endif\n ;v0 outlineThickness=iResolution.y*.5\n ;v0 i=length(v1(f.x.b.x,f.x.b.y)*outlineThickness)\n ;//this looks kina nead like \"Fxdx()\", but it is more misleading than anything?\n ;v0 ellipseBorderThickness=(sin(iTime)*.5+.5)*9.;//=0.01\n ;v0 blur=20./max(iResolution.y,1.)\n ;//v0 r=1.-f.x.x\n ;v0 r=ssb2(ellipseBorderThickness,f.x.a*iResolution.y/i)\n ;//v3 yellow =v3(v2(1,1,0),r)\n ;//v3 yellow =v3(v2(1,1,0),ssb(1.-r*iResolution.y/i))\n ;v3 yellow =v3(v2(1,1,0),1.-ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;//v0 b=0.;//no magenta here//v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(yellow,cyan);}\n\n\nv3 linearGraph(v1 u,v0 h,v0 g\n){d0 d=getd(u.x)\n ;//v0 div=sqrt(1.+p.y*p.y)\n ;v0 r=abs(d.a-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;d=getd(u.x)\n ;//no analytical 2nd derivative, so this one sucks a bit\n ;v0 b=abs(d.b-u.y)/(sqrt(1.+d.b*d.b))-thick\n ;//this does not work for scaled p, is far from being user friendly\n ;v0 blur=20./max(iResolution.y,1.)\n ;v3 yellow =v3(v2(1,1,0),ssb(r))\n ;v3 cyan   =v3(v2(0,1,1),ssb(g))\n ;v3 magenta=v3(v2(1,0,1),ssb(b))\n ;return aOverB(aOverB(yellow,magenta),cyan);}\n \n v3 in2d(v0 t,v1 u,v2 r,v3 m\n ){u=fra(t,u,r,m)\n  ;u*=9.\n  ;v1 f=abs(fract(u));//green carthesian grid   \n  v0 h=abs(fract(length(u)+thick)-thick);//green polar circles\n  v0 g=min(min(f.x,f.y),h);\n  return ovalEyes(u,h,g);\n  return linearGraph(u,h,g);\n }\n\n v3 in1d(v1 u){return v3(0);}\n\n                               \n//demoIKBezier is now a dreidelDebugger for iDiegeticUI                        \nv3 demoIkBezier(v0 t,v1 u,v2 r,v3 m//define bezier by start,eng,Arclength\n){v3 c=v3(1)\n ;u   =viewzoom*(u   -r.xy*.5)/r.y\n ;m.xy=viewzoom*(m.xy-r.xy*.5)/r.y\n ;v1 p0=v1(-.4)\n ;v1 l0=v1( .7)\n ;v1 l1=v1(.5,-.5)\n ;//v1 r1=v1(.5,-.1)\n ;v0 pointCount=texture(iDiegeticUI,(v1(maxCount, 0.)+.5)/iResolution.xy).y\n ;if(pointCount >0.\n ){p0=fra(t,bufDrag(+0.).xy,r,m)*viewzoom\n ;}\n ;if(pointCount >1.//point4 sets one point of the red/yellow arc\n ){l0=fra(t,bufDrag(+1.).xy,r,m)*viewzoom\n ;}  \n ;if(pointCount >2.//point4 sets one point of the red/yellow arc\n ){l1=fra(t,bufDrag(+2.).xy,r,m)*viewzoom\n ;} \n ;v0 d=segment(p0,l0,l1)*2.     //distance of p3 to line segment\n ;if(length(l0-l1)>d)l1=l0+d*normalize(l1-l0)\n ;c.z=segment(u,l0,l1)//vis blue line segment\n ;v1 p11=knee(l0,l1,d)//red dot is knee \n ;v1 p10=project(p0-l0,l1-l0)+l0\n ;c.x=length(u-p11)-.04\n ;c.x=min(c.x,segment(u,p10,p0))\n ;c.y=BezierQuad(u,l0,p11,l1)\n ;c.x=abs(c.x)-.01 \n ;c.y-=.02\n ;c.z=abs(c.z-.05)-.02\n ;c=mix(smoothstep(c.xyzw,-c.xyzw,vec4(viewzoom/Aa(t,u,r,m))),fract(c.xyzw*9.),.2)\n ;//c.xy+=c.w*.2//fold w as yellow\n ;c=pdOver(pdOver(v3(1,0,0,1)*c.x,v3(0,1,0,1)*c.y)\n          ,pdOver(v3(0,0,1,1)*c.z,v3(1,1,0,0)*c.w))\n ;return c\n ;}\n                               \nvoid mainImage( out v3 O,in v1 u\n){v0 t=iTime\n ;v2 r=iResolution.xyz\n ;v3 m=iMouse.xyzw\n    \n #if (scene==3)\n ;O=mix(in3d(t,u,r,m),in2d(t,u,r,m),.1)\n #elif (scene==2)\n ;O=in3d(t,u,r,m)\n #elif (scene==1)\n ;O=in2d(t,u,r,m)\n #elif (scene==0)\n ;O=in1d(t,u,r,m)\n #endif \n    \n ;//O=demoIkBezier     (iTime,u,iResolution,iMouse)\n ;}\n\n//my todo_list;\n//todo, find aliases for common operations, and debug them.\n//I suspect that modulo and 2d rotation seem buggy.\n//\n//todo, merge with hg_sdf, full set\n//to have hg_sdf with first derivatives, in 2 or 3 domains.\n//it already poited at my lack of competence to substitute correctly\n//-> lots of small errors.\n//\n//done, looking good enough:\n//\n//fSphere()\n//fRay() (infinite line segment with radius 1)\n//fBox()\n//fBoxCheap()\n//\n//mind() maxd() unions of 2 distance fields (Boolean AND, boolean OR)\n//fOpUnionRound()\n//fOpIntersectionRound()\n//fOpDifferenceRound()\n//\n//I failed at:\n//fOp*Columns\n//fOP*Staircase\n//\n//memo:  https://en.wikipedia.org/wiki/PID_controller\n//- is [[weighted sum of [2 (or more) derivatives]] in a feedback loop]\n//- application is [cruise control] and [music instruments]\n//\n//todo pModd() , will likely hint me at how to fix stuff.\n//\n//todo: include complex plane transformation math of\n//  https://www.shadertoy.com/view/ls2cDt\n//for anything \"Cauchy\"\n//  https://en.wikipedia.org/wiki/Complex_analysis\n//  https://en.wikipedia.org/wiki/Augustin-Louis_Cauchy\n//\n//todo, antialiasing, merger with: https://www.shadertoy.com/view/MdXczr\n//todo: https://en.wikipedia.org/wiki/Quaternionic_analysis\n//todo, curvature stuff, because I want a minimal surface !\n\n\n/**/ //--- start AD-memo todo rant\n/*\n\ntodo, copy   https://www.shadertoy.com/view/MdsBRX\n\nAD26 cleanup 2019-04 is the version where i renamed [length] to [sd]\n\nmemo of a timeless issue:\nfunctions are never (to be) named by the input types (a lesson to learn from noise libraries)\nfunctions are named by output types                  (a lesson to learn from noise libraries)\nproblem of AD is that it is monadic, input types define poutput types:\nv0 si(v0 a)  //must be a thing\nvi si(v0 a)  //must be a thing\nvi si(d0 a)  //must be a thing\n->\nv0 si(d0 a)  //must NEVER be a thing, instead call;  si(D0(a))\n//lets just not do the above\n//and instead imply\nv0 si(D0(a)) \n\nrants:\nExplicit structure \n- adds simplifying symmetry\n- confuses, mostly due to its atomic defines, and counting from 0.\n- creates \"permutation hell\", as usual.\n- does not slow down performance\n\nThis defines implicit 3d Surfaces, or 2d curves, \n... with ChainRule automatic differentiation Arithmetic, \nThis inevitably makes you write in prefixNotation, like Lisp source code.\nsurely this would look much better in Lisp than in Webgl\nStill waiting for the Lisp gpu API, and openCL or CUDA are not my thing!\n... there is \"harlan\" for inspiration, but it is a 2007 non-api thing...\n\n\n/**/ //--- end__ AD-memo todo rant\n\n\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//[RE]= [Relativity Engine] v6\n\n//parent  RE7 : https://www.shadertoy.com/view/tlf3zj    (BayesianEpsilon targetFPS)\n\nvec4 Get(float a\n){return texture(iRe,vec2(varWdth*.5+a*varWdth,.5)/iResolution.xy);}\n\nfloat keyDif(vec2 a){a/=255.\n ;return texture(iChannel1,vec2(a.x,.2)).x\n        -texture(iChannel1,vec2(a.y,.2)).x;}\n\n\nbool Proc(float c,float d,float w){return(abs(d-c*w-.5*w)*2.<w);}\n/*\nbool Processing(float c, float d\n){//float a=d-c*varWdth\n ;//float b=varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (abs(d-c*varWdth-.5*varWdth)*2.<varWdth)//(0.<a&&a<b)\n ;}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingold(float c, float d\n){float a=d-c*varWdth\n ;float b=(c*varWdth+varWdth)-c*varWdth//(c+1.)*varWdth-c*varWdth\n ;return  (0.<a&&a<b);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)\nbool Processingolderstill(float c, float d\n){return  (d-c*varWdth>0.)\n        &&(d-c*varWdth<(c+1.)*varWdth-c*varWdth);}\n//(0.<a&&a<b)==(abs(a-.5*b)*2.<b)*/\nbool ProcessingOldest(float a, float pos\n){return  (pos>a*varWdth)        //-a*varWdth\n        &&(pos<(a+1.)*varWdth);} //-a*varWdth\n\n\n\nvoid mainImage( out vec4 o, in vec2 u\n){if(u.y>1.||u.x>varWdth*10.\n ){o=vec4(0.);return;}\n ;pos = Get(RePos).xyz\n ;dpos = Get(RePosD).xyz\n ;vec4 quat = Get(ReQua)\n ;vec4 dquat = Get(ReQuaD)\n ;float time = Get(ReTime).x\n ;float deltaT = min(0.1,iTimeDelta)\n ;float plf = LorentzFactor(length(dpos))\n ;time += deltaT* mix(1.,plf,TimeDilation)\n ;SetTime(time)\n ;ProcessCamPos(pos,quat)\n ;mat3 m=mat3(1)\n ;vec3 acc=vec3(0)\n ,right  =qr(quat,m[0])\n ,up     =qr(quat,m[1])\n ,forward=qr(quat,m[2])\n ,velDir = normalize(dpos)\n ;vec4 normDist = GetNormal(pos+vec3(0.,-2.,0.))\n ;vec3 norm = normDist.xyz\n ;float proxAlert = normDist.a\n ;//grav += normalize(norm-grav) * iTimeDelta\n ;//collisions\n ;float collisionViolence = dot(velDir,-norm)\n ;vec2 e=vec2(.002,0)\n ,pitchYaw = Get(ReCamR).xy\n ,joystick=(iMouse.xy-iMouse.zw)/iResolution.yy\n ;if(iMouse.x == 0. && iMouse.y == 0.)joystick *= 0.\n ;joystick*=max(1.,joystick.x)\n ;joystick*=8.\n ;if(iMouse.z <= 0.)joystick = vec2(0)\n ;pitchYaw += joystick*deltaT\n ;pitchYaw.y = clamp(pitchYaw.y,-pi*.45,pi*.45)\n ;quat = aa2q(pitchYaw.x,vec3(0,1,0))\n ;right =qr(quat,vec3(1.,0.,0.))\n ;quat = qm(aa2q(-pitchYaw.y,right),quat)\n ;//quat = MulQuat(aa2q(-deltaT*joystick.x,forward),quat)\n ;vec3 groundForwardDir = cross(right,vec3(0,1,0))\n //;float thurst=keyDif(vec2(KEY_E,KEY_D)) \n// ;float strafe=keyDif(vec2(KEY_F,KEY_S))\n ;acc+=keyDif(vec2(KEY_E,KEY_D))*groundForwardDir*thrustForce\n ;acc+=keyDif(vec2(KEY_F,KEY_S))*right*thrustForce\n ;if(length(acc)>thrustForce)acc=normalize(acc)*thrustForce\n ;acc+= gravity;// * abs(dot(norm,forward));   //gravity\n ;acc-=(dpos/maxSpeed)*thrustForce  //drag\n ;//add acceleration\n ;//dpos +=  deltaT*acc\n ;dpos +=  (deltaT*acc);///(plf*plf);\n ;//properDpos += (deltaT*acc)/(plf*plf);\n ;if(length(dpos)>maxSpeed)dpos=normalize(dpos)*0.999*maxSpeed\n ;if(proxAlert <=0.\n ){//if (collisionViolence > 0.)\n  ;//dpos = reflect(dpos,norm)/(collisionViolence*10.+1.);\n  ;dpos.y =0.\n  ;//pos.y=0.\n  ;//pos  =vec3(0.,0.,-4.)\n  ;}\n ;vec4 wallCollision = GetNormal(pos)\n ;//velDir = normalize(dpos)\n ;//nosefall/stall\n ;//quat=MulQuat(BuildQuat(cross(forward,velDir),length(velDir-forward)*deltaT),quat)\n ;//add derivatives\n ;pos+=deltaT*dpos*mix(1.,plf,TimeDilation)\n ;if(wallCollision.w<.5\n ){dpos.xz-=max(0.,dot(dpos.xz,-wallCollision.xz))*dpos.xz\n  ;pos.xz+=(wallCollision.xz)*(.5-wallCollision.w);}\n ;if (iFrame == 0\n ){dpos=vec3(0)\n  ;pos =vec3(0,0,-4.)\n  ;quat=vec4(0,0,0,1)//BuildQuat(vec3(1.,0.,0.),1.57)\n  ;}\n ;float v=u.x    \n ;float w=varWdth\n ;if(Proc(RePos         ,v,w))o=vec4(pos,1.)\n ;if(Proc(RePosD       ,v,w))o=vec4(dpos,1.)\n ;if(Proc(ReQua        ,v,w))o=vec4(quat)\n ;if(Proc(ReQuaD      ,v,w))o=vec4(dquat)\n ;if(Proc(RePosDD      ,v,w))o=vec4(acc,1.)\n ;if(Proc(ReTime        ,v,w))o=vec4(time)\n ;if(Proc(ReCol   ,v,w))o=vec4(proxAlert)\n ;if(Proc(ReCamR,v,w))o=vec4(pitchYaw,0,0);\n    \n}", "buffer_c_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "//iTR  TemporalReprojection\n\n// almost entirely:\n// Created by inigo quilez - iq/2018\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// made more compativle by ollj\n// [compatible v4]\n\n//ichan0=wood\n//ichan1=self C (optional for blur instead of celshaded black outlines)\n//ichan3=void\n//ichan3=self C\n//other ichannels may cause silly artefacts (ppixels with 0-vallues seem to create nans, that then make white dots in dark areas)\n\n/*\nmade (more) gles100 compatible\n(i hope i did not forget anything important)\n\n- all lops are complete forLoops\n- all loops have constant max iteration count\n- no ivec*\n- no bitwise operands\n- dualFunctionEd\n- - no texelFetch() \n- - no silly Array stuff \n- - int sign(int a)\n- - int abs(int a)\n- did not add tons of global runtime variables ;)\n- did not add [/*\"] after [#]\n- A lot of code looks 15 years dumber now.\n\n*/\n\n\n#define NUMBOXES 22\n\n//vec4 tf0(vec2 b,vec3 r){return tf(iChannel0,b,r);}\n//vec4 tf1(vec2 b,vec3 r){return tf(iChannel1,b,r);}\n//vec4 tf2(vec2 b,vec3 r){return tf(iChannel2,b,r);}\nvec4 tf3(vec2 b,vec3 r){return tf(iChannel3,b,r);}\n\n//#if 1\n#if VER <300\n//7 are manually placed\nvec3 size7(int i\n){if(i==1)return vec3(10.5,0.1,10.5)\n ;if(i==3)return vec3(10.5,7.5, 0.1)\n ;if(i==5)return vec3(10.5,7.5, 0.1)\n ;if(i==7)return vec3( 0.1,7.5,10.5)\n ;if(i==9)return vec3( 0.1,7.5,10.5)\n ;if(i==11)return vec3( 4.0,0.1,10.5)\n ;return         vec3( 4.0,0.1,10.5);}\nvec3 pos7(int i){\n ;if(i==0)return vec3( 0)\n ;if(i==2)return vec3(  0, 0,-10)\n ;if(i==4)return vec3(  0, 0, 10)\n ;if(i==6)return vec3( 10, 0,  0)\n ;if(i==8)return vec3(-10, 0,  0)\n ;if(i==10)return vec3( -7,-7,  0)\n ;return  vec3(  7,-7,  0);}\nvoid getLocation(int i, out mat4 resMat, out vec3 resSiz\n){if(i<7\n ){resMat = translate( pos7(i*2))\n  ;resSiz = size7(i*2+1)\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(i*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(i*43,i*23,i*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n\n#else\n//7 are manually placed\nconst vec3 possiz[14] = vec3[14](\n    vec3(  0, 0,  0), vec3(10.5,0.1,10.5),\n    vec3(  0, 0,-10), vec3(10.5,7.5, 0.1),\n    vec3(  0, 0, 10), vec3(10.5,7.5, 0.1),\n    vec3( 10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3(-10, 0,  0), vec3( 0.1,7.5,10.5),\n    vec3( -7,-7,  0), vec3( 4.0,0.1,10.5),\n    vec3(  7,-7,  0), vec3( 4.0,0.1,10.5));\nvoid getLocation(int id, out mat4 resMat, out vec3 resSiz\n){if(id<7\n ){resMat = translate( possiz[2*id+0] )\n  ;resSiz = possiz[2*id+1]\n ;}else{\n  ;resMat = rotationAxisAngle(vec3(0.3,0.4,0.5)*1.41421, -float(id*13))* translate(vec3(0.0,-2.5,0.0)-vec3(5.0,2.0,5.0)*sin(vec3(id*43,id*23,id*137)));\n  ;resSiz = vec3(1.1,1.6,0.08);}}\n#endif\n\nfloat fhash1(float n \n){float a=(sqrt(5.)*.5+.5) //golden ratio is sufficient here.\n ;a=n*a\n ;a=abs(a)\n ;return fract(a);}\n\n    \nint ihash1(int n \n){//return 0\n /*\n ;float a=(sqrt(5.)*.5+.5)//golden ratio is NOT good here\n ;a*float(n)*a\n ;return int(fract(a)*pow(2.,22.))\n /**/\n ;float f=float(n)\n ;f =f*pow(2.,13.)// (n << 13) \n //f=f^ n  //not good/compatible/fast, but also really not essential.\n ;n=int(f)\n ;n=n*(n*n* 15731+789221)+1376312589 \n ;n=abs(n)\n ;return n//its a hack, but its close enough to the original.\n /**/\n ;}\n\n//hash2() is completely taken apart, or replaced by a fibonaciSphere\n\n#define cs(a) vec2(cos(a),sin(a))\n#define sr1m(a) sqrt(1.-(a)*(a))\n//return point[k] of a fibonacciSphere with [n] equidistributed points\n//divides by [n] and squares the result, [n] should not be too large, or we lose too much precision\nvec3 fibSphereKthOfNpoints(float k,float n  //0<=k<=n!=0 ;k-bounds are implied geometrically.\n){if(n==0.)n=1.//worksafe\n ;float x=((k*2.+1.)/n)-1.\n ;return vec3(cs(k*pi*(3.-sqrt(5.)))*sr1m(x),x);//poles of HairyBallProblem are along x-axis!\n ;}//https://stackoverflow.com/questions/9600801/evenly-distributing-n-points-on-a-sphere/44164075#44164075\nvec3 uniformVector(int seed\n){const float points=pow(2.,22.)  //[machineEpsilon]=pow(2.,-23)\n ;float f=fhash1(float(seed))\n ;return fibSphereKthOfNpoints(mod(f,points),points);}\n\n//the last remaining hash2() subroutine call is deconstructzed in here:\nvec3 cosineDirection(int seed, in vec3 nor\n){seed=seed*7+11\n ;int n=int(seed)    \n ;float f=float(n)*pow(2.,13.)\n ;//n = int(f)^n //original integer hash used a mask, but thats slow in glES100, and its fine without mask.\n ;n=n*(n*n*15731+789221)+1376312589\n ;int nx=n*n\n ;int ny=n*n*16807\n ;nx=abs(nx)\n ;ny=abs(nx)\n ;vec2 r=vec2(nx,ny)\n  ;r=r/float(0x7fffffff)\n    //;vec2 r = hash2( seed);\n    // by fizzer: http://www.amietia.com/lambertnotangent.html\n    ;float a = 6.2831853 * r.y;\n    float u = 2.0*r.x - 1.0;\n    return normalize( nor + vec3(sqrt(1.0-u*u) * vec2(cos(a), sin(a)), u) );\n}\n\nfloat iBox(vec3 ro,vec3 rd,mat4 txx,vec3 rad\n){// convert from ray to box space\n ;vec3 rdd = (txx*vec4(rd,0.0)).xyz\n ;vec3 roo = (txx*vec4(ro,1.0)).xyz\n ;// ray-box intersection in box space\n ;vec3 m = 1.0/rdd\n ;vec3 n = m*roo\n ;vec3 k = abs(m)*rad\n ;vec3 t1 = -n - k\n ;vec3 t2 = -n + k\n ;float tN = max( max( t1.x, t1.y ), t1.z )\n ;float tF = min( min( t2.x, t2.y ), t2.z )\n ;if( tN > tF || tF < 0.0) tN = -1.0\n ;return tN;}\n\n// returns normal, st and face\nvoid nBox(vec3 o,vec3 d,mat4 txx,mat4 txi,vec3 rad//rayorigin,raydirection\n         ,out vec3 outNor,out vec2 outST,out int outFaceID\n){// convert from ray to box space\n ;vec3 rdd=(txx*vec4(d,0.0)).xyz\n ;vec3 roo=(txx*vec4(o,1.0)).xyz\n ;// intersect and select\n ;vec3 s=-sign(rdd)\n ;vec3 t=(-roo+s*rad)/rdd\n ;// compute normal in world space\n ;      if(t.x>t.y&&t.x>t.z){outNor=txi[0].xyz*s.x;outST=roo.yz+rdd.yz*t.x;outFaceID=int(1+int(s.x))/2 // 0, 1\n ;}else if(t.y>t.z)         {outNor=txi[1].xyz*s.y;outST=roo.zx+rdd.zx*t.y;outFaceID=int(5+int(s.y))/2 // 2, 3 \n ;}else                     {outNor=txi[2].xyz*s.z;outST=roo.xy+rdd.xy*t.z;outFaceID=int(9+int(s.z))/2 // 4, 5 \n ;}}\n\n\n\n\n\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oNor, out vec2 oUV, out int oID\n){float tmi = 1e20\n ;mat4  cma\n ;vec3  csi\n ;int  cin = 0xffffffff\n ;for( int i=0; i<NUMBOXES; i++   //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;float res = iBox( ro, rd, ma, si )\n  ;if( res>0.0 && res<tmi\n  ){cma = ma\n   ;csi = si\n   ;cin = i\n   ;tmi = res\n ;}}\n ;int resID\n ;nBox( ro, rd, cma, inverse(cma), csi, oNor, oUV, resID )\n ;oID = cin*6 + resID\n ;return (cin==0xffffffff) ? -1.0 : tmi;}\n\nfloat castShadowRay(vec3 ro,vec3 rd\n){for( int i=0; i<NUMBOXES; i++ //es100 safe\n ){mat4 ma; vec3 si; getLocation(i, ma, si)\n  ;if(iBox(ro,rd,ma,si)>0.)return 0.;}\n ;return 1.;}\n\nmat3 setCamera(vec3 o,vec3 d, float t//origin,target,time\n){d=normalize(d-o)\n ;o=normalize(cross(d,vec3(sin(t),cos(t),0.)))\n ;return mat3(o,cross(o,d),-d);}\n\nvec3 sphereMap(vec3 d){return vec3(.3,.4,1.2);}    \n\nvoid light1(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int k,int bounce, int sa,float epsilon){\n   ;vec3 sunCol =  vec3(1.7,0.8,0.6)*10.0; \n   ;vec3 sunDir = normalize(vec3(0.5,0.9,-0.2));\n   ;vec3 ssundir = normalize(sunDir+.01*uniformVector(sa + 11 + 45*(bounce+11*k)))\n   ;float sunDif =  max(0.0, dot(ssundir, nor))\n   ;float sunSha = 1.0; if( sunDif > 0.00001 ) sunSha = castShadowRay( pos + nor*epsilon, ssundir)\n   ;iColor += sunCol * sunDif * sunSha\n   ;vec3 h = normalize( sunDir - rd )\n   ;float shl = 0.04 + 0.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n   ;float spe = tex.x*30.0*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n   ;iColor += spe * shl * sunCol * sunSha * sunDif\n   ;}\nvoid light2(inout vec3 iColor,vec3 pos,vec3 nor,vec3 rd,vec3 tex,int sa,int k,int bounce,float epsilon){\n//;for( int i=min(0,iFrame); i<2; i++ //not es100 safe\n ;for( int i=0;i<2;i++// es100 safe\n ){//if(iFrame>1)break//i see no difference in this es100 save line\n  ;vec3 skyPoint=cosineDirection((sa+7*int(iFrame)+47*(k)+13*int(i)+bounce*92),nor)\n  ;float skySha = castShadowRay( pos + nor*epsilon, skyPoint)\n  ;vec3  skyCol = sphereMap(skyPoint)\n  ;iColor += skyCol * skySha / 2.0\n  ;vec3 h = normalize( skyPoint - rd )\n  ;float shl=.04+.96*pow( 1.0-clamp(dot(h,-rd),0.0,1.0), 5.0 )\n  ;float spe=tex.x*250.*pow( clamp( dot( nor, h ), 0.0, 1.0 ), 24.0*tex.x )\n  ;iColor+=spe*shl*skyCol*skySha/2.;};}\n\nvec4 render( in vec3 ro, in vec3 rd, int sa, out int oID\n){const float epsilon = 0.001\n ;vec3 colorMask = vec3(1.0)\n ;vec3 accumulatedColor = vec3(0.0)\n ;vec3 oro = ro\n ;vec3 ord = rd\n ;oID = NUMBOXES+10\n ;float fdis = 0.\n ;const int numRays = 4\n ;for( int k=0; k<numRays; k++ //es100 safe\n ){ro=oro\n  ;rd=ord\n  ;colorMask = vec3(1.0)\n  ;for(int bounce=0;bounce<3;bounce++ //es100 safe // bounces of GI\n  ){vec3 nor\n   ;vec2 st\n   ;int id\n   ;float t=castRay( ro, rd, nor, st, id )\n   ;if( t < 0.\n   ){if( k==0 && bounce==0\n    ){accumulatedColor=sphereMap(rd)*float(numRays)*pi\n     ;oID=NUMBOXES+10\n     ;fdis = 1000.\n    ;}break;}\n   ;int obj = id/6\n   ;vec3 pos = ro + rd*t\n   ;if(k==0&&bounce==0){fdis=t;oID =id;}\n   ;int kid=id/6\n   ;vec3 surfaceColor=vec3(.4)\n   ;vec3 tex = texture(iChannel0, st.yx*0.3 ).xyz\n   ;if( kid>=1 && kid<=4) tex = texture( iChannel0, st*0.2 ).xyz*vec3(0.7,0.8,0.8)\n   ;surfaceColor *= tex\n   ;//direct lighitng\n   ;colorMask *= surfaceColor\n   ;vec3 iColor=vec3(0)\n   #if 1\n   ;light1(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   #if 1\n   ;light2(iColor,pos,nor,rd,tex,sa,k,bounce,epsilon)\n   #endif\n   ;accumulatedColor += colorMask * iColor\n   ;// calculate new ray\n   ;float isDif = 0.8\n   ;if(fhash1(float(sa + 1 + 7*bounce + 91*k + 31*int(iFrame))) < isDif\n   ){rd = cosineDirection((76 + 73*(bounce+5*k) + sa + 17*int(iFrame)), nor)\n   ;}else{\n    ;float glossiness = 0.4\n    ;rd = normalize(reflect(rd, nor)) + uniformVector(sa + 111 + 65*(bounce+7*k)+87*int(iFrame)) * glossiness\n    ;}\n   ;ro = pos + epsilon*nor;}}\n ;accumulatedColor /= float(numRays)\n ;return vec4( clamp(accumulatedColor,0.,10.),fdis );}\n\nvec3 getVofM(mat3 a,int b){//return a[b]\n ;if(b==2)return a[2]\n ;if(b==1)return a[1]\n ;return a[0];}\n\n     \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord\n){\n #ifndef SceneTR\n ;fragColor=vec4(1);return\n #endif\n ;vec3 r=iResolution.xyz\n ;vec2 off=vec2(0)\n ;//off=(hash2(int(iFrame))-.5)*5.\n ;vec2 p = (2.*(fragCoord+off)-r.xy)/r.y\n ;int sa = ihash1( int(iFrame)*11 + int(fragCoord.x) + int(fragCoord.y)*113 )\n ;float time = -2.0 + (iTime-10.0)*0.03    // camera movement\n ;float cr = 0.1*cos(0.1)\n ;vec3 ro = vec3(8.0*cos(time), 1.0, 8.0*sin(time) )\n ;vec3 ta = vec3(0.0,3.0,0.0)\n ;float fl = 1.8\n ;mat3 cam = setCamera( ro, ta, cr )\n ;vec3 rd = normalize( cam * vec3(p,-fl) )\n ;int id\n ;vec4 ren=render(ro,rd,sa,id)\n ;vec3 c=ren.xyz\n ;float t=ren.w\n ;// reproject from previous frame and average\n ;mat4 oldCam=mat4(tf3(vec2(0,0),r)\n                  ,tf3(vec2(1,0),r)\n                  ,tf3(vec2(2,0),r),0,0,0,1)\n ;vec4 wpos=vec4(ro + rd*t,1.0)    // world space\n ;vec3 cpos=(wpos*oldCam).xyz;  // camera space note inverse multiply\n ;vec2 npos=-fl * cpos.xy / cpos.z  // ndc space\n ;vec2 spos=.5+.5*npos*vec2(r.y/r.x,1.)   // screen space\n ;spos-=off/r.xy //undo dither\n ;vec2 rpos = spos * r.xy - .5// raster space\n ;vec2 ipos=vec2(floor(rpos))\n ;if( (ipos.y>0. || ipos.x>2.) && iFrame>0\n ){// blend pixel color history\n  #if 1\n  ;vec2 fuv=rpos-vec2(ipos)\n  ;vec4 odata1=tf3(ipos,r)\n  ;vec4 odata2=tf3(ipos+vec2(1,0),r)\n  ;vec4 odata3=tf3(ipos+vec2(0,1),r)\n  ;vec4 odata4=tf3(ipos+vec2(1.),r)\n  ;vec4 ocol=vec4(0)\n  ;int n=0\n  ;if(id==int(odata1.w)){ocol+=vec4(odata1.xyz,1.)*(1.-fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata2.w)){ocol+=vec4(odata2.xyz,1.)*(   fuv.x)*(1.-fuv.y);n++;}\n  ;if(id==int(odata3.w)){ocol+=vec4(odata3.xyz,1.)*(1.-fuv.x)*(   fuv.y);n++;}\n  ;if(id==int(odata4.w)){ocol+=vec4(odata4.xyz,1.)*(   fuv.x)*(   fuv.y);n++;}\n  ;if(n>2)c=mix(max(ocol.xyz/ocol.w,0.),c,.1\n );else   c=mix(textureLod(iChannel1, spos,0.).xyz,c,.3)\n  #else\n  ;col=mix(textureLod(iChannel1,spos,0.).xyz,col,.1)\n  #endif\n  ;}\n ;vec2 ifc = vec2(floor(fragCoord))\n ;vec3 s=getVofM(cam,int(vec2(floor(fragCoord)).x))\n ;if( ifc.y==0. && ifc.x<=2.)fragColor=vec4(s,-dot(s,ro))\n ;else                       fragColor=vec4(c,id);}\n\n", "buffer_d_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define ST struct\n#define norma normalize\n#define m1 mat2\n#define m2 mat3\n#define m3 mat4\n#define i0 int\n#define i1 ivec2\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\nstruct v00{v0 a;v0 b;};\nstruct v11{v1 a;v1 b;};\nstruct v22{v2 a;v2 b;};//for 2 domains(density/distance field)\nstruct v33{v3 a;v3 b;};\nstruct v111{v1 a;v1 b;v1 c;};\nstruct v222{v2 a;v2 b;v2 c;};\nstruct v333{v3 a;v3 b;v3 c;};//for 3 domains(density/distance field); also used by DA,but as bridge to non-DA.\nstruct v2222{v2 a;v2 b;v2 c;v2 d;};\nv111 g111(v22 a){return v111(vec2(a.a.x,a.b.x),vec2(a.a.y,a.b.y),vec2(a.a.z,a.b.z));}\nv2222 muv(v2222 a,vec4 b){return v2222(a.a*b.x,a.b*b.y,a.c*b.z,a.d*b.w);}\nv22 g22(vec2 a){return v22(vec3(a.x),vec3(a.y));}\n\n#define phi (sqrt(5.)*.5+.5)\n\n\n/**///--start: iDiegeticUI v2:\n/*\nself  : https://www.shadertoy.com/view/WtfGDM\nparent: https://www.shadertoy.com/view/Xt3BzX (multiple dots smoothened compositing)\nparent: https://www.shadertoy.com/view/XttBRB (multiple dots smoothened)\nparent: https://www.shadertoy.com/view/4dtSRn (multiple dots)\nparent: https://www.shadertoy.com/view/MdKGRw (ui widgeds)\nreusable drag and drop framework. \n- Drag objects around by clicking on them.\n- Add new objects by clicking in space.\n- Delete objects by dragging them to the red square.\n\n/*\nmodifiables for diecetic_UI_2\nare used by the buffer [iDiegeticUI]\n*/\nconst v0 maxCount = 128.;//large numbers are fine.\n#define  UiDotBorder 1. //dot outline thickness\nconst v0 UiDotRadius = 10.;\n#define clickPointRadius UiDotRadius\nconst v0 statePos  = maxCount;\nconst v0 offsetPos = maxCount + 1.;\nconst v3 deleteRect=v3(0.,0.,40.,40.);\n\n/**///--end__: iDiegeticUI v2:\n/**///--\n/**///--start: iChannel-Buffer-pattern\n\n/*\n//Scene2D just shows a 3d scene of brush strokes: https://www.shadertoy.com/view/ltj3Wc\n#define Scene2D\n\n//else, there are 2 3d scenes:\n#ifndef Scene2D\n //[temporal reprojection] makes (even moving) images better over time, but it is a slow process.\n #define SceneTR\n#endif\n*/\n//do TemporalReprojection (slow brdf code and a fullscreen buffer that is slow, even while it is not visible)\n//#define SceneTR\n//disaabled while it keeps crashing the parser iff i run all code at once.\n//yay, reaching a limit is fun!\n\n//memo, make SceneTR faster, by diminishing brdf complexits, reflectionCount or whatever.\n\n#define kifsFungusIter 13\n#define kifsFungusSeed .55\n\n/**/ // start: shadertoy-iChannel-pattern\n/* \nThis amalgation uses the shadertoy-iChannel-pattern:\na-abcd,b-abcd,c-abcd,d-abcd,i-abcd\nUnless a an unnecessary pointer is changed to something more important\n- like KeyboarIn, CubeMapA, a staric distanceField to Glyphs, or a blueNoise Texture.\nthe ichannels of all frasmeBuffers are identical:\niChannel0<-BuffA\niChannel1<-BuffB\niChannel2<-BuffC\niChannel3<-BuffD\nTo have [plugin]s that are rarely more than 1 iChannel FrameBuffer\n[plugin] names are like iChannels, because thats what they point to.\nThis stucture lets me define global modifiable buffer pointers \nfor a plugin-HotSwap option\nwith #ifdef iDiegeticUI contexts for missing-plugin cases:\nEach [plugin] is one seperate FrameBufferObject, summarizing what they buffer:\niDiegeticUI, a lot of object parameters, to be drag and droppable, currently just 2d points.\niAD        , no DoubleBuffer, functions cannot read buffers from commonTab (shadertoy is a bit suilly here)\niCanBez    , no DoubleBuffer, this is the final composite out.\n*/\n/*\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iVoid0      iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n*/\n#define iDiegeticUI iChannel0\n#define iAD         iChannel1\n#define iRe         iChannel2\n#define iVoid1      iChannel3\n#define iCanBez     ImageMain\n#define bufDrag(x) texture(iDiegeticUI,(vec2(x,0.)+.5)/iResolution.xy)\n\n/**///--end__: iChannel-Buffer-pattern\n/**///--\n/**///--start: compatibilityCore \n\n#define tiny .00001\n#define pib acos(0.)\n#define pi acos(-1.)\n#define tau (pi*2.)\n#define sat(x)clamp(x,0.,1.)\n#define u2(a) su(mu(a,2.),1.)\n#define u5(a) su(mu(a,.5),.5)\n#define u5cos(a) (u5(cos(a))\n//below is needed for old code, that i failed to update so that su() and mu() work on the right inpout types.\n#define u5cos2(a) ((cos(a))*.5+.5)\n//#define cosu5(a) u5(co(a))\n//divide 1./Aa == hairlineDrawing or sharpBokeh: b=smoothstep(1./Aa,-1./Aa,b)\n#define Aa(t,u,r,m) (min(r.x,r.y)/viewZoom(t,u,r,m))\n//fta insists on TURM-parameters because it contains Viewzoom(), that (locally) insists on TURM\n#define fra(t,u,r,m) (u-.5*r.xy)*viewZoom(t,u,r,m)/(r.y)\n\n/*\nself  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\nparent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\nvery common subroutines|aliases assert:\n- structure aliases listed below, where:\n- - Array index starts with 0:\n- - - f(x,y)=x*y  ;has [x} as its [0th parameter] and [y] as its [1th parameter]\n- - - A formulaOne race car has 0 drivers and 3 tires\n- - - The fastest racer of a race always achieves 0th place of a race\n- - - 2-dimensional spacetime (minkovski diagram) has 0 time domains and 2 space domains\n- - - the length of an array is equal to the position of its last entry\nv*   = linear matrix = vector  with [*]         fields\nm*   = square matrix           with [*]-squared fields\nd*** = single variate calculus over [*] domains down to [tally of *] derivatives\nC*** = multivatiate   calculus over [*] domains down to [tally of *] derivatives\n[tally of *] == [stick counting], in a base1System\n- https://en.wikipedia.org/wiki/Unary_numeral_system\n- https://en.wikipedia.org/wiki/Repdigit\n/**/\n\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\nconst vec3 vs=vec3(-1,0,1);\nv1 perp(v1 a){return a.yx*vs.xz;}\nv1 perp2(v1 a,v1 b){return vec2(a.x*b.y,-a.y*b.x);}\n//http://mathworld.wolfram.com/PerpDotProduct.html\nv0 perpdot(v1 a,v1 b){return dot(perp(a),b);}//==determinant(mat2(a,b)),aka cross2(),for also being the crossproduct()of a mat2.\n\n//every 2d determinant has a perpendicular dotproduct\n\n//nul function is needed for cases, where the same function is defined 2 times\n//eg: once with sat and once without sat (with nul instead of with sat) => difference between segment() and line()\n#define nUl(b) b nul(b a){return a;}\nnUl(v0)\nnUl(v1)\nnUl(v2)\nnUl(v3)\n    \n/**/ // start: compatibilityCore \n//self  : https://www.shadertoy.com/view/wlf3RB   (compatible v4)\n//parent: https://www.shadertoy.com/view/Xd2fzR   (less compatible)\n//for a global manual override\n//cannot define any namespace with dual undersore, -> fatal error\n#define VER __VERSION__\n//#define VER 100  //webGl1==openGlEs100\n//#define VER 300  //webGl2==openGlES300\n//there may be some smaller values, labeled \"experimental*\"\n//therefore we only care if (VER <300)\n#if VER <300\n//outerproduct is glES300 exclusive\nm2 outerProduct(v2 a,v2 b){return m2(a*b.x,a*b.y,a*b.z);}//i may have swapped a and b wrongly here.\n//sign(int) is gles300 exclusive\ni0 sign(i0 a){return i0(sign(v0(a)));}\n//abs(int) is gles300 exclusive\ni0 abs(i0 a){return (a)*sign(a);}\n//texelFetch() uses gles300 exclusive ivec2, substituting with texture(,(vec2()*.5)/iResolution.xy)\nv3 tf(sampler2D a,v1 b,v2 r){return texture(a,(b+.5)/r.xy) ;}\n#else\nv3 tf(sampler2D a,v1 b,v2 r){return texelFetch(a,i1(b),0) ;}\n#endif\n\n/**///--end__: compatibilityCore\n/**///--\n/**///--start: openGl NaN-precision\n/*\nexponent ==255 is reserved for Inf and NaN\nmantissa ==0   is   is Inf*(signBit*2-1)\nmantissa !=0        is NaN //(sign is irrelevant in opengl)\nNaN implies that you got too close to an asymptote\nsome languages use different NaN mantissas to differentiate between types/signs of asymptotes\nopengl is not such a language. All opengl NaN are created #.\n\n32bit signed float bounds: //calculated with win7 64bit calculator:\nLargest  positive  2.-pow(2.,-23.)*pow(2., 127.)==3.4028234663852885981170418348451e38\nSmallest positive    normal        pow(2.,-126.)==1.1754943508222875079687365372222e-38\nSmallest positive subnormal        pow(2.,-150.)==7.0000000000000000000000000000000e-46 \nSmallest negative           = -1*(1+.5+.25+.125+...+ pow(2,-23)*pow(2.^127.)\n                           ~=-pow(2,128) //sum rounds up to 2. in the given precision?\n                            =-3.403e38\nlargest negative normal     =-pow(2.,-127.) //safe assertion???\n//useless for calculations with any predictive property.\n\n#define exp2(a) pow(2.,a) [2<<a]\nhttps://en.wikipedia.org/wiki/Machine_epsilon\ngives an upper bound on the relative rounding error in floating point arithmetic\nmake [exponent] SMALLER, to make [epsilon] larger\n*/\n#define Exponent floor(8. )  //comment values are for exponent=8.\n#define Mantissa floor(23.)  //comment values are for mantissa=23.\nconst v0 mEpsilon   =exp2(-Mantissa);//=1.1920928955078125000000000000000e-7\nconst v0 mEpsilonRec=exp2(+Mantissa);//=8388608.;  \nconst v0  epsilon   =exp2(-Mantissa+Exponent);//=0.000030517578125 ==pow(2.,-23.+8.)\nconst v0  epsilonRec=exp2(+Mantissa-Exponent);//=32768.=mEpsilonRec/pow(2.,8.)=pow(2.,23.-8.)\n#define zFar epsilonRec\n//abs(safeInt)==v0(i0(abs(safeInt)))\nconst v0  safeInt   =exp2(+Mantissa+max(Exponent,8.));//=2147483648.=8388608.*pow(2.,8.)\nconst v0  safeIntRec=exp2(-Mantissa-max(Exponent,8.));//=4.656612873077392578125e-10 ;\n#undef Exponent\n#undef Mantissa\n\n/**///--end__: openGl NaN-precision\n/**///--\n/**///--start: AD structure\n/*\na [derivative of f(t)] == [instantaneous rate of change over of f(t) t]\n[derivative of [absememt(t)]] == [[distance(t)]]\n[derivative of [distance(t)]] == [[speed(t)]]\n[derivative of [speed(t)]]    == [[acceleration]]\n\nThis CommonTab valculatesthe 3rd derivative of a v3 trough many functions:\ndata types that start with [d*] imply Automatic Differentiation\nfunctions  that start with [D*] imply explicit typecasting to type [d*]\n\na. == first parameter, , ends up being OuterFunction,dividend\nb. == second parameter , ends up being innerFunction,divisor\nc. == third parameter  , ends up being interpolant\n...\n.a==0th derivative\n.b==1th derivative\n.c==2th derivative\n.d==3th derivative\n...\nforeach derivative we use either type; v0, or v1 ,or v2 ,or v3\ndepending on how many dimensions the function/isoline/isosurface/isovolume has:\n[d*  ]dt =+1th derivative\n[d** ]dt²=+2th derivative (and dt)\n[d***]dt³=+3th derivative (and dt adnd dt²)\n[*N*] sets number of domains|dimensions to differentiate over (in parallel)\n      these are commonly orthogonal domains of space.xyzw\n(number of N) in [dN**] sets how many differentials we want to calculate\n     a 1st derivative is rather simple to get\n,but a 2nd derivative usually implies ProductRule or QuotientRule\n,and a 3rd derivative has diminished utility with recursive complexity (productRules of productRules)\n,and a 4th derivative is not even attempted (except for simple identities?)\n\nstruct d(v0 a;);//just use v0 instead of a [d]  struct\nthe whole DA set is pretty consistent, and i tried domain/ds the other way around and that sucked.\nthe first value is a float, because thats what the function returns, a length.\nAND most shapes apply the same functions to a value (no branching, all domains are NOT independent functionWise)\nbut many functions over 2d or 3d should be independent, and can be branching!\n...as a result, the d*** structs are nonsense, and i may need a BIG rewrite.\n\nso, what we may utilize here (to format an UV.xyz to give to any distanceField) is something like:\nc22 da_domain2(v2 p){return c22\n (d22(p.x,v2(1,0,0),v2(1,0,0))\n ,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n ,d22(p.y,v2(0,0,1),v2(0,0,1)));}\n//so the c22 struct first seperates by number of domains, seperating into 3 sub scructs, one foreach domain.\n//each derivative VECTOR has as many domains as the whole struct.\n//i actually wonder, WHY this is not always a type float.\n*/\nST   d0  {v0   a;v0   b              ;};//1 domains t,dt\nST   d00 {v0   a;v0   b;v0   c       ;};//1 domains t,dt,dt²\nST   d000{v0   a;v0   b;v0   c;v0   d;};//1 domains t,dt,dt²,dt³ \nST   d1  {v0   a;v1   b              ;};//2 domains t,dt\nST   d11 {v0   a;v1   b;v1   c       ;};//2 domains t,dt,dt²\nST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³ \nST   d2  {v0   a;v2   b              ;};//3 domains t,dt\nST   d22 {v0   a;v2   b;v2   c       ;};//3 domains t,dt,dt²   \nST   d222{v0   a;v2   b;v2   c;v2   d;};//3 domains t,dt,dt²,dt³ \nST   d3  {v0   a;v3   b              ;};//4 domains t,dt\nST   d33 {v0   a;v3   b;v3   c       ;};//4 domains t,dt,dt²\nST   d333{v0   a;v3   b;v3   c;v3   d;};//4 domains t,dt,dt²,dt³\n//the dNULLss can be cast invo v-s and back\nd000 D000(v3   a){return d000(a.x,a.y,a.z,a.w);}\nv3     V3(d000 a){return   v3(a.a,a.b,a.c,a.d);}\nd00   D00(v2   a){return d00(a.x,a.y,a.z);}\nv2     V2(d000 a){return  v2(a.a,a.b,a.c);}\nd0     D0(v1   a){return d0(a.x,a.y);}\nv1     V1(d00  a){return v1(a.a,a.b);}\n//above is sub-struct of below\n//, you may want to read the below before the above!\n//the c* structs are used by the uv inputs, c2 is for 3d, with 1 derivative\n//a distance field is itterated over by: DAMValue s=df(da_domain1(o+i*t))\nST c0  {d0   x                     ;};//1 domains t,dt\nST c00 {d00  x                     ;};//1 domains t,dt,dt²\nST c000{d000 x                     ;};//1 domains t,dt²dt³ \nST c1  {d1   x;d1   y              ;};//2 domains t,dt    \nST c11 {d11  x;d11  y              ;};//2 domains t,dt,dt² \nST c111{d111 x;d111 y              ;};//2 domains t,dt,dt²dt³ \nST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\nST c22 {d22  x;d22  y;d22  z       ;};//3 domains t,dt,dt² \nST c222{d222 x;d222 y;d222 z       ;};//3 domains t,dt,dt²dt³  \nST c3  {d3   x;d3   y;d3   z;d3   w;};//4 domains t,dt\nST c33 {d33  x;d33  y;d33  z;d33  w;};//4 domains t,dt,dt²   \nST c333{d333 x;d333 y;d333 z;d333 w;};//4 domains t,dt,dt²,dt³  \n//above structure may be inefficient, but its user friendlyness first\n//I tried many other structures for AD, this one still wins\n//the weirdness, that the first value is always a float, is based on the output of the function, with a scalar distance\n\n//data types that start with [d*] imply [automatic differentiation]\n//functions  that start with [D*] imply explicit typecasting to type [d*]\n//- ALL typecasting just fills voids with zeroes\n//- this may often not do what you want it to do\nv1 V1(v0 a){return v1(a,0);}\nv2 V2(v0 a){return v2(a,0,0);}\nv3 V3(v0 a){return v3(a,0,0,0);}\n//v2 V2(v1 a){return v2(a,0);}//what to put in .z here? .x or .y or.0?\nv2 V3(v1 a){return v2(a,0);}\nd0 D0(v0 a){return d0(a,0.);}\nd1 D1(v0 a){return d1(a,v1(0));}\nd2 D2(v0 a){return d2(a,v2(0));}\nd1 D1(d0 a){return d1(a.a,V1(a.b));}\nd2 D2(d0 a){return d2(a.a,v2(a.b,0,0));}\nd2 D2(d1 a){return d2(a.a,v2(a.b,0));}\nd3 D3(d0 a){return d3(a.a,v3(a.b,0,0,0));}\nd00 D00(v0 a){return d00(a,0.,0.);}\nd11 D11(v0 a){return d11(a,v1(0),v1(0));}\nd22 D22(v0 a){return d22(a,v2(0),v2(0));}\nd33 D33(v0 a){return d33(a,v3(0),v3(0));}\nd000 D000(v0 a){return d000(a,0.,0.,0.);}\nd111 D111(v0 a){return d111(a,v1(0),v1(0),v1(0));}\nd222 D222(v0 a){return d222(a,v2(0),v2(0),v2(0));}\nd333 D333(v0 a){return d333(a,v3(0),v3(0),v3(0));}\n//struct ADm2{v2 a;v2 b;v2 c;v2 d;};//for 3 domains (density/distance field)\n\n//a=0th derivative (point in 3d space)\n//b=1st derivative over 3 domains\n//c=2md derivative over 3 domains\n//d=3rd derivative over 3 domains\n\n//The 3 (or 2) dimensions|domains \n//...are resolved with [struct cN{}] and [da_domain(vN  p)]:\n//where N=number of domains, range [0..3]\n\n//the da_domain*() functions orhtogonally proiject the derivatives onto an matrix.\n//the inpput point o is spread among as many d*** structs as there are domains.\nc000 da_domain3(v0 p){return c000\n(d000(p,1.,1.,1.));}//3 derivatives over 1d\nc111 da_domain3(v1 p){return c111\n(d111(p.x,v1(1,0),v1(1,0),v1(1,0))//3 derivatives over 2d\n,d111(p.y,v1(0,1),v1(0,1),v1(0,1)));}\nc222 da_domain3(v2 p){return c222\n(d222(p.x,v2(1,0,0),v2(1,0,0),v2(1,0,0))\n,d222(p.y,v2(0,1,0),v2(0,1,0),v2(0,1,0))//3 derivatives over 3d\n,d222(p.z,v2(0,0,1),v2(0,0,1),v2(0,0,1)));}\nc333 da_domain3(v3 p){return c333\n(d333(p.x,v3(1,0,0,0),v3(1,0,0,0),v3(1,0,0,0))\n,d333(p.y,v3(0,1,0,0),v3(0,1,0,0),v3(0,1,0,0))\n,d333(p.z,v3(0,0,1,0),v3(0,0,1,0),v3(0,0,1,0))//3 derivatives over 4d\n,d333(p.w,v3(0,0,0,1),v3(0,0,0,1),v3(0,0,0,1)));}\nc00  da_domain2(v0 p){return c00\n(d00 (p,1.,1.));}//2 derivatives over 1d\nc11 da_domain2(v1 p){return c11\n(d11(p.x,v1(1,0),v1(1,0))//2 derivatives over 2d\n,d11(p.y,v1(0,1),v1(0,1)));}\nc22 da_domain2(v2 p){return c22\n(d22(p.x,v2(1,0,0),v2(1,0,0))\n,d22(p.y,v2(0,1,0),v2(0,1,0))//2 derivatives over 3d\n,d22(p.y,v2(0,0,1),v2(0,0,1)));}\nc33 da_domain2(v3 p){return c33\n(d33(p.x,v3(1,0,0,0),v3(1,0,0,0))\n,d33(p.y,v3(0,1,0,0),v3(0,1,0,0))\n,d33(p.z,v3(0,0,1,0),v3(0,0,1,0))//2 derivatives over 4d\n,d33(p.w,v3(0,0,0,1),v3(0,0,0,1)));}\nc0 da_domain1(v0 p){return c0(d0  (p,1.));}//1 derivatives over 1d\nc1 da_domain1(v1 p){return c1//1 derivatives over 2d\n (d1(p.x,v1(1,0))\n ,d1(p.y,v1(0,1)));}\nc2 da_domain1(v2 p){return c2//1 derivatives over 3d\n(d2(p.x,v2(1,0,0))\n,d2(p.y,v2(0,1,0))\n,d2(p.z,v2(0,0,1)));}\nc3 da_domain1(v3 p){return c3//1 derivatives over 4d\n(d3(p.x,v3(1,0,0,0))\n,d3(p.y,v3(0,1,0,0))\n,d3(p.z,v3(0,0,1,0))\n,d3(p.w,v3(0,0,0,1)));}\n/*\nimplementation example:\n/*the [c*] struct folds domains to simplify AD-utility:\nthe BoxFunction (with sharp corners) becomes:\nd2 fBoxCheap(c2 p,v2 s){//p=point; s=boxSize\n ;c2 u=subdabsd(p,s)//u=abs(p)-s \n ;return maxdm(u)     //return max(u.x,u.y)\n ;} //for 1 derivatives over 3d space\nd222 fBoxCheap(c2 p,v2 s){\n ;return maxdm(subdabsd(p,s));}//for 3 derivatives over 3d space\n*/\n\n/*\nimplementation example:\n;d333 a=D333(0.)\n;a=ADfunctionMagic(a) //any of the functions below:\n//a.a.xyzw==0th derivative  over 4 domains\n//a.b.xyzw==1th derivatives over 4 domains\n//a.c.xyzw==2th derivatives over 4 domains\n//a.d.xyzw==3th derivatives over 4 domains\n/**/\n\n/**///--end__: AD structure\n/**///--\n/**///--start: AD functions \n\n/*\naka: [derivative arithmetic] set for [automatic differentiation]\n\n//AD uses these prexisNotation Namespaces and is defined for these domains):\n//[d0..d333] means, it is defined for up..3 derivatives over up..4 domains (but also any lesser permutation)\n//[c...] are some extended struct special cases (higher dimensional)\n//\n//ne()       0-a ,[d0..d333], also [c0..c333]\n//fl() floor(a  ),[d0..d333]\n//fr() fract(a  ),[d0..d333] <= su(1.,fl(a))==mod(a,1.) //complement..floor()\n//mo()   mod(a,b),[d0..d333] <= su(a,mu(b,fl(di(a,b)))) (true_basis_modulo)\n//si()   sin(a  ),[d0..d333]\n//co()   cos(a  ),[d0..d333]\n//ex()   exp(a  ),[d0..d333] //inverse of log()\n//ln()   log(a  ),[d0..d333]\n//sg()  sign(a  ),[d0..d333]\n//ab()   abs(a  ),[d0..d333],[c2]\n//su()        a-b,[d0..d333],[c0..c3]\n//ad()        a+b,[d0..d333],[c0..c3] <== su(a,ne(b))\n//mu()        a*b,[d0..d333],[c0..c3]\n//di()        a/b,[d0..d333]\n//po()   pow(a,b),[d0..d333] <= ex(mu(ln(x),x))\n//mi()   min(a,b),[d0..d333],[c2]\n//sr()  sqrt(a  ),[d0..d333]\n//p2()   pow(a,2),[d0..d333],[c0..c2] <=mu(a,a)\n//p3()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),a)\n//p4()   pow(a,3),[d0..d333],[c0..c2] <=mu(mu(a,a),mu(a,a))  //because for AD, mu() recursion is faster than pow(a,b)\n//dt()   dot(a,b),[d0..d333],[c0..c3] <=ad(mu(),mu()...)\n//dd()   dot(a,a),[d0..d333],[c0..c3] <= dt(a,a)\n//sd()  length(a),[d0..d333] <=po(dd(a),1./2.) == sq(dd(a))\n//cd()           , <=po(dd(a),1./3.)\n//qd()           , <=po(dd(a),1./4.)   \n//ud()           , <=po(dd(a),1./5.)\n//ata()          ,[d0..d333]\n//cl()  clamp()               <=mi(ma(a.,0.),1.)\n//st()   sat()                <=clamp(a.,0.,1.)\n//suab()         , [d0..d333] <=ab(sub(a))\n//\n//ab derivatives may be false/naive (3rd derivative is most likely nonsense)\n/**/\n\n//max(a,b)=-min(-a,-b), requires ne()\nv0   ne(v0   a){return -a;}\nd0   ne(d0   a){return d0  (-a.a,-a.b);}\nd1   ne(d1   a){return d1  (-a.a,-a.b);}\nd2   ne(d2   a){return d2  (-a.a,-a.b);}\nd3   ne(d3   a){return d3  (-a.a,-a.b);}\nd00  ne(d00  a){return d00 (-a.a,-a.b,-a.c);}\nd11  ne(d11  a){return d11 (-a.a,-a.b,-a.c);}\nd22  ne(d22  a){return d22 (-a.a,-a.b,-a.c);}\nd33  ne(d33  a){return d33 (-a.a,-a.b,-a.c);}\nd000 ne(d000 a){return d000(-a.a,-a.b,-a.c,-a.d);}\nd111 ne(d111 a){return d111(-a.a,-a.b,-a.c,-a.d);}\nd222 ne(d222 a){return d222(-a.a,-a.b,-a.c,-a.d);}\nd333 ne(d333 a){return d333(-a.a,-a.b,-a.c,-a.d);}\nc0   ne(c0   a){return c0  (ne(a.x));}\nc00  ne(c00  a){return c00 (ne(a.x));}\nc000 ne(c000 a){return c000(ne(a.x));}\nc1   ne(c1   a){return c1  (ne(a.x),ne(a.y));}\nc11  ne(c11  a){return c11 (ne(a.x),ne(a.y));}\nc111 ne(c111 a){return c111(ne(a.x),ne(a.y));}\nc2   ne(c2   a){return c2  (ne(a.x),ne(a.y),ne(a.z));}\nc22  ne(c22  a){return c22 (ne(a.x),ne(a.y),ne(a.z));}\nc222 ne(c222 a){return c222(ne(a.x),ne(a.y),ne(a.z));}\nc3   ne(c3   a){return c3  (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc33  ne(c33  a){return c33 (ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\nc333 ne(c333 a){return c333(ne(a.x),ne(a.y),ne(a.z),ne(a.w));}\n\n\n//floor(a) is a basis-function for mod() and fract() (all complement each other)\n//calculus on floor() is simpler than on fract() or mod() , so we defien fract() as 1.-floor(), and not as mod(a,1.)\n//and becase floor(a)=a-fract(a) is needed for differentials!\n//using floor(a) as basis,simplifies automaticDiffernetiation (and it fixes mod())\nv0 fl(v0 a){return floor(a);}\ni0 fl(i0 a){return a;} //tautological definition of floor(int(a)) simplifies things\n//multiplying by 0 seems silly, but:\n//it maintains structure to multiply by *a.b *a.c *a.d\n//it eases into the logic of Automatic Differentiation\nd0   fl(d0   a){return d0(floor(a.a),0.*a.b);}\nd00  fl(d00  a){return d00 (floor(a.a),0.*a.b,0.*a.c);}\nd000 fl(d000 a){return d000(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd1   fl(d1   a){return d1(floor(a.a),0.*a.b);}\nd11  fl(d11  a){return d11 (floor(a.a),0.*a.b,0.*a.c);}\nd111 fl(d111 a){return d111(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd2   fl(d2   a){return d2(floor(a.a),0.*a.b);}\nd22  fl(d22  a){return d22 (floor(a.a),0.*a.b,0.*a.c);}\nd222 fl(d222 a){return d222(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\nd3   fl(d3   a){return d3(floor(a.a),0.*a.b);}\nd33  fl(d33  a){return d33 (floor(a.a),0.*a.b,0.*a.c);}\nd333 fl(d333 a){return d333(floor(a.a),0.*a.b,0.*a.c,0.*a.d);}\n\n//fract(a)=a-floor(a)\n#define fr(a) su(1.,fl(a))\n//true-basis-modulo:\n//in comparison, [mod(a,b)] [a%b] are BOTH just an inconsistent MESS\n//just try a<=0 or b<=0 or b==63.\n#define mo(a,b) su(a,mu(b,fl(di(a,b))))\n//v0 mo(v0 a,v0 b){return a-(b*fl(a/b));}//==mod(a,b)\n//i0 mo(i0 a,i0 b){return a-(b*  (a/b));}//==   (a%b)\n//mod(a,1.) NEVER returns 1 (its a halfopen interval [0..1[ )\n//we KNOW that 1./0.   = 0. !!!\n//from that, we know that the antiderivative of (1./0.)==log(0.) == 0.+C\n//we KNOW that log(0.) = 0. !!!\n//we KNOW that pow(0.,0.) ==== exp(log(0.)*0.) ==  exp(0*0) = 0. !!!\n//any any argument for pow(0.,0.) approaching 1. but never reaching 1 \n// , is blown out of the water, shown to be wrong\n// , by solving for BASIC modulo arithmetic, where pow(0.,0.) ALWAYS approaches 0.\n\nv0 si(v0 a){return sin(a);}\nv0 co(v0 a){return cos(a);}\nd0 si(d0 a){return d0(si(a.a),co(a.a)*a.b);}\nd1 si(d1 a){return d1(si(a.a),co(a.a)*a.b);}\nd2 si(d2 a){return d2(si(a.a),co(a.a)*a.b);}\nd0 co(d0 a){return d0(co(a.a),-si(a.a)*a.b);}\nd1 co(d1 a){return d1(co(a.a),-si(a.a)*a.b);}\nd2 co(d2 a){return d2(co(a.a),-si(a.a)*a.b);}\n//[automatic differentiation] uo to 3rd derivative of o(a())\n//see siD() for the o()-values of trigonometry derivatives of sin() cos()\nd000 AD(d000 a,v3 o){v0 O=a.c*o.x\n ;return D000(o.xyyy*v3(1.,a.b,a.c,a.d)\n +v3(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\nd00 AD(d00 a,v2 o){v0 O=a.c*o.x\n ;return D00(o.xyy*v2(1.,a.b,a.c)\n +v2(0,0,a.b*v1(o.z*a.b,-(2.*O+(a.b*a.b*o.y+O)))));}\n\nv3 siD(v0 a){return v3(si(a),co(a),-si(a),-co(a));}//because derivatives of cin/cos have a periodicity of 4 derivatives,\nv2 siD2(v0 a){return v2(si(a),co(a),-si(a));}      //but we may also want just 2 derivatives (+base)\n\nd000 si(d000 a){return AD(a,siD(a.a)     );}//sin()dxdxdx\nd000 co(d000 a){return AD(a,siD(a.a).yzwx);}//cos()dxdxdx\nd00 si(d00 a){return AD(a,siD2(a.a));}//sin()dxdxdx\nd00 co(d00 a){return AD(a,siD2(a.a).yzx);}//cos()dxdxdx\n\n#define Omg(f,x) x=f(d00(a.a,a.b.x,a.c.x))\n#define OMg(f,x) x=f(d000(a.a,a.b.x,a.c.x,a.d.x))\n\nd11 si(d11 a){d00 Omg(si,x);d00 Omg(si,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 si(d22 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 si(d33 a){d00 Omg(si,x);d00 Omg(si,y);d00 Omg(si,z);d00 Omg(si,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 si(d111 a){d000 OMg(si,x);d000 OMg(si,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 si(d222 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 si(d333 a){d000 OMg(si,x);d000 OMg(si,y);d000 OMg(si,z);d000 OMg(si,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nd11 co(d11 a){d00 Omg(co,x);d00 Omg(co,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 co(d22 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 co(d33 a){d00 Omg(co,x);d00 Omg(co,y);d00 Omg(co,z);d00 Omg(co,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 co(d111 a){d000 OMg(co,x);d000 OMg(co,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 co(d222 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 co(d333 a){d000 OMg(co,x);d000 OMg(co,y);d000 OMg(co,z);d000 OMg(co,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//once more a clear sign of my structure extending poorly HERE\n\n//patching humber of domains as sub of numberofDerivatives is silly\n//numberOfDerivatives must be sub of DumberOdFomains\n//you would  prilarily chose how many domains your scene has\n//you woul secondarily chose how many differentials you need\n//above structure is ignorant of above 2 lines\n//so the d111 struct is already silly!\n\n//c111 si(c111 a){return c111(si(a.x),(si(a.y));}//sin()dxdxdx\n\n\n\n//single parameter operations are MUCH simpler here:\n\n//ex(d000) seems to be fine\nv0 ex(v0 a){return exp(a);}\nd0 ex(d0 a){v0 x=ex(a.a);return d0(x,x*a.b);}\nd1 ex(d1 a){v0 x=ex(a.a);return d1(x,x*a.b);}\nd2 ex(d2 a){v0 x=ex(a.a);return d2(x,x*a.b);}\n//sqrt() and divisions require a worksave reciprocal operator:\n//ex(d00) seems to be fine\nd00  ex(d00  a){return d00 (ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c);}//(tripple) productRule\nd000 ex(d000 a){return d000(ex(a.a),ex(a.a)*a.b,ex(a.a)*a.b*a.b+ex(a.a)*a.c\n,ex(a.a)*a.b*a.b*a.b+  ex(a.a)*a.c*a.b +  ex(a.a)*a.c*a.b+ex(a.a)*a.b*a.c+ex(a.a)*a.d);}//3rd derivative\nd11 ex(d11 a){d00 Omg(ex,x);d00 Omg(ex,y)              ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ex(d22 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ex(d33 a){d00 Omg(ex,x);d00 Omg(ex,y);d00 Omg(ex,z);d00 Omg(ex,w)\n    ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ex(d111 a){d000 OMg(ex,x);d000 OMg(ex,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ex(d222 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ex(d333 a){d000 OMg(ex,x);d000 OMg(ex,y);d000 OMg(ex,z);d000 OMg(ex,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ln seems to be fine\nv0 ln(v0 a){return log(a);}\nd0 ln(d0 a){return d0(log(a.a),a.b/a.a);}\nd00 ln(d00 a){return d00(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a));}//dtdt\nd000 ln(d000 a){return d000(ln(a.a),a.b/a.a,(a.c*a.a-a.b*a.b)/(a.a*a.a)//dtdt\n,((a.a*a.d-a.b*a.c)*(a.a*a.a)-2.*(a.c*a.a-a.b*a.b)*(a.b*a.a))/(a.a*a.a*a.a*a.a)//dtdtdt\n //the dividend may still contain a faster growing a.b or a.c or a.d ?\n);}//ln() is a special case of di() == one antiderivative higher.\nd1 ln(d1 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));return d1(x.a,v1(x.b,y.b));}\nd2 ln(d2 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z))\n ;return d2(x.a,v2(x.b,y.b,z.b));}\nd3 ln(d3 a){d0 x=ln(d0(a.a,a.b.x));d0 y=ln(d0(a.a,a.b.y));d0 z=ln(d0(a.a,a.b.z));d0 w=ln(d0(a.a,a.b.z))\n ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd11 ln(d11 a){d00 Omg(ln,x);d00 Omg(ln,y)              ;return d11(x.a,v1(x.b,y.b)    ,v1(x.c,y.c));}\nd22 ln(d22 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ln(d33 a){d00 Omg(ln,x);d00 Omg(ln,y);d00 Omg(ln,z);d00 Omg(ln,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ln(d111 a){d000 OMg(ln,x);d000 OMg(ln,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ln(d222 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ln(d333 a){d000 OMg(ln,x);d000 OMg(ln,y);d000 OMg(ln,z);d000 OMg(ln,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//sg() seems to be fine\nv0 sg(v0 a){return sign(a);}\nv1 sg(v1 a){return sign(a);}\nv2 sg(v2 a){return sign(a);}\nv3 sg(v3 a){return sign(a);}\nd0 sg(d0 a){return d0(sign(a.a),0.);}\nd1 sg(d1 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;return d1(x.a,v1(x.b,y.b));}\nd2 sg(d2 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z))\n   ;return d2(x.a,v2(x.b,y.b,z.b));}//this one is needed by sdUnterprim()\nd3 sg(d3 a){d0 x=sg(d0(a.a,a.b.x));d0 y=sg(d0(a.a,a.b.y))\n   ;d0 z=sg(d0(a.a,a.b.z));d0 w=sg(d0(a.a,a.b.z))\n   ;return d3(x.a,v3(x.b,y.b,z.b,w.b));}\nd00  sg(d00  a){return  d00(sign(a.a),0.,0.);}\nd000 sg(d000 a){return d000(sign(a.a),0.,0.,0.);}//super trivial (if you ignore the discontinuity)\nd11 sg(d11 a){d00 Omg(sg,x);d00 Omg(sg,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 sg(d22 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 sg(d33 a){d00 Omg(sg,x);d00 Omg(sg,y);d00 Omg(sg,z);d00 Omg(sg,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 sg(d111 a){d000 OMg(sg,x);d000 OMg(sg,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 sg(d222 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 sg(d333 a){d000 OMg(sg,x);d000 OMg(sg,y);d000 OMg(sg,z);d000 OMg(sg,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\n\n//ab() 3rd derivative seems nonsensical, to check through!\nv0 ab(v0 a){return abs(a);}\nd0 abss(v0 a){return d0(abs(a),sign(a));}//subroutine\n//cmd() is special case of component wise multiplication for abs() with a.a=1.\nd0 cmd(d0 a,v0 b){return d0(a.a,a.b*b);}\nd1 cmd(d0 a,v1 b){return d1(a.a,a.b*b);}\nd2 cmd(d0 a,v2 b){return d2(a.a,a.b*b);}\nd3 cmd(d0 a,v3 b){return d3(a.a,a.b*b);}\nd0 ab(d0 a){return cmd(abss(a.a),a.b);}//d (abs(a.a),sign(a.a)*a.b);}\nd1 ab(d1 a){return cmd(abss(a.a),a.b);}//d1(abs(a.a),sign(a.a)*a.b);}\nd2 ab(d2 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd3 ab(d3 a){return cmd(abss(a.a),a.b);}//d2(abs(a.a),sign(a.a)*a.b);}\nd00 ab(d00 a){return d00(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b);}\nd000 ab(d000 a){return d000(abs(a.a)\n,sign(a.a)*a.b\n,sign(a.a)*a.c+a.b\n,sign(a.a)*a.d+a.c);}//i am a bit suspicious about the derivatives here,not sure if it is THAT simple.\nd11 ab(d11 a){d00 Omg(ab,x);d00 Omg(ab,y)\n ;return d11(x.a,v1(x.b,y.b),v1(x.c,y.c));}\nd22 ab(d22 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z)\n ;return d22(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c));}\nd33 ab(d33 a){d00 Omg(ab,x);d00 Omg(ab,y);d00 Omg(ab,z);d00 Omg(ab,w)\n ;return d33(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c));}\n//more numbers in the type name=more derivatives are calculated, larger numbers=more domains\nd111 ab(d111 a){d000 OMg(ab,x);d000 OMg(ab,y)\n ;return d111(x.a,v1(x.b,y.b),v1(x.c,y.c),v1(x.d,y.d));}\nd222 ab(d222 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z)\n ;return d222(x.a,v2(x.b,y.b,z.b),v2(x.c,y.c,z.c),v2(x.d,y.d,z.d));}\nd333 ab(d333 a){d000 OMg(ab,x);d000 OMg(ab,y);d000 OMg(ab,z);d000 OMg(ab,w)\n ;return d333(x.a,v3(x.b,y.b,z.b,w.b),v3(x.c,y.c,z.c,w.c),v3(x.d,y.d,z.d,w.d));}\nc0   ab(c0   a){return c0  (ab(a.x));}\nc00  ab(c00  a){return c00 (ab(a.x));}\nc000 ab(c000 a){return c000(ab(a.x));}\nc1   ab(c1   a){return c1  (ab(a.x),ab(a.y));}\nc11  ab(c11  a){return c11 (ab(a.x),ab(a.y));}\nc111 ab(c111 a){return c111(ab(a.x),ab(a.y));}\nc2   ab(c2   a){return c2  (ab(a.x),ab(a.y),ab(a.z));}\nc22  ab(c22  a){return c22 (ab(a.x),ab(a.y),ab(a.z));}\nc222 ab(c222 a){return c222(ab(a.x),ab(a.y),ab(a.z));}\nc3   ab(c3   a){return c3  (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc33  ab(c33  a){return c33 (ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\nc333 ab(c333 a){return c333(ab(a.x),ab(a.y),ab(a.z),ab(a.w));}\n\n//derivatives of functions with 2 input parameters are trickier:\n//  https://en.wikipedia.org/wiki/Multivariable_calculus\n//There are exponential many permutations of mod() mixd() mind() input types\n\n//substraction is simple, because \"differentiation equals integration\"\n//  https://en.wikipedia.org/wiki/Cauchy_integral_formula\n//...making the implementation of the chain rule much simpler for:\n//  https://en.wikipedia.org/wiki/Translation_(geometry)\n\n//su() ad() seem to be fine\n#define omG(f,x) f(d000(a.a,a.b.x,a.c.x,a.d.x),d000(b.a,b.b.x,b.c.x,b.d.x))\n#define oMg(f,x) f(d00(a.a,a.b.x,a.c.x),d00(b.a,b.b.x,b.c.x))\n#define sux b){return a-b;}\n#define sun(n,f,g) n f(n a,v0 g n f(v0 a,n g n f(n a,n g\nsun(v1,su,sux)\nsun(v2,su,sux)\nsun(v3,su,sux)\nv0 su(v0 a,v0 sux\n//v1 su(v1 a,v0 sux\n//v1 su(v0 a,v1 sux\nd2 su(d2 a,d2 b){return d2(a.a-b.a,a.b-b.b);}//3d translation\nd1 su(d1 a,d1 b){return d1(a.a-b.a,a.b-b.b);}//2d translation\nd0 su(d0 a,d0 b){return d0(a.a-b.a,a.b-b.b);}//1d translation\nd2 su(d2 a,v0 b){return d2(a.a-b  ,a.b);}\nd2 su(d2 a,d0 b){return d2(a.a-b.a,a.b);}\nd2 su(d2 a,d1 b){return d2(a.a-b.a,a.b);}      \nd3 su(d3 a,v0 b){return d3(a.a-b  ,a.b);}\nd1 su(d1 a,v0 b){return d1(a.a-b  ,a.b);}                             \nd1 su(d1 a,d0 b){return d1(a.a-b.a,a.b);}\nd0 su(d0 a,v0 b){return d0(a.a-b  ,a.b);}                           \nd2 su(v0 a,d2 b){return d2(a  -b.a,-b.b);}\nd2 su(d0 a,d2 b){return d2(a.a-b.a,-b.b);}\nd2 su(v3 a,d2 b){return d2(a.a-b.a,-b.b);}\nd1 su(v0 a,d1 b){return d1(a  -b.a,-b.b);}\nd1 su(d0 a,d1 b){return d1(a.a-b.a,-b.b);}\nd0 su(v0 a,d0 b){return d0(a  -b.a,-b.b);}\nd3 su(v0 a,d3 b){return d3(a  -b.a,-b.b);}\nd3 su(d3 a,d3 b){return d3(a.a-b.a,-b.b);}\nd00 su(d00 a,d00 b){return d00(a.a-b.a,a.b-b.b,a.c-b.c);}\nd11 su(d11 a,d11 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd22 su(d22 a,d22 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd33 su(d33 a,d33 b){d00 xa=oMg(su,x);d00 ya=oMg(su,y);d00 za=oMg(su,z);d00 wa=oMg(su,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd000 su(d000 a,d000 b){return d000(a.a-b.a,a.b-b.b,a.c-b.c,a.d-b.d);}\n//ST   d111{v0   a;v1   b;v1   c;v1   d;};//2 domains t,dt,dt²,dt³\nd111 su(d111 a,d111 b){d000 xa=omG(su,x);d000 ya=omG(su,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd222 su(d222 a,d222 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd333 su(d333 a,d333 b){d000 xa=omG(su,x);d000 ya=omG(su,y);d000 za=omG(su,z);d000 wa=omG(su,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\n      \nd33 su(d33 p,v3 s){return su(p,d33(s.x,v3(0),v3(0)));}\nd22 su(d22 p,v2 s){return su(p,d22(s.x,v2(0),v2(0)));}\nd11 su(d11 p,v1 s){return su(p,d11(s.x,v1(0),v1(0)));}\nd00 su(d00 p,v0 s){return su(p,d00(s  ,v0(0),v0(0)));}//this seems VERY nonsensical, to only store .x\n\nd33 su(d33 p,v0 s){return su(p,d33(s,v3(0),v3(0)));}\nd22 su(d22 p,v0 s){return su(p,d22(s,v2(0),v2(0)));}\nd11 su(d11 p,v0 s){return su(p,d11(s,v1(0),v1(0)));}\n      \n#define oMG(f) f(p.x,s.x),f(p.y,s.y)\nc3 su(c3 p,v3 s){return c3(oMG(su),su(p.z,s.z),su(p.w,s.w));}\nc2 su(c2 p,v2 s){return c2(oMG(su),su(p.z,s.z));}\nc1 su(c1 p,v1 s){return c1(oMG(su));}\nc0 su(c0 p,v0 s){return c0(su(p.x,s));}\n//subd(absd(p),s) equals a translation away from the origin by [s]\n//... AND mirroring at origin, via abs() \n//... so it it clamps a an implicit surface to a limited \"thickness\"\n//(in 3 domains),also translating its first de)rivatives.\n\n//addition is negated substraction:\n#define ad(a,b) su(a,ne(b))\n#define adddabsd(a,b) suab(a,negd(b))\n\n//automatic_differentiation_multiplication \n// productRule within the chainRule\n//  https://en.wikipedia.org/wiki/Product_rule\n#define atb a.a*b,a.b*b);}\n#define mdb b){return mu(b,a);}\n#define mux b){return a*b;}\nsun(v1,mu,mux)\nsun(v2,mu,mux)\nsun(v3,mu,mux)      \nv0 mu(v0 a,v0 mux\nd3 mu(d3 a,v0 b){return d3(atb\nd2 mu(d2 a,v0 b){return d2(atb\nd1 mu(d1 a,v0 b){return d1(atb\nd0 mu(d0 a,v0 b){return d0(atb\nd2 mu(v0 a,d2 mdb //mdb is the commutative inverse of the 3 above ones\nd1 mu(v0 a,d1 mdb\nd0 mu(v0 a,d0 mdb//scalar multiplication is tautological product_rule.\n#define mutal(f) b){return f(a.a*b.a,a.b*b.a+a.a*b.b);}\nd0 mu(d0 a,d0 mutal(d0)\nd1 mu(d1 a,d1 mutal(d1)\nd1 mu(d0 a,d1 mutal(d1)\nd1 mu(d1 a,d0 mutal(d1)\nd2 mu(d2 a,d2 mutal(d2)\nd2 mu(d2 a,d0 mutal(d2)\nd2 mu(d0 a,d2 mutal(d2)\nd3 mu(v0 a,d3 b){return d3(a  *b.a,a  *b.a+a  *b.b);}\nd3 mu(d3 a,d3 b){return d3(a.a*b.a,a.b*b.a+a.a*b.b);}\nd00  mu(d00  a,d00  b){return d00 (a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b);}//dxdx\nd000 mu(d000 a,d000 b){return d000(a.a*b.a,a.a*b.b+a.b*b.a,a.b*b.b+a.a*b.c+a.c*b.a+a.b*b.b//dxdx\n,a.c*b.b+a.b*b.c+a.b*b.c+a.a*b.d+a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c);}//dxdxdx\nd11 mu(d11 a,d11 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mu(d111 a,d111 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mu(d22 a,d22 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mu(d222 a,d222 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mu(d33 a,d33 b){d00 xa=oMg(mu,x);d00 ya=oMg(mu,y);d00 za=oMg(mu,z);d00 wa=oMg(mu,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mu(d333 a,d333 b){d000 xa=omG(mu,x);d000 ya=omG(mu,y);d000 za=omG(mu,z);d000 wa=omG(mu,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}    \nd00  mu(d00  a,v0 b){return mu(a,d00 (b,0.,0.));}\nd000 mu(d000 a,v0 b){return mu(a,d000(b,0.,0.,0.));}\nd11  mu(d11  a,v0 b){return mu(a,d11 (b,v1(0),v1(0)));}\nd111 mu(d111 a,v0 b){return mu(a,d111(b,v1(0),v1(0),v1(0)));}\nd22  mu(d22  a,v0 b){return mu(a,d22 (b,v2(0),v2(0)));}\nd222 mu(d222 a,v0 b){return mu(a,d222(b,v2(0),v2(0),v2(0)));}\nd33  mu(d33  a,v0 b){return mu(a,d33 (b,v3(0),v3(0)));}\nd333 mu(d333 a,v0 b){return mu(a,d333(b,v3(0),v3(0),v3(0)));}//multiply by constant, needed for sqrt()\nc3 mu(c3 p,v3 s){return c3(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z),mu(p.w,s.w));}\nc2 mu(c2 p,v2 s){return c2(mu(p.x,s.x),mu(p.y,s.y),mu(p.z,s.z));}\nc1 mu(c1 p,v1 s){return c1(mu(p.x,s.x),mu(p.y,s.y));}\nc0 mu(c0 p,v0 s){return c0(mu(p.x,s));}\n//special utility cases come last\nc2 mu(c2 p,v0 s){return mu(p,v2(s));}\n    \n//reciprocal derivatives are most confusing.\n#define atc a.a/b,a.b/b);}\n#define dix b){return a/b;}\nsun(v1,di,dix)\nsun(v2,di,dix)\nsun(v3,di,dix)      \nv0 di(v0 a,v0 dix\nd3 di(d3 a,v0 b){return d3(atc\nd2 di(d2 a,v0 b){return d2(atc\nd1 di(d1 a,v0 b){return d1(atc\nd0 di(d0 a,v0 b){return d0(atc//inverse scalar multiplication is a tautolotgy.\n#define bxx /(b.a*b.a));}\nd2 di(v0 a,d2 b){return d2(a  /b.a,(-a  *b.b)bxx\nd3 di(v0 a,d3 b){return d3(a  /b.a,(-a  *b.b)bxx\nd2 di(d0 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d1 a,d2 b){return d2(a.a/b.a,(-a.a*b.b)bxx\nd2 di(d2 a,d2 b){return d2(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\nd3 di(d3 a,d3 b){return d3(a.a/b.a,(a.b*b.a-a.a*b.b)bxx\n\n//di() seems to be fine()\nd00  di(d00  a,d00  b){return d00 (a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a));}//dxdx\nd000 di(d000 a,d000 b){return d000(a.a/b.a,(a.b*b.a-a.a*b.b)/(b.a*b.a)//dx\n,((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))/(b.a*b.a*b.a*b.a) \n,((((a.d*b.a+a.c*b.b+a.c*b.b+a.b*b.c-a.c*b.b-a.b*b.c-a.b*b.c-a.a*b.d)*(b.a*b.a)//dxdx\n+(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.b*b.a*b.a*b.b))\n+(-2.*(a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.b)\n+(a.b*b.a-a.a*b.b)*(b.b*b.b+b.a*b.c)))*(b.a*b.a*b.a*b.a)\n-((a.c*b.a+a.b*b.b-a.b*b.b-a.a*b.c)*(b.a*b.a)\n-2.*(a.b*b.a-a.a*b.b)*(b.a*b.b))\n*4.*(b.b*b.a*b.a*b.a))/(b.a*b.a*b.a*b.a*b.a*b.a*b.a*b.a));}//dxdxdx //3rd derivative quotient rule sure is something\nd11 di(d11 a,d11 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 di(d111 a,d111 b){d000 xa=omG(di,x);d000 ya=omG(di,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 di(d22 a,d22 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 di(d222 a,d222 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 di(d33 a,d33 b){d00 xa=oMg(di,x);d00 ya=oMg(di,y);d00 za=oMg(di,z);d00 wa=oMg(di,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}                          \nd333 di(d333 a,d333 b){d000 xa=omG(di,x);d000 ya=omG(di,y);d000 za=omG(di,z);d000 wa=omG(di,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\n\nd00  di(d00  a,v0 b){return di(a,d00 (b,0.,0.));}//needed for min()\nd000 di(d000 a,v0 b){return di(a,d000(b,0.,0.,0.));}//needed for min()\n//All exponential functions utilize their Base_E_identity:\n//...which is still not efficient, but comes doen to O(exp(n*log(n)))\n//      pow (x,y)==exp(     log (x)*y )//baseE exponential and logarythmic functions.\n#define po(x,y) ex(mu(ln(x),y))\n\n//this isNOT mx() with differentials, this is just mi() with differentials and subroutines!\n\n//mixd is subroutine for mind(), which is used as branch. mix(n1,n2,step(m,0.))\nv0 mixd(v0 a,v0 b,v0 c){return mix(a,b,c);}\nv1 mixd(v1 a,v1 b,v0 c){return mix(a,b,c);}\nv2 mixd(v2 a,v2 b,v0 c){return mix(a,b,c);}\nv3 mixd(v3 a,v3 b,v0 c){return mix(a,b,c);}\n//v1 mixd(v0 a,v1 b,v0 c){return mix(v0tv1(a),b,c);} oh my permutations...\nd0 mixd(d0 a,d0 b,v0 c){return d0(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d1 a,d1 b,v0 c){return d1(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd2 mixd(d2 a,d2 b,v0 c){return d2(mix(a.a,b.a,c),mix(a.b,b.b,c));}\nd1 mixd(d0 a,d1 b,v0 c){return mixd(D1(a),b,c);}\nd2 mixd(d0 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd2 mixd(d1 a,d2 b,v0 c){return mixd(D2(a),b,c);}\nd1 mixd(d1 a,d0 b,v0 c){return mixd(a,D1(b),c);}\nd2 mixd(d2 a,d1 b,v0 c){return mixd(a,D2(b),c);}\nd2 mixd(d2 a,d0 b,v0 c){return mixd(a,D2(b),c);}\n//the return of Fortran's \"XIF(m,n1,n2)===(m==0)?n1:n2===mix(n1,n2,step(m,0.)*step(0.,m))\n//ecept it compares if (a.x>b.x)\n#define min1 {return mixd(b,a,step(a.a,b.a));}\n#define min3 {return mi(b,a);}\n//I define mind() and -maxd(-,-) instead of maxd() and -mind(-,-)\n//because min() is far more common than max(), for z-buffering.       \n#define xmi b){return min(a,b);}\n#define ma(a,b) ne(mi(ne(a),ne(b)))\n#define ma2(a,b,c) ma(ma(a,b),c)\n#define ma3fffff(a,b,c,d) ma(ma(a,b),ma(c,d))\nv0 mi(v0 a,v0 xmi\nv1 mi(v1 a,v1 xmi\nv2 mi(v2 a,v2 xmi\nv3 mi(v3 a,v3 xmi\n//component-wise min() aliases: \nv0 mi(v1 a){return mi(a.x,a.y);}\nv0 mi(v3 a){return mi(mi(a.xy),mi(a.zw));}\n//3-domain matrix tripples:\n//todo, renew structure of this old mess\nd2 mi(d2 a,d2 b)min1\nd2 mi(d1 a,d2 b)min1\nd2 mi(d0 a,d2 b)min1\nd2 mi(d2 a,d1 b)min1\nd2 mi(d2 a,d0 b)min1\nd1 mi(d1 a,d1 b)min1\nd1 mi(d0 a,d1 b)min1\nd0 mi(d0 a,d0 b)min1\nd2 mi(v0 a,d2 b){return mixd(D2(a),b,step(b.a,a));}\nd2 mi(d2 a,v0 b){return mixd(D2(b),a,step(a.a,b));}\nd1 mi(v0 a,d1 b){return mi(D1(a),b);}\nd0 mi(v0 a,d0 b){return mi(D0(a),b);}\n//d0 mi(v0 a,v0 b){return D0(min(a,b));}\nd1 mi(d1 a,d0 b)min3\nd1 mi(d1 a,v0 b)min3\nd0 mi(d0 a,v0 b)min3\n//min(x,y) = (x+y-abs(x-y))/2 == di(ad(x,su(y,ab(su(x,y)))),2.)\n//max(x,y) = (x+y+abs(x-y))/2 == di(ad(x,ad(y,ab(su(x,y)))),2.)\nd00  mi(d00  a,d00  b){return di(ad(a,su(b,ab(su(a,b)))),2.);}\nd000 mi(d000 a,d000 b){return di(ad(a,su(b,ab(su(a,b)))),2.);}     \nd11 mi(d11 a,d11 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y)\n ;return d11(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c));}\nd111 mi(d111 a,d111 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y)\n ;return d111(xa.a,v1(xa.b,ya.b),v1(xa.c,ya.c),v1(xa.d,ya.d));}\nd22 mi(d22 a,d22 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z)\n ;return d22(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c));}\nd222 mi(d222 a,d222 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z)\n ;return d222(xa.a,v2(xa.b,ya.b,za.b),v2(xa.c,ya.c,ya.c),v2(xa.d,ya.d,za.d));}\nd33 mi(d33 a,d33 b){d00 xa=oMg(mi,x);d00 ya=oMg(mi,y);d00 za=oMg(mi,z);d00 wa=oMg(mi,z)\n ;return d33(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c));}\nd333 mi(d333 a,d333 b){d000 xa=omG(mi,x);d000 ya=omG(mi,y);d000 za=omG(mi,z);d000 wa=omG(mi,z)\n ;return d333(xa.a,v3(xa.b,ya.b,za.b,wa.b),v3(xa.c,ya.c,ya.c,wa.c),v3(xa.d,ya.d,za.d,wa.d));}\nc2 mi(c2 a,v2 p){return c2(mi(a.x,p.x),mi(a.y,p.y),mi(a.z,p.z));}\nc2 madm(c2 a,v2 p){return c2(ma(a.x,p.x),ma(a.y,p.y),ma(a.z,p.z));}\nc2 madm(c2 a,v0 p){return madm(a,v2(p));}\nc2 mi(c2 a,v0 p){return mi(a,v2(p));}//needed for fast clamping\nd2 mi(d2 a,d2 b,d2 c){return mi(mi(a,b),c);}\nd2 mi(c2 a){return mi(a.x,a.y,a.z);}\nd2 madm(d2 a,d2 b,d2 c){return ma(ma(a,b),c);}\nd2 madm(c2 a){return madm(a.x,a.y,a.z);}\n\n//This lets you derive over up to 3 dimensions at once OR seperately, \n//...using very self-similar dual-function variants:\n//#define pow2d(a) d2(mu(a.x,a.x),mu(a,2.))\n\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n#define p2(a) mu(a,a)\n#define p3(a) mu(a,mu(a,a))\n#define p4(a) ex(a,4.)\n//In terms of 3rd derivatives, it is deinitely slower    to do ex(a,2.), than mu(a,a)\n//In terms of 3rd derivatives, it is likely    slower    to do ex(a,3.), than mu(a,mu(a,a))\n//In terms of 3rd derivatives, it is possibly  faster(!) to do ex(a,4.), than mu(mu(a,a),mu(a,a))\n//- the exponentRule is less complex than the productRule, even with only one derivative\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)\n//- ProductRule 3rd derivative   is  7add+15mult+0pow()  \n//- ProductRule 3rd derivative*2 is 14add+30mult+0pow()  \n//- ProductRule 3rd derivative*3 is 21add+45mult+0pow()\n//- PowerRule   3rd derivative   is 13add+12mult+7pow() //(pow of simple exponents)                 \n                           \n//above pow2() is very special and simple derivative arithmetic \n//... that should tell you what is going on with all the other \n//... dual number arithmetic functions below.\n//operations with only 1 input parameter are the simplest.\n\n//It gets trickier with functions that take up to 3 parameters:, applying the\n//  https://en.wikipedia.org/wiki/Triple_product_rule\n//Euclidean distance (pythagorean theorem) with first derivatives:\n\n//length() is a wrapped dd(a)==dot(a,a)\n//it uses the same root-wrapper as   sr(),cr(),qr(),ur()\n//so we replace [length()] with sd() == squareDotSelf\n\n//dot() takes vectors as input, so we take this one differently, dot() is only defined for c1(vec2) c22(vec3) c33(vec4)\n//dot()always returns a d0(float)\n//the function is ad( (ad(mu(),mu()),  ad(mu(),mu()) )\n//the function is ad( (ad(mu(),mu()),     mu()       )\n//the function is      ad(mu(),mu())\n//and multiplied terms are of type v0\n\n//ST c1  {d1   x;d1   y              ;};//2 domains t,dt   \n//ST d1  {v0   a;v1   b              ;};//2 domains t,dt\n//ST c2  {d2   x;d2   y;d2   z       ;};//3 domains t,dt\n      \n//the c* inputs can be da_domain1(v*) outputs\nd0   dt(c0   a,c0   b){return       mu(a.x,b.x);}//dotproduct in 2d with 1 derivative (is just mu())\nd00  dt(c00  a,c00  b){return       mu(a.x,b.x);}//dotproduct in 2d with 2 derivative\nd000 dt(c000 a,c000 b){return       mu(a.x,b.x);}//dotproduct in 2d with 3 derivative   \nd1   dt(c1   a,c1   b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 1 derivative\nd11  dt(c11  a,c11  b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 2 derivative\nd111 dt(c111 a,c111 b){return ad(   mu(a.x,b.x),mu(a.y,b.y));}//dotproduct in 2d with 3 derivative   \nd2   dt(c2   a,c2   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 1 derivative\nd22  dt(c22  a,c22  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 2 derivative\nd222 dt(c222 a,c222 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),mu(a.z,b.z));}//dotproduct in 3d with 3 derivative\nd3   dt(c3   a,c3   b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 1 derivative\nd33  dt(c33  a,c33  b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 2 derivative\nd333 dt(c333 a,c333 b){return ad(ad(mu(a.x,b.x),mu(a.y,b.y)),ad(mu(a.z,b.z),mu(a.w,b.w)));}//dotproduct in 4d with 3 derivative\nv0 dt(v0 a,v0 b){return dot(a,b);}v0 dt(v1 a,v1 b){return dot(a,b);}\nv0 dt(v2 a,v2 b){return dot(a,b);}v0 dt(v3 a,v3 b){return dot(a,b);}\n\n#define dd(a) dt(a,a)\n//explicit dd() dual type (for uberprim)\n#define dd2(a,b) ad(p2(a),p2(b))\n//multi-dd() (muliple lengths at once)\n#define d2d(a,b)    v1(   dd(a),dd(b))\n#define d3d(a,b,c)  v2(d2d(a,b),dd(c))\n#define d4d(a,b,c,d)v3(d2d(a,b),d2d(c,d))\n         \nv0 rec(v0 a){return (a==0.)?a:1./a;}//return [1/a] , work safe\n#define v0q v0 q=sd(v1(x.a,y.a))\n#define ll2 q,(x.b*x.a+y.b*y.a)*rec(q));}\nv0 sd(v0 a){return abs(a);}\nv0 sd(v1 a){return length(a);}//squareDotSelf==length()\nv0 sd(v2 a){return length(a);}//==sqrt(dt(a))\nv0 sd(v3 a){return length(a);}//==po(dd(a),1./2.)\nv0 cd(v0 a){return po(dd(a),1./3.);}\nv0 cd(v1 a){return po(dd(a),1./3.);}\nv0 cd(v2 a){return po(dd(a),1./3.);}\nv0 cd(v3 a){return po(dd(a),1./3.);}//cubicDotSelf\nv0 qd(v0 a){return po(dd(a),1./4.);}\nv0 qd(v1 a){return po(dd(a),1./4.);}\nv0 qd(v2 a){return po(dd(a),1./4.);}\nv0 qd(v3 a){return po(dd(a),1./4.);}//quarticDotSelf\nv0 ud(v0 a){return po(dd(a),1./5.);}\nv0 ud(v1 a){return po(dd(a),1./5.);}\nv0 ud(v2 a){return po(dd(a),1./5.);}\nv0 ud(v3 a){return po(dd(a),1./5.);}//quinticDotSelf\nd0 sd(d0 x,d0 y){v0q;return d0(ll2\nd1 sd(d1 x,d1 y){v0q;return d1(ll2\nd2 sd(d2 x,d2 y){v0q;return d2(ll2\nd1 sd(c1 u){return sd(u.x,u.y);}//2*2domains (distance on a plane in 2d)\n//d2 sd(c2 u){return sd(u.x,u.y);}//2*3domains (distance on a plane in 3d)\n//above are planar length, below are 3d lengths\nd2 sd(d2 x,d2 y,d2 z){v0 q=length(v2(x.a,y.a,z.a));\n return d2(q,(x.b*x.a+y.b*y.a+z.b*z.a)*rec(q));}\nd2 sd(c2 u){return sd(u.x,u.y,u.z);}//3*3domains (3d euclidean distance)\n\n\nv0 sr(v0 a){return sqrt(a);}v1 sr(v1 a){return sqrt(a);}v2 sr(v2 a){return sqrt(a);}v3 sr(v3 a){return sqrt(a);}\nd0 sr(d0 a){v0 q=sqrt(a.a);return d0(q,.5*rec(q)*a.b);}\nd1 sr(d1 a){v0 q=sqrt(a.a);return d1(q,.5*rec(q)*a.b);}\nd2 sr(d2 a){v0 q=sqrt(a.a);return d2(q,.5*rec(q)*a.b);}\nd3 sr(d3 a){v0 q=sqrt(a.a);return d3(q,.5*rec(q)*a.b);}//first derivative shortcut is near\nd00  sr(d00  a){return ex(mu(ln(a),.5));}//2nd and 3rd derivative i do not bother with.,\nd000 sr(d000 a){return ex(mu(ln(a),.5));}\nd11  sr(d11  a){return ex(mu(ln(a),.5));}\nd111 sr(d111 a){return ex(mu(ln(a),.5));}\nd22  sr(d22  a){return ex(mu(ln(a),.5));}\nd222 sr(d222 a){return ex(mu(ln(a),.5));}\nd33  sr(d33  a){return ex(mu(ln(a),.5));}\nd333 sr(d333 a){return ex(mu(ln(a),.5));}\n\n/**///--end__: AD functions                    \n/**///--\n/**///--start: analysis common subroutines\n\n\n//compare [a] with [0.0] to return [b]==true or [c]==false\n//branching code is always faster than branchless code\n//, but the branchless code*s step() can be made into a smoothstep.\n  #define    more(a,b,c) ((a> 0.)?b:c)\n//#define    more(a,b,c)             mix(a,b,step(c,0.))\n  #define    less(a,b,c) ((a< 0.)?b:c)\n//#define    less(a,b,c)             mix(a,b,step(0.,c))\n  #define   equal(a,b,c) ((a==0.)?b:c)\n//#define   equal(a,b,c)             mix(b,a,step2\n  #define unequal(a,b,c) ((a!=0.)?b:c)\n//#define unequal(a,b,c)             mix(a,b,step2\n  #define  unless(a,b,c) ((a>=0.)?b:c) \n//#define  unless(a,b,c)             mix(b,a,step(0.,c)) //==greater OR equal\n  #define  unmore(a,b,c) ((a<=0.)?b:c)\n//#define  unmore(a,b,c)             mix(b,a,step(c,0.))\n// https://www.shadertoy.com/view/XssfRf\n#define step2 step(c,0.)+step(0.,c)-1.)\n//above is based on   https://www.reddit.com/r/askmath/comments/6aag2g/simplifying_stepa00step00a/\n\nfloat mStretch(vec2 u,vec2 m//mstretch generalization\n){float b=.5*sign(u.x)*m.x\n ;float c=(sign(abs(u.x)-m.x))\n ;u.x*=-.5\n ;return b+c*(b+u.x)+u.x*2.*m.y/m.x+u.x\n ;//if(abs(u.x)>m.x)return-u.x+m.x*sign(u.x);return 0.;//branching variant can be faster\n ;}//#define mStretch(v,m)mix(v-m,mix(0.,v,step(v,0.)),step(v,m));\n//stretch   ;centric,most commonly used,therefore atomic\n#define mStretch(u,m).5*(sign(u)*m-u)*((sign(abs(u)-m))+1.)\n//stretch nimus;positive values do not change\n#define mStretchM(u,m)mStretch((u*2.+m),m)*.5\n//vec2  mStretchM(vec2  u,vec2  m){m*=.5;u=u+m;return  mStretch(u,m);}\n//stretch plus ;negative values do not change\n#define mStretchP(u,m)mStretch((u*2.-m),m)*.5\n//based on #define analstretching(u,m)mix(u-m,mix(vec2(0.),u,step(u,vec2(0.))),step(u,m))\n//https://en.wikipedia.org/wiki/Trigonometric_constants_expressed_in_real_radicals\n//a simpler shape for debugging.\nfloat circleStretch(vec2 u,vec4 m){return length(mStretch(u,m.xy))-2.;}\n\n/**///--end__: analysis common subroutines                  \n/**///--\n/**///--start: analysis Hue Gradient Gamma \n\n//rgba colorspace matrices\n      \n#define ut(a,b) (a*(1.-b))          \nv3 pdOut(v3 a,v3 b){return ut(b,a.w);}\nv3 pdOver(v3 a,v3 b){return ut(b,a.w)+a;}\nv3 pdAtop(v3 a,v3 b){return ut(b,a.w)+a*b.w;}\nv3 pdXor(v3 a,v3 b){return ut(b,a.w)+v3(ut(a,b.w));}\nv3 pdIn(v3 a,v3 b){return v3(a.xyz*b.w,1);}//pdIn() is just multiplication, note swapped AB case here\n//https://en.wikipedia.org/wiki/Alpha_compositing\nv3 aOverB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a+b*(1.-a));}\n//v1 aOverB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a+b*(1.-a));}\n//not sure if correct, but looks useful.\nv3 aXorB(v3 a,v3 b){a.xyz*=a.w;b.xyz*=b.w;return v3(a*(1.-b)+b*(1.-a));}\n//v1 aXorB(v1 a,v1 b){a.x*=a.y;b.x  *=b.y;return v1(a*(1.-b)+b*(1.-a));}\n\n//return color corrected r\nv2 ff_filmic_gamma3(v2 r){v2 x=max(v2(0),r-.004)\n;return (x*(x*6.2+.5))/(x*(x*6.2+1.7)+.06);}\n      \n#define ab012(a,b)(a+b*v2(0,1,2))  //desaturation.rgb kernel;b scales offset\n//rainbow*()ro from purple to purple for range[0..1],this makes ab012()desaturate into semi-gaussian scattering.\nv2 rainbow(v0 a,v0 b){return u5(cos(2.*pi*ab012(a,b)));}//sine rainbow with offsets,desaturates colors for small b\nv2 rainbowt(v0 a,v0 b){return abs(u2(fract(ab012(a,b))));}//triangle rainbow with offsets,desaturates colors for small b\nv2 rainbow(v0 a){return rainbow(a,1./3.);}\nv2 rainbowt(v0 a){return rainbowt(a,1./3.);}\n#define ToRgb(a) return c.z*mix(v2(1.),sat(a(-c.x)),c.y);}\nv2 angleToColor(v2 c){ToRgb(rainbow)//cos-mix\n//v2 hsv2rgb(v2 c){ToRgb(rainbow2)//linear-mix not identical to the below, but close\nv2 hsv2rgb(const v2 c){return c.z*mix(v2(1),sat(abs(fract(c.x+v2(3,2,1)/3.)*6.-3.)-1.),c.y);}\nv2 rgb2hsv(v2 a){v3 K=v3(0,-1,2,-3)/3.//https://www.shadertoy.com/view/MdGfWm\n ;v3 P=mix(v3(a.bg,K.wz),v3(a.gb,K.xy),step(a.b,a.g));v3 Q=mix(v3(P.xyw,a.r),v3(a.r,P.yzx),step(P.x,a.r))\n ;v0 D=Q.x-min(Q.w,Q.y),E=1e-10;return v2(abs(Q.z+(Q.w-Q.y)/(6.*D+E)),D/(Q.x+E),Q.x);}\n\n#define hsv2rgb(c) c.z*mix(vec3(1),sat(abs(fract(c.x+vec3(3,2,1)/3.)*6.-3.)-1.),c.y)\n//below is inverse of above, it swivels quite a lot, i think i once made this much smarter!, like in 2008\n#define rgb2hsv2(a,b,c,d,e,f) mx(vec4(a,b),vec4(c,d),st(e,f))\n#define rgb2hsv3(K) rgb2hsv2(a.zy,K.wz,a.yz,K.xy,a.z,a.y)\n#define rgb2hsv4(P) rgb2hsv2(P.xyw,a.x,a.x,P.yzx,P.x,a.x)\n#define rgb2hsv5(D,q) abx(vec2(q.w-q.y,D)/(vec2(6.*D,q.x)+1e-10)+vec2(q.z,0))\n#define rgb2hsv6(q) vec3(rgb2hsv5((q.x-min(q.w,q.y)),q),q.x)\n#define rgb2hsv(a) rgb2hsv6(rgb2hsv4(rgb2hsv3((vec4(0,-1,2,-3)/3.))))//https://www.shadertoy.com/view/MdGfWm\n//common legacy namespaces\n#define hsv2rgbR     rainbowt    //3 tri waves, most blurry, fast and precise, consoidder for mobile\n#define angleToColor rainbows //3 cos waves, medium blurry\n//hsv2rgb() most commonly implies a [capped triangle waveform]\n\n                      \n/**///--end__: analysis Hue Gradient Gamma \n/**///--\n/**///--start: analysis smin      \n\n//smin: 2nd letter sets 1of3 boolean fuzzy-unions,\"mex()\"==max(a,-b) is semi-nonsense;\n//3rd letter sets type of smoothing union\n//sMinExponential [m*e] is slow but commutative (like multiple parallel resistors)\n//you should pre-reciprocal the [k] of [m*e]\n///mie(a,b,k)=(log(exp(k*-a)+exp(k*-b))/k);} is expomemtial smooth minimum; mee()mes()mer() are [boolean nonimplication,0100]\n//vec4 mu(vec3 a,vec4 b){return a*b;}\n#define mae(a,b,k) di(ln(ad(ex(mu(k,a)),ex(mu(k,b)))),k)//sMaxExponential\n#define mee(a,b,k) ne(mae(a,ne(b),k))//sDifExponential\n#define mie(a,b,k) mee(ne(a),b,k)//sMinExponential\n//\n//w11 mx(w11 a,w11 b,vec1 c){return ad(mu(c,su(a,b)),a);} //mix(a,b,c) [~=] c*(a-b)+a;<- actually false\n//w11 mx(w11 a,w11 b,w11 c){return w11(mix(a.a,b.a,c.a),mix(a.b,b.b,c.a)//close enough, likely false\n//ad(mu(c.b,su(a.b,b.b)),a.b)\n//mix(a.b,b.b,c.b)\n//);}//somehow almost correct.\n//SminPPolynomial [m*e] by IQ is fast but not commutative; mis2() is subroutine\n#define mis2(a,b,k,h) su(mx(b,a,h),mu(mu(k,h),su(1.,h)))\n//#define mis2(a,b,k,h) (mix(b,a,h)-(k)*(h)*(1.-(h)))\n//#define mis(a,b,k) mis2(a,b,k,sat(u5(((b)-(a))/(k))))\n#define mis(a,b,k) mis2(a,b,k,sat(ad(mu(di(su(b,a),k),.5),.5)))\n#define mas(a,b,k) ne(mis(ne(a),ne(b),k))\n#define mes(a,b,k) ne(mis(   a ,ne(b),k))\n//sMinQuadratic mar()mir()mer() use the subroutine mima(),that unifies (smoothened by ar(k)) quadratic min()+max()+mex().\n//soft logic,by @paniq?   absurdly small epsilon evades a division by 0\nvec2 ar(float r){return vec2(r,mix(.5/(r+1e-15),0.,step(r,0.)));}//apolonean round union\n//uncaught use-case; max(-a,b),gets negated,which is just done by swapping a and b instead.\n//s.z,s.w:radius&scaling,as returned by ar() k is vec4() for the option of interpolating between multiple [k]\n#define mima4(a,b,k,d) (.5*(a+k.x*(b+k.w*d*d)))\n#define mima3(a,b,k) mima4(a,b,k,ma0(k.z-b))\n#define mima2(a,b,k) mima3(a+b,abs(a-(b)),k)\n#define mima(a,b,k) mima2(a,(b)*k.y,k)\n/* //use case examples that specialize the general function mima()\nfloat ma(float a,float b){return mima(a,b,vec4(1,1,0,0));}//max(a,b)\nfloat mi(float a,float b){return mima(a,b,vec4(-1,1,0,0));}//min(a,b)\nfloat me(float a,float b){return mima(a,b,vec4(1,-1,0,0));}//max(a,-b)\n//k is a circleRadius,[m*r] ignores negative k because it does k.z*k.z*k.w*/\n                      \n#define mi0(a) mi(a,0.)\n#define ma0(a) ne(mi0(-(a)))  \n                      \nfloat mar(float a,float b,float k){return mima(a,b,vec4(1,1,ar(k)));} // max( a,b,k)=-min(-a,-b,k)\nfloat mir(float a,float b,float k){return mima(a,b,vec4(-1,1,ar(k)));}//-max(-a,-b,k)= min( a,b,k)\nfloat mer(float a,float b,float k){return mima(a,b,vec4(1,-1,ar(k)));}// max( a,-b,k)=-min(-a,b,k)\n\nfloat recsum(vec2 a){return 1./(1./(a.x+a.y));}\n\n//#define mae(a,b,k) (log(exp(k*a)+exp(k*b))/k)//sMaxExponential\n#define resistor2(a,b  ) (a)*(b)    /((a)+(b))\n#define resistor3(a,b,c) ((a)*(b)*(c))/(1.+a*((b)*(c)*(c)))\n//(a)*(b)*(c)/((b)*(c+1.)+(a)*(b+1.))//smells like nonsense\n#define miso2(a,b    ,k) pow(resistor2(pow(a,k),pow(b,k)         ),1./(k))\n#define miso3(a,b,c  ,k) pow(resistor3(pow(a,k),pow(b,k),pow(c,k)),1./(k))\n\n//average of 2, of exponential smin(a.x,a.y,b)\n#define maAv(a,b) ((mae(a.x,-a.y,b)+a.x)*.5)//sAvgExponential\n\nvec4 demoSminBone3(vec2 u,vec2 m,vec2 n//have 4 distances to 3 muscles and 1 bone, and smin() them to each other:\n){float zoom=3.\n ;u*=zoom;m*=zoom;n*=zoom\n ;vec4 r=vec4(0,0,0,1)\n ;vec2 v=u-m\n ;v.x=mStretch(v.x,.7)//stretch sphere to capsule\n ;vec4 d=vec4(dd(u+vec2(1)),dd(v),dd(u-n),dd(u))//4 squared distances\n ;d=sqrt(d)\n ;d-=1.\n ;d.w=mae(-d.w,length(u-vec2(0,1))-.5,7.)//optionally a crescent-bone (kina hoof-shaped)\n ;d.w-=.5\n ;//d.x=box(u+vec2(1),vec2(1))//optionally overwrite with roundedBox\n ;d.xyz-=.3\n ;d.xyz-=cos(vec3(1,1.61,2.61))*.3+.3\n ;float cc=1.2\n ;float e=mie(mie(d.x,d.y,cc),mie(d.z,d.w,cc),cc)//for white skin outline\n ;//d.xy=vec2(mae(d.x,-d.y,4.),mae(d.y,-d.x,4.))//cude but not udefull for anatomy muscles\n ;float recTrip=1./(1./d.w+1./d.y)\n ;//for simplicity, mmuscles are rings, where only ever 2 muscles overlap around a bone\n ;//d.xyz=vec3(mae(d.x,-d.y,9.)+d.x+d.z,mae(d.y,-d.x,9.)+d.x+d.y,mae(d.z,-d.y,9.)+d.z+d.y)/3.;//muscles mix overlappingly\n ;//d.x=-miso3(-d.x,-d.y,-d.z,1.)\n //;d.xyz=vec3((mae(d.x,-d.y,9.)+d.x)*.5\n //           ,(mae(d.y,-d.z,9.)+d.y)*.5\n //           ,(mae(d.z,-d.z,9.)+d.z)*.5)\n ;float po=12.\n ;d.xyz=vec3(maAv(vec2(maAv(d.xz,po),d.y),po)\n            ,maAv(vec2(maAv(d.yz,po),d.x),po)\n            ,maAv(vec2(maAv(d.zx,po),d.y),po))//works because of comutativity of [m*e]  \n           //but it looks very ugly if the any 2 centers are close to each other\n ;float bb=6.\n ;d.xyz=vec3(mae(d.x,-d.w,bb),mae(d.y,-d.w,bb),mae(d.z,-d.w,bb))//smax(a,-b with the bone.\n ;vec4 hair=.1*d\n ;//d*=mix(vec4(1),vec4(.5),step(d,vec4(.5)))//nope, i wanted 2 smoothsteps.\n ;d=smoothstep(hair,-hair,d*(abs(d)+1.)+.2)//slim all interior shapes for free filler borders\n ;e=smoothstep(.01,-.01,e)\n ;d=sat(d)\n ;vec4 red  =vec4(1,0,0,1)*d.x\n ;vec4 green=vec4(0,1,0,1)*d.y\n ;vec4 blue =vec4(0,0,1,1)*d.z\n ;vec4 yello=vec4(1,1,0,1)*d.w\n ;vec4 white=vec4(1)*e\n ;r=white\n ;r=pdOver(yello,r)\n ;r=pdOver(blue,r)//porterDuff AlphaCompositing\n ;r=pdOver(green,r)\n ;r=pdOver(red,r)\n ;return r;}\n\nfloat miy(float a,float b,float r//https://www.shadertoy.com/view/XtccDr\n){float e=max(r*.02,(abs(a-b)/r));return min(a,b)-max(.01,(r*e*.75*(exp(1.-(e*2.5))))*.5/max(a,b));}\n// Commutative smooth minimum function.Provided by Tomkh,from Alex Evans's (aka Statix)talk:\nfloat mia(float a,float b,float k){float f=ma0(1.-abs(b-a)/k);return min(a,b)-k*.25*f*f;}\n#define smoothBump(x,y,z,w) smoothstep(x-z,x+z,w)*smoothstep(y+z,y-z,w)\n\n/**///--end__: analysis smin \n/**///--           \n/**///--start: analysis sabs smoothstep windowfunction hulls\n\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n/**///--end__: analysis sabs smoothstep windowfunction hulls \n/**///--           \n/**///--start: pattern debug\n                               \n//todo,, wallpaper tiling\n                               \n//needed to debug complex (number) functions.\n\n//inspired by https://www.shadertoy.com/view/4tG3Wh  \nfloat checkerBool(vec2 h){h=fract(h);return float(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nfloat checkerBool2(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(.5));return float(b.x==b.y);}\nfloat checkerBool2(vec3 h\n){h=fract(h)\n ;bvec3 b=greaterThan(h,vec3(.5))\n ;return float(b.x==b.y&&b.y==b.z);}\n//checkerBoolT oscillates xy comparators over time.\n                      \n#define checkerSign(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignS(v) mu(sg(mo(v,2.)-.5))\n#define checkerSignSt(v,t) mu(sg(mo(v,2.)-t))\n \n\n#define sm(a,b)smoothstep(a-10./500.,a,b)\nfloat PatternCircles(vec2 p,float m//giraffe bubbles of\n){p.x-=m*.5*step(0.,sin(pi*p.y/m)) //https://www.shadertoy.com/view/MsSyRz\n ;p=mod(p,m)-m*.5\n ;return 1.-sm(0.,(p.x*p.x+p.y*p.y)-1.);}\n\n/**///--end__: pattern debug\n/**///--\n/**///--start: pattern hash noise (take 2)\n\n// Cellular noise (\"Worley noise\") in 2D in GLSL. #version 120\n// Copyright (c) Stefan Gustavson 2011-04-19. All rights reserved.\n// This code is released under the conditions of the MIT license.\n// See LICENSE file for details.\n// https://github.com/stegu/webgl-noise\n\n// Modulo 7 without a division\n\nvec3 mod7(vec3 x){return x-floor(x*(1./7.))*7.;}\nvec3 mod289(vec3 x){return x-floor(x*(1./289.))*289.;}\nvec2 mod289(vec2 x){return x-floor(x*(1./289.))*289.;}\n\n// Permutation polynomial: (34x^2 + x) mod 289\nvec3 permute(vec3 x){return mod289((34.0 * x + 1.0) * x);}\n//vec3 permute(vec3 a){return mob89((34.*a+1.)*a);}//Permutation polynomial:(34x^2+x)mod 289\n\n// Cellular noise, returning F1 and F2 (closest and second closest) in a vec2.\n// Standard 3x3 search window for good F1 and F2 values\nvec2 cellular(vec2 P) {\n#define K 0.142857142857 // 1/7\n#define Ko 0.428571428571 // 3/7\n#define jitter 1.0 // Less gives more regular pattern\n\tvec2 Pi = mod289(floor(P));\n \tvec2 Pf = fract(P);\n\tvec3 oi = vec3(-1.0, 0.0, 1.0);\n\tvec3 of = vec3(-0.5, 0.5, 1.5);\n\tvec3 px = permute(Pi.x + oi);\n\tvec3 p = permute(px.x + Pi.y + oi); // p11, p12, p13\n\tvec3 ox = fract(p*K) - Ko;\n\tvec3 oy = mod7(floor(p*K))*K - Ko;\n\tvec3 dx = Pf.x + 0.5 + jitter*ox;\n\tvec3 dy = Pf.y - of + jitter*oy;\n\tvec3 d1 = dx * dx + dy * dy; // d11, d12 and d13, squared\n\tp = permute(px.y + Pi.y + oi); // p21, p22, p23\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 0.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d2 = dx * dx + dy * dy; // d21, d22 and d23, squared\n\tp = permute(px.z + Pi.y + oi); // p31, p32, p33\n\tox = fract(p*K) - Ko;\n\toy = mod7(floor(p*K))*K - Ko;\n\tdx = Pf.x - 1.5 + jitter*ox;\n\tdy = Pf.y - of + jitter*oy;\n\tvec3 d3 = dx * dx + dy * dy; // d31, d32 and d33, squared\n\t// Sort out the two smallest distances (F1, F2)\n\tvec3 d1a = min(d1, d2);\n\td2 = max(d1, d2); // Swap to keep candidates for F2\n\td2 = min(d2, d3); // neither F1 nor F2 are now in d3\n\td1 = min(d1a, d2); // F1 is now in d1\n\td2 = max(d1a, d2); // Swap to keep candidates for F2\n\td1.xy = (d1.x < d1.y) ? d1.xy : d1.yx; // Swap if smaller\n\td1.xz = (d1.x < d1.z) ? d1.xz : d1.zx; // F1 is in d1.x\n\td1.yz = min(d1.yz, d2.yz); // F2 is now not in d2.yz\n\td1.y = min(d1.y, d1.z); // nor in  d1.z\n\td1.y = min(d1.y, d2.x); // F2 is in d1.y, we're done.\n\treturn sqrt(d1.xy);\n}\n\n\n\n/**///--end__: pattern hash noise (take 2)\n/**///--\n/**///--start: pattern hash noise (take 1)  (incompatible, broken and a bit dumb\n\n\n//hashes are named by output type,NEVER by input type\n//hfd() is slower but slighly better than fractSin()\n//hfd1 mirrors at y=x and has strong banding on diagonals.\n//fract(dot(1031))hash summer 2018 seems ot be generally superior to fract(sin())hashes\nvec3 g3(v0 a){return vec3(a);}                        \nvec3 g3(vec2 a){return a.xyx;}\nvec3 g3(vec3 a){return a;}\nvec4 g4(v0 a){return vec4(a);}\nvec4 g4(vec2 a){return a.xyxy;}\nvec4 g4(vec3 a){return a.xyzy;}\nvec4 g4(vec4 a){return a;}\n//[hfd*] hashes by David Hoskins,Creative Commons Attribution-ShareAlike 4.0 International Public License\n//parent https://www.shadertoy.com/view/4djSRW\n#define hs vec4(.1031,.1030,.0973,.1099)\n//#define HASHSCALE3 vec3(443.897,441.423,437.195,444.129)//For smaller input rangers like audio tick or 0-1 UVs use these...\n#define hout1(a)fract((a.x+a.y)*a.z)\n#define hout2(a)fract((a.xx+a.yz)*a.zy)\n#define hout3(a)fract((a.xxy+a.yzz)*a.zyx)\n#define hout4(a)fract((a.xxyz+a.yzzw)*a.zywx)\n#define h3mid(a)((a)+dot(a,a.yzx+19.19))\n#define h4mid(a)((a)+dot(a,a.wzxy+19.19))\n//only hash4 takes in vec4.all hash functions take vey1,v3c2,vec3 in (a vec4 generalizations is a mild overkill for most vec2,vec3 contexts)\n#define hfd1(a)hout1(h3mid(fract(hs.x*g3(a))))\n#define hfd2(a)hout2(h3mid(fract(hs.xyz*g3(a))))\n#define hfd3(a)hout3(h3mid(fract(hs.xyz*g3(a))))\n#define hfd4(a)hout4(h4mid(hs*g4(a)))\n//not sure if its this shaders fault,likely a fract()error,but the avobe hsh gives bad lines.\n//float hfd1(float n){ return fract(sin(n)*1e4);}\n\n//hash by dr2,incompatible with a more common hash,good for fast fbm with normals (labeled: h41-noise)\n#define vec1 float\nvec1 mx(vec1 a,vec2 b){return mix(b.x,b.y,a);}\nvec1 bilin(vec4 a,vec2 b){return mix(mx(b.x,a.xy),mx(b.x,a.zw),b.y);}\n#define herm32(a) ((a)*(a)*(3.-2.*(a)))\n//noise by dr2 is a union of \"penguins\": https://www.shadertoy.com/view/4lfBWB\n//and \"train ride\":                      https://www.shadertoy.com/view/4s2Sz3\n//and \"Books and Stairs 2\"               https://www.shadertoy.com/view/MtsfRl\nconst vec1 cHashM=43758.54;\nvec4 hSeed=vec4(0,1,57,58);//vec3(0,37,39,41); //vec4(0,1,57,113);\nvec1 hash1(vec2 p){return fract(sin(dot(p,hSeed.yz))*cHashM);}\nvec1 hash1(vec3 p){return fract(sin(dot(p,hSeed.yzw))*cHashM);}\nvec2 hash2(vec1 p){return fract(sin(p+vec2(0,1))*cHashM);}\nvec2 hash2(vec2 p){return fract(sin(vec2(dot(p,hSeed.yz),dot(p+vec2(1,0),hSeed.yz)))*cHashM);}\nvec4 hash4(vec3 p){vec2 e=vec2(1,0);return fract(sin(vec4(dot(p,hSeed.yzw),dot(p+e.xyy,hSeed.yzw),dot(p+e.yxy,hSeed.yzw),dot(p+e.xxy,hSeed.yzw)))*cHashM);}\nvec4 hash4(vec1 p){return fract(sin(p+hSeed)*cHashM);}\nvec1 noise1(vec1 p){return mx(herm32(fract(p)),hash2(floor(p)));}\nvec1 noise1(vec2 p){vec2 f=floor(p);p=herm32(fract(p));return mx(p.x,mix(hash2(f),hash2(f+vec2(0,1)),p.y));}\nvec1 noise1(vec3 p){vec3 f=floor(p);p=herm32(fract(p));return bilin(mix(hash4(f),hash4(f+vec3(0,0,1)),p.z),p.xy);}\nvec3 noise3(vec2 p){vec2 f=fract(p),g=f*f,u=g*(3.-2.*f);vec4 h=hash4(dot(floor(p),hSeed.yzw.xy))\n ;return vec3(h.x+(h.y-h.x)*u.x+(h.z-h.x)*u.y+(h.x-h.y-h.z+h.w)*u.x*u.y,30.*g*(g-2.*f+1.)*(vec2(h.y-h.x,h.z-h.x)+(h.x-h.y-h.z+h.w)*u.yx));}\n//gradient shaded volumetric animated noise,labeled [afo-tri-noise],from \"dust storm\" by @stormoid\n//has strong diagonals and strong short periodicity.\n#define perm2(k,a) k(a.x+k(a.y))\n#define perm3(k,a) k(a.z+perm2(k,a.xy))\nvec3 afo3(vec3 p){return vec3(perm2(u5cos2,p.zy),perm2(u5cos2,p.zx),perm2(u5cos2,p.yx));}\nfloat noise1t(vec3 p,float spd//triangle-interpolation noise.\n){float z=1.4,r=0.\n ;p=p*9.+vec3(7,13,21)//optionally evade the strong [y=x mirror] that afo3() has\n ;vec3 b=p\n ;for(float i=0.;i<4.;i++//multi-octaves,but the afo3(()function also implies a sqivel-rotation.\n ){vec3 dg=afo3(b*2.)\n  ;p+=(dg+      spd);b*=1.8;z*=1.5;p*=1.2\n//;p+=(dg+iTime*spd);b*=1.8;z*=1.5;p*=1.2\n  ;r+=perm3(u5cos2,p)/z //a weird way of using define,deal with it\n  ;b+=.14;};return r;}//the hyperplanes are aligned to the lattice,and because of that alignment the animation does not look too \"random\"\n//voronoi/cellular\n//noise-open-challenge:\n//there exist ways to do a 2pass of 2 voronoi,first pass is 3x3 square lattice 9tap,with 3 buffered values.\n//,second pass is 5x5 square lattice 25 tap.\n//and the result is a [shortest distance to cell border]\n//and i would like to have this here,with a planar distance and/or a 3d distance to a cell border\n\n\nv22 ff(vec3 a){return v22(fract(a),floor(a));}//BUT here mat3 would just waste memory and mat32 mat23 are less comatible.\nv11 ff(vec2 a){return v11(fract(a),floor(a));}\nvec2 ff(float a){return vec2(fract(a),floor(a));}\nv22 su(vec2 a,v22 b){return v22(a.x-b.a,a.y-b.b);}\nv22 mu(float a,v22 b){return v22(a*b.a,a*b.b);}\n/**/\nmat3 su(mat3 a,mat3 b){return a-b;}\nmat3 addf(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n\n//fast cellular noise,optimized by ollj\n//mouse.xy is basically \"salting hashes\"\n//imouse.x sets jitter range[0..1] 0 is squares,1 is maximum jitter. (known bug,iMouse.x-scaling for lower left quadrant is a bit bad here)\n//imouse.z sets hash dividend,is ideally 1/7,but others can be fine too.use like a salt.\n//lower left quadrant is 2d input noise2x2x2\n//the other 3 quadrants are 3d input noises3x3x3 where .z is iTime.\n//the 3 quadrants inputs are swiveled differently to debug 3 orthogonal hyperplanes in one view.\n//return value .x is L1,.y is L2 according to [worley noise]\n//this uses a lot of mat2,or the v33 struct,and permute()functions similar to ahsima-simplex noise,defers the sorting,for performance.\n//Cellular noise (\"Worley noise\")in 3D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license.\n//See LICENSE file for details.\n//https://github.com/stegu/webgl-noise\n//#define mous (iResolution.xyxy-iMouse.xyzw)//flip mouse everywhere,for shadertoy fun\n//mat3 fr(mat3 a){return mat3(fr(a[0]),fr(a[1]),fr(a[2]));} //namespace conflict\n//mat3 fl(mat3 a){return mat3(fl(a[0]),fl(a[1]),fl(a[2]));}\nmat3 addd(mat3 a,vec3 b){return mat3(a[0]+b.x,a[1]+b.y,a[2]+b.z);}\n//mat3 addF(mat3 a,vec3 b){return mat3(a[0]+b,a[1]+b,a[2]+b);}//contextual namespace hell.\n\n//manespace conflict evaded \nmat3 ma3f(vec3 a,float b,float c){return mat3(a,vec3(b),vec3(c));}\n//th7 is for the 2d noise,should be (iResolution.y/7.),BUT i managed to make other values look fine,too\n#define th7 (200./500.)//usually==1./7.,because mod(a,7)is famous for old LCGs.\n//th8 is for the 3d noise,should be (iResolution.y/7.),other values may work,but they tend to barely work at all,try only simple factors of 1/7\n#define th8 (500./7./mix(1.,4.,200./500.))//seems to be fine bounds,not too sure.\n//500 substitutes iResolution.y \n//200 substitutes mous.y     \nvec3 frr(vec3 a){return fract(a);}\nmat3 frr(mat3 a){return mat3(frr(a[0]),frr(a[1]),frr(a[2]));}\n#define fl(a) (a-frr(a))\n      \nvec3 mod2893d(vec3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nmat3 mod2893d(mat3 x){return x-fl(x*(1./289.))*289.;}//Modulo 289 without a division (only multiplications)\nvec3 mod73d(vec3 x){return x-floor(x*(1.0/th8))*th8;}//Modulo 7 without a division\nmat3 mod73d(mat3 x){return x-fl(x*(1.0/th8))*th8;}\n//Permutation polynomial:(34x^2+x)mod 289\nvec3 permute3d(vec3 x){return mod2893d((34.0*x+1.)*x);}\nmat3 permute3d(mat3 x){return mod2893d((34.0*x+1.)*x);}\n#define Kcel 1./th8//1/7\n#define Kcel2 1./th8/th8//1/(7*7)\n#define Kcelo (1.-Kcel)*.5//1/2-Kcel/2\n#define Kcelz 1./(th8-1.)//1/6\n#define Kcelzo .5-2./(th8-1.)//0.416666666667//1/2-1/6*2\n//500 substitutes iResolution.y \n//200 substitutes mous.y     \nmat3 perM3(vec3 p){return mat3(permute3d(p-1.),permute3d(p),permute3d(p+1.));}\nmat3 perM3(vec3 p,vec3 b){vec3 p1=permute3d(p+b.x-1.);vec3 p2=permute3d(p+b.y);vec3 p3=permute3d(p+b.z+1.);return mat3(p1,p2,p3);}\n#define maa(a,b,c) ma3f(pf[0],pf[1].a,pf[2].b)+jitter*c\n#define mat3dd(a)a[0]*a[0]+a[1]*a[1]+a[2]*a[2]\n#define mat3ddmaa(a,b,c)mat3dd((maa(a,b,mat3(ox3[c],oy3[c],oz3[c]))))\n//vec3 square(v33 a){return a.a*a.a+a.b*a.b;} //remoived for old structure\n//todo,make it traversable bny getting distance2Border.\n\n//a lot of noise fails due to high domain su() incompatibility\n      \n//Cellular noise (\"Worley noise\")in 2D in GLSL.\n//Copyright (c)Stefan Gustavson 2011-04-19.All rights reserved.\n//This code is released under the conditions of the MIT license of://https://github.com/stegu/webgl-noise\n//mod(a,289.)without a division (only multiplications),because [mod(33.,33.)!=0] on too many implementations.\nvec3 mob89(vec3 a){return a-floor(a*(1./289.))*289.;}\nvec2 mob89(vec2 a){return a-floor(a*(1./289.))*289.;}\nv11  mob89(v11  a){return v11(a.a,a.b-floor(a.b*(1./289.))*289.);}//vers ypecial use case\nmat2 mob89(mat2  a){return mat2(a[0],a[1]-floor(a[1]*(1./289.))*289.);}//vers ypecial use case\nvec3 modth7(vec3 a){return a-floor(a*th7)/th7;}//Modulo 7 without a division\nv22  modth7(v22  a){return v22(a.a,(a.b-floor(a.b*th7)/th7)*th7);}//special case for a #define\n#define tt3(p,f,j,m,a)square(su(j,(v22(vec3(a),f),mu(m,mu(m,modth7(ff(p*th7)))))))\n#define permi(c)p=permute(o+k.b.y+px.c)\n#define ppm(d,e,c)r[d]=tt3(p,f,k.a,m,e);permi(c)\n//a lot of noise fails due to high domain su() incompatibility\n      \n      \n/**///--end__: pattern hash noise\n/**///--                         \n/**///--start: complex number triginometry \n\n//one idea is to define all functions as vec4,and then expand to vec4,and then just ignore most domains later on.\n//this should work in some contexts,but may not work in all contexts,this frame can make a library much smaller,but it also is an overhead.\n//return vec4()and explicitly fill all unused domains with n\nvec4 an(vec4 a,float n){return a;}\nvec4 an(vec3 a,float n){return vec4(a,n);}\nvec4 an(vec2 a,float n){return an(vec3(a,n),n);}\nvec4 an(vec2 a,vec2 n){return vec4(a,a);}//for c2()and c4()this is mod2\nvec4 an(float a,float n){return an(vec2(a,n),n);}\n#define ana1(a)an(a,1.)\n#define anaa(a)an(a,a)\n//#define ana0(a)an(a,0)//leat worksafe\n//#define anaa(a)an(a,a)//unpredictable worksafety\n//exmaple below defines c2()as framed c4;\n#define c4(a)((a)*vec4(1,-1,1,-1))\n//c22(c)-(c.a-c.b*i)\n#define c22(a)c4(anaa(a)).xy  //namespace conflict\nvec2 cs(v1 a){return vec2(cos(a.x),sin(a.y));}\nvec2 cs(v0 a){return cs(vec2(a,a));}    \n                               \n//atan2() is a bit tricky, thankfully commonly only defined for v1.\nv0 ata(v0 a){return atan(a);}//atan(x/y) has limited range and is non branching.\nd000 ata(d000 a){v0 b=a.a*a.a+1.;v0 c=b*b;return d000(atan(a.a),a.a/b,-(b-2.)/b,2.*a.a*(a.a-4.)/(b*c));}\nd00  ata(d00  a){v0 b=a.a*a.a+1.;v0 c=b*b;return d00 (atan(a.a),a.a/b,-(b-2.)/b);}\nd0   ata(d0   a){v0 b=a.a*a.a+1.;v0 c=b*b;return d0  (atan(a.a),a.a/b);}\n\n//expliicit atan2() //https://en.wikipedia.org/wiki/Atan2\nv0 atand(v0 x,v0 y){//return atan(y,x);//2 branches, goes full circle.\n if(x >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}\n\n/*\nd00 atand(d00 x,d00 y){//return atan(y,x);//2 branches, goes full circle.\n if(x.a >0.)return atan(di(y,x));\n if(y >0.)return  su( pi*.5,atan(di(x,y)));\n if(0.>y )return  su(-pi*.5,atan(di(x,y)));\n if(0.>x )return  ad( pi   ,atan(di(y,x)));\n return 0.;}/**/\nv0 atand(v1 a){return atand(a.y,a.x);}\n//but that means it only cares for 2 domains?\n//d1 atand(d1 a,d1 b){return a;\n\n/*\ntodo, all the trigonometry functions with glES100 to gles300 porting\n*/\n\nv0 su(v1 a){return a.x-a.y;}\n                               \n#define le(a) sqrt(dd(a))\nvec2 sub2(vec4 a){return a.xy-a.zw;}//substract in modulo 2  \n//real and imaginary parts for polar z\nv0 arg(v1 a){return atan(a.y,a.x);}\nv1 c2p(v1 a){return v1(arg(a),le(a));}\nv1 p2c(v1 a){return v1(co(a.x),si(a.x))*a.y;}\nv0 real(v1 z){return p2c(z).x;return z.s*co(z.t);}\nv0 imag(v1 z){return p2c(z).y;return z.s*si(z.t);}\n\nv1 crCo(v1 a){return sqrt(length(a)+c22(a.x));}//core of complex root function,lacks sign adjustment and scaling!\n\nv1 ciCo(v1 u,v1 z,v0 r){return v1(u.y-u.x+r*r,2.*z.x*z.y);}//core of complex root function,for 3 inverse trigs\n\n//param2&2*x complex number polar transforms;[Principal branch==0th branch] is implied unless Cth branch can be set explicity.\nv1 sqc(v1 a){v0 n=a.x+length(a);return v1(n,a.y)/sqrt(2.*n);}//sqrt(z)-sqrt((sqrt(a^2+b^2)+a)/2)+sgn(b)sqrt((sqrt(a^2+b^2)-a)/2)i,complex root\nv3 sqc(v3 a){v3 c=v3(crCo(a.xy),crCo(a.zw));c.yw*=sign(a.yw);return c*.5;}//parallel sqrt(z)\nv1 po2c(v1 c){v1 d=c*c;return v1(d.x-d.y,2.*c.x*c.y);}//v1 po2c(v1 a){return muc(a,a);return v1(sub(a*a),2.*a.x*a.y);}//complex square\nv1 po3c(v1 z){v0 p=z.x*z.x,q=z.y*z.y;return z*v1(p-3.*q,3.*p-q);}//z*z*z=a*(a*a-3*b*b)+b*(3*a*a-b*b)*i,complex cube\nv1 recc(v1 a){if(a.x==0.)return v1(1e10);return c22(a)/dd(a);}//reciprocal/inverse of z;1/z=(a-b*i)/(a*a+b*b),inverse of z;\nv1 lgc(v1 a){a=c2p(a);a.x=log(a.x);return a;}//return v1(log(dd(a))*.5,arg(a));}\nv3 lgc(v3 a){return v3(lgc(a.xy),lgc(a.zw));}//parallel lgc()\nv1 suc(v1 a,v1 b){return a-b;}v1 adc(v1 a,v1 b){return a+b;}///complex addition is trivial\nv1 muc(v1 a,v1 b){return a*b.x+perp(a)*b.y;}//return a*mat2(b.x,-b.y,b.yx);}//complex multoplication\nv1 muc(v1 a,v1 b,v1 c){return muc(muc(a,b),c);}//z*w*x=ace-bde-adf-bcf+(acf-bdf+ade+bce)*i//complex mult\nv1 muc(v3 a){return muc(a.xy,a.zw);}//parallel mult\nv1 dic(v1 a,v1 b){if(a.x==0.)return v1(65535.);return a*mat2(b,-b.y,b.x)/dd(b);}//return(a*b.x-perp(a)*b.y)/dd(b);}//complex division\nv1 lgc(v1 a,v1 b){return dic(lgc(b),lgc(a));}//principal branch of the logarithm base b of z,b is complex;\nv1 lgc(v1 a,v0 c){return v1(log(dd(a))*.5,arg(a)+c*tau);}//Cth logarithm-base-e-branch of z,0th==principal,log   z=log(a^2+b^2)/2+(arg(z)+n2p)i\nv1 exc(v1 a){return cs(a.y)*exp(a.x);}//pow(exp,a)-pow(eul,a)-pow(eul,a(cos(b)+sin(b)*i))\n//v1 lgc(v1 a,v0 c){a=c2p(a);return v1(log(a.x),a.y+c*tau);}//should be the same!\nv1 poc(v1 a,v1 b){return exc(muc(b,lgc(a)));}//pow(b,z)-exp(b*log(a))//0th==principal   branch of pow(z,W)\nv1 poc(v1 w,v1 z,v0 c){return exc(muc(w,lgc(z,c)));}//Cth branch of pow(z,w)\nv1 lgc(v1 a,v1 b,v0 c){return dic(lgc(b,c),lgc(a));}//Cth logarithm-base-a-branch of b,0th==principal,log_b z=log(b)/log(a)\nv1 wrtc(v1 a,v1 b){return exc(dic(lgc(b),a));}//0th==principal   branch of pow(z,(1/w))\nv1 wrtc(v1 a,v1 b,v0 c){return exc(dic(lgc(b,c),a));}//Cth branch of pow(z,(1/w))\n//v1 sqc(v1 z){v1 c=sqrt((length(z)+c22(z.x))*.5);c.y*=sign(z.y);return c;}//significantly worse near [.y=0.&&x>0]\n\nv1 sic(v1 z){return .5*cs(z.x).yx*(exp(z.y)+c22(exp(-z.y)));}//v1 sic(v1 z){return v1(0.5*sin(z.x)*(exp(z.y)+exp(-z.y)),.5*cos(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted  v1 sic(v1 c){v1 d=exp(c2(c.y));return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 si2c(v1 c){v1 d=v1(exp(c.y),1);return v1(sin(c.x)*(d.x+d.y)*.5,cos(c.x)*(d.x-d.y)*.5);}\nv1 coc(v1 z){return .5*c22(cs(z.x))*(exp(z.y)+c22(exp(-z.y)));}\n\n//obsoleted v1 coc(v1 z){ return v1(0.5*cos(z.x)*(exp(z.y)+exp(-z.y)),-0.5*sin(z.x)*(exp(z.y)-exp(-z.y)));}\n//obsoleted v1 coc(v1 c){v1 d=exp(c2(c.y));return v1(cos(c.x)*(d.x+d.y)*.5,-sin(c.x)*(d.x-d.y)*.5);}\nv1 ta2c(v1 c){v1 d=exp(c22(c.y));v0 e=cos(c.x),s=(d.x-d.y)*.5;return v1(sin(c.x)*e,s*(d.x+d.y)*.5)/(e*e+s*s);}\nv1 tac(v1 z){return dic(sic(z),coc(z));}//tan(z)-sin(z)/cos(z),complex tangent==ta2c()\nv1 cotc(v1 z){return dic(coc(z),sic(z));}//cot(z)-cos(z)/sin(z),complex cotangent\n////hyperbolics\n//sinh z=sinh(a)cos(b)+cosh(a)sin(b)i,hyperbolic sine\nv1 sihc(v1 z){return .5*cs(z.y)*(exp(z.x)+c22(exp(-z.x)).yx);}//v1 sinh(v1 z){ return 0.5*v1((exp(z.x)-exp(-z.x))*cos(z.y),(exp(z.x)+exp(-z.x))*sin(z.y));}\n//v1 sinh2c(v1 z){z=c22(z).yx;return sic(z);}//close to sinhc but not the same,phase is off nicely\n//cosh(z)-cosh(a)cos(b)+sinh(a)sin(b)i,hyperbolic cosine(swivel-rotate works fine here)\nv1 cohc(v1 z){return coc(c22(z.yx));}//v1 cosh(v1 z){ return v1(0.5*(exp(z.x)+exp(-z.x))*cos(z.y),0.5*(exp(z.x)-exp(-z.x))*sin(z.y));}\n//gl2.0 v1 tahc(v1 z){return dic(sinh(z),cosh(z));}//tanh(z)-sinh(z)/cosh(z),hyperbolic tangent\n//gl2.0 v1 cothc(v1 z){return dic(cosh(z),sinh(z));}//coth(z)-cosh(z)/sinh(z),hyperbolic cotangent\n//gl2.0 sechc(v1 z){return recc(cosh(z));}//sech(z)-1/cosh(z),hyperbolic secant\n//gl.0 v1 cschc(v1 z){return recc(sinh(z));}//csch(z)-1/sinh(z),hyperbolic cosecant\n//these look stranger than they likely shozld,possibly buggy\n//arsic is WAY too noisy.\nv1 arsic(v1 z){return c22(lgc(perp(z)+sqc(c22(po2c(z.yx)))+v1(1,0)).yx);}//arsic(z)--log(a*i-b+sqrt(1+b*b-a*a-2abi))*i,inverse sine\n//v1 arsic(v1 z){v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(-z.y+a.x,z.x+a.y));return v1(a.y,-a.x);}\nv1 arcoc(v1 z){return-c22(lgc(z+c22(sqc(po2c(z.yx)+v1(1,0)).yx)).yx);}//arcoc(z)-log(a+bi-sqrt(1+b^2-a^2-2abi)i)i,inverse cosine\n//v1 arcoc(v1 z){ v1 a=sqc(v1(1.0+z.y*z.y-z.x*z.x,-2.0*z.x*z.y));a=lgc(v1(z.x+a.y,z.y-a.x));return v1(-a.y,a.x);}\nv1 csec(v1 z){return recc(coc(z));}//sec(z)-1/cos(z),complex __secant==complex inverse of complex cosine\nv1 ccsc(v1 z){return recc(sic(z));}//csc(z)-1/sin(z),complex cosecant==complex inverse of complex __sine\n//i am not too sure about the next 5 inverses;likely made some silly error,needs debugging\n//arcotc(z)-i*(log((a^2+b^2-b-ai)/(a^2+b^2))-log((a^2+b^2+b+ai)/(a^2+b^2)))*.5,inverse cotangent\n//arcotc/(seems to be bad code\nv1 arcotc(v1 z){v0 r=z.x*z.x+z.y*z.y;return sub2(c4(lgc((v3(z.yx,-z.yx)+v3(r,0,r,0)).yxzw/r)))*.5;}//v1 arcotc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=lgc(v1(p+q-z.y,-z.x)/r);v1 b=lgc(v1(p+q+z.y,z.x)/r);return v1(b.y-a.y,a.x-b.x)/2.0;}\n//artac(z)-i*(log(1+b-ai)-log(1-b+ai))*.5 ,inverse tangent\n//tahc(artanh(c))has some symmetry,but may still be broken\n//artac appears broken\nv1 artac(v1 z){return sub2(c4(lgc(v3(1,0,1,0)-c22(z.yx).xyxy).yxwz))*.5;}//v1 artac(v1 z){ v1 a=lgc(v1(1.0+z.y,-z.x));v1 b=lgc(v1(1.0-z.y,z.x));return v1(b.y-a.y,a.x-b.x)/2.0;}\n//arcsec(csec(c))arcsec(ccsc(c))looks almost good\n//arcsec(z)--log((a+sqrt((a^2+b^2)^2-a^2+b^2+2abi)i-bi)/(a^2+b^2))i,inverse secant\nv1 arcsec(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(sub2(c4(v3(z,sqc(ciCo(u,z,r)).yx)))).yx)+v1(0.,log(r));}//v1 arcsec(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(z.x-a.y,a.x-z.y));return v1(a.y,log(r)-a.x);}\n//arccsc(csec(c))arccsc(ccsc(c))looks good\n//arccsc(z)--log((sqrt((a^2+b^2)^2-a^2+b^2+2abi)+b+ai)/(a^2+b^2))i,inverse cosecant\nv1 arccsc(v1 z){v1 u=v1(z.x*z.x,z.y*z.y);v0 r=su(u);return c22(lgc(z.yx+sqc(ciCo(u,z,r))).yx)+v1(0.,log(r));}//v1 arccsc(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r-p+q,2.0*z.x*z.y));a=lgc(v1(a.x+z.y,a.y+z.x));return v1(a.y,log(r)-a.x);}\n//arcsch(z)-log((sqrt((a^2+b^2)^2+a^2-b^2-2abi)+a-bi)/(a^2+b^2)),//inverse hyperbolic cosecant\nv1 arcsch(v1 z){v1 u=z*z;v0 r=su(u);return lgc(c22(z)+sqc(ciCo(u.yx,z,r)))-v1(0,log(r));}//v1 arcsch(v1 z){ v0 p=z.x*z.x;v0 q=z.y*z.y;v0 r=p+q;v1 a=sqc(v1(r*r+p-q,-2.0*z.x*z.y));a=lgc(v1(a.x+z.x,a.y-z.y));return v1(a.x-log(r),a.y);}\n////inverse hyperbolics\n//arsinh looks messy,likely broken\nv1 arsinh(v1 z){return lgc(z+sqc(po2c(z)+v1(1,0)));}//arsinh(z)-log(a+bi+sqrt(a^2-b^2+1+2abi)),inverse hyperbolic sine\n//arsinh looks almost okay,likely broken\nv1 arcosh(v1 z){return lgc(z+muc(sqc(z.xyxy+v3(1,0,-1,0))));}//arcosh(z)-log(a+bi+sqrt(a+1+bi)sqrt(a-1+bi)),inverse hyperbolic cosine\n//artanh(z)-log((1-a^2-b^2+2bi)/(1+a^2+b^2-2a))/2,inverse hyperbolic tangent\n//artanh(artac(c))is uniform ,artac(artanh(c))is white\nv1 artanh(v1 z){v0 r=1.-su(z*z);z*=2.;return .5*lgc(-v1(r,z.y)/(r+z.x));}//v1 artanh(v1 z){v0 r=z.x*z.x+z.y*z.y;return lgc(v1(1.0-r,2.0*z.y)/(1.0+r-2.0*z.x))/2.0;}\n//cothc(arcoth(c))looks somehwat passable\n//arcoth(z)-log((a^2+b^2-1-2bi)/(a^2+b^2-2a+1))/2,inverse hyperbolic cotangent\nv1 arcoth(v1 z){;v0 r=z.x*z.x+z.y*z.y-1.;z*=-2.;return .5*lgc(v1(r,z.y)/(r+2.+z.x));}//v1 arcoth(v1 z){ v0 r=z.x*z.x+z.y*z.y;return lgc(v1(r-1.0,-2.0*z.y)/(r-2.0*z.x+1.0))/2.0;}\n//arsech(z)-log((sqrt(a^2-b^2-(a^2+b^2)^2-2abi)+a-bi)/(a^2+b^2)),inverse hyperbolic secant\nv1 arsech(v1 z){v0 r=su(z*z);return lgc(c22(z)+muc(sqc(v3(-r,0,r,0)+c22(z).xyxy)))-v1(log(r),0);}//ok-ollj\n                \nvec4 demoComplex(vec2 u,vec2 m,vec2 n\n){u=c2p(u/4.);m=c2p(m/4.);u.x/=pi;m.x/=pi\n ;//u=sqc(u);//u=sqc(vec4(u,m)).xy\n ;//u=suc(u,m);//u=adc(u,m);\n ;u=dic(u,m);//u=muc(u,m)\n ;//u=po2c(u)\n ;//u=po3c(u)\n ;//u=poc(u,m);//u=poc(u,m,n.x)\n ;//u=recc(u)\n ;//u=lgc(u);//u=lgc(u,m);//u=lgc(u,n.x);//u=lgc(u,m,n.x)\n ;//u=exc(u)\n ;//u=wrtc(u,m);//u=wrtc(u,m,n.x)\n ;//u=si2c(u)//;u=sic(u) ;u=coc(u)\n ;//u=cotc(u)\n ;//u=tac(u);//u=ta2c(u);// cotc(u)\n ;//u=sihc(u);u=cohc(u);u=tahc(u);u=cothc(u);u=sechc(u);u=cschc(u)\n ;//u=arcoc(coc(u))\n ;//u=csec(u);//u=ccsc(u);//u=arcotc(u);//u=artac(u)\n ;//u=arcsec(u);//u=arccsc(u);//u=arcsch(u)\n ;//u=arsinh(u);//u=arcosh(u);//u=artanh(u);//u=arcoth(u);//u=arsech(u)\n ;//u=p2c(u)\n ;float c=checkerBool(u)//1.- for sechc()\n ;vec4 a=vec4(fract(u*2.),c,c*.9)\n ;a.xyz*=a.w\n ;return a;}                         \n                               \n\n/**///--end__: complex number triginometry \n/**///--\n/**///--start: sort\n                               \n#define minx(a,b)mix(b,a,step(a.x,b.x))\n#define manx(a,b)mix(a,-b,step(a.x,-b.x))\n#define maxx(a,b)-minx(-a,-b)\nint getPosLarge(vec3 a//return position of largest  value [0..2]          \n){if(a.x>a.y){if(a.x>a.z)return 0;if(a.y>a.z)return 1;return 2\n       ;}else{if(a.y>a.z)return 1;return 3;}}\nint getPosSmall(vec3 a//return position of smallest value [0..2]          \n){if(a.x<a.y){if(a.x<a.z)return 0;if(a.y<a.z)return 1;return 2\n       ;}else{if(a.y<a.z)return 1;return 2;}}\nint getPosMid(vec3 a//return position of middle value [0..2]          \n){if(a.x<a.y){if(a.y<a.z)return 1;if(a.z<a.x)return 0;return 1  \n       ;}else{if(a.z<a.y)return 1;if(a.x<a.z)return 1;return 3;}}\nvec3 getPosLargeV(vec3 a){vec3 r=vec3(0);r[getPosLarge(a)]=1.;return r;}//return vector that indicates smalles value with a [1]   \nvec3 getPosSmallV(vec3 a){vec3 r=vec3(0);r[getPosSmall(a)]=1.;return r;}//return vector that indicates smalles value with a [1]\n//vec3 getPosMidV  (vec3 a){return vec3(1)-getPosLargeV(a)-getPosSmallV(a);}//dumb and slow but works\n      \n\n      \nv0 sh4(v0 x){return x*x*x*(x*(x*6.-15.)+10.);}\n\n\n//hash & simplex noise from https://www.shadertoy.com/view/Msf3WH\nv1 hash(v1 p){p=v1(dot(p,v1(127.1,311.7)),dot(p,v1(269.5,183.3)))\n ;return fract(sin(p)*43758.5453123)*2.-1.;}//returns -.5 to 1.5. i think.\nv0 noise(in v1 p\n){const v0 K1 = 0.366025404 // (sqrt(3)-1)/2;\n ;const v0 K2 = 0.211324865 // (3-sqrt(3))/6;\n ;v1 i=floor(p+(p.x+p.y)*K1)\n ;v1 a=p-i+(i.x+i.y)*K2\n ;v1 o=(a.x>a.y) ? v1(1.0,0.0) : v1(0.0,1.0) //v1 of = 0.5 + 0.5*v1(sign(a.x-a.y), sign(a.y-a.x));\n ;v1 b=a-o+K2\n ;v1 c=a+u2(K2)\n ;v2 h=max( 0.5-v2(dot(a,a), dot(b,b), dot(c,c) ), 0.0 )\n ;v2 n=h*h*h*h*v2( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)))\n ;return dot( n, v2(70.0));}\nv0 noise01(v1 p){return clamp((noise(p)+.5)*.5, 0.,1.);}\n\nv0 dtoa(v0 d,v0 a){return sat(1./(clamp(d,1./a,1.)*a));}\n\nv0 sdAxisAlignedRect(v1 uv, v1 tl, v1 br//rounded rectangle\n){v1 d = max(tl-uv, uv-br)\n ;return length(max(v1(0.0), d)) + min(0.0, max(d.x, d.y));}\n\nv0 rand(v1 co){return fract(sin(dot(co.xy ,v1(12.9898,78.233))) * 43758.5453);}\nv0 rand(v0 n){return fract(cos(n*89.42)*343.42);}\nv0 paperbleed(v1 u){return (2.+rand(u.y)+rand(u.x))*30.;}//ink bleeds on papyrus.\n\n\n                 \n//project point [a] onto line trough vecN(0) and vecN([b])\nv1 project(v1 a,v1 b){return b*dot(a,b)/dd(b);}\nv1 projectS(v1 a,v1 b){return b*sat(dot(a,b)/dd(b));}\n//v2 project(v2 a,v2 b){return a*dot(a,b)/dd(b);}\n//v3 project(v3 a,v3 b){return a*dot(a,b)/dd(b);}\n//shortest distance between point [a] and line trough vecN(0) and vecN([b])\n//v1 dLine(v1 a,v1 b){return a*dot(a,b)/dd(b);}\n\nd3 suab(d3 p,v0 s){return su(ab((p)),s);}\nd2 suab(d2 p,v0 s){return su(ab((p)),s);}\nd1 suab(d1 p,v0 s){return su(ab((p)),s);}\nd0 suab(d0 p,v0 s){return su(ab((p)),s);}\nd33 suab(d33 p,d33 s){return su(ab((p)),s);}           \nd22 suab(d22 p,d22 s){return su(ab((p)),s);}\nd11 suab(d11 p,d11 s){return su(ab((p)),s);}\nd00 suab(d00 p,d00 s){return su(ab((p)),s);}\nd333 suab(d333 p,d333 s){return su(ab((p)),s);}           \nd222 suab(d222 p,d222 s){return su(ab((p)),s);}\nd111 suab(d111 p,d111 s){return su(ab((p)),s);}\nd000 suab(d000 p,d000 s){return su(ab((p)),s);}\n//suab extendsions have been frustrating and halted                    \n                      \nc3 suab(c3 p,v3 s){return c3(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z),suab(p.w,s.w));}\nc2 suab(c2 p,v2 s){return c2(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\nc1 suab(c1 p,v1 s){return c1(suab(p.x,s.x),suab(p.y,s.y));}\nc0 suab(c0 p,v0 s){return c0(suab(p.x,s));}\n//c22 suab(c22 p,v2 s){return c22(suab(p.x,s.x),suab(p.y,s.y),suab(p.z,s.z));}\n\n/*\nhttps://en.wikipedia.org/wiki/Holonomic_function\nhave closed forms in derivatives and antiderivatives.\n*/\n\nbool inRect(v1 u, v3 b\n){b.xyzw-=u.xyxy\n ;return mi(b.zy-b.xw)<mi(b)\n ;return mi(b.z-b.x,b.y-b.w)<mi(b) ;}\n      \n/**///--end__: common aliases\n/**///\n/**///--start: linear hulls smoothstep\n\n#define ssb2(a,b) smoothstep(a,-a,b)\n#define ssb(b) smoothstep(blur,-blur,b)\n#define sM b){return smoothstep(b,-b,a);}\nv0 ss(v0 a,v0 sM                 \nv1 ss(v1 a,v0 sM\nv2 ss(v2 a,v0 sM\nv3 ss(v3 a,v0 sM\nv3 ss(v3 a,v3 sM\nv3 ss(v0 a,v3 b){return smoothstep(b,-b,v3(a));}\n\n// 0-1 1-0\nv0 smoothstep4(v0 e1, v0 e2, v0 e3, v0 e4, v0 val\n){return min(smoothstep(e1,e2,val),1.-smoothstep(e3,e4,val));}\n\n      \n#define fsaa 2.\n//#define fsaa 2, (2./min(iResolution.x,iResolution.y))\nfloat sawCos(vec2 u){//u*=2.;//sale here,or better outside of this function.\n u.x=fract(u.x);u+=(1.-2.*u)*step(u.y,u.x);\n return cos(clamp(1.-u.x/u.y,0.,1.)*pi)*.5+.5;}\nfloat sawCos(vec2 u,float b){u.y=b;return sawCos(u);}\nfloat sawCos(float a,float b){return sawCos(vec2(a,b));}\n//this basically replaces c.g=smoothstep(aa,-aa,c.g);\nfloat sawCos(float a){return sawCos(a,fsaa);}\n//mix smoothstep(aa,-aa,c)with a hint of s,diminishing over c.\n#define sci()mix(s,smoothstep(fsaa,-fsaa,c),.85)/(abs(c)+.5)\nvec3 sawCos3(vec3 c,float b){vec3 s=vec3(sawCos(c.r,b),sawCos(c.g,b),sawCos(c.b,b));return sci();}\nvec2 sawCos2(vec2 c,float b){vec2 s=vec2(sawCos(c.r,b),sawCos(c.g,b));return sci();}\n\n//too bad this sucker has a division in it:\n#define ss13(a)a=smoothstep(crisp,-crisp,a);\n//above is smoothstep,blow is smootheststep,which looks like neon-glow\n//sinusoidial smoothstepp-like has infinitely good derivatives\n#define sss13(a)(1.-cos(clamp(a*acos(-1.),0.,acos(-1.))));\n\nfloat within(float a,float b,float c){if(b<c&&c<a)return 1.;return 0.;}//guessing a missing lib here\n//smoothstep\n#define ss(x,y,z)smoothstep(x,y,z)\n//smoothbump\n#define sbump(x,y,z,b)ss(x,x+b,z)*ss(y+b,y,z)\nfloat skewbox(vec2 uv,vec3 top,vec3 bottom,float b//https://www.shadertoy.com/view/4s33zf\n){float y=within(top.z,bottom.z,uv.y)\n ;return sbump(mix(top.x,bottom.x,y),mix(top.y,bottom.y,y),uv.x,b)*sbump(bottom.z,top.z,uv.y,b);}\n\n\n/**///--end__: linear hulls smoothstep\n/**///\n/**///--start: Reflect and rotate            \n\nm1 rot2D(v0 r){v0 c = cos(r), s = sin(r);return m1(c, s, -s, c);}\nv1 r4(v1 r){return v1(r.y,-r.x);}//perpendicular quater rotation\n                      \nm3 rotationAxisAngle(v2 v,v0 r//axis,angle\n){v0 s=sin(r),c=cos(r)\n ;return m3(m2(c)+outerProduct(v,v)*(1.-c)+m2(0,-v.z,v.yz,0,-v.xy,v.x,0)*s)+m3(1)-m3(m2(1));}\n\n//return distance to 1/24th rotated axis (for super fast arrow shape)\nfloat r12(vec2 u\n){const float s2=sqrt(2.),s6=sqrt(6.)\n ;//extreme un-pointy:return dot(u,vec2(s6+s2,s6-s2)*.25)\n ;return dot(u.yx,vec2(s6+s2,s6-s2)*.25);}\n\nm3 translate(v2 t){m3 m=m3(1);m[3]=v3(t.xyz,1);return m;}\n\n\nvoid pR(inout vec2 p,float a){p=co(a)*p+si(a)*vec2(p.y,-p.x);}//rotate point by a\nvoid pR45(inout vec2 p){p=sqrt(.5)*(p+p.yx*vec2(1,-1));}//rotate p by 1/8 (part of hg_sdf)\nmat2 r1(v0 a){vec2 b=cs(a);return mat2(b.xy,-b.y,b.x);}//rotations matrix, not sureabout direction\nmat2 r2(v0 a){vec2 b=cs(a);return mat2(b.yy,-b.y,b.x);}//namespace reserved for halfAxisMirror\nfloat AngleBetween(vec2 a,vec2 b){vec2 l=sqrt(vec2(dd(a),dd(b)))\n ;return acos(dot(a,b)*l.y/l.x);}//;return acos(dot(normalize(a),normalize(b)))\nfloat AngleBetween(vec2 a//rotation to get vec2(1,0) to a (rotate left or right)\n){return acos(dot(a,vec2(1,0))/length(a))*sign(a.y);}\n                      \n//modify inputs to abs(.x) == mirror vertically\nvoid mirror(inout vec2 u,inout vec2 m){m.x=abs(m.x);u.x=abs(u.x);}\n//single reflection along a half rotated plane -> SINGLE rotation. Applying this matrix twice just gets you mat2(1)\n#define r2(r) mat2(sin(r+vec4(1,0,0,-1)*asin(1.)))\n//rotate p by angle r: p=r(p,r);\n#define r1(p,r) (cos(r)*p+sin(r)*vec2(-p.y,p.x))\n//vec2 r(vec2 p,float t){return cos(r)*p+sin(r)*vec2(-p.y,p.x);\n//}//from https://www.shadertoy.com/view/XlfGzH\n//float angleBetween(v1 a,v1 b){return acos(dt(a,b);}\n\n//Quaternion\n/*\n//asserting that length of quaternions are close to 1\n//we can norma() by dividing by the squaredLength dd(a)! \nv3 qn(v3 q){return q/dd(q);}\n/**/\nv3 qn(v3 q){return q/dot(q,q);}\nv3 aa2q(v0 b,v2 a// b must be normalized!\n){b*=.5;return qn(v3(a*sin(b),cos(b)));}\n#define srmi1p2a(a) sqrt(1.-(a)*(a))\nv3 q2aa(v3 a\n){a.w=2.*acos(a.w)\n ;a.xyz/=srmi1p2a(a.w)\n ;return a;}\nv3 qm(v3 a, v3 b\n){v3 res= v3(0.)\n ;res.w  =a.w*b.w-dot(a.xyz,b.xyz)\n ;res.xyz=a.w*b.xyz+b.w*a.xyz+cross(a.xyz,b.xyz)\n ;return norma(res);}\nv2 qr(v3 q,v2 v\n){v2 t=2.*cross(q.xyz,v)\n ;return v+q.w*t+cross(q.xyz,t);}\n                      \n/**///--end__: Reflect and rotate  \n/**///--\n/**///--start: analytic closed-form  solutions \n\nv0 add(v1 a){return a.x+a.y;}\nv0 suv(v3 a){return dot(v3(1),a);}v0 suv(v2 a){return dot(v2(1),a);}v0 suv(v1 a){return a.x+a.y;}//sum of vector\n\n//(without special-case checks)from  https://www.shadertoy.com/view/XdKyRR  \nvec4 solve_quartic(vec4 p){\n ;float quadrant=sign(p.x),s=p.w// form resolvent cubic and solve it to obtain one real root\n ,j=p.x*p.z-4.*p.w,k=4.*p.y*p.w-p.z*p.z-p.x*p.x*p.w,b=(-2.*p.y*p.y*p.y+9.*p.y*j+27.*k)/27.//coefficients of normal form\n ,delta1=b*b/4.,a=(3.*j-p.y*p.y)/3.,delta2=a*a*a/27.,z1\n ;if(delta1+delta2<0.)z1=2.*sqrt(-a/3.)*cos(acos(-sign(b)*sqrt(delta1/-delta2))/3.)\n ;else    z1=suv(pow(abs(-.5*b+vec2(1,-1)*sqrt(max(delta1+delta2,0.))),vec2(1./3.)))//sum of 2 cubic roots\n ;z1+=p.y/3. // shift back from normal form to root of resolvent cubic\n ;float R2=p.x*p.x/4.-p.y+z1//form quartic roots from resolvent cubic root\n ;bool R_ok=(R2>=0.);float R=sqrt(max(R2,0.)),foo,bar;if(R==0.//i do not call this elegant!\n ){float z124s=z1*z1-4.*p.w;R_ok=R_ok &&(z124s>=0.);foo=3.*p.x*p.x/4.-2.*p.y   ;bar=2.*sqrt(max(z124s,0.))\n ;}else{           ;foo=3.*p.x*p.x/4.-R2-2.*p.y;bar=(4.*p.x*p.y-8.*p.z-p.x*p.x*p.x)/(4.*R);}\n ;float D=sqrt(max(foo+bar,0.)),E=sqrt(max(foo-bar,0.));vec4 roots=vec4(-p.x/4.)+.5*vec4(R+D,R-D,-R+E,-R-E)\n ;roots=mix(roots,roots.xzyw,step(sign(p.x),0.))//optional root sorting within homotopy\n ;return roots;}//used to get closest point on ellipse: https://www.shadertoy.com/view/XttyWN\n\n\n//get 2/3 roots by http://en.wikipedia.org/wiki/Cubic_function#Cardano.27s_method\n#define root232(a,b)  add(sign(b)*pow(abs(b),v1(1./3.)))-a/3.\n#define root23(a,b,d) root232(a, ((v1(1,-1)*sqrt(d)-q)*.5) )\nv1 solveCubic2b(v0 a,v0 b,v0 c//https://www.shadertoy.com/view/XtdyDn\n){v1 p=v1(b-a*a/3.,a)\n ;v0 q=a*(2.*a*a-9.*b)/27.+c\n ,s=p.x*p.x*p.x\n ;c=q*q+4.*s/27.//determinant seperates cases where a root repeats\n ;if(q*q+4.*s/27.>0.)return root23(v1(a),b,c)//both return values are identical\n ;v0 v=acos(-sqrt(-27./s)*q*.5)/3.,m=cos(v),n=sin(v)*sqrt(3.);p/=3.//...does not care for 3rd (middle) root, intended as subroutine for bezier/parabola\n ;return v1(m+m,-n-m)*sqrt(-p.x)-p.y;}//middle root is something line m-n or n-m, salbe scaling\nv1 solveCubic2b(v2 a){return solveCubic2b(a.x,a.y,a.z);}//https://www.shadertoy.com/view/XtdyDn\n//...does not care for 3rd (middle); middle root is something line m-n or n-m, salbe scaling\n\n \n//struct Hit{vec3 n;}\n#define MAX_DEPTH 200.\nvoid Quadric(vec3 ro, vec3 rd, vec3 p, vec3 abc, float r, vec2 yCap, float id\n){//intersect any quadric Ax^2+By^2+Cz^2-r=0  (this is only complicated because of the cap)\n //ex: ellipse: abc=vec3(1.0,0.5,1.0), cyl: abc=vec3(1.0,0.0,1.0), cone: abc=vec3(1.0,-1.0,1.0)\n p=ro-p ;//mx*(ro-p);rd=mx*rd;//for rotations\n vec2 pln=vec2(0.0);\n vec3 N;\n float Y_Plane=1.0,t1=MAX_DEPTH,t2=-MAX_DEPTH;\n if(yCap!=vec2(0.0)){ \n  pln=vec2(p.y-yCap)/-rd.y;\n  if(pln.x>pln.y){pln.xy=pln.yx;Y_Plane=-Y_Plane;}\n }\n if(pln.y>=0.0){\n  float A=dot(abc*rd,rd),B=2.0*dot(abc*p,rd),C=dot(abc*p,p)-abs(r)*r,inner=B*B-4.0*A*C;\n  if(inner<0.0){//throw out if not inside (if inside your looking thru the middle of a cylinder etc.)\n   if(C<0.0){t1=-MAX_DEPTH;t2=MAX_DEPTH;}\n  }else{\n   inner=sqrt(inner);\n   vec2 t=vec2(-B-inner,-B+inner)/(2.0*A);\n   if(t.x>t.y){if(t.y>0.0 && t.y>pln.x){t.x=-MAX_DEPTH;}t.y=MAX_DEPTH;}\n   t1=t.x;t2=t.y;N=abc*(p+rd*t.x);\n  }\n  if(yCap!=vec2(0.0)){\n   if(pln.x>t2 || pln.y<t1){t1=MAX_DEPTH;}//no hit\n   else if(pln.x>t1){t1=pln.x;N=vec3(0.0,Y_Plane,0.0);}\n  }\n  //if(t1>0.0 && t1<H.t){   H.t=t1;H.id=id;H.n=normalize(N);//*mx;\n  //}\n }\n}//https://www.shadertoy.com/view/ldGGRD\n\n/**///--end__: analytic solutions  \n/**///--\n/**///--start: euclidean tracing\n\nv1 gLLxX(v1 A,v1 B,v1 C,v1 D//line line intersection of lines AB and CD; http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;if (dotperp==0.)return A\n ;dotperp=max(abs(dotperp),tiny)*sign(dotperp)//jumps from -tiny to +tiny, lazy 0-avoidance, lines are never parallel!\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n//below doesnt catch parallel div0 cases.\nv1 gLLxX0(v1 A,v1 B,v1 C,v1 D//line line intersection  http://wiki.secondlife.com/wiki/Geometric\n){v1 b=B-A,d=D-C,c=C-A\n ;v0 dotperp=b.x*d.y-b.y*d.x\n ;v0 t=(c.x*d.y-c.y*d.x)/dotperp\n ;return v1(A.x+t*b.x,A.y+t*b.y);}//second life wiki geometry\n    \n//return how far (p) is in front of ray/normal (ut), [>0],or on (u)[=0], or behind (u)[<0] (along the ray)\nfloat isInfront(vec2 u,vec2 t,vec2 p){return dot(p-u,t-u);}\n//isInfront doesnt care for zFar,isWithin asserts (t] to be zfar\n//use isWithin to check if a lineLineIntersection is within a segment.   [<]0for false, >=0 true\nfloat isWithin(vec2 u,vec2 t,float r\n){if(r>=0.){\n ;if(dd(t-u)<=r*r)return r;\n };return -1.;}\n//above already has a cached dotproduct.\nfloat isWithin(vec2 u,vec2 t,vec2 r){r.x=isInfront(u,t,r);return isWithin(u,t,r.x);}\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\n\n\n//https://www.shadertoy.com/view/XdVyRd\nbool SolveSquare(float A,float B,float C,out vec2 x\n){float D=B*B-4.0*A*C\n ;if(D<0.0)return false\n ;x.x=(-B-sqrt(D))/(2.0*A)\n ;x.y=(-B+sqrt(D))/(2.0*A)\n ;return true;}\nfloat sphIntersect(vec3 ro,vec3 rd,vec4 sph//https://www.shadertoy.com/view/4tlBDs\n){vec3 oc=ro-sph.xyz//this one is by iq, with his mit licensing.\n ;float b=dot(oc,rd)\n ;float c=dot(oc,oc)-sph.w*sph.w\n ;float h=b*b-c\n ;if(h<0.0)return-1.\n ;return-b-sqrt(h);}\nbool SphereIntersect(float SpRad,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float A=dot(rd,rd)\n ;float B=2.0*dot(ro,rd)\n ;float C=dot(ro,ro)-SpRad*SpRad\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;t=min(tt.x,tt.y)\n ;if(t<0.0)return false\n ;norm=normalize(ro+t*rd)\n ;return true;}\n//cube intersection function\nbool cube (vec3 p,vec3 dir,vec3 pos,float size,inout vec2 startend,inout vec3 side,inout vec3 hit\n){float fix=.00001//https://www.shadertoy.com/view/MtSGRc\n ;vec3 minim=pos-vec3(size)*.5\n ;vec3 maxim=pos+vec3(size)*.5\n ;vec3 omin=(minim-p)/dir\n ;vec3 omax=(maxim-p)/dir\n ;vec3 maxi=max(omax,omin)\n ;vec3 mini=min(omax,omin)\n ;startend.y=min(maxi.x,min (maxi.y,maxi.z))\n ;startend.x=max(max(mini.x,0.0),max(mini.y,mini.z))\n ;float rayhit=0.\n ;if(startend.y-startend.x>fix)rayhit=1.\n ;hit=p+startend.x*dir\n ;side=vec3(0,0,-1.)//get normal\n ;if(abs(hit.x-minim.x)<fix)side=vec3( 1, 0,0)\n ;if(abs(hit.x-maxim.x)<fix)side=vec3(-1, 0,0)\n ;if(abs(hit.y-minim.y)<fix)side=vec3( 0, 1,0)\n ;if(abs(hit.y-maxim.y)<fix)side=vec3( 0,-1,0)\n ;if(abs(hit.z-minim.z)<fix)side=vec3( 0, 0,1)\n ;return rayhit>.5;}\nbool ConeIntersect(vec2 ConeR_ab,vec2 ConeCaps,vec3 ro,vec3 rd,out float t,out vec3 norm\n){t=10000000.\n ;float Al=ConeR_ab.x*rd.z\n ;float Bl=ConeR_ab.x*ro.z+ConeR_ab.y\n ;float A=dot(rd.xy,rd.xy)-Al*Al\n ;float B=2.0*(dot(rd.xy,ro.xy)-Al*Bl)\n ;float C=dot(ro.xy,ro.xy)-Bl*Bl\n ;vec2 tt\n ;if(!SolveSquare(A,B,C,tt))return false\n ;vec2 zz=ro.zz+rd.zz*tt\n ;int n=2\n //todo: apply zz.x-=zz.y and do the LessThan magic\n ;if((zz.x<ConeCaps.x)||(zz.x>ConeCaps.y)){tt.x=tt.y;n--;}\n ;if((zz.y<ConeCaps.x)||(zz.y>ConeCaps.y)){tt.y=tt.x;n--;}\n ;if(n==0)return false\n ;t=min(tt.x,tt.y)\n ;norm.xy=normalize(ro.xy+rd.xy*t)\n ;norm.z=-ConeR_ab.x\n ;norm=normalize(norm)\n ;return true;}\n\n//The MIT License\n//Copyright © 2017 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files (the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\nvec3 parallelogramIntersect(vec3 ro,vec3 rd,vec3 vv0,vec3 vv1,vec3 vv2//https://www.shadertoy.com/view/4tlBDs\n){vec3 a=vv0-vv1\n ;vec3 b=vv2-vv0\n ;vec3 p=vv0-ro\n ;vec3 n=cross(a,b)\n ;vec3 q=cross(rd,p)\n ;float i=1.0/dot(rd,n)\n ;float u=dot(q,a)*i\n ;float v=dot(q,b)*i\n ;float t=dot(n,p)*i\n ;if(u<0.0 || u>1.0 || v<0.0 || v>1.0)return vec3(-1.0)\n ;return vec3(t,u,v);}\n\n\n//is a bit lame, because it just traces 3 things seperately.\nbool ConeCapsuleIntersect(vec2 spZRad1,vec2 spZRad2,vec3 ro,vec3 rd,out float t,out vec3 norm\n){if(spZRad1.x>spZRad2.x\n ){vec2 tmp=spZRad1\n  ;spZRad1=spZRad2\n  ;spZRad2=tmp;}\n ;vec2 ConeCaps\n ;float spdz=spZRad2.x-spZRad1.x\n ;float h1=(spZRad1.y*spZRad2.y-spZRad1.y*spZRad1.y)/spdz\n ;float h2=(spZRad2.y*spZRad2.y-spZRad1.y*spZRad2.y)/spdz\n ;ConeCaps.x=spZRad1.x-h1\n ;ConeCaps.y=spZRad2.x-h2\n ;float ConeR1=sqrt(spZRad1.y*spZRad1.y-h1*h1)\n ;float ConeR2=sqrt(spZRad2.y*spZRad2.y-h2*h2)\n ;vec2 dZdR=vec2(ConeCaps.y-ConeCaps.x,ConeR2-ConeR1)\n ;vec2 ConeR_ab\n ;ConeR_ab.x=dZdR.y/dZdR.x\n ;ConeR_ab.y=ConeR2-ConeCaps.y*ConeR_ab.x\n ;float sp_t\n ;vec3 sp_n\n ;int n=0\n ;if(ConeIntersect(ConeR_ab,ConeCaps,ro,rd,t,norm)){n++;}\n ;if(SphereIntersect(spZRad1.y,vec3(ro.xy,ro.z-spZRad1.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;if(SphereIntersect(spZRad2.y,vec3(ro.xy,ro.z-spZRad2.x),rd,sp_t,sp_n)\n ){if(sp_t<t\n  ){t=sp_t\n   ;norm=sp_n;}\n  ;n++;}\n ;return(n>0);}\n \n//The MIT License\n//Copyright © 2016 Inigo Quilez\n//Permission is hereby granted,free of charge,to any person obtaining a copy of this software and associated documentation files(the \"Software\"),to deal in the Software without restriction,including without limitation the rights to use,copy,modify,merge,publish,distribute,sublicense,and/or sell copies of the Software,and to permit persons to whom the Software is furnished to do so,subject to the following conditions:The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.THE SOFTWARE IS PROVIDED \"AS IS\",WITHOUT WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,DAMAGES OR OTHER LIABILITY,WHETHER IN AN ACTION OF CONTRACT,TORT OR OTHERWISE,ARISING FROM,OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n//trace capsule.if(missed)return vec4(-1); return vec(SmallestPositiveIntersection,normal.xyz)\nvec4 iCapsule(vec3 u,vec3 d,vec3 b,vec3 a,float t//rayOrigin,rayDirection,BasePosition,CylinderSpine,radius\n){vec3 o=u-b;t*=t;float l=length(a)//cylinderspine goes from Baseposition to the center of the second sphere.\n ;if(l>0.//https://www.shadertoy.com/view/Xt3SzX\n ){vec3 e=a/l;vec2 v=vec2(dot(e,d),dot(e,o));//normalize and project\n  ;e=vec3(dot(o,d)-v.y*v.x,dd(o)-v.y*v.y-t,1.-v.x*v.x)\n  ;float h=perpdot(e.xy,e.zx)//trace cylinder hit condition\n  ;if(h<0.)return vec4(-1)//misses cyliner\n  ;e.z=(-e.x-sqrt(h))/e.z;v.y+=e.z*v.x;v.x=e.z//trace cylinder\n  ;if(abs(v.y)<l)return vec4(v.x,normalize(o+v.x*d-a*v.y/l));//return traced cylinder cylinder\n  ;u-=b+a*sign(v.y)//mirrored sphere\n  ;e.x=dot(u,d)//[o] has changed,this is a different dot(o,d)than the one earlier.\n  ;t+=e.x*e.x-dd(u)//difference between 3 squares\n  ;if(t>0.){v.x=-e.x-sqrt(t);return vec4(v.x,normalize(u+d*v.x));}\n ;}//else//trace sphere\n ;return vec4(-1);}//change to(1)to see the tangents\n\n\nvec4 GN(int i//plane definitions for geod\n){vec4 n=vec4(0.0,1.0,0.0,0.5)\n ;    if(i==11)n.y=-n.y\n ;    else if(i>0\n ){        float j=mod(float(i)-1.0,5.0)\n  ;        float a=2.0*pi/5.0*j\n  ;        float y=0.6\n  ;        if(i>5){a+=pi/5.0;y=-y;}\n ;n=vec4(cos(a),y,sin(a),0.6);    }\n ;return n ;}\n\nvoid Geod( in vec3 ro, in vec3 rd, in vec3 p, in float id//trace geod\n){//a convex shape made by intersecting planes\n //find the farthest facing plane nearer then the closest back-facing plane\n p=ro-p;\n float t1=-MAX_DEPTH,t2=MAX_DEPTH;\n vec3 N1;\n for(int i=0;i<12;i++){\n  vec4 n=GN(i); //mx*N[i].xyz;\n  float frontface=dot( n.xyz,-rd );\n  float t=(dot( n.xyz, p )-n.w) / frontface;\n  if(frontface>0.0){\n   if(t>t1){N1=n.xyz;t1=t;}\n  }else{\n   if(t<t2){t2=t;}\n  }\n }\n //if(t1>0.0 && t1<=t2 && t1<H.t){H.t=t1;H.id=id;H.n=N1;//*mx;\n //}\n}//https://www.shadertoy.com/view/ldGGRD\n\n//projection core\n#define pc(a,b) dot(a,b)/dd(b)\n//todo, many shapes deserve a shorter [*u]==unsigned alternative\n//todo, make it work without the p.x=abs(p.x)\n//s=trapezoids;bottom width,top width,height ; t=[to calcullate sign]\nfloat trapezoid2(vec2 p,vec3 s,inout vec4 t\n){p.x=abs(p.x)//https://www.shadertoy.com/view/XdKGDy\n ;t=vec4(vec3(p.xy,s.x)-s.yzy,-2.*s.z)\n ;vec2 d=t.xy-t.zw*sat(pc(t.xy,t.zw))\n ;vec4 h=vec4(max(p.x-vec2(s.xy),0.),p.y+s.z*vec2(1,-1))\n ;h.xyz=vec3(dd(d),dd(h.xz),dd(h.yw))\n ;return sqrt(miv(h.xyz));}\nfloat trapezoidU(vec2 p,vec3 s){vec4 t=vec4(0);return trapezoid2(p,s,t);}\nfloat trapezoid(vec2  p,vec3 s){vec4 t=vec4(0);float a=trapezoid2(p,s,t);return a*sign(max(dot(t.xy,vec2(-1,1)*t.wz),abs(p.y)-s.z));}\n\n\n/**///--end__: euclidean tracing\n/**///--\n/**///--start: AD-/mercury.sexy/hd_sdf\n\n//euclidean tracing[line line intersection] is needed for some shapes here\n                      \n//Below are translations of the hg_sdf library\n//to use the above [Derivative Arithmetic]\n//mostly just in prefix-notation\n//but also with quite the tricky structure\n//as examples. on how to translate between 2 arithmetics.\n           \n                      \n//---hg_sdf http://mercury.sexy/hg_sdf // https://www.shadertoy.com/view/Xs3GRB\n//mod must be on top od all unions that include mod()\nfloat pMirror(inout float p,float d){float s=mix(-1.,1.,step(p,0.));p=abs(p)-d;return s;}\nfloat pReflect(inout vec3 p,vec3 n,float o){float t=dot(p,n)+o;p=mix(p-2.*t*n,p,step(t,0.));return mix(-1.,1.,step(t,0.));}\nvec2 pMirrorOctant (inout vec2 p,vec2 dist){vec2 s=vec2((p.x<0.)?-1.:1.,(p.y<0.)?-1.:1.);pMirror(p.x,dist.x);pMirror(p.y,dist.y);if(p.y>p.x)p.xy=p.yx;return s;}\n//todo,make better column code! this may benefid from my improved pmod() code\n\n//pmod() got killed by su() incompatibility\n//#define frflpm(z,y)z frfl(z a){return z(fract(a.a),floor(a.b));}z pmod(z a){return mu(su(frfl(y(a.a/a.b+.5)),y(.5,.0)),y(a.b,1.));}\n////frflpm(v00,c00)  frflpm(v11,c11)frflpm(v22,c22)frflpm(v33,c33)  //high domain su() incompatibility\n\n#define pMOD(d,e) d e(inout d a,d b){d c=floor((a/b)+.5);a=(fract((a/b)+.5)-.5)*b;return c;}\npMOD(vec1,pmod)pMOD(vec2,pmod)pMOD(vec3,pmod)pMOD(vec4,pmod)//repetitive only for less repetitive legacy namespace support.\nvec1 pModMirror1(inout vec1 p,vec1 s){float c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nvec2 pModMirror1(inout vec2 p,vec2 s){vec2 c=pmod(p,s);p*=u2(mod(c,2.));return c;}\nfloat pModInterval1(inout float p,float s,float b,float x){float c=pmod(p,s);if(c>x){p+=s*(c-x);c=x;}if(c<b){p+=s*(c-b);c=b;}return c;}\nfloat pModSingle1(inout float p,float s){float c=floor((p/s)+.5);p=mix(p,(fract((p/s)+.5)-.5)*s,step(p,0.));return c;}\nfloat pModPolar(inout vec2 p,float t\n){vec2 q=c2p(p)\n ;float v=pi/t\n ;q.x+=v//offset by half-axis\n ;float c=floor(q.x*.5*v)\n ;q.x=mod(q.x,2.*v)-v\n ;p=p2c(q)\n ;if(abs(c)>=t*.5)c=abs(c)\n ;return c;}\nvec2 pModGrid2(inout vec2 p,vec2 size\n){vec2 c=floor((p+size*.5)/size)\n ;p=mod(p+size*.5,size)-size*.5;p*=mod(c,2.)*2.-vec2(1);p-=size*.5\n ;if(p.x>p.y)p.xy=p.yx;return floor(c*.5)\n ;}\n\nvec2 pModMirror2(inout vec2 p,vec2 size//likely duped\n){vec2 halfsize=size*.5;\n vec2 c=floor((p+halfsize)/size);\n p=mod(p+halfsize,size)-halfsize;\n p *=mod(c,vec2(2))*2.-vec2(1);\n return c;}\n                      \n//float ma(vec4 a){return 0.;}\n\nconst vec1 _1=.57735026919;\nconst vec4 PHI=vec4(1,sqrt(5.)*.5+vec3(-1,1,2)*.5);\nconst vec2 _B=norma(PHI.xy);\n     /* killed by incompatibility                 \nfloat Blob(vec3 p){p=abs(p);p=mix(p,p.yzx,step(p.x,ma(p.y,p.z)))\n ;vec1 l=le(p),b=ma(vec4(dot(p,vec3(_1)),dot(p.xz,norma(PHI.zx)),dot(p.yx,_B),dot(p.xz,_B)))\n ;return l-1.5-.15*cos(mi(sq(1.-b/l)*4.*pi,pi));}\n//dist2plane [n]=plane Normal [d]shortestDistanceOfPlaneTo vec4(0) (see \"hessian normal form\")\n/**/\n#define fPlane(p,n,d) ad(dt(p,n),d)\n      \n      \n      \nv0 fOpUnionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r-a,r-b),0.);return max(r,min(a,b))-length(u);}     \nd2 fOpUnionRound(d2 a,d2 b,v0 r\n){d2 x=su(r,a);x=ma(x,0.)\n ;d2 y=su(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=mi(a,b);m=ma(r,m);return su(m,x);}\n//does not seem to have good lipschitz.\nv0 fOpIntersectionRound(v0 a,v0 b,v0 r\n){v1 u=max(v1(r+a,r+b),0.);return min(-r,max(a,b))+length(u);}\nd2 fOpIntersectionRound(d2 a, d2 b,v0 r\n){d2 x=ad(r,a);x=ma(x,0.)\n ;d2 y=ad(r,b);y=ma(y,0.);x=sd(x,y)\n ;d2 m=ma(a,b);m=mi(-r,m);return ad(m,x);}\n#define fOpDifferenceRound(a,b,r) fOpIntersectionRound(a,negd(b),r)\n\nv0 pMod1(inout v0 p,v0 s){p/=s\n;v0 c=floor((p)+.5);p=(fract(p+.5)-.5)*s;return c;}\n/*  old struct fr() incompatibility\nd2 pMod1(d2 p,v0 s){p=di(p,s)\n;//v3 c=floord4(p);//c=subd(c,.5);//v0 c=floor((p)+.5);\n;p=ad(p,.5);p=fr(p);p=su(p,.5);p=mu(p,s)//p=(fract(p+.5)-.5)*s;\n;return p;}*/\n\n           \n//return distance to [wedge.rounded.circle],circle/IniniteLineSegment end at m.xy,the other line is horizontal.\nfloat wedgeRound(vec2 u,vec2 m\n){if(m.y==0.){if(m.x<0.)return u.y;if(u.x>m.x)return-abs(u.y);return-length(u-m);}//linear special cases\n ;m.y=abs(m.y)\n ;float l=length(m),d=dot(u,normalize(m)/l)-1.\n ;if(max(sign(u.x-l),sign(d))>0.)return(min(dot(vec2(-u.y,u.x),normalize(m)),u.y))//return minimum distance to 2 lines\n ;vec2 i=gLLxX(vec2(l,0),vec2(l,1),m,m+vec2(m.y,-m.x))//line line intersection\n ;return length(m-i)-length(u-i);}//aka ollj appolonean rounded railroad(bad c1 continuity)\n\n\n\n#define cylinder(a,r,h) ma(lbm(a.xz,r),abm(a.y,h))//uv,radiusXZ,heightY;vertical cylinder\n#define ls2(a,c) dd(su(a,mu(c,sat(di(dt(a,c),dd(c))))))//sqared orthogonal projection ,ls()sub ,is squared distance\n#define ls(a,b,c) sqrt(ls2(su(a,b),su(c,b)))//pointAdistance to (diagonal) lineSegment from B to C\n//float lsNaive(vec2 u,vec2 n,vec2 m){float b=dot((2.*n),u);float c=length(m);\n //return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n //if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//PointDistance to lines https://www.shadertoy.com/view/4dBfzG\nfloat ls1(vec2 u,vec2 m){float b=dot((2.*m),u);//branching FAST line segment with a length of 1.\n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(m,vec2(-u.y,u.x))),step(abs(b-1.),1.));//branchless  \n if(abs(b-1.)>1.)return length(u-m*.5*(1.+sign(b)));return abs(dot(m,vec2(-u.y,u.x)));}//==if(b*b>2.*b)..\n//return __signed distance of [u] to line trough(0,0)and [m],m must be normalized.\nfloat line(vec2 u,vec2 m){u.x=-u.x;return dot(m,u.yx);}\n//return unsigned distance of [u] to line trough(0,0)and [m]\nfloat ils(vec2 u,vec2 m){\n//return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n if(dot(m,u)<0.)return length(u);return abs(dot(m,vec2(-u.y,u.x)));}\n//return distance of [u] to line_segment from(0,0)to [m]\n//[m] must NOT be normalized!\n//return distance of [u] to line_segment from(0,0)to [n]*[a],n must be normalized\nfloat lss13(vec2 u,vec2 n,float a){vec2 m=n*a;return ls(u,n,m);\n float b=dot((2.*n),u);float c=length(m);//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n//return mix(length(u-m*.5*(1.+sign(b))),abs(dot(n,vec2(-u.y,u.x))),step(abs(b-c),c));//branchless   \n if(abs(b-c)>c)return length(u-m*.5*(1.+sign(b)));return abs(dot(n,vec2(-u.y,u.x)));}//==if(b*b>2.*b*c)...\n//all above functions require m to be normalized, which is done exmplicityly with thebelow fiunctions.\n#define lineN(u,m) line(u,normalize(m))\n#define lsa(u,m)   abs(line(u,m))\n#define lsaN(u,m)  abs(line(u,normalize(m)))\n#define ilsN(u,m)  ils(u,normalize(m))\n#define ls1N(u,m)  ls1(u,normalize(m))\n#define lsN(u,m)   ls(u,normalize(m),m)\n#define lssN(u,n,a)lss13(u,normalize(n),a)\n//signed infinite line (unique because it has a sign bias), 2 variants are likely quite identical.\n#define lineInf(p,a,b) dot(normalize(vec2((b-a).yx)*vec2(1,-1)),p-a)\n#define lineInfbbb(u,m) dot(u-m.xy,(m.zw-m.xy)*vec2(-1,1))//signed distance to line \n//likely very identical to lineInf() ???//vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n//more generally,f should be normalized here for proper caling, but scaling is irrelevant as we only care fror the sign \n#define lsY(a,b) mx(le(a.xz),le(vec3(a.xz,abm(a.y,b.x))),st(b.y,ab(a.y)))//pointAdistance to vertical lineSegment from b.x to b.y aling Ydomain???\nfloat lsYbbb(vec2 u,vec2 m,vec2 n){m=m-n;return (u.x-n.x)*m.y/m.x-u.y+n.y;}//likely identical to lsY()???\n//note that a torus can not be mStretch()ed into a tube\n\n\n#define torus(a,b) le(vec2(lbm(a.xz,b),a.y))//pointA distance of HOLLOW ring with radiusB ,lathe of [le(p.xz))-b]\n#define disc2(p,l) mi(vec3(abs(p),le(vec2(p,l)),st(l,0.)))//disc()sub\n#define disc(p,b) disc2(p.y,lbm(p.xz,b))//pointA distance of FILLED ring with radiusB ,lathe of [le(p.xz))-b],but filled!\n#define hexCircum2(a,b) ma(vec2(ma(a.x*.866+a.z*.5,a.z),a.y)-b)//hexCircum()sub\n#define hexCircum(a,b) hexCircum2(abs(a),b)//pointA.xyzDistance to hexagon,set by circumcircle radius b.x,with height b.x\nfloat cci(vec3 r){float d=r.z*2.;r*=r;return(r.x-r.y+r.z)/d;}\n//does not check for non-intersecticn cases! intersection.y is not important\n//return signed distance of u to line trough m.xy and m.zw\nfloat fCone(vec3 p,float r,float h//this needs some optimization;\n){vec2 t,m,q=vec2(length(p.xz),p.y);t=q-vec2(0.,h);m=norma(vec2(h,r))\n ;float j=dt(t,vec2(m.y,-m.x))\n ;float d=max(dt(t,m),-q.y)\n ;if(q.y>h&&j<0.)d=max(d,le(t))\n ;if(q.x>r&&j>le(vec2(h,r)))d=max(d,le(q-vec2(r,0)))\n ;return d;}\n//return distance of [p] measure distance to,[2 circle centers] and [2 sphere radii],connected by a tangential capped cone.\nvec3 bicapsule3(vec3 p,vec3 a,vec3 b,float s,float t//https://www.shadertoy.com/view/4l2cRW\n){vec3 c=b-a;float l=dot(p-a,c)/dd(c);vec3 u=mix(a,b,l)-p;//simple distance to line segment\n //Calculate the offset along segment according to the slope of the bicapsule\n ;c.x=length(c);float r=s-t;//find tangent angle for a point/sphere//the part in the tan()is the arcsecant function.\n ;float o=length(u)/tan(acos(1./(((c.x/abs(r))-1.)*c.x+1.)));//This is adjacent/tan(theta)-opposite\n ;o*=sign(r);//optional,for+1mult(),handle t>s as well\n ;l=sat(l-o);c=mix(a,b,l);return c+(normalize(p-c)*mix(s,t,l));}//And back to classic capsule closest point(with mix()ed radius)\n\nconst float eRm=.0001;\nvec1 bicapsule(vec3 p,vec3 a,vec3 b,float s,float t){float c=min(s,t);s-=c;t-=c\n ;return le(p-bicapsule3(p,a,b,s,t))-c+eRm;}//main problem here is that it is an UNSIGNED distance, so the smaller radius>eps.\n //must substract larger radius from smaller and add that as thickness for non-shitty normals\n//similar to bicapsule,except that the straigt segment is a circle segment.\n//for simplicity,the shape touches x=y at y=0 and at y=1;\n//m.xy define 2 circle radii,both thicles touch the .y as describec above,for scale,and this is all that is needed to define the shape.\n//return circle-circle-intersection.x;r.x=circle.left.radius;r.y=circle.right.radius;r.z=circles-centers.distance\n\n\n//https://en.wikipedia.org/wiki/Moss%27s_Egg\n#define EarVagEgg moss\n#define CylEarVagEgg cylMoss\n//moss() is still far from standardized. rac is the central radius, should be parametric.\nfloat moss(vec2 u,vec3 m//m.x+m.xy<=1. is relevant, larger values just return a circle.\n){vec3 c=vec3(0)\n ;m=abs(m);m.xy=min(m.xy,vec2(.49999))//;m.xy=max(m.xy,vec2(-.49999))\n ;if(m.x>m.y)m.xy=m.yx//now it is worksave\n ;float rac=m.z\n ;vec3 d=vec3(0,m.y,m.y),e=vec3(0,1.-m.x,m.x)//upper&lower circle ;.xy=center .z=radius  \n ,h=vec3(0,1.-m.x,rac-m.x),l=vec3(0,m.y,rac-m.y)//upper&lower intersect ring\n ;vec2 i=vec2(0);//center of 2 large circles,to be calculated by intersection\n ;i.y=m.y-cci(vec3(l.z,h.z,m.y+m.x-1.));//circle circle intersection.y\n ;float r=0.,y=m.y-i.y;i.x=-sqrt(l.z*l.z-y*y);//circle circle intersection.x\n ;u.x=abs(u.x)\n ;if (lineInfbbb(u,vec4(i,d.xy))<.0)r=length(u-d.xy)-d.z//lower part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else if(lineInfbbb(u,vec4(i,e.xy))>.0)r=length(u-e.xy)-e.z//upper part//the conditional is likely better with a triconometric arcsecant thingie.\n ;else       r=length(u-i)-l.z-m.y//middle part\n ;return r;}//todo lathe this one //cylMoss() is capped cylinder to extrude it to 3d.\nfloat moss(vec2 u,vec2 m){return moss(u,vec3(m,mix(.5,3.,sin(1.)*.5+.5)));} //ain(1.) was iTime\n//pointUdistance to cylinder of thickness h of shapeFunction z example for z==(abs(moss(u.xy,m))-.05\n//#define cyl(u,h,z) ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02)//nope can not indert a function() as #defione param\n//cylMoss() is capped cylinder to extrude it to 3d.\nfloat cylMoss(vec3 u,vec2 m,float h){return ma(abs(u.z)-h,abs(abs(moss(u.xy,m))-.05)-.02);}\n//todo lathe this one for a 3d ear-shape\n\n//distance from (u) to lenss nut hourglass (rd) (radius,circleCenterDistances)\nfloat vesica(vec2 u,float r,float d\n){u=abs(u);float b=(r*r-d*d);vec2 a=vec2(u.y*d,u.x+d);a*=a*sign(a)\n ;return((a.x/b>a.y))?length(u-vec2(0,sqrt(b)))*sign(d)\n                     :length(u+vec2(d,0))-r;}//https://www.shadertoy.com/view/XtVfRW\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat sdHorseshoe(vec2 p,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;p.x=abs(p.x)\n ;float l=length(p)\n ;p=mat2(-c.x,c.y,c.y,c.x)*p\n ;p=vec2((p.y>0.)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l )\n ;p=vec2(p.x,abs(p.y-r))-w.xy\n ;return length(max(p,0.)+min(mav(p),0.))   -w.z;\n ;//return length(ma0(p))+mi0(mav(p))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n\n      \n                      /*\nvec2 CoordCross(vec3 u\n){vec3 o=vec3(2,.1,2)\n ;vec2 b=vec2(box(u-o*vec3(1,-1,1),o),-1)\n ;float e=ma(ab(u))-9.*u5(cos(iTime))//distance from vec3(0) where coordinate crosses are drawn\n ;u=fract(u/2.-.5)-.5\n ;float c=ma(ab(u))+.125*e//width of each coordinate cross\n ;float y=step(abs(u.z),abs(u.x))\n ;u.xz=mix(u.xz,vec2(-u.z,u.x),step(abs(u.z),abs(u.x)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;y+=step(abs(u.z),abs(u.y))*2.\n ;u.yz=mix(u.yz,vec2(-u.z,u.y),step(abs(u.z),abs(u.y)))//;if(abs(u.y)<abs(u.x))u=vec2(-u.y,u.x)//cross mirror\n ;float d=ma(ab(u.xy))+.003*e//thickness of coordinate crosses\n ;d=ma(d,c) \n ;d=ma(d,e)\n ;vec2 r=vec2(d,y)\n ;r=minx(r,b)\n ;return r\n ;}\n/**/\nvec2 abx(vec2 a){return vec2(abs(a.x),a.y);}  \n\n/*\n//return distance to(barely more than a)half-donut,bitten off perfectly round.\nfloat halfWorm(vec2 u,float r,float s){u.x=abs(u.x);\n if(r<=0.)return length(u);//i do not see this integrating with code below.\n u.y*=s;vec2 i=u/r;i.x-=1.;\n float a=length(.5*(sign(u.y)*(u-i)+u+i)),c=a/r;\n s=.5*(sign(u.y)*(c-a-1.)+(a+c)-1.);//s=mix(a,b,step(0.,u.y));\n//if(0.>u.y)s=length(u);else s=length(u)/r-1.;\n return abs(s)*r;}\n*/\n//special halfWorm(u,1,1):\nfloat halfWorm11(vec2 u){float a=length(sign(u.y)*vec2(.5,0)+vec2(abs(u.x)-.5,u.y))\n ;return abs(a-.5*(1.+sign(u.y)));}\n//a simpler shape for debugging.\nfloat ellipseCheap(vec2 u){return length(vec2(abs(u.x+1.),u.y))+length(vec2(abs(u.x-1.),u.y));}\n\n\n// The [stairs] and [cpolumns] produce n-1 steps of a staircase/column:\nfloat mistairs(float a,float b,float r,float n\n){float s=r/n\n ;float u=b-r\n ;return mi(mi(a,b),.5*(u+a+abs(mod(u-a+s,2.*s)-s)));}\n#define mastairs(a,b,r,n)-mistairs(-a,-b,r,n)\n#define mestairs(a,b,r,n)-mistairs(-a,b,r,n)\n#define columns2(r,n,d) r/(n+d)\n#define columns3 if(mod(n,2.)==1.)p.y+=t;a=pmod(p.y,t*2.);float s=length(p)-t\n#define columns4 vec2 p=vec2(a,b);pR45(p)\n// The \"Columns\" flavour makes n-1 circular columns at a 45 degree angle\n//columns asserts that normlsd of a and b are at 90deg angle. it does not perform too well at other angles.\nfloat micolumns(inout float a,float b,float r,float n){     float m=min(a,b);if(max(a,b)>=r*2.)return  m;float d=sqrt(.5);float t=columns2(r  ,n+2.,d);columns4;p.x-=(r-t)*d;columns3;return  min( min(s, p.x),m);}\nfloat mecolumns(inout float a,float b,float r,float n){a=-a;float m=min(a,b);if(max(a,b)>=r   )return -m;float d=sqrt(.5);float t=columns2(r*d,n   ,d);columns4;p.x-=(r+t)*d;columns3;return -min(-min(s,-p.x),m);}\nfloat mucolumns(inout float a,float b,float r,float n){return mecolumns(a,-b,r,n);}\n#define mucolumns(a,b,r,n) mecolumns(a,-b,r,n)\nfloat pipe(float a,float b,float r){return le(vec2(a,b))-r;}\n//what,no pipeGroove?\n#define engrave(a,b,r)  ma(a,mu((a+r-ab(b)),sq(.5)))\n#define groove(a,b,r,h) ma(a,mi(ad(a,r),su(h,ab(b))))//r=depth h=width\n#define tongue(a,b,r,h) -groove(-a,b,r,h)// mi(a,ma(su(a,r),su(ab(b),h)))\n      \n\n\n\n//https://www.shadertoy.com/view/ltGXWG\n//i need to render this\n#define smod(t,n)       (mod(t+(n)/2., n)-(n)/2.)\n//i need to render this\n#define dbox(t,r)       ( max(t.x,max(t.y,t.z))-(r) )\n//used to define a box.\n#define setbox(t,h,w,d)   abs(t)/vec4(h,w,d,1)\n\nfloat sdCappedCylinder( vec3 p, vec2 h //not exactly sure what this is\n){vec2 d=abs(vec2(length(p.xz),p.y))-h;               //cylinder\n  return min(max(d.x,d.y),0.0)+length(max(d,0.0));}\n\nfloat sdConeSection( vec3 p, float h, float r1, float r2\n){vec2 d=vec2(-p.z,p.z)-h\n ;float si=.5*(r1-r2)/h\n ;d.y=max(sqrt(dd(p.xy)*(1.-si*si))+d.y*si-r2,d.y)\n ;return length(max(vec2(d.x,d.y),.0))+min(max(d.x,d.y),0.);}\n/*\nfloat sdConeSection( vec3 p, float h, float r1, float r2 ){\n  float d1=-p.z-h;\n  float q=p.z-h;\n  float si=0.5*(r1-r2)/h;\n  float d2=max( sqrt( dot(p.xy, p.xy)*(1.0-si*si))+q*si-r2, q );\n  return length(max(vec2(d1, d2), 0.0))+min(max(d1, d2), 0.);}*/\n\n\nfloat arrow(vec2 u,vec4 m\n){u.y*=sign(u.y)\n ;//if(u.y>m.x)return length(u-vec2(m.z,0.))-1.;//too lazy to calculate or estimate tangent here.\n ;m.z*=.25\n ;m.zw=abs(m.zw)\n ;//vec2 d=vec2(1,-sqrt(2.))*.5;//12th rotation\n ;float a=r12(u)-m.z//24th rotation\n ;a=max(a,-u.x)\n ;u.y=-mStretchP(u.y,m.y)\n ;u.x=-mStretchM(u.x,m.x)\n ;//u.x=mStretchP(u.x,-m.x)\n ;float b=length(u)-m.w\n ;a=min(a,b)\n ;//return c\n ;//a=min(a,c)\n ;return a;}\n\n\n\n/**///--end__: AD mercury.sexy/hd_sdf\n/**///--\n/**///--start: projections\n                      \n//ortographics\nmat4 rotX4(float a){vec2 r=cs(a);return mat4(r.x,0,r.y,0,0,1  ,0  ,0,-r.y,0   ,r.x,0,0,0,0,1);}\nmat4 rotY4(float a){vec2 r=cs(a);return mat4(1  ,0,0  ,0,0,r.x,r.y,0,0   ,-r.y,r.x,0,0,0,0,1);}\nmat3 rotX3(float a){return mat3(rotX4(a));}\nmat3 rotY3(float a){return mat3(rotY4(a));}\n//cam prjections\nv22 cam(vec2 u\n){float camOrbit=3.//camera orbits at distance to vec3(0)\n ;//return v33(vec3(0,0,-camOrbit),norma(vec3(u,1)))//super lazy alternative\n ;vec2 m=vec2(0)//-.03*(iMouse.xy-iResolution.xy*.5)//mouse input\n ;vec2 n=cs(vec2(1,.61)*1.)//autopilot //*iTime\n ;m=vec2(1)//mx(n,m,step(0.,iMouse.z))\n ;mat3 a=rotX3(m.x)*rotY3(m.y)\n ;vec3 pos=a*vec3(0,0,-camOrbit)\n ;vec3 dir=norma(a*vec3(u,1))\n ;return v22(pos,dir);}\n\n//Phong+debugPlanes\n//todo (fix df() nonsense\n//https://en.wikipedia.org/wiki/Line%E2%80%93plane_intersection#Algebraic_form\n//https://www.shadertoy.com/view/llXcDr\n                      \n                      \n/**///--end__: projections  \n/**///--\n/**///--start: AD Superprims\n      \nvec3 dt(vec3 a,mat3 b){return vec3(dot(a,b[0]),dot(a,b[1]),dot(a,b[2]));}\nmat3 mu3(vec3 a,mat3 b){return mat3(a.x*b[0],a.y*b[1],a.z*b[2]);}\nvec3 suv(mat3 a){return a[0]+a[1]+a[2];}\n\n//odsoleted by cir()\n/*\n#define abm(a,b) (abs(a)-b)  //ditance taxicap   -b\n#define lbm(a,b) (length(a)-b)//distance euclidean-b\n#define boxf(a,b) ma(abm(a,b))\n#define roundit(a) lbm(ma0(a),mi(ma0(-(a))))   //==(le(ma0(a))+ma(mi0(a)))\n#define corner(a) roundit(mi0(a)) //i am not convinced by this one\n//#define box(a,b) roundit(abm(a,b))\n/**/\n      \n//cir()  return distance of (u) to (rounded) box/circle/AxisAlignedLineSegment\n//yes, thats a lot of basic shapes\n//called cir() because all lowest LOD are boxes.\n//cirS() seperates polynomials to allow to delay the sqrt() \n//       of ALL boxes with the same thickness (if tree-branch-thicknesses are uniform)\n//       by getting sqrt(min(multiple squared values))\n//cirS() header exists with and without stretching(&automatic offset)\n//\n//u=uv point\n//b.x=thickness\n//b.y=cornerRoundness [0..1] interpolates between circle and boxRounded\n//lod=LoD lod==0 is always a square\nvec2 cirCore(vec2 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\nvec2 cirCore(vec3 u,vec2 b,float lod\n){float k=mav(u)-b.y//sharp-corner-box distance (precalc for optional Bound)\n ;if(k>.1) return vec2(0.,mav(u)-b.y)//optional bound around sqrt()\n ;if(miv(u)>0.)return vec2(dd(max(u,0.)),-miv(max(-u,0.))-b.y)\n ;return vec2(0.,k);}\n\n//cir header without stretch\nvec2 cirS(vec2 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l){b.y*=b.x*sat(l);u=(abs(u)-b.x+b.y);return cirCore(u,b,l);}\n\n//cir header with stretch option\n//s=size stretch\n//positibes are useful for segments/boxes\n//negative inputs create ray/wedge (wedge interiors (2 negative domains) are only good within +-b.x)\n//s=vec2(0,-1) creates an upwards ray, af moves the base up, till vec2(0) touches the bottom\n//s=vec2(1,0) stretches by 1 along .x and moves to the right till vec2(0) is on the surface.\n//any s>0 will create a line segment, where vec2(0) is on the surface, iff one other domain of s==0\nvec2 cirS(vec2 u,vec2 b,float l,vec2 s\n){bvec2 e=lessThan(s,vec2(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;e=greaterThan(s,vec2(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\nvec2 cirS(vec3 u,vec2 b,float l,vec3 s\n){bvec3 e=lessThan(s,vec3(0))\n ;if(e.x){u.x-=b.y*.5;s.x=0.;u.x=min((u.x),0.);}\n ;if(e.y){u.y-=b.y*.5;s.y=0.;u.y=min((u.y),0.);}\n ;if(e.z){u.z-=b.y*.5;s.z=0.;u.z=min((u.z),0.);}\n ;e=greaterThan(s,vec3(0))\n ;if(e.x)u.x-=(s.x+b.y)*.5\n ;if(e.y)u.y-=(s.y+b.y)*.5     \n ;if(e.z)u.z-=(s.z+b.y)*.5 \n ;b.y*=b.x*sat(l)//always scaled by b.x*lod, much easier to use  \n ;u=abs(u)-b.x+b.y;\n ;u-=s*.5     \n ;return cirCore(u,b,l);}\n\nfloat cir(vec2 u,vec2 b,float l,vec2 s){u   =cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec2 u,vec2 b,float l       ){u   =cirS(u,b,l  );return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l,vec3 s){u.xy=cirS(u,b,l,s);return more(u.x,sqrt(u.x),0.)+u.y;}\nfloat cir(vec3 u,vec2 b,float l       ){u.xy=cirS(u,  b,l);return more(u.x,sqrt(u.x),0.)+u.y;}\n\n//without LoD (default to 1.)\nfloat cir(vec2 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec2 u,vec2 b,vec2 s){return cir(u,b,1.,s);}\nfloat cir(vec3 u,vec2 b       ){return cir(u,b,1.  );}\nfloat cir(vec3 u,vec2 b,vec3 s){return cir(u,b,1.,s);}\n\n//without lod & with maximum roundness (b and s swapped to avoid namespace conflict with self)\nfloat cir(vec2 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec2 u,float b,vec2 s){return cir(u,vec2(b,1.),s);}\nfloat cir(vec3 u,float b       ){return cir(u,vec2(b,1.)  );}\nfloat cir(vec3 u,float b,vec3 s){return cir(u,vec2(b,1.),s);}\n//cir was tested in 2d, but 3d may have typos?)\n\n//r=vec2(cos(t),sin(t)) angled point t==0. is a full circle (can have hairline gap)\n//r=radius\n//w.x=straightSegmentLength\n//w.y=straightthickness\n//w.y=roundness\nfloat horseshoe(vec2 u,vec2 c,float r,vec3 w\n){w.z=w.z*w.y\n ;w.y-=w.z\n ;float circle=length(u)-w.z\n ;u.x=abs(u.x)\n ;u=mat2(-c.x,c.y,c.y,c.x)*u\n ;float l=length(u)\n ;u=vec2((u.y>0.)?u.x:l*sign(-c.x),(u.x>0.)?u.y:l)\n ;u=vec2(u.x,abs(u.y-r))-w.xy;\n ;return length(max(u,0.))+ min(0.,max(u.x,u.y))-w.z;\n}//https://www.shadertoy.com/view/WlSGW1\n      \n//uvw==*3 boolean active mirrors' in the coxeter diagram\n////https://www.shadertoy.com/view/MltSD4\nvec2 poly(vec3 p,float type,vec3 uvw//knighty's fold-n-cut polyhedra\n){vec2 o=vec2(0)//iMouse.xy/iResolution.xy //;p*=o.x;uvw*=o.x/nope no easy scaling\n ;o=vec2(0,u5(cos(.61))*.1)\n ;const vec2 tetra=vec2(.5,sqrt(.5))\n ;vec2 m=vec2(.80901699,.30901699)//docecahedral\n ;if(type<2.){m=vec2(.5,sqrt(.5));m=mix(tetra,tetra.yx,step(0.,type));}//tetrahedral/octahedral\n ;vec3 c=vec3(-.5,-m.x,m.y)\n ;float id=1.;//will store a lot of signs\n ;for(int i=0;i<5;i++){id*=4.;id+=sign(p.x)+sign(p.y)*2.;p.xy=abs(p.xy);p-=2.*mi0(dot(p,c))*c;}\n //;id*=4.;id+=sign(p.x)+sign(p.y)*2.;\n ;mat3 y=mat3(0,0,1,m.y,0,.5,0,m.yx)\n ;p-=norma(suv(mu3(uvw,y)))\n ;y[1]=norma(y[1]);y[2]=norma(y[2])\n ;vec3 z=vec3(dd(p-vec3(mi0(p.x),0,0))\n             ,dd(p-vec3(0,mi0(p.y),0))\n             ,dd(p-mi0(dot(p,c))*c));\n ;return vec2(mi(mav(dt(p,y))-o.x*3.,sqrt(miv(z))-o.y),id)//-.05 is a rounded bloney corner\n //the last value later sets saturation(or hue)\n ;}\n\n                      \nstruct v14{float a;vec4 b;};\n                      \nv14 dfPolyMod3(vec3 p\n){vec3 modp=floor(p*.25)\n ;p-=2.+4.*modp\n ;//made up hash of position to an integer 0-15 to yield 16 different polyhedra\n ;float index=mod(5.*modp.x+7.*modp.y+13.*modp.z,16.)\n ;float modindex=mod(index,7.)\n ;//choosing the 'active mirrors' in the coxeter diagram,can be 1,2 or all 3\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;//there are 7 unique shapes with octahedral symmetry,7 with dodecahedral,2 remaining with tetrahedral \n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec2 pp=poly(p,type,vec3(a,b,c))\n ;v14 r=v14(pp.x,-vec4(vec2(pp.y,index/15.).yxyx))\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n \nv14 dfPoly16(vec3 p,float i//.x=distanceP .y=surfaceId .z= i/15.\n){float index=i\n ;float modindex=mod(index,7.)\n ;float a=(mod(modindex,2.)==1.|| modindex==6.)?1.:0.\n ;float b=(modindex<4.)?1.:0.//sign(modindex-4.)//\n ;float c=(modindex>=2.&&modindex<6.)?1.:0.\n ;float d=index<14.?2.:0.\n ;float type=index<7.?1.:d\n ;vec3 oldtype=vec3(poly(p,type,vec3(a,b,c)),index)//previous return type was a vec3\n ;return v14(oldtype.x,-oldtype.yzyz)\n ;}\n\nv14 mi(v14 a,v14 b,float c){return v14(mix(a.a,b.a,c),mix(a.b,b.b,c));}\n\nv14 minxb(v14 a,v14 b){if(a.a<b.a)return a;return b;}//guessing this was what this one does\n                      \nv14 dfPoly(vec3 u\n){float scale=.5\n ;u/=scale\n ;v14 r=v14(zFar,vec4(0))\n ;float tt=.5 //iTime*.5\n ;float ls=3.//lattice scale\n ;v14 s=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt   ,32.)))\n ;v14 q=dfPoly16(u-vec3(0,.5,0)*ls,floor(mod(tt+1.,32.)))\n ;q=mi(s,q,fract(tt))\n ;r=minxb(r,q)\n ;u.xz+=1.5*ls \n ;r=minxb(r,dfPoly16(u,0.))//slow lattice because its not traversed.\n ;r=minxb(r,dfPoly16(u-vec3(0,0,1)*ls,1.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,2)*ls,2.))\n ;r=minxb(r,dfPoly16(u-vec3(0,0,3)*ls,3.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,0)*ls,4.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,1)*ls,5.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,2)*ls,6.))\n ;r=minxb(r,dfPoly16(u-vec3(1,0,3)*ls,7.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,0)*ls,8.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,1)*ls,9.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,2)*ls,10.))\n ;r=minxb(r,dfPoly16(u-vec3(2,0,3)*ls,11.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,0)*ls,12.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,1)*ls,13.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,2)*ls,14.))\n ;r=minxb(r,dfPoly16(u-vec3(3,0,3)*ls,11.))/**/\n //so , a BVH for each sphere coul.d help a marcher, but then it also taps for color\n ;r.b.x=r.b.y*.5//sloppy bridge conversion, todo, fix this as soon as the conversion is done.\n //;v14 r=v14(pp.x,-pp.yzyz)\n ;r.a*=scale\n ;return r\n //;return vec3(poly(p,type,vec3(a,b,c)),index/15.).xzy//last value later sets hue(or saturation)\n ;}\n\n                      \n//Goursat Surface is an implicit surface with VERY high [rootMultiplicity\n//it is THE goto if you want high exponents, high precision and high performance\n//because it excessively pow(a,2.) and pow(a,4.) over 3 domains\n//no NOT confuse exp2(a)=pow(2.,a )=ex(2.,a )=e2(a)\n//with             (a*a)=pow(a ,2.)=ex(a ,2.)=p2(a)=mu(a,a)\n//goursat has not good LipschitzContinuity, scales with distance to singularities!\nd2 sdGoursat(c2 p,v3 m//https://www.shadertoy.com/view/XlV3Dy\n){d2 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d2 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d2 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n                    \nd3 sdGoursat(c3 p,v3 m//4d goursat surface or some sort of shadow?\n){d3 a=p2(p.x),b=p2(a);a=mu(5.,a)\n ;d3 c=p2(p.y),d=p2(c);c=mu(5.,c)\n ;d3 e=p2(p.z),f=p2(e);e=mu(5.,e)\n ;d=ad(d,f);c=ad(c,e)\n ;b=ad(b,d);a=ad(a,c)\n ;b=su(b,a)\n ;b=ad(20.*m.x,b)\n ;v0 q=length(b.b.xyz)\n ;q=max(11.8,q)\n ;return di(b,q);}\n\n//known bug:                          \n//r.y==0. results in nan-noise on many cases.//sdUnterprim() has the preprocessor sdUberprim()             \n//yeah, because r.y then sets the thickness of a wall\n             \nd2 sdUnterprim(c2 u,v2 r,v3 m//m is [s]Uberprim\n){c2 d=su(ab(u),m.xyz)\n  //sadly this lower bound for thickness must be this high (for many shape-cases)\n ;if(abs(r.y)<.0004)r.y=.0004//worksafe: abs(wall thickness)>=mEpsilon\n ;v0 t=mu(-2.,m.z)\n ;v0 s=t\n ,w=dd2(r.z,t)\n ;//w=ma(w,.1)\n ;t=di(t,w)\n ;w=di(r.z,w)\n ;d2 q=dd2(ma(d.x,0.),ma(d.y,0.))\n ;q=sr(ab(q))\n ;q=su(q,r.x)\n ;q=ad(q,mi(0.,ma(d.x,d.y))) \n ;//hole support: without this line, all results are convexHulls/holeLess\n #ifndef CONVEX    \n ;q=ab(q)\n ;q=su(q,m.w)\n #endif \n ;d2 f=su(u.z,m.z)\n ;d2 i=mu(q,w)\n ;i=ad(i,mu(f,t))  \n ;i=mi(i,1.)\n ;i=ma(i,0.)\n ;d2 x=su(q,mu(r.z,i))\n ;d2 y=su(f,mu(s,i))\n ;d2 h=ad(u.z,m.z)\n ;d2 g=ma(su(q,r.z),0.)\n ;d2 e=ma(q,0.)\n ;d2 c=dd2(x,y)//dot(diag,diag)\n ;d2 a=dd2(g,h)//dot(h0,h0)\n ;d2 b=dd2(f,e)//dot(h1,h1) //f is read alone later on\n ;a=mi(a,b)\n ;a=mi(a,c)\n ;a=sr(ab(a))\n ;b=su(mu(f,w),mu(q,t))//is a dot()\n ;b=ma(b,d.z)\n ;b=sg(b)\n ;a=mu(a,b)\n ;return su(a,r.y);}\n// m: width, height, depth, thickness\n// r: xy corner radius, z corner radius, bottom radius offset\nd2 sdUberprim(c2 p,v3 m,v2 r\n){m.xy=m.xy-r.x\n #ifdef CONVEX  \n ;r.x=su(r.x,r.y)\n #else\n ;r.x=su(r.x,m.w);m.w=su(m.w,r.y)\n #endif\n ;m.z=su(m.z,r.y)\n ;return sdUnterprim(p,r,m);}//https://www.shadertoy.com/view/MsVGWG\n\n// \"Generalized Distance Functions\" by Akleman and Chen.\n// see the Paper at https://www.viz.tamu.edu/faculty/ergun/research/implicitmodeling/papers/sm99.pdf\n// This set of constants is used to construct a large variety of geometric primitives.\n// Indices are shifted by 1 compared to the paper because we start counting at Zero.\n// Some of those are slow whenever a driver decides to not unroll the loop,\n// which seems to happen for fIcosahedron und fTruncatedIcosahedron on nvidia 350.12 at least.\n// Specialized implementations can well be faster in all cases.\n// Macro based version for GLSL 1.2/ES 2.0 by Tom\n//#define PHI (1.618033988749895)\n#define GDFVector0 vec3(1,0,0)\n#define GDFVector1 vec3(0,1,0)\n#define GDFVector2 vec3(0,0,1)\n#define GDFVector3 normalize(vec3(1,1,1))\n#define GDFVector4 normalize(vec3(-1,1,1))\n#define GDFVector5 normalize(vec3(1,-1,1))\n#define GDFVector6 normalize(vec3(1,1,-1))\n#define GDFVector7 normalize(vec3(0,1,1.61+1.))\n#define GDFVector8 normalize(vec3(0,-1,1.61+1.))\n#define GDFVector9 normalize(vec3(1.61+1.,0,1))\n#define GDFVector10 normalize(vec3(-1.61-1.,0,1))\n#define GDFVector11 normalize(vec3(1,1.61+1.,0))\n#define GDFVector12 normalize(vec3(-1,1.61+1.,0))\n#define GDFVector13 normalize(vec3(0,1.61,1))\n#define GDFVector14 normalize(vec3(0,-1.61,1))\n#define GDFVector15 normalize(vec3(1,0,1.61))\n#define GDFVector16 normalize(vec3(-1,0,1.61))\n#define GDFVector17 normalize(vec3(1.61,1,0))\n#define GDFVector18 normalize(vec3(-1.61,1,0))\n#define fGDFBegin float d=0.;\n// Version with variable exponent.\n// This is slow and does not produce correct distances,but allows for bulging of objects.\n#define fGDFExp(v) d +=pow(abs(dot(p,v)),e);\n// Version with without exponent,creates objects with sharp edges and flat faces\n#define fGDF(v) d=max(d,abs(dot(p,v)));\n#define fGDFExpEnd return pow(d,1./e)-r;\n#define fGDFEnd return d-r;\n// Primitives follow:\nfloat fOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fDodecahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector13) fGDFExp(GDFVector14) fGDFExp(GDFVector15) fGDFExp(GDFVector16)\n fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12)\n fGDFExpEnd}\nfloat fTruncatedOctahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector0) fGDFExp(GDFVector1) fGDFExp(GDFVector2) fGDFExp(GDFVector3)\n fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExpEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r,float e\n){fGDFBegin\n fGDFExp(GDFVector3) fGDFExp(GDFVector4) fGDFExp(GDFVector5) fGDFExp(GDFVector6)\n fGDFExp(GDFVector7) fGDFExp(GDFVector8) fGDFExp(GDFVector9) fGDFExp(GDFVector10)\n fGDFExp(GDFVector11) fGDFExp(GDFVector12) fGDFExp(GDFVector13) fGDFExp(GDFVector14)\n fGDFExp(GDFVector15) fGDFExp(GDFVector16) fGDFExp(GDFVector17) fGDFExp(GDFVector18)\n fGDFExpEnd}\nfloat fOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fDodecahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12)\n fGDFEnd}\nfloat fTruncatedOctahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector0) fGDF(GDFVector1) fGDF(GDFVector2) fGDF(GDFVector3)\n fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDFEnd}\nfloat fTruncatedIcosahedron(vec3 p,float r\n){fGDFBegin\n fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n fGDF(GDFVector11) fGDF(GDFVector12) fGDF(GDFVector13) fGDF(GDFVector14)\n fGDF(GDFVector15) fGDF(GDFVector16) fGDF(GDFVector17) fGDF(GDFVector18)\n fGDFEnd}\nfloat fTruncatedIcosahedronB(vec3 u,float r){return max(fIcosahedron(u,r),fDodecahedron(u,r));}\n\n                      //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r){return max(box(u,vec3(r)),fOctahedron(u,r));}\n\nfloat fTruncatedIcosahedronB(vec3 u,float r,float s){return max(fIcosahedron(u,r,s),fDodecahedron(u,r,s));}\n //mi() incompatibility\n//float fTruncatedOctahedronB(vec3 u,float r,float s){return max(box(u,r),fOctahedron(u,r,s));}\n//well i do not have an exponential box.\n\n                      \n/**///--end__: AD Superprims\n/**///--\n/**///--start: Glyphs\n\nv0 brushNoise(v1 v,v2 r//https://www.shadertoy.com/view/ltj3Wc\n){v+=(noise01(v)-.5)*.02\n ;v+=cos(v.y*3.)*.009\n ;v+=(noise01(v*5.)-.5)*.005\n ;v+=(noise01(v*min(r.y,r.x)*.18)-.5)*.0035\n ;return v.x;}\n\n//\"Magic Fractal\" for fungus/splatters (on metaball), by dgreensp\n//aka MAGIC_BOX-fractal: https://www.shadertoy.com/view/4ljGDd\nv0 fractalFungus(v2 p){p=1.-abs(1.-mod(p,2.));v2 f=v2(0,length(p),0)\n ;for(int i=kifsFungusIter;i>0;i--      \n ){p=abs(p)/(f.y*f.y)-kifsFungusSeed;f.z=length(p);f=v2(f.x+abs(f.z-f.y),f.zz);}return f.x;}\nv0 fractalFungus(v1 u\n){return fractalFungus(m2( .28862355854826727,.6997227302779844 , .6535170557707412\n                         , .06997493955670424,.6653237235314099 ,-.7432683571499161\n                         ,-.9548821651308448 ,.26025457467376617, .14306504491456504)*v2(u,0));}         \n\n//lazy gradient debugger for sweep brush strokes  https://www.shadertoy.com/view/ltj3Wc\n//to be replaced with some smarter stuff\nv2 debugDist(v0 u){v2 r\n //;u*=pi *100.\n ;if(u>0.)r=mix(v2(0, 0,.5),v2(.5,.5,1),sin(u*pi *100.))// red = negative / inside geometry.\n ;else    r=mix(v2(1,.5,.5),v2(.5, 0,0),sin(u*pi *100.))// blue = positive, of of geometry.\n ;r = mix(r,v2(0),sat(abs(u)))// falloff\n ;return r;}\n                      \n//pluginName= iCanvas\n//self: https://www.shadertoy.com/view/ltj3Wc   (brush stroke experiments)\n//crunched by ollj, minor featuures removed.\n//slowly assimilation, to be merged with BuffD\n//duroing that it lives in the sump of the commontap\n//produce a line with brush strokes. the inputs are such\n//that you can apply it to pretty much any line; the geometry is separated from this function.\nv2 colorBrushStroke(v1 u,v2 r,v3 m,v1 p,v0 w, v0 sdGeometry, v2 inpColor, v3 bc//brushColor\n){w=(u.y/w)// position along the line. in the line is 0-1.\n ;if(false ){ //important for uv debugging\n  ;//return mix(inpColor, v2(0), dtoa(sdGeometry, 1000.));// reveal geometry.\n  ;//return mix(inpColor, debugDist(u.y), dtoa(sdGeometry, 1000.));// reveal Y\n  ;//return mix(inpColor, debugDist(w), dtoa(sdGeometry, 1000.));// reveal pos in line.\n  ;return mix(inpColor, debugDist(u.x), dtoa(sdGeometry, 1000.));// reveal X\n  ;}\n ;if(w>0.   // warp position-in-line, to control the curve of the brush falloff.\n ){v0 mouseX=m.x==0.?.2:(m.x/r.x)\n  ;w = pow(w, (pow(mouseX,2.)*15.)+1.5);}\n ;v0 n=0.//bleed noise\n +noise01(u*v1(min(r.y,r.x)*.2, 1.))//tiny\n +noise01(u*v1(79,1))//fine\n +noise01(u*v1(14,1))//coarse\n ;n*=dtoa(sdGeometry, 300.)/3.// keep stroke texture inside geometry.\n ;n=max(.08,n)//null-evasion\n ;v0 a=pow(n,max(0.,w)+.09)//add allows bleeding\n ;if(w>0.)a=max(0.,a-pow(w,0.5))//optioonal more fading\n ;a=sh4(a)+.4*smoothstep(17.,18.5,fractalFungus(v2(p,u.x)))//hermite+fungalFreckles\n ;bc.a=sat(a*bc.a*dtoa(sdGeometry,paperbleed(p)))\n ;return mix(inpColor,bc.xyz,bc.a);}\nv2 strokeLine(v1 u,v2 r,v3 M,v2 c, v3 b, v3 m, v0 w\n){v0 lineAngle=atan(m.x-m.z,m.y-m.w)//axis-align\n ;m1 rotMat =rot2D(lineAngle)\n ;v0 W=length(m.xy-m.zw)    // make an axis-aligned line from this line.\n ;v1 T=m.xy*rotMat// top left\n ;v1 B=T+v1(0,W)// bottom right\n ;v1 l=u*rotMat\n ;l.x+=(noise01(l*1.)-.5)*.02\n ;l.x+=cos(l.y*3.)*.009//lp wave\n ;l.x+=(noise01(l*5.)-.5)*.005;//random waviness like individual strands are moving around\n ;l.x+=(noise01(l*min(r.y,r.x)*.18)-.5)*.0035;// HP random noise makes it look less scientific\n ;v0 d=sdAxisAlignedRect(l,T,B)-w/2.\n ;return colorBrushStroke((T-l)*v1(1,-1),r,M,u,W,d,c,b);}\n//https://en.wikipedia.org/wiki/Enso\n//japanese zen glyph, dualism-enlightenment circle, a signature that captures a moment in time.\nv2 humanizeEnso(v1 u,v2 R,v0 r,v0 lineLength//return: xy=u, z = radius\n){v1 v=u\n ;v.x+=v.y*.24/lineLength//offset circle along its path for a twisting effect.\n ;r+=(noise01(u*1.)-.5)*.04\n ;r+=sin(u.y*3.)*.019//lp wave\n ;v.x+=sin(u.x*30.)*.02\n ;v0 b=min(R.y,R.x)*.18\n ;v.x+=(noise01(u*b )-.5)*.0035//HP random noise makes it look less scientific\n ;v.x+=(noise01(u*5.)-.5)*.005 //random waviness like individual strands are moving around\n ;return v2(v,r);}\n//sweepAmt is 0 to 1, the amount of the circle to cover by the brush stroke. \n//1=whole circle. 0=just a point.\n//u,canvasColor,brushColor,n,angle,sweepAmt,lineWidth\nv2 enso(v1 u,v2 R,v3 M,v2 c, v3 b,v1 o,v0 n, v0 a, v0 sweepAmt, v0 w\n){v1 v=u-o\n ;//v2 R=iResolution\n ;//v3 M=iMouse\n ;v0 angle = mod(atan(v.x, v.y)-a,tau)\n ;v0 d=n*tau//is far from euclidean due to all noise below. \n ;v=v1(n-length(v),angle* d/tau)\n ;v0 lineWidth1=w*mix(1.,.9,smoothstep(0.,d,v.y))//narrow end\n ;v2 h=humanizeEnso(v,R,n,d)\n ;v0 e=max(-length(u-o)+h.z,length(u-o)-h.z)\n ;e-=lineWidth1*.5// round off\n ;v2 r=v2(1),r2=colorBrushStroke(h.xy,R,M,u,d,e,c,b)\n ;if(angle>pi //modifies h, so above line cant go below\n ){v.y-=d\n  ;h=humanizeEnso(v,R,n,d)\n  ;v1 strokeStartPos=o+v1(sin(a),cos(a))*h.z      \n  ;e=length(u-strokeStartPos)-w*.5*1.// round off things just like in the line routine.\n  ;r=colorBrushStroke(h.xy,R,M,u,d,e,c,b);}\n ;return min(r,r2);}\nv2 brushCircle(v1 u,v2 r,v3 m,v2 c\n){return enso(u*v1(1),r,m,c,v3(0,0,0,.9)\n                           ,v1(0,0),// origin\n                            .6,.2,.5,.3)// radius, angle of brush start, sweep amt 0-1, width\n;}    \nv2 redline0(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return strokeLine(u,r,m,c,v3(v2(.8,.1,0),.9),v3(-1.4,yo-.4,2.6,yo-.4),.3);}\nv2 redline1(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),.4),v3(1.3,yo,-2.9,yo),.03);}\nv2 redline2(v1 u,v2 r,v3 m,v2 c,v0 yo\n){return c=strokeLine(u,r,m,c,v3(v2(.8,.1,0),0.52),\n                           v3(1.3,.3+yo+(cos(u.x*12.)*.025),-2.9,.3+yo),.1);}\n//shitty subroutine is shitty\nv1 getuv_centerX(v1 fragCoord,v2 r, v1 newTL, v1 newSize\n){v1 ret = v1(fragCoord.x / r.x, (r.y - fragCoord.y)/r.y)\n ;// ret is now 0-1 in both dimensions\n ;ret*=newSize// scale up to new dimensions\n ;v0 aspect = r.x / r.y\n ;ret.x *= aspect// orig aspect ratio\n ;v0 newWidth = newSize.x * aspect\n ;return ret + v1(newTL.x - (newWidth-newSize.x) / 2.0, newTL.y);}\nv3 ltj3Wc(v3 o, in v1 u,v2 r,v3 m\n){//v2 r=iResolution\n ;//v3 m=iMouse\n ;//o=v3(.01*magicBox(v2(u/iResolution.xy,iMouse.x)));return;//debug hash\n ;v1 uv=(u/ r.y * 2.0) - 1.\n ;u = getuv_centerX(u,r, v1(-1,-1), v1(2,2))// 0-1 centered\n ;v2 c=v2(1.,1.,0.875)// bg\n ;v0 dist\n ;// geometry on display...\n ;v0 yo = sin(-u.x*pi*0.5)*0.2\n ;c=redline0(u,r,m,c,yo)\n ;c=redline1(u,r,m,c,yo)\n ;c=redline2(u,r,m,c,yo)\n ;c=brushCircle(u,r,m,c)\n ;// paint blotches\n ;v0 blotchAmt = smoothstep(20.,50.,fractalFungus((u+12.)*2.))// smoothstep(40.,40.5, fractalFungus((uv+9.4)*2.));\n ;blotchAmt = pow(blotchAmt, 3.)// attenuate\n ;blotchAmt = .7*smoothstep(.2,.4,blotchAmt)// sharpen\n ;c*=1.-blotchAmt\n ;// signature/stamp code removed\n ;c.rgb+=(rand(u)-.5)*.08// grain\n ;c.rgb=sat(c.rgb)//clamp\n ;v1 uvScreen=(u /r.xy * 2.)-1.\n ;//c*=1.-dot(uvScreen*.5,uvScreen*.62)// vignette\n ;return v3(c,1);}\n//note to self, this shader uses amt in leu of amount\n//, so the term \"sweep amt\" is somewhat coined in a new context\n                          \n/**///--end__: Glyphs\n/**///--\n/**///--start: AD march RayMarchingPrimitivesBasic                 \n                      \n//return distance to unit sphere\nd2 fSphere(c2 p){d2 q=sd(p.x,p.y,p.z);return su(q,1.);}\n\n//#u,o,t) distance between (u) and segment  from   (o) to     (t)   (strethed dot always does sqrt)\n//    ray(u,o,t) distance between (u) and ray      from   (o) trough (t)   \n//   line(u,o,t) distance between (u) and line     though (o) trough (t)  \n//    ray(u)     distance between (u) and ray      from (0,0) trough (0,1) \n#define segment2(a,c,d) dd(su(a,mu(c,d(di(dt(a,c),dd(c))))))      \n#define segments(u,o,t,d) (segment2(su(u,o),su(t,o),d))\n#define segment(u,o,t) sqrt(segments(u,o,t,sat))\n#define    line(u,o,t) sqrt(segments(u,o,t,nul))\n#define rAy(c) float ray(c u,c o,c t){if(dot(u-o,t-o)<0.)return length(u-o);return line(u,o,t);}\nrAy(v0)rAy(v1)rAy(v2)rAy(v3)\nfloat ray(v1 u){if(u.x>0.)return length(u);return u.y;}   \n\n\n//vec2 from_angle(float t){return vec2(cos(t),sin(t));}//angle2Normal\nvec2 from_cos(float u){u=clamp(u,-1.,1.);return vec2(u,sqrt(1.-u*u));}//cos2normal\nfloat ellipse_dist(vec2 p,vec2 ab,out vec4 coeffs,out vec4 roots,out bool is_circle,out int k\n){float sig=sign(p.y);p.y=abs(p.y);vec2 ds=vec2(1e5,-1)//signed distance\n ;is_circle=abs((ab.x-ab.y)/ab.x)<1e-2//is important for precision reasons,is a useful BVH-shortcut.\n ;if(is_circle//near-circles are special quadratic case of a quartic ellipse\n){float dc=length(p)-ab.x;float u=normalize(p).x;roots=vec4(u,0,0,-u);coeffs=vec4(0,1,0,-u*u);ds=vec2(abs(dc),dc)\n ;}else{//ellipse\n  //formulate quartic polynomial of ellipse. solve for position u=cos(theta)along ellipse \n  //so that the tangent at the point [a*u,b*sqrt(1-u^2)] is perpendicular to the displacement between p and the point itself\n  //this gets 2 or 4 solutions. we need to inspect each of them in the arc case\n  ;float l=ab.y*ab.y-ab.x*ab.x,ax=ab.x*p.x/l,by=ab.y*p.y/l,a2x2=ax*ax,b2y2=by*by\n  ;coeffs=vec4(2.*ax,(a2x2+b2y2)-1.,-2.*ax,-a2x2)// vector of polynomial coefficients\n  ;roots=solve_quartic(coeffs)// solve for up to 4 roots \n  ;roots=mix(roots.xzyw,roots,step(-sig,0.))//optional root sorting within homotopy,green always on top,disregarding u.y\n  ;roots=mix(roots,roots.xzyw,step(ab.y,ab.x))//optional root sorting within homotopy,green always on top,disregarding ellypsoid/ratio.\n  ;for(int i=0;i<4;++i//for each root\n ){vec2 c=ab*from_cos(roots[i])// get absolute distance to the closest point on the ellipse,as well as its sign\n   ;vec2 b=vec2(length(p-c),dot(p-c,c))\n   ;float s=sign(ds.x-b.x)*.5+.5\n   ;k=k+i*int(s)\n   ;ds=mix(ds,b,s)\n ;}}return ds.x*sign(ds.y);}\n\n/**///--end__: march RayMarchingPrimitivesBasic\n/**///follows:\n/**///--start: march bezier \n\n//[follows], because segment() is special case of bezier()\n   \n//http://www.perbloksgaard.dk/research/DistanceToQuadraticBezier.jpg\n//BezierQuad is ALWAYS coplanar (3 CVs define a plane)\n//dot()projection to 2d, and a fold to 1d, simplify  lot\n                      \n//there is likely a better check for colinearity\n//this one may even fail iff any 2 of 3 points are identical.\nbool isColinear(v1 a,v1 b,v1 c){return length(norma(a-b)-norma(a-c))<.001;}\n\n//return distance of u to bezierQuad with CVs(a,b,c); is (always) coplanar 2d.\nv1 dQBezierSub(inout v1 u,inout v1 a,inout v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){b=mix(b+v1(1e-4),b,abs(sign(b*2.-a-c)))//catch colinear case\n ;u-=a;a=b-a;b=c-b-a\n ;return solveCubic2b(v2(-3.*dot(a,b),dot(u,b)-2.*dd(a),dot(u,a))/-dd(b));}\n#define BezierQuadTail(u,a,b,c) min(dd((a*2.+b*c.x)*c.x-u),dd((a*2.+b*c.y)*c.y-u))\n\n//return distance of u to Parabola over bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadParabola(v1 u,v1 a,v1 b,v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuad(v1 u, v1 a, v1 b, v1 c//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=sat(c);//a bezier is a clamped 2dParabola\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n\n//return distance of u to bezierQuad, with CVs(a,b,c); is (always) coplanar 2d.\nv0 BezierQuadGeneral(v1 u, v1 a, v1 b, v1 c,v1 m//..input[b] is not on the liine,but defines a triangle bound.\n){if(isColinear(a,b,c))return segment(u,a,c);\n ;c=dQBezierSub(u,a,b,c)//modifies u,a,b, and sets c, thats 5 floats changing!\n ;c=clamp(c,m.x,m.y)//https://www.shadertoy.com/view/Xl3BRX\n                  //bezier is just a clamped parabola\n                   //from [[0].. [.5]..[1]] , which bijectively maps to [a..b..c]\n                   //a better range would be [-1..1], to map better onto this function?\n ;return sqrt(BezierQuadTail(u,a,b,c));}\n#define rot(a) m1(cos(a),sin(a),-sin(a),cos(a) )\n\n//return p1 of quadratic bezier, when given start, end and arclength\nv1 knee(v1 p0,v1 p2,v0 L){v1 l=p2-p0;float s=L*L//https://www.shadertoy.com/view/4ltyWr\n ;return .5*((p0+p2)+sqrt(max(0.,s-dot(l,l)))*sign(L)*norma(v1(-l.y,l.x)));}\n\n/**///--end__: march bezier \n/**///--\n/**///--start: RE mach RayMarchingPrimitivesBasic (with global for relativity)                  \n\n                      \nv0 maxGISize;//what is this?\n                      \nv0 sphere(v3 ray,v2 u, v0 radius\n){maxGISize = max(maxGISize,radius*ray.w)\n ;return ray.w*(length(ray.xyz-u)-radius);}\nv0 cylinderY(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize=max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xz-u.xz)\n -radius, abs(ray.y-u.y)-height));}\nv0 cylinderZ(v3 ray,v2 u, v0 radius, v0 height\n){maxGISize = max(maxGISize,height*radius*ray.w)\n ;return ray.w*(max(length(ray.xy-u.xy)\n -radius, abs(ray.z-u.z)-height));}\nv0 cube(v3 ray, v2 u, v0 size\n){maxGISize = max(maxGISize,size*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}\n\nv0 REbox(v3 ray, v2 u, v2 size\n){maxGISize = max(maxGISize,length(size)*ray.w)\n ;ray.xyz = abs(ray.xyz-u) - size\n ;return ray.w*max(max(ray.x,ray.y),ray.z);}   \n\n//c.xy=sin/cos of angle. r is the radius //uppr segment is always round\nfloat pieSlice(vec2 u,vec2 c,float r //a simple packman\n){u.x=abs(u.x)\n ;v0 l=length(u)-r\n ;v0 m=length(u-c*clamp(dot(u,c),0.,r) )\n ;return max(l,m*sign(c.y*u.x-c.x*u.y));}//https://www.shadertoy.com/view/3l23RK\n\n// trapezoid / capped cone, specialized for Y alignment\nfloat sdTrapezoid( in vec2 p, in float r1, float r2, float he\n){vec2 k1 = vec2(r2,he);\n    vec2 k2 = vec2(r2-r1,2.0*he);\n\tp.x = abs(p.x);\n    vec2 ca = vec2(max(0.0,p.x-((p.y<0.0)?r1:r2)), abs(p.y)-he);\n    vec2 cb = p - k1 + k2*clamp( dot(k1-p,k2)/dd(k2), 0., 1. );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0\n   ;return s*sqrt( min(dd(ca),dd(cb)));}//https://www.shadertoy.com/view/MlycD3\n\n//polygon distance does crossingCumbers, has better (rounded) interios than windingnumbers.\nconst int N = 5;\nfloat sdPoly(vec2[N] v, in vec2 p\n){const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }return s*sqrt(d);}//https://www.shadertoy.com/view/wdBXRW\n      \n/**///--end__: RayMarchingPrimitivesBasic\n/**///--\n/**///--start: Relativity\n\n\n//bellow code is RE7:\n                          /*\nrelativistic engine, with mutable/slower speedOfLight\nsimulates:\n- Delayed view of far objects\n- Doppler Red/blue shifts of color\n- Field of view distortion\n- Relativistic Length Contractions\n- Relativistic Time Dilation + (Doppler & proper velocity consequences)\n- blue-shifted light in the movement direction\n- , and red-shifted behind you. Because of doppler effect.\n- - hard shadows, that may move slower trough spacetime\n- Relativistic simultaneity view (SimultaneousEvents = 1. & cLag = 0.)\n- - To better see the train paradox:\n- - - put cLag & FOVAberrationOfLight to zero\n- - Explanations : While at rest in front of the tunnel\n- - ,watch the shrinked train entering and fitting in the tunnel\n- - ,But if you move along with the train, this one won't be shrinked\n- - ,but the tunnel will be\n- - ,the train will no longer fits in the tunnel. \n- - But... what happens if one close the tunnel doors at this time ?\n- Twin Paradox :\n- - Waiting for the train at a corner to make a whole return trip \n- - will take more time than moving along with it.\n-See the result of a blinking light, slowly drawing waves on the walls.\n-see correctly distorted field of view \n- ,by moving along with the train and notice\n- ,that it is not distorted anymore but the rest is\n- ,by setting the speed of light to a large number\n- ,the train will be exactly the same.\nblatantly false\n- shadows are unaffected by gravity\n- the black hole is a physical pitch black sphere, and as such it casts a SHARP shadow\nDoes not simulate:\n- Doppler additionnal shift when space is contracted, not sure...\n- The rotating object in the middle of the scene is not really affected by doppler color shifting\n- Mass of object\n/**/\n//ESDF keyboard layout is more compatible with more layputs (french)\n#define KEY_E 69.5\n#define KEY_S 83.5\n#define KEY_D 68.5\n#define KEY_F 70.5\n//light settings\n#define cSpe 2.5\n//SpeedOfLight in meter/second\n//divides by /(cSpe*cSpe), so do not make it too large!\n#define cLag 1.\n//PhotonLatency [0..1]; zero=instant vision,makes easier to see how relativity affect time & space\n#define FOVAberrationOfLight 1.\n//take relative velocity of photons to camera & distort field of view\n//optical settings\n#define dopplerFactor .5\n//take player/object/light vel to shift color\n#define repeatDoppler 0\n//relativity\n#define LgthContraction  1.\n//shrink map along velocity vector at high speed\n#define TimeDilation 1.\n//speed map frame time at high speed\n#define SimultaneousEvents 1.\n//see past behind you, futur foward at high speed (not supposed to be observed)\n#define relativisticDoppler .2\n//take light source speed into account and their own time dilation\n//black hole\n#define BlackHoleMassFactor 2.\n#define AccretionDisk 2.\n//player and cam\n#define fishEye false\n#define FOV 1.3\n//1.57 = 90\n#define maxSpeed 2.4\n//do not go over speed of light it breaks time & space\n#define thrustForce 15.\n//player acceleration\n#define RayPrecision 1.\n#define MaxRayDist 9.0\n#define numMats 7\n#define numLights 3\n#define GI 1.3\n#define GIDist 2.5\n#define gravity v2(0.,-3.,0.)\n                      \n//#define SetMaterial(matID) if (rDist < lastrDist) r.material = nextMat; nextMat = matID; lastrDist = rDist;\n#define beginMaterial(matID) if (matID == processedMaterial || processedMaterial == -1) { nextMat = matID; lastrDist = o;\n#define endMaterial() } if (o != lastrDist) rayMat = nextMat;  \n//#define SetMaterial(matID) if (processMaterials) SetMaterialID(MatID);\ni0 nextMat;\ni0 rayMat;\ni0 rayObj;\nv0 matSize;\nv0 lastrDist;\nv0 lastrDistObj;\nv3 volumetricCol;\n//BuffCoords of [RE] must be\n//- the same for [Re] and [Image] (therefore commonTab)\n//- mutually exclusive (within [Re] buffer]\n//- 0<=x<Resolution.xy\n#define RePos   0.\n#define RePosD  1.\n#define ReQua   2.\n#define RePosDD 3.  //not used by Image\n#define ReQuaD  4.  //not used by Image\n#define ReTime  5.\n#define ReCol   6.  //not used by Image\n#define ReCamR  7.  //not used by Image\n#define RePosDP 8.  //not used by Image\nv0 varWdth=1.;\n//#define ReTraT  9.  \n//v0 PROPER_D_POS = 8.;\n//v0 TRAIN_TIME = 9.;\n\n                      /*\n//v0 varWdth = 5.;\n/*\nv0 POS = 0.;\nv0 D_POS = 1.;\nv0 DD_POS = 2.;\nv0 QUAT = 3.;\nv0 D_QUAT = 4.;\nv0 TIME = 5.;\nv0 COLLISION = 6.;\nv0 CAM_PITCHYAW = 7.;\nv0 PROPER_D_POS = 8.;\nv0 TRAIN_TIME = 9.;\n*/\n\n//webgl1==openglEs100 does not allow arrays of structs (classes)\n//structs are replaced by namespace-wasting arrays of structparams: \n#define objNum 7\n//object array enum labels objectId\n#define oCam        0\n#define oCubeChil   1\n#define oCubeMy     2\n#define oBlackHole  3\n#define oTrain      4\n#define oTunnel     5\n#define oTunnelDoor 6\n//for below object properties;\nv3 [objNum] objRot;//rotation\nv2 [objNum] objPos;//position\nv2 [objNum] objVel;//velocity\nv2 [objNum] objSca;//scale\n//v0[objNum] objRad;//radius optimization\n//\n                      \n//lights have no labels\nv3[numLights] oliCol;//colorIntensity;\nv2[numLights] oliPos;//position\nv0[numLights] oliHal;//HaloResult\n//v0[numLights] oliSiz;//size\nv0 lorentzF;\n//mat3x3 LZLgthContract;\nv2 pos;\n//v2 dpos;\nv0 playerTime;\nint curObj = 0;//es100 error , first class array\nint minObjDepth = -1; \n                      \n//DopplerShift\nv0 GetMatch(v2 c,v2 s,v0 t //col,shiftedFreq,targetFreq\n){s=log2(s)-t\n #if repeatDoppler >0  \n ;s=fract(s)\n ;c*=max(max(v2(0),1.-abs(s)*3.),1.-abs(s-1.)*3.)\n #else\n ;c*=max(v2(0),1.-abs(s)*3.)\n #endif\n ;return c.x+c.y+c.z;}\n//dopplerShiftFactor\nv2 dsf(v2 c,v2 f//all values of f are identical.\n){f*=v2(1.,1.257,1.58)\n ;v2 r=v2(1,2,4)/3.\n ;return v2(GetMatch(c,f,0. )+GetMatch(c,f,1.)*.3+GetMatch(c,f,-r.x)*.2\n             ,GetMatch(c,f,r.x) \n             ,GetMatch(c,f,r.y)+GetMatch(c,f,1.)*.5+GetMatch(c,f,r.z)*.25);}\nv2 dsf(v2 c,v0 f){return dsf(c,v2(f));}\n//v2 DopplerShift(v2 c,v0 s//color,speed\n//){return dsf(c,v2(cSpe/(cSpe-s*dopplerFactor)));}\nv3 Transform(int i,v3 p\n){p.xyz=objPos[i]-p.xyz\n ;p.xyz=qr(objRot[i],p.xyz)\n ;p.xyz/=objSca[i]\n ;p.w*=dot(v2(1),abs(objSca[i]))/3.//distance field dilation approx\n ;return p;}\nvoid ProcessCamPos(v2 u, v3 rot\n){objPos[oCam]= u\n ;objRot[oCam]=rot;}//es100 error , no array of class allowed\nv0 LorentzFactor(v0 v//velocity\n){v=(v*v)/(cSpe*cSpe)\n ;return 1./(sqrt(1.-min(v,.9999)));}\nv2 dpos;//relevant for each pixel of [RE] and [Image] \nvoid ProcessObjectPos(v0 time\n){objPos[oCubeMy]=v2(0) \n ;objRot[oCubeMy]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oCubeMy]=v2(.8)//es100 error , no array of class allowed\n ;objPos[oBlackHole]=v2(5.,sin(time*0.2),-5.)//es100 error , no array of class allowed\n ;objRot[oBlackHole]=aa2q(time*2.,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oBlackHole]=v2(1)//es100 error , no array of class allowed\n ;objPos[oCubeChil]=v2(1)//es100 error , no array of class allowed\n ;objRot[oCubeChil]=aa2q(time*1.,norma(objPos[oCubeChil]))//es100 error , no array of class allowed\n ;//o_myCubeChildren.rot = v3(0,0,0,1)\n ;objSca[oCubeChil]=v2(.4)//es100 error , no array of class allowed\n ;v0 trainV = 2.2\n ;objVel[oTrain]= v2((floor(mod(trainV*time/16.,2.))*2.-1.)*trainV,0,0)//es100 error , no array of class allowed\n ;v0 trainDir = 1.\n ;if (objVel[oTrain].x < 0.)trainDir = -1.//es100 error , no array of class allowed\n ;objPos[oTrain]=v2(abs(1.-mod(trainV*time/16.,2.))*16.-8.,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTrain]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTrain]= v2(1.,1.,trainDir/mix(LorentzFactor(trainV*LgthContraction),1.,cLag))\n ;//objects[o_train].b.x = 0.//es100 error , no array of class allowed\n ;objPos[oTunnel]=v2(0,-.8,9.)//es100 error , no array of class allowed\n ;objRot[oTunnel]=aa2q(pi*.5,v2(0,1,0))//es100 error , no array of class allowed\n ;objSca[oTunnel]=v2(1.,1.,1)//es100 error , no array of class allowed\n ;objPos[oTunnelDoor]=objPos[oTunnel]//es100 error , no array of class allowed\n ;objRot[oTunnelDoor]=objRot[oTunnel]//es100 error , no array of class allowed\n ;v0 open = clamp((1.-abs(3.*objPos[oTrain].x))*2.,0.,1.)//es100 error , no array of class allowed\n ;objSca[oTunnelDoor]= v2(open,open,1);}//es100 error , no array of class allowed\n//es100 error , no array of class allowed\nvoid ProcessLightValue(v0 t\n){oliPos[0]=v2(6.,1.,sin(t))\n ;oliCol[0]=3.*v3(0.2,1.,.2,1)\n ;oliPos[1]=v2(-3,-2.2,sin(t*.3)*8.)\n ;oliCol[1]=2.*v3(1,1,0.5,1)\n ;oliPos[2]=v2(9.5,1.8,9.5)\n ;oliCol[2]=3.*max(0.,abs(sin(pi*t)))*v3(1,.2,1,1);}\nvoid SetTime(v0 t){ProcessLightValue(t);ProcessObjectPos(t);}//es100 error , no array of class allowed\n#define beginObj(objID,var) Transform(objID,var); curObj=objID;  lastrDistObj = o;\n#define endObj() if(o!=lastrDistObj)rayObj=curObj;lastrDistObj=o;\n#define ADD(f) o=min(o, f);\n#define SUB(f) o=max(o,-f);\n#define VOL(func)  if (func < rDist)\n//volume marching accumulator, used for blackHoleAccretionDisk\nv0 vma=0.;\nv0 map(v2 pos, int processedMaterial\n){v0 o = 0. //0. if first operation is a SUB(), 1e10 otherwise\n ;maxGISize = 0.\n ;rayObj = 0\n ;v3 w = v3(pos,1)//worldSpace\n ;beginMaterial(0)\n ;SUB(REbox(w,v2(0,0,0),v2(10,2.5,10)))\n ;ADD(cylinderY(w,v2(-6,0,-2.),0.1,3.))\n ;ADD(cylinderY(w,v2(5,0,-2.),0.1,3.))\n ;endMaterial()\n ;v3 c=beginObj(oCubeMy,w)//cubespace, not color\n ;//ADD(REbox(c,v2(0,0,0),v2(1)))\n ;//c.xz = abs(c.xz)\n ;for(int i=0;i<4;i++\n ){beginMaterial(i)\n  ;ADD(sphere(c,v2(0,0,0),1.))\n  ;endMaterial()\n  ;c=abs(c)\n  ;c=beginObj(oCubeChil,c);}\n ;v3 blackHoleSpace = beginObj(oBlackHole,w)\n ;beginMaterial(8)\n ;ADD(sphere(blackHoleSpace,v2(0,0,0),.5))\n ;endMaterial()\n ;v3 tunnelSpace = beginObj(oTunnel,w)\n ;beginMaterial(3)\n ;ADD(REbox(tunnelSpace,v2(0,.5,0),v2(.2,.1,1.5)))\n ;ADD(REbox(tunnelSpace,v2(0,-.5,0),v2(.2,.1,1.5)))\n ;endMaterial()\n ;v3 tunnelDoorSpace = beginObj(oTunnelDoor,w)\n ;beginMaterial(4)\n ;ADD(REbox(tunnelDoorSpace,v2(0,0,1.4),v2(.2,.4,0.1)))\n ;ADD(REbox(tunnelDoorSpace,v2(0,0,-1.4),v2(.2,.4,0.1)))\n ;endMaterial()\n ;v3 trainSpace = beginObj(oTrain,w)\n ;beginMaterial(7)\n ;ADD(REbox(trainSpace,v2(0,0,-.8),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0,-.4),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0)      ,v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0, .4),v2(.1,.1,.18)))\n ;ADD(REbox(trainSpace,v2(0,0,.68),v2(.1,.1,.06)))\n ;ADD(cylinderZ(trainSpace,v2(0,.04,.8),.07,.18))\n ;endObj()\n ;endMaterial()\n ;v0 temp = max(0.,(1.-20.*abs(blackHoleSpace.y)))\n ;v0 tmpGauss = length(blackHoleSpace.xz)-1.5\n ;o=min(o,max(0.1,max(abs(blackHoleSpace.y),.5*abs(tmpGauss))))\n ;temp*=o*pow(2.7,-(tmpGauss*tmpGauss)/.1)\n ;vma+=(1.-vma)*temp*AccretionDisk\n ;for(int L=0; L<3; L++\n ){\n  ;ADD(sphere(w,oliPos[L]\n              //o_lights[L].b\n              ,0.001))\n  ;\n  ;v2 relPos = oliPos[L]-pos//o_lights[L].b\n  ;oliHal[L]//o_lights[L].haloResult \n      += o*(0.02/(dot(relPos,relPos)+0.01))\n  ;}\n ;return o;}\nv3 GetNormal(v2 u\n){v1 e = v1(0.003,0.)\n ;v0 o=map(u,-1)\n ;return v3(norma(v2(map(u+e.xyy,-1)\n                    ,map(u+e.yxy,-1)\n                    ,map(u+e.yyx,-1))-o),o);}\n\n//--end__: Relativity\n//--\n//--start: barycentric\n\n#define transp23 vec3(a.x,b.x,c.x),vec3(a.y,b.y,c.y)\n\n//(X) are 3 .x values of triangle corners (abc) (Y) are its .y values \n//return reciprocal determinant\nfloat c2bdet(vec3 X,vec3 Y){return 1./suv(perp(X.xy-X.z)*(Y.xy-Y.z));}\nfloat c2bdet(vec2 a,vec2 b,vec2 c){return c2bdet(transp23);}\n//return barycentric of carthesian point (l) over triangle (a,b,c)==(X,Y)\nvec3 c2b(vec2 p,vec3 X,vec3 Y,float d){p-=vec2(X.z,Y.z)\n ;vec4 a=vec4((vec4(X.xy,Y.xy)-vec4(X.zz,Y.zz))*vec4(1,-1,-1,1)).wyzx*p.xyxy\n ;p=vec2(suv(a.xy),suv(a.zw))*d;return vec3(p,1.-p.x-p.y);}\nvec3 c2b(vec2 p,vec3 X,vec3 Y){return c2b(p,X,Y,c2bdet(X,Y));}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c,float d){return c2b(u,transp23,d);}\nvec3 c2b(vec2 u,vec2 a,vec2 b,vec2 c){return c2b(u,transp23);}\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\n      vec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}\n\n//return 3 squared lengths of triangle sides of triangle (a,b,c)\nvec3 getSqoaredLengths(vec2 a,vec2 b,vec2 c){return d3d(a-b,b-c,c-a);}\n//return SQUARED length of vector (p) in barycentric coordinates\n//t=getSqoaredLengths(a,b,c) is intended to be buffered\nfloat lengthBary(vec3 p,vec3 t){return -suv(t*p.yxx*p.zzy);}\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Distance_between_points               \n\n     \n//shortest carthesian distance may be different than euclidean. even to the 3 points??\n//anyways, this is buggy, and i cant find the bug.\n\nfloat segmentS(vec2 u,vec2 o,vec2 t\n){u=u-o\n ;t=t-o\n ;o.x=(dot(u,t)/dd(t))\n ;t*=sat(o.x)\n ;return (dd(u-t));}\n      \nfloat segmentB(vec2 u,vec2 o,vec2 t){\n ;return sqrt(segmentS(u,o,t));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;return sqrt(min(a,b));}\nfloat segmentB(vec2 u,vec2 o0,vec2 t0,vec2 o1,vec2 t1,vec2 o2,vec2 t2){\n ;float a=segmentS(u,o0,t0)\n ;float b=segmentS(u,o1,t1)\n ;float c=segmentS(u,o2,t2)\n ;return sqrt(min(min(a,b),c));}\n\n/*\n//return carthesian of barycentric point (l) over triangle (a,b,c)==(X,Y)\nvec2 b2c(vec3 l,vec3 X,vec3 Y){return vec2(suv(X*l),suv(Y*l));}\nvec2 b2c(vec3 l,vec2 a,vec2 b,vec2 c){return b2c(l,transp23);}/**/\n\n//return any POSITION-of input the (a.xyz) is >0||<1||<2/3 (for clamp()ed pointer vectors)\n//for carthesian coordinates, this can point at relatively specific sectors/directions\n//faster than finding the POSITION-OF the smallest of 3. values otherwise.\n\nint getPos0(vec3 a){if(a.x<0.)return 0;if(a.y<0.)return 1;return 2;}\nint getPos1(vec3 a){if(a.x>0.)return 0;if(a.y>0.)return 1;return 2;}\nint getPos2(vec3 a){const float twothirds=2./3.\n   ;if(a.x<=twothirds)return 0;if(a.y<=twothirds)return 1;return 2;}\n//above are subroutines for sdTriangle() below\n//instead of 2 short ranged mod(a,b), we just branch and substract:\n#define lazymods int i=g+1;if(i>2)i-=3;int h=g+2;if(h>2)h-=3\n//return distance of (u) to triangle with corners (p[0].xy,p[1].xy,p[2].xy)\nfloat sdTriangle(mat3 p,vec2 u\n){float carthesianDet=c2bdet(p[0].xy,p[1].xy,p[2].xy) \n  //carthesianDet() has the only division within sdTriangle() \n  //,besides one division for each segment() line distance\n  //,which we need to do much less here.\n  //carthesianDet()is the same value any (u) (depends on triangle shape)\n ;vec3 k=c2b(u,p[0].xy,p[1].xy,p[2].xy,carthesianDet)//get carthesian of (u)\n ;float b=suv(sat(sign(k)))//sum up to distinguish 3 cases\n ;if(b==1.//if outside triangle border\n ){int g=getPos1(k);lazymods\n  ;return segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy);}//min of 2 line distances\n ;if(b==2.//else if outside triangle corner\n ){int g=getPos0(k);lazymods\n  ;return segmentB(u,p[i].xy,p[h].xy);}//only 1 line distance for the largest tiles\n ;//else (if) in triangle center (this case is rare)\n /*\n ;if(mod(iTime*.3,2.)<1.\n   //toggle center calculations over time (this division is just for show)\n ){\n //weirdBaricentricCenter version:\n ;int g=getPos2(1.-k);lazymods//took me a while to figure out (1.-k)\n ;//anyways, this has weird and wrong motorcycleGraphs to the barycenter.\n ;return -segmentB(u,p[g].xy,p[i].xy,p[g].xy,p[h].xy)//min of 2 line distances\n ;}else{/**/\n  ;//correct inside distance still needs 2 line_Dists, but sign() is simpler!\n  ;return -segmentB(u,p[0].xy,p[1].xy,p[0].xy,p[2].xy,p[1].xy,p[2].xy);}\n  //min of 3 line distances only inside the triangle\n//utility subroutine so the mat3() scope replaces the p1,p2,p3 scopes\n//without this, the parser may just duplicate too many floats for a pointable matrix\nfloat sdTriangle(vec2 p0,vec2 p1,vec2 p2,vec2 u\n){return sdTriangle(mat3(p0,0,p1,0,p2,0),u);}\n/**///--end__: barycentric\n/**///--\n/**///--start: memo\n                      \n             \n//solving with linear equations (and not with perlendicular doorproduct rhombus)\n\n/*getting the linear function of a line (o,t) //2 points on a line\ny=m*x+b\nm=(o.y-t.y)/(o.x-t.x) //slpe == rate of change over one domain (x)\nb=t.y-m*t.x           //f(0)\n\nm=(o.x-t.x)/(o.y-t.y)  //is constant\neither enter o.xy or t.xy\no.y      =m*o.x+b    \nt.y      =m*t.x+b\nt.y-m*t.x=     +b   //b is f(0)\n\nm=(o.x-t.x)/(o.y-t.y) //slope\nb=t.y-m*t.x           //f(0)  (this is a vec2 in 3d)\n\n//the above is odd for barycentric coordinates.\n//theres no y=m*x+b pointSlope form\n//sure, the slope is simple\n//oh wait, i just assert a skewed 2d coordinate system.\n\n//where ever 2 things intersect, they are the same, there they are equal.\n//this equation is a linear equation system, with as mnany lines as domains\n//substract factors to get all constants on one side\n                      \n/*  solving lonear equations with inverse matrix:\nhttps://courses.lumenlearning.com/ivytech-collegealgebra/chapter/solving-a-system-of-linear-equations-using-the-inverse-of-a-matrix/\n\n  a*x=b\n    x=b/a\n    x=b*inverse(a)\n\na is a matrix\nx are coefficients (one foreach domain)\nb may be zero vector, usually only contains constanty.\n                      \nexample (2d line intersection)\nA linear function is visible as a line where f(x)=y\ncos(x)  =y\ncos(x)-y=0\n\nany intersection of 2 things may have an intersection, where both functions are equal\n3*a+ 8*b=5\n4*a+11*by7\n\nA=mat2(vec2(3,8),vec2(4,11)\nX=vec2(a,b)\nB=vec2(5,7)\nA*X=B\ninverse(A)==mat2(11,-8,-4,3)\ninverse(A)*B==vec2(-1,1)  \nBEWARE that matrix multiplication is not commutative  inverse(A)*B != b*inverse(A)\n->\nvec2(x,y)==vec2(-1,1)\n/**/\n                      \n/*\nlazy animated checkerboard\n//inspired by https://www.shadertoy.com/view/4tG3Wh\n//i failed to extend this one to 3d.  \n#define hfrac v1 h){h=fract(h)\n#define gthv greaterThan(h,v1\n#define floatbool2);return v0(b.x==b.y);}\nv0 checkerBool(hfrac;return v0(h.x>.5==h.y>.5);}\n//checkerBool2()might be faster than checkerBool()//xy are independent\nv0 checkerBool2(hfrac;bvec2 b=gthv(.5   )floatbool2\n//checkerBoolT oscillates xy comparators over time.\nv0 checkerBoolT(hfrac;bvec2 b=gthv(cos(iTime)*.45+.5)floatbool2\n/**/\n\n/*\nfloat checkerBoolT(vec2 h){h=fract(h);bvec2 b=greaterThan(h,vec2(cos(iTime)*.45+.5));return float(b.x==b.y);}\nfloat checkerBoolT(vec3 h){h=fract(h);bvec3 b=greaterThan(h,vec3(cos(iTime)*.45+.5));return float(b.x==b.y&&b.y==b.z);}\n/**/\n                      \n/*\ntodo\nget RE included\n\nfix duplicates with the hg_sdf segment\n\nfix vNNN struct incompatibles (is simple)\n\nfix all that relies on high domain su() functions. (incompatibility\n- hash noise errors  , re-copy from   https://www.shadertoy.com/view/XlVyDK\n\ninclude debugHg2() marcher from       https://www.shadertoy.com/view/XlVyDK\n\na lot of hg sdf uses higher doimkensional mod mo(), which fails here an is from  /XlVyDK\n*/\n                      \n/*\nvec4 Phong(vec3 d,vec3 l,vec4 u){//direction,lightDirection,uvHit\n ;vec3 n=dNormal3X(u.xyz,df)\n ;float diffuse=max(0.,dot(n,l))\n ;float spec=max(0.,dot(reflect(l,n),norma(d)))\n ;spec=pow(spec,16.)*.5\n ;vec2 tid=vec2(0)//d(u.xyz).yz//surfaceID is distanceField specific\n ;//tid=fract(tid*phi)//golden ration hash is most uniform but not very \"blue\".\n ;//tid.y=u5(tid.y)//more saturation\n ;//vec3 surf=angleToColor(vec3(tid,1))//surfaceID to color\n ;//surf=mix(tex(u.xyz),surf),.5)//mix in a whatever 3d texture we have.\n ;vec3 surf=tex(u.xyz);\n    //;vec4 rainb=fract((vec4(0,1,2,3)+11.)*phi)\n    //;vec4 x=vec4(angleToColor(vec3(rainb.x,1,1)),c.x)//first derivative\n ;vec3 c=mix(vec3(.3,.6,1.),vec3(1,.9,.7),diffuse)*surf+spec*vec3(1,.9,.8)\n //not i got to make a difference between distance fog and distance fadeout\n ;float alp=pow(dd(u.xyz),1.)\n ;alp=sat(alp)\n ;return vec4(c,alp)//distance fadeout\n //;return vec4(c,eul-log(length(u.xyz)))//silly fog\n ;}\nvec4 shade(vec3 ray_start,vec3 ray_dir,vec3 lir,vec4 hit\n){float ray_len\n ;vec3 dir=hit.xyz-ray_start\n ;vec4 c=DebugPlanes(ray_start,ray_dir,length(dir))\n ;if(hit.w==0.)return c\n ;vec4 p=Phong(dir,lir,hit)\n ;return vec4(mix(p.xyz,c.xyz,.5),1.)\n ;}\n/**/\n                      \n/* //hg_sdf namespace legacy compatibility:\n#define fBoxCheap(p,b) boxf(p,b)\n#define fBox2Cheap(p,b) boxf(p,b)\n#define fBox(a,b) box(a,b)\n#define fBox2(a,b) box(a,b)\n#define fCorner(a) corner(a)\n#define fCylinder(a,r,h) cylinder(a,r,h)\n#define dls(a,b,c) ls(a,b,c)\nfloat fCapsule(vec3 p,vec1 r,vec3 b){return lsY(p,b)-r;}\n//float fCapsule(vec3 a,vec3 b,vec3 c,vec1 r){return ls(a,b,c)-r;}//parser error?\n#define fTorus(a,i,b) (torus(a,b)-(i))\n#define circle(a,b) torus(a,b)\n#define fDisc(a,b) disc(a,b)\n#define fHexagonCircumcircle(a,b) hexCircum(a,b)\n#define fHexagonIncircle(a,b) hexCircum(a,vec2(b.x*.866,b.y))\n#define fOpUnionChamfer(a,b,r)        miChamfer(a,b,r)\n#define fOpIntersectionChamfer(a,b,r) maChamfer(a,b,r)\n#define fOpDifferenceChamfer(a,b,r)   meChamfer(a,b,r)\n#define fOpUnionSoft(a,b,r) chamfer180(a,b,r)\n#define fOpUnionRound(a,r)        miRound(a,r)\n#define fOpIntersectionRound(a,r) maRound(a,b)\n#define fOpDifferenceRound(a,b)   meRound(a,b)\n#define fOpRoundE(a,b)            meRound(-a,b)\n#define fOpUnionStairs(a,r,n)        miStairs(a,r,n)\n#define fOpIntersectionStairs(a,r,n) maStairs(a,r,n)\n#define fOpDifferenceStairs(a,b,r,n) meStairs(a,r,n)\n#define fOpPipe(a,b,r) pipe(a,b,r)\n#define fOpEngrave(a,b,r) engrave(a,b,r)\n#define fOpGroove(a,b,r,h) groove(a,b,r,h)\npMOD(vec1,pMod1)pMOD(vec2,pMod2)pMOD(vec3,pMod3)pMOD(vec4,pMod4)/**/\n\n", "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2cRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3564, 3564, 3662, 3662, 3849], [3851, 3907, 3935, 3935, 4058], [4076, 4076, 4105, 4105, 4655], [5083, 5083, 5116, 5116, 5127], [5532, 5532, 5546, 5546, 5584], [5588, 5588, 5674, 5674, 12802], [12810, 12810, 12847, 12847, 13978], [13986, 14122, 14208, 14305, 14644], [14646, 14801, 14886, 14886, 15187], [15189, 15189, 15235, 15235, 16188], [16190, 16190, 16266, 16266, 17393], [17401, 17401, 17464, 17511, 18081], [18083, 18479, 18503, 18503, 18529], [18530, 18530, 18555, 18555, 18892], [20835, 24466, 24497, 24497, 24522], [24522, 25380, 25408, 25408, 25427], [25445, 25495, 25525, 25525, 25559], [25560, 25626, 25653, 25653, 25674], [25684, 25709, 25736, 25736, 25759], [29933, 29933, 29953, 29964, 30011], [32172, 32365, 32393, 32404, 32452], [32453, 32721, 32752, 32789, 32943], [32944, 32944, 32983, 32994, 33136], [33187, 33187, 33206, 33206, 33272], [33397, 33397, 33439, 33439, 33595], [33596, 33596, 33640, 33640, 33791], [33792, 33792, 33892, 33892, 34187], [34188, 34188, 34245, 34268, 36382], [39821, 42658, 42700, 42700, 43098], [43100, 43100, 43138, 43204, 44023], [45271, 45271, 45297, 45297, 46079]], "test": "untested"}
{"id": "tlKXDz", "name": "Foggy Flyover", "author": "ruojake", "description": "That's FBM terrain and volumetric fog checked off on the Shadertoy achievements!", "tags": ["3d", "raymarching", "terrain", "volume"], "likes": 12, "viewed": 754, "published": 3, "date": "1595189089", "time_retrieved": "2024-07-30T20:54:53.788428", "image_code": "// Foggy Flyover by Kristian Sivonen (ruojake)\n// CC BY-SA 4.0 (https://creativecommons.org/licenses/by-sa/4.0/)\n\n// Hash without sine by Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n// --\n\n\nconst vec2 o = vec2(1., 0.);\n\nfloat noise(vec3 p)\n{\n\tvec3 pi = floor(p);\n    vec3 pf = smoothstep(0., 1., p - pi);\n    return mix(\n        mix(\n        \tmix(hash13(pi), hash13(pi+o.xyy), pf.x),\n            mix(hash13(pi+o.yyx), hash13(pi+o.xyx), pf.x),\n            pf.z\n        ),\n        mix(\n        \tmix(hash13(pi+o.yxy), hash13(pi+o.xxy), pf.x),\n            mix(hash13(pi+o.yxx), hash13(pi+1.), pf.x),\n            pf.z\n        ),\n    pf.y);\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = smoothstep(0., 1., p - pi);\n    vec2 r = mix(vec2(hash12(pi), hash12(pi+o.yx)), vec2(hash12(pi+o), hash12(pi+1.)), pf.x);\n    return mix(r.x, r.y, pf.y);\n}\n\nconst mat2 ROT = mat2(.98, -.198, .198, .98);\n\n#define sat(v) clamp(v,0.,1.)\n\nfloat fbm(vec2 p, float o)\n{\n\tfloat res = 0.;\n   \tfor(float i = 1.; i < o; i += i)\n    {\n        res += noise(p*i) / i;\n    \tp = p * ROT;\n        o -= ROT[0][0] * .001 * sign(iTime);\n    }\n    return res;\n}\n\nfloat scene(vec3 p, float o)\n{\n\tfloat res = fbm(p.xz, o) * .5;\n    res *= 2.5 - res * res;\n    return .4 * (p.y + res - 1.5);\n}\n\nvec3 normal(vec3 p, float o)\n{\n\tfloat d = fbm(p.xz, o);\n    vec2 e = vec2(.001, .0);\n    return normalize(d - vec3(\n        fbm(p.xz - e, o),\n        d - 0.0011,\n        fbm(p.xz - e.yx, o)));\n}\n\nfloat shadow(vec3 ro, vec3 rd, float maxDist, float k)\n{\n    float res = 1.;\n    float d = 0.;\n    float t = .01;\n    for(int i = 0; i < 30; ++i)\n    {\n        d = scene(ro + rd * t, 16.);\n        res = min(res, k * d / t);\n        t += d;\n    \tif(abs(d) < .001 || t >= maxDist)\n            break;\n        if (res < .001)\n        {\n        \tres = 0.;\n            break;\n        }\n    }\n    return res;\n}\n\nvec3 ray(vec3 ro, vec3 lookAt, vec2 uv, float zoom)\n{\n\tvec3 f = normalize(lookAt - ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n\n    return normalize(uv.x * r + uv.y * u + f * zoom);\n}\n\nfloat clouds(vec3 p)\n{\n\tfloat res = noise(p * 4.) * 2.;\n    p.y -= iTime * .02;\n    res -= noise(p * 11.);\n\n    return sat(res * 4. * (1. - res));\n}\n\nvec3 material(vec3 p, vec3 n, float l, float t)\n{\n\tfloat noise0 = fbm(p.xz * 20., 32.);\n    float noise1 = fbm(p.xz * 310., 4.);\n    noise1 = 2. * noise1 - 1.;\n    float y = p.y;\n    t = sat(t * .03 - .1);\n    vec3 sunCol = vec3(1., .97, .85);\n    \n    vec3 forest = vec3(.03, .08, .01) + noise1 * .02;\n    forest += l * .1 * sunCol;\n    vec3 rock = vec3(.025) + noise1 * .01;\n    rock += l * sunCol * .3;\n    vec3 snow = vec3(.6, .6, .7);\n    snow += l * .4 * sunCol;\n    \n    vec3 res = mix(rock, forest, smoothstep(.8, .5, y + .2 * noise0) * n.y * (2. - n.y));\n    res = mix(res, snow, smoothstep(1.2 - t, 1.3 + t, y + .4 * noise0));\n    return mix(res, res * vec3(.5, .55, .9), smoothstep(.3, 0., l));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n\tvec2 m = clamp((iMouse.xy / iResolution.xy) * 2. - 1., vec2(-1.), vec2(1.));\n    if (m == vec2(-1.,-1.)) m = vec2(0.);\n    \n    vec3 tgt = vec3(m.x * 2. + 10., m.y + 1.4, 2. + iTime * .3 - max(abs(m.x), abs(m.y) * .5) * 2.);\n    vec3 ro = vec3(10.,1.5, iTime * .3);\n    \n    vec3 rd = ray(ro, tgt, uv, .8);\n    float t = 0.;\n    vec3 p;\n    \n    if (rd.y < 0.)\n    {\n        for(int i = 0; i < 90; i++)\n        {\n            p = ro + rd * t;\n            float d = scene(p, 16.);\n            t += d * (1.25 - pow(abs(rd.y), 4.) + sat(t * .1 - 1.));\n            if (abs(d) < .001 * (1.+t) || t > 30.) break;\n        }\n        t = t >= 30. ? 1000. : t;\n    }\n    else\n    {\n    \tt = 1000.;\n        p = ro + rd * t;\n    }\n    \n    float theta = .5 * 3.1415;\n    vec3 lDir = normalize(vec3(-sin(theta), .25, cos(theta)));\n    float dither = fract(13.013 * dot(fragCoord + float((iFrame & 7) * 17), vec2(.104212, .672709)));\n    \n    float maxl = .8;\n    vec3 cFog = vec3(.1,.15,.2);\n    vec4 fog = vec4(0.);\n    float ft = max(ro.y - maxl, 0.) / (-rd.y + .0001);\n    ft += dither * (.025 * ft + .1) * (1. - sat(-rd.y));\n    vec3 v = vec3(0.,iTime * -.02,0.);\n\tfloat h = 1. - abs(rd.y);\n    vec3 shadowCol = cFog * vec3(.4, .5, .7);\n    float l = 0.;\n    vec3 skyCol = mix(vec3(.7, .8, 1.), vec3(.1, .1, .4), sat(rd.y));\n    \n    vec3 col = vec3(0.);\n\tif (t < 500.)\n    {\n    \n        if(p.y <= maxl)\n            for(int i = 0; i < 35; i++)\n            {\n                float dt = .01 + h * .1;\n                ft += dt;\n\n                if (ft >= t) break;\n\n                vec3 fp = (ro + rd * ft);\n\n                if (rd.y >= 0. && fp.y > maxl) break;\n\n                float d = clouds(fp + v) * (maxl + h) * dt * 10.;\n                float fade = min(sat(maxl - fp.y), min(ft * .5, maxl - ft * .05));\n                fade *= fade;\n                d *= fade;\n                ft += min(sat(h - fade) * .03, t - ft);\n                if (d > .01)\n                {\n                    l = 0.;\n                    float s = shadow(fp, lDir, 15. - fp.y, 20.);\n                    if (s > .001)\n                    {\n                        s *= 2. - s;\n                        l = sat(s * (1. - clouds(fp + lDir * .1 + v) * 3. * fade));\n                    }\n                    float w = sat((.1 * l + .91) - fog.a);\n                    fog.rgb += mix(shadowCol, cFog + l, l) * d * w;\n                    fog.a += d * w;\n\n                    if (fog.a > .95) \n                    {\n                        fog.a = 1.;\n                        break;\n                    }\n                }\n            }\n\n        fog.rgb = mix(fog.rgb, skyCol, sat(t * .05 - .15));\n        fog.a = min(fog.a, 1.);\n\n\n        vec3 n = t < 10. ? t < 6. ? normal(p, 256.) : normal(p, 64.) : normal(p, 8.);\n        l = sat(dot(n, lDir) * .8 + .2);\n        float s = shadow(p + n * .1 + vec3(0.,.03,0.), lDir, 15., 14.);\n        float sun = smoothstep(.9995, 1., dot(rd,lDir));\t\n\n        col = rd.y <= 0. ? mix(\n            vec3(material(p, n, l * s, t)), \n            skyCol, \n            sat(t * .05 - .15)) : skyCol;\n        col += sun * 2. * smoothstep(1.,.9999, 30. - t);\n\n        col = mix(col, fog.rgb, fog.a * fog.a);\n    }\n    else col = skyCol;\n    \n    col *= 1. - smoothstep(.45, .7, length((uv * iResolution.y / iResolution.xy))) * .5;\n    col += (dither * .03 - .015) * col;\n    fragColor = vec4(pow(col,vec3(1./2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlKXDz.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[114, 192, 214, 214, 331], [333, 333, 356, 356, 459], [498, 498, 519, 519, 914], [916, 916, 937, 937, 1128], [1208, 1208, 1236, 1236, 1414], [1416, 1416, 1446, 1446, 1543], [1545, 1545, 1575, 1575, 1739], [1741, 1741, 1797, 1797, 2144], [2146, 2146, 2199, 2199, 2357], [2359, 2359, 2381, 2381, 2507], [2509, 2509, 2558, 2558, 3216], [3218, 3218, 3274, 3274, 6749]], "test": "untested"}
{"id": "3tBcWG", "name": "Cave map (dancing worms)", "author": "jarble", "description": "This is an \"inside-out\" map of a cave system, based on a modification of my [url=https://www.shadertoy.com/view/tlBcDh]\"alien megacity\"[/url] fractal. With some added distortion, they also look like dancing worms.\nUse the mouse to look around.", "tags": ["3d", "fractal", "tunnel", "cave"], "likes": 2, "viewed": 369, "published": 3, "date": "1595184689", "time_retrieved": "2024-07-30T20:54:54.950321", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*3000.0;\n\n    float\n        size1 = 1100.0,\n    \ti = 1.0;\n    for(int j = 0; j < iterations; j++){\n        i *= multiplier;\n        p += sin(p.yzx*i)/i/(1.0+length(sin(p*i+iTime)));\n\n    }\n    return vines(p,size1)/(i)/10.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n\n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n#define image_scale 8.0\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 100.0,\nEPSILON = 0.001,\nsize = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat vines(vec3 p,float size1){\n    return size-length((sin(p/vec3(length((p/20.0)))))*size1)/1.8;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*3000.0;\n\n    float\n        size1 = 1100.0,\n    \ti = 1.0;\n    for(int j = 0; j < iterations; j++){\n        i *= multiplier;\n        p += sin(p.yzx*i)/i/(1.0+length(sin(p*i+iTime)));\n\n    }\n    return vines(p,size1)/(i)/10.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcWG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 82, 82, 323], [325, 325, 353, 353, 430], [432, 853, 944, 944, 1317], [1332, 1586, 1651, 1651, 1783], [1785, 1874, 1903, 1903, 2213], [2215, 2707, 2847, 2847, 3442], [3444, 3814, 3899, 3899, 4246], [4248, 4575, 4624, 4659, 4790], [4792, 4792, 4819, 4819, 4968], [4970, 4970, 5027, 5027, 5658]], "test": "untested"}
{"id": "wl2yzt", "name": "Flying through psychedelic mist", "author": "mrange", "description": "License CC0: Flying through psychedelic mist\nMessing around with colors and FBM. \nSet BPM to some value that match your music.", "tags": ["2d", "fbm", "colorful"], "likes": 38, "viewed": 1391, "published": 3, "date": "1595152447", "time_retrieved": "2024-07-30T20:54:55.787084", "image_code": "// License CC0: Flying through psychedelic mist\n// Messing around with colors and FBM. \n\n// Set BPM to some value that match your music.\n#define BPM             30.0\n\n#define GAMMAWEIRDNESS\n#define QUINTIC\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rotSome          = MROT(1.0);\nconst vec3 std_gamma        = vec3(2.2, 2.2, 2.2);\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co, vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#ifdef QUINTIC\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nvec3 alphaBlendGamma(vec3 back, vec4 front, vec3 gamma) {\n  vec3 colb = max(back.xyz, 0.0);\n  vec3 colf = max(front.xyz, 0.0);;\n  \n  colb = pow(colb, gamma);\n  colf = pow(colf, gamma);\n  vec3 xyz = mix(colb, colf.xyz, front.w);\n  return pow(xyz, 1.0/gamma);\n}\n\nvec3 offset_0(float z) {\n  float a = z;\n  vec2 p = vec2(0.0);\n  return vec3(p, z);\n}\n\nvec3 offset_1(float z) {\n  float a = z/3.0;\n  vec2 p = -2.0*0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 offset(float z) {\n  return offset_1(z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.1;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.1;\n  return 0.125*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec3 skyColor(vec3 ro, vec3 rd) {\n  return mix(1.5*vec3(0.75, 0.75, 1.0), vec3(0.0), length(2.0*rd.xy));\n}\n\nfloat height(vec2 p, float n, out vec2 diff) {\n  const float aan = 0.45;\n  const float ppn = 2.0+0.2;\n  \n  float s = 0.0;\n  float d = 0.0;\n  float an = 1.0;\n  vec2 pn = 4.0*p+n*10.0;\n  vec2 opn = pn;\n\n  const int md = 1;\n  const int mx = 4;\n  \n  for (int i = 0; i < md; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n  }\n\n  for (int i = md; i < mx; ++i) {\n    s += an*(vnoise(pn)); \n    d += abs(an);\n    pn *= ppn*rotSome;\n    an *= aan; \n    pn += (3.0*float(i+1))*s-TIME*5.5;     // Fake warp FBM\n  }\n\n  s /= d;\n\n  diff = (pn - opn);\n\n  return s;\n}\n\nvec4 plane(vec3 ro, vec3 rd, vec3 pp, float aa, float n) {\n  vec2 p = pp.xy;\n  float z = pp.z;\n  float nz = pp.z-ro.z;\n  \n  vec2 diff;\n  vec2 hp = p;\n  hp -= nz*0.125*0.5*vec2(1.0, -0.5);\n  hp -= n;\n  float h = height(hp, n, diff);\n  float gh = (vnoise(0.25*(p+vec2(n))));\n  h *= mix(0.75, 1.0, gh);\n  h = abs(h);\n  \n  vec3 col = vec3(0.0);\n  col = vec3(h);\n  float huen = (length(diff)/200.0);\n  float satn = 1.0;\n  float brin = h;\n  col = hsv2rgb(vec3(huen, satn, brin));\n  \n  float t = sqrt(h)*(smoothstep(0.0, 0.5, length(pp - ro)))*smoothstep(0.0, mix(0.4, 0.75, pow(psin(TIME*TAU*BPM/60.0), 4.0)), length(p));\n  return vec4(col, t);\n}\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  float lp = length(p);\n//  vec3 rd = normalize(p.x*uu + p.y*vv + (3.00-1.0*tanh(lp))*ww);\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.00+tanh(lp))*ww);\n\n  float planeDist = 1.0-0.25;\n  const int furthest = 6;\n  const int fadeFrom = furthest-4;\n\n  float nz = floor(ro.z / planeDist);\n\n  vec3 skyCol = skyColor(ro, rd);  \n  \n  vec3 col = skyCol;\n\n  for (int i = furthest; i >= 1 ; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n   \n      float aa = length(dFdy(pp));\n\n      vec4 pcol = plane(ro, rd, pp, aa, nz+float(i));\n      float nz = pp.z-ro.z;\n      float fadeIn = (1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), nz));\n      float fadeOut = smoothstep(0.0, planeDist*0.1, nz);\n      pcol.xyz = mix(skyCol, pcol.xyz, (fadeIn));\n      pcol.w *= fadeOut;\n\n      vec3 gamma = std_gamma;\n#ifdef GAMMAWEIRDNESS\n      float ga = pp.z;\n      vec3 gg = vec3(psin(ga), psin(ga*sqrt(0.5)), psin(ga*2.0));\n      gamma *= mix(vec3(0.1), vec3(10.0), gg);\n#endif\n      col = alphaBlendGamma(col, pcol, gamma);\n    } else {\n      break;\n    }\n    \n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME;\n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(normalize(vec3(0.0,1.0,0.0)+ddro), ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yzt.jpg", "access": "api", "license": "cc0-1.0", "functions": [[490, 490, 512, 512, 681], [683, 683, 707, 707, 774], [776, 776, 797, 797, 826], [828, 828, 850, 850, 1426], [1428, 1428, 1485, 1485, 1687], [1689, 1689, 1713, 1713, 1773], [1775, 1775, 1799, 1799, 1941], [1943, 1943, 1965, 1965, 1989], [1991, 1991, 2014, 2014, 2089], [2091, 2091, 2115, 2115, 2194], [2196, 2196, 2229, 2229, 2302], [2304, 2304, 2350, 2350, 2899], [2901, 2901, 2959, 2959, 3541], [3542, 3542, 3598, 3598, 4780], [4782, 4782, 4819, 4819, 5027], [5029, 5029, 5058, 5058, 5381], [5383, 5383, 5435, 5435, 5597]], "test": "untested"}
{"id": "Wl2cRt", "name": "fluidity", "author": "DaMastaCoda", "description": "A dumb fluid sim WIP\n\ndon't run:\ngShaderToy.SetTexture(2, {mSrc:'https://i.ibb.co/pRvFNJf/circles1.png', mType:'texture', mID:1, mSampler:{ filter: 'nearest', wrap: 'clamp', vflip:'true', srgb:'false', internal:'byte' }});\nwith Buffer B selected", "tags": ["fluid"], "likes": 0, "viewed": 325, "published": 3, "date": "1595101811", "time_retrieved": "2024-07-30T20:54:56.547052", "image_code": "//display\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    // fragColor = vec4(col,1.0);\n    //fragColor = vec4(texture(iChannel1, uv).bbb,0.0);\n    fragColor = vec4(texture(iChannel0, uv).rgb,0.0);\n    vec3 samp = texture(iChannel0, uv).rgb;\n    \n    //fragColor = vec4(hsv2rgb(vec3(samp.rg,1.0)),1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "struct fluid {\n\tpolar coord;\n    float amount;\n};\n\nvec4 tex(sampler2D te, vec2 coord, vec2 offset) {\n \treturn texture(te, (coord+offset)/iResolution.xy);   \n}\n\nvec4 tex(sampler2D te, vec2 coord) {\n    return tex(te, coord, vec2(0,0));\n}\n\nfluid toFluid(vec4 inp) {\n\treturn fluid(polar(inp.r,decompressS(inp.g)),decompressS(inp.b));    \n}\n\nvec4 fromFluid(fluid inp) {\n    return vec4(inp.coord.angle,compressS(inp.coord.radius),compressS(inp.amount),1.0);\n}\n\n//sim\n\nvoid applyStuff(inout fluid me, vec2 coord, vec2 offset) {\n    \n    \n}\n\nvoid applyStuffb(inout fluid me, vec2 coord, vec2 offset) {\n    \n    fluid side01 = toFluid(tex(iChannel0, coord, offset));\n    \n        float transferRate = dot(toCart(side01.coord)/side01.coord.radius, -offset);\n        if(transferRate > 0.0) {\n            me.amount += transferRate * side01.coord.radius;\n            me.coord = toPolar(toCart(me.coord)+toCart(side01.coord)*transferRate);\n        }\n        if(transferRate < 0.0) {\n            \n            me.amount += transferRate * me.coord.radius;\n            me.coord = toPolar(toCart(me.coord)+toCart(me.coord)*transferRate);\n            \n        }\n\n}\n\nfloat rand(vec4 seed) {\n    return sin(seed.x*5443435345.34235+seed.y*45435343452.435345)/2.0+0.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //each px holds dir 0..1, radius 0..*, value: 0..*\n    vec2 uv = fragCoord/iResolution.xy;\n\n    fluid oldMe = toFluid(tex(iChannel0, fragCoord));\n    \n    if(iFrame == 0) {\n     \t//oldMe.amount = rand(vec4(fragCoord.x, fragCoord.y,0.0,0.0));\n     \toldMe.coord.radius = 0.0;\n     \toldMe.coord.angle = 0.0;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(1.0,0.0,0.0,1.0);\n        return;\n    }\n    \n    if(texture(iChannel1, fragCoord/iResolution.xy).r==1.0){\n        oldMe.amount = 0.0;\n     \toldMe.coord.radius = 0.0;\n     \toldMe.coord.angle = 0.0;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(0.0,1.0,0.0,1.0);\n        return;\n        \n    }\n    \n   \t\n    vec4 src =texture(iChannel1, fragCoord/iResolution.xy);\n    src.g;\n    if(src.y>0.5){\n        oldMe.amount = 1.0;\n     \toldMe.coord.radius = 1.0;\n     \toldMe.coord.angle = texture(iChannel1, fragCoord/iResolution.xy).b;\n    fragColor = fromFluid(oldMe);\n        fragColor = vec4(0.0,src.y>0.5,src.y,1.0);\n        return;\n        \n    }\n    \n    // Output to screen\n    //move\n    \n    //vel.angle = mod(vel.angle+0.01,1.0);\n    //vel.radius = mod(vel.radius+0.1,2.0);\n    //applyStuff(oldMe,fragCoord,vec2(0,-1));\n    //applyStuff(oldMe,fragCoord,vec2(-1,-1));\n    //applyStuff(oldMe,fragCoord,vec2(-1,0));\n    //applyStuff(oldMe,fragCoord,vec2(-1,-1));\n    //applyStuff(oldMe,fragCoord,vec2(0,1));\n    //applyStuff(oldMe,fragCoord,vec2(1,1));\n    //applyStuff(oldMe,fragCoord,vec2(1,0));\n    //applyStuff(oldMe,fragCoord,vec2(1,-1));\n    \n    \n\tvec2 around = vec2(0, 0);\n    \n/*\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+0,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,+0))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(-1,-1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+0,+1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,+1))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,+0))).coord);\naround += toCart(toFluid(tex(iChannel0, fragCoord, vec2(+1,-1))).coord);\n*/\n    float times = 0.0;\n    #define Blur 1.0\n    for(float xoff = -1.0 * Blur; xoff <= Blur; ++xoff) {\n        for(float yoff = -1.0 * Blur; yoff <= Blur; ++yoff) {\n            vec2 match = toCart(toFluid(tex(iChannel0, fragCoord, vec2(xoff,yoff))).coord);\n\t\t\taround += match;\n                       \n        }\n    }\n    around *= 1.0 / length(around);\n    \n\n\toldMe.coord = toPolar(around);\n    \n    \n    \n    // update vel\n    \n    //vel = toPolar(uv-vec2(0.5,0.5));\n    \n    \n    //fragColor = vec4(0, pol.radius/3.0,0,1);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Stores image for sim\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texture(iChannel2, fragCoord/iResolution.xy);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "precision highp float;\n#define M_PI 3.1415926535897932384626433832795\n\nstruct compressed {\n    float compressedValue;\n};\n\nstruct polar {\n    float angle;\n    float radius;\n};\n    \nvec2 toCart(polar pol) {\n    return vec2(cos((pol.angle-0.5)*2.0*M_PI), sin(pol.angle)) * pol.radius;\n}\n\npolar toPolar(vec2 xy) {\n    if(xy.x == 0.0 && xy.y == 0.0) {\n        return polar(0.0,0.0);\n    }\n    \n    return polar(atan(xy.y, xy.x)/(M_PI*2.0)+0.5, sqrt(xy.x * xy.x + xy.y * xy.y));\n}\n\nfloat compressS(float inp) {\n    return 1.0-(1.0/(inp+1.0));\n}\n\ncompressed compress(float inp) {\n    return compressed(compressS(inp));\n}\n\nfloat decompressS(float inp) {\n    return -1.0-(1.0/(inp-1.0));\n}\n\nfloat decompress(compressed inp) {\n    return decompressS(inp.compressedValue);\n}\n\n\n// credit to http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 67, 117, 522]], "test": "untested"}
{"id": "wlSyzd", "name": "quadratic bezier triangle 2 AABV", "author": "ollj", "description": "drag mouse for quaternion rotation\narrow keys to accellerate and roll\nsee image tab\n\ni tried rotations and AABVs, and rotations failed.\n", "tags": ["bezier", "camera", "bspline", "fly", "aabv", "bpatch"], "likes": 8, "viewed": 428, "published": 3, "date": "1595097955", "time_retrieved": "2024-07-30T20:54:57.489533", "image_code": "//drag mouse for quaternion rotation\n//arrow keys to accellerate and roll\n\n//grandparent bezierPatch  : https://www.shadertoy.com/view/XsjSDt\n//grandparent flyQuaternion: https://www.shadertoy.com/view/MldczM\n//parent                   : https://www.shadertoy.com/view/ttjSzw\n//self                     : https://www.shadertoy.com/view/wlSyzd\n\n//A triangular cubic bezier patch, bound by 6 CV-heights, \n//is tranceable analytically with good performance and precision\n//for no good reason i never bothered to fix the camera of /XsjSDt, till now\n//and i notice that this shader sucks if the camera is inside the bezier-triangle-prism.\n\n//it works fine, as long as the patch is not too planar\n//any near-planar bezierPatch has a too small determinant which diminishes precision too much.\n//the first few milliseconds of this demo are near-planar\n\n//it works fine as long as the camera is not inside the bounding-prism (incl min&&max height) \n//of the bezier patch\n\n//But if the camera is inside the bezierPrism, the roots are in the wrong order. \n//and it seems to treat roots behind the camera as if they are infront of the camera??\n\n//BUT it always renders 2 patches, and their distance to each other is the distance of the camera to vec3(0)\n//, as if they are mirror images.\n//and they intersect when the camera is close to it.\n//, and they appear to swap places when you move over one of them.\n//and then you may confuse it for its mirror image.\n//unless you have the original inside its AABV\n\n//the open question here is, how to remove the mirror image solution?\n\nvoid mainImage(out vec4 o, in vec2 u){\n o=texture(iChannel0,u/iResolution.xy, -100.0 );\n  //o+=mainImage2(o,u);\n}\n\n//everything is in BuffA and common", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 iMouseZwFix(vec4 m,bool NewCoke\n ){if(m.z>0.){ //while mouse down\n    if(m.w>0.)return m;//mouse was clicked in THIS     iFrame \n    else m.w=-m.w      //mosue was clicked in previous iFrame\n    //remember, MouseDrag advances the iFrame Count, even while paused !!\n ;}else{if(!NewCoke||m.w>0.)return m.xyxy; //OPTIONAL onMouseUp (fold or whatever)\n    m.zw=-m.zw;}\n  return m;}\n\n#define v0 float\n#define v1 vec2\n#define v2 vec3\n#define v3 vec4\n#define u2(a)(a*2.-1.)\n#define u5(a)(a*.5+.5)\n#define dd(a)dot(a,a)\n//perpendicular dot()used for line intersections.\n#define dotp(a,b)dot(v1(-a.y,a.x),b)\nv0 suv(v1 a){return a.x+a.y;}\nv0 miv(v1 a){return min(a.y,a.x);}\nv0 miv(v2 a){return min(a.z,miv(a.xy));}\nv0 miv(v3 a){return min(miv(a.zw),miv(a.xy));}//return min domain of vector.\n#define mav(a)-miv(-a)\n#define sat(a)clamp(a,0.,1.)\nv3 minx(v3 a,v3 b){return mix(b,a,step(a.x,b.x));}//return the v3 with the smaller .x\n\nv0 suv(v2 a){return a.x+a.y+a.z;}\nv0 ad(v1 a){return a.x+a.y;}\nv0 mu(v1 a){return a.x*a.y;} \n\n#define rs3 sqrt(3.)\n#define rs5 sqrt(5.)\n#define phi u4(rs5)\n#define Phi u5(rs5)\n//(reciprocal) [skewConstant] arithmetic:   [rs*]==[reciprocal square of *]\n// ske==.36602540378;//==sqrt(3.)*.5-.5\n//#define   ske u4(rs3)\n//reSke=.21132486540;//==(sqrt(3.)*.5-.5)/sqrt(3.)==.5-.5/sqrt(3.)\n//#define reSke u4(rs3)/rs3\n//enter [0.366025] or [.2113248654] in search engines and be amazed by peoplewho use values without knowing them\n//v1   skew(v1 u){return u+ad(u)*ske;}\n//v1 unskew(v1 u){return u-ad(u)*reSke;}\nv0 det2d(v1 a,v1 b){return a.x*b.y-a.y*b.x;}//2d determinant(mat2(a,b))-=perpendicular dotproduct\n\n//Cartesian to barycentric(relative to spline verts)\nv2 CartToBary(v1 c,v1 p1,v1 p2,v1 p3\n){c-=p1;v1 a=p2-p1,b=p3-p1,d=v1(dot(c,b),dot(c,a))\n ;v2 r=v2(dd(a),dd(b),dot(a,b))\n ;r=v2(0.,det2d(r.yz,d),det2d(r.xz,d.yx))/det2d(r.yz,r.zx)\n ;return v2(1.-r.y-r.z,r.yz);}\n\nv0 board(v2 p){p=floor(p*2.);return mod(p.x+p.y+p.z,2.);}\nv0 board(v1 p){p=floor(p*2.);return mod(p.x+p.y,2.);}\n//https://www.shadertoy.com/view/4lySzc\n\nmat3 opop(v2 a,v2 b){return outerProduct(a,v2(1))\n                           +outerProduct(  v2(1),b);}\nmat3 pqfmA(){return opop((v2(2,7,5)),sqrt(v2(13,21,17)));}\n//matrix of quadratic fields with unique prime factors to maximize period length\n//also has the neat effect of all starting at null, which tends to be (near) a special (coplanar) case\n// that we can then skip over and safely assert to not reorrur anytime soon.\n\n//quaternions q()<->creation r()<->rotaition\n//use like matrix multiplication, see https://www.shadertoy.com/view/lstSRM\n//normalize quaternion: true for quaternions <-> nornamoze(q)=q/length(q)==q/length(q*q)=q/dot(q,q)\nv3 qid(){return v3(0,0,0,1);}//NULL_ROTATION\nv3 qinv(v3 q){return v3(-q.xyz,q.w)/dd(q);}//inverse quaternion\nv3 q(v2 o){o*=0.5;v2 s=sin(o),c=cos(o) //quaternion from pitch,yaw,roll (in that order):\n          ;return v3(s.x*c.y*c.z+s.y*c.x*s.z,s.y*c.x*c.z-s.x*c.y*s.z\n,s.x*s.y*c.z+s.z*c.x*c.y, c.x*c.y*c.z-s.x*s.y*s.z);}\nv3 q(v3 q){return q/dd(q);} //normalize quaternion (may be needed after every 5th rotation)\n//return quaternin of [axis]&{angle] rotation\nv3 q(v2 axis, v0 angle){angle*=.5;return v3(axis*sin(angle),cos(angle));}\n//return [r]rotation, rotated by [b]\nv3 r(v3 b,v3 r){return v3(b.w*r.xyz+r.w*b.xyz+cross(b.xyz,r.xyz),b.w*r.w-dot(b.xyz,r.xyz));}\n//return [v]vector, rotated by [b] around v2(0)\nv2 r(v3 b,v2 v){v2 t=2.*cross(b.xyz, v);return v+b.w*t+cross(b.xyz,t);}//return r(q,r(v3(v,.0),qinv(q))).xyz\n//return p, rotated by b, AROUND c (center) instead of around v2(0) (offset rotation)\nv2 r(v3 b,v2 p,v2 c){return r(b,p+c)-c;}\n//return shortest rotation fro+\n//get rotation from a to b (around v2(0), has higher precision for small angles: Written by Moon Metty, optimized by Strife Onizuka\nv3 RotBetween(v2 a,v2 b\n){v0 aabb=sqrt(dd(a)*dd(b))//product of the lengths of the arguments\n ;if(aabb!=0.\n ){v0 ab=dot(a,b)/aabb// normalized dotproduct of the arguments (cosine)\n  ;v2 c=v2((a.y*b.z-a.z*b.y),(a.z*b.x-a.x*b.z),(a.x*b.y-a.y*b.x))/aabb//normalized crossproduct of the arguments\n  ;v0 cc=dd(c)//squared length of normalized crossproduct (sine)\n  ;if (cc!=0.//test if arguments are not (anti)parallel\n  ){v0 s\n   ;if(ab>-.707107)s=1.+ab   //use the cosine, or...\n   ;else s=cc/(1.+sqrt(1.-cc))//use the sine   to adjust the s-element\n   ;v0 m=sqrt(cc+s*s)//magnitude of the quaternion\n   ;return v3(c,s)/m  //return normalized quaternion\n  ;}if(ab>0.)return v3(0,0,0,1);//arguments are parallel, or anti-parallel if not true: ZERO_ROTATION\n  ;v0 m=length(a.xy)//sqrt(a.x*a.x+a.y*a.y)//length of one argument projected on the XY-plane\n  ;if(m!=0.)return v3(a.y,-a.x,0,0)/m //return rotation with axis in the XY-plane\n  ;return v3(1,0,0,0);// arguments are parallel to Z-axis,rotate around the X-axis\n ;}return v3(0,0,0,1);}//arguments too small,ZERO_ROTATIO\n/*\nv3 q2aa(v3 q){return v3(q.xyz/sqrt(1.0-q.w*q.w),acos(q.w)*2.0);}//assumed q is normalized coverts to axis&angle\nv3 qlookat(v2 v){return aa2q(v2(-v.y,v.x,0.0),acos(v.z/length(v)));}//point in direction v\nv2 vmulq(v2 p, v3 q){return qmulq(qinv(q),qmulq(v3(p,0.0),q)).xyz;}//inverse rotation\nv3 qslerp(v3 q1, v3 q2, v0 f){\n\tv0 d=dot(q1,q2),theta=acos(abs(d)),ost=(1.0/sin(theta)); \n\treturn normalize(q1*sin(theta*(1.0-f))*ost*sign(d)+q2*sin(theta*f)*ost);}/**/\n\n//trace AABV-box 3d,2d,1d, all worksave, reciprocal direction replaces a lot of branching and epsilon nonsense\n//is more precise the closer length(direction) is to 1\n//returns: .x if box is hit, .y=far root, .y=near root.\n//rayorigin,raydirection,lowcorner,highcorner\n//worksaving, if(one domain of raiDir ==0) this is a simpler special case with one less domain.\n#define TABV(a,b) if(d.a==0.)return abv(d.b,l.b,h.b)\nv2 abv(v0 d,v0 l,v0 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){if(d==0.)return v2(0)//directionless ray is not a ray\n ;d=1./d;l=l*d;h=h*d\n ;d=min(h,l);h=max(h,l);return v2(v0(h>max(d,0.)),h,d);}\nv2 abv(v1 d,v1 l,v1 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,y);TABV(y,x);d=1./d;l=l*d;h=h*d\n ;v0 o=mav(min(h,l))\n ;h.x=miv(max(h,l))\n ;return v2(v0(h.x>max(o,0.)),h.x,o);}\nv2 abv(v2 d,v2 l,v2 h//rayDirection,lowCornerMinusRayorigin,highcornerMinusRayorigin\n){TABV(x,yz);TABV(y,xz);TABV(z,xy);d=1./d;l=l*d;h=h*d\n ;v2 o=min(h,l)\n ;h=max(h,l)\n ;o.xy=max(o.xx,o.yz);o.z=mav(o.xy)\n ;o.xy=min(h.xx,h.yz);o.x=miv(o.xy)\n ;return v2(v0(o.x>max(o.z,0.)),o.x,o.z);}\n#define aabv(o,d,l,h) abv(d,l-o,h-o)\n\nv2 triangleNornal(v2 a,v2 b,v2 c){return cross(a-b,a-c);}//normal of triangle of 3 pointsi is cross() of any 2 sides.\n\n//LineSegmentAB+RayUD intersection\nv1 LineISect(v1 a,v1 b,v1 u,v1 d\n){vec4 c=vec4(b.y-a.y,a.x-b.x,d.y-u.y,u.x-d.x)\n ;u=v1(dot(c.zw,u),det2d(c.xy,c.zw))\n ;if(u.y==0.)return v1(0)//parralel lines do not intersect.\n ;c*=v3(u.xx,vec2(dot(c.xy,a)))\n ;return (c.wx-c.yz)/u.y;}\n\n/* //explicit version for compatibility where bvec4 is not a defined type.\nbool altm(v1 a,v3 b){\n ;v3 c=v3(a,b.zw)\n ;b=v3(b.xy,a)\n ;if(c.x<b.x)return true;\n ;if(c.y<b.y)return true;\n ;if(c.z<b.z)return true;\n ;if(c.w<b.w)return true;\n ;return false\n ;//return any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;}*/\n\n\n/*\n//grandparent backup version to check errors\nv1 v2VertA = v1( 0.0, 4.0 ); \nv1 v2VertB = v1(-4.0,-4.0 );\nv1 v2VertC = v1( 4.0,-4.0 );\n#define D_BIAS 0.0001\nv2 CartToBary( v1 v2Cart ){\n    v1 w0 = v2VertB - v2VertA;\n    v1 w1 = v2VertC - v2VertA;\n    v1 w2 = v2Cart - v2VertA;\n    v0 d00 = dot(w0, w0);\n    v0 d01 = dot(w0, w1);\n    v0 d11 = dot(w1, w1);\n    v0 d20 = dot(w2, w0);\n    v0 d21 = dot(w2, w1);\n    v0 denom = d00 * d11 - d01 * d01;\n    v2 v3Bary;\n    v3Bary.y = (d11 * d20 - d01 * d21) / denom;\n    v3Bary.z = (d00 * d21 - d01 * d20) / denom;\n    v3Bary.x = 1.0 - v3Bary.y - v3Bary.z;\n    return v3Bary;}\nv3 BezierTriISect( const v2 v3CameraPos, const v2 v3LookDir, v2 CP_2, v2 CP_0 ){\n    v1 v2LookPt = v3CameraPos.xy + v3LookDir.xy;\n    //This is a hacky brute-force way of finding limits of triangle bounding retion.  \n    // I will probably re-write this with a better approach.\n    v1 v2PosA = LineISect( v2VertA, v2VertB, v3CameraPos.xy, v2LookPt );\n    v1 v2PosB = LineISect( v2VertB, v2VertC, v3CameraPos.xy, v2LookPt );\n    v1 v2PosC = LineISect( v2VertC, v2VertA, v3CameraPos.xy, v2LookPt );\n    v1 v2MinA = v1( min( v2VertA.x, v2VertB.x ), min( v2VertA.y, v2VertB.y ) ) - D_BIAS;\n    v1 v2MinB = v1( min( v2VertB.x, v2VertC.x ), min( v2VertB.y, v2VertC.y ) ) - D_BIAS;\n    v1 v2MinC = v1( min( v2VertC.x, v2VertA.x ), min( v2VertC.y, v2VertA.y ) ) - D_BIAS;\n    v1 v2MaxA = v1( max( v2VertA.x, v2VertB.x ), max( v2VertA.y, v2VertB.y ) ) + D_BIAS;\n    v1 v2MaxB = v1( max( v2VertB.x, v2VertC.x ), max( v2VertB.y, v2VertC.y ) ) + D_BIAS;\n    v1 v2MaxC = v1( max( v2VertC.x, v2VertA.x ), max( v2VertC.y, v2VertA.y ) ) + D_BIAS;\n    bool bAValid = \n        v2PosA.x >= v2MinA.x && v2PosA.x <= v2MaxA.x && \n        v2PosA.y >= v2MinA.y && v2PosA.y <= v2MaxA.y;\n    bool bBValid =\n        v2PosB.x >= v2MinB.x && v2PosB.x <= v2MaxB.x &&\n        v2PosB.y >= v2MinB.y && v2PosB.y <= v2MaxB.y;    \n    bool bCValid =\n        v2PosC.x >= v2MinC.x && v2PosC.x <= v2MaxC.x && \n        v2PosC.y >= v2MinC.y && v2PosC.y <= v2MaxC.y;\n    v0 fCamDistA = (v2PosA.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistB = (v2PosB.x - v3CameraPos.x) / v3LookDir.x;\n    v0 fCamDistC = (v2PosC.x - v3CameraPos.x) / v3LookDir.x;\n    \n    v2 v3Start, v3End;\n    if( bAValid && bBValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistA, fCamDistB );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistA, fCamDistB );\n    }else if( bBValid && bCValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistB, fCamDistC );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistB, fCamDistC );\n    }else if( bCValid && bAValid )    {\n        v3Start = v3CameraPos + v3LookDir * min( fCamDistC, fCamDistA );\n        v3End = v3CameraPos + v3LookDir * max( fCamDistC, fCamDistA );\n    }else{       return v3( 0.0, 0.0, 0.0, 2.0 );    }       //no intersection!\n    v2 S = CartToBary( v3Start.xy );\n    v2 E = CartToBary( v3End.xy );\n    //Plug in eye ray and solve variables for root finding.\n    v2 ES = E - S;\n    v0 fA = dot( ES * ES, CP_2 ) + 2.0*dot( v2(ES.y*ES.z, ES.x*ES.z, ES.x*ES.y), CP_0 );\n    v0 fB = - (v3End.z - v3Start.z) + 2.0*( \n        dot( ES*S, CP_2 ) + \n        dot( v2((ES.y*S.z + ES.z*S.y), (ES.x*S.z + ES.z*S.x), (ES.x*S.y + ES.y*S.x)), CP_0 ) );\n    v0 fC = - v3Start.z + dot( S*S, CP_2 ) +\n    \t2.0*dot( v2(S.y*S.z,S.x*S.z,S.x*S.y), CP_0 );    \n    //Actual root finding\n    v0 fRoot = fB*fB - 4.0*fA*fC;\n    if( fRoot >= 0.0 )    {\n        v0 fRootA = (-fB + sqrt( fRoot ) ) /( 2.0 * fA );\n        v0 fRootB = (-fB - sqrt( fRoot ) ) /( 2.0 * fA );        \n        if( fRootA >= 0.0 && fRootA <= 1.0 )        {\n            if( fRootB >= 0.0 )                fRootA = min( fRootB, fRootA );\n            return v3( S + fRootA*ES, fRootA );        }\n        if( fRootB >= 0.0 && fRootB <= 1.0 )            return v3( S + fRootB*ES, fRootB );    }    \n    return v3(0.0, 0.0, 0.0, 2.0);}/**/\n\n\n\n//by @JJcoolkl,crunched by ollj\n//analytical intersection of RAY [u,d]=[origin,direction] \n//and quadratic-bezier triangular-patch(6 CV-heights)\n//in:\n//c1,c0 6 CW heights (orthogonal to triangle plane)\n//p1,p2,p3 corners of base triangle\n//res=resolution.x (screen width in oixel)\n//out:\n//.xyz returns intersection\n//.w   returns if it hits (.w<=1 means it hit a surface)\n//inout:\n//cd is a debug color, used to show the bounding volume, and 3 cases within that volume.\nv3 BezierTriISect(const v2 u,const v2 d,v2 c1,v2 c0,v1 p1,v1 p2,v1 p3,v0 res,inout v2 cd\n){\n ;//return BezierTriISect(u,d,c1,c0) //reference to grandparent version, to compare if i introduced an error, or found a grandpparent error\n ;v1 L=u.xy-d.xy\n ,a=LineISect(p1,p2,u.xy,L)//project ray onto the triangle, within its ray+triangle intersections\n ,b=LineISect(p2,p3,u.xy,L)\n ,c=LineISect(p3,p1,u.xy,L)//three 2d intersections\n //\n //sicne eror hairlines are always lines, the error seems to be in the projected triangle 2d intersection.\n //\n //g+bA, h+bB, o+bC distinguish 3 ways to slice a triangle in two, in respect to its corners \n #define Mm(a,b,c)min(a.c,b.c)\n #define MM(a,b,c)max(a.c,b.c)\n #define mmm(a,b)v3(Mm(a,b,x),Mm(a,b,y),MM(a,b,x),MM(a,b,y))+q\n ;v3 q=v3(-1,-1,1,1)*.001/res//tiny epsilon accounts for precision loss. this seals the seam between 2 planes in screenspace\n //;v3 q=v3(-1,-1,1,1)*4./res//just to visualize the screenspace seam\n ,g=mmm(p1,p2),h=mmm(p2,p3),o=mmm(p3,p1)\n #define altm(a,b)any(lessThan(v3(a,b.zw),v3(b.xy,a)))\n ;bool bA=altm(a.xy,g),bB=altm(b.xy,h)\n ;v2 f,e=(v2(a.x,b.x,c.x)-u.x)/d.x//e stores 3 lengths.x of raystart.x to intersections.x, we care more for the shorter ones here.\n ;cd=v2(.7,0,0);//initially assume intersection with 1/3 sides of a \"triangle prism\"\n ;       if(  bA||bB ){bool bC=altm(c.xy,o)//restructured,1/3 of all cases skips the calculation of cB (remains default assumed case above)\n  ;      if(!(bB||bC)){e=e.yzx;cd=cd.yzx//intersection with 1/3 sides of a \"triangle prism\"\n  ;}else if(!(bA||bC)){e=e.zxy;cd=cd.zxy//intersection with 1/3 sides of a \"triangle prism\"\n ;}else{cd=cd.yyy;return v3(0,0,0,2);}}//no intersection with prism\n ;f=u+d*miv(e.xy);v2 S=CartToBary(f.xy,p1,p2,p3)//barycentric projection root solving black magic\n ;e=u+d*mav(e.xy);v2 E=CartToBary(e.xy,p1,p2,p3)-S//Plug in eye ray and solve variables for root finding.\n ;o=v3(0,f.z-e.z,dot(S*S,c1)-f.z,0)\n   +v3(dot(E*E,c1)+dot(E.yxx*E.zzy,c0)*2.\n      ,dot(E*S,c1)+dot(v2(dot(E.yz,S.zy),dot(E.xz,S.zx),(E.x*S.y+E.y*S.x)),c0)//i smell a cross()\n      ,dot(v2(S.y*S.z,S.x*S.z,S.x*S.y),c0),0)*2.//3 root solving factors; .x is the scalar to baricentric range[0..1]\n ;o.z=o.y*o.y-2.*o.x*o.z\n ;if(o.z>=0.&&o.x!=0.//worksafing\n ){a=(v1(1.,-1.)*sqrt(o.z)-o.y)/o.x;//[a] stores 2 distances to two roots, scaled to a [0..1] barycentric range., a.x may not be within that range, meaning theres less than 2 roots.\n  ;if(abs(a.x-.5)<.5\n  ){if(a.y>0.) a.x=miv(a); //a.xy may not be within that [0..1]range, meaning theres less than 2 roots, we hope theres one root.\n   ;return v3(S+a.x*E,a.x);}\n  ;if(abs(a.y-.5)<=.5){cd+=v2(0,.3,.3);return v3(S+a.y*E,a.y)//;if(a.y>=0.&&a.y<=1.)\n  ;}};return v3(0,0,0,2);}//no intersection\n\n\n\n//above function has triangle normal fixed to v2(0,0,+11), all corners have .z==0.\n//below version rotates the whole set around p1 to set the triangle normal to v2(0,0,1)\nv3 BezierTriISect(v2 u,v2 d,v2 c1,v2 c0,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd\n){v2 n=normalize(triangleNornal(p1,p2,p3))\n ;v3 b=RotBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;v2 s=v2(0,0,p1.z);\n \n// ;u =r(b,u ,p1)-s\n// ;d =r(b,d ,p1)-s\n// ;p2=r(b,p2,p1)-s\n// ;p3=r(b,p3,p1)-s\n ;return BezierTriISect(u,d,c1,c0,p1.xy,p2.xy,p3.xy,res,cd);}\n//this transform seems to be false.", "buffer_a_code": "//buffA.start\n\n/*\nbezier patch analytic: https://www.shadertoy.com/view/4tSyRz\n- single page, less duped code. trutural sorting \n- less globals, more object oriented.\n- more defines\n- larger render distance.\n- establishing [tiny namespace convention]\n- - mostly in scene()\n- - distance field is called gd() and gd1()for colors (resolves fractal G-buffer stuff?)\nparent: https://www.shadertoy.com/view/lsd3Dl\n  Rocket City by eiffie (although there are no rockets \n   and there is little if any esemblance to a city this is what eiffie called it)\n  eiffie just wanted to make a reusable flight control \n   but then messed that up with collision detection.\n*/\n\nv2 BezierTriangle_Quadratic_Normal(const v2 u,const v2 a,const v2 b,v2 p1,v2 p2,v2 p3//get normal(2nd derivative)of quadradicBezier triangularPatch\n){v2 n=triangleNornal(p1,p2,p3)\n ;v3 c=RotBetween(n,v2(0,0,1))\n ;//we rotate everything around p1, and then move it by -p1.z, to make all p*.z values ==0.\n ;//v2 s=v2(0,0,p1.z);\n ;//p2=r(c,p2,p1)-s\n ;//p3=r(c,p3,p1)-s\n ;return normalize(cross(v2(p1.xy-p2.xy,suv(u*v2(a.x-b.z,b.z-a.y,b.y-b.x)))\n                        ,v2(p1.xy-p3.xy,suv(u*v2(a.x-b.y,b.z-b.x,b.y-a.z)))));}\n\nv3 ComputeBezierColor(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3,v0 res,inout v2 cd//get color based on bezier tri intersection+lighting\n){v3 v4ISect=BezierTriISect(u,d,a,b,p1.xy,p2.xy,p3.xy,res,cd)//analytical intersection of ray [u,d] and triangular quadratic-bezier patch(6 CV-heights [a,b])\n ;v2 c=v2(0)\n ;if(v4ISect.w<2.\n ){v2 n=BezierTriangle_Quadratic_Normal(v4ISect.xyz,a,b,p1,p2,p3)//analytical first derivative\n  ;c=n*.5+.5\n  ;if(board(v4ISect.xyz*9.)>0.)c.z=1.-c.z//barycentric checkerboard\n  ;return v3(c,1);}return v3(0);}\n\n//controls (i may have swapped left and right here, do not overthing this one)\n#define LEFT_ARROW 39\n#define RIGHT_ARROW 37  \n#define UP_ARROW 38\n#define DOWN_ARROW 40\n\n#define THRUST 0.1*iTimeDelta\n#define ROLL 1.0*iTimeDelta\n#define ROTATE 4.0*iTimeDelta\n//collision epsilon\n#define TOO_CLOSE 0.01\n//should scale with movement speed\n//return signed distane of[p] to a surface. (relict for collision detection of flyCamera.\nv0 gd(v2 u){return 999.;}//never collide\n\n//load and save, originally from iq, modified\nv0 isInside(v1 p,v1 c){v1 d=abs(p-.5-c)-.5;return -max(d.x,d.y);}\nv3 load(int re){return texture(iChannel0,(.5+v1(re,.0))/iChannelResolution[0].xy,-100.);}\nvoid store(in int re, in v3 va, inout v3 o, in v1 u\n){if(isInside(u,v1(re,0))>.0)o=va;}//o=(isInside(u,v1(re,0))>.0)?va:o;}\n//bool KeyDown(in int key){return (texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x>0.0);}\nv0 key(in int key){return texture(iChannel1,v1((v0(key)+0.5)/256.0, 0.25)).x;}\n\n/*\n//namespace convention\n[o]RayOrigin\n[d]RayDirection\n[c]color, to be returned\n[f]FragmentSpaceScaling, to blur rasterization, against moire;a=smoothstep(s,-s,a);\n[t]TimeTraveled (implies division by speed of light) == distance to camera \n[g]gradient, signed distance to surface.\n*/\n\nv0 sp(v2 u,v2 d,vec4 s//draw CV as transparent spheres,with simple projection;radius scaled by distance to camera.//cameraPos,Sphere\n){u-=s.xyz;v0 a=dot(d,u);u.x=length(u);s.w+=.0001;u.y=s.w*s.w;return sat(mix(0.,1.,(a*a-(u.x*u.x)+u.y)/(u.y-s.w*s.w)));}\nv0 ComputeOverlay(v2 u,v2 d,v2 a,v2 b,v2 p1,v2 p2,v2 p3\n ){v2 n=normalize(triangleNornal(p1,p2,p3))\n  ;return sp(u,d,v3(p1+n*a.x,.2))\n         +sp(u,d,v3(p2+n*a.y,.2))      \n         +sp(u,d,v3(p3+n*a.z,.2))      \n         +sp(u,d,v3((p1+p2)*.5+n*b.x,.2))\n         +sp(u,d,v3((p3+p1)*.5+n*b.y,.2))\n         +sp(u,d,v3((p2+p3)*.5+n*b.z,.2));}//paint 6 CVs\n\n//lots of min max for an aabv\nv0 doAABV(v2 v,v2 d,v2 p1,v2 p2,v2 p3,v2 a,v2 b){\n     ;v2 n=normalize(triangleNornal(p1,p2,p3))\n// ;v3 q=RotBetween(n,v2(0,0,1))\n/*\n ;v2 s=v2(0,0,p1.z);\n ;p2=r(q,p2,p1)-s\n ;p3=r(q,p3,p1)-s\n/**/ \n ;v2 cv1=p1+n*a.x,cv12=(p1+p2)*.5+n*b.x\n ;v2 cv2=p2+n*a.y,cv23=(p3+p3)*.5+n*b.y\n ;v2 cv3=p3+n*a.z,cv31=(p3+p1)*.5+n*b.z\n #define muchm(a,b,c) v0 b=a(a(a(cv1.c,cv2.c),a(cv3.c,cv12.c)),a(cv23.c,cv31.c))\n ;muchm(min,x,x);muchm(max,X,x)\n ;muchm(min,y,y);muchm(max,Y,y)\n ;muchm(min,z,z);muchm(max,Z,z)     \n ;v2 aa=aabv(v,d,v2(x,y,z),v2(X,Y,Z))\n ;if(aa.x<1.)return 0.//outside of AABV\n ;return 1.;}\n\nv2 bezierPatch(v2 v,v2 d,v2 p1,v2 p2,v2 p3){//position,direction, trianglecorners \n ;v3 o=v3(0);\n ;mat3 pq=pqfmA()//matrix of different quadratic fields, to be most aperiodic\n ;pq=pq*(iTime*.2+.001)//.001 to skip the coplanar case at iTime==0 (with tiny determinant). dare to get closer to it, its quite the precision-mess where it gets too planar (but not quite planar)\n ;v2 a=cos(pq[0]),b=cos(pq[2])\n ;//a=v2(0,1,2)\n ;//b=v2(0,1,2)\n ;a*=9.\n ;b*=9.\n ;v2 cd=v2(0)\n //the line below is completely optional, and may not even be worth computing\n //as it is only an AxisAlignedBoundingVolume for culling.\n ;if(doAABV(v,d,p1,p2,p3,a,b)==0.)return v2(.5)//if(ray misses AABV)return grey!\n    \n ;//a*=0.0;b*=0.0 //known bug debug enforcing case: planar case has determinant of 0 special case!\n ;v3 c=ComputeBezierColor(v,d,a,b,p1,p2,p3,iResolution.x,cd)\n ;c=mix(v3(.5,.5,.5,1.),c,c.a)//lazy alpha compositioning\n ;if(c.xyz==v2(.5))c.xyz=mix(c.xyz,cd,.2)//debug color output\n ;o=mix(c,v3(.7,.7,.7,1),ComputeOverlay(v,d,a,b,p1,p2,p3))\n ;return o.xyz;\n;}\n \nv2 scene(v2 o,v2 d\n){ //corners.xy of a triangle\n ;v2 \n p1=v2(-4,0,0)\n,p2=v2(4,0,0)\n,p3=v2(0,sqrt(3.)/3.*4.*4.,0);\n//.z==0. for simplicity/debugging\n ;return bezierPatch(o,d,p1,p2,p3)\n ;}//origin,direction\n\nv3 mainImage2(out v3 fragColor,v1 fragCoord){\n v2 t=normalize(v2((2.0*fragCoord-iResolution.xy)/iResolution.y,1.0));\n v2 o=load(0).xyz;\n v3 fw=(load(1));\n t=r(fw,t);\n return v3(scene(o,t),1);}\n\nvoid steer(out v3 o,v1 u\n){v3 p,qrot\n ;if(iFrame<2//init\n ){p=v3(8,4,0,0)-v3(11,11,11,0)\n  ;//todo debug the line in this camera angle: p=v3(8,4,0,0);qrot=normalize(v3(0,1,2,1))\n  ;qrot=normalize(v3(0,1,2,1))\n  ;//p.xyz+=r(qrot,v2(0,0,1))*6.//move camera forward, but the error is gone then\n ;}else{//next frame\n  ;p=load(0);qrot=load(1)//load state from previous frame\n  ;v2 fw=v2(0,0,1)\n  ;fw=r(qrot,fw) //this can be done simpler\n  ;v2 newp=p.xyz+fw*p.w*.2\n  ;if(gd(newp)>TOO_CLOSE)p.xyz=newp\n  ;else{\n   ;if(gd(v2(p.xy,newp.z))>TOO_CLOSE)p.z=newp.z;\n   ;if(gd(v2(p.x,newp.y,p.z))>TOO_CLOSE)p.y=newp.y;\n   ;if(gd(v2(newp.x,p.yz))>TOO_CLOSE)p.x=newp.x;//mkay every domain checked intependently\n  ;}\n ;p.w+=THRUST*(key(UP_ARROW)-key(DOWN_ARROW));\n ;v0 roll=ROLL*(key(RIGHT_ARROW)-key(LEFT_ARROW));\n ;v1 m=v1(0)\n ;vec4 mouse=iMouse\n ;mouse=iMouseZwFix(mouse,true)\n ;if(iMouse.z>.0\n ){v1 n=mouse.xy-mouse.zw\n  ;n.x=-n.x\n  ;m.xy-=(n)/iResolution.xy;}\n ;v3 qp=q(v2(m.yx*ROTATE,roll))\n ;qrot=normalize(r(qrot,qp))//normalize before saving\n;}\n;store(0,p,o,u)//position,forwardVelocity\n;store(1,qrot,o,u)//rotation\n;}\n\nvoid mainImage(out v3 o,v1 u){\n;if(all(lessThan(u,v1(2.5,1.5))))steer(o,u)\n    ;else o=mainImage2(o,u); }", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyzd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1567, 1567, 1605, 1605, 1680]], "test": "untested"}
{"id": "tlBczd", "name": "fractal blob 2", "author": "feedme", "description": "yeh", "tags": ["yeh"], "likes": 1, "viewed": 267, "published": 3, "date": "1595087214", "time_retrieved": "2024-07-30T20:54:58.273436", "image_code": "//------Distance field--------\n\n//Returns the following values:\n//X: distance to the fractal.\n//Y: number of iterations needed, from 0 to 1.\n//Z: The 'r' value.\n//W: The 'dr' value.\nvec4 getDistanceToFractal(vec3 pos, float timeScale, float bailoutScale)\n{\n    const int Iterations = 7;\n    float Bailout = 2.0 * bailoutScale;\n    float powLerp = 0.5 + (0.5 * sin((iTime * timeScale) + 4.9));\n    float Power = mix(1.0, 8.0, pow(powLerp, 1.0));\n    \n    vec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n    float nIterations = 0.0;\n\tfor (int i = 0; i < Iterations ; i++) {\n\t\tr = length(z);\n        nIterations += 1.0;\n        \n\t\tif (r>Bailout)\n        {\n            break;\n        }\n\t\t\n\t\t// convert to polar coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow( r, Power-1.0)*Power*dr + 1.0;\n\t\t\n\t\t// scale and rotate the point\n\t\tfloat zr = pow( r,Power);\n\t\ttheta *= Power;\n\t\tphi *= Power;\n\t\tphi = (phi);\n        \n\t\t// convert back to cartesian coordinates\n\t\tz = zr*vec3(sin(theta)+cos(phi), sin(phi)+sin(theta), cos(theta)); // changeing * to + did cool stuff\n\t\tz+=pos;\n\t}\n\treturn vec4(0.5*log(r)*r/dr,\n                nIterations / float(Iterations),\n                r,\n                dr);\n}\n\nmat3 rotPos2 = mat3(0.7071067812, -0.7071067812, 0.0,\n                   \t0.70710678120, -0.7071067812, 0.0,\n                    0.0, \t\t   0.0, \t\t  1.0);\n//Returns the following values:\n//X: distance to the surface.\n//Y: number of iterations needed, from 0 to 1.\n//Z: The 'r' value.\n//W: The 'dr' value.\nvec4 getDistanceToSurface(vec3 pos)\n{\n    return getDistanceToFractal(pos, 1.2, 1.);  //warp speed\n    vec4 first = getDistanceToFractal(pos, 1.0, 1.0),\n         second = getDistanceToFractal(pos, 10.0, 10.0);\n    if (first.x < -second.x) return first;\n    else return second;\n}\n\nvec3 getNormal(vec3 pos)\n{\n    const vec2 epsilon = vec2(1.0, 0.004);\n    \n    return normalize(vec3(getDistanceToSurface(pos + epsilon.yxx).x -\n                              getDistanceToSurface(pos - epsilon.yxx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xyx).x -\n                              getDistanceToSurface(pos - epsilon.xyx).x,\n                     \t  getDistanceToSurface(pos + epsilon.xxy).x -\n                              getDistanceToSurface(pos - epsilon.xxy).x));\n}\n\n\n\n//-----Ray-marching---------\n\nstruct RayMarchData\n{\n    float moveDist;\n    vec3 hitPos;\n    float nIterations;\n    \n    float nFractalIterations;\n    float fractalR, fractalDR;\n};\n\n#define MAX_ITERATIONS 200\n#define MAX_ITERATIONS_F float(MAX_ITERATIONS)\n    \n#define DISTANCE_EPSILON 0.00001\n\n//Performs the ray-marching algo. Returns whether something was hit.\nbool marchRay(out RayMarchData dat, vec3 rayStart, vec3 rayDir)\n{\n    dat.hitPos = rayStart;\n    dat.nIterations = 0.0;\n    vec4 distData;\n    \n    for (int i = 0; i < MAX_ITERATIONS; ++i)\n    {\n        dat.nIterations += 1.0;\n        distData = getDistanceToSurface(dat.hitPos);\n        \n        if (distData.x < DISTANCE_EPSILON)\n        {\n            dat.nFractalIterations = distData.y;\n            dat.nIterations /= float(MAX_ITERATIONS);\n            dat.fractalR = distData.z;\n            dat.fractalDR = distData.w;\n            return true;\n        }\n        \n        dat.hitPos += (distData.x * rayDir);\n        dat.moveDist += distData.x;\n    }\n    \n    dat.nIterations /= float(MAX_ITERATIONS);\n    return false;\n}\n\n\n\n//-----------Main------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //Cam data.\n    float distFromCenter = 2.5 + (0.0 * sin(10.8 * iTime)); //sinewave of moving in and out (currently off)\n    const float camRotSpeed = 0.01;\n    vec3 camForward = normalize(vec3(cos((camRotSpeed * iTime) + (iMouse.x / iResolution.x * -8.0)),\n                                     sin((camRotSpeed * iTime) + (iMouse.x / iResolution.x * -8.0)),\n                                     mix(-1.5, 1.5, iMouse.y / iResolution.y))),\n         camPos = distFromCenter * -camForward,\n         camUp = vec3(0.0, 0.0, 1.0),\n         camSide = cross(camForward, camUp);\n    camUp = cross(camSide, camForward);\n    \n    \n    //Ray data.\n    const float fovScale = 0.5;\n    vec2 uvNormalized = -1.0 + (2.0 * uv);\n    vec3 rayStart = camPos + (camForward * fovScale) +\n        \t\t\t(camSide * uvNormalized.x) +\n        \t\t\t(camUp * uvNormalized.y * (iResolution.y / iResolution.x));\n    vec3 rayDir = normalize(rayStart - camPos);\n    \n     \n    //Ray-march through the scene.\n    RayMarchData dat;\n    bool hit = marchRay(dat, rayStart, rayDir);\n    \n    //Color the scene.\n    if (hit)\n    {\n        float val = 1.0 - smoothstep(0.0, 1.0, smoothstep(0.0, 1.0, pow(dat.nIterations, 0.25)));\n        //float val = pow(dat.fractalR, 0.25);\n        fragColor.xyz = vec3(val);\n        \n        //fragColor.xyz = fract(dat.hitPos * 2.0);\n        //fragColor = texture(iChannel0, vec2(val, iTime * 0.1));\n        //fragColor = vec4(dat.hitPos * pow(val, 0.5), 1.0);\n    }\n    else\n    {\n        fragColor = vec4(texture(iChannel1, rayDir.xzy).xyz, 1.0);\n    }\n    \n    \n    //Some debug-logging color outputs.\n    //fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n    //fragColor = vec4(0.5 + (0.5 * getNormal(dat.hitPos)), 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBczd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 182, 256, 256, 1220], [1376, 1526, 1563, 1563, 1804], [1806, 1806, 1832, 1832, 2309], [2608, 2677, 2742, 2742, 3402], [3406, 3436, 3493, 3493, 5255]], "test": "untested"}
{"id": "ttSyRd", "name": "stolen mandelbrot", "author": "feedme", "description": "to convert", "tags": ["learning"], "likes": 4, "viewed": 326, "published": 3, "date": "1595082241", "time_retrieved": "2024-07-30T20:54:59.021436", "image_code": "#define distfar 6.0\n#define iterations 4\n\nfloat calcfractal(vec3 coord) {\n    vec3 orbit = coord;\n    float dz = 1.0; // darkness again\n    \n    for (int i=0; i<iterations; i++) {\n        \n        float r = length(orbit);\n    \tfloat o = acos(orbit.z/r);\n    \tfloat p = atan(orbit.y/orbit.x);\n        \n        dz =12.0*r*r*r*r*r*r*r*dz + 1.0; // this effected darkness and tone\n        \n        r = r*r*r*r*r*r*r;\n        o = 4.0*o;                // alter the fractal\n        p = 16.0*p;               // alter the fractal / vertical division\n        \n        orbit = vec3( r*sin(o)*cos(p), r*sin(o)*sin(p), r*cos(o) ) + coord;\n        \n        if (dot(orbit,orbit) > 1.544) break; // changing this changed the fractal itself, going to 1 to reset\n    }\n    float z = length(orbit);\n    return 0.6*z*log(z)/dz; // shadows\n}\n\nvec2 map(vec3 p) {\n    return vec2(calcfractal(p.xzy),1.0);\n}\n\nvec3 trace(vec3 ro, vec3 rd) {\n    float t = 0.2;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>distfar) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return vec3(t, h.y, i);\n        t += h.x;\n    }\n    return vec3(0.0);\n}\n\nvec3 calcnormal(vec3 p) {\n    vec2 e = vec2(0.0801,0.0); // moving highlights?\n    vec3 n;\n    n.x = map(p+e.xyy).x - map(p-e.xyy).x;\n    n.y = map(p+e.yxy).x - map(p-e.yxy).x;\n    n.z = map(p+e.yyx).x - map(p-e.yyx).x;\n    return normalize(n);\n}\n\nfloat softshadow (vec3 ro, vec3 rd) {\n    float res = 0.;\n    float t = 0.1;\n    for (float i = 0.0; i < 1000.0; i++) {\n        if (t>1.0) break;\n        vec2 h = map(ro + t*rd);\n        if (h.x < 0.0001) return 0.0;\n        res = min(res, 4.0*h.x/t);\n        t += h.x;\n    }\n    return res;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = (2.0)*uv-1.0;                            // size from bottom left // second no. horizontal align\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(0.0,0.0,-1.4);  // horizontal cam // vertical cam // distance\n    vec3 rd = normalize(vec3(uv,1.5));\n    float the = 3.0*sin(iTime/30.0-1.0); // vertical axis set zero\n    mat2 rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.yz *= rmat;\n    ro.yz *= rmat;\n    the = iTime/30.0; // turn speed // higher is slower\n    rmat = mat2(cos(the),sin(the),-sin(the),cos(the));\n    rd.xz *= rmat;\n    ro.xz*= rmat;\n    \n    vec3 t = trace(ro, rd);\n    \n    vec3 col = vec3(0.); // BACKGROUND COLOUR\n    \n    if (t.z > 0.0) {\n        vec3 pos = ro + rd*t.x;\n        vec3 nor = calcnormal(pos);\n        vec3 lig = normalize(vec3(0.3,1.0,0.3)); // light direction?\n        vec3 rdy = dot(nor, rd) * nor;\n        vec3 rdx = rd - rdy;\n        vec3 ref = rdx - rdy;\n        \n        float occ = clamp(0.0,1.0,1.0/(1.0+pow(t.z/30.0,3.0)));\n        float sha = softshadow(pos, lig);\n        float dif = max(0.0,dot(lig,nor));\n        float sky = max(0.0,nor.y); // brightness / dodge\n        float ind = max(0.0,dot(-lig,nor));\n        float spec = pow( max(0.0,dot(ref,lig)) , 20.0);\n        \n        col  = dif*vec3(0.9,0.8,0.7)*vec3(sha);\n        col += sky*vec3(0.16,0.20,0.24)*occ;\n        col += ind*vec3(0.40,0.48,0.40)*occ;\n        col += 0.1*occ;\n        col += spec*sha*vec3(0.9,0.8,0.7);\n\n        \n        col = pow(col,vec3(0.45));\n    }\n    \n\tfragColor = vec4(col,1.0);\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[42, 42, 73, 73, 822], [824, 824, 842, 842, 885], [887, 887, 917, 917, 1140], [1142, 1142, 1167, 1167, 1388], [1390, 1390, 1427, 1427, 1683], [1686, 1686, 1743, 1743, 3337]], "test": "untested"}
{"id": "WlBcRd", "name": "Alien Thing", "author": "Leria", "description": "Alien Thing\nWarning, dont touch it... also, it looks like a virus...\nI just played with my energy transfer shader to have this look, I mixed it with a fbm\n", "tags": ["fractal", "noise", "perlin", "alien", "energy"], "likes": 9, "viewed": 564, "published": 3, "date": "1595032749", "time_retrieved": "2024-07-30T20:54:59.969900", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//animation 0 or 1\n#define ANIM\t\t\t\t1\n\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.1\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t.2\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  .6 );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n    \n            float anim = 0.;\n            #if ANIM\n            anim = iTime/2.;\n            #endif\n    \n    f = Psnoise(p+anim); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); \n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 5.), m.pos); \n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(1.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s <120; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            \n            float rad_bubl = RADIUS/5.; //radius of bubble, also control the opening of the bubble\n            vec3 pB = vec3(0,0,rad_bubl);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (rad_bubl) -1.);\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);             \n            \n            float dispersion_rate = (fbm((p/2.))); //local dispersion rate\n\n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate); //modify it to tune the local velocity, 1.60 is precalculated value\n            //velocity\n            #define VT\tvelocity            \n           \n            //energy\n            float energy = .5*(VT*VT*VT)/rad_bubl; //energy transfer rate\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = ( Psnoise( (p-pB+dp)*l) + energy)*(max(0.,d)*l);\n\n\n            float mask = smoothstep(0.,\n                                    10.*RADIUS,\n                                  \t(RADIUS-length(center)));// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size          \n             vec3 rgb_t = exp(-vec3(\n                \t\tk * 1. * dens, \n                      \tk * 2. * dens,\n              \t      \tk * 2. * dens));    \n            \n            t_acc *= (rgb_t);           \n    \n    \t\t//blending\n   \t\t\tc += t_acc*vec3(1.)*(1.-rgb_t);\n            \n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n        \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(0.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "#define PI \t\t\t\t\t3.1415926\n\n//most of \"noise stuff\" comes from iq\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n/////////////////////\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1460, 1460, 1485, 1498, 1872], [1874, 1874, 1899, 1912, 2376], [2378, 2378, 2397, 2397, 2490], [2492, 2511, 2587, 2587, 2634], [2636, 2636, 2668, 2668, 2688], [2690, 2690, 2724, 2724, 2746], [2833, 2833, 2874, 2874, 2910], [2912, 2912, 2998, 2998, 3033], [3035, 3035, 3078, 3078, 3118], [3120, 3120, 3144, 3144, 3192], [3194, 3194, 3234, 3234, 3538], [3540, 3540, 3564, 3564, 3627], [3630, 3630, 3682, 3682, 7044], [7047, 7047, 7104, 7104, 7733]], "test": "untested"}
{"id": "3lBcRd", "name": "Cratered planets", "author": "jarble", "description": "Another variation of my [url=https://www.shadertoy.com/view/wlBczy]\"planets with moons\"[/url] fractal. By adding the fractal to itself at several different scales, I added many bumps and craters to the planets' surfaces.", "tags": ["3d", "raymarching", "planets"], "likes": 2, "viewed": 373, "published": 3, "date": "1595032610", "time_retrieved": "2024-07-30T20:55:00.776743", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p,float i) {\n    p += sin(p.yzx*i/100.0)*50.0/i;\n    //p += sin(p.yzx*20.0)/80.0;\n    return  (3.0 -.9/(i)+ sin(p.x)+cos(p.y)+cos(p.z))*2.9;\n}\n\nfloat sceneSDF2(vec3 p,int iterations){\n    float k = 1.0;\n    float to_return = sceneSDF1(p,k);\n    for(int i = 0; i < iterations; i++){\n        k *= 6.0;\n\n        to_return = min(to_return, to_return*1.5/k+sceneSDF1(p*k,k/5.0));\n    }\n    return to_return;\n}\n\nfloat sceneSDF2(vec3 p){\n\treturn sceneSDF2(p,2);\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 100.0;\n    return sceneSDF2(p,1)-sceneSDF2((p.yzx)*(10.0+sceneSDF2(p*(20.0))*.01))*.01;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= 100.0;\n    vec3 c1 = vec3(sceneSDF2(p+p.yzx/2.0),sceneSDF2(p+p.zxy/2.0),sceneSDF2(p+p/2.0));\n    return (sin(c1))*vec3(.5)/(5.0)+vec3(.4,.3,.3);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    //viewDir.xz *= sin(iTime)/2.0+1.0;\n    \n    vec3 eye = vec3(5.0, 5.0, 5.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t*t/3/4096)%3+(t/7/4096)%7-(t/2/4096)%2)))|t>>4|t>>5&t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[489, 489, 522, 522, 652], [654, 654, 693, 693, 914], [916, 916, 940, 940, 966], [968, 968, 991, 991, 1090], [1092, 1092, 1120, 1120, 1276], [1278, 1699, 1790, 1790, 2138], [2153, 2407, 2472, 2472, 2604], [2606, 2695, 2724, 2724, 3034], [3036, 3528, 3668, 3668, 4258], [4260, 4630, 4715, 4715, 5073], [5075, 5402, 5451, 5486, 5617], [5619, 5619, 5676, 5676, 6799]], "test": "untested"}
{"id": "WtBcRd", "name": "1/2 oct. steps", "author": "yonatan", "description": "idk, another iteration on https://www.shadertoy.com/view/3tSczK\n\nmouse x sets speed.", "tags": ["fractal"], "likes": 5, "viewed": 378, "published": 3, "date": "1595032354", "time_retrieved": "2024-07-30T20:55:01.929661", "image_code": "#define R2 1.41421356237\n#define r (iResolution.xy)\n#define t (iTime*(1.-iMouse.x/r.x))\n#define M(q)q*=mat2(sin(t*.1-t/s+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n\tfloat s,g,e,i;\n    for(i=g=0.;i++<20.;){\n        e=s=2.;\n        vec4 p=vec4(g*(FC.xy*e-r)/r.y,g-1.7,1);\n        for(int i;i++<24;s*=R2)\n            M(p.xy),\n            M(p.yz),\n            p=abs(p)*R2-R2+1.;\n        g+=e=length(p)/s;\n        o+=(1e-5-p/s*.05)/e;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 182, 182, 471]], "test": "untested"}
{"id": "WlScRd", "name": "Simple triangle", "author": "UrbanFlame", "description": "Input you triangle points and create simple triangle", "tags": ["test"], "likes": 1, "viewed": 390, "published": 3, "date": "1595028484", "time_retrieved": "2024-07-30T20:55:02.695613", "image_code": "// Check if point (current uv coords) has same sign as third point in compare with straight line\n// of triangle\nbool isInPlace(vec2 curPos, vec2 start, vec2 end, vec2 other)\n{\n    float a = (curPos.x - start.x) / (end.x - start.x);\n\tfloat b = (curPos.y - start.y) / (end.y - start.y);\n    float diff = a - b;\n    \n    float a1 = (other.x - start.x) / (end.x - start.x);\n\tfloat b1 = (other.y - start.y) / (end.y - start.y);\n    float diff1 = a1 - b1;\n    \n    return (diff1 >= 0.0 && diff >= 0.0) || (diff < 0.0 && diff1 < 0.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(1.0, 1.0, 1.0);\n\n    \n    //Setup your points for triangle\n    vec2 aPoint = vec2(0.1213, 0.313);\n    vec2 bPoint = vec2(0.43895, 0.821398);\n    vec2 cPoint = vec2(0.4934, 0.6405);\n    \n    \n    if (isInPlace(uv, aPoint, bPoint, cPoint) &&\n        isInPlace(uv, aPoint, cPoint, bPoint) &&\n        isInPlace(uv, bPoint, cPoint, aPoint))\n    {\n    \tcol = vec3(0.0, 0.0, 0.0);        \n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 112, 175, 175, 529], [532, 532, 589, 639, 1182]], "test": "untested"}
{"id": "3tByRd", "name": "GB/GBC Camera", "author": "CelestialAmber", "description": "Inspired by yx's version: https://www.shadertoy.com/view/ttsSzr", "tags": ["camera"], "likes": 4, "viewed": 589, "published": 3, "date": "1595022896", "time_retrieved": "2024-07-30T20:55:03.689954", "image_code": "#define mode 1  //0: Game Boy, 1: Game Boy Color\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n\nvec2 res = vec2(128,112); //Gameboy Camera's screen resolution\n    vec2 uvRes = vec2(floor(res.y*(iResolution.x/iResolution.y)),res.y); //Widescreen version of the Gameboy's screen resolution\n    \n    \n    vec2 uv = fragCoord/iResolution.xy; \n    uv.x=1.-uv.x; // optional mirror selfie mode\n    vec2 pos = floor(uv*uvRes);\n       \n    vec3 col = vec3(0);\n\n    if (uvRes.x/2. - res.x/2. < pos.x && uvRes.x/2. + res.x/2. > pos.x){\n        if(mode == 0){\n        //use specific weighted amounts of each channel to improve the grayscale colors (Luma values)\n    \tfloat gray = dot(texture(iChannel0,pos/uvRes).rgb, vec3(0.2126,0.7152,0.0722));\t\n        float dither = texture(iChannel1, pos/8.).r;\n            \n    \tcol = vec3(floor(gray*3.+dither)/3.);\n        }else{\n        vec3 tex = texture(iChannel0,pos/uvRes).rgb;\n        float dither = texture(iChannel1, pos/8.).r;\n        //downscale the colors to be within the GBC's limitations (around 56 colors max according to the Wikipedia article)\n        vec3 newCol = (floor(tex*4. + dither))/4.;\n            \n        col = newCol;        \n        }\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 106, 106, 1251]], "test": "untested"}
{"id": "3lSyRd", "name": "Test Circle 1", "author": "UrbanFlame", "description": "Simple circle with random colors\nTrying to understand how shader works", "tags": ["test"], "likes": 2, "viewed": 254, "published": 3, "date": "1595022328", "time_retrieved": "2024-07-30T20:55:04.640413", "image_code": "#define RandomF(x) 0.5+0.5*cos(x)\n\nfloat remap(float value, float inMin, float inMax, float outMin, float outMax)\n{\n \treturn outMin + (value - inMin) * (outMax - outMin) / (inMax - inMin) ;  \n}\n\nfloat remap(float value, float inMin, float inMax)\n{\n    return (value - inMin) * 1.0 / (inMax - inMin) ;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Created total color vec and setting to white for background\n    vec3 col = vec3(1.0, 1.0, 1.0);\n    float circleRadius = 1.0;\n \n    float xCircle = remap(uv.x, 0.0, 1.0, -1.0, 1.0) * iResolution.x / iResolution.y;    \n    float yCircle = remap(uv.y, 0.0, 1.0, -1.0, 1.0) ;\n    float sumCirclePoints = pow(xCircle, 2.0) + pow(yCircle, 2.0);\n    float powCircleRadius = pow(circleRadius, 2.0);\n    \n    if (sumCirclePoints <= powCircleRadius)\n    {\n        float linesFrequency = 3.0;\n        float colorValue = RandomF(uv.x * iTime * linesFrequency);\n     \tcol = vec3(uv.xyx * colorValue);\n        \n        //Adding alpha near to circle borders\n        //float distanceToCenter = distance(vec2(uv.x * iResolution.x / iResolution.y, uv.y)\n        //                                  , vec2(0.5 * iResolution.x / iResolution.y, 0.5));\n       \t\n        float distanceToCenter = sumCirclePoints / powCircleRadius;\n        col = mix(col, vec3(1.0, 1.0, 1.0), distanceToCenter);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyRd.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[35, 35, 115, 115, 193], [195, 195, 247, 247, 302], [305, 305, 362, 412, 1496]], "test": "untested"}
{"id": "WtBczt", "name": "Energy Transfer Look detailed", "author": "Leria", "description": "More visually detailed version of this shader : https://www.shadertoy.com/view/tl2czV and with a bit of color to distinguish the shades of opacity\nThreads are like path of the energy, big particles are accumulations of energy\nDark areas = big opacity", "tags": ["noise", "simplex", "energy", "transfer", "multiplicative"], "likes": 6, "viewed": 455, "published": 3, "date": "1595019064", "time_retrieved": "2024-07-30T20:55:05.688610", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//anim 0 or 1\n#define ANIM\t\t\t\t0\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t7.\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nfloat sdf_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12.), m.pos); \n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    int fbm_weight = 0;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n\n                        float anim = 0.;\n            #if ANIM\n            anim = iTime/2.;\n            #endif\n            \n            float rad_bubl = RADIUS/2.;\n            vec3 pB = vec3(0,0,rad_bubl);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (RADIUS/2.) -1.);\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB);             \n            \n            float dispersion_rate = 1./(Psnoise((p-anim))); //non-uniform dispersion rate\n\n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate); //modify it to tune the average velocity, 1.60 is precalculated value\n            //velocity\n            #define VT\tvelocity\n            \n            //energy rate\n\t\t\t#define \tEPSILON_R\t\t1.\n            \n            //energy\n            float energy = .5*(VT*VT*VT)/rad_bubl; //energy transfer rate\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            //if(energy > 8.)\n            \tn = .1*( fbm( (p-pB+dp)/1.*l) + EPSILON_R*energy)*(max(0.,d)*l);\n\n\n            float mask = smoothstep(0.,\n                                    4.*RADIUS,\n                                  (RADIUS-length(center)));// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                    1.) *n );\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 1. * dens, \n                      \tk * 2. * dens,\n              \t      \tk * 2. * dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    //fragColor = .5*vec4(Psnoise(vec3(uv, 1.)*20.))+.5; return;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBczt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[921, 994, 1016, 1016, 1189], [1859, 1859, 1916, 1916, 2085], [2087, 2110, 2132, 2385, 3302], [3304, 3304, 3330, 3330, 4155], [4258, 4258, 4283, 4296, 4670], [4672, 4672, 4697, 4710, 5063], [5065, 5065, 5084, 5084, 5177], [5179, 5198, 5274, 5274, 5321], [5323, 5323, 5355, 5355, 5375], [5377, 5377, 5411, 5411, 5433], [5472, 5495, 5552, 5552, 5719], [5784, 5784, 5808, 5808, 5968], [5970, 5970, 5994, 5994, 6079], [6081, 6110, 6138, 6138, 6308], [6310, 6332, 6378, 6378, 7001], [7051, 7051, 7092, 7092, 7128], [7130, 7130, 7216, 7216, 7251], [7253, 7253, 7296, 7296, 7336], [7338, 7338, 7392, 7392, 7513], [7515, 7515, 7539, 7539, 7587], [7589, 7589, 7629, 7629, 7933], [7935, 7935, 7959, 7959, 8023], [8025, 8025, 8078, 8078, 8435], [8438, 8438, 8490, 8490, 12113], [12116, 12116, 12173, 12173, 12868]], "test": "untested"}
{"id": "tt2yWW", "name": "Mario Head", "author": "PixelPhil", "description": "Itsa me! Mario!\nAfter the piranha plant, a procedurally animated PBR Mario head hommage to the Mario 64 loading screen.\nI hope this brings you joy. ", "tags": ["animation", "mario", "face", "head", "expression"], "likes": 47, "viewed": 1441, "published": 3, "date": "1595011805", "time_retrieved": "2024-07-30T20:55:06.741794", "image_code": "//\n// Mario Head by Philippe Desgranges\n// Email: Philippe.desgranges@gmail.com\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n#define MAX_DST 45.0\n#define MIN_DST 0.008\n#define S(a,b,c) smoothstep(a,b,c)\n#define sat(a) clamp(a,0.0,1.0)\n#define ZERO (min(iFrame,0))\n\n//Material regions\n#define SKIN\t\t \t0.0\n#define CAP   \t\t\t1.0\n#define CAP2   \t\t\t2.0\n#define HAIR\t\t\t3.0\n#define HAIR2\t\t\t4.0\n#define EYES\t\t\t5.0\n#define INSIDE_MOUTH \t6.0\n#define\tTEETH\t\t\t7.0\n\n        \n// All the parametters for an animation pose\nstruct KeyFrame\n{\n\tvec2 eyePos;\n    float eyelidsOpen;\n\tfloat eyeOpening;\n    float browBend;\n    float moustacheBend;\n    float mouthOpenVert;\n    float mouthOpenHoriz;\n    float bendX;\n    float twistX;\n    vec2 headRotation;\n};\n\n// Linear interpolation between two animation frames\nvoid mixKeyFrame(KeyFrame a, KeyFrame b, float ratio, out KeyFrame c)\n{\n    c.eyePos\t\t = mix(a.eyePos\t\t\t,b.eyePos\t\t  ,ratio);\n    c.eyelidsOpen\t = mix(a.eyelidsOpen\t,b.eyelidsOpen\t  ,ratio);\n\tc.eyeOpening\t = mix(a.eyeOpening\t\t,b.eyeOpening\t  ,ratio);\n    c.browBend\t\t = mix(a.browBend\t\t,b.browBend\t\t  ,ratio);\n    c.moustacheBend  = mix(a.moustacheBend  ,b.moustacheBend  ,ratio);\n    c.mouthOpenVert  = mix(a.mouthOpenVert  ,b.mouthOpenVert  ,ratio);\n    c.mouthOpenHoriz = mix(a.mouthOpenHoriz ,b.mouthOpenHoriz ,ratio);\n    c.bendX\t\t\t = mix(a.bendX\t\t\t,b.bendX\t\t  ,ratio);\n    c.twistX\t\t = mix(a.twistX\t\t\t,b.twistX\t\t  ,ratio);\n    c.headRotation\t = mix(a.headRotation\t,b.headRotation\t  ,ratio);\n}\n\n// all matrices and offsets that needs to be pre-computed\n// in order to keep the SDF relatively straightforward\nstruct MatSpace\n{\n    float twistLower;\n    float twistX;\n    float bendX;\n    float moustacheBend;\n    \n    vec3 eyeRad;\n    vec3 cheekPos;\n\tvec3 cheekRad;\n\tvec3 chinPos;\n\tvec3 noseRad;\n\n\tvec3 mouthPos;\n\tvec3 mouthRad;\n\n\tvec3 lipPos;\n\tfloat lipStretchX;\n\tfloat lipThickness;\n\n\tmat3 earMat;\n\tmat3 cap1Mat;\n\tmat3 cap2Mat;\n\n\tvec3 hairTip1;\n\tvec3 hairTip2;\n\n\tfloat browOffset;\n\tfloat browBend;\n\n\tvec3 teethPos;\n\n\tvec2 eyePos;\n    float eyelidsOpen;\n};\n\n// Attributes of a PBR material\nstruct PBRMat\n{\n    vec3 albedo;\n    float metalness;\n    float roughness;\n};\n\n// Ditance to the Letter M (cap + bg)\nfloat MDist(vec2 uvs)\n{\n    vec2 p = uvs;\n    p.x = abs(p.x);\n            \n\n    float v = p.y - 0.7 - p.x;\n    v = max(v, p.y - 2.6 + p.x * 1.8); \n    \n    \n    float v2 = p.y - 0.0 - p.x;\n    v2 = max(v2, p.y - 1.6 + p.x * 2.35); \n    \n    v = max(v, -v2);\n    \n    v = max(v, -p.y - 1.0 + p.x * 0.3);\n    return v;\n}\n    \n\n// Computes a PBR Material from material ID and world position\nvoid GetColor(float id, vec3 pos, MatSpace ps, out PBRMat mat, out vec3 normalBend)\n{   \n    normalBend = vec3(0);\n    \n    if (id == SKIN)\n    {\n        mat = PBRMat(vec3(1.0, 0.8, 0.8), 0.1, 0.3);\n    }\n    else if (id == CAP)\n    {\n        float mMask = 0.0;\n        \n        if (pos.z < 0.0)\n        {\n            vec2 p = pos.xy - vec2(0.0, 8.0);\n           \n            float v = MDist(p);\n            \n            mMask = length(p * vec2(1.0, 1.2));\n    \t\tmMask = S(2.3, 2.28, mMask);\n            mMask *= S(-0.03, 0.03, v);\n        }\n     \n        \n        mat = PBRMat(mix(vec3(0.8, 0.0, 0.0), vec3(1,1,1), mMask) , 0.05, 1.0);\n    }\n    else if (id == CAP2)\n    {\n        mat = PBRMat(vec3(0.8, 0.0, 0.0), 0.05, 1.0);\n    }\n    else if (id == HAIR)\n    {\n        mat = PBRMat(vec3(0.5, 0.25, 0.05), 0.1, 0.5);\n    }\n    else if (id == HAIR2)\n    {\n        mat = PBRMat(vec3(0.25, 0.15, 0.02), 0.3, 0.2);\n    }\n    else if (id == EYES)\n    {\n\n        \n        vec2 uvs = pos.xy;\n        \n        uvs.x -= 1.5 * sign(pos.x);\n        uvs -=  ps.eyePos; // eye position\n        \n  \t\tfloat iris = length(uvs * vec2(1, 0.7));\n        \n        vec3 blue = vec3(0.3, 0.8, 1.0);\n        vec3 blue2 = vec3(0.1, 0.2, 0.8);\n        \n        blue = mix(blue, blue2, S(0.1, 1.3, iris - uvs.y * 0.2));\n        \n        vec3 eyeCol = mix(blue, vec3(1, 1, 1), S(0.75, 0.8, iris));\n        \n        eyeCol *=  S(0.45, 0.5, iris);\n        eyeCol +=  S(0.3, 0.2, length(uvs - vec2(0, 0.3))) * 3.0;\n        \n        float lidDst = abs(pos.y - 2.6) - ps.eyelidsOpen;\n        \n        float lid = S(0.001, 0.01, lidDst);\n        \n        eyeCol = mix(eyeCol, vec3(1.0, 0.8, 0.8) * S(-0.2, 0.2, lidDst), lid);\n        \n        mat = PBRMat(eyeCol, 0.0, 0.5);\n    }\n    else if (id == INSIDE_MOUTH)\n    {\n        mat = PBRMat(vec3(0.75, 0.0, 0.1), 0.05, 1.0);\n    }\n    else \n    {\n        mat = PBRMat(vec3(1.0, 1.0, 1.0), 0.05, 1.0);\n    }\n    \n    return;\n}\n\n\n// Some pprocedural animation functions\n\nvoid HappyExpression(out KeyFrame res)\n{\n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 1.0 + opening * 0.2;\n    res.browBend = -opening * 0.2;\n    res.moustacheBend = -opening * 0.15;//sin(iTime * 2.0) * 0.3;\n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.mouthOpenVert =  0.01 - smile * 0.04;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = 0.01 + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -0.1 -opening * 0.2;//sin(iTime) * 0.3;\n    res.twistX = 0.0;//sin(iTime * 10.0) * 0.2;\n\n    \n    float eyelidsOpen = fract(iTime * 0.2) * 30.0;\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    float rotX = Noise1(iTime * 0.3, 14.0);\n    res.headRotation = vec2(rotX * 0.5, opening * 0.3);\n    \n    res.eyePos = vec2(opening * 0.5, 3.0);\n}\n\n\n\nvoid AngryExpression(out KeyFrame res)\n{\n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 0.6 + opening * 0.4;\n    res.browBend = -opening * 0.4 - 0.4;\n    \n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.moustacheBend = 0.2 -  smile * 0.2;//sin(iTime * 2.0) * 0.3;\n    \n    res.mouthOpenVert =  0.02 - smile * 0.04;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = -0.02;// + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = 0.2 + opening * 0.1;//sin(iTime) * 0.3;\n    \n\n    res.twistX = Noise1(iTime * 0.3, 487.0) * 0.5;\n\n    \n    float eyelidsOpen = min(fract(iTime * 0.2) * 30.0, 0.8 +  res.twistX);\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    float rotY = Noise1(iTime * 1.5, 14.0);\n    res.headRotation = vec2(-0.03, rotY * 0.3);\n    \n    res.eyePos = vec2(opening * 0.8, 3.2);\n}\n\nvoid LaughExpression(out KeyFrame res)\n{\n    float laugh = sin(iTime * 5.0) + sin(iTime * 16.34) * 0.5;\n    \n    float opening = Noise1(iTime, 444.0);\n    res.eyeOpening = 0.6 + opening * 0.4;\n    res.browBend = laugh * 0.3 + 0.1;\n    \n    float smile = Noise1(iTime * 1.56, 447.0);\n    \n    res.moustacheBend = -0.1 +  smile * 0.5;//sin(iTime * 2.0) * 0.3;\n    \n    res.mouthOpenVert =  0.03 + laugh * 0.02;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = - laugh * 0.02;// + smile * 0.08;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -laugh * 0.2 + 0.05;\n\n    res.twistX = 0.0;//Noise1(iTime * 0.3, 487.0) * 0.5;\n                        \n    res.eyelidsOpen = 0.0;\n    \n    res.headRotation = vec2(0.4 + laugh * 0.2, Noise1(iTime * 0.2, 444.0) * 1.2);\n    \n    res.eyePos = vec2(0.0, 4.0);\n}\n\n\nvoid AmazedExpression(out KeyFrame res)\n{\n    float hfNoise = Noise1(iTime * 4.0, 36.0);\n  \tfloat opening = Noise1(iTime * 0.7, 444.0);\n    res.eyeOpening = 1.3 + opening * 0.2;\n    res.browBend = -opening * 0.2 + 0.1;\n    res.moustacheBend = hfNoise * 0.05 - 0.05;//sin(iTime * 2.0) * 0.3;\n    \n    float smile = Noise1(iTime * 0.56, 447.0);\n    \n    res.mouthOpenVert =  0.04 - hfNoise * 0.01;//sin(iTime * 3.0) * 0.04;\n    res.mouthOpenHoriz = 0.0 + smile * 0.02;//-0.02;//sin(iTime) * 0.05;\n    res.bendX = -0.1;//sin(iTime) * 0.3;\n    res.twistX = -opening * 0.1;//sin(iTime * 10.0) * 0.2;\n\n    \n    float eyelidsOpen = fract(iTime * 0.3) * 30.0;\n                        \n    res.eyelidsOpen = eyelidsOpen;\n    \n    \n    \n    float rotX = Noise1(iTime * 0.3, 14.0);\n    res.headRotation = vec2(rotX * 0.5 + 0.15, opening * 0.3);\n    \n    res.eyePos = vec2(opening * 0.5 + hfNoise * 0.2, 3.8 );\n}\n\n// Chooses a random anim based on a [0 - 1] seed\n\nvoid ExpressionForSeed(out KeyFrame res, float seed)\n{\n    if (seed < 0.25)\n    {\n\t\tLaughExpression(res);\n    }\n    else if (seed < 0.75)\n    {\n       HappyExpression(res);\n    }\n    else// if (seed < 0.75)\n    {\n       AmazedExpression(res);\n    }\n    /*\n    else\n    {\n       AngryExpression(res);// Not sure I like this expression anymore\n    }*/\n}\n\n// Build all the matrices and offsets necessary to compute the SDF\n// leaving all that in would lead to bad perfs and longer compile times\nvoid buildMatSpace(KeyFrame frame, out MatSpace res)\n{\n    res.moustacheBend = frame.moustacheBend;\n    res.twistLower = -0.4 + frame.mouthOpenVert * 0.5;\n    res.twistX = frame.twistX;\n    res.bendX = frame.bendX;\n    res.moustacheBend = frame.moustacheBend;\n\n    res.eyeRad = vec3(0.21, 0.37 * frame.eyeOpening, 0.20) * 0.5;\n    res.cheekPos = vec3(0.2 + frame.mouthOpenHoriz * 0.5, -0.014 - frame.mouthOpenVert, -0.19);\n    res.cheekRad = vec3(0.51, 0.55 + frame.mouthOpenVert * 0.5, 0.57) * 0.5;\n    res.chinPos = vec3(0.0, -0.26 - frame.mouthOpenVert * 0.6, -0.22 - frame.mouthOpenVert * 1.0);\n    res.noseRad = vec3(0.42 + frame.mouthOpenHoriz, 0.39 - frame.mouthOpenHoriz * 0.5, 0.41) * 0.5;\n\n    res.mouthPos = vec3(0.0, -0.13 - frame.mouthOpenVert * 1.8, -0.41);\n    res.mouthRad = vec3(0.32, 0.16 + frame.mouthOpenVert, 0.31) * 0.5;\n\n    res.lipPos = vec3(0.0, -0.06 - frame.mouthOpenVert * 3.0, -0.36 - frame.mouthOpenVert * 1.5);\n    res.lipStretchX = 1.0f - frame.mouthOpenHoriz * 7.0;\n    res.lipThickness = 0.1 - frame.mouthOpenVert;\n\n    res.earMat = rotationX3(-65.0 * degToRad + frame.mouthOpenHoriz);\n    res.cap1Mat = rotationX3(30.0 * degToRad);\n    res.cap2Mat = rotationX3(60.0 * degToRad);\n\n    res.hairTip1 = vec3(0.45 - frame.mouthOpenVert * 0.6,0.06,-0.23);\n    res.hairTip2 = vec3(0.42 - frame.mouthOpenVert * 0.25,0.19,-0.28);\n\n    res.browOffset = (frame.eyeOpening - 1.0) * 0.15;\n    res.browBend = frame.browBend;\n\n    res.teethPos = vec3(0.0, -0.1 - frame.mouthOpenVert * 0.5, -0.2  - frame.mouthOpenVert);\n\n    res.eyePos = frame.eyePos;\n    res.eyelidsOpen = frame.eyelidsOpen;\n\n}\n\n\n// SDF of the scene\nvec2 SDF(vec3 pos, MatSpace ps)\n{   \n      \n    vec3 posUntwisted = pos * 0.1;\n    \n    //twist for th jaw\n    float twist = S(-0.1, ps.twistLower, posUntwisted.y) * ps.twistX;\n    \n    pos = rotationY3(twist) * posUntwisted;\n\n    pos.x = abs(pos.x); // face is symmetrical\n    posUntwisted.x = abs(posUntwisted.x);\n    \n    // bend for the face (happy / sad)\n    float bend = clamp(pos.x * pos.x * ps.bendX, -0.5, 0.5);\n    \n    pos.y += bend;\n    \n    // ellipsoids for the face\n    float head = sdEllipsoid(pos - vec3(0.0, 0.22, 0.03), vec3(0.96, 1.18, 0.99) * 0.5);\n    float cheek = sdEllipsoid(pos - ps.cheekPos, ps.cheekRad);\n    float chin = sdEllipsoid(pos - ps.chinPos, vec3(0.41, 0.34, 0.38) * 0.5);\n    \n    // Nose (tapered ellipsoid)\n    vec3 noseR = ps.noseRad;\n    noseR.x += clamp(pos.y * 0.125, -0.05, 0.05);\n    float nose = sdEllipsoid(pos - vec3(0.0, 0.13, -0.62), noseR);\n    \n    // holes for the eyes and mouth\n    float eye = sdEllipsoidPrecise(pos - vec3(0.14, 0.27, -0.39), ps.eyeRad);\n    \n    vec3 mouthPos = pos;\n    mouthPos.x *= ps.lipStretchX;\n    float innerMouth = sdEllipsoid(mouthPos - ps.mouthPos, ps.mouthRad);\n    \n    // lower lip is a torus\n    float lowerlip = sdTorus((mouthPos - ps.lipPos).xzy, vec2(0.15, ps.lipThickness));\n    \n   \t// ears too\n    float ear = sdTorus(ps.earMat * (pos - vec3(0.5, 0.13, 0.07)).yzx, vec2(0.16, 0.07));\n    \n    // smooth combine all that stuff\n    head = smin(head, chin, 0.06);\n    head = smin(head, lowerlip, 0.02);\n    head = smax(head, -innerMouth, 0.05);\n    head = smax(head, -eye, 0.05);\n    head = smin(head, cheek, 0.1);\n    head = smin(head, nose, 0.06);\n    head = smin(head, ear, 0.11);\n    \n    \n    // The cap is also a bunch of eelipsoids\n    vec3 cap1Pos = ps.cap1Mat * (pos - vec3(0, 0.8, -0.08));\n    float cap = sdEllipsoid(cap1Pos, vec3(1.04, 0.69, 0.77) * 0.5);\n    \n    vec3 cap2Pos = ps.cap1Mat * (pos - vec3(0, 0.46, 0.24));\n    cap = smin(cap, sdEllipsoid(cap2Pos, vec3(1.28, 0.66, 1.18) * 0.5), 0.27);\n    \n    vec3 cap3Pos = ps.cap2Mat * (pos - vec3(0.0, 0.89, 0.69));\n    cap = smax(cap, -sdEllipsoid(cap3Pos, vec3(1.95, 0.71, 1.01) * 0.5), 0.09);\n    \n    // the visor is the intersection of two capsules\n    vec3 vpos = pos;\n    vpos.x *= 0.9; // sligtly scaled\n    float visor = sdCapsule(vpos, vec3(0,0.25,0), vec3(0,0.15,-1.0), 0.5);\n    \n  \tfloat visorHollow =  -sdCapsule(vpos, vec3(0,0,0), vec3(0,0.2,-2.0), 0.56);\n                              \n    visor = smax(visor, visorHollow, 0.09);\n \tcap = max(cap, visorHollow);\n    \n    // side hair is two capsules\n    float hair = sdCapsule(pos, vec3(0.40,0.39,-0.11), ps.hairTip1, 0.07);\n    hair = smin(hair, sdCapsule(pos, vec3(0.39,0.37,-0.11), ps.hairTip2, 0.06), 0.03);\n    \n    // back hair is a bunch of allipsoids\n    float backHair = sdEllipsoid(pos - vec3(0.0, -0.02, 0.43), vec3(0.34, 0.41, 0.34) * 0.5);\n    backHair = smin(backHair, sdEllipsoid(pos - vec3(0.21, 0.02, 0.38), vec3(0.34, 0.41, 0.34) * 0.5), 0.04);\n    backHair = smin(backHair, sdEllipsoid(pos - vec3(0.37, 0.1, 0.29), vec3(0.29, 0.39, 0.29) * 0.5), 0.04);\n    \n    hair = min(hair, backHair);\n    \n    // the moustache is a torus cut with a cylinder distorted with a sine\n    vec3 mSpace = posUntwisted;\n    mSpace.y += posUntwisted.x * ps.moustacheBend;\n    \n    vec3 mPos = (mSpace - vec3(0.0, 0.8, -0.5)).xzy;\n    mPos.y *= 3.0;\n    \n    float mustache = sdTorus(mPos, vec2(0.9, 0.15));\n    \n    float mCut = length(mSpace.xy - vec2(0.08, 0.12)) - 0.26;\n    mCut -= abs(sin(mSpace.x * 25.0)) * 0.03;\n    \n    mustache = smax(mustache, mCut, 0.06);\n    \n\t// brows are made with an tapered ellipsoid cut with a cylinder\n    vec3 browPos = pos;\n    \n    browPos.y += (pos.x - 0.15) * ps.browBend;\n    float brow = sdEllipsoid(browPos - vec3(0.17, 0.42 + ps.browOffset, -0.44 + browPos.x * 0.3), vec3(0.3, 0.3, 0.1) * 0.5);\n    float browCut = length(browPos.xy - vec2(0.15, 0.33 + ps.browOffset)) - 0.17;\n    \n    brow = smax(brow, -browCut, 0.03);\n    \n    mustache = min(mustache, brow);\n    \n    // teeth are a cylinder compound\n    vec3 tPos = pos - ps.teethPos;\n    \n    float teeth = length(tPos.xz) - 0.25;\n    teeth = abs(teeth) - 0.02;\n    teeth = max(teeth, abs(tPos.y) - 0.06);\n    \n    float eyes = sdEllipsoid(pos - vec3(0.0, 0.25, -0.17), vec3(0.78, 0.74, 0.50) * 0.5);\n    \n\n    // Combine all parts together with materil ids\n    vec2 res = vec2(head, innerMouth < 0.0 ? INSIDE_MOUTH : SKIN);\n    res = combineMin(res, vec2(cap, CAP));\n    res = combineMin(res, vec2(visor, CAP2));\n\tres = combineMin(res, vec2(hair, HAIR));\n    res = combineMin(res, vec2(mustache, HAIR2));\n    res = combineMin(res, vec2(eyes, EYES));\n    res = combineMin(res, vec2(teeth, TEETH));\n\treturn res;\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( vec3 pos, MatSpace ps)\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    \n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e * SDF(pos+0.0005*e, ps).x;\n    }\n    return normalize(n);\n}\n\n// inspired by\n// https://iquilezles.org/articles/rmshadows\nfloat shadow(vec3 pos, vec3 lPos, MatSpace ps)\n{   \n    vec3 dir = lPos - pos;  // Light direction & disantce\n    \n    float len = length(dir);\n    dir /= len;\t\t\t\t// It's normalized now\n    \n    pos += dir * MIN_DST * 2.0;  // Get out of the surface\n    \n    float dst = SDF(pos, ps).x; // Get the SDF\n    \n    // Start casting the ray\n    float t = 0.0;\n    float obscurance = 1.0;\n    \n    while (t < len)\n    {\n        if (dst < MIN_DST) return 0.0; \n        obscurance = min(obscurance, (20.0 * dst / t)); \n        t += dst;\n        pos += dst * dir;\n        dst = SDF(pos, ps).x;\n    }\n    return obscurance;     \n}\n\nfloat shadow(vec3 p, vec3 n, vec3 lPos, MatSpace ps)\n{\n    return shadow(p + n * MIN_DST * 40.0, lPos, ps);\n}\n\n// Cast a ray across the SDF return x: Distance, y: Materila Id\nvec2 castRay(vec3 pos, vec3 dir, float maxDst, float minDst, MatSpace ps)\n{\n    vec2 dst = vec2(minDst * 2.0, 0.0);\n    \n    float t = 0.0;\n    \n    while (dst.x > minDst && t < maxDst)\n    {\n        dst = SDF(pos, ps);\n        t += dst.x;\n        pos += dst.x * dir;\n    }\n    \n    return vec2(t + dst.x, dst.y);\n}\n\n\n// A PBR-ish lighting model\nvec3 PBRLight(vec3 pos, vec3 normal, vec3 view, PBRMat mat, vec3 lightPos, vec3 lightColor, float fresnel, MatSpace ps, bool shadows)\n{\n    //Basic lambert shading stuff\n    \n    //return vec3(fresnel);\n    \n    vec3 key_Dir = lightPos - pos;\n    \n    float key_len = length(key_Dir);\n    \n\n    \n    key_Dir /= key_len;\n    \n\n    float key_lambert = max(0.0, dot(normal, key_Dir));\n    \n     \n    float key_shadow = shadows ? S(0.0, 0.10, shadow(pos, normal, lightPos, ps)) : 1.0; \n    \n    float diffuseRatio = key_lambert * key_shadow;\n   \n    \n    vec3 key_diffuse = vec3(diffuseRatio);\n    \n\n    // The more metalness the more present the Fresnel\n    float f = pow(fresnel + 0.5 * mat.metalness, mix(2.5, 0.5, mat.metalness));\n    \n    // metal specular color is albedo, it is white for dielectrics\n    vec3 specColor = mix(vec3(1.0), mat.albedo, mat.metalness);\n    \n    vec3 col = mat.albedo * key_diffuse * (1.0 - mat.metalness);\n    \n    // Reflection vector\n    vec3 refDir = reflect(view, normal);\n    \n    // Specular highlight (softer with roughness)\n    float key_spec = max(0.0, dot(key_Dir, refDir));\n    key_spec = pow(key_spec, 10.0 - 9.0 * mat.roughness) * key_shadow;\n    \n    float specRatio = mat.metalness * diffuseRatio;\n    \n    col += vec3(key_spec) * specColor * specRatio;\n    col *= lightColor;\n    \n\n    \n    return col;\n}\n\n// Some 3 octave 1D noise for animation\nfloat Noise13(float x, float seed)\n{\n    float res = Noise1(x, seed);\n    res += Noise1(x * 2.0, seed) * 0.5;\n    res += Noise1(x * 4.0, seed) * 0.25;\n    return res;\n}\n\n\nvec4 render(vec2 uvs)\n{\n    vec3 col;\n    \n\n        \n    if (dot(uvs, uvs) > 0.3) // Skip pretty much everything away from the head\n    {\n       \t//return vec4(1.0);\n    }\n    else\n    {\n        // arrival spin\n        float arrival = 1.0 - min(iTime * 0.5, 1.0);\n        arrival *= arrival;\n\n        \n        // build camera ray\n        vec3 camPos = vec3(0.0, 3.25, -42.0);\n        vec3 camDir = vec3(0.0, 0.0,  1.0);\n        vec3 rayDir = camDir + vec3(uvs * 0.45, 0.0);\n\n\t\t// mouse interaction\n        vec2 mouse = iMouse.xy/iResolution.xy;\n        if(mouse.x<.001) mouse = vec2(0.5, 0.5);\n\n        vec2 viewAngle = vec2((-mouse.x - 0.45) * pi2, (mouse.y - 0.5) * 0.8);\n\n        MatSpace matSpace;\n\n        // compute two animations\n        float slice = iTime * 0.2;\n        float id = floor(slice);\n        float progress = fract(slice);\n\n        KeyFrame kf1;\n        ExpressionForSeed(kf1, N2(vec2(id, 135.0)));\n\n        KeyFrame kf2;\n        ExpressionForSeed(kf2, N2(vec2(id + 1.0, 135.0)));\n\n\t\t// blend them together\n        KeyFrame kf;\n        mixKeyFrame(kf1, kf2, S(0.8, 1.0, progress), kf);\n\n        // compute the head rotation matrix\n        mat4 rotX = rotationX(kf.headRotation.x - arrival * 0.5);\n        mat4 rotY = rotationY(kf.headRotation.y  + arrival * (pi * 5.0));\n        mat4 rotZ = rotationZ(Noise1(iTime * 0.2, 345.0) * 0.2);\n        mat4 modelMat = rotY * rotX * rotZ;\n\n\n\t\t// then the viwe matrix\n        mat4 viewMat =  rotationY(viewAngle.x) * rotationX(viewAngle.y);\n        mat4 modelViewMat = modelMat * viewMat;\n\n\n\t\t// transform the ray in object space\n        camPos = (modelViewMat * vec4(camPos, 1.0)).xyz;\n        rayDir = (modelViewMat * vec4(rayDir, 0.0)).xyz;\n\n\n        // Build matrices & offsets\n        buildMatSpace(kf, matSpace);\n\n        \n\t\tvec2 d = castRay(camPos, rayDir, MAX_DST, MIN_DST, matSpace);\n        \n        if (d.x < MAX_DST)\n    \t{\n            // if it's a hit render the face\n            \n        \tvec3 pos = camPos + rayDir * d.x;\n \t\n        \tvec3 n;\n        \t\n        \tvec3 normalOffset = vec3(0);\n        \t\n            // compute the surface material\n        \tPBRMat mat;\n        \tGetColor(d.y, pos, matSpace, mat, normalOffset);\n        \t\n        \tmat.albedo *= mat.albedo; // Convert albedo to linear space\n        \t\n        \tn = normalize(calcNormal(pos, matSpace) + normalOffset);\n        \t\n            // Fake AO\n        \tfloat ao = SDF(pos + n * 0.7, matSpace).x;\n        \t\n\n        \tcol = mat.albedo * 0.2;\n        \t\n        \t// Fresnel\n        \tfloat fresnel = 1.0 - sat(dot(n, -rayDir));\n\t\n\t\n            // transform lights to object space\n        \tvec3 key_LightPos = (modelViewMat * vec4(12.0, 3.0, -30.0, 0.0)).xyz;        \n        \tvec3 fill_LightPos =  (modelViewMat * vec4(-15.0, -7.0, 10.0, 0.0)).xyz;\n            \n            // Add lighting\n        \tcol += PBRLight(pos, n, rayDir, mat, key_LightPos, vec3(1.2), fresnel, matSpace, true);\n        \tcol += PBRLight(pos, n, rayDir, mat, fill_LightPos, vec3(3.0), fresnel, matSpace, true);\n\t\n \t\t\tcol *= S(0.0, 0.1, ao) * 0.5 + 0.5; // blend AO to unflatten a bit\n        \t\n    \t\tcol = pow(col,vec3(0.4545)); // gamma correction\n    \t\treturn vec4(col, 0.0);\n    \t}\n    }\n    \n    // Background\n \n    vec2 screens = fract(uvs * vec2(2.2, 3.0) + vec2(0.0, 0.5)) - vec2(0.5, 0.5);\n\n    vec2 as = abs(screens);\n\n    float dark = S(0.7, 0.1, as.x) * S(0.7, 0.1, as.y);\n\n    vec3 deepBlue = vec3(0.2, 0.2, 0.8);\n    vec3 lightBlue = vec3(0.3, 0.4, 0.9);\n\n    float m = S(-0.1, 0.1, MDist(screens * vec2(6.0, 4.0) - vec2(0, -0.3)));\n\n    float scan = sin(uvs.y * 100.0 + iTime * 3.0) * 0.1;\n\n    float noiseFrame = floor(iTime * 20.0);\n    float noise = Noise2(uvs * 140.0 + vec2(noiseFrame * 14.3, noiseFrame * 4.3)) * 0.35;\n\n    col = mix(lightBlue, deepBlue, m + scan + noise)  * dark;\n  \n    return vec4(col, 0.0);\n}\n\n// Classic stuff\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec2 uv =(fragCoord - .5 * iResolution.xy) / iResolution.y;\n\n    vec3 res = render(uv).rgb;\n\n    // Output to screen\n    fragColor = vec4(res.rgb,1.0);\n}", "image_inputs": [{"id": 23366, "src": "https://soundcloud.com/user-147775334/itsa-me-mario-a-trap-creation-produced-by-dj-alexy", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define pi 3.14159265359\n#define pi2 (pi * 2.0)\n#define halfPi (pi * 0.5)\n#define degToRad (pi / 180.0)\n\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat3 rotationX3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3(1.0, 0,\t 0,\n\t\t\t \t0, \t c,\t-s,\n\t\t\t\t0, \t s,\t c);\n}\n\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat3 rotationY3( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat3( c, 0,\t s,\n\t\t\t \t 0,\t1.0, 0,\n\t\t\t\t-s,\t0,\t c);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n\n\n// https://iquilezles.org/articles/smin\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/smin\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdSphere(vec3 pos, vec3 center, float radius)\n{\n    return length(pos - center) - radius;\n}\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat dot2( vec2 v ) { return dot(v,v); }\n\n\nvec2 combineMin(vec2 a, vec2 b)\n{\n    return (a.x < b.x)? a : b;\n}\n\nvec2 combineMax(vec2 a, vec2 b)\n{\n    return (a.x > b.x)? a : b;\n}\n\n\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoidPrecise( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// https://iquilezles.org/articles/distfunctions\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k1 = length(p/r);\n    return (k1-1.0)*min(min(r.x,r.y),r.z);\n}\n\n\n// Some hash function 2->1\nfloat N2(vec2 p)\n{\t// Dave Hoskins - https://www.shadertoy.com/view/4djSRW\n    p = mod(p, vec2(1456.2346));\n\tvec3 p3  = fract(vec3(p.xyx) * vec3(443.897, 441.423, 437.195));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// A 2d Noise\nfloat Noise2(vec2 uv)\n{\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c01 = N2(corner + vec2(0.0, 1.0));\n\tfloat c11 = N2(corner + vec2(1.0, 1.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    vec2 diff = fract(uv);\n    \n    diff = diff * diff * (vec2(3) - vec2(2) * diff);\n    //diff = smoothstep(vec2(0), vec2(1), diff);\n    \n    return mix(mix(c00, c10, diff.x), mix(c01, c11, diff.x), diff.y);\n}\n\n// 1d Noise, y is seed\nfloat Noise1(float x, float seed)\n{\n    vec2 uv = vec2(x, seed);\n    vec2 corner = floor(uv);\n\tfloat c00 = N2(corner + vec2(0.0, 0.0));\n\tfloat c10 = N2(corner + vec2(1.0, 0.0));\n    \n    float diff = fract(uv.x);\n    \n    diff = diff * diff * (3.0 - 2.0 * diff);\n    \n    return mix(c00, c10, diff) - 0.5;\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yWW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[784, 837, 908, 908, 1535], [2211, 2249, 2272, 2272, 2567], [2574, 2637, 2722, 2722, 4582], [4626, 4626, 4666, 4666, 5430], [5434, 5434, 5474, 5474, 6286], [6288, 6288, 6328, 6328, 7083], [7086, 7086, 7127, 7127, 7986], [8038, 8038, 8092, 8092, 8389], [8391, 8530, 8584, 8584, 10145], [10148, 10168, 10201, 10201, 14903], [14906, 14952, 14993, 15091, 15306], [15308, 15368, 15416, 15416, 15988], [15990, 15990, 16044, 16044, 16099], [16101, 16165, 16240, 16240, 16480], [16483, 16511, 16646, 16713, 17862], [17864, 17904, 17940, 17940, 18072], [18075, 18075, 18098, 18098, 21920], [21922, 21939, 21996, 21996, 22155]], "test": "untested"}
{"id": "3tScRt", "name": "Mixing Paint", "author": "BackwardsCap", "description": "i use the same calculations for velocity/pressure as in my other shader https://www.shadertoy.com/view/wtjyzc\nexcept in this one i am using the velocity to simulate the movement of fluids\n\nPress space to view the velocity matrix\nClick to reset an area", "tags": ["fluid"], "likes": 7, "viewed": 369, "published": 3, "date": "1595007172", "time_retrieved": "2024-07-30T20:55:07.496776", "image_code": "//if its black, restart the simulation once buffer C's channel 1 has loaded it's texture\n\n//i use the same calculations for velocity/pressure as in my other shader https://www.shadertoy.com/view/wtjyzc\n//except in this one i am using the velocity matrix to simulate the movement of fluids\n\nvoid mainImage( out vec4 c, in vec2 f )\n{ \n    c = texelFetch( iChannel2, ivec2(32,0),0).x>0.?T1(f):T0(f);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), state, v, pr, d, n);\n    F(p, vec2(0,-1), state, v, pr, d, n);\n    F(p, vec2(1,0), state, v, pr, d, n);\n    F(p, vec2(-1,0), state, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;   \n    state.z = d;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define decay .999\n#define T0(U) texture(iChannel0, U/R)\n#define T1(U) texture(iChannel1, U/R)\n#define T2(U) texture(iChannel2, U/R)\n\n#define V(U) T0(mod(U,R))", "buffer_b_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), state, v, pr, d, n);\n    F(p, vec2(0,-1), state, v, pr, d, n);\n    F(p, vec2(1,0), state, v, pr, d, n);\n    F(p, vec2(-1,0), state, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;    \n    state.z = d;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(1,1), state, v, pr, d, n);\n    F(p, vec2(-1,-1), state, v, pr, d, n);\n    F(p, vec2(1,-1), state, v, pr, d, n);\n    F(p, vec2(-1,1), state, v, pr, d, n);\n    \n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;    \n    \n    state.z = d;\n    \n    if(iMouse.z>1. && length(p-iMouse.xy)-50.<1.)state.xy=T1(p).xy*.1;\n    \n\tif(iFrame<30)state.xy=T1(p).xy*.1;\n    \n    if(p.x<1. || p.y<1. || R.x-p.x<1. || R.y-p.y<1.) state.xy*=0.8;\n    \n}", "buffer_c_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 S0(vec2 U){return T0(U);}\nvec4 S1(vec2 U){return T1(U);}\n\nvoid mainImage(out vec4 state, vec2 f)\n{\n    for(int i=0;i<5;i++)\n    f -= S1(f).xy;\n \n    state = S0(f);\n    \n    if(iMouse.z>1. && length(f-iMouse.xy)-50.<1.)state=T2(f);\n\n    if(iFrame<30)state=T2(f);\n}", "buffer_d_inputs": [{"id": 10, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScRt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[290, 290, 331, 331, 398]], "test": "untested"}
{"id": "wtjyzc", "name": "Creeping Fluid", "author": "BackwardsCap", "description": "Fluids are weird", "tags": ["fluid"], "likes": 3, "viewed": 319, "published": 3, "date": "1595002917", "time_retrieved": "2024-07-30T20:55:08.303618", "image_code": "//if its black, restart the simulation once buffer C's channel 1 has loaded it's texture\n\nvoid mainImage( out vec4 c, in vec2 f)\n{\n    c = (T0(f).xzyw);\n    c+=dot(c.xy,c.xy);\n    c.b=pow(c.b+c.r,2.0);\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), state, v, pr, d, n);\n    F(p, vec2(0,-1), state, v, pr, d, n);\n    F(p, vec2(1,0), state, v, pr, d, n);\n    F(p, vec2(-1,0), state, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;   \n    state.z = d;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define decay .999\n#define T0(U) texture(iChannel0, U/R)\n#define T1(U) texture(iChannel1, U/R)\n\n#define V(U) T0(mod(U,R))", "buffer_b_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(0,1), state, v, pr, d, n);\n    F(p, vec2(0,-1), state, v, pr, d, n);\n    F(p, vec2(1,0), state, v, pr, d, n);\n    F(p, vec2(-1,0), state, v, pr, d, n);\n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;    \n    state.z = d;\n}", "buffer_b_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 S0(vec2 U){return T0(U);}\n\nvoid F(vec2 p, vec2 offset, vec4 state, inout vec2 v, inout float pr, inout float d, inout float n)\n{\n    vec4 target = S0(p+offset-V(p+offset).xy);\n    offset=normalize(offset);\n    v+=offset*(target.w-state.w);\n    pr+=target.w;\n    d+=dot(offset,target.xy);\n    n++;\n}\n\nvoid mainImage(out vec4 state, vec2 p)\n{\n    state = S0(p-V(p).xy);\n    vec2 v = vec2(0);\n    float d = 0., pr=0.,n=0.;\n    \n    F(p, vec2(1,1), state, v, pr, d, n);\n    F(p, vec2(-1,-1), state, v, pr, d, n);\n    F(p, vec2(1,-1), state, v, pr, d, n);\n    F(p, vec2(-1,1), state, v, pr, d, n);\n    \n    \n    d/=n;\n    pr/=n;\n    v/=n;\n    \n    state.w = pr-d;\n\tstate.xy -= v;    \n    \n    state.z = d;\n    \n\tif(length(state)==0.||length(iMouse.xy-p)<30.&&iMouse.z>0.)state.xy=T1(p).xy*.5;\n}", "buffer_c_inputs": [{"id": 7, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjyzc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[90, 90, 130, 130, 203]], "test": "untested"}
{"id": "wlscRH", "name": "Physically Based Rendering test", "author": "zduny", "description": "PBR based on lessons from: [url=https://learnopengl.com/PBR/Theory]Learn OpenGL[/url]\nHit \"Reset time\" button first (so pre-filtering can happen on loaded cube map texture instead of blank, black one).\nUse mouse to rotate.\nMay crash low-end GPUs.", "tags": ["raytracing", "pbr"], "likes": 6, "viewed": 633, "published": 3, "date": "1594999639", "time_retrieved": "2024-07-30T20:55:09.305939", "image_code": "const int samples = 3; // (square root, actual number = samples^2)\nconst float animationSpeed = 0.1;\nconst bool enablePointLights = true;\nconst bool enableToneMapping = true;\nconst bool showBRDFlookUpTable = false;\nconst float exposure = 1.0;\n\nstruct Material {\n  vec3 albedo;\n  float metallic;\n  float roughness;\n};\n\nstruct PointLight {\n  vec3 position;\n  vec3 color;\n};\n\nvec3 pbrPointLight(in Material material, in PointLight light, in vec3 position,\n                   in vec3 normal, in vec3 cameraPosition) {\n  vec3 toLight = light.position - position;\n\n  vec3 N = normalize(normal);\n  vec3 V = normalize(cameraPosition - position);\n  vec3 L = normalize(toLight);\n  vec3 H = normalize(V + L);\n\n  float distanceToLight = length(toLight);\n  float attenuation = 1.0 / (distanceToLight * distanceToLight);\n\n  vec3 radiance = light.color * attenuation;\n\n  float NDF = distributionGGX(N, H, material.roughness);\n  float G = geometrySmith(N, V, L, material.roughness);\n\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, material.albedo, material.metallic);\n  vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);\n\n  vec3 kS = F;\n  vec3 kD = vec3(1.0) - kS;\n  kD *= 1.0 - material.metallic;\n\n  vec3 numerator = NDF * G * F;\n  float denominator = 4.0 * max(dot(N, V), 0.0) * max(dot(N, L), 0.0) + 0.0001;\n  vec3 specular = numerator / max(denominator, 0.00001);\n\n  float NdotL = max(dot(N, L), 0.0);\n\n  return (kD * material.albedo / pi + specular) * radiance * NdotL;\n}\n\n// const float MAX_REFLECTION_LOD = 4.0;\n// #define getSpecular(R, roughness) textureLod(prefilterMap, R,  roughness *\n// MAX_REFLECTION_LOD).rgb;\n/* It's a poor approximation, but, for the purpose of this example, I had to\n   settle for this, since ShaderToy does not support multiple cube maps at the\n   moment, or, alternatively, it does not allow saving to different cubemap\n   mipmap levels, which is needed to prefilter environment map for different\n   roughness values and storing it efficiently. */\n#define getSpecular(R, roughness)                                              \\\n  mix(texture(iChannel0, R).rgb, texture(irradianceMap, R).rgb, roughness);\n\nvec3 pbrImageBased(in Material material, in samplerCube irradianceMap,\n                   in sampler2D brdfLUT, in vec3 position, in vec3 normal,\n                   in vec3 cameraPosition, in float ambientOcclusion) {\n  vec3 N = normalize(normal);\n  vec3 V = normalize(cameraPosition - position);\n  vec3 R = reflect(-V, N);\n\n  vec3 F0 = vec3(0.04);\n  F0 = mix(F0, material.albedo, material.metallic);\n  vec3 F = fresnelSchlickRoughness(max(dot(N, V), 0.0), F0, material.roughness);\n\n  vec3 kS = F;\n  vec3 kD = 1.0 - kS;\n  kD *= 1.0 - material.metallic;\n\n  vec3 irradiance = texture(irradianceMap, N).rgb;\n  vec3 diffuse = irradiance * material.albedo;\n\n  vec3 prefilteredColor = getSpecular(R, material.roughness);\n  vec2 brdf =\n      texture(brdfLUT, vec2(max(dot(N, V), 0.0), material.roughness)).rg;\n  vec3 specular = prefilteredColor * (F * brdf.x + brdf.y);\n\n  vec3 ambient = (kD * diffuse + specular) * (1.0 - ambientOcclusion);\n\n  return ambient;\n}\n\nvec3 trace(in Ray ray) {\n  int count = 7;\n  float stp = 1.5;\n  float offset = stp * float(count) / 2.0;\n\n  vec3 outPosition;\n  vec3 outNormal;\n  Material outMaterial;\n\n  /* I use a matrix stack to make my toys easily portable to \"normal\",\n   * rasterization based workflow. */\n  mat4 transform = rotationMatrix(up, iTime * 0.2 * animationSpeed) *\n                   rotationMatrix(right, iTime * 0.35 * animationSpeed);\n\n  float t = 10000.0;\n  for (int i = 0; i < count; i++) {\n    for (int j = 0; j < count; j++) {\n      float metallic = float(j) / float(count - 1);\n      float roughness = 1.0 - float(i) / float(count - 1);\n\n      float x = (float(i) + 0.5) * stp - offset;\n      float y = (float(j) + 0.5) * stp - offset;\n\n      Sphere sphere = Sphere((vec4(x, y, 0.0, 1.0) * transform).xyz, 0.5);\n      float t0, t1;\n      if (rayIntersectsSphere(ray, sphere, t0, t1) && t0 > 0.0 && t0 < t) {\n        t = t0;\n\n        outPosition = positionOnRay(ray, t);\n        outNormal = sphereNormal(sphere, outPosition);\n        outMaterial.albedo = vec3(1.0, 0.0, 0.0);\n        outMaterial.metallic = metallic;\n        outMaterial.roughness = roughness;\n      }\n    }\n  }\n\n  vec3 outputColor = vec3(0.0);\n  if (t < 10000.0) {\n    outputColor += pbrImageBased(outMaterial, iChannel1, iChannel2, outPosition,\n                                 outNormal, ray.origin, 0.0);\n\n    if (enablePointLights) {\n      PointLight light;\n      vec3 ambientLight = vec3(0.001);\n      light.position = vec3(-20.0, 20.0, 20.0);\n      light.color = vec3(6000.0);\n      outputColor +=\n          pbrPointLight(outMaterial, light, outPosition, outNormal, ray.origin);\n\n      light.position = vec3(20.0, 20.0, 30.0);\n      light.color = vec3(2000.0);\n      outputColor +=\n          pbrPointLight(outMaterial, light, outPosition, outNormal, ray.origin);\n\n      light.position = vec3(20.0, -20.0, 25.0);\n      light.color = vec3(1500.0);\n      outputColor +=\n          pbrPointLight(outMaterial, light, outPosition, outNormal, ray.origin);\n\n      light.position = vec3(-20.0, -20.0, 25.0);\n      light.color = vec3(1800.0);\n      outputColor +=\n          pbrPointLight(outMaterial, light, outPosition, outNormal, ray.origin);\n    }\n  } else {\n    outputColor = texture(iChannel0, ray.direction).rgb;\n  }\n\n  if (enableToneMapping) {\n    outputColor = vec3(1.0) - exp(-outputColor * exposure);\n  } else {\n    outputColor *= exposure;\n  }\n\n  return outputColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  const float fov = pi / 1.8;\n  float step = 1.0 / float(samples);\n\n  float normalizer = float(samples * samples);\n\n  vec2 mouse = (iMouse.xy / iResolution.xy - vec2(0.5)) * 5.0;\n  /* I use a matrix stack to make my toys easily portable to \"normal\",\n   * rasterization based workflow. */\n  mat4 transform = rotationMatrix(up, mouse.x * 1.3) *\n                   rotationMatrix(right, 2.5 + mouse.y * 1.3) *\n                   translationMatrix(vec3(0.0, 0.0, 12.0));\n\n  vec3 outColor = vec3(0.0);\n  float t0, t1;\n  for (int sx = 0; sx < samples; sx++) {\n    for (int sy = 0; sy < samples; sy++) {\n      Ray ray = createRayPerspective(\n          iResolution.xy, (fragCoord + vec2(float(sx), float(sy)) * step), fov);\n\n      transformRay(ray, transform);\n\n      outColor += trace(ray);\n    }\n  }\n\n  outColor /= normalizer;\n\n  fragColor = vec4(toSRGB(outColor), 1.0);\n\n  if (showBRDFlookUpTable) {\n    vec2 uv = fragCoord / iResolution.xy;\n    fragColor = vec4(texture(iChannel2, uv).rgb, 1.0);\n  }\n}\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float epsilon = 0.00001;\nconst float pi = 3.14159265359;\n\nconst vec3 right = vec3(1.0, 0.0, 0.0);\nconst vec3 up = vec3(0.0, 1.0, 0.0);\n\n// Color\nvec3 toSRGB(in vec3 color) { return pow(color, vec3(1.0 / 2.2)); }\n\n// Matrix\nmat4 rotationMatrix(in vec3 axis, in float angle) {\n  axis = normalize(axis);\n  float s = sin(angle);\n  float c = cos(angle);\n  float oc = 1.0 - c;\n\n  return mat4(\n      oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,\n      oc * axis.z * axis.x + axis.y * s, 0.0, oc * axis.x * axis.y + axis.z * s,\n      oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s, 0.0,\n      oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s,\n      oc * axis.z * axis.z + c, 0.0, 0.0, 0.0, 0.0, 1.0);\n}\n\nmat4 translationMatrix(in vec3 translation) {\n  return mat4(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0,\n              translation.x, translation.y, translation.z, 1.0);\n}\n\n// Ray\nstruct Ray {\n  vec3 origin;\n  vec3 direction;\n};\n\nRay rayFromTo(in vec3 from, in vec3 to) {\n  return Ray(from, normalize(to - from));\n}\n\nRay createRayPerspective(in vec2 resolution, in vec2 screenPosition,\n                         in float verticalFov) {\n  vec2 topLeft = vec2(-resolution.x, -resolution.y) * .5;\n  float z = (resolution.x * .5) / abs(tan(verticalFov / 2.0));\n\n  return Ray(vec3(0.0, 0.0, 0.0),\n             normalize(vec3(topLeft + screenPosition, -z)));\n}\n\nvec3 positionOnRay(in Ray ray, in float t) {\n  return ray.origin + ray.direction * t;\n}\n\nvoid transformRay(inout Ray ray, mat4 matrix) {\n  ray.origin = (matrix * vec4(ray.origin, 1.0)).xyz;\n  ray.direction = normalize(matrix * vec4(ray.direction, 0.0)).xyz;\n}\n\nvoid reflectRay(inout Ray ray, vec3 position, vec3 normal) {\n  ray.origin = position + normal * epsilon;\n  ray.direction = reflect(ray.direction, normal);\n}\n\n// Sphere\nstruct Sphere {\n  vec3 position;\n  float radius;\n};\n\nvec3 sphereNormal(in Sphere sphere, in vec3 position) {\n  return normalize(position - sphere.position);\n}\n\nbool rayIntersectsSphere(in Ray ray, in Sphere sphere, out float t0,\n                         out float t1) {\n  float a = dot(ray.direction, ray.direction);\n  vec3 s0_r0 = ray.origin - sphere.position;\n  float b = 2.0 * dot(ray.direction, s0_r0);\n  float c = dot(s0_r0, s0_r0) - (sphere.radius * sphere.radius);\n  float delta = b * b - 4.0 * a * c;\n  float a_2 = 2.0 * a;\n\n  if (delta < 0.0) {\n    return false;\n  }\n\n  float delta_sqrt = sqrt(delta);\n\n  t0 = (-b - delta_sqrt) / a_2;\n  t1 = (-b + delta_sqrt) / a_2;\n\n  return true;\n}\n\n// Physically based rendering\nvec3 fresnelSchlick(in float cosTheta, in vec3 F0) {\n  return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nvec3 fresnelSchlickRoughness(float cosTheta, vec3 F0, float roughness) {\n  return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\nfloat distributionGGX(in vec3 N, in vec3 H, in float roughness) {\n  float a = roughness * roughness;\n  float a2 = a * a;\n  float NdotH = max(dot(N, H), 0.0);\n  float NdotH2 = NdotH * NdotH;\n\n  float nom = a2;\n  float denom = (NdotH2 * (a2 - 1.0) + 1.0);\n  denom = pi * denom * denom;\n\n  return nom / max(denom, 0.001);\n}\n\nfloat geometrySchlickGGX(in float NdotV, in float roughness) {\n  float r = (roughness + 1.0);\n  float k = (r * r) / 8.0;\n\n  float nom = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n\nfloat geometrySmith(in vec3 N, in vec3 V, in vec3 L, in float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = geometrySchlickGGX(NdotV, roughness);\n  float ggx1 = geometrySchlickGGX(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}\n\nfloat geometrySchlickGGXforIBL(in float NdotV, in float roughness) {\n  float a = roughness;\n  float k = (a * a) / 2.0;\n\n  float nom = NdotV;\n  float denom = NdotV * (1.0 - k) + k;\n\n  return nom / denom;\n}\n\nfloat geometrySmithIBL(in vec3 N, in vec3 V, in vec3 L, in float roughness) {\n  float NdotV = max(dot(N, V), 0.0);\n  float NdotL = max(dot(N, L), 0.0);\n  float ggx2 = geometrySchlickGGXforIBL(NdotV, roughness);\n  float ggx1 = geometrySchlickGGXforIBL(NdotL, roughness);\n\n  return ggx1 * ggx2;\n}", "cube_a_code": "void mainCubemap(out vec4 fragColor, in vec2 fragCoord, in vec3 rayOri,\n                 in vec3 rayDir) {\n  if (iFrame > 0) {\n    fragColor = texture(iChannel1, rayDir);\n  } else {\n    vec3 N = rayDir;\n\n    vec3 irradiance = vec3(0.0);\n\n    // tangent space calculation from origin point\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 right = cross(up, N);\n    up = cross(N, right);\n\n    float hack = max(1.0 - float(iFrame), 0.0);\n\n    float sampleDelta = 0.05;\n    float nrSamples = 0.0f;\n    for (float phi = 0.0; phi < 2.0 * pi * hack; phi += sampleDelta) {\n      for (float theta = 0.0; theta < 0.5 * pi * hack; theta += sampleDelta) {\n        // spherical to cartesian (in tangent space)\n        vec3 tangentSample =\n            vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta));\n        // tangent space to world\n        vec3 sampleVec = tangentSample.x * right + tangentSample.y * up +\n                         tangentSample.z * N;\n\n        irradiance +=\n            texture(iChannel0, sampleVec).rgb * cos(theta) * sin(theta);\n        nrSamples++;\n      }\n    }\n\n    irradiance = pi * irradiance * (1.0 / float(nrSamples));\n\n    fragColor = vec4(irradiance, 1.0);\n  }\n}\n", "cube_a_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define STORAGE iChannel0\nconst ivec2 resolutionDataLocation = ivec2(1, 0);\n\nbool saveResolutionData(in ivec2 fragCoord, out vec4 fragColor) {\n  if (fragCoord == resolutionDataLocation) {\n    vec4 previousResolutionData = texelFetch(STORAGE, fragCoord, 0);\n    vec2 oldResolution = previousResolutionData.xy;\n    fragColor = vec4(iResolution.xy, oldResolution);\n      \n    return true;\n  }\n    \n  return false;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  ivec2 position = ivec2(fragCoord);\n  if (!saveResolutionData(position, fragColor)) {\n    fragColor = texelFetch(STORAGE, position, 0);\n  }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "float radicalInverseVdC(uint bits) {\n  bits = (bits << 16u) | (bits >> 16u);\n  bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);\n  bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);\n  bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);\n  bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);\n  return float(bits) * 2.3283064365386963e-10; // / 0x100000000\n}\n\nvec2 hammersley(uint i, uint N) {\n  return vec2(float(i) / float(N), radicalInverseVdC(i));\n}\n\nvec3 importanceSampleGGX(vec2 Xi, vec3 N, float roughness) {\n  float a = roughness * roughness;\n\n  float phi = 2.0 * pi * Xi.x;\n  float cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));\n  float sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\n  // from spherical coordinates to cartesian coordinates - halfway vector\n  vec3 H;\n  H.x = cos(phi) * sinTheta;\n  H.y = sin(phi) * sinTheta;\n  H.z = cosTheta;\n\n  // from tangent-space H vector to world-space sample vector\n  vec3 up = abs(N.z) < 0.999 ? vec3(0.0, 0.0, 1.0) : vec3(1.0, 0.0, 0.0);\n  vec3 tangent = normalize(cross(up, N));\n  vec3 bitangent = cross(N, tangent);\n\n  vec3 sampleVec = tangent * H.x + bitangent * H.y + N * H.z;\n  return normalize(sampleVec);\n}\n\nvec2 integrateBRDF(float NdotV, float roughness) {\n  vec3 V;\n  V.x = sqrt(1.0 - NdotV * NdotV);\n  V.y = 0.0;\n  V.z = NdotV;\n\n  float A = 0.0;\n  float B = 0.0;\n\n  vec3 N = vec3(0.0, 0.0, 1.0);\n\n  const uint SAMPLE_COUNT = 1024u;\n  for (uint i = 0u; i < SAMPLE_COUNT; ++i) {\n    // generates a sample vector that's biased towards the\n    // preferred alignment direction (importance sampling).\n    vec2 Xi = hammersley(i, SAMPLE_COUNT);\n    vec3 H = importanceSampleGGX(Xi, N, roughness);\n    vec3 L = normalize(2.0 * dot(V, H) * H - V);\n\n    float NdotL = max(L.z, 0.0);\n    float NdotH = max(H.z, 0.0);\n    float VdotH = max(dot(V, H), 0.0);\n\n    if (NdotL > 0.0) {\n      float G = geometrySmithIBL(N, V, L, roughness);\n      float G_Vis = (G * VdotH) / (NdotH * NdotV);\n      float Fc = pow(1.0 - VdotH, 5.0);\n\n      A += (1.0 - Fc) * G_Vis;\n      B += Fc * G_Vis;\n    }\n  }\n  A /= float(SAMPLE_COUNT);\n  B /= float(SAMPLE_COUNT);\n\n  return vec2(A, B);\n}\n\n#define STORAGE iChannel1\nconst ivec2 resolutionDataLocation = ivec2(1, 0);\nbool resolutionChanged() {\n  vec4 resolutionData = texelFetch(STORAGE, resolutionDataLocation, 0);\n  return resolutionData.xy != resolutionData.zw;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = fragCoord / iResolution.xy;\n\n  if (iFrame > 0 && !resolutionChanged()) {\n    fragColor = texture(iChannel0, uv);\n  } else {\n    vec2 integratedBRDF = integrateBRDF(uv.x, uv.y);\n    fragColor = vec4(integratedBRDF, 0.0, 1.0);\n  }\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlscRH.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[373, 373, 513, 513, 1451], [2118, 2118, 2335, 2335, 3073], [5507, 5507, 5562, 5562, 6560]], "test": "untested"}
{"id": "WtXcWs", "name": "Hyperbolic Honeycomb Sections", "author": "mla", "description": "Based on the ideas in Nelson and Segerman's \"Visualizing Hyperbolic Honeycombs\": [url]https://arxiv.org/abs/1511.02851[/url]. See also: [url]http://bulatov.org/math/180110/index.html[/url]\n\nSee code header for details & controls.", "tags": ["honeycomb", "hyperbolic", "horosphere"], "likes": 20, "viewed": 733, "published": 3, "date": "1594970077", "time_retrieved": "2024-07-30T20:55:10.109789", "image_code": "/////////////////////////////////////////////////////////////////////////////////\n//\n// Hyperbolic Honeycomb Sections, mla, 2020.\n//\n// Show a horospheric section through a hyperbolic honeycomb.\n//\n// Based on the ideas in Nelson and Segerman's \"Visualizing Hyperbolic\n// Honeycombs\": [url]https://arxiv.org/abs/1511.02851[/url]. See also:\n// [url]http://bulatov.org/math/180110/index.html[/url]\n//\n// Show a section through the halfspace model of hyperbolic space,\n// parallel to the boundary (so it's a horosphere). Reflect or invert\n// points of the section (after transforming to the ball model) in the\n// sides of a Goursat tetrahedron to form a honeycomb.\n//\n// Coloring just indicates the number of inversion/reflection steps\n// needed to reach the fundamental region. Keys 1-4 ('acontrol' in the\n// code) determine which mirrors count towards the total (so it's\n// roughly which mirrors are activated in the Dynkin diagram).\n//\n// Controls:\n// <mouse>,<up>,<down>: zoom and transform\n// <pageup>,<pagedown>: select tetrahedron type\n// <left>,<right>: select tetrahedron subtype\n// 1-4: active mirrors (see above)\n// 5-8: line selection\n// d: dark edges\n// x: show parameters\n// z: auto zoom\n//\n/////////////////////////////////////////////////////////////////////////////////\n\nint AA = 2;\nfloat scale = 2.2;\nfloat cycletime = 10.0;\n\nbvec4 acontrol = bvec4(1,0,0,0);\nbvec4 bcontrol = bvec4(1,0,0,0);\nbool uselocalscale = false;\n\nvec3 A,B,D; // Planes\nvec4 C;     // Inversion sphere\n\nvoid init(ivec3 PQR) {\n  //   A B C D\n  //   o-o-o-o\n  //    P Q R\n  // Construct the Goursat tetrahedron, faces A,B,C,D, with opposite\n  // vertexes a,b,c,d. Vertex c is at origin with adjacent faces A,B,D\n  // (Euclidean) planes. Face C opposite the origin is spherical with\n  // centre C.xyz, radius C.w. c can't be an ideal point (since it's\n  // the origin), but the other points can be.\n  // Uses x = 0 and z = 0 as planes, so can use a more efficient\n  // fold: p.xz -> abs(p.xz) if we like.\n  // icos(P) = cos(PI/P) etc. for integer P.\n  int P = PQR[0], Q = PQR[1], R = PQR[2];\n  A = vec3(0,0,1);\n  B = vec3(0,isin(P),-icos(P));\n  D = vec3(1,0,0);\n\n  // Construct sphere of inversion with correct dihedral angles.\n  // Plane face through origin, normal n, sphere centre c, radius r:\n  // cos(theta) = c.n/r (proof left to reader).\n  // centre is on z = 0 as must be orthogonal to A (the z-axis).\n  float r = 1.0/icos(R);\n  float k = r*icos(Q)/isin(P);\n  vec3 centre = vec3(1,k,0);\n\n  // And rescale to fit in the unit ball\n  C = vec4(centre,r)/sqrt(dot(centre,centre)-r*r);\n}\n\nbool tryreflect(inout vec3 p, vec3 n) {\n  float k = dot(p,n);\n  if (k >= 0.0) return false;\n  p -= 2.0*k*n;\n  return true;\n}\n\nbool tryreflect(inout vec3 p, vec4 c) {\n  // This reflection is an inversion\n  vec3 centre = c.xyz; float r = c.w;\n  vec3 p1 = p-centre;\n  float k = r*r/dot(p1,p1);\n  if (k < 1.0) return false;\n  p = k*p1;\n  p += centre;\n  return true;\n}\n\nfloat facedist(vec3 p, vec3 n) {\n  return abs(dot(p,n));\n}\n\nfloat facedist(vec3 p, vec4 c) {\n  vec3 centre = c.xyz; float r = c.w;\n  return abs(distance(p,centre)-r);\n}\n\nvec3 palette[] = vec3[](vec3(1,0,0),vec3(1,1,0),vec3(0,1,0),\n                        vec3(0,1,1),vec3(0,0,1),vec3(1,0,1));\n \nvec3 getcolor(int index) {\n  int ncolors = palette.length();\n  if (key(CHAR_M)) return vec3(float(index%ncolors)/float(ncolors-1)); // Monochrome\n  return mix(vec3(1),palette[index%ncolors],0.8);\n}\n\nvec3 pcolor(vec2 z, vec2 mouse) {\n  // Mouse transform\n  invert(z,mouse,1.0);\n  invert(z,vec2(0),1.0);\n\n  // To half plane: p.z is height above ideal boundary\n  float t = 1.0;\n  if (!key(CHAR_Z)) t = fract(iTime/cycletime);\n  vec3 p = vec3(z,exp(-10.0*t));\n  // Invert to the Poincare ball (Cayley transform)\n  invert(p,vec3(0,0,1),2.0);\n  invert(p,vec3(0),1.0);\n\n  int maxsteps = 50, numsteps;\n  for (numsteps = 0; numsteps < maxsteps; numsteps++) {\n    for (int i = 0; i < maxsteps; i++) {\n      // Apply subset of reflections completely first\n      if ((acontrol[0] || !tryreflect(p,A)) &&\n          (acontrol[1] || !tryreflect(p,B)) &&\n          (acontrol[2] || !tryreflect(p,C)) &&\n          (acontrol[3] || !tryreflect(p,D))) break;\n    }\n    // Then the remainder\n    if ((!acontrol[0] || !tryreflect(p,A)) &&\n        (!acontrol[1] || !tryreflect(p,B)) &&\n        (!acontrol[2] || !tryreflect(p,C)) &&\n        (!acontrol[3] || !tryreflect(p,D))) break;\n  }\n  if (numsteps == maxsteps) return vec3(0);\n  vec3 col = getcolor(numsteps);\n  float d = 1e8;\n  if (!bcontrol[0]) d = min(d,facedist(p,A));\n  if (!bcontrol[1]) d = min(d,facedist(p,B));\n  if (!bcontrol[2]) d = min(d,facedist(p,C));\n  if (!bcontrol[3]) d = min(d,facedist(p,D));\n  float localscale = 1.0-dot(p,p);\n  float lwidth = 0.01;\n  if (uselocalscale) lwidth *= localscale;\n  if (key(CHAR_D)) col = mix(vec3(0),col,smoothstep(0.0,2.0*lwidth,d));\n  else col = mix(col,vec3(0),0.4*smoothstep(0.5*lwidth,lwidth,d));\n  return col;\n}\n\nint pmin(int min, int a) {\n  if (a == 0) return a;\n  else return a+min-1;\n}\n\nconst int ntypes = 7;\nconst int nsubtypes = 5;\n// Select a tetrahedron. pmin ensures that an angle parameter is\n// either 0 (meaning infinity) or is >= some minimum value.\nivec3 getPQR(int type, int subtype) {\n  int P,Q,R;\n  int index = 0;\n  if (type == index++) P = 3, Q = 4, R = pmin(4,subtype);\n  else if (type == index++) P = 5, Q = 3, R = pmin(4,subtype);\n  else if (type == index++) P = 3, Q = 6, R = pmin(3,subtype);\n  else if (type == index++) P = 5, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 3+subtype, Q = 0, R = 0; // Infinities all round\n  else if (type == index++) P = 4, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 6, Q = 4, R = pmin(3,subtype);\n  else if (type == index++) P = 3, Q = 5, R = pmin(6,subtype);\n  return ivec3(P,Q,R);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord ) {\n  acontrol[0] = !key(CHAR_0+1);\n  acontrol[1] = key(CHAR_0+2);\n  acontrol[2] = key(CHAR_0+3);\n  acontrol[3] = key(CHAR_0+4);\n  bcontrol[0] = key(CHAR_0+5);\n  bcontrol[1] = key(CHAR_0+6);\n  bcontrol[2] = key(CHAR_0+7);\n  bcontrol[3] = key(CHAR_0+8);\n  float zoom = exp(0.1*float(keycount(KEY_DOWN)-keycount(KEY_UP)));\n  vec2 mouse = iMouse.x <= 0.0 ? vec2(0)\n    : vec2((2.0*iMouse.xy-iResolution.xy)/iResolution.y);\n  mouse *= scale;\n  int type = imod(keycount(KEY_PAGE_DOWN)-keycount(KEY_PAGE_UP),ntypes+1);\n  int subtype = imod(keycount(KEY_RIGHT)-keycount(KEY_LEFT),nsubtypes);\n  if (type != 0) {\n    type = type-1;\n  } else {\n    int t = int(iTime/cycletime);\n    type = t/nsubtypes%ntypes;\n    subtype = t%nsubtypes;\n  }\n  ivec3 PQR = getPQR(type,subtype);\n  init(PQR);\n  vec3 col = vec3(0);\n  for (int i = 0; i < AA; i++) {\n    for (int j = 0; j < AA; j++) {\n      vec2 z = vec2((2.0*(fragCoord+vec2(i,j)/float(AA))-iResolution.xy)/iResolution.y);\n      z *= scale*zoom;\n      col += pcolor(z,mouse);\n    }\n  }\n  col /= float(AA*AA);\n  if (key(CHAR_X)) {\n    vec2 z = fragCoord.xy;\n    // Show indication of parameters\n    int N = ntypes+1+nsubtypes+1+4;\n    vec2 xy = float(N)*z/iResolution.x;\n    xy.x -= 0.5;\n    float gridx = round(xy.x);\n    int i = int(gridx);\n    vec3 dotcol;\n    if (i == type ||\n        i == ntypes+1+subtype ||\n        i == ntypes+1+nsubtypes+1+0 && acontrol[0] ||\n        i == ntypes+1+nsubtypes+1+1 && acontrol[1] ||\n        i == ntypes+1+nsubtypes+1+2 && acontrol[2] ||\n        i == ntypes+1+nsubtypes+1+3 && acontrol[3]) {\n      dotcol = vec3(1);\n    } else if (i != ntypes && i != ntypes+1+nsubtypes) {\n      dotcol = vec3(0);\n    } else {\n      dotcol = col;\n    }\n    col = mix(dotcol,col,smoothstep(0.3,0.33,distance(xy, vec2(gridx,1.0))));\n  }\n  col = pow(col,vec3(0.4545));\n  if (alert) col.r = 1.0;\n  fragColor = vec4(col,1);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define keystate(k,n) ( texelFetch(iChannel3,ivec2(k,n),0) )\n\nvoid mainImage(out vec4 t, vec2 uv) {\n  int i = int(uv.x);\n  int j = int(uv.y);\n  if ( iFrame == 0) {\n    t = vec4(0);\n  } else {\n    t = texelFetch(iChannel2,ivec2(i,j),0); // Get current state   \n  }  \n  if (i == 0) {\n    float w1 = keystate(j,2).x;\n    if (w1 != t.w) {\n      t.w = w1;\n      t.x++;\n    }\n  }     \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n// common\n////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.141592654;\n\nbool alert = false;\nvoid assert(bool b) {\n  if (!b) alert = true;\n}\n\nint imod(int n, int m) {\n  // glsl % undefined for -ve arguments\n  if (n < 0) return m-1-(-n-1)%m;\n  else return n%m;\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat COS[] =\n  // Don't trust cos on the GPU to be accurate enough: cos(PI/n) for n = 0..31\n  // Note that we have COS[0] = 1 = cos(PI/infinity)\n  float[](1.0,-1.0,0.0,0.5,0.7071067812,0.8090169944,0.8660254038,\n          0.9009688679,0.9238795325,0.9396926208,0.9510565163,0.9594929736,\n          0.9659258263,0.9709418174,0.9749279122,0.9781476007,0.9807852804,\n          0.9829730997,0.984807753,0.9863613034,0.9876883406,0.9888308262,\n          0.9898214419,0.990685946,0.9914448614,0.9921147013,0.9927088741,\n          0.9932383577,0.9937122099,0.9941379572,0.9945218954,0.9948693234);\n\nfloat icos(int p) {\n  if (p >= COS.length()) return cos(PI/float(p));\n  return COS[p];\n}\n                        \nfloat isin(int p) {\n  if (p >= COS.length()) return sin(PI/float(p));\n  return sqrt(1.0-COS[p]*COS[p]); // Let's hope sqrt(0) = 0\n\n}\n\nvoid invert(inout vec2 z, vec2 centre, float r2) {\n  z -= centre; z *= r2/dot(z,z); z += centre;\n}\n\nvoid invert(inout vec3 z, vec3 centre, float r2) {\n  z -= centre; z *= r2/dot(z,z); z += centre;\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtXcWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1491, 1491, 1513, 2034, 2574], [2576, 2576, 2615, 2615, 2700], [2702, 2702, 2741, 2778, 2939], [2941, 2941, 2973, 2973, 2999], [3001, 3001, 3033, 3033, 3109], [3236, 3236, 3262, 3262, 3433], [3435, 3435, 3468, 3489, 4932], [4934, 4934, 4960, 4960, 5009], [5058, 5183, 5220, 5220, 5792], [5794, 5794, 5847, 5847, 7719]], "test": "untested"}
{"id": "3tjcz3", "name": "Overswirl", "author": "wyatt", "description": "I think this is actually conserving subpixel angular momentum physically - but I could be wrong - I did add a fudge factor to overdo it a little because everyone wants it be unrealistically swirly ", "tags": ["swirl", "fluid"], "likes": 18, "viewed": 501, "published": 3, "date": "1594960357", "time_retrieved": "2024-07-30T20:55:10.884717", "image_code": "Main {\n\tNeighborhoodA;\n\tNeighborhoodB;\n    \n    float height = a_mi.x;\n    \n    vec3 normal = normalize(vec3(b_e.x-b_w.x,b_n.x-b_s.x,1));\n\t\n    Q = abs(.2+a_mi.w*vec4(.4,.5,1,1)-a_mi.z*vec4(.2,.6,.7,1));\n    Q *= 0.8+0.2*texture(iChannel2,normal);\n}", "image_inputs": [{"id": 26, "src": "/media/a/94284d43be78f00eb6b298e6d78656a1b34e2b91b34940d02f1ca8b22310e8a0.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PARAM1 .5\n\n// Tout ca va etre pareil pour tout les shaders\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n\n#define NeighborhoodA vec4 a_mi = A(U+vec2(0,0)),  a_n  = A(U+vec2(0,1)),  a_e  = A(U+vec2(1,0)),  a_s  = A(U-vec2(0,1)),     a_w  = A(U-vec2(1,0)),    a_ne = A(U+vec2(1,1)),      a_se = A(U+vec2(1,-1)),    a_sw = A(U+vec2(-1,-1)),  a_nw = A(U+vec2(-1,1)),    a_ave = 0.125*(a_n+a_e+a_s+a_w+a_ne+a_se+a_sw+a_nw);\n#define NeighborhoodB vec4 b_mi = B(U+vec2(0,0)),  b_n  = B(U+vec2(0,1)),  b_e  = B(U+vec2(1,0)),  b_s  = B(U-vec2(0,1)),     b_w  = B(U-vec2(1,0)),    b_ne = B(U+vec2(1,1)),      b_se = B(U+vec2(1,-1)),    b_sw = B(U+vec2(-1,-1)),  b_nw = B(U+vec2(-1,1)),    b_ave = 0.125*(b_n+b_e+b_s+b_w+b_ne+b_se+b_sw+b_nw);\n\n#define Main void mainImage (out vec4 Q, in vec2 U)", "buffer_a_code": "Main {\n    \n    NeighborhoodA;\n    NeighborhoodB;\n\t\n    a_mi.xy -= 0.25*vec2(b_e.x-b_w.x,b_n.x-b_s.x);\n    a_mi.xy -= 0.25*abs(b_mi.y)*vec2(b_n.y-b_s.y,-b_e.y+b_w.y);\n    a_mi -= 0.25*(\n        a_n.y*a_n-a_s.y*a_s+\n        a_e.x*a_e-a_w.x*a_w\n                   );\n    a_mi.y -= .1/R.y*(1.-a_mi.w);\n    // Input \n    if (iMouse.z>0.&&length(iMouse.xy-U)<10.) {\n        a_mi.y = .8;\n        a_mi.z = 1.;\n    }else if (length (U-vec2(.1,.9)*R) < 10.) {\n    \ta_mi.w = 0.;\n        a_mi.xy = .2*vec2(sin(.1*iTime),-cos(.1*iTime));\n    }\n    \n    // Init\n    if (iFrame < 1) {\n    \ta_mi = vec4(0,1,1,-1)*exp(-.1*length(U-0.5*R));\n        a_mi.w = 1.;\n    }\n    \n    // Out\n    Q = a_mi;\n    if (U.x<1.||R.x-U.x<1.||R.y-U.y<1.) Q.xy *= 0.;\n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    \n    NeighborhoodA;\n    NeighborhoodB;\n    \n    b_mi.x -= 0.25*(a_n.y+a_e.x-a_s.y-a_w.x);\n    b_mi.y = b_ave.y*.92+0.1*(a_n.x-a_e.y-a_s.x+a_w.y);\n    b_mi -= 0.25*(\n        a_n.y*b_n-a_s.y*b_s+\n        a_e.x*b_e-a_w.x*b_w\n                   )*vec4(0,1,1,1);\n    \n    Q = b_mi;\n    if (U.x<5.||U.y<5.||R.x-U.x<5.||R.y-U.y<5.) Q.y *= 0.;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U-A(U).xy);\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = B(U-A(U).xy);\n\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "3tjyR3", "name": "Tunnel of Thorns", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3t2czK]\"caves of steel\"[/url] fractal.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion", "cave"], "likes": 4, "viewed": 301, "published": 3, "date": "1594945554", "time_retrieved": "2024-07-30T20:55:11.642691", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 6\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float\n    MIN_DIST = 0.0,\n\tMAX_DIST = 100.0,\n\tEPSILON = 0.01,\n\tsize = 1000.0,\n\tscale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat vines(vec3 p,float size1){\n    p /= length(p)*2.0;\n    float s1 = 1.0;\n    return size-length((sin(p.yzx/s1)/s1+1.0+sin(p/vec3(length((p/50.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n\n    p /= scale*60.0; \n    //p = (2.0+cos(p/50.0))*100.0;\n    float size1 = 800.0,\n    result = vines(p,size1),\n    i = 15.0;\n    for(int j = 0; j < iterations; j++){\n        p = (sin(p.yzx/i+i)*i-sin(p)/i);\n        result = min(result,result-vines(p,size1)/(i));\n    }\n    return result*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N),\n    dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a,\n    light1Pos = eye,\n    light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye),\n    s = normalize(cross(f, up)),\n    u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    float t1 = (30.2+sin(iTime/2.0))*24.0;\n    vec3 eye = vec3(30.0+iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir,\n    K_a = surface_color(p),\n    K_d = K_a,\n    K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyR3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[558, 558, 590, 590, 724], [727, 727, 751, 751, 1052], [1054, 1054, 1082, 1082, 1159], [1161, 1582, 1673, 1673, 2044], [2059, 2313, 2378, 2378, 2510], [2512, 2601, 2630, 2630, 2940], [2942, 3434, 3574, 3574, 4163], [4165, 4535, 4620, 4620, 4952], [4954, 5281, 5330, 5365, 5486], [5488, 5488, 5545, 5545, 6560]], "test": "untested"}
{"id": "ttSczc", "name": "volumetric curl noise", "author": "macbooktall", "description": "quick sketch / not proper volumetric (doesn't check when exited etc). use mouse x to control curl freq", "tags": ["refraction", "curlnoise"], "likes": 19, "viewed": 955, "published": 3, "date": "1594943275", "time_retrieved": "2024-07-30T20:55:12.492419", "image_code": "#define minDist 0.001\n#define maxDist 5.\n#define surfaceRefraction 0.9\n#define curlStepRefraction 0.9\n\n#define curlFreq 1.\n\n\nuniform vec4 bgColor;\nin vec2 uv;\n\nvec2 mouse;\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nvoid transformSpace(inout vec3 pos) {\n\tpR(pos.xz, -iTime*0.5);\n\tpR(pos.xy, sin(iTime*0.5)*0.5);    \n}\n\nfloat map(in vec3 pos) {\n\ttransformSpace(pos);\n\n    float dist = sdBox(pos, vec3(0.25));\n    return dist;\n}\n\nvec3 curl(vec3 pos) {\n    vec3 eps = vec3(1., 0., 0.);\n    vec3 res = vec3(0.);\n\n    float yxy1 = snoise(pos + eps.yxy);\n    float yxy2 = snoise(pos - eps.yxy);\n    float a = (yxy1 - yxy2) / (2. * eps.x);\n\n    float yyx1 = snoise(pos + eps.yyx);\n    float yyx2 = snoise(pos - eps.yyx);\n    float b = (yyx1 - yyx2) / (2. * eps.x);\n\n    res.x = a - b;\n\n    a = (yyx1 - yyx2) / (2. * eps.x);\n\n    float xyy1 = snoise(pos + eps.xyy);\n    float xyy2 = snoise(pos - eps.xyy);\n    b = (xyy1 - xyy2) / (2. * eps.x);\n\n    res.y = a - b;\n\n    a = (xyy1 - xyy2) / (2. * eps.x);\n    b = (yxy1 - yxy2) / (2. * eps.x);\n\n    res.z = a - b;\n\n    return res;\n}\n\nfloat march(in vec3 camPos, in vec3 rayDir) {\n\n    float dist = minDist;\n\n    for (int i = 0; i < 25; i++) {\n        vec3 p = camPos + rayDir * dist;\n        float res = map(p);\n        if (res <= minDist) break;\n        dist += res;\n        if (dist >= maxDist) break;\n    }\n\n    return dist;\n}\n\nvec3 volumeMarch(in vec3 pos, in vec3 rayDir) {\n\n\ttransformSpace(pos);\n\n    const int numSteps = 10;\n    float dist = minDist;\n    float stepSize = 0.05;\n    \n\tvec3 col = vec3(0.);\n    float freq = 4. + (mouse.x-0.5) * curlFreq;\n    \n    for (int i = 0; i < numSteps; i++) {\n        vec3 p = pos + rayDir * dist;\n        float res = map(p);\n\t    dist += stepSize;\n        \n        // the curl noise function animated wrt the current color and time\n\t\tvec3 c = curl(p*freq + sin(col+iTime)*0.1);\n        \n        // refract the ray dir with the current noise sample\n\t\trayDir = refract(rayDir, c, curlStepRefraction);\n        \n        // accumulate the color\n\t\tcol += c;\n    }\n    return col;\n}\n\nvec3 calcNormal(in vec3 pos) {\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(map(pos + eps) - map(pos - eps),\n                     map(pos + eps.yxz) - map(pos - eps.yxz),\n                     map(pos + eps.yzx) - map(pos - eps.yzx)));\n}\n\nvec4 render(in vec3 camPos, in vec3 rayDir) {\n\n    float dist = march(camPos, rayDir);\n    vec3 fPos = camPos + rayDir * dist;\n    vec3 nor = calcNormal(fPos);\n\trayDir = refract(rayDir, nor, surfaceRefraction);\n\tvec3 col = volumeMarch(fPos, rayDir) * (-.25-dot(rayDir, nor));\n\n\tcol = pow(col, vec3(1.25));\n\tcol = mix(col, bgColor.rgb, clamp(dist/maxDist, 0.0, 1.0));\n    return vec4(col, dist);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tmouse = iMouse.xy / iResolution.xy;\n    vec4 color = vec4(0.);\n    vec2 uv_c = uv * 2. - 1. ;\n    uv_c.x *= iResolution.x/iResolution.y;\n    vec3 ray = normalize (vec3(1., 0., 0.) * uv_c.x +\n                          vec3(0., 1., 0.) * uv_c.y +\n                          vec3(0., 0., 1.) * 2.5);\n\n    vec3 camPos = vec3(0., 0., -1.);\n    \n    color += vec4(render(camPos, ray));\n\n    fragColor = color;\n}\n", "image_inputs": [], "common_code": "//\tSimplex 3D Noise\n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSczc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 205, 205, 247], [249, 249, 280, 280, 367], [369, 369, 406, 406, 470], [472, 472, 496, 496, 579], [581, 581, 602, 602, 1224], [1226, 1226, 1271, 1271, 1521], [1523, 1523, 1570, 1570, 2214], [2216, 2216, 2246, 2246, 2471], [2473, 2473, 2518, 2518, 2869], [2871, 2871, 2928, 2928, 3374]], "test": "untested"}
{"id": "tlScz3", "name": "Recursively orbiting moons", "author": "jarble", "description": "A moon orbits a moon, which orbits another moon of a moon of a planet.\nThe orbital periods aren't quite accurate: they should be calculated using Kepler's third law.", "tags": ["3d", "raymarching", "planet", "orbit"], "likes": 2, "viewed": 313, "published": 3, "date": "1594934229", "time_retrieved": "2024-07-30T20:55:13.340152", "image_code": "//this is based on https://www.shadertoy.com/view/ttByRD\n//the renderer is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float planet_size = 1000.0;\nconst float size = 10.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat craters(vec3 p,float i){\n    float scale1 = 32.0;\n    p -= (i+sin(p.yzx/scale1))*scale1;\n    p /= planet_size;\n    p *= i;\n\treturn length(sin(i*p*length(sin(p))))*scale1*sqrt(scale1)/i;\n}\n\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat planet(vec3 p) {\n    return (sphere(p,planet_size))*scale/10.0;\n}\n\nfloat sceneSDF(vec3 p){\n    p /= scale;\n    float result = planet(p);\n    float scale = 1.0;\n    for(int i = 0; i < 4; i++){\n        scale *= 1.07;\n        //p = -p.yzx;\n        float t1 = iTime*scale*3.0;\n        p += scale*(p+5000.0*vec3(sin(t1),cos(t1),0));\n\n\t\tresult = min(result,planet(p));\n    }\n    return result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(1.0,.5,.3+sin(p+sin(p.yzx))/5.0)/1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 2.0;\n    vec3 eye = scale*(18.5+sin(iTime/speed)*.7)*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScz3.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 379, 409, 409, 572], [575, 575, 609, 609, 640], [642, 642, 664, 664, 713], [715, 715, 738, 738, 1037], [1039, 1039, 1067, 1067, 1123], [1125, 1546, 1637, 1637, 1943], [1958, 2212, 2277, 2277, 2409], [2411, 2500, 2529, 2529, 2839], [2841, 3333, 3473, 3473, 4083], [4085, 4455, 4540, 4540, 5312], [5314, 5641, 5690, 5725, 5856], [5858, 5858, 5915, 5915, 6898]], "test": "untested"}
{"id": "3tscDS", "name": "2D Fluid Movement", "author": "BackwardsCap", "description": "Dipping my toes in fluid simulation.\nPress space to view velocity and pressure\n\nThis is a deconstruction of a deconstruction by spalmer of a shader by wyatt\nspalmer: https://www.shadertoy.com/view/wtlcWr\nwyatt: https://www.shadertoy.com/view/ws2fDc", "tags": ["fluid"], "likes": 22, "viewed": 1153, "published": 3, "date": "1594930002", "time_retrieved": "2024-07-30T20:55:14.094136", "image_code": "// Buffers A B and C make up our fluid feedback loop\n// Buffer D mimics colors leaking through the fluid using the velocity and pressure data calculated in our fluid simulation\n\nvoid mainImage(out vec4 c,vec2 f) {c=texelFetch( iChannel2, ivec2(32,0),0).x>0.?.25+T1(f).xywz:T0(f);}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//deconstructing a deconstruction by spalmer of a shader by wyatt\n//https://www.shadertoy.com/view/wtlcWr\n//https://www.shadertoy.com/view/ws2fDc\n\n//access to ires in common buffer\n#define R iResolution.xy\n\n#define decay .999\n\n//easily access the textures\n#define T0(U) texture(iChannel0, U/R)\n#define T1(U) texture(iChannel1, U/R)\n\n#define Sampler0 vec4 S0(vec2 U) { return T0(U); }\n#define Sampler1 vec4 S1(vec2 U) { return T1(U); }\n\n//wrap the space (useful when sampling)\n#define A(U) T0(mod(U,R))\n\n\n//define jet movement, velocity and positions\n#define Jet0Pos(U) vec2(i*-2.0,-.4+abs(i)*2.0)\n\n#define Jet1Pos(U) vec2(sin(U)/1.5,cos(U)/1.5)\n\n#define Jet0Fwd (vec2(-2.5*i,.5-abs(i)))\n#define Jet1Fwd vec2(0,-.25)\n\n#define isJet0 length(uv-Jet0Pos(0.)) < .01\n\n#define isJet1 length(uv-Jet1Pos(0.)) < .025\n\n#define jetFor for(float i=-.20;i<.25;i+=.1)", "buffer_a_code": "//defines a sampler function that returns a value from the texture easily\nSampler0\n\nvoid Fluid(vec2 coordinates, vec2 offset, vec4 values, inout vec2 velocity, inout float pressure, inout float divergence, inout float neighbors)\n{\n    // Sample buffer C, which samples B, which samples A, making our feedback loop\n    vec4 s = S0(coordinates+offset);\n    offset = normalize(offset);\n    \n    // gradient of pressure from the neighboring cell to ours\n    float sampledPressure = s.w;\n    float currentPressure = values.w;\n    \n    //add the velocity scaled by the pressure that its exerting\n    velocity += offset*(sampledPressure-currentPressure);\n    \n    // add pressure\n    pressure += sampledPressure;\n    \n    // divergence of velocity\n    divergence += dot(offset,s.xy);\n    \n    //increase number of neighbors sampled\n    neighbors++;\n}\n\nvoid mainImage(out vec4 values, vec2 coordinates)\n{    \n    //sample from the previous state\n    values = S0(coordinates-A(coordinates).xy);\n    \n    vec2 velocity = vec2(0);\n    float divergence = 0.;\n    float pressure = 0., neighbors = 0.;\n\n    Fluid(coordinates, vec2(0, 1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(0,-1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2( 1,0), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(-1,0), values, velocity, pressure, divergence, neighbors);\n\n    //average the samples\n    velocity /= neighbors;\n    divergence /= neighbors;\n    pressure /= neighbors;\n\n    //output pressure in w, velocity in xy\n    values.w = pressure - divergence;\n    values.xy -= velocity;\n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Sampler0\n    \nvoid Fluid(vec2 coordinates, vec2 offset, vec4 values, inout vec2 velocity, inout float pressure, inout float divergence, inout float neighbors)\n{\n    // Sample buffer\n    vec4 s = S0(coordinates+offset-A(coordinates+offset).xy);\n    offset = normalize(offset);\n    \n    // gradient of pressure from the neighboring cell to ours\n    float sampledPressure = s.w;\n    float currentPressure = values.w;\n    \n    //add the velocity scaled by the pressure that its exerting\n    velocity += offset*(sampledPressure-currentPressure);\n    \n    // add pressure\n    pressure += sampledPressure;\n    \n    // divergence of velocity\n    divergence += dot(offset,s.xy);\n    \n    //increase number of neighbors sampled\n    neighbors++;\n}\n\nvoid mainImage(out vec4 values, vec2 coordinates)\n{    \n    //sample from the previous state\n    values = S0(coordinates-A(coordinates).xy);\n    \n    vec2 velocity = vec2(0);\n    float divergence = 0.;\n    float pressure = 0., neighbors = 0.;\n\n    Fluid(coordinates, vec2(0, 1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(0,-1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2( 1,0), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(-1,0), values, velocity, pressure, divergence, neighbors);\n\n    //average the samples\n    velocity /= neighbors;\n    divergence /= neighbors;\n    pressure /= neighbors;\n\n    //output pressure in w, velocity in xy\n    values.w = pressure - divergence;\n    values.xy -= velocity;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Sampler0\n\nvoid Fluid(vec2 coordinates, vec2 offset, vec4 values, inout vec2 velocity, inout float pressure, inout float divergence, inout float neighbors)\n{\n    // Sample buffer\n    vec4 s = S0(coordinates+offset-A(coordinates+offset).xy);\n    offset = normalize(offset);\n    \n    // gradient of pressure from the neighboring cell to ours\n    float sampledPressure = s.w;\n    float currentPressure = values.w;\n    \n    //add the velocity scaled by the pressure that its exerting\n    velocity += offset*(sampledPressure-currentPressure);\n    \n    // add pressure\n    pressure += sampledPressure;\n    \n    // divergence of velocity\n    divergence += dot(offset,s.xy);\n    \n    //increase number of neighbors sampled\n    neighbors++;\n}\n\nvoid mainImage(out vec4 values, vec2 coordinates)\n{\n    \n\tvec2 uv = (2.*coordinates-R)/iResolution.y;;\n    \n    //sample from the previous state\n    values = S0(coordinates-A(coordinates).xy);\n    \n    vec2 velocity = vec2(0);\n    float divergence = 0.;\n    float pressure = 0., neighbors = 0.;\n\n    Fluid(coordinates, vec2(0, 1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(0,-1), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2( 1,0), values, velocity, pressure, divergence, neighbors);\n    Fluid(coordinates, vec2(-1,0), values, velocity, pressure, divergence, neighbors);\n\n    //average the samples\n    velocity /= neighbors;\n    divergence /= neighbors;\n    pressure /= neighbors;\n\n    //output pressure in w, velocity in xy\n    values.w = pressure - divergence;\n    values.xy -= velocity;\n    \n    //set the velocity of certain areas to positive    \n    jetFor\n    if (isJet0)  {\n        values.xy = Jet0Fwd;\n    }\n    \n    if (isJet1) {\n        values.xy = Jet1Fwd*2.0;\n    }\n    \n    values*=decay;\n\n    if (coordinates.x<1.||coordinates.y<1.||R.x-coordinates.x<1.||R.y-coordinates.y<1.) values.xy *= 0.;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Sampler0\nSampler1\n    \nvoid mainImage(out vec4 values, vec2 coord)\n{\n\tvec2 p = (coord), uv = (2.*coord-R)/R.y;\n    \n    //p is the coordinate we are currently on\n\t//move the opposite direction of it's velocity\n    //sample the pixel at that position, meaning it moves towards us by our velocity\n    //the more we do it the faster our fluid will spread\n    //mimicing viscosity or something\n    \n    for(int i=0;i<4;i++)\n    p -= S1(p).xy;\n \n    values = S0(p);\n\n\tjetFor\n    if (isJet0) {\n    \tvalues = .5+.5*sin(.1*iTime+vec4(4,3,2,1))*sin(i*2.0)*vec4(4,2,3,4);\n    }\n    \n    \n    if (isJet1) {\n    \tvalues = .5+.5*sin(iTime*.5+vec4(2.,3,1,1));\n    }\n    \n    values*=decay;\n}\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tscDS.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 213, 213, 280]], "test": "untested"}
{"id": "3tBcRc", "name": "Lissajous curve", "author": "VechirkoIgor", "description": "Lissajous curve", "tags": ["lissajouscurve"], "likes": 0, "viewed": 258, "published": 3, "date": "1594917059", "time_retrieved": "2024-07-30T20:55:14.844131", "image_code": "\nfloat roundRadius = 0.06f * 800.0f;\n\nvec2 getRoundPos()\n{\n    vec2 pos = vec2( sin(iTime), cos(iTime/2.0f) );\n    \n    pos = pos / 2.0f;\n    pos = pos + vec2( 0.5f );\n    \n    return pos;\n}\n\nvec4 getBackgroundColor()\n{\n    return vec4( 0.3f, 0.3f, 0.3f, 1.0f );\n}\nvec4 getRoundColor()\n{\n    return vec4( 0.0f, 1.0f, 0.0f, 1.0f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float distToRoundCenter = length(getRoundPos()*iResolution.xy - fragCoord);\n    \n    vec2 uv = fragCoord / iResolution.xy;\n    if ( uv.x > 0.499f && uv.x < 0.501f )\n    {\n        fragColor = vec4( 1.0f, 0.0f, 0.0f, 1.0f );\n    }\n    else if ( uv.y > 0.498f && uv.y < 0.502f )\n    {\n        fragColor = vec4( 1.0f, 0.0f, 0.0f, 1.0f );\n    }\n    else if ( distToRoundCenter > roundRadius )\n    {\n         fragColor = getBackgroundColor();\n    }\n    else\n    {\n        fragColor = getRoundColor();\n    }\n   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcRc.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 38, 58, 58, 190], [192, 192, 219, 219, 264], [265, 265, 287, 287, 332], [334, 334, 391, 391, 902]], "test": "untested"}
{"id": "tl2czV", "name": "Energy transfer look", "author": "Leria", "description": "Working on energy transfer look with no animation (static) but you can enable ANIM to 1 (line2) to see how it looks-like with time animation, however it's not realist\nYou can redefine energy rate  to see how the look behaves\nYou can rotate the \"object\"", "tags": ["raymarch", "velocity", "energy", "transfer"], "likes": 9, "viewed": 522, "published": 3, "date": "1594892565", "time_retrieved": "2024-07-30T20:55:15.779630", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n//anim 0 or 1\n#define ANIM\t\t\t\t0\n\n//energy rate\n#define \tEPSILON_R\t\t1.\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t4.\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n    \n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n#define DISPERSION_VELOCITY\t7.\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t0\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n#define STRETCH\t\t \t\t1\n\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* (clamp( noise(p)/.122 +.5 ,0.,1.)) )\n#define Psnoise(p) ( 2.*( exp( snoise(p)) ) )\n\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n    f = Psnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p ); p = p*s;\n    f *=  Psnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n\n// Sphere intersection\nfloat intersect_sphere( Ray r, vec3 sphere, float rad )\n{\n\tvec3 oc = r.origin - sphere;\n\tfloat b = dot( oc, r.dir );\n\tfloat c = dot( oc, oc ) - rad*rad;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return -1.0;\n\treturn -b - sqrt( h );\n}\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nfloat sdf_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 7.), m.pos); \n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    int fbm_weight = 0;\n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n   \n    float t_gen = 1.;\n\n    float param_t = intersect_sphere(r, m.pos, RADIUS);\n    if(param_t <= -1.)\n        return;\n    vec3 p = ray_interpolation(r, k*jit);        \n     \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    int s = 0;\n    \n    for(s; s < 100; s++)\n    {               \n        vec3 dU = vec3(0.);\n\n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n\n            float rad_bubl = RADIUS/4.;\n            vec3 pB = vec3(0,0,rad_bubl);//RADIUS/2.);\n            float r_p = length(p-pB)/2.*RADIUS;\n            float d = 1. +6.*( length(p-pB) / (RADIUS/2.) -1.);\n            \n\t\t\tvec3 dp = vec3(0.);\n            dp += d*(p-pB); \n            \n            float anim = 0.;\n            #if ANIM\n            anim = iTime/2.;\n            #endif\n            \n            float dispersion_rate = 1./Psnoise(p-anim); //non-uniform dispersion rate\n\n            float velocity = 1.60*(DISPERSION_VELOCITY*dispersion_rate); //modify it to tune the average velocity, 1.60 is precalculated value\n            //velocity\n            #define VT\tvelocity\n            //energy\n            float energy = .5*(VT*VT*VT)/rad_bubl; //energy transfer rate\n#define SQR(x) ( (x)*(x) ) \n            float l = exp(-.5*SQR(d/2.));\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            n = .1*( fbm( (p-pB+dp)/1.*l) + EPSILON_R*energy  )*(max(0.,d)*l);\n\n\n            float mask = smoothstep(0.,\n                                    4.*RADIUS,\n                                    (RADIUS-length(center)));// * .06*n ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                               \t  0.,\n                                  1.) *n );\n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 1.* dens, \n                      \tk * 1.* dens,\n              \t      \tk * 1.* dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius) || \n           (t_acc.x+t_acc.y+t_acc.z < 0.001 && t_acc.x+t_acc.y+t_acc.z > 40. ))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    //fragColor = .5*vec4(Psnoise(vec3(uv, 1.)*20.))+.5; return;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n/*\n    float t = dot(sphere.center - ray.origin, ray.direction);\n    float y = distance(sphere.center, ray.origin + ray.direction * t);\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2czV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 1032, 1054, 1054, 1227], [1897, 1897, 1954, 1954, 2123], [2125, 2148, 2170, 2423, 3340], [3342, 3342, 3368, 3368, 4193], [4296, 4296, 4321, 4334, 4708], [4710, 4710, 4735, 4748, 5101], [5103, 5103, 5122, 5122, 5215], [5217, 5236, 5312, 5312, 5359], [5361, 5361, 5393, 5393, 5413], [5415, 5415, 5449, 5449, 5471], [5510, 5533, 5590, 5590, 5757], [5822, 5822, 5846, 5846, 6006], [6008, 6008, 6032, 6032, 6117], [6119, 6148, 6176, 6176, 6346], [6348, 6370, 6416, 6416, 7039], [7089, 7089, 7130, 7130, 7166], [7168, 7168, 7254, 7254, 7289], [7291, 7291, 7334, 7334, 7374], [7376, 7376, 7430, 7430, 7551], [7553, 7553, 7577, 7577, 7625], [7627, 7627, 7667, 7667, 7971], [7973, 7973, 7997, 7997, 8060], [8062, 8062, 8115, 8115, 8472], [8475, 8475, 8527, 8527, 12012], [12015, 12015, 12072, 12072, 12767]], "test": "untested"}
{"id": "tdBfzd", "name": "z0rg x Aastal DnB", "author": "z0rg", "description": "Think to reset time to be sure that the song and the video both start at 0s you know shadertoy's soundcloud sync issue.", "tags": ["neuro", "dnb", "vidjing", "boomboom"], "likes": 6, "viewed": 314, "published": 3, "date": "1594891796", "time_retrieved": "2024-07-30T20:55:16.533614", "image_code": "// z0rg x Aastal DnB by Sebastien Maire is licensed under CC BY-SA 4.0. \n// To view a copy of this license, visit https://creativecommons.org/licenses/by-sa/4.0\n//\n// A thing I was preparing since long for a DJ friend, as we both share\n// the passion for DnB music.\n//\n// The code is crappy as hell :p, you know it started as a simple thing\n// and then just throwing more code at it and I didn't take much time\n// to organize it, I'm open to suggestions on this aspect though.\n//\n// Checkout the video recorded version !\n// https://www.youtube.com/watch?v=GOfZamGVUe4\n//\n// Btw I hope you'll like it as much as I liked doing it.\n\n// The define is to load the iChannel2 in which I put my friend's\n// logo using the chrome extension to load local images\n//#define LOGO\n\nconst float PI = 3.14159265;\nmat2 r2d(float a){float sa = sin(a);float ca=cos(a);return mat2(ca,sa,-sa,ca);}\nfloat rand(vec2 co){ return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453); }\n\nvec3 logo(vec2 uv)\n{\n#ifdef LOGO\n    uv *= r2d(sin(iTime+uv.y*5.)*.1);\n    return texture(iChannel2, clamp(uv+vec2(.5+.01*texture(iChannel0, vec2((abs(uv.y)*5.),0.)).x,.5), vec2(0.), vec2(1.))).www*pow(sat((iTime/5.)), 10.);\n#else\n    return vec3(0.);\n#endif\n}\n\nfloat time;\nfloat grad(float t, float tStart, float tEnd)\n{\n    if (t > tEnd || t < tStart)\n        return 0.;\n    float delta = tEnd-tStart;\n    return clamp(t-tStart, 0., delta) / delta;\n}\nfloat getKeyState(int keycode)\n{\n    return texelFetch( iChannel1, ivec2(keycode,0),0 ).x;\n}\n\nfloat getKeyPress(int keycode)\n{\n    return texelFetch( iChannel1, ivec2(keycode,1),0 ).x;\n}\n\nfloat getKeyToggle(int keycode)\n{\n    return texelFetch( iChannel1, ivec2(keycode,2),0 ).x;\n}\n\n\nvec3 sat(vec3 v)\n{\n  return vec3(sat(v.x),sat(v.y), sat(v.z));\n}\nfloat _sub(float a, float b)\n{\n  return max(a,-b);\n}\nfloat _union(float a, float b)\n{\n  return min(a, b);\n}\n\nfloat _sqr(vec2 uv, vec2 sz)\n{\n  vec2 r = abs(uv)-sz;\n  return max(r.x,r.y);\n}\n\nvec2 repeat(vec2 uv, vec2 rep)\n{\n    return mod(uv+0.5*rep,rep)-0.5*rep;\n}\n\nvec3 repeat(vec3 uv, vec3 rep)\n{\n    return mod(uv+0.5*rep,rep)-0.5*rep;\n}\n\nfloat _trees(vec2 uv, float sz, float rep)\n{\n    uv = repeat(uv, vec2(rep+0.05*sin(uv.y*2.+1.5), 5.));\n    return _sqr(uv, vec2(sz, 2.));\n}\n\nfloat _cyl(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3  ba = b - a;\n    vec3  pa = p - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    \n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    \n    float cyl = sign(d)*sqrt(abs(d))/baba;\n    return mix(cyl, length(p)-1., sin(iTime*.2)*.5+.5);\n}\n\nvec3 lookAt(vec3 dir, vec2 uv)\n{\n  dir = normalize(dir);\n  vec3 right = -normalize(cross(dir, vec3(0., 1., 0.)));\n  vec3 up = normalize(cross(dir, right));\nvec2 fov = vec2(2./**sin(iTime*5.)*/);\n  return dir+right*uv.x*fov.x+up*uv.y*fov.y;\n}\nfloat rng(float a, float mi, float ma)\n{\n    return float(a > mi && a < ma);\n}\n\nvec3 texCross(vec2 uv)\n{\n    uv += .5*vec2(sin(time), cos(time));\n    uv *= r2d(time);\n    uv *= 3.;\n    uv = repeat(uv, vec2(1.));\n    float coef = mix(_union(_sqr(uv, vec2(.01, .2)), _sqr(uv, vec2(.01, .2).yx)), lenny(uv)-.5, sin(iTime*.03+10.9)*.2+.2);\n    return (1.-sat(coef*200.))*vec3(.34,.43,.56+.3*sin(iTime*.3)); \n    return vec3(0.);\n}\n\nfloat map(vec3 p)\n{\n    \n    p.xy *= r2d(time);\n    vec3 rep = mix(vec3(2.), vec3(5.*sin(iTime),2.,.5), sat((iTime-220.)/1.));\n    p = repeat(p, rep);\n    //p.yz *= r2d(time);\n    float len = 5.;\n    float rad = .5;\n    float a = _cyl(p, vec3(0.,-len, 0.), vec3(0.,len, 0.), rad);\n    float b = _cyl(p, vec3(-len, 0., 0.), vec3(len, 0., 0.), rad);\n    float c = _cyl(p, vec3(0.,0.,-len), vec3(0.,0.,len), rad);\n    return _union(a, _union(b, c));\n}\n\nvec3 rdr3D(vec2 uv)\n{\n    vec3 lookAtPos = vec3(0.);\n    float moveZ = float(iTime > 134.5)*(abs(sin(iTime))*5.);\n    vec3 orig = vec3(sin(time), cos(time), -2.5+moveZ);\n    vec3 dir = lookAt(lookAtPos - orig, uv); \n    vec3 p = orig + dir;\n    float dist = 0.;\n    for (int i = 0; i < 256; ++i)\n    {\n        float d = map(p);\n        if (d < 0.001)\n        {\n            return vec3(.5)*sat(dist);\n        }\n        dist += d;\n        p += dir * d*0.999;\n    }\n    return vec3(0.);\n}\nfloat sub(float a, float b)\n{\n  return max(a,-b);\n}\n\n\n\nfloat cir(vec2 p, float r)\n{\n  float a = atan(p.y,p.x)+r*sin(2.*r+iTime*.1);\n    float spd = (sin(iTime*.1)*.5+.5);\n  return (length(p)-r)-sin(a*7.-iTime*spd)*.15\n  +sin(a*3.-iTime*5.*spd)*.2\n  +sin(a*5.+sin(a))*.02;\n}\n\nfloat border(vec2 p, float th, float r)\n{\n  return sub(cir(p,r),cir(p,r-th));\n}\nvec3 rdrCirLines(vec2 uv)\n{\n  vec3 col;\n  int i = 0;\n    float sharp = 5.0;\n  while (i<32)\n  {\n    float fi = float(i);\n      col += vec3(sat(pow(abs(uv.y),4.))*2.,.8,sat(abs(uv.x)+.5))*(1.-sat(border(uv,0.0005, .2+.02*fi)*sharp));\n    col += .005*vec3(sat(pow(abs(uv.y),4.))*2.,.8,sat(abs(uv.x)+.5)).yxx*(1.-sat(border(uv*.5*vec2(-1.,1.)*(sin(iTime*.2)*.5+1.),0.0005, .1+.02*fi)*40.));\n    \n      ++i;\n  }\n\n  return col*.15*sat(length(uv));\n}\n\n\nvec3 rdrScn(vec2 uv, float speed,float timeBump)\n{\n  time = iTime;//*speed+timeBump;\n  if (iTime > 110.)\n     time = iTime*speed+timeBump;\n  if (mod(iTime, 2.) < 1. && iTime > 45.0)\n      time = -time;\n    if (iTime < 45.0)\n        time *= .5;\n  uv*= 3.2+smoothstep(0., .439, mod(time,.4389))*.1; //vertical\n  uv *= r2d(PI/12.);\n  vec3 land;\n  float lightFlicker = sumfx(onoff(iTime, 0.0f, 5.0f), onoff(iTime, 57.0f, 200.0f));\n  vec3 light = lightFlicker*(.5+.3*round(asin(sin(iTime*PI*2.0*4.0*2.)))*vec3(100.,200.,197.)/255.);\n  land = mix(vec3(.1,.1,.2),light,sat(.0+sat(1.-length(uv))));\n    \n  float trees = _trees(uv+vec2(time, 0.).yx, 0.05+sin(time+uv.x)*.1, 0.3);\n  \n  //land += .2*vec3(.5,.7,.74)*(sat(trees*20.));\nland += light*sat(1.-lenny(uv*.5))*(sin(time+uv.x+PI)*.5+.5);\n    vec3 blackStripsCol = texCross(uv)*(1.-sat(trees*250.));\n  return land+rdr3D(uv)*(sat(.8+sat(trees*50.)))+blackStripsCol*.5;\n}\n\nvec3 rdrtunnel(vec2 uv)\n{\n  vec3 col;\n  float t = iTime*.1+uv.x*2.*sin(iTime)+uv.y*4.*sin(iTime);\n  float tt = iTime;//*(1.+.05*sin(iTime*.2));\n  float blur = 2.*mix(0.01,0.001,sin(iTime*.2)*.5+.5);\n  float l = pow(length(uv),.1)*1.;\n  uv += vec2(sin(t+l),cos(t+l))*.2*pow(length(uv),.5);\n  col = texture(iChannel3, vec2(0.1*atan(uv.y, uv.x)/PI, .05*tt+blur/length(uv))).xyz;\nvec3 col2 = texture(iChannel3, -vec2(.2*atan(uv.y, uv.x)/PI, .05*tt+.001/length(uv))).xyz;\n\n  return vec3(.9,.12,.38)*col2*.8+.1*col*pow(length(uv),.5)*vec3(.5,.3,.7)*max(dot(uv, vec2(1.)),.5)\n  + 3.5*pow(1.-sat(lenny(uv*.5)),5.)*vec3(.32,.45,.65);\n}\n\n\nvec3 compositing(vec2 uv)\n{\n\tvec2 tst = rdrCirLines(uv*2.0).xy;\n    float visiBlue = 1.0f;//*(1.0-sat(iTime/1.));\n    visiBlue = sumfx(visiBlue, \n                     sumfx(onoff(iTime, 56.5,57.), onoff(iTime, 53.,53.5)));\n    tst *= visiBlue*.01;\n  \tvec3 col = rdrScn(uv*mix(1.,5.,sat((sin(iTime)*.2+.2)*(iTime-200.)/50.))+tst, .2, .05*round(asin(sin(iTime*PI*2.0))));\n    col = mix(col, (col+(rdrCirLines(uv*mix(1.,2., sin(iTime*.25)*sat((iTime-230.)/20.)))))*.5+col, visiBlue*.8);\n    col = mix(col, (vec3(.8)+col)*rdrtunnel(uv).yxz, sat((iTime-220.)/2.)*sat(mod(iTime, 5.)/5.+.2));\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n\n\tif (iTime > 134.2)\n    {\n        float tst = max(sin((iTime-3.)*PI*.4), 0.);\n        if (tst > .5)\n       \t uv *= (abs(sin(iTime*PI*8.))*.2+.5)*(1.+sin(iTime)*.5+.5);\n    }\n  vec3 col = compositing(uv);\n    col = pow(col, vec3(1.)/mix(1., 10.*length(uv), pow(grad(iTime, 120., 133.), .5)));\n \tcol *= pow(min(iTime, 5.)/5., 5.)\n        +abs(sin(iTime*PI))*float(iTime > .5 && iTime < 2.);\n    \n    vec3 colpost = vec3(sat(float(mod(uv.y+rand(uv)*0.0002+time, 0.01) < 0.005)*(1.-length(uv))))*col;\n    col = mix(col, colpost, float(iTime<120.)*((sin(iTime*PI)+sin(iTime*PI*3.2))*.5+.5));\n    col = mix(col, 1.-col.yzx, logo(uv*vec2(1.,2.)*1.).x);\n    fragColor = vec4(mix(col, col.zxy, sat(col.y+abs(uv.y*5.))*.8*sat((iTime-220.)/1.)), 1.0);\n\tfragColor *= 1.-sat((iTime-418.)/.5);\n}\n", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 22951, "src": "https://soundcloud.com/aastal/shortmix-2-neuro", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "const int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_SPACE  = 32;\nconst int KEY_NUM0  = 48;\nconst int KEY_NUM1  = 49;\nconst int KEY_NUM2  = 50;\nconst int KEY_NUM3  = 51;\nconst int KEY_NUM4  = 52;\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\n\nfloat lenny(vec3 v)\n{\n  return abs(v.x)+abs(v.y)+abs(v.z);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\nfloat sumfx(float curve, float val)\n{\n    return sat(curve+val);\n}\n\nfloat onoff(float t, float start, float end)\n{\n    return float(t > start && t < end);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdBfzd.jpg", "access": "api", "license": "cc-by-sa-4.0", "functions": [[797, 797, 815, 815, 876], [877, 877, 897, 897, 965], [967, 967, 987, 987, 1227], [1241, 1241, 1288, 1288, 1419], [1420, 1420, 1452, 1452, 1512], [1514, 1514, 1546, 1546, 1606], [1608, 1608, 1641, 1641, 1701], [1704, 1704, 1722, 1722, 1768], [1769, 1769, 1799, 1799, 1821], [1822, 1822, 1854, 1854, 1876], [1878, 1878, 1908, 1908, 1956], [1958, 1958, 1990, 1990, 2032], [2034, 2034, 2066, 2066, 2108], [2110, 2110, 2154, 2154, 2249], [2251, 2251, 2296, 2296, 2723], [2725, 2725, 2757, 2757, 2966], [2967, 2967, 3007, 3007, 3045], [3047, 3047, 3071, 3071, 3393], [3395, 3395, 3414, 3414, 3843], [3845, 3845, 3866, 3866, 4330], [4331, 4331, 4360, 4360, 4382], [4386, 4386, 4414, 4414, 4604], [4606, 4606, 4647, 4647, 4685], [4686, 4686, 4713, 4713, 5129], [5132, 5132, 5182, 5182, 6047], [6049, 6049, 6074, 6074, 6675], [6678, 6678, 6705, 6705, 7281], [7284, 7284, 7341, 7341, 8215]], "test": "untested"}
{"id": "tl2czK", "name": "Reflective Balls", "author": "vipiao", "description": "Using ray marching to render multiple reflective balls on a reflective catwalk.", "tags": ["raymarching", "reflection", "animated"], "likes": 1, "viewed": 352, "published": 3, "date": "1594872789", "time_retrieved": "2024-07-30T20:55:17.417251", "image_code": "\n// Inspird by \"[TUT] RayMarching for Dummies!\".\n\n#define PI 3.1415926538\n\n#define MAX_STEPS 300\n#define MAX_DIST 100.\n#define SURF_DIST .01\n\nfloat GetDist(vec3 p) {\n\tvec4 s = vec4(2.5, 1, 2.5, 1);\n    \n    vec3 p2 = p;\n    p2.y = mod(p.y+1., 5.)-1.;\n    float sphereDist =  length(p2-s.xyz)-s.w;\n    float planeDist = p.y;\n    \n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    vec3 pos = ro;\n    vec3 posMod;\n    bool isRelective = true;\n    int numR = 0;\n    int occlusion = 0;\n    float curveFactor = -0.0005;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n        // Reflection.\n        /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n        vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n        vec3 relPos = pos-reflectionPoint;\n        float proj = dot(relPos, reflectionNormal);\n        if(proj < 0.){\n        \tpos -= 2.*reflectionNormal * proj;\n            rd = reflect(rd, reflectionNormal);\n        }*/\n        \n        //\n        posMod.x = mod(pos.x, 5.);\n        posMod.y = pos.y;\n        posMod.z = mod(pos.z, 5.);\n        float dS = GetDist(posMod);\n        pos += rd*dS;\n        \n        // Curve.\n        vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        rd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n        \n        dO += dS;\n        //if(dO>MAX_DIST || dS<SURF_DIST) break;\n        if(dS<SURF_DIST) {\n            if (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n            break;\n        }\n        occlusion ++;\n        if (i == MAX_STEPS-1){\n        \treturn dO/(pow(float(occlusion), 0.5)*0.1+1.);\n        }\n    }\n    // Reflect.\n    for(int j=0; j</*int(mod(iTime,5.))*/10 && isRelective; j++) {\n        numR++;\n        dO *= 1.;\n        vec3 normal;\n        if (pos.y < SURF_DIST) {\n            normal = vec3(0,1,0);\n        } else {\n            normal = normalize(posMod-vec3(2.5, 1, 2.5));\n        }\n        if (dot(rd,normal) < 0.) {\n        \trd = reflect(rd, normal);\n            numR++;\n        }\n        pos += rd*SURF_DIST*2.;\n\n        for(int i=0; i<MAX_STEPS; i++) {\n            // Reflection.\n            /*vec3 reflectionPoint = vec3(1.+iTime*5.,0,0);\n            vec3 reflectionNormal = normalize(vec3(-1,-0.5,0));\n            vec3 relPos = pos-reflectionPoint;\n            float proj = dot(relPos, reflectionNormal);\n            if(proj < 0.){\n                pos -= 2.*reflectionNormal * proj;\n                rd = reflect(rd, reflectionNormal);\n            }*/\n            \n            //\n            posMod.x = mod(pos.x, 5.);\n            posMod.y = pos.y;\n            posMod.z = mod(pos.z, 5.);\n            float dS = GetDist(posMod);\n            pos += rd*dS;\n        \n            // Curve.\n            vec3 sideways = normalize(vec3(-rd.z, rd.y, rd.x));\n        \trd = normalize(rd + vec3(0,curveFactor*dS,0) + sideways*dS*0.002);\n            \n            dO += dS;\n            //if(dO>MAX_DIST || dS<SURF_DIST) break;\n            if(dS<SURF_DIST) {\n            \tif (pos.z >= 5. || pos.z <= 0. || pos.y > 5.) isRelective = false;\n                break;\n            }\n            occlusion ++;\n            if (i == MAX_STEPS-1){\n                return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n            }\n        }\n    }\n    /*for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || dS<SURF_DIST) break;\n    }*/\n    return dO/(pow(float(occlusion), 0.5)*0.1+1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0.+iTime*1.*5., 1.+0.15+cos(iTime*PI*.2)*1., cos(iTime*PI*.2*0.5+PI*0.5)*3.5*0.+4.);\n    //vec3 ro = vec3(0.+iTime*1.*5., 6.+cos(iTime)*3.5, 2.5+cos(iTime+PI*0.5)*3.5);\n    float angle = sin(iTime*0.2)*PI*0.5+PI;\n    //vec3 ro = vec3(0., 1., 0.);\n    \n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.));\n    float x = -rd.z*sin(angle + PI*0.) + rd.x*cos(angle + PI*0.);\n    float z = rd.x*sin(angle + PI*0.) + rd.z*cos(angle + PI*0.);\n    rd.x = x;\n    rd.z = z;\n    \n    float d = RayMarch(ro, rd);\n    col = vec3(d/150.);\n    \n    fragColor = vec4(col, 1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2czK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[142, 142, 165, 165, 386], [388, 388, 422, 422, 3499], [3501, 3501, 3558, 3558, 4234]], "test": "untested"}
{"id": "WtcSzj", "name": "Sci-Fi Corridor", "author": "felipunkerito", "description": "Trying to recreate some level design from the UE reddit. Had it laying around for a while, did some final touches and here it is!", "tags": ["3d", "raymarching"], "likes": 5, "viewed": 349, "published": 3, "date": "1594863805", "time_retrieved": "2024-07-30T20:55:18.371700", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 buf = texture( iChannel0, uv );\n    \n    fragColor = mix( texture( iChannel1, uv ), buf, 0.7 );\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define EPS 0.001\n#define FAR 30.0\n#define MAX_ITER 1200\n#define SPEED 2.1\n#define HASHSCALE1 .1031\n#define PI acos( -1.0 )\n#define Smooth\n#define AUD texture( iChannel2, vec2( 0.5 ) ).x\n#define WAV texture( iChannel2, vec2( 0.3 ) ).x\n#define FRE texture( iChannel2, vec2( 0.8 ) ).x\n\nvec3 glow = vec3( 0 );\n\nmat2 rot( float a )\n{\n\n    return mat2( cos( a ), -sin( a ),\n                 sin( a ),  cos( a )\n               );\n\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n// power smooth min (k = 8);\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n// Taken from cabibo's https://www.shadertoy.com/view/Ml2XDw\nfloat smax( float a, float b, float k )\n{\n    return log( exp( k * a ) + exp( k * b ) ) / k;\n}\n\nvec3 turn( vec3 p )\n{\n\n    p.z -= iTime * SPEED;\n    p.x += 2.2 * sin( p.z * 0.4 ) + 1.5 * cos( p.z * 0.3 );\n    p.y += 0.1 * cos( p.z * 0.7 );\n    \n    return p;\n\n}\n\nvec3 dip( vec3 p )\n{\n\n    p.y -= 0.25 + 0.25 * sin( ( p.x + p.z ) + iTime * SPEED * FRE * 0.001 );\n    p.z += 1.0 + iTime * SPEED;\n    //p.x = abs( p.x );\n    //p.x -= 0.8;\n    //p.z = mod( p.z, 1.2 ) - 0.6;\n    \n    return p;\n\n}\n\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    \n    vec2 d = abs( vec2( length( p.xz ), p.y ) ) - h;\n    return min( max( d.x, d.y ), 0.0 ) + length( max( d, 0.0 ) );\n    \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    \n  \tvec3 q = abs( p ) - b;\n  \treturn length( max( q, 0.0 ) ) + min( max( q.x, max( q.y, q.z ) ), 0.0 );\n\n}\n\nfloat sdBox( vec2 p, vec2 b )\n{\n    \n  \tvec2 q = abs( p ) - b;\n  \treturn length( max( q, 0.0 ) ) + min( max( q.x, q.y ), 0.0 );\n\n}\n\nfloat sp( vec3 p, float a )\n{\n\n\treturn length( p - vec3( 0, -0.7, 0 ) ) - a;\n\n}\n\nfloat tri( float amp, float dis, float fre, float spe, float dec )\n{\n\n    return amp * sin( fre * dis - iTime * spe ) / ( dec + dis * dis );\n    \n}\n\n// Shane's\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n    \n    //return cellTileColor(p);\n  \n    n = max((abs(n) - 0.2)*7., 0.001); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z ); \n\treturn (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 0);\n    \n    //p.z += iTime * 0.2;\n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\nvec2 map( vec3 p )\n{\n    \n    p = turn( p );\n    //p.xy *= 1.2;\n    \n    float tu =  max( -( length( p.xy ) - 2.0 ), length( p.xy ) - 2.5 );\n    \n    vec3 pRoo = p;\n    pRoo.y -= 2.0;\n    float roo = length( pRoo.xy ) - 1.0;\n    \n    vec2 tun = vec2( max( -roo, tu ), 0.0 );\n    \n    pRoo.y -= 2.1;\n    \n    vec2 roof = vec2( length( pRoo.xy ) - 2.0, 1.0 );\n    \n    if( roof.x < tun.x )\n    {\n    \n        tun = roof;\n    \n    }\n    \n    vec3 floP = dip( p );\n    vec2 flo = vec2( smin( p.y + 0.8 + tri( 0.5, length( floP.xz ), 10.0 + AUD * 10.0, 3.0, 35.0 + 30.0 * sin( ( floP.x + floP.z ) - iTime * SPEED ) ), sp( floP, 0.2 ), 0.2 ), 2.0 );\n    //vec2 flo = vec2( smin( p.y + 0.8, sp( floP, 0.2 ), 0.2 ), 2.0 );\n    \n    if( tun.x < flo.x ) \n    {\n    \n        flo = tun;\n    \n    }\n    \n    vec3 pro = p;\n    \n    pro.y += 0.1;\n    pro.zy *= rot( 1.5708 );\n    \n    pro.y = mod( pro.y, 2.0 ) - 1.0;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    pro.y = abs( pro.y );\n    pro.y -= 0.1;\n    pro.y = abs( pro.y );\n    pro.y -= 0.025;\n    \n    vec3 boxP = pro;\n    boxP.z += 0.45;\n    boxP.x = abs( boxP.x );\n    boxP.x -= 1.95;\n    \n    vec2 cyl = vec2( min( sdBox( boxP, vec3( 0.01, 0.005, 0.07 ) ), max( -p.y + 0.4, max( -sdCylinder( pro, vec2( 1.98, 0.01 ) ), sdCylinder( pro, vec2( 2.03, 0.005 ) ) ) ) ), 3.0 );\n   \n    \n    if( cyl.x < flo.x )\n    {\n    \n        flo = cyl;\n    \n    }\n    \n    vec3 cylP = p;\n    cylP.y -= 2.1;\n    cylP.x = abs( cylP.x );\n    cylP.x -= 0.6;\n    \n    vec2 cylC = vec2( length( cylP.xy ) - 0.1, 4.0 );\n    \n    if( cylC.x < flo.x )\n    {\n    \n        flo = cylC;\n    \n    }\n    \n    vec3 pbo = p;\n    pbo.y += 0.7;\n    pbo.x = abs( pbo.x );\n    pbo.x -= 1.85;\n    \n    vec2 box = vec2( sdBox( pbo.xy, vec2( 0.1, 0.1 ) ) - 0.05, 5.0 );\n    \n    if( box.x < flo.x )\n    {\n    \n        flo = box;\n    \n    }\n    \n    //float tileSize = 1.5;\n    \n    //vec3 id = vec3( int( p.x / tileSize ), int( p.y / tileSize ), int( p.z / tileSize ) );\n    \n    vec3 tub = p;\n    tub.y += 0.29;\n    vec3 tubO = tub;\n    tub.x = abs( tub.x );\n    tub.x -= 1.995;\n    tubO.x = abs( tubO.x );\n    tubO.x -= 2.11;\n    tubO += 0.15;\n    tub.y += 0.05 * cos( tub.z * 1.0 ) * sin( tub.z * 0.4 );\n    tubO.y += 0.025 * cos( 20.0 + tubO.z * 1.0 ) * -sin( tubO.z * 0.6 );\n    \n    vec2 sid = vec2( min( length( tubO.xy ) - 0.024, length( tub.xy ) - 0.025 ), 6.0 );\n    \n    if( flo.x < sid.x )\n    {\n    \n        sid = flo;\n    \n    }\n    \n    // This one is quite fun!\n    //vec2 sph = vec2( flo.x - 0.004, 7.0 );\n    //vec2 sph = vec2( smin( p.y + 0.801, sp( p, 0.201 ), 0.2 ), 7.0 );\n    /*vec2 sph = vec2( sp( floP, 0.207 ), 7.0 );\n    \n    if( sph.x < sid.x )\n    {\n    \n        sid = sph;\n    \n    }*/\n    \n    return sid;\n    \n}\n\nvec3 norm( vec3 p )\n{\n\n    vec2 e = vec2( EPS, 0 );\n    \n    return normalize( \n           \t\t\t\tvec3( \n                        \t\tmap( p + e.xyy ).x - map( p - e.xyy ).x,\n                            \tmap( p + e.yxy ).x - map( p - e.yxy ).x,\n                            \tmap( p + e.yyx ).x - map( p - e.yyx ).x\n                            \n                        \t) \n    \t\t\t\t);\n\n}\n\nfloat ray( vec3 ro, vec3 rd, out float d )\n{\n\n    float t = 0.0;\n    \n    for( int i = 0; i < MAX_ITER; ++i )\n    {\n    \n        d = map( ro + rd * t ).x;\n        \n        if( d < EPS || t > FAR )\n        {\n        \n            break;\n        \n        }\n        \n        t += d;\n        glow += vec3( 1e-4, 1e-3, 1e-4 ) * FRE;\n    \n    }\n    \n    return t;\n\n}\n\n/*\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax, int technique )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<32; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n\n        // traditional technique\n        if( technique==0 )\n        {\n        \tres = min( res, 10.0*h/t );\n        }\n        // improved technique\n        else\n        {\n            // use this if you are getting artifact on the first iteration, or unroll the\n            // first iteration out of the loop\n            //float y = (i==0) ? 0.0 : h*h/(2.0*ph); \n\n            float y = h*h/(2.0*ph);\n            float d = sqrt(h*h-y*y);\n            res = min( res, 10.0*d/max(0.0,t-y) );\n            ph = h;\n        }\n        \n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n*/\n\nvec3 sha( vec3 ro, vec3 rd, float t, vec2 d )\n{\n\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n    vec3 col = vec3( 0 );\n    \n    if( map( p ).y == 0.0 ) \n    {\n    \n    \tn = texBump( iChannel1, turn( p ), n, 0.005 );\n        col += 0.1;\n    \n    }\n    \n    vec3 ref = reflect( rd, n );\n    \n    vec3 lig = ro - vec3( 0.1, 0.5, -1.4 );\n    lig.x -= turn( lig ).x;\n    lig = normalize( lig );\n    //lig.x -= turn( lig ).x;\n    //lig = normalize( lig );\n    vec3 blig = -lig;\n    \n    //vec2 d = map( p );\n    \n    \n    //float amb = 0.5 + 0.5 * n.y; \n    float dif = max( 0.0, dot( n, lig ) );\n    float bac = max( 0.0, dot( n, blig ) );\n    \n    float spe = pow( clamp( dot( lig, ref ), 0.0, 1.0 ), 4.0 ); \n    //float sha = calcSoftshadow( p, lig, 0.01, 3.0, 1 );\n    \n    // Taken from tekf's awesome KIFS https://www.shadertoy.com/view/lssSWM.\n    vec3 ambient = mix( vec3( 0.03, 0.05, 0.08 ), vec3( 0.1 ), ( -n.y + 1.0 ) ); // ambient\n    // ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = t / 20.0; \n\tfloat occlusion = max( 0.0, 1.0 - map( p + n * aoRange ).x / aoRange ); // can be > 1.0\n\tocclusion = exp2( -3.0 * pow( occlusion, 2.0 ) ); // tweak the curve\n\tambient *= occlusion;\n    \n    col += vec3( 0.2, 0.2, 0.3 ) * ambient;\n    //col += vec3( 0.2, 0.2, 0.3 ) * amb;\n    col += vec3( 0.4, 0.4, 0.2 ) * spe;\n    col += vec3( 0.2, 0.1, 0.1 ) * dif;\n    col += vec3( 0.1, 0.1, 0.2 ) * bac;\n    \n    //col += vec3( 0.4, 0.4, 0.2 ) * spe;\n    \n    //col += 0.6 * texture( iChannel0, ref ).rgb;\n    \n    /*if( d.y == 2.0 )\n    {\n    \n        col += glow + AUD;\n    \n    }*/\n    \n    /*\n    if( d.y == 0.0 )\n    {\n    \n        col += tex3D( iChannel1, p, n );\n    \n    }\n    \n    \n    if( d.y == 1.0 )\n    {\n    \n        col *= vec3( 10 );\n    \n    }\n    \n    if( d.y == 2.0 )\n    {\n    \n        col *= vec3( 0, 1, 1 );\n    \n    }\n    \n    if( d.y == 3.0 )\n    {\n    \n        col *= vec3( 0, 1, 0 );\n    \n    }\n    \n    if( d.y == 4.0 )\n    {\n    \n        col *= vec3( 0, 0, 1 );\n    \n    }*/\n    \n    if( d.y == 1.0 )\n    {\n    \n        col += vec3( 0.2, 0.14, 0.1 ) * ( 0.5 + 0.5 * -n.y ) * occlusion;\n        col += 2.0 * spe;\n    \n    }\n    \n    if( d.y == 2.0 )\n    {\n    \n        col *= vec3( 0.5, 0.45, 0.4 );\n        //col += 0.5 * texture( iChannel0, ref ).rgb;\n    \n    }\n    \n    /*if( d.y == 3.0 )\n    {\n    \n        col *= 0.5;\n    \n    }*/\n    \n    //col *= glow;\n    \n    //col *= 0.5 + t * t * 0.3;\n    col = mix( col, vec3( 0.9, 0.88, 0.8 ), t * 0.08 );\n    \n    col += 0.2 * glow;// + AUD;\n    \n    return pow( col, vec3( 0.4545 ) );\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = ( -iResolution.xy + 2.0 * fragCoord.xy ) / iResolution.y;\n\n    vec3 ro = vec3( 0, -0.3, 0 );\n    vec3 rd = normalize( vec3( uv, -1 ) );\n    vec3 tur = turn( ro );\n    ro.x -= tur.x;\n    //ro.zy *= rot( iMouse.y * 0.05 );\n    //rd.zy *= rot( iMouse.y * 0.05 );\n    rd.xz *= rot( tur.x * 0.2 );\n    \n    float d = 0.0, t = ray( ro, rd, d );\n    vec3 p = ro + rd * t;\n    vec3 n = norm( p );\n    \n    vec2 m = map( p );\n    \n    vec3 shad = d < EPS ? sha( ro, rd, t, m ) : vec3( 1 );\n    \n    if( ( m.y == 2.0 || m.y == 3.0 || m.y == 4.0 || m.y == 6.0 ) && d < EPS )\n    {\n\n    \trd = normalize( reflect( rd, n ) );\n   \t \tro = p + rd * EPS;\n\n        shad = sha( ro, rd, t, m );\n        \n    }\n    \n    fragColor = vec4( shad, 1 );\n    \n}", "buffer_a_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23352, "src": "https://soundcloud.com/twistedmusic/shpongle-before-the-big-bang", "ctype": "musicstream", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 tex = texture( iChannel0, uv );\n    vec4 bac = texture( iChannel1, uv );\n    \n    float eff = iTimeDelta * ( ( tex.r + bac.r + tex.g + bac.g + tex.b + bac.b ) * 0.33333 );\n    \n    fragColor = clamp( vec4( mix( bac, tex, eff ).rgb, eff ), vec4( 0.0 ), vec4( 1.0 ) );\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtcSzj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 215]], "test": "untested"}
{"id": "3l2czV", "name": "digitalflow", "author": "vdmo", "description": "experiments of course darling ;) ", "tags": ["cineshader"], "likes": 21, "viewed": 17261, "published": 3, "date": "1594853252", "time_retrieved": "2024-07-30T20:55:19.222425", "image_code": "//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 20. * iTime),\n      r = (x)^(y);\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 10970 < 1000 );\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"vdmo.tv\",\n\t\"description\": \"live visuals\",\n\t\"model\": \"nothing\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2czV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 224]], "test": "untested"}
{"id": "3l2cRV", "name": "chrysalis 2", "author": "haptix", "description": "chrysalis 2", "tags": ["kif", "chrysalis"], "likes": 3, "viewed": 348, "published": 3, "date": "1594845854", "time_retrieved": "2024-07-30T20:55:20.080132", "image_code": "float pi = acos(-1.);\nfloat glo = 0.;\n\nmat2 rot (float rad)\n{\n    return mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n}\n\nvec2 box(vec3 p, vec3 b, float matId)\n{\n    vec3 q = abs(p) - b;\n    return vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.), matId);\n}\n\nvec2 rBox(vec3 p, vec3 b, float r, float matId)\n{\n\tvec3 q = abs(p) - b;\n\treturn vec2(length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.) - r, matId);\n}\n\nvec3 kif(vec3 p)\n{    \n    float t = iTime + iDate.y;\n    \n    for(float i = 0.; i < 9.; i++)\n    {   \n        p.xy *= rot(.067*t);\n        \n        p = abs(p) - vec3(((sin(.02*t) + .5) * .011*cos(t*.07)) + ((cos(.013*t) + .5) * .011*sin(t*.07)) + .09,\n                          ((cos(.03*t) + .5) * .011*sin(t*.17)) + ((sin(.015*t) + .5) * .011*cos(t*.17)) + .05,\n                          ((cos(.05*t) + .5) * .011*sin(t*.27)) + ((sin(.017*t) + .5) * .011*cos(t*.27)) + .07);\n\n        p.zx *= rot(-.043*t);\n        \n        p = abs(p) - vec3(((cos(.03*t) + .5) * .011*sin(t*.19)) + ((sin(.015*t) + .5) * .011*cos(t*.19)) + .05,\n                          ((sin(.05*t) + .5) * .011*cos(t*.29)) + ((cos(.017*t) + .5) * .011*sin(t*.29)) + .09,\n                          ((sin(.02*t) + .5) * .011*cos(t*.09)) + ((cos(.013*t) + .5) * .011*sin(t*.09)) + .07);\n    }\n    \n    return p;\n}\n\nvec2 add(vec2 m1, vec2 m2)\n{\n    return m1.x < m2.x ? m1 : m2;\n}\n\nvec2 map(vec3 p)\n{   \n    float rCorner = .002;\n    p = kif(p);\n    \n    vec2 m1 = rBox(p, vec3(.65, .06, .65), .015, 1.);\n    vec2 m2 = rBox(p, vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m3 = rBox(vec3(p.x - .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m4 = rBox(vec3(p.x + .05, p.yz), vec3(.004, .85, 1.05), rCorner, 3.);\n    vec2 m5 = rBox(p, vec3(.08, .8, 1.), rCorner, 2.);\n    vec2 m6 = rBox(vec3(p.x - .25, p.yz), vec3(.06, .55, .45), .015, 1.);\n    vec2 m7 = rBox(vec3(p.x + .25, p.yz), vec3(.06, .55, .45), .015, 1.);\n    vec2 m = add(m1, m2);\n    m = add(add(add(add(add(add(m1, m2), m3), m4), m5), m6), m7);\n    glo += .1 / (.1 + m1.x*m1.x*m1.x);\n    return m;\n}\n\nvec2 tr(vec3 ro, vec3 rd)\n{\n    float far = 22.;\n\tvec2 h,t= vec2(.01);\n\tfor(int i = 0; i < 256; i++)\n\t{\n\t\th = map(ro + rd*t.x);\n\t\tif(h.x < .001 || t.x > far)\n\t\t\tbreak;\n\t\tt.x += h.x * .9;\n        t.y = h.y;\n  \t}\n    if(t.x > far)\n        t.y = 0.;\n\treturn t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ro = vec3(.6*cos(-.1*iTime),\n                   .91*sin(-.1*iTime),\n                   -4.);\n\tvec3 camTarget = vec3(0.);\n\tvec3 up = vec3(0., 1., 0.);\n\tvec3 camDir = normalize(camTarget - ro);\n\tvec3 camRight = normalize(cross(up, ro));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n    vec3 lightPos = vec3(2.5, 2.5, -20.);\n    vec3 lightPos2 = vec3(-2.5, -2.5, -20.);\n  \n\tvec2 screenPos = -1. + 2. * gl_FragCoord.xy / iResolution.xy;\n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec2 eps = vec2(0., .01);\n\tvec3 rd = normalize(camRight*screenPos.x + camUp*screenPos.y + camDir);\n  \n\tvec2 t = tr(ro, rd);\n\n    vec3 colRot = vec3(sin(.317*(iTime)),\n                       cos(.151*(iTime)),\n                       cos(.227*(iTime))) + 1.2;\n\n    if (t.y > 0.)\n    {\n        vec3 hit = ro + rd*t.x;\n        vec3 lightDir = normalize(lightPos - hit);\n        vec3 lightDir2 = normalize(lightPos2 - hit);\n        \n        vec3 norm = normalize(map(hit).x - vec3(map(hit - eps.yxx).x,\n                              \t\t\t\t\tmap(hit - eps.xyx).x,\n                              \t\t\t\t\tmap(hit - eps.xxy).x));\n        \n        float diff = max(0., dot(lightDir, norm));\n        float spec = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float spec2 = pow(max(dot(rd, reflect(norm, lightDir)), 0.), 100.);\n        float ao = clamp(map(t.x + norm*.5).x / .5, 0., 1.);\n        \n        vec3 col = vec3(.1);\n        col *= .1 * ao;\n        \n        if(t.y == 1.)\n            colRot = vec3(.18);\n        else if (t.y == 3.)\n        {\n            col += glo*.02*colRot;\n        }    \n        else\n        {\n            colRot = colRot.yzx;\n            col += glo*.02*colRot;\n        }\n        \n        col += .3 * diff * colRot;\n        col += 1. * spec * vec3(0., .7, 1.);\n        col += 1. * spec2 * vec3(0., .7, 1.);\n        \n        fragColor = vec4(col, 1.);\n    }\n    else\n    \tfragColor = vec4(glo*colRot.zxy*.02, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 61, 61, 121], [123, 123, 162, 162, 268], [270, 270, 319, 319, 423], [425, 425, 443, 443, 1306], [1308, 1308, 1336, 1336, 1372], [1374, 1374, 1392, 1392, 2063], [2065, 2065, 2092, 2092, 2324], [2326, 2326, 2383, 2383, 4318]], "test": "untested"}
{"id": "WljyRV", "name": "Painted eggs", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/3t2czK]\"caves of steel\"[/url] fractal.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 327, "published": 3, "date": "1594841994", "time_retrieved": "2024-07-30T20:55:20.969753", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 1\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    float s1 = 3.0;\n    return size-length((sin(p/s1)*s1+.5/s1+sin(p/vec3(length((p/20.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*1200.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float multiplier = 9.0;\n    float i = multiplier;\n    for(int j = 0; j < iterations; j++){\n        p = sin(p.yzx/i)*i-sin(p*i)/i;\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return -result*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    viewDir.yz *= rot(sin(iTime/10.0));\n    viewDir.xz *= rot(cos(iTime/10.0));\n    float t1 = (iTime)*24.0;\n    vec3 eye = vec3(1.1+t1/35.0,-13.4-t1*1.16,.9+t1/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljyRV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[611, 611, 643, 643, 751], [754, 754, 778, 778, 1111], [1113, 1113, 1141, 1141, 1218], [1220, 1641, 1732, 1732, 2038], [2053, 2307, 2372, 2372, 2504], [2506, 2595, 2624, 2624, 2934], [2936, 3428, 3568, 3568, 4178], [4180, 4550, 4635, 4635, 4982], [4984, 5311, 5360, 5395, 5526], [5528, 5528, 5585, 5585, 6713]], "test": "untested"}
{"id": "3t2czK", "name": "Caves of steel", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tlBcDh]\"alien megacity\"[/url] fractal.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion", "cave"], "likes": 2, "viewed": 322, "published": 3, "date": "1594836717", "time_retrieved": "2024-07-30T20:55:22.011966", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N),\n    dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a,\n    light1Pos = eye,\n    light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye),\n    s = normalize(cross(f, up)),\n    u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    float t1 = (1.2+sin(iTime/2.0))*24.0;\n    vec3 eye = vec3(1.1+t1/35.0,-13.4-t1*1.16,.9+t1/10.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = surface_color(worldDir*10.0+iTime/10.0).yzx;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    vec3 K_a = surface_color(p),\n    K_d = K_a,\n    K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 3\n\nconst int MAX_MARCHING_STEPS = 300;\nconst float\n    MIN_DIST = 0.0,\n\tMAX_DIST = 100.0,\n\tEPSILON = 0.001,\n\tsize = 1000.0,\n\tscale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat vines(vec3 p,float size1){\n    float s1 = 3.0;\n    return size-length((sin(p/s1)/s1+.5/s1+sin(p/vec3(length((p/20.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0,\n    result = vines(p,size1),\n    i = 15.0;\n    for(int j = 0; j < iterations; j++){\n        p = sin(p.yzx/i)*i-sin(p*i)/i;\n        result = min(result,result-vines(p,size1)/(i));\n    }\n    return -result*scale/4.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N),\n    dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a,\n    light1Pos = eye,\n    light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye),\n    s = normalize(cross(f, up)),\n    u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n        vec4 dmap = depth_map(fragCoord);\n\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    float t1 = (1.2+sin(iTime/2.0))*24.0;\n    vec3 eye = vec3(1.1+t1/35.0,-13.4-t1*1.16,.9+t1/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float l0 = sqrt(length(eye-dmap.xyz));\n    \n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    \n    fragColor = vec4(eye + dist * worldDir, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2czK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 480, 571, 571, 895], [910, 1164, 1229, 1229, 1361], [1363, 1452, 1481, 1481, 1791], [1793, 2285, 2425, 2425, 3014], [3016, 3386, 3471, 3471, 3803], [3805, 4132, 4181, 4216, 4337], [4339, 4339, 4366, 4366, 4515], [4517, 4517, 4574, 4574, 5520]], "test": "untested"}
{"id": "WljczK", "name": "Noisy Colorful Cells", "author": "NightJolt", "description": "color and noise and color and noise and color and noise and cells", "tags": ["noise", "color", "cell"], "likes": 3, "viewed": 263, "published": 3, "date": "1594836666", "time_retrieved": "2024-07-30T20:55:22.874660", "image_code": "vec2 random2(vec2 p) {\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvec2 effect(vec2 p) {\n    float ang = iTime * 0.1;\n    mat2x2 rot = mat2x2(cos(ang), -sin(ang), sin(ang), cos(ang));\n    \n    p *= rot;\n    \n    return p;\n}\n\nvec3 noise_map(vec2 p) {\n    vec2 cell = floor(p);\n    vec2 point = fract(p);\n    \n    float min_dist = 1.;\n    \n    for (int x= -1; x <= 1; x++) {\n        for (int y= -1; y <= 1; y++) {\n            vec2 new_cell = vec2(x, y);\n            vec2 new_point = random2(new_cell + cell);\n            \n            float offset = texelFetch(iChannel0, ivec2(.7, 0), 0).x;\n            \n            new_point = sin(new_point * sin(iTime * .4) * 5. + iTime + offset) * .5 + .5;\n            \n            float dist = length(new_cell + new_point - point);\n            \n            min_dist = min(min_dist, dist);\n        }\n    }\n    \n    vec3 color = vec3(min_dist);\n    color *= color;\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n    float screen_ratio = iResolution.x / iResolution.y;\n    //uv = fract(uv * 3.);\n    uv -= sin(iTime * .3) * .1 + .5;\n    uv.x *= screen_ratio;\n    vec3 color;\n    \n    uv *= 20.;\n    \n    uv = effect(uv);\n    \n    float offset_noise_x = noise_map(uv).x;    \n    float offset_noise_y = noise_map(uv + vec2(1., 1.)).x;\n    float offset_noise_z = noise_map(uv + vec2(2., 2.)).x;\n    \n    uv += (vec2(offset_noise_x) - .5) * .1;\n    color += vec3(offset_noise_x, offset_noise_y, offset_noise_z);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 115], [117, 117, 138, 138, 273], [275, 275, 299, 299, 973], [975, 975, 1030, 1030, 1608]], "test": "untested"}
{"id": "WlBczG", "name": "Hyperbolic Poincare Tiling", "author": "Shane", "description": "A basic hyperbolic Poincare tiling example to provide a basis for anyone who'd like to make one.", "tags": ["escher", "truchet", "geometry", "art", "hyperbolic", "impossible", "poincare"], "likes": 53, "viewed": 1221, "published": 3, "date": "1594822024", "time_retrieved": "2024-07-30T20:55:23.908895", "image_code": "/*\n\n\tHyperbolic Poincare Tiling\n\t--------------------------\n\n\n\tThis is a simpler hyperbolic polygonal tiling of the Poincare disc that\n    I've put together to accompany the more involved example I posted earlier.\n\n\tIn regard to the Poincare disc side of things, it was helpful to reference\n\tMLA, SL2C and STB's examples -- All authors have really nice work on here,\n\twhich is well worth the look. STB provided me with the link that he used\n    for his \"Hyperbolic Poincaré transformed\" example which enabled me to \n\tstreamline the setup code quite a bit. In fact, I'd imagine that once \n    someone like Fabrice Neyret gets a hold of it, you'll see a two tweet\n\tPoincare tiling. :)\n\n    Anyway, the code is very basic, but I've put in a reasonably thorough\n\texplanation, along with some useful links, so hopefully that'll be enough\n\tto give people a start.\n\n\tBy the way, the default setting is the standard triangle configuration\n\tyou'll see around. However, I've colored the triangle segments to match\n    ajoining ones, and put lines from the triangle center to the vertices to \n    produce the cube look. This is one of countless arrangements and patterns \n    that you may have seen around. I'm hoping others will put up a few more on \n    Shadertoy at some stage.\n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I'm assuming was in turn based on a slide presentation by\n    // Vladimir Bulatov: http://www.bulatov.org/math/1001/index.html\n\t//\n    Hyperbolic Poincaré transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n\n\t// Like everyone else, I love the following example. However, be warned that \n    // it involves complex geometry. :)  Seriously though, Mattz can come up with \n    // solutions to problems in a few minutes that have utterly confounded me for \n    // weeks.\n    //\n\tHyperbolic Wythoff explorer - mattz \n\thttps://www.shadertoy.com/view/wtj3Ry\n\n\n    // The shader that this particular one accompanies.\n    Hyperbolic Poincare Weave - Shane\n    https://www.shadertoy.com/view/tljyRR\n\n*/\n\n// Here's a more Earth tone-looking palette for people who require something\n// less cheery looking... OK, by \"people,\" I mean, me. :D\n//#define EARTH_TONES\n\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// P represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P − 2)*(Q − 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5 , 5-4, 6-4, 7-3.\n//\nconst int N\t\t= 3;\t// Polygon vertices.\nconst int Q\t\t= 8;\t// Polygons meeting at a vertex.\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n\t// There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n    \n    // Essentially, you're going to be reflecting points about polygonal edges, \n    // so you'll need the distance from your initial circle center to that of \n    // the center of the circle that runs adjacent to the current domain edges in\n    // order to perform a hyperbolic reflection. You'll need the radius of that \n    // circle as well. The distance and radius will depend directly upon how\n    // how many edges your polygon has and how many adjacent polygons (the\n    // number that meet at a vertex point) there are.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after. Of course, none of this will mean much without \n    // some imagery to refer to. Shadertoy user, SLB, provided me with a link\n    // to a setup image that made life much easier. Without too much trouble,\n    // it's possible to use whatever trigonometric identities you want to \n    // arrive at the following. In fact, with more effort, I'm pretty sure it'd\n    // be possible to do better. Here's the link:\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n    //\n    // I also find the imagery on the following page helpful as well:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n   \n    float a = sin(PI/float(N)), b = cos(PI/float(Q));\n\tfloat d2 = cos(PI/float(N) + PI/float(Q))/a;\n\tfloat r2 = 1./(b*b/a/a - 1.);\n\t// Distance between adjacent polygon centers, the adjacent polygon radius,\n    // and the current polygon radius. We're assuming no negatives, but I'm \n    // capping things above zero, just in case.\n\treturn sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));  \n   \n\n}\n\n// Globle polygon value. Not used here, but normally, it'd be the focus.\n//float gPoly;\n\n// Count variable, which is seful for all kinds of things. It's a measure\n// of how many iterations were required to get to the current polygon.\n// The center polygon would have a count of one, and should increase as we \n// radiate outwards.\nfloat count;\n\n\n// Hyperbolically reflecting the polygon across each of it's edges\n// via an inverse Mobius transform.\nvec2 transform(vec2 p, vec3 circ) {\n    \n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n     \n    float ia = (floor(atan(p.x, p.y)/TAU*float(N)) + .5)/float(N);\n    vec2 vert = rot2(ia*TAU)*vec2(0, circ.x);\n   \n    float rSq = circ.y*circ.y;\n    \n    // Circle inversion, which relates back to an inverse Mobius\n    // transformation. There are a lot of topics on just this alone, but \n    // the bottom line is, if you perform this operation on a point within\n    // the Poincare disk, it will be reflected. It's similar to the\n    // \"p /= dot(p, p)\" move that some may have used before.\n    vec2 pc = p - vert;\n    float lSq = dot(pc, pc);\n    \n    // If the distance (we're squaring for speed) from the current point to\n    // any vertex point is within the circle limits, hyperbolically reflect it.\n    if(lSq<rSq){\n         \n        p = pc*rSq/lSq + vert;\n        //p = rot2(TAU/float(N))*p; // Experimenting with rotation.\n        \n        // Maintaining chirality. I can thank MLA for this bit. If you \n        // don't do this, the coordinates will lose their polarity...\n        // I originally didn't do this. :D\n        //p.x = -p.x;\n        \n        // If we have a hit, increase the counter. This value can be useful\n        // for coloring, and other things.\n        count++;\n         \n    }\n    \n   \n    /* \n    // If you're after a CSG polygon to work with, the following should work.\n    // I've lazily set it to a global, but there'd be cleaner ways to work \n    // the calculations in.\n    float poly = (length(p) - circ.z);\n    poly = max(poly, -(length(pc) - circ.y));\n    gPoly = min(gPoly, poly);\n    */\n    return p;\n}\n\n\n// Very handy. I should write my own, but this works. I\n// rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n// IQ's standard box function.\nfloat sBox(in vec2 p, in vec2 b){\n   \n    vec2 d = abs(p) - b;\n    return min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\n// This will draw a box (no caps) of width \"ew\" from point \"a \"to \"b\". I hacked\n// it together pretty quickly. It seems to work, but I'm pretty sure it could be\n// improved on. In fact, if anyone would like to do that, I'd be grateful. :)\nfloat lBox(vec2 p, vec2 a, vec2 b, float ew){\n    \n    float ang = atan(b.y - a.y, b.x - a.x);\n    p = rot2(ang)*(p - mix(a, b, .5));\n\n    vec2 l = vec2(length(b - a), ew);\n    return sBox(p, (l + ew)/2.) ;\n}\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    \n    \n    // Aspect correct coordinates: Actually, fragCoord is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixel shader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n    \n    /*\n    // Moving to the half plane model.\n    const float sc = 2.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    */\n    \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.05;\n    \n     \n    // Hyperbolic the hyperbolic... I made that up, but it spherizes things \n    // a bit, which looks interesting.\n    //uv *= (1. + dot(uv, uv))/2.;\n   \n    \n    // Poincare coordinates.\n    vec2 p = uv;\n   \n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n        \n    // Perform some free rotation.\n    p = rot2(iTime/16.)*p;\n    \n   \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n    \n    // Globale polygon value. Not used here, but I'll use it when I make\n    // an extruded raymarched version.\n    //gPoly = 1e5;\n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    vec3 domInfo = initDomain();    \n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up... or something\n    // to that effect... It's been a while. Either way, this is what you do\n    // if you want to see the outside pattern. :)\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n  \n    \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    //\n    // One more important thing I should mention is that there's a test\n    // within the transform function (if you're outside the domain) that \n    // would allow you to break early, but I'm bypassing that for \n    // simplicity. The function is cheap, so I'm letting it run through, \n    // but when speed is an issue, it should be considered.\n    for(int i=0; i<24; i++){\n        p = transform(p, domInfo);\n    }\n    \n    \n    // From here on in, it's just rendering code. None of it is difficult, or\n    // particularly interesting. Once you have the local cell coordinates,\n    // you can render whatever you want. In this case, I've produced some\n    // colors according to whatever polygon segment where in, some dark \n    // center to polygon vertex point lines, and some shading lines with a\n    // dark box -- The last two are based on the center to edge mid point \n    // lines. All very simple.\n  \n   \n    // Vertex lines and edge mid point lines, and points.\n    float ln = 1e5, ln2 = 1e5, pnt = 1e5;\n    \n    // Initial point set to the boundary of whatever circle we're in.\n    vec2 v0 = vec2(0, domInfo.z), m0;\n    \n    // I'm being lazy and looping around the polygon vertices and mid\n    // points to produce the line information. I could just as easily\n    // do the repeat polar thing. I also believe it's easier to read for\n    // those trying to decipher this.\n    for(int i = 0; i<N; i++){\n\n        // Mid edge points. Note that interpolating from one edge vertex\n        // to the other won't give the correct results due to the\n        // hyperbolic nature of the local space, so we're rotating between\n        // vertex points and setting the distance do the correct distance\n        // measured out in the initialization function.\n        m0 = (rot2(PI/float(N))*v0)*(domInfo.x - domInfo.y)/domInfo.z;\n         \n        // Center to vertex distances. \n        ln = min(ln, lBox(p, vec2(0), v0, .007));\n        // Center to edge mid point distances. \n        ln2 = min(ln2, lBox(p, vec2(0), m0, .007));\n        \n        // Vertex points.\n        pnt = min(pnt, length(p - v0));\n \n        // Rotating to the next vertex point.\n        v0 = rot2(TAU/float(N))*v0;\n    }\n    \n \n    // Setting a ring distance field, then using that to add more to the \n    // smoothing factor to alleviate aliasing around the borders. It's \n    // hacky, and no substitute for super sampling, but it works well \n    // enough here.\n    float ssf = (2. - smoothstep(0., .25, abs(length(uv) - 1.) - .25));\n    float sf = 2./iResolution.y*ssf;//(count*count + 1.);//fwidth(shape);// \n\n \n    \n    // Setting the color, according to the polygon segment angle. It works\n    // well for this configuration, and others where the adjacent polyongs,\n    // Q are even, but breaks with odd Q, in which case you have to render in\n    // other lines.\n    float angl = mod(atan(p.x, p.y), TAU)*float(N)/TAU;\n    float triSeg = floorSm(angl, .15);  // Note the smooth floor function.\n    triSeg = (triSeg + .5)/float(N);\n\n    // IQ's versatile palette routine. It's one of my favorites.\n    #ifdef EARTH_TONES\n    vec3 oCol = .55 + .45*cos(triSeg*TAU/3.5 + vec3(0, 1, 2)/1.1);\n    #else\n    vec3 oCol = .55 + .45*cos(triSeg*TAU + vec3(0, 1, 2)).yxz;\n    #endif\n    \n    // Line pattern.\n    //float pat = clamp(sin(ln2*TAU*40.)*2. + 1., 0., 1.)*.4 + .8;\n    float pat = smoothstep(0., .25, abs(fract(ln2*50. - .2) - .5)*2. -.2);\n    \n    // Some subtle polygon segment (cube face) shading.\n    float sh = clamp(.65 + ln/domInfo.z*4., 0., 1.);\n    \n    // The background color. It looks interesting enough like this, but the lines\n    // give it additional depth.\n    vec3 col = min(oCol*(pat*.2 + .9)*sh, 1.);\n\n    // Rendering the lines.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln));\n    // The dark boxes on the inside of the ring only.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, -(ln - .085)));\n\n    \n    // Polygon vertex points and central point.\n    pnt -= .032;\n    pnt = min(pnt, length(p) - .032);\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, pnt));\n    col = mix(col, vec3(1, .8, .3), 1. - smoothstep(0., sf, pnt + .02));\n    \n    \n    // A quick background image... Definitely needs more effort. :)\n    #ifdef EARTH_TONES\n    vec3 bg = vec3(.85, .4, .3);//.55 + .45*cos(TAU/6. + vec3(0, 1, 2)/1.2);\n    #else\n    vec3 bg = vec3(.4, .2, 1);\n    #endif\n    bg *= .3*(mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), .5)*.5 + .5);\n    pat = smoothstep(0., .25, abs(fract((uv.x - uv.y)*43. - .25) - .5)*2. -.5);\n    bg *= max(1. - length(uv)*.5, 0.)*(pat*.2 + .9);\n    \n   \n    // Putting in the outer ring. I did this in a hurry, so you could do it in\n    // fewer steps for sure. Think of it as a lesson on what not to do. :D\n    float cir = length(uv);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*10., abs(cir - 1.) - .05))*.7);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*2., abs(cir - 1.) - .05)));\n    col = mix(col, vec3(.9) + bg, (1. - smoothstep(0., sf, abs(cir - 1.) - .03)));\n    col = mix(col, col*max(1. - length(uv)*.5, 0.), (1. - smoothstep(0., sf, -cir + 1.05)));\n    col = mix(col, bg, (1. - smoothstep(0., sf, -cir + 1.05)));\n    /*\n    // Dial markings -- Hours and seconds, for whatever reason. Hmmm, might be too much,\n    // so I'm leaving it out. Yet, another five minutes I'll never get back. :D\n    uv = rot2(iTime/16.)*uv; float ang = atan(uv.x, uv.y)/TAU;\n    float dial = abs(fract(ang*12.) - .5)*2. - .025;\n    dial = min(abs(fract(ang*60.) - .5)*2. - .05, dial);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*3., max(abs(cir - 1.) - .03, dial)))*.95);\n    */\n    // Shadow.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(cir - 1.035) - .03))*.8);\n\n  \n    // Toning things down ever so slightly. \"1. - exp(col*a)\" is used as a toning\n    // device... I'm toning things down a little bit. I prefer not to post process\n    // too much, but sometimes, it can help tie things together when the\n    // background tones don't match the foreground, and so forth. Sometimes, \n    // multiplying everything by a single subtle sepia color, or whatever can help\n    // tie things together overall. Anyway, comment the line out, and you'll see\n    // that it tones down the highlights just a little.    \n    col = mix(col, 1. - exp(-col), .35);\n    \n    // Rough gamma correction, then present to the screen.\n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[2252, 2285, 2307, 2307, 2365], [2824, 3292, 3310, 4902, 5299], [5647, 5750, 5785, 6053, 7609], [7612, 7796, 7829, 7829, 7918], [7920, 7951, 7984, 7984, 8071], [8073, 8312, 8357, 8357, 8520], [8522, 8550, 8578, 8609, 9335], [9338, 9338, 9393, 9601, 18444]], "test": "untested"}
{"id": "ttBcRV", "name": "Flying through glowing stars", "author": "mrange", "description": "License CC0: Flying through glowing stars\nThe result of playing around trying to improve an old shader", "tags": ["2d"], "likes": 17, "viewed": 664, "published": 3, "date": "1594818145", "time_retrieved": "2024-07-30T20:55:24.764607", "image_code": "// License CC0: Flying through glowing stars\n//  The result of playing around trying to improve an old shader\n\n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/(k))*(x)*(x)+(k)*.5,abs(x),abs(x)-(k))\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in vec3 co) {\n  return fract(sin(dot(co, vec3(12.9898,58.233, 12.9898+58.233))) * 13758.5453);\n}\n\nfloat starn(vec2 p, float r, int n, float m) {\n  // From IQ: https://www.shadertoy.com/view/3tSGDy\n  // https://iquilezles.org/articles/distfunctions2d\n  \n  // Minor tweak to use SABS over abs to smooth inner corners\n  // SABS: https://www.shadertoy.com/view/Ws2SDK\n\n  // next 4 lines can be precomputed for a given shape\n  float an = 3.141593/float(n);\n  float en = 3.141593/m;  // m is between 2 and n\n  vec2  acs = vec2(cos(an),sin(an));\n  vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) for regular polygon,\n\n  float bn = mod(atan(p.x,p.y),2.0*an) - an;\n  p = length(p)*vec2(cos(bn),SABS(sin(bn), 0.15));\n  p -= r*acs;\n  p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n  return length(p)*sign(p.x);\n}\n\nvec4 alphaBlend(vec4 back, vec4 front) {\n  vec3 xyz = mix(back.xyz*back.w, front.xyz, front.w);\n  float w = mix(back.w, 1.0, front.w);\n  return vec4(xyz, w);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nvec3 offset(float z) {\n  float a = z;\n  vec2 p = -0.075*(vec2(cos(a), sin(a*sqrt(2.0))) + vec2(cos(a*sqrt(0.75)), sin(a*sqrt(0.5))));\n  return vec3(p, z);\n}\n\nvec3 doffset(float z) {\n  float eps = 0.05;\n  return 0.5*(offset(z + eps) - offset(z - eps))/eps;\n}\n\nvec3 ddoffset(float z) {\n  float eps = 0.05;\n  return 0.5*(doffset(z + eps) - doffset(z - eps))/eps;\n}\n\nvec4 planeCol(vec3 ro, vec3 rd, float n, vec3 pp) {\n  const float s = 0.5;\n  \n  vec2 p = pp.xy;\n  float z = pp.z;\n  vec2 dpy = dFdy(p);\n  float aa = length(dpy);\n\n  p -= (1.0+5.0*(pp.z - ro.z))*offset(z).xy;\n  \n  p *= s;\n  float r = hash(vec3(floor(p+0.5), n));\n  p = fract(p+0.5)-0.5;\n  rot(p, ((TAU*r+n)*0.25));\n  float d = starn(p, 0.20, 3 + 2*int(3.0*r), 3.0);\n  d -= 0.06;\n  d/=s;\n  \n  float ds = -d+0.03;\n  vec3 cols = hsv2rgb(vec3(337.0/360.0+0.1*sin(n*0.3), 0.8, 0.54+0.2*sin(n*0.3)));\n  float ts = 1.0 - smoothstep(-aa, 0.0, ds);\n  vec4 cs =  vec4(cols, ts*0.93);\n\n  float db = abs(d) - (0.06);\n  db = abs(db) - 0.03;\n  db = abs(db) - 0.00;\n  db = max(db, -d+0.03);\n    vec3 colb = vec3(1.0, 0.7, 0.5);\n  float tb = exp(-(db)*30.0*(1.0 - 10.0*aa));\n  vec4 cb = vec4(1.5*colb, tb);\n\n  vec4 ct = alphaBlend(cs, cb);\n\n  return ct;\n}\n\nvec3 color(vec3 ww, vec3 uu, vec3 vv, vec3 ro, vec2 p) {\n  vec3 rd = normalize(p.x*uu + p.y*vv + (2.0-tanh(length(p)))*ww);\n  \n  vec4 col = vec4(vec3(0.0), 1.0);\n\n  const float planeDist = 1.0;\n  const int furthest = 6;\n  const int fadeFrom = furthest-3;\n\n  float nz = floor(ro.z / planeDist);\n\n  for (int i = furthest; i >= 1; --i) {\n    float pz = planeDist*nz + planeDist*float(i);\n    \n    float pd = (pz - ro.z)/rd.z;\n    \n    if (pd > 0.0) {\n      vec3 pp = ro + rd*pd;\n      \n      vec4 pcol = planeCol(ro, rd, nz+float(i), pp);\n      float fadeIn = 1.0-smoothstep(planeDist*float(fadeFrom), planeDist*float(furthest), pp.z-ro.z);\n      pcol.xyz *= sqrt(fadeIn);\n  \n      col = alphaBlend(col, pcol);\n    }\n  }\n  \n  return col.xyz*col.w;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float tm = TIME*0.65;\n  \n  vec3 ro   = offset(tm);\n  vec3 dro  = doffset(tm);\n  vec3 ddro = ddoffset(tm);\n\n  vec3 ww = normalize(dro);\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0)+1.5*ddro, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 col = color(ww, uu, vv, ro, p);\n  col = postProcess(col, q);\n  \n  const float fadeIn = 2.0;\n    \n  return col*smoothstep(0.0, fadeIn, TIME);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcRV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[419, 419, 441, 441, 610], [612, 612, 636, 636, 719], [721, 721, 767, 1042, 1431], [1433, 1433, 1473, 1473, 1592], [1594, 1594, 1627, 1627, 1712], [1714, 1714, 1736, 1736, 1870], [1872, 1872, 1895, 1895, 1971], [1973, 1973, 1997, 1997, 2075], [2077, 2077, 2128, 2128, 2915], [2917, 2917, 2973, 2973, 3663], [3665, 3665, 3702, 3702, 3910], [3912, 3912, 3941, 3941, 4331], [4333, 4333, 4385, 4385, 4547]], "test": "untested"}
{"id": "wtSyRK", "name": "Raymarcher - Test 2: Repetition", "author": "SpinningCube", "description": "An infinite grid of multicolored spheres.", "tags": ["raymarching"], "likes": 3, "viewed": 441, "published": 3, "date": "1594787652", "time_retrieved": "2024-07-30T20:55:25.628297", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Filmic tonemapping curve by milesWaugh\n\nconst int maxSteps = 256;\nconst float epsilon = 0.01;\nconst float focalLength = 1.;\nconst float renderDist = 8000.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfShininess;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = .9*vec3(.5, .6, .7);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance(mod(ray, 150.), pos ) - radius;\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float shininess ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfShininess = shininess;\n        }\n    }\n}\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n    \n    vec3 sinVector = vec3(1., 0.81, 1.23);\n    \n    vec3 colx = vec3(0.25*sin((ray/10.)*sinVector)+0.5);\n    \n    addSDF( Sphere( ray, vec3(100, 100, 100), 15.), colx, 1.5, 512. );\n    \n    return SDE;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        scene( ray, renderDist );\n        \n        rayLength += SDE;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < epsilon ) {\n            return vec4(1., ray);\n        }\n    }\n    return vec4(1., ray);\n}\n\nvoid phongLighting(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if (true)/*( shootRay(lightDir, ray + (surfNormal * 1.), lightDist, false).x == 0. )*/ {\n        \n        diffuse += max(intensity * dot(surfNormal, lightDir), 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n    \tspecular += max(intensity * surfSpecular * pow(dot(surfNormal, halfway), surfShininess), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    phongLighting( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    phongLighting( ray, rayDir, normalize(vec3(-1,1,-2)), surfNormal, 1., 0. );\n}\n\nvec3 filmicTransform(vec3 color) {\n    //return color;\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    float fog = clamp(length(ray - camera)/(renderDist), 0., 1.);\n    //fog = fog*fog;\n    //fog = fog*fog;\n    vec3 finalCol = (diffuse * surfCol) + (ambient * surfCol) + specular;\n    finalCol = mix(finalCol, ambient, fog);\n    \n    return filmicTransform(finalCol);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = vec3(60.*iTime, 30.*iTime, 200.*iTime);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = filmicTransform(ambient);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyRK.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[446, 446, 489, 489, 532], [544, 544, 594, 594, 648], [650, 650, 685, 685, 709], [711, 711, 780, 780, 959], [961, 961, 1004, 1004, 1240], [1242, 1242, 1269, 1269, 1640], [1642, 1642, 1723, 1723, 2164], [2166, 2166, 2275, 2275, 2608], [2610, 2610, 2701, 2701, 2842], [2844, 2844, 2902, 2902, 2984], [2986, 2986, 3020, 3040, 3211], [3213, 3213, 3268, 3268, 3628], [3630, 3630, 3687, 3687, 4263]], "test": "untested"}
{"id": "WtByzV", "name": "Gaussian Distributed Fog", "author": "blackle", "description": "line integral for a volume whose density is defined by a gaussian curve centred at the origin. shown here as a glowy blob", "tags": ["fog", "integral", "lineintegral"], "likes": 21, "viewed": 617, "published": 3, "date": "1594786725", "time_retrieved": "2024-07-30T20:55:26.480020", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//silly approximation for error function\nfloat erf(float x) {\n    return smoothstep(0.,1.,smoothstep(-2.25,2.25,x))*2.-1.;\n}\n\nfloat antiderivative(float x, vec3 origin, vec3 dir) {\n    //antiderivative for exp(-dot(origin+dir*x, origin+dir*x))\n    float od = dot(origin,dir);\n    return sqrt(acos(-1.)) * exp(od*od - dot(origin,origin)) * erf(od + x);\n}\n\nfloat lineintegral(vec3 a, vec3 b) {\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);\n}\n\nfloat pillar;\nfloat ground;\nfloat scene(vec3 p) {\n    p = asin(sin(p+1.));\n    pillar = length(p.xy)-.25;\n    ground = p.z;\n    return min(pillar, ground);\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) {\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p)-vec3( scene(k[0]),scene(k[1]),scene(k[2]) ) );\n}\n\nfloat bayer(vec2 fragCoord) {\n    return texelFetch(iChannel0, ivec2(fragCoord) % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float b = bayer(fragCoord);\n\n    vec3 cam = normalize(vec3(.8,uv));\n\tvec3 init = vec3(-4,0,0);\n    cam = erot(cam, vec3(0,1,0), .2);\n    init = erot(init, vec3(0,1,0), .2);\n    cam = erot(cam, vec3(0,0,1), iTime/5.);\n    init = erot(init, vec3(0,0,1), iTime/5.);\n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 150 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist * cam;\n        if (distance(p,init)>500.) break;\n    }\n    float lpillar = pillar;\n    bool is_pillar = dist == pillar;\n    \n    //this is the part were we use the line integral to get the glowing ball\n    float glow = lineintegral(p*.8,init*.8)*.8;\n    \n    \n    float fog = smoothstep(20.,0.,distance(p,init)); fog *= fog;\n\tvec3 n = norm(p);\n\tvec3 r = reflect(cam,n);\n    \n    float tex = texture(iChannel1, p).x;\n    tex = texture(iChannel1, p/2.+tex/10.).x;\n    float ss = smoothstep(-.01,.01,scene(p-normalize(p)*.01));\n    float ao = smoothstep(-.1,.1,scene(p+n*.1));\n    float diffdot = dot(n,-normalize(p));\n    float diff = max(diffdot,0.) + diffdot*.1+.1;\n    float spec = max(dot(r,-normalize(p)),0.);\n    float fres = 1.-abs(dot(cam,n))*.98;\n    vec3 matcol = is_pillar ? vec3(0.9,.3,.05) : vec3(0.4,.4,.45);\n    if (is_pillar) matcol = erot(matcol, normalize(sin(-p)), .4)*.7+.3;\n    vec3 col = matcol*mix(diff,ss,.5)*ao*(tex*.1+.9);\n    if (is_pillar) col += fres*pow(spec,20.-tex*tex*15.)*.5;\n    \n    //reflection\n    bool hit2;\n    vec3 p2 = p + n*.1;\n    for (int i = 0; i < 20 && !hit2; i++) {\n        dist = scene(p2);\n        hit2 = dist*dist < 1e-6;\n        p2 += dist * r;\n        if (distance(p2,p)>50.) break;\n    }\n\n    float factor = 1./(1.+distance(p2,p)+dist);\n    vec3 n2 = norm(p2);\n    float refdiff = 1.-max(dot(n2,-normalize(p2)),0.)*.4;\n   \tglow += lineintegral(p2*.8,p*.8)*.1*fres*(tex*.4+.6);\n    col *= 1.-factor*fres*refdiff*(tex*.5+.5);\n    \n    //cast shadows\n    float mindist = 1000.;\n    vec3 minpoint;\n    bool lighthit = false;\n    for (int i = 0; i < 25; i++) {\n        vec3 point = mix(p+n*.05,vec3(0),(float(i+1)+b)/26.);\n        float dist = scene(point);\n        if (dist < mindist) {\n            mindist = dist;\n            minpoint = point;\n        }\n    }\n    float sharpness = distance(p,minpoint);\n    float shadow = smoothstep(-.05-sharpness/20.,.1,mindist)*.8;\n    shadow += smoothstep(-.1-sharpness/10.,.2,mindist)*.2;\n    \n    fragColor.xyz = (hit ? col : vec3(.1))*fog*shadow;\n    fragColor += glow;\n    fragColor = smoothstep(vec4(-.3),vec4(1.3),sqrt(fragColor)) + b/128.;\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 39, "src": "/media/a/27012b4eadd0c3ce12498b867058e4f717ce79e10a99568cca461682d84a4b04.bin", "ctype": "volume", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByzV.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 235, 255, 255, 318], [320, 320, 374, 437, 547], [549, 549, 585, 585, 710], [740, 740, 761, 761, 869], [871, 871, 909, 909, 971], [1028, 1028, 1058, 1058, 1134], [1136, 1136, 1166, 1166, 1278], [1280, 1280, 1299, 1299, 1415], [1417, 1417, 1446, 1446, 1509]], "test": "untested"}
{"id": "3lBczV", "name": "Fractal asteroid field", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/wlBczy]\"planets with moons\"[/url] shader, but it looks more like a field of asteroids.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "planets"], "likes": 1, "viewed": 325, "published": 3, "date": "1594783189", "time_retrieved": "2024-07-30T20:55:27.342714", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(inout vec3 p,float i) {\n    p += sin(p.yzx*i/50.0)*25.0/i;\n    p += sin(p.yzx*10.0)/20.0;\n    return  (3.0 -.9/(i)+ sin(p.x)+cos(p.y)+cos(p.z))*(2.9);\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 300.0;\n    float k = 1.0;\n    float to_return = sceneSDF1(p,k);\n    for(int i = 0; i < 3; i++){\n        k *= 3.0;\n\t\tp *= 3.0;\n        to_return = min(to_return, to_return*1.5/k+sceneSDF1(p,k/4.0));\n    }\n    return to_return;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 c1 = vec3(sceneSDF(p/10.0),sceneSDF(p/4.0),sceneSDF(p/6.0));\n    return (sin(c1))*vec3(.5)/5.0+vec3(.4,.3,.3);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    //viewDir.xz *= sin(iTime)/2.0+1.0;\n    \n    vec3 eye = vec3(5.0, 5.0, 5.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "vec2 sound1(int t)\n{\n    t = (t*(((t/5/4096)%5+(t*t/3/4096)%3+(t/7/4096)%7-(t/2/4096)%2)))|t>>4|t>>5&t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBczV.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[491, 491, 530, 530, 659], [661, 661, 684, 684, 921], [923, 923, 951, 951, 1073], [1075, 1496, 1587, 1587, 1899], [1914, 2168, 2233, 2233, 2365], [2367, 2456, 2485, 2485, 2795], [2797, 3289, 3429, 3429, 4019], [4021, 4391, 4476, 4476, 4834], [4836, 5163, 5212, 5247, 5378], [5380, 5380, 5437, 5437, 6560]], "test": "untested"}
{"id": "3tSczK", "name": "Color by Something", "author": "yonatan", "description": "This started out as https://twitter.com/gaziya5/status/1277518357219205120", "tags": ["fractal"], "likes": 4, "viewed": 343, "published": 3, "date": "1594765975", "time_retrieved": "2024-07-30T20:55:28.215380", "image_code": "#define r (iResolution.xy)\n#define t iTime\n\n#define M(q)q*=mat2(sin(t*.1-t/s+vec4(0,11,33,0)))\n\nvoid mainImage( out vec4 o, in vec2 FC )\n{\n    o=vec4(0);\n\tfloat s,g,e,i,j,m;\n    for(;i++<20.;) {\n        vec3 p=g*vec3((FC.xy*2.-r)/r.y,1);\n        p.z--;\n        e=s=2.;\n        for(int i;i++<12;s+=s)M(p.xy),M(p.yz),p=abs(p)-.3,e=min(e,(length(p)+1.)/s),p+=p;g+=e;o.xyz+=p/s/e;\n    }\n    o.xyz*=log(8./e)*.005;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSczK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[96, 96, 138, 138, 411]], "test": "untested"}
{"id": "WlByzK", "name": "Superfluid helium", "author": "michael0884", "description": "Trying out cubemap based simulations. A 128^3 simulation domain.\nQuantum vortex rings\nhttps://www.damtp.cam.ac.uk/user/ngb23/publications/review.pdf", "tags": ["2d", "3d", "data", "landau", "ginsburg"], "likes": 24, "viewed": 515, "published": 3, "date": "1594764831", "time_retrieved": "2024-07-30T20:55:29.086052", "image_code": "// Fork of \"Wave equation 3D\" by michael0884. https://shadertoy.com/view/WtBcDz\n// 2020-07-08 14:45:14\n\n// Fork of \"Cubemap utils\" by rory618. https://shadertoy.com/view/wdsBRn\n// 2020-07-06 22:07:44\n\n// iq's smooth HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n//trilinear sampling\nvec4 S(vec3 x)\n{\n    vec4 X = vec4(x, 0.);\n    float zf = fract(X.z);\n    float zi = floor(X.z);\n    X.z = zi;\n    vec3 r0 = XYFaceToRayDir(getC(X));\n    vec3 r1 = XYFaceToRayDir(getC(X+vec4(0,0,1,0)));\n    return mix(texture(iChannel0, r0),texture(iChannel0, r1),zf);\n}\n\nfloat rho(vec3 x)\n{\n    x = x + vec3(B)*0.5;  \n    vec3 b = step(2., x)*step(x, vec3(B) -2.);\n    vec4 v = S(x);\n    return b.x*b.y*b.z*abs(1. - dot(v.xy,v.xy));\n}\n\nvec4 color(vec3 x)\n{\n    x = x + vec3(B)*0.5;  \n    vec3 b = step(2., x)*step(x, vec3(B) -2.);\n    vec4 v = S(x);\n    float r = b.x*b.y*b.z*abs(1. - dot(v.xy,v.xy));\n    float alpha = smoothstep(1.,0.3, r);\n    float angle = atan(v.y, v.x)/(2.*PI);\n    vec3 c = hsv2rgb(vec3(angle, 1., r)); \n    return vec4(c, alpha);\n}\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(0.25,-0.25, 0.25, -0.25);\n    return   (e.zwwz*rho( pos + e.xyy ) + \n  \t\t\t  e.wwzz*rho( pos + e.yyx ) + \n\t\t\t  e.wzwz*rho( pos + e.yxy ) + \n              e.zzzz*rho( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\nvec3 ray; vec3 cpos; vec2 angles;\nmat3 rmat;\nvec2 p;\nvec3 getRay(vec2 pos)\n{\n    rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float size = min(iResolution.y/3., iResolution.x/4.);\n    \n    //setup camera\n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.4*iTime, PI*0.5+0.5*sin(0.35*iTime));\n    cpos = -camd*getRay(R*0.5);\n    ray = getRay(I);\n    \n    vec4 c = vec4(0., 0., 0., 1.);\n    float td = 0.;\n    float dtd = 5.; //+ 10.*InterleavedGradientNoise(I, iFrame);\n    for(int i = 0; i < 75; i++)\n    {\n        vec4 col = color(cpos + ray*td);\n     \tfloat r = length(col.xyz);\n        dtd = 1./(0.4 + 10.*r*r*r);\n        td += dtd;\n        c.w = c.w*col.w;\n        if(c.w < 0.01) break;\n        c.xyz += 8.*col.xyz*col.xyz*(1. - col.w)*dtd; \n    }\n    \n    if(c.w < 0.01)\n    {\n        vec3 p = cpos + ray*td;\n        vec4 g = calcGrad(p);\n        vec3 n = -normalize(g.xyz);\n        vec3 r = reflect(ray, n);\n        c.xyz += 0.5*n.z + 0.5 + texture(iChannel3, r.xzy).xyz;\n    }\n    else\n    {\n        c.xyz += 0.5*texture(iChannel2, ray.xzy).xyz;\n    }\n   \n    \n    \n    \n    \n    O = tanh(1.*c);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define dt 0.6\n#define freq 0.04\n\n//sample the domain\nvec4 S(ivec4 X)\n{\n    vec3 r = XYFaceToRayDir(getC(vec4(X)));\n    return texture(iChannel0, r);\n}\n\n//add a wave torus\n//t: x - radius, y - thickness, z - rotation speed 1, w - rotation speed 2; \nvoid wave_torus(inout vec2 psi, vec3 p, vec4 t)\n{\n    float angle1 = t.w*atan(p.x, p.z); \n    vec2 q = vec2(length(p.xz)-t.x,p.y)/t.y;\n    float angle2 = t.z*atan(q.y, q.x);\n    float angle = (angle1 + angle2)*smoothstep(3.*t.x, 0.5*t.x, length(q));\n    //make a zero ring\n  \tpsi *= ( 1. - exp(-dot(q,q)) );\n    //rotate the phase to make it move\n    psi *= Rot(angle);\n}\n\nvoid mainCubemap( out vec4 Q, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{        \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n   \tivec4 X = getX(XYFace);\n    \n    if(X.w == 0)\n    {\n    \tQ = S(X);\n    \tvec4 L = (S(X + DX.zyyy) + S(X + DX.xyyy) +\n        \t\t  S(X + DX.yzyy) + S(X + DX.yxyy) +\n         \t\t  S(X + DX.yyzy) + S(X + DX.yyxy))/6. -  Q;\n    \n        //schrodinger equation integraion\n        if(iFrame%2 == 0)\n        \tQ.x += dt*(L.y - Q.y*F(Q.xy));\n        else\n        \tQ.y -= dt*(L.x - Q.x*F(Q.xy));\n        \n    \tQ.xy = Rot(freq*dt)*Q.xy;\n        \n        vec3 x = vec3(X.xyz);\n        vec3 border = smoothstep(5.,0., x)*smoothstep(vec3(B)-5.,vec3(B),x);\n        \n        //normalization border conditions\n        Q.xy = mix(Q.xy, vec2(1.,0.), pow(border.x*border.y*border.z,0.2));\n        \n        \n        if(iFrame%1000 == 0)\n        {\n            \n          \n        }\n        \n        if(iFrame < 200)\n        {\n            Q = vec4(1,0,0,0);\n            wave_torus(Q.xy, x - vec3(B)*vec3(0.55,0.7,0.5), vec4(10,1.5,-1.,0.));\n            wave_torus(Q.xy, x - vec3(B)*vec3(0.55,0.7,0.5), vec4(20,1.5,-1.,0.));\n             wave_torus(Q.xy, x - vec3(B)*vec3(0.55,0.7,0.5), vec4(30,1.5,-1.,0.));\n            wave_torus(Q.xy, x - vec3(B)*vec3(0.45,0.3,0.5), vec4(10,1.5,1.,0.));\n             wave_torus(Q.xy, x - vec3(B)*vec3(0.45,0.3,0.47), vec4(20,1.5,1.,0.));\n             wave_torus(Q.xy, x - vec3(B)*vec3(0.45,0.3,0.47), vec4(30,1.5,1.,0.));\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.14159265\n\n//render range\n#define range 500.\n#define FOV 2.\n#define camd 75.\n\n//number of variables\n#define VAR 3\n\n#define CUBE 1024\n\n//the domain\n#define B ivec3(128,128,128)\n\n#define DX ivec3(-1, 0, 1)\n\n\n//nonlinear potential\nfloat F(vec2 psi)\n{\n    return -0.46*(1. - length(psi));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//convert to domain coordinates\nivec4 getX(ivec3 XYface)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int var = XYface.z/s;\n    ivec2 z2 = XYface.xy/B.xy;\n    int Z = z2.x + z2.y*N.x + (XYface.z%s)*N.x*N.y;\n    ivec2 XY = XYface.xy%B.xy;\n    \n    return ivec4(XY, Z, var);\n}\n\n//convert to cubemap coordinates\nvec3 getC(vec4 p)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int pz = int(p.z);\n    ivec3 z3 = ivec3(pz%N.x, (pz/N.x)%N.y, pz/(N.x*N.y));\n    vec2 XY = p.xy + vec2(z3.xy*B.xy);\n    \n    return vec3(XY, p.w*float(s) + float(z3.z));\n}\n\n\nfloat G(vec3 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec3 x)\n{\n    return exp(-length(x));\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1,     0,        0,\n                         0,  cos(a.y), sin(a.y), \n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x),  sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0,            0,    1); \n   return phi_rot*theta_rot;\n}\n\n\n\nvec3 XYFaceToRayDir(vec3 p){\n    vec2 x = vec2(p-512.) + 0.5;\n           if (p.z==0.){     return vec3( 512.,-x.y,-x.x);\n    } else if (p.z==1.){     return vec3( x.x, 512., x.y);\n    } else if (p.z==2.){     return vec3( x.x,-x.y, 512.);\n    } else if (p.z==3.){     return vec3(-512.,-x.y, x.x);\n    } else if (p.z==4.){     return vec3( x.x,-512.,-x.y);\n    } else if (p.z==5.){     return vec3(-x.x,-x.y,-512.);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512., -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 239, 266, 266, 444], [446, 467, 483, 483, 737], [739, 739, 758, 758, 902], [904, 904, 924, 924, 1224], [1226, 1226, 1256, 1256, 1474], [1529, 1529, 1552, 1552, 1679], [1959, 1959, 2000, 2000, 2997]], "test": "untested"}
{"id": "3lByRK", "name": "Analytic Line Integral Fog", "author": "blackle", "description": "analytic integral for fog with the density `pow(dot(sin(origin + x*dir), vec3(1), 2.);` currently have problems with divisions by zero\n\non the left is one component, on the right are 50 summed up", "tags": ["fog", "analytic", "integral", "lineintegral"], "likes": 8, "viewed": 517, "published": 3, "date": "1594758165", "time_retrieved": "2024-07-30T20:55:29.939770", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//shitty way to prevent division by zero. if b is zero, add a little bit to it.\nvec3 div(vec3 a, vec3 b) {\n    b += vec3(equal(b,vec3(0)))*.01;\n    return a/b;\n}\n\nfloat antiderivative(float x, vec3 origin, vec3 dir) {\n    //antiderivative for pow(dot(sin(origin + x*dir), vec3(1), 2.);\n    mat3 A = mat3(1,1,0,-1,0,1,0,-1,-1);\n    mat3 B = mat3(1,1,0,1,0,1,0,1,1);\n    vec3 Q = origin + dir*x;\n    vec3 integral = div(sin(A*Q),(A*dir)) - div(sin(B*Q),(B*dir)) + div((2.*Q-sin(2.*Q)),(4.*dir));\n    return dot(integral, vec3(1));\n}\n\nfloat lineintegral(vec3 a, vec3 b) {\n    float len = distance(a, b);\n    vec3 dir = (b-a)/len;\n    return antiderivative(len,a,dir) - antiderivative(0.,a,dir);\n}\n\nfloat scene(vec3 p) {\n    p = asin(sin(p+1.));\n    return length(p)-1.;\n}\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\n#define FK(k) floatBitsToInt(k*k/7.)^floatBitsToInt(k)\nfloat hash(float a, float b) {\n    int x = FK(a), y = FK(b);\n    return float((x*x-y)*(y*y+x)-x)/2.14e9;\n}\n\nvec3 hash3(float a, float b) {\n    float s1 = hash(a, b);\n    float s2 = hash(s1, b);\n    float s3 = hash(s2, b);\n    return vec3(s1,s2,s3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1,uv));\n\tvec3 init = vec3(-4,0,0);\n    cam = erot(cam, vec3(0,1,0), .2);\n    init = erot(init, vec3(0,1,0), .2);\n    cam = erot(cam, vec3(0,0,1), iTime/5.);\n    init = erot(init, vec3(0,0,1), iTime/5.);\n    init.x += iTime;\n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 100 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p += dist * cam;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 a = p; vec3 b = init; float scale = 1.;\n    float fog = lineintegral(a,b)/20.;\n    \n    if (uv.x > 0.) {\n    \t//sum up multiple different versions of the fog\n    \tfor (int i = 0; i < 50; i++) {\n            //random rotation\n        \tvec3 ax = normalize(tan(hash3(float(i),14353.)));\n        \tfloat ro = hash(float(i),66123.)*10.;\n        \ta = erot(a,ax,ro);\n        \tb = erot(b,ax,ro);\n        \tfog += lineintegral(a*scale,b*scale)/sqrt(scale);\n       \t\tscale *= 1.06;\n    \t}\n\t\tfog /= 2500.;\n\t}\n\n    fragColor = sqrt(vec4(fog));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByRK.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 274, 300, 300, 355], [357, 357, 411, 479, 724], [726, 726, 762, 762, 887], [889, 889, 910, 910, 962], [964, 964, 1002, 1002, 1064], [1121, 1121, 1151, 1151, 1227], [1229, 1229, 1259, 1259, 1371], [1373, 1373, 1430, 1430, 2504]], "test": "untested"}
{"id": "tljyRG", "name": "Overlapping hextiles", "author": "mrange", "description": "License CC0: Overlapping hextiles\nThere are many examples on Shadertoy of overlapping rectangular tiling. Thought ST could need (another?) an example of how to do overlapping hex tiles.", "tags": ["2d", "hextiling"], "likes": 8, "viewed": 479, "published": 3, "date": "1594725752", "time_retrieved": "2024-07-30T20:55:30.831387", "image_code": "// License CC0: Overlapping hextiles\n//  There are many examples on Shadertoy of overlapping rectangular tiling. \n//  Thought ST could need (another?) an example of how to do overlapping hex tiles.\n    \n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot60    = MROT(TAU/6.0);\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst vec2 off1     = normalize(vec2(0.5, 0.0));\nconst vec2 off2     = rot60*off1;\nconst vec2 off3     = rot60*off2;\nconst vec2 off4     = rot60*off3;\nconst vec2 off5     = rot60*off4;\nconst vec2 off6     = rot60*off5;\nconst vec2 idx1     = vec2(+2.0, +0.0);\nconst vec2 idx2     = vec2(+1.0, +1.0);\nconst vec2 idx3     = vec2(-1.0, +1.0);\nconst vec2 idx4     = vec2(-2.0, +0.0);\nconst vec2 idx5     = vec2(-1.0, -1.0);\nconst vec2 idx6     = vec2(+1.0, -1.0);\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(dot(p1, p1) < dot(p2, p2)));\n  vec2 n = round((p3 - p + hsz)/hsz);\n  p = p3;\n\n  return round(n);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// Single cell distance field\nfloat cell(vec2 p, vec2 n) {\n  float a = hash(n+sqrt(3.0));\n  rot(p, TAU*a+TIME);\n  float d0 = box(p, vec2(0.5, 0.25)*mix(0.25, 1.25, psin(TAU*a+TIME)));\n  return d0;\n}\n\nfloat df(vec2 p) {\n  // Close to origo seems the cell index is computed incorrectly\n  p += 100.0;\n  vec2 hp = p;\n  vec2 hn = hextile(hp);\n  \n  float d = 1E6;\n  // The current cell\n  d = min(d, cell(hp, hn));\n  // Take union with all surrounding cells to support overlapping distance fields\n  d = min(d, cell(hp - off1, hn - idx1));\n  d = min(d, cell(hp - off2, hn - idx2));\n  d = min(d, cell(hp - off3, hn - idx3));\n  d = min(d, cell(hp - off4, hn - idx4));\n  d = min(d, cell(hp - off5, hn - idx5));\n  d = min(d, cell(hp - off6, hn - idx6));\n    \n  return d;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  float s = 0.25;\n  float d = df(p/s)*s;\n  \n  float aa = 4.0/RESOLUTION.y;\n  \n  vec3 col = vec3(0.0);\n  \n  col = mix(col, vec3(1.0), smoothstep(-aa, 0.0, -d));\n  col += vec3(0.5)*pcos(300.0*d);\n\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyRG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[964, 964, 988, 988, 1058], [1060, 1060, 1081, 1081, 1110], [1112, 1112, 1133, 1133, 1162], [1164, 1164, 1197, 1197, 1282], [1284, 1284, 1315, 1315, 1341], [1343, 1343, 1370, 1370, 1446], [1448, 1448, 1476, 1575, 1766], [1768, 1768, 1807, 1807, 1896], [1898, 1898, 1937, 1937, 1966], [1968, 1998, 2026, 2026, 2166], [2168, 2168, 2186, 2251, 2728], [2730, 2730, 2759, 2759, 2970], [2972, 2972, 3024, 3024, 3184]], "test": "untested"}
{"id": "Wt2yzG", "name": "Best Friend Cube", "author": "blackle", "description": "some new shitty way to fake reflections in this extremely specific circumstance", "tags": ["bep"], "likes": 27, "viewed": 569, "published": 3, "date": "1594695385", "time_retrieved": "2024-07-30T20:55:31.704053", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat GaborNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<5.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        //random rotation in 3d. the +.1 is to fix the rare case that g == vec3(0)\n        //https://suricrasia.online/demoscene/functions/#rndrot\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat super(vec2 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nfloat box(vec2 p, vec2 d, float es) {\n    vec2 q = abs(p)-d;\n    vec2 qq = max(q,0.);\n    return mix(super(qq),length(qq),es) +min(0.,max(q.x,q.y));\n}\n\nvec3 distorted_p;\nfloat plate;\nfloat bx;\nfloat bump;\nfloat scene(vec3 p) {\n    float plateangle = atan(p.x,p.y);\n    \n    //different noise for each dimension\n    vec3 distort = vec3(0);\n    distort.x += GaborNoise(p/2., iTime*3., 1.15)*.3;\n    distort.y += GaborNoise(p/2.+10., iTime*3., 1.15)*.3;\n    distort.z += GaborNoise(p/2.+20., iTime*3., 1.15)*.3;\n\n    float es = smoothstep(0.,.3,GaborNoise(p*2., 0., 1.15));\n    plate = box(vec2(p.z+1.6,length(p.xy)), vec2(0.1,2.5+sin(plateangle*23.)*.004 -abs(es)*.001 ), es*.8+.2 )-.07;\n    plate = min(plate, box(vec2(p.z+6.6,length(p.xy)),vec2(5.,.8-abs(es)*.001),0. ));\n\n    p += distort;\n\n    distorted_p = p;\n    vec3 ap = abs(p);\n    bump = min(ap.x,min(ap.y,ap.z));\n    bump = smoothstep(0.,.1,bump);\n    bx = box(p,vec3(1))-.3-bump*.05;\n    return min(bx,plate);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nfloat bayer(vec2 fragCoord) {\n    return texelFetch(iChannel0, ivec2(fragCoord) % 8, 0).x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-10.,0,-0.5);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    float dist;\n    for (int i = 0; i < 250 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam*.8;\n        if (distance(p,init)>50.) break;\n    }\n    bool pl = dist == plate;\n    float lbx = bx;\n    float lb = bump;\n    vec3 local_coords = distorted_p;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.05,.05,scene(p+vec3(.05)/sqrt(3.)));\n    float rao = smoothstep(-.2,.1,scene(p+r*.1)) * smoothstep(-.4,.1,scene(p+n*.1));\n    float tex = GaborNoise(local_coords*3., 0., 1.5)+.5;\n    float diff = mix(length(asin(sin(n*2.)*.9)*0.5+0.5)/sqrt(3.),ss,.2)+.1;\n    float spec1 = length(asin(sin(r*4.)*.9)*0.5+0.5)/sqrt(3.);\n    float spec2 = length(asin(sin(r*3.)*.9)*0.5+0.5)/sqrt(3.);\n    float specpow = mix(2.,5.,tex);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n\n    vec3 col1 = vec3(0.7,0.3,0.4)*diff + pow(spec2,specpow)*frens*.5;\n    vec3 col2 = vec3(0.7)*(ss*.8+.2) + pow(spec1*1.1,40.)*frens + spec1*frens*.3;\n\n    float bgdot = length(asin(sin(cam*3.5)*.8)*0.4+0.6)/sqrt(3.);\n    vec3 bg = vec3(.2,.2,.3) * bgdot*bgdot + pow(bgdot, 10.)*2.;\n    \n    float tex2 = smoothstep(0.1,.8,GaborNoise(p*4., 0., 1.2));\n    vec3 bounce = p+r*lbx*(2.-tex2);\n    float rao2 = smoothstep(-lbx,lbx,scene(bounce));\n    vec3 bouncecol = mix(vec3(.7,.3,0.4), vec3(.8), smoothstep(-.8,.8,bounce.x*bounce.y*bounce.z));\n    vec3 pedistal = vec3(.1)*spec1 + pow(spec1, 10.-tex2*2.);\n    if (n.z>.99) pedistal = mix(bouncecol*frens*.4, pedistal, rao2);\n    \n    vec3 col = mix(col1,col2,smoothstep(-.05,.05,local_coords.x*local_coords.y*local_coords.z));\n    col *= lb*.3+.7;\n    if (pl) col = pedistal;\n    fragColor.xyz = hit ? rao*col : bg;\n    fragColor *= 1.- dot(uv,uv)*.6;\n    fragColor = sqrt(smoothstep(-.01, 1.1, fragColor));\n}", "image_inputs": [{"id": 28, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yzG.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 340, 385, 1045], [1047, 1047, 1068, 1068, 1100], [1102, 1102, 1123, 1123, 1155], [1157, 1157, 1184, 1184, 1268], [1270, 1270, 1307, 1307, 1420], [1475, 1475, 1496, 1496, 2241], [2243, 2243, 2262, 2262, 2378], [2380, 2380, 2409, 2409, 2472], [2474, 2474, 2531, 2531, 4877]], "test": "untested"}
{"id": "WljcRG", "name": "Another xor \"automaton\"", "author": "jarble", "description": "This animation has many patterns that resemble cellular automata. This is based on [url=https://www.shadertoy.com/view/wtlcR8]another pattern[/url] that I found.", "tags": ["xor"], "likes": 44, "viewed": 1020, "published": 3, "date": "1594683337", "time_retrieved": "2024-07-30T20:55:32.554779", "image_code": "//modified from https://www.shadertoy.com/view/wtlcR8\nvoid mainImage(out vec4 O, vec2 U) {\n  int x = int(U),\n      y = int(U.y + 30. * iTime),\n      r = x^y;\n   O = vec4( abs(r*r*r)/(y+int(iTime*50.)) % 9970 < 1000 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 90, 90, 219]], "test": "untested"}
{"id": "wlBczy", "name": "Planets with moons", "author": "jarble", "description": "It's a galaxy of fractal planets with many \"moons\" or satellites around them.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "planets"], "likes": 3, "viewed": 419, "published": 3, "date": "1594677572", "time_retrieved": "2024-07-30T20:55:33.325717", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    vec3 c1 = vec3(sceneSDF(p/10.0),sceneSDF(p/4.0),sceneSDF(p/6.0));\n    return (sin(c1))*vec3(.5)/3.0+vec3(.4,.3,.3);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.5, 0.5, 0.5);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    //viewDir.xz *= sin(iTime)/2.0+1.0;\n    \n    vec3 eye = vec3(5.0, 5.0, 5.0*iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 2.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF1(vec3 p,float i) {\n    p += sin(p.yzx*i/100.0)*50.0/i;\n    p += sin(p.yzx*30.0)/60.0;\n    return  (3.0 -.9/(i)+ sin(p.x)+cos(p.y)+cos(p.z))*(2.9);\n}\n\nfloat sceneSDF(vec3 p){\n    p /= 100.0;\n    float k = 1.0;\n    float to_return = sceneSDF1(p,k);\n    for(int i = 0; i < 2; i++){\n        k *= 5.0;\n\n        to_return = min(to_return, to_return*1.5/k+sceneSDF1(p*k,k/4.0));\n    }\n    return to_return;\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBczy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 210], [212, 633, 724, 724, 1036], [1051, 1305, 1370, 1370, 1502], [1504, 1593, 1622, 1622, 1932], [1934, 2426, 2566, 2566, 3156], [3158, 3528, 3613, 3613, 3971], [3973, 4300, 4349, 4384, 4515], [4517, 4517, 4574, 4574, 5697]], "test": "untested"}
{"id": "tlBczy", "name": "3D Wavelet Noise", "author": "blackle", "description": "An attempt to generalize https://www.shadertoy.com/view/wsBfzK to 3 dimensions and distort an SDF.", "tags": ["noise"], "likes": 55, "viewed": 1345, "published": 3, "date": "1594676976", "time_retrieved": "2024-07-30T20:55:34.093664", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<5.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        //random rotation in 3d. the +.1 is to fix the rare case that g == vec3(0)\n        //https://suricrasia.online/demoscene/functions/#rndrot\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nfloat super(vec3 p) {\n    return sqrt(length(p*p));\n}\n\nfloat box(vec3 p, vec3 d) {\n    vec3 q = abs(p)-d;\n    return super(max(q,0.))+min(0.,max(q.x,max(q.y,q.z)));\n}\n\nvec3 distorted_p;\nfloat scene(vec3 p) {\n    //different noise for each dimension\n    p.x += WaveletNoise(p/2., iTime*3., 1.15)*.3;\n    p.y += WaveletNoise(p/2.+10., iTime*3., 1.15)*.3;\n    p.z += WaveletNoise(p/2.+20., iTime*3., 1.15)*.3;\n    distorted_p = p;\n    return box(p,vec3(1))-.3;\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 cam = normalize(vec3(1.2,uv));\n    vec3 init = vec3(-7.,0,0);\n    \n    float yrot = 0.5;\n    float zrot = iTime*.2;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        zrot = 4.*mouse.x;\n    }\n    cam = erot(cam, vec3(0,1,0), yrot);\n    init = erot(init, vec3(0,1,0), yrot);\n    cam = erot(cam, vec3(0,0,1), zrot);\n    init = erot(init, vec3(0,0,1), zrot);\n    \n    vec3 p = init;\n    bool hit = false;\n    for (int i = 0; i < 250 && !hit; i++) {\n        float dist = scene(p);\n        hit = dist*dist < 1e-6;\n        p+=dist*cam*.9;\n        if (distance(p,init)>50.) break;\n    }\n    vec3 local_coords = distorted_p;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float ss = smoothstep(-.05,.05,scene(p+vec3(.05)/sqrt(3.)));\n    float tex = WaveletNoise(local_coords*3., 0., 1.5)+.5;\n    float diff = mix(length(sin(n*2.)*0.5+0.5)/sqrt(3.),ss,.7)+.1;\n    float spec = length(sin(r*4.)*0.5+0.5)/sqrt(3.);\n    float specpow = mix(3.,10.,tex);\n    float frens = 1.-pow(dot(cam,n),2.)*0.98;\n    vec3 col = vec3(0.7,0.2,0.4)*diff + pow(spec,specpow)*frens;\n    float bgdot = length(sin(cam*3.5)*0.4+0.6)/sqrt(3.);\n    vec3 bg = vec3(.2,.2,.3) * bgdot + pow(bgdot, 10.)*2.;\n    fragColor.xyz = hit ? col : bg;\n    fragColor = sqrt(fragColor);\n    fragColor *= 1.- dot(uv,uv)*.6;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBczy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 194, 232, 232, 294], [296, 296, 342, 387, 1047], [1049, 1049, 1070, 1070, 1102], [1104, 1104, 1131, 1131, 1215], [1235, 1235, 1256, 1297, 1508], [1510, 1510, 1529, 1529, 1645], [1647, 1647, 1704, 1704, 3131]], "test": "untested"}
{"id": "ttSczG", "name": "Slot canyon", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtBcWm]\"Crazy distorted caves\"[/url] shader.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 343, "published": 3, "date": "1594660667", "time_retrieved": "2024-07-30T20:55:35.045119", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 100.0;\n    return 1.5*vec3(.6+sin(sceneSDF(p*4.0))/4.0,.3,.2)*length(sin(vec3(sceneSDF(p/5.0),sceneSDF(p*2.0),sceneSDF(p*3.0))));\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(iTime*100.0,800.0+500.0*sin(iTime/5.0),0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+200.0)*400.0;\n\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 4.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\nfloat planet_surface(inout vec3 p,float i){\n    p = p*(1.0 - p.zyx/(size*10.0/i))/size;\n    p = (sin((p)/i+p.yzx/50.0))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p = vec3(1000.0,0,0)+sin(p/1000.0)*1000.0;\n    p /= scale*(10.0+.5*sin(p.yzx/25.0+p/25.0));\n    \n    float result = 0.0;\n    for(float i = 1.0; i < 9.0; i *= 3.0){\n        p = p*i;\n    \tresult = -planet_surface(p,i)/(i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*8.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 100.0;\n    return 1.5*vec3(.6+sin(sceneSDF(p*4.0))/4.0,.3,.2)*length(sin(vec3(sceneSDF(p/5.0),sceneSDF(p*2.0),sceneSDF(p*3.0))));\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)*scale*2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*100.0,800.0+500.0*sin(iTime/5.0),0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSczG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 245], [248, 669, 760, 760, 1127], [1142, 1396, 1461, 1461, 1593], [1595, 1684, 1713, 1713, 2023], [2025, 2517, 2657, 2657, 3267], [3269, 3639, 3724, 3724, 4139], [4141, 4468, 4517, 4552, 4683], [4685, 4685, 4712, 4712, 4861], [4863, 4863, 4920, 4920, 5572]], "test": "untested"}
{"id": "tljyRR", "name": "Hyperbolic Poincare Weave", "author": "Shane", "description": "A hyperbolic Poincare double sided Truchet weave that draws inspiration from Escher's Snake print and Mattz's \"Hyperbolic Truchet tiles\" example.", "tags": ["escher", "truchet", "geometry", "tile", "art", "hyperbolic", "poincare", "weave"], "likes": 129, "viewed": 2306, "published": 3, "date": "1594651656", "time_retrieved": "2024-07-30T20:55:36.003557", "image_code": "/*\n\n\tHyperbolic Poincare Weave\n\t-------------------------\n\n\n\tThis is a double sided Truchet weaved hyperbolic polygonal tiling of the \n    Poincare disc... which sounds more complex than it actually is, since it's \n    nothing more than an amalgamation of procedures that you'll find all over \n    Shadertoy.\n\n    The imagery itself draws minor inspiration from M. C. Escher's Snake print, \n    and was rendered in a graphic ink style.\n\n\tI've always admired Matt's \"Hyperbolic Truchet\" example, and have wanted\n\tto put my own version together for a while, but I knew it'd involve some\n\tcareful forethought, so put it aside until I was feeling energetic. However, \n    since that was never going to happen, I decided to fumble my through an\n    example anyway. :D\n\n\tIn regard to the Poincare disc side of things, it was helpful to reference\n\tMLA, SL2C and STB's examples -- All authors have really nice work on here,\n\twhich is well worth the look. STB's \"Hyperbolic Poincaré transformed\"\n\tworkings were more reminiscent of my own method (but nicer), so I adopted \n    his calculations for the initialization function.\n\n\tDouble sided Truchet patterns were BigWings's idea some time back... Others\n    may have done it, but none were advertising. :) Anyway,\tthey've been covered \n    before by both myself and others, if you wish to learn about that particular \n    aspect of this example.\n\n    Poincare disc tiling and hyperbolic transformations have also been covered \n    everywhere, so there are plenty of examples on the net and on Shadertoy \n    regarding that aspect as well. Having said that, I'm hoping I've provided \n    enough of an explanation here to give people a start.\n\n \tThere's not as much code here as you'd think. Especially for the Poincare \n\tdisc setup. However, the example is a little long winded, so I'll put up a\n\tvery basic example without the weave within the next day or two to give \n\tpeople something easier to consume.\n\n    The last thing I'll mention is that Poincare disc tiling is relatively\n\trudimentary in the grand scheme of things. However, this is not my area of\n\texpertise, so don't look into anything I've written too deeply. In fact, if\n\tyou happen to be one of the experts on Shadertoy, and you spot anything that \n    doesn't seem right, feel free to let me know.\n\t\n\n\n\n    Poincare disc examples:\n\n    // The hyperbolic transformation itself is based on STB's example here,\n    // which I was informed was based on the following:\n    //\n    // Conformal Models of the Hyperbolic Geometry - Vladimir Bulatov \n    // http://www.bulatov.org/math/1001/index.html\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n\t//\n    Hyperbolic Poincaré transformed - stb\n\thttps://www.shadertoy.com/view/3lscDf\n\n    // A beautiful example, and my reason for wanting to make one of these.\n    //\n\tHyperbolic Truchet tiles  - mattz \n    https://www.shadertoy.com/view/3llXR4\n\n\t// Like everyone else, I love the following example. However, be warned that \n    // it involves complex geometry. :)  Seriously though, Mattz can come up with \n    // solutions to problems in a few minutes that have utterly confounded me for \n    // weeks.\n    //\n\tHyperbolic Wythoff explorer - mattz \n\thttps://www.shadertoy.com/view/wtj3Ry\n\n*/\n\n\n// Regular pentagon tiling, which wouldn't work on the Euclidian plane, but\n// works just fine within the Poincare disc.\n//#define PENTAGON\n\n// Moving to the half plane model. It's a very simple transformation, so I\n// figured I may as well include it.\n//#define HALF_PLANE\n\n\n#define PI\t\t3.14159265\n#define TAU\t    6.28318531\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n/*\n// GPU based random function.\nfloat hash21(vec2 p){  \n\n    // IQ's vec2 to float hash.\n    return fract(sin(dot(p, vec2(127.619, 57.583)))*43758.5453); \n    \n    \n    // Attempting to fix accuracy problems on some systems by using\n    // a slight variation on Dave Hoskin's hash formula, here:\n    // https://www.shadertoy.com/view/4djSRW\n    //vec3 p3 = fract(vec3(p.xyx)*.1031);\n    //p3 += dot(p3, p3.yzx + 43.1723);\n    //return fract((p3.x + p3.y)*p3.z);\n    \n}\n*/\n\n// Fabrice's fork of \"Integer Hash - III\" by IQ: https://shadertoy.com/view/4tXyWN\nfloat hash21(vec2 f){\n\n    uvec2 p = floatBitsToUint(f);\n    p = 1664525U*(p>>1U^p.yx);\n    return float(1103515245U*(p.x^(p.y>>3U)))/float(0xffffffffU);\n}\n\nvoid swap(inout int a, inout int b){ int tmp = a; a = b; b = tmp; }\n// A swap without the extra declaration -- It works fine on my machine, but I'm\n// not game  enough to use it, yet. :)\n//void swap(inout int a, inout int b){ a = a + b; b = a - b; a = a - b; }\n\n \n// Very handy. I rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n\n// Poincare disc setup. Less work than you thiink is necessary.\n\n// N represents the number of polygon vertices, and Q is the number of \n// adjacent polygons to each vertex within the Poincare disc.\n//\n// For tilings to work, the following must be true: (P − 2)*(Q − 2)>4.\n//\n// For instance, 3 and 7 will work, but 4 and 4 will not.\n//\n// 3-7, 3-8, 4-5, 5-4, 6-4, 7-3.\n//\n// The further caveat with this particular example is that Q must be even\n// for the weave pattern to work... Why is a bit of a mystery to me. I'll \n// need to think about it, or wait for someone to explain. :)\n//\n#ifdef PENTAGON\nconst int N = 5;\t// Polygon vertices.\nconst int Q\t= 4;\t// Polygons meeting at a vertex.\n#else\nconst int N = 3;\t// Polygon vertices.\nconst int Q\t= 8;\t// Polygons meeting at a vertex.\n#endif\n\n\nfloat count; // Circle inversion count variable. \n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec3 initDomain(){\n    \n    // There are quite a few ways to calculate the initial circular domain \n    // values, simply because there are several solutions to the same geometric \n    // problems, which is all this is. In fact, as geometric situations go,\n    // this is not a particularly difficult one to solve.\n    \n    // Essentially, you're going to be reflecting points about polygonal edges, \n    // so you'll need the distance from your initial circle center to that of \n    // the center of the circle that runs adjacent to the current domain edges in\n    // order to perform a hyperbolic reflection. You'll need the radius of that \n    // circle as well. The distance and radius will depend directly upon how\n    // how many edges your polygon has and how many adjacent polygons (the\n    // number that meet at a vertex point) there are.\n\n    // The following is some highschool level circle and triangle geometry to \n    // get the values we're after. Of course, none of this will mean much without \n    // some imagery to refer to. I find the diagrams on the following page more \n    // helpful than most: http://www.malinc.se/noneuclidean/en/poincaretiling.php\n    //\n     \n    /*\n    float alpha = PI/float(Q);\n    float beta = PI/float(N);\n    float gamma = PI/2. - alpha;\n    \n    // I've left these in this form in order to help follow the logic in the\n    // diagram that I've linked to above (about half way down the page). However,\n    // converting to cos and sin, etc, would be better.\n    float a = tan(gamma);\n    float b = tan(beta);\n\n    // Initial polygon radius.\n\tfloat polyRad = sqrt((a - b)/(a + b));\n\n    //float OP = (d + 1./d)/2.; \n    //float OM = OP/cos(beta);\n    float centDist = (polyRad + 1./polyRad)/2./cos(beta); // OM, on the diagram link above.\n    float circRad = ((-polyRad + 1./polyRad)/2.)/cos(gamma); // AM, on the diagram.\n    \n    return vec3(centDist, circRad, polyRad);\n    */\n    \n    \n    // Shadertoy user, SLB, uses the following, which does the exact same\n    // thing, but tackles the problem from a different perspective. It can\n    // be derived from the calculations above (which I was bored enough\n    // to confirm), and since I find them cleaner, I'm using them instead. By \n    // the way, the measurements given back will differ after a few decimal\n    // places, so will produce a slightly different random pattern, but \n    // it's essentially the same thing.\n    //\n    // As an addendum, SLB informed me that the calculations were based on \n    // the following informative article:\n    //\n    // The Hyperbolic Chamber - Jos Leys\n    // http://www.josleys.com/article_show.php?id=83\n   \n    float piDivN = PI/float(N), piDivQ = piDivN + PI/float(Q) - PI/2.;\n    \n    // Helper variables.\n\tvec2 trig1 = vec2(cos(piDivN), sin(piDivN));\n    vec2 trig2 = vec2(cos(piDivQ), sin(piDivQ));\n    \n    // Distance from the current circular domain center to the adjacent\n    // circle center, and the radius of that circle. These values will be \n    // the same for all polygons.\n    float dist = trig1.x - trig2.x*trig1.y/trig2.y;\n    float rad = length(vec2(dist, 0.) - trig1);\n    \n    float d = max(dist*dist - rad*rad, 0.);\n\n    // The last value is the distance from the current center to each\n    // vertex point... so the radius, I guess. It's used as a scaling \n    // component.\n\treturn vec3(dist, rad, 1)/sqrt(d);\n    \n    /*\n    // Shorter version, based off of the geometric diagram in the article above. \n\tfloat a = sin(PI/float(N)), b = cos(PI/float(Q));\n    float d2 = cos(PI/float(N) + PI/float(Q))/a;\n    float r2 = 1./(b*b/a/a - 1.);\n    return sqrt(max(vec3(1. + r2, r2, d2*d2*r2), 0.));    \n    */\n}\n\n\n// Hyperbolically reflecting the polygon across each of its edges\n// via an inverse Mobius transform. If you can't picture this fromt the \n// example imagery, looking at an image regarding polygon reflection in \n// a Poincare disc will make it clearer.\n//\n// By the way, if you want to get more of an intuitive feel for circle \n// inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n// https://www.youtube.com/watch?v=sG_6nlMZ8f4\nvec2 transform(vec2 p, vec2 circ) {\n    \n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n     \n    float ia = (floor(atan(p.x, p.y)/TAU*float(N)) + .5)/float(N);\n    // Start with a point on the boundary of the circle, then use \n    // polar repetition to put it on all the edge boundaries...\n    // right in the middle of the edge, which makes sense.\n    vec2 vert = rot2(ia*TAU)*vec2(0, circ.x);\n   \n    // The radius squared of the circle domain you're reflecting to. \n    float rSq = circ.y*circ.y;\n    \n    // Circle inversion, which relates back to an inverse Mobius\n    // transformation. There are a lot of topics on just this alone, but \n    // the bottom line is, if you perform this operation on a point within\n    // the Poincare disk, it will be reflected. It's similar to the\n    // \"p /= dot(p, p)\" move that some may have used before.\n    vec2 pc = p - vert;\n    float lSq = dot(pc, pc);\n    \n    // If the distance (we're squaring for speed) from the current\n    // point to any of the edge vertex points is within the limits, \n    // hyperbolically reflect it.\n    if(lSq<rSq){\n         \n        p = pc*rSq/lSq + vert;\n        \n        // Attempting to add some extra randomness. Normally,\n        // you wouldn't have this here.\n        p = rot2(TAU/float(N)*(count + float(Q)))*p;\n        \n        \n        // If we have a hit, increase the counter. This value can be useful\n        // for coloring, and other things.\n        count++; \n       \n    }\n     \n    return p;\n}\n\n\n// IQ's signed distance to a quadratic Bezier. Like all of IQ's code, it's\n// quick and reliable. :)\n//\n// Quadratic Bezier - 2D Distance - IQ\n// https://www.shadertoy.com/view/MlKcDD\nfloat sdBezier(vec2 pos, vec2 A, vec2 B, vec2 C){\n  \n    // p(t)    = (1 - t)^2*p0 + 2(1 - t)t*p1 + t^2*p2\n    // p'(t)   = 2*t*(p0 - 2*p1 + p2) + 2*(p1 - p0)\n    // p'(0)   = 2*(p1 - p0)\n    // p'(1)   = 2*(p2 - p1)\n    // p'(1/2) = 2*(p2 - p0)\n    \n    vec2 a = B - A;\n    vec2 b = A - 2.0*B + C;\n    vec2 c = a * 2.0;\n    vec2 d = A - pos;\n\n     // If I were to make one change to IQ's function, it'd be to cap off the value \n    // below, since I've noticed that the function will fail with straight lines.\n    float kk = 1./max(dot(b,b), 1e-6); // 1./dot(b,b);\n    float kx = kk * dot(a,b);\n    float ky = kk * (2.0*dot(a,a)+dot(d,b)) / 3.0;\n    float kz = kk * dot(d,a);      \n\n    float res = 0.0;\n\n    float p = ky - kx*kx;\n    float p3 = p*p*p;\n    float q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    float h = q*q + 4.0*p3;\n\n    if(h >= 0.0) \n    { \n        h = sqrt(h);\n        vec2 x = (vec2(h, -h) - q) / 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));\n        float t = uv.x + uv.y - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 1 root\n        vec2 qos = d + (c + b*t)*t;\n        res = length(qos);\n    }\n    else\n    {\n        float z = sqrt(-p);\n        float v = acos( q/(p*z*2.0) ) / 3.0;\n        float m = cos(v);\n        float n = sin(v)*1.732050808;\n        vec3 t = vec3(m + m, -n - m, n - m) * z - kx;\n        t = clamp( t, 0.0, 1.0 );\n\n        // 3 roots\n        vec2 qos = d + (c + b*t.x)*t.x;\n        float dis = dot(qos,qos);\n        \n        res = dis;\n\n        qos = d + (c + b*t.y)*t.y;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        qos = d + (c + b*t.z)*t.z;\n        dis = dot(qos,qos);\n        res = min(res,dis);\n\n        res = sqrt( res );\n    }\n    \n    return res;\n}\n\n// Rendering the smooth Bezier segment. The idea is to calculate the midpoint\n// between \"a.xy\" and \"b.xy,\" then offset it by the average of the combined normals\n// at \"a\" and \"b\" multiplied by a factor based on the length between \"a\" and \"b.\"\n// At that stage, render a Bezier from \"a\" to the midpoint, then from the midpoint\n// to \"b.\" I hacked away to come up with this, which means there'd have to be a more\n// robust method out there, so if anyone is familiar with one, I'd love to know.\nfloat doSeg(vec2 p, vec4 a, vec4 b, float r){\n    \n    // Mid way point.\n    vec2 mid = (a.xy + b.xy)/2.; // mix(a.xy, b.xy, .5);\n    \n    // The length between \"a.xy\" and \"b.xy,\" multiplied by... a number that seemed\n    // to work... Worst coding ever. :D\n    float l = length(b.xy - a.xy)*1.732/6.; // ;//(1.4142 - 1.)/1.4142;\n \n    // Points on the same edge each have the same normal, and segments between them\n    // require a larger arc. There was no science behind the decision. It's just \n    // something I noticed and hacked a solution for. Comment the line out, and you'll \n    // see why it's necessary. By the way, replacing this with a standard semicircular \n    // arc would be even better, but this is easier.\n    if(abs(length(b.zw - a.zw))<.01) l = r; \n  \n    // Offsetting the midpoint between the exit points \"a\" and \"b\"\n    // by the average of their normals and the line length factor.\n    mid += (a.zw + b.zw)/2.*l;\n\n    // Piece together two quadratic Beziers to form the smooth Bezier curve from the\n    // entry and exit points. The only reliable part of this method is the quadratic\n    // Bezier function, since IQ wrote it. :\n    float b1 = sdBezier(p, a.xy, a.xy + a.zw*l, mid);\n    float b2 = sdBezier(p, mid, b.xy + b.zw*l, b.xy);\n    \n    // Return the minimum distance to the smooth Bezier arc.\n    return min(b1, b2);\n}\n\n \n\n// Regular Polygon SDF - BasmanovDaniil\n// https://www.shadertoy.com/view/MtScRG\nfloat Polygon(vec2 p, float vertices, float radius){\n\n    float segmentAngle = TAU/vertices;\n     \n    float angleRadians = atan(p.x, p.y);\n    float repeat = mod(angleRadians, segmentAngle) - segmentAngle/2.;\n    float inradius = radius*cos(segmentAngle/2.);\n    float circle = length(p);\n    return cos(repeat)*circle - inradius;\n   \n}\n\n// Mouse pointer inversion.\nvec2 mouseInversion(vec2 p){\n    \n    // Mouse coordinates.\n    vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    // Hack for the zero case instance. If someone has a better way,\n    // feel free to let me know.\n    if(length(m) < 1e-3) m += 1e-3; \n    // A hack to stop some craziness occurring on the border.\n    if(abs(m.x)>.98*.7071 || abs(m.y)>.98*.7071) m *= .98;\n    \n    // Taking the mouse point and inverting it into the circle domain.\n    // Feel free to check some figures, but all will get mapped to \n    // values that lie within circle radius.\n    float k = 1./dot(m, m);\n    vec2 invCtr = k*m; \n    float t = (k - 1.)/dot(p -invCtr, p - invCtr);\n    p = t*p + (1. - t)*invCtr;\n    p.x = -p.x; // Keep chirality. MLA does this. \n    \n    return p;\n    \n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    \n    \n    // Aspect correct coordinates: Actually, fragCoord is already in \n    // aspect correct form, so shifting and scaling is all that is\n    // required in this particular pixel shader environment.\n    vec2 uv = (2.*fragCoord - iResolution.xy)/iResolution.y;\n  \n    \n    #ifdef HALF_PLANE\n    // Moving to the half plane model.\n    const float sc = 4.;\n    uv.y += sc/2. + 1.;\n    uv /= dot(uv, uv)/sc;\n    uv.y -= 1.; \n    #else   \n    // Contracting things just a touch to fit the Poincare domain on \n    // the canvas.\n    uv *= 1.05;\n    #endif\n      \n    // Poincare coordinates.\n    vec2 p = uv;\n \n\n\n    // A bit of mouse inversion and rotation to begin with. You'll\n    // see this a lot in various hyperbolic examples, and others.\n    p = mouseInversion(p);\n        \n    // Perform some free rotation.\n    p = rot2(iTime/16.)*p;\n    \n    \n    // Inversion count. It's used for all kinds of things, like \n    // random number production, etc.\n    count = 0.;\n\n    \n    // Filling in the domain origin information: From left to right, it \n    // returns the distance between adjacent polygon centers, the adjacent \n    // polygon radius, and the current polygon radius. These values remain\n    // the same for all polygons throughout the hyperbolic plane, so this \n    // is all that's required to tile the disc.\n    vec3 domInfo = initDomain();\n    \n \n    // Performing multiple reflective inversions to fill out the disk. Due \n    // to the nature of the hyperbolic transform, the polygon tiles get \n    // smaller as you approach the outer disk, and never reach the edge. \n    // There are a bunch of proofs in complex analysis that illustrate\n    // this, but nothing shows it as well as a computer program. :)\n    // Drop the number of iterations and you'll see the process unfold.\n    //\n    // One more important thing I should mention is that there's a test\n    // within the transform function (if you're outside the domain) that \n    // would allow you to break early, but I'm bypassing that for \n    // simplicity. The function is cheap, so I'm letting it run through, \n    // but when speed is an issue, it should be considered.\n    for(int i=0; i<24; i++){\n        p = transform(p, domInfo.xy);\n    }\n    \n    // Handling the imagery outside the Poincare circle domain by inverting or\n    // mirroring it back into the circle so that it shows up... or something\n    // to that effect... It's been a while. Either way, this is what you do\n    // if you want to see the outside pattern. :)\n    //\n    // By the way, if you want to get more of an intuitive feel for circle \n    // inversion, I recommend Numberphile's \"Epic Circles\" video, here:\n    // https://www.youtube.com/watch?v=sG_6nlMZ8f4\n    if(length(p)> 1.) p /= dot(p, p); \n    \n      \n    // This isn't absolutely necessary, but scaling the transformed coordinates\n    // by the disk radius brings things into the zero to one range, which saves\n    // a lot of headaches when plotting vertex points, and so forth.\n    p /= (domInfo.z);\n    \n    // Smoothing factor: You could never really get this right. Super sampling\n    // would be the best option, but the cheap alternative is kind of OK.\n    float sf = .015;\n    // Reduces sparkling at the ring edges... Experimental, for now. \n    //float rsf = (2. - smoothstep(0., .2, abs(length(uv) - 1.) - .2));\n    //float sf = 4./iResolution.y*rsf;//(count*count + 1.);//fwidth(shape);// \n\n      \n    // Rendering the polygon with a standard routine. I you were after pixel \n    // precise imagery, you'd need to take the overlapping circle point route,\n    // or take it a step further and carve out edge circles... At some stage, \n    // I'd like to put together an extruded version, in which case, I'd take\n    // the aforementioned into account, but for now, this will work fine. :)\n    //\n    // By the way, it's possible to account for the warping a bit by pinching \n    // the local coordinates slightly to match the warped hyperbolic space. \n    // It's possible to use a cheap hacky method (see below), rather than the \n    // more advanced method suggested. However, the best way is to use some\n    // CSG within the transform function. I'll do that when I put an extruded\n    // version together at a later stage.\n    //float shape = Polygon(p*(1. - dot(p, p)*domInfo.z/3.), float(N), .72); // Pinched.\n    float shape = Polygon(p, float(N), .8);\n\n \n    \n    // Lines and vertex points.\n    vec2 vp[N];\n    float ln[N]; \n    \n    // Offset mid points (sitting either side of the midpoint).\n    // Shuffle array. This will be used to shuffle rendering order.\n    const int N2 = N*2;\n    vec4 mp[N2];\n    int shuff[N2];\n    \n    float vert = 1e5;\n    vec2 v0 = vec2(0, 1);\n    \n    for(int i = 0; i<N; i++){\n        vert = min(vert, length(p - v0) - .09);//.25*domInfo.z\n        vp[i] = v0;        \n        v0 = rot2(TAU/float(N))*v0;\n    }\n    \n\n    // Producing some colored segments based on the angle of the \n    // local polygon cell coordinates.\n    vec2 rp = rot2(float(count + 2.)*TAU/float(N))*(p);\n    float angl = mod(atan(rp.x, rp.y), TAU)*float(N2)/TAU;\n    float triSeg = (floorSm(angl, .1) + .5)/float(N2);\n    vec3 oCol = .55 + .45*cos(triSeg*TAU + vec3(0, 1, 2));\n    // Fire palette option... Interesting, but I'm giving it a down vote. :D\n    //vec3 oCol = pow(vec3(1.5, 1, 1)*max(triSeg, 0.), vec3(1, 3, 16));\n\n    // Debug coloring to test out various color combinations.\n    //oCol = vec3(1.2, .8, .5).xzy*(mod(count, float(N)) + 1.)/(float(N) + 1.); \n    //if(mod(float(count), 4.)>1.5) oCol *= vec3(1.2, 1.5, 1);\n    \n    \n    // Coloring up the canvas. All this was added in on the fly. Once you have\n    // access to the local coordinates and vertice information, you do\n    // whatever you want.\n    \n    // Background.\n    vec3 col = vec3(1, .99, .98);\n    \n    // The polygon. The default is a triangle, but others will work too.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, shape));\n    col = mix(col, oCol, 1. - smoothstep(0., sf, shape + .04));//.35*f*f\n\n    // Vertices.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, vert));\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(length(p) - 1.) - .09)));\n    \n \n\n    // Polygon side length. Even though they look like different lengths,\n    // they're hyperbolically the same.\n    float sLength = length(vp[0] - vp[1]);\n    \n    \n    for(int i = 0; i<N; i++){ \n        \n        // Initializing the shuffle array while we're here\n        shuff[i*2] = i*2;\n        shuff[i*2 + 1] = i*2 + 1;\n        \n        // Constructing the two points on either side of the midpoint and\n        // the respective normals to act as entry and exit points for\n        // the Bezier curves.\n        vec2 mpi = mix(vp[i], vp[(i + 1)%N], .5);\n        vec2 tangenti = normalize(mpi - vp[i]);\n        //\n        // The neat formulae above is how you'd calculate mid points in Euclidean \n        // geometry, whereas in this case, you have to calculate the mid point by rotating\n        // the vertex point to the mid point position, then using a known  center to mid \n        // point distance (neighbor to neighbor center to center minus initial radius)... \n        // However, I need to calculate proper edge tangents... I'll leave the\n        // approximations above, for now. :)\n        //vec2 mpi = (rot2(PI/float(N))*vp[i]/domInfo.z)*(domInfo.x - domInfo.y);\n        //vec2 tangenti = normalize(mpi.yx*vec2(1, -1));\n        \n        // Points flanking either side of the mid point above.\n        mp[i*2].xy = mpi - tangenti*sLength/6.;\n        mp[i*2 + 1].xy = mpi + tangenti*sLength/6.;\n        \n        // Respective normals, which are fed into a Bezier line curve formula. That thing\n        // is compicated as well, but thankfully, IQ calculated that. :)\n        mp[i*2].zw = tangenti.yx*vec2(1, -1);\n        mp[i*2 + 1].zw = tangenti.yx*vec2(1, -1);\n    \n    } \n    \n    \n    // Shuffling the variable array of points and normals -- Six is the maximum. I think \n    // this is the Fisher–Yates method, but don't quote me on it. It's been a while since \n    // I've used a shuffling algorithm, so if there are inconsistancies, etc, feel free to \n    // let me know.\n    //\n    // For various combinatorial reasons, some non overlapping tiles will probably be \n    // rendered more often, but generally speaking, the following should suffice.\n    //\n    //int index = N;\n    for(int i = N2 - 1; i>0; i--){\n        \n        // For less than three edges, skip the upper array positions.\n        if(i >= N2) continue;\n        \n        // Using the cell ID and shuffle number to generate a unique random number.\n        float fi = float(i);\n        \n        // Random number for each triangle: The figure \"s*3 + ioffs + 1\" is unique for\n        // each triangle... I can't remember why I felt it necessary to divide by 3,\n        // but I'll leave it in there. :)\n        float rs = hash21(vec2(count) + domInfo.xy + domInfo.z + fi/float(N2));\n        \n        // Other array point we're swapping with.\n        //int j = int(floor(mod(rs*float(index)*1e6, fi + 1.)));\n        // I think this does something similar to the line above, but if not, let us know.\n        int j = int(floor(rs*(fi + .9999)));\n        swap(shuff[i], shuff[j]);\n        \n        //swap(mp[i], mp[j]);\n        \n    }  \n     \n    \n    for(int i = 0; i<N; i++){   \n        \n        // Shuffled indices.\n        int j = shuff[i*2], jp1 = shuff[i*2 + 1];\n        \n        // Constructing each of the Bezier line segments. Each is\n        // rendered from one random entry point to a random exit.\n        // It's covered more thoroughly in my other examples, if\n        // you're interested in the process.\n        // \n        // Offset mid points, and their normal directions.\n        float lnOff = sLength/4.; // Quarter side length.\n        ln[i] = doSeg(p, mp[j], mp[jp1], lnOff) - .105;\n        \n        // Interwoven rings.\n        // Technically, you need a proper arc formula (which you can find in my \n        // other Truchet examples), but this will illustrate the general idea.\n        //ln[i] = abs(length(p - vp[i]) - sLength/1.75) - lw;\n    \n    }\n    \n    \n    // Fine shape lines. They need to be faded out near the outer ring edges.\n    // Hence, the esoteric ring blending add in.\n    float ringBlend = smoothstep(0., .235, abs(length(uv) - 1.) - .1);\n    float pat2 = abs(fract(shape*16.) - .5)*2. - .05; // Concentric dark lines.\n    col = mix(col, vec3(0), ringBlend*(1. - smoothstep(0., .5, pat2))*.7);\n    \n     for(int i = 0; i<N; i++){\n         \n         // Rendering the Bezier curves. There's a drop shadow, stroke,\n         // colored layer, and fine inner lines. All standard layering stuff.\n         \n         // Line pattern.\n         pat2 = abs(fract(ln[i]*16. + .5) - .5)*2. - .05;\n         pat2 = mix(1., 0., ringBlend*(1. - smoothstep(0., .5, pat2))*.7);\n         \n         // Bezier distance field layers.\n         vec3 bgC = col;\n         col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ln[i]))*.3);\n         col = mix(col, vec3(0), 1. - smoothstep(0., sf, ln[i]));\n         col = mix(col, mix(bgC*1.2, vec3(1, .97, .26), .85)*pat2, \n                   1. - smoothstep(0., sf, ln[i] + .04));\n         col = mix(col, col*1.3, 1. - smoothstep(0., sf, ln[i] + .085));\n         \n    }\n\n    \n    // Rendering an outer ring with fake shadwo and all that. Poincare disks can \n    // get pretty busy visually on the outer edges, so I figured this was a kind\n    // of artsy way to deal with it. There are others.\n    //float lu2 = length(uv - vec2(.3));\n    \n    // Rotate the coordinates, construct a right, and put a dial pattern on it.\n    uv*= rot2(iTime/16.);\n    float lu = length(uv); // Circle.\n    float ring = abs(lu - 1.) - .05; // Ring distance field.\n    \n    // Dial pattern.\n    float ang = atan(uv.x, uv.y)/TAU;\n    float pat = abs(fract(ang*72.) - .5)*2.;\n    pat = smoothstep(0., sf, pat - .125);\n    \n\n    // Rendering the drop shadow, etc.\n   \n    col = mix(col, vec3(0), (1. - smoothstep(0., sf*5., ring-.01))*.6);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf/2., ring)));\n\n    col = mix(col, vec3(1, .99, .98)*pat*.35 + .65, 1. - smoothstep(0., .005, ring + .02));\n    ring = max(ring + .02, lu - .995);\n    col = mix(col, vec3(.4)*pat, (1. - smoothstep(0., sf/3., ring)));\n   \n    \n    // Black and white imagery outside the ring to give it more of an ink art kind of feel.\n    col = mix(col, min( mix(col, vec3(1)*dot(col, vec3(.299, .587, .114)), \n                   min(lu*.7, 1.))*1.15, 1.),  1. - smoothstep(0., sf, 1.05 - lu));\n    \n    /*\n    // Subtle light... I wasn't feeling it. I was going to put in the whole refracted dome \n    // thing, but took the less is more option.\n    float spe = max(1. - lu2*lu2*2., 0.);\n    col = mix(col, col + pow(spe, 6.)*.05 + pow(spe, 16.)*.3, \n                   1. - smoothstep(0., sf, lu2 - .6));\n    col = mix(col, col + lu2*lu2, 1. - smoothstep(0., sf, lu2 - .25));\n    */\n    \n    fragColor = vec4(sqrt(max(col, 0.)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3627, 3660, 3682, 3682, 3740], [4216, 4299, 4320, 4320, 4454], [4456, 4456, 4492, 4492, 4523], [4720, 4862, 4895, 4895, 4984], [5836, 6304, 6322, 8958, 9985], [9988, 10431, 10466, 10734, 12137], [12140, 12324, 12373, 12569, 14053], [14055, 14548, 14593, 14620, 15903], [15908, 15989, 16041, 16041, 16326], [16328, 16356, 16384, 16415, 17141], [17143, 17143, 17197, 17405, 30239]], "test": "untested"}
{"id": "WlByzy", "name": "Neonwave style", "author": "mrange", "description": "License CC0: Neonwave style road, sun and city\nThe result of a bit of experimenting with neonwave style colors.", "tags": ["2d", "neonwave"], "likes": 25, "viewed": 1072, "published": 3, "date": "1594640245", "time_retrieved": "2024-07-30T20:55:36.778485", "image_code": "// License CC0: Neonwave style road, sun and city\n//  The result of a bit of experimenting with neonwave style colors.\n    \n#define PI          3.141592654\n#define TAU         (2.0*PI)\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvec3 hsv2rgb(vec3 c) {\n  const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n  vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n  return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat hash(in float co) {\n  return fract(sin(co*12.9898) * 13758.5453);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat mod1(inout float p, float size) {\n  float halfsize = size*0.5;\n  float c = floor((p + halfsize)/size);\n  p = mod(p + halfsize, size) - halfsize;\n  return c;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat planex(vec2 p, float w) {\n  return abs(p.y) - w;\n}\n\nfloat planey(vec2 p, float w) {\n  return abs(p.x) - w;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat sun(vec2 p) {\n  const float ch = 0.0125;\n  vec2 sp = p;\n  vec2 cp = p;\n  mod1(cp.y, ch*6.0);\n\n  float d0 = circle(sp, 0.5);\n  float d1 = planex(cp, ch);\n  float d2 = p.y+ch*3.0;\n\n  float d = d0;\n  d = pmax(d, -max(d1, d2), ch*2.0);\n\n  return d;\n}\n\nfloat city(vec2 p) {\n  float sd = circle(p, 0.5);\n  float cd = 1E6;\n\n  const float count = 5.0;\n  const float width = 0.1;\n\n  for (float i = 0.0; i < count; ++i) {\n    vec2 pp = p;\n    pp.x += i*width/count;\n    float nn = mod1(pp.x, width);\n    float rr = hash(nn+sqrt(3.0)*i);\n    float dd = box(pp-vec2(0.0, -0.5), vec2(0.02, 0.35*(1.0-smoothstep(0.0, 5.0, abs(nn)))*rr+0.1));\n    cd = min(cd, dd);\n  }\n  \n  return max(sd,cd);\n}\nvec3 sunEffect(vec2 p) {\n  float aa = 4.0 / RESOLUTION.y;\n\n  vec3 col = vec3(0.1);\n  vec3 skyCol1 = hsv2rgb(vec3(283.0/360.0, 0.83, 0.16));\n  vec3 skyCol2 = hsv2rgb(vec3(297.0/360.0, 0.79, 0.43));\n  col = mix(skyCol1, skyCol2, pow(clamp(0.5*(1.0+p.y+0.1*sin(4.0*p.x+TIME*0.5)), 0.0, 1.0), 4.0));\n  \n  p.y -= 0.375;\n  float ds = sun(p);\n  float dc = city(p);\n\n  float dd = circle(p, 0.5);\n \n  vec3 sunCol = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 1.0), clamp(0.5 - 1.0*p.y, 0.0, 1.0));\n  vec3 glareCol = sqrt(sunCol);\n  vec3 cityCol = sunCol*sunCol;\n  \n  col += glareCol*(exp(-30.0*ds))*step(0.0, ds);\n  \n\n  float t1 = smoothstep(0.0, 0.075, -dd);\n  float t2 = smoothstep(0.0, 0.3, -dd);\n  col = mix(col, sunCol, smoothstep(-aa, 0.0, -ds));   \n  col = mix(col, glareCol, smoothstep(-aa, 0.0, -dc)*t1);   \n  col += vec3(0.0, 0.25, 0.0)*(exp(-90.0*dc))*step(0.0, dc)*t2;\n\n//  col += 0.3*psin(d*400);\n\n  return col;\n}\n\nfloat ground(vec2 p) {\n  p.y += TIME*80.0;\n  p *= 0.075;\n  vec2 gp = p;\n  gp = fract(gp) - vec2(0.5);\n  float d0 = abs(gp.x);\n  float d1 = abs(gp.y);\n  float d2 = circle(gp, 0.05);\n\n  const float rw = 2.5;\n  const float sw = 0.0125;\n\n  vec2 rp = p;\n  mod1(rp.y, 12.0);\n  float d3 = abs(rp.x) - rw;\n  float d4 = abs(d3) - sw*2.0;\n  float d5 = box(rp, vec2(sw*2.0, 2.0));\n  vec2 sp = p;\n  mod1(sp.y, 4.0);\n  sp.x = abs(sp.x);\n  sp -= vec2(rw - 0.125, 0.0);\n  float d6 = box(sp, vec2(sw, 1.0));\n\n  float d = d0;\n  d = pmin(d, d1, 0.1);\n  d = max(d, -d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d = min(d, d6);\n  \n  return d;\n}\n\nvec3 groundEffect(vec2 p) {\n  vec3 ro = vec3(0.0, 20.0, 0.0);\n  vec3 ww = normalize(vec3(0.0, -0.025, 1.0));\n  vec3 uu = normalize(cross(vec3(0.0,1.0,0.0), ww));\n  vec3 vv = normalize(cross(ww,uu));\n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.5*ww);\n\n  float distg = (-9.0 - ro.y)/rd.y;\n\n  const vec3 shineCol = 0.75*vec3(0.5, 0.75, 1.0);\n  const vec3 gridCol = vec3(1.0);\n\n  vec3 col = vec3(0.0);\n  if (distg > 0.0) {\n    vec3 pg = ro + rd*distg;\n    float aa = length(dFdx(pg))*0.0002*RESOLUTION.x;\n    \n    float dg = ground(pg.xz);\n    \n    col = mix(col, gridCol, smoothstep(-aa, 0.0, -(dg+0.0175)));   \n    col += shineCol*(exp(-10.0*clamp(dg, 0.0, 1.0)));\n    col = clamp(col, 0.0, 1.0);\n    \n//    col += 0.3*psin(dg*100);\n    col *= pow(1.0-smoothstep(ro.y*3.0, 220.0+ro.y*2.0, distg), 2.0);\n  }\n  \n  return col;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col = clamp(col,0.0,1.0);\n//  col=pow(col,vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  vec3 col = vec3(0.0);\n\n  vec2 off = vec2(0.0, 0.0);\n  \n  col += sunEffect(p+off);\n  col += groundEffect(p+off);\n\n  col = postProcess(col, q);\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x / RESOLUTION.y;\n \n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzy.jpg", "access": "api", "license": "cc0-1.0", "functions": [[245, 245, 267, 267, 436], [438, 438, 463, 463, 511], [513, 513, 537, 537, 607], [609, 609, 630, 630, 659], [661, 661, 700, 700, 825], [827, 827, 858, 858, 884], [886, 886, 913, 913, 989], [991, 991, 1022, 1022, 1047], [1049, 1049, 1080, 1080, 1105], [1107, 1107, 1146, 1146, 1235], [1237, 1237, 1276, 1276, 1305], [1307, 1307, 1326, 1326, 1559], [1561, 1561, 1581, 1581, 1992], [1993, 1993, 2017, 2017, 2906], [2908, 2908, 2930, 2930, 3530], [3532, 3532, 3559, 3559, 4353], [4355, 4355, 4392, 4392, 4614], [4616, 4616, 4645, 4645, 4805], [4807, 4807, 4859, 4859, 5023]], "test": "untested"}
{"id": "WtSczG", "name": "Raymarcher - Test 1", "author": "SpinningCube", "description": "This is my first ray marcher on Shadertoy.", "tags": ["raymarching"], "likes": 4, "viewed": 378, "published": 3, "date": "1594611578", "time_retrieved": "2024-07-30T20:55:37.553413", "image_code": "\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Filmic Transform curve by milesWaugh\n\nconst int maxSteps = 256;\nconst float epsilon = 0.0001;\nconst float focalLength = 1.;\nconst float renderDist = 5000.;\n\nvec3 camera;\nfloat SDE;\nvec3 ray;\n\nvec3 surfCol;\nvec3 surfNormal;\nfloat surfSpecular;\nfloat surfShininess;\nbool updateMat;\n\nfloat diffuse = 0.;\nfloat specular;\nvec3 ambient = vec3(0.1, 0.1, 0.1);\n\nvec3 rayDirection( float focal, vec2 xy ) {\n    return (normalize(vec3(xy, focal)));\n}\n\n// SDF's\n\nfloat Sphere( vec3 ray, vec3 pos, float radius ) {\n    return distance( ray, pos ) - radius;\n}\n\nfloat Ground( vec3 ray, float y ) {\n    return ray.y - y;\n}\n\nvoid addSDF( float SDF, vec3 col, float specular, float shininess ) {\n    if ( SDF < SDE ) {\n        SDE = SDF;\n        if (updateMat) {\n        \tsurfCol = col;\n        \tsurfSpecular = specular;\n        \tsurfShininess = shininess;\n        }\n    }\n}\n\nfloat scene( vec3 ray, float renderDist ) {\n    \n    SDE = renderDist;\n    addSDF( Sphere( ray, vec3(10, 0, 100), 15.), vec3(.8, 0., 0.), 1.5, 512. );\n    addSDF( Sphere( ray, vec3(-20, 0, 120), 15.), vec3(0., 0., 1.), 1.5, 512. );\n    //addSDF( Sphere( ray, vec3(5.*cos(iTime), 5.*sin(iTime), 120), 15.), vec3(0., 0., 1.), 1., 256. );\n    addSDF( Ground( ray, -15.), vec3(.4, .4, .4), 1., 256. );\n    return SDE;\n}\n\nvec3 calcNormal( vec3 p )\n{\n    const float h = 10. * epsilon; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    //const float eps = 10. * epsilon; // replace by an appropriate value\n    //const vec2 h = vec2(eps,0);\n    return normalize( k.xyy * scene( p + k.xyy*h, renderDist ) + \n                      k.yyx * scene( p + k.yyx*h, renderDist ) + \n                      k.yxy * scene( p + k.yxy*h, renderDist ) + \n                      k.xxx * scene( p + k.xxx*h, renderDist ));\n    \n}\n\nvec4 shootRay( vec3 rayDir, vec3 start, float renderDist, bool updateMaterial ) {\n    updateMat = updateMaterial;\n    ray = start;\n    float rayLength = 0.;\n    for ( int i = 0; i <= maxSteps; i++ ) {\n        \n        scene( ray, renderDist );\n        \n        rayLength += SDE;\n        ray = rayDir * rayLength + start;\n        \n        if ( rayLength > renderDist ) {\n            return vec4(0., ray);\n        }\n        if ( SDE < epsilon ) {\n            return vec4(1., ray);\n        }\n    }\n    return vec4(1., ray);\n}\n\nvoid phongLighting(vec3 ray, vec3 rayDir, vec3 lightDir, vec3 surfNormal, float intensity, float lightDist) {\n    if ( shootRay(lightDir, ray + (surfNormal * 1.), lightDist, false).x == 0. ) {\n        \n        diffuse += max(intensity * dot(surfNormal, lightDir), 0.);\n\t\t\n        vec3 halfway = normalize(lightDir - rayDir);\n    \tspecular += max(intensity * surfSpecular * pow(dot(surfNormal, halfway), surfShininess), 0.);\n\n    }\n}\n\nvoid pointLight( vec3 ray, vec3 rayDir, vec3 position, float intensity, vec3 surfNormal ) {\n    vec3 lightDir = normalize(position - ray);\n    phongLighting( ray, rayDir, lightDir, surfNormal, intensity, distance(position, ray) );\n}\n\nvoid sceneLights(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    pointLight( ray, rayDir, vec3(-50, 50, -10), 1., surfNormal );\n}\n\nvec3 filmicTransform(vec3 color) {\n    return vec3(1. - (1./(5. * pow(color.x, 2.) + 1.)),\n                1. - (1./(5. * pow(color.y, 2.) + 1.)),\n                1. - (1./(5. * pow(color.z, 2.) + 1.)));\n}\n\nvec3 lighting(vec3 ray, vec3 rayDir, vec3 surfNormal) {\n    diffuse = 0.;\n    specular = 0.;\n    \n    sceneLights(ray, rayDir, surfNormal);\n    \n    vec3 finalCol = filmicTransform((diffuse * surfCol) + (ambient * surfCol) + specular);\n    \n    return finalCol;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    camera = vec3(0., 5.*sin(iTime), 0.);\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - iResolution.xy/2.)/iResolution.x;\n    \n    vec3 rayDir = rayDirection( focalLength, uv );\n    \n    vec4 rayData = shootRay( rayDir, camera, renderDist, true );\n    \n    vec3 col;\n    \n    if (rayData.x == 1.) {\n        vec3 surfNormal = calcNormal( rayData.yzw );\n    \tcol = lighting( rayData.yzw, rayDir, surfNormal );\n    }\n    else {\n        col = ambient;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSczG.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[446, 446, 489, 489, 532], [544, 544, 594, 594, 638], [640, 640, 675, 675, 699], [701, 701, 770, 770, 949], [951, 951, 994, 994, 1366], [1368, 1368, 1395, 1395, 1874], [1876, 1876, 1957, 1957, 2398], [2400, 2400, 2509, 2509, 2832], [2834, 2834, 2925, 2925, 3066], [3068, 3068, 3126, 3126, 3195], [3197, 3197, 3231, 3231, 3402], [3404, 3404, 3459, 3459, 3667], [3669, 3669, 3726, 3726, 4274]], "test": "untested"}
{"id": "3lScRG", "name": "Raymarching Sphere and Plane", "author": "Mega_Salamence", "description": "https://www.youtube.com/watch?v=PGtv-dBi2wE&t=362s", "tags": ["raymarching"], "likes": 1, "viewed": 323, "published": 3, "date": "1594603027", "time_retrieved": "2024-07-30T20:55:38.321360", "image_code": "#define SURFACE_DIST .01\n#define MAX_DIST 100.\n#define MAX_STEPS 100\n\n\nfloat GetDist(vec3 p)\n{\n\tvec4 s = vec4(0, 1, 6, 1);\n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    float d = min(sphereDist, planeDist);\n    return d;\n}\n\nfloat RayMarching(vec3 ro, vec3 rd) {\n\tfloat depth = 0.0f;\n    for(int i = 0 ;i < MAX_STEPS; i ++) {\n\t\tvec3 p = ro + depth * rd;\n        float dist = GetDist(p);\n        depth += dist;\n        if(dist < SURFACE_DIST || depth > MAX_DIST)\n            break;\n    }\n    return depth;\n}\n\n\nvec3 GetNormal(vec3 p)\n{\n \tvec2 e = vec2(0.01f, 0.0f);   \n    float d = GetDist(p);\n    vec3 n = vec3(\n    \td - GetDist(p - e.xyy),\n    \td - GetDist(p - e.yxy),\n    \td - GetDist(p - e.yyx));\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0, 5, 6);\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    float diff = clamp(dot(n ,l), 0., 1.);\n    float d = RayMarching(p + n * SURFACE_DIST, l);\n    if(d < length(lightPos - p))\n        diff *= .1;\n    return diff;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    \n    vec3 ro = vec3(0.0f, 1.0f, 0.0f);\n   \tvec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    float d = RayMarching(ro, rd);\n    vec3 p = ro + rd * d;\n   \tfloat diff = GetLight(p);\n    \n    \n   \tvec3 col = vec3(diff);\n    fragColor = vec4(col, 1.0f);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lScRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[71, 71, 94, 94, 255], [257, 257, 294, 294, 538], [541, 541, 565, 565, 758], [760, 760, 784, 784, 1051], [1054, 1054, 1111, 1111, 1443]], "test": "untested"}
{"id": "WlByRG", "name": "Caves of grass", "author": "jarble", "description": "These caves are made of a material that looks like hair, fur, or grass.\nUse the mouse to look around.", "tags": ["fractal", "grass", "caves"], "likes": 1, "viewed": 424, "published": 3, "date": "1594602272", "time_retrieved": "2024-07-30T20:55:39.265835", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= length(vec3(1.0)+sin(p/500.0))*500.0;\n    p /= scale;\n    p /= 2.0;\n    return vec3(.3,.5,.3)+sin(vec3(planet_surface(p,1.0)))/10.0;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS/2; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.004;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "int s1(int t, int b){\n\treturn (t/b/4096)%b;\n}\n\nvec2 sound1(int t)\n{\n    int t1 = t*(s1(t/2,2)+1);\n    t = t*(6-s1(t/7,3)+s1(t1/7,6)/2+s1(t1/11,3)/2+s1(t1/13,6)/2-s1(t1,2))|t1>>6|t1>>5;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = 1.0;\n    float result1 = 0.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult = sound1(int(time*factor))/factor;\n        factor += result.x/128.0;\n        result1 += result.x;\n    }\n    result1 /= 4.0;\n    return vec2(result1)/10.0;\n}\n\n/*\nint s1(int t, int b){\n\treturn (t/b/4096)%b;\n}\n\nvec2 sound1(int t)\n{\n    int t1 = t*(s1(t/2,2)+1);\n    t = t*(6-s1(t/7,3)+s1(t1/7,6)/2+s1(t1/11,3)/2+s1(t1/13,6)/2-s1(t1,2))|t1>>6|t1>>5;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = 1.0;\n    float result1 = 0.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult = sound1(int(time*factor))/factor;\n        factor += result.x/128.0;\n        result1 += result.x;\n    }\n    result1 /= 4.0;\n    return vec2(result1)/10.0;\n}\n*/", "sound_inputs": [], "common_code": "#define image_scale 4.0\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin((p1.yzx/i)/i+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*2.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 27.0; i *= 3.0){\n        //p += sin(p.yzx);\n        p += sin(i+p.yzx*i/81.0)*81.0;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= length(vec3(1.0)+sin(p/500.0))*500.0;\n    p /= scale;\n    p /= 2.0;\n    return vec3(.3,.5,.3)+sin(vec3(planet_surface(p,1.0)))/10.0;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale*10.0)*4.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.004;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap.xyz);\n    float l1 = dmap.w;\n    \n\n    //if(l1 < l0){\n        l0 = sqrt((l0));\n    //}\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByRG.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 87, 231], [234, 655, 746, 746, 1120], [1135, 1389, 1454, 1454, 1586], [1588, 1677, 1706, 1706, 2016], [2018, 2510, 2650, 2650, 3260], [3262, 3632, 3717, 3717, 4132], [4134, 4461, 4510, 4545, 4676], [4678, 4678, 4705, 4705, 4854], [4856, 4856, 4913, 4913, 5473]], "test": "untested"}
{"id": "wsySzy", "name": "planet with asteroid belts", "author": "abje", "description": "mouse, arrow keys, shift and ctrl to move aound.\n\nfrom a comment on [url]https://www.shadertoy.com/view/wdjSzz[/url]\n\"Time to make some saturn rings\"\n     - Duke, 2019-03-18", "tags": ["torus", "asteroids"], "likes": 5, "viewed": 366, "published": 3, "date": "1594599436", "time_retrieved": "2024-07-30T20:55:40.315030", "image_code": "#define sun vec3(800,100,1000)\n\n// noise by iq\n// https://www.shadertoy.com/view/4sfGzS\n//////////////////////////////////////////////////////////////\nfloat hash(vec3 p)  // replace this by something better     //\n{                                                           //\n    p  = fract( p*0.3183099+.1 );                           //\n\tp *= 17.0;                                              //\n    return fract( p.x*p.y*p.z*(p.x+p.y+p.z) );              //\n}                                                           //\n                                                            //\nfloat noise( in vec3 x )                                    //\n{                                                           //\n    vec3 i = floor(x);                                      //\n    vec3 f = fract(x);                                      //\n    f = f*f*(3.0-2.0*f);                                    //\n\t                                                        //\n    return mix(mix(mix( hash(i+vec3(0,0,0)),                //\n                        hash(i+vec3(1,0,0)),f.x),           //\n                   mix( hash(i+vec3(0,1,0)),                //\n                        hash(i+vec3(1,1,0)),f.x),f.y),      //\n               mix(mix( hash(i+vec3(0,0,1)),                //\n                        hash(i+vec3(1,0,1)),f.x),           //\n                   mix( hash(i+vec3(0,1,1)),                //\n                        hash(i+vec3(1,1,1)),f.x),f.y),f.z); //\n}                                                           //\n//////////////////////////////////////////////////////////////\n\nvec2 ellipsoid(vec3 ro, vec3 rd, vec3 size) {\n    size = 1.0/max(size, 0.001);\n    \n    ro *= size;\n    rd *= size;\n    \n    float e = 1.0/dot(rd,rd);\n    float b = -dot(rd,ro)*e;\n    vec3 p = ro+rd*b;\n    float a = dot(p,p);\n    if (a > 1.0) return MISS;\n    float c = sqrt((1.0-a)*e);\n    \n    return b+vec2(-c,c);\n}\n\nvec4 cylinder(vec3 p, vec3 r, float s0, float s1) {\n    \n    p.y = 0.0;\n    r.y = 0.0;\n    \n    float l = 1.0/length(r);\n    r *= l;\n    \n    vec3 oc = p;\n    float b = dot( oc, r );\n    float c = dot( oc, oc );\n    float d = c-s0*s0;\n    float e = c-s1*s1;\n    float h = b*b - d;\n    \n    vec4 f = vec4(MISS,MISS);\n    if( h>0.0 ) {\n    \tfloat i = b*b - e;\n        if( i>0.0 ) {\n            i = sqrt(i);\n\n            f.zw = -b + vec2(-i,i);\n        }\n        \n        h = sqrt(h);\n\n        f.xy = -b + vec2(-h,h);\n    }\n    \n    return f*l;\n}\n\nvec2 plane(vec3 ro, vec3 rd, float s) {\n    float a = rd.y;\n    float b = ro.y;\n    \n    float c = abs(s/a);\n    float d = -b/a;\n    \n    return d+vec2(-c,c);\n}\n\nvec4 sqrring(vec3 ro, vec3 rd, float r, vec2 s) {\n    \n    vec2 pln = plane(ro,rd,s.y);\n    pln.x = max(pln.x,0.0);\n    \n    vec4 d = cylinder(ro,rd,r+s.x,r-s.x);\n    \n    d.x = max(d.x,pln.x);\n    \n    if (d.y > d.z && d.w > pln.x) {\n        \n        d = d.xzwy;\n        \n        if (d.x > d.y && d.x < d.z) {\n            d.xy = d.zw;\n            d.zw = MISS;\n        }\n        \n    } else {\n        d.zw = MISS;\n    }\n    \n    d.yw = min(d.yw,pln.y);\n    \n    return d;\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n, float l) {\n    float a = dot(rd, n);\n    float b = dot(ro,n)-l;\n\n    if (b*a > 0.0) return sign(a)*10000.0;\n\n    return b/abs(a);\n\n}\n\nfloat hash( float n ) {\n    return fract(sin(n)*43758.5453);\n}\n\nvec4 solid(vec3 p, vec3 rd, float s)\n{\n    float distn = 0.0;\n    float distf = FAR;\n    vec3 dir = vec3(0.,1.,0.);\n    float h = 3.;\n    float v = 6.;\n    mat2 hr = rot(PI * 2.0 / h);\n    mat2 vr = rot(PI * 2.0 / v);\n\tvec3 n;\n    for(float j = 0.; j < v; ++j)\n    {\n        for(float i = 0.; i < h; ++i)\n        {\n            float ran = hash(s + j * i)*0.2;\n\n            float len = plane(p, rd, dir,0.1+ran);\n\n            if (len >= 0.0) {\n                if (len > distn) {\n                    distn = len;\n                    n = dir;\n                }\n            } else {\n                distf = min(distf,-len);\n            }\n\n            dir.xz *= hr;\n        }\n\n        dir.yz *= vr;\n    }\n    if (distf < distn) distn = FAR;\n    return vec4(distn,n);\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\n\nfloat plane(vec3 ro, vec3 rd, vec3 n) {\n    \n    float a = dot(rd,n);\n    float b = dot(ro,n);\n    \n    float d = -b/a;\n    \n    if (d < 0.0) return FAR;\n    \n    return d;\n\n}\n\nvec4 pvoxel(vec3 ro, vec3 rd, vec2 limit, float lines, float pivot, float radius, out float ring) {\n    \n    float orbit = iTime*0.1;\n    float spin = iTime*0.2;\n    \n    ro.xz *= rot(orbit);\n    rd.xz *= rot(orbit);\n    //ro += limit.x*rd;\n    float d = limit.x;\n    vec3 p = ro+rd*d;\n\n    float ang = (atan(p.x,p.z)/PI*0.5+0.5)*lines;\n    float dir = sign(dot(rd.xz,vec2(p.z,-p.x)));\n    float slice = floor(ang-dir);\n    \n    vec2 cell;\n    vec2 lens = vec2(FAR);\n    \n    vec3 rd2;\n    vec3 ird;\n    \n    float maxdist = limit.y-limit.x;\n    \n    float sliceratio = 1.0/lines*2.0*PI;\n    \n    mat2 slicerot = rot(sliceratio);\n    \n    float angle;\n    float angleedge;\n    \n    vec2 pln;\n    vec3 cent;\n\n    float hit = limit.x;\n    \n    for (int i = 0; i < 120; i++)\n    {\n        //if (sin(cell.x)*sin(cell.y) < -0.5) break;\n        if (d > limit.y) break;\n        float len = min(lens.x,lens.y);\n        \n        if (i > 0) {\n            //if (i == 2) break;\n            float l = min(len,hit);\n\n            mat2 rot1 = rot(-angle);\n            mat2 rot2 = rot(-angle*4.0-spin);\n            \n            vec3 c = vec3(0,cell.y,cell.x);\n            ring = dot(c.yz,c.yz);\n            if (ring < radius) {\n                c.zy *= rot2;\n                c.z -= pivot;\n                c.xz *= rot1;\n                \n                vec3 lp = ro-c;\n                vec3 rd2 = rd;\n                mat2 r = rot(iTime);\n                lp.xz *= r;\n                rd2.xz *= r;\n                r = rot(iTime * .5);\n                lp.xy *= r;\n                rd2.xy *= r;\n                r = rot(iTime * .25);\n                lp.yz *= r;\n                rd2.yz *= r;\n\n                vec4 sph = solid(lp,rd2,cell.x+cell.y*1.2432+slice*2.432);\n\n                if (sph.x < l)\n                {\n                    sph.zw *= rot(-iTime * .25);\n                    sph.yz *= rot(-iTime * .5);\n                    sph.yw *= rot(-iTime);\n    \t\t\t\tsph.yw *= rot(-orbit);\n                    \n                    return sph;\n                }\n            }\n        }\n        \n        if (hit < len)\n        {\n        \tslice += dir;\n            slice = mod(slice,lines);\n            d = hit;\n            \n            angle = (slice+0.5)*sliceratio;\n            angleedge = angle+dir*sliceratio*0.5;\n            \n            pln = vec2(cos(angleedge),-sin(angleedge));\n            cent = vec3(sin(angle),0.0,cos(angle));\n\n            float a = dot(rd.xz,pln);\n            hit = -dot(ro.xz,pln)/a;\n            if (a*dir > 0.0) hit = FAR;\n            \n            mat2 rot1 = rot(angle);\n            mat2 rot2 = rot(angle*4.0+spin);\n            \n            rd2 = rd;\n            rd2.xz *= rot1;\n            rd2.zy *= rot2;\n            \n            ird = 1.0/abs(rd2);\n            \n            vec3 p = ro+rd*d;\n            p.xz *= rot1;\n            \n            p.z += pivot;\n            \n            p.zy *= rot2;\n            p.zy += 0.5;\n            cell = floor(p.zy);\n    \t\tlens = d+abs(step(0.0,rd2.zy)-p.zy+cell.xy)*ird.zy;\n        } else {\n            d = len;\n            \n            if (lens.x < lens.y) {\n                lens.x += ird.z;\n                cell.x += sign(rd2.z);\n            } else {\n                lens.y += ird.y;\n                cell.y += sign(rd2.y);\n            }\n        }\n    }\n    return vec4(FAR,vec3(-1));\n}\n\nfloat asteroidring(vec3 ro, vec3 rd) {\n    return 0.0;\n}\n\nvec4 asteroids(vec3 ro, vec3 rd, float far, out float ring) {\n    vec4 l = sqrring(ro, rd, 12.0, vec2(2.5));\n    \n    float a;\n    \n    for (int i = 0; i < 2; i++) {\n        l.y = min(l.y, far);\n        if (l.x < l.y)\n        {\n            vec4 hit = pvoxel(ro,rd,l.xy, 50.0, 12.0, 5.1, ring);\n            if (hit.x < l.y)\n                return hit;\n\n            l.xy = l.zw;\n        } else {\n            break;\n        }\n    }\n    return vec4(FAR,vec3(-1));\n}\n\nvec4 ray(vec3 ro, vec3 rd, out float ring, out int planet) {\n    \n    //temp variables\n    float l = FAR;\n    vec3 n2;\n    float r = -1.0;\n    float r2;\n    \n    // ray variables\n    float d = FAR;\n    vec3 n = vec3(-1);\n    \n    vec3 p = ro;\n    vec2 sph = ellipsoid(p,rd,vec3(7));\n    \n    if (max(sph.x,0.0) < min(sph.y,l)) {\n        l = sph.x;\n        n2 = normalize(ro+rd*l);\n    }\n    \n    vec4 field = asteroids(p, rd, l, r2);\n    \n    if (field.x < l) {\n        r = r2;\n        l = field.x;\n        n2 = field.yzw;\n    }\n    \n    if (l < d) {\n        n = n2;\n        d = l;\n        planet = 1;\n        ring = r;\n    }\n    \n    mat2 rot1 = rot(-0.7);\n    p = ro;\n    vec3 rd2 = rd;\n    p -= vec3(sin(iTime*0.2),sin(iTime*0.2),cos(iTime*0.2))*20.0;\n    p.xy *= rot1;\n    rd2.xy *= rot1;\n    sph = ellipsoid(p,rd2,vec3(7));\n    l = d;\n    n2;\n    r = -1.0;\n    \n    if (max(sph.x,0.0) < min(sph.y,l)) {\n        l = sph.x;\n        r = -1.0;\n        n2 = normalize(p+rd2*l);\n    }\n    \n    field = asteroids(p, rd2, l, r2);\n    \n    if (field.x < l) {\n        r = r2;\n        l = field.x;\n        n2 = field.yzw;\n    }\n    \n    if (l < d) {\n    \tmat2 rot1 = rot(0.7);\n        n2.xy *= rot1;\n        n = n2;\n        d = l;\n        planet = 2;\n        if (p.y+rd2.y*d > 0.0) planet++;\n        ring = r;\n        \n    }\n    \n    //sun\n    p = ro-sun;\n    sph = ellipsoid(p,rd,vec3(70));\n    \n    if (max(sph.x,0.0) < min(sph.y,d)) {\n        d = sph.x;\n        n = normalize(p+rd*d);\n        planet = 4;\n    }\n    \n    \n    \n    return vec4(d,n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord*2.0-iResolution.xy)/iResolution.y;\n\n    vec3 ro = getdata(campos).xyz;\n    vec3 rd = normalize(vec3(uv,1));\n\n    vec4 rotcam = getdata(camrot);\n\n    rd.zy *= rot(rotcam.y);\n    rd.zx *= rot(rotcam.x);\n    \n    float ring;\n    int planet;\n    vec4 r = ray(ro,rd, ring, planet);\n    //float ray = pvoxel(ro,rd,vec2(0,FAR),10.0);\n    \n    // Output to screen\n    vec3 col = vec3(0);\n    \n    if (r.x < FAR) {\n    \t\n        vec3 p = ro+rd*r.x;\n        \n        if (planet != 4) {\n            vec3 sundir = normalize(sun-p);\n\n            float a = clamp(dot(r.yzw,sundir),0.3,1.0);\n\t\t\tfloat one; int two;\n            if (ray(p+r.yzw*0.01,sundir,one,two).x < 100.0) a = 0.3;\n            \n            float gray = 0.0;\n\n            if (ring < 1.0)\n                gray = 0.01;\n            else if (ring < 3.0)\n                gray = 0.2;\n            else\n                gray = 1.0;\n\n            col = vec3(gray);\n\n            if (ring < 0.0) {\n                if (planet == 1) {\n                    col = vec3(0.4,0.0,1.0);\n                } else if (planet == 2) {\n                    col = vec3(0.4,0.8,0.4);\n                } else if (planet == 3) {\n                    col = vec3(0.0,0.6,0.0);\n                }\n            }\n\n            col *= a;\n        } else {\n           col = vec3(1,0.5,0); \n        }\n    } else {\n        col = sqr(rd.x*0.5+1.0)*vec3(0.1,0.0,0.9);\n        col += max((sqr(noise(rd*100.0))-0.8)*10.0,0.0);\n        \n    }\n\n    col = clamp(col,0.0,1.0);\n    fragColor = vec4(sqrt(col.xyz),1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define lastmouse 0\n#define campos 1\n#define camrot 2\n\n#define rot(A) mat2(cos(A),-sin(A),sin(A),cos(A))\n#define sqr(a) (a*a)\n\n#define sensitivity 3.0\n#define movespeed 3.0\n\n//keyboard keys\n#define KEY_UP    38\n#define KEY_DOWN  40\n#define KEY_RIGHT 39\n#define KEY_LEFT  37\n#define KEY_SHIFT 16\n#define KEY_CTRL  17\n\n//movement keys\n#define MOVE_FORW   KEY_UP\n#define MOVE_LEFT   KEY_LEFT\n#define MOVE_RIGHT  KEY_RIGHT\n#define MOVE_BACK   KEY_DOWN\n#define MOVE_UP     KEY_SHIFT\n#define MOVE_DOWN   KEY_CTRL\n\n//constants\n#define PI radians(180.0)\n#define FAR 10000.0\n#define MISS vec2(FAR,FAR-1.0)\n", "buffer_a_code": "float getkey(int x, int y)\n{\n    return texelFetch(iChannel1,ivec2(x,y),0).x;\n}\n\nvec4 getdata(int index) {\n    ivec2 p;\n    p.x = index%int(iResolution.x);\n    p.y = index/int(iResolution.x);\n    return texelFetch(iChannel0,p,0);\n}\nvec4 updatedata(int index) {\n    vec4 data = getdata(index);\n    \n    vec4 iMouse2 = getdata(lastmouse);\n    \n    \n    bool refresh = iFrame == 0;\n    \n    if (index == lastmouse) {\n        return iMouse;\n    } else if (index == campos) {\n        \n        if (refresh) {\n            return vec4(vec3(0,14,-30.0),1);\n        }\n        \n        vec4 rotcam = getdata(camrot);\n        \n        vec3 move = vec3(getkey(MOVE_RIGHT,0)-getkey(MOVE_LEFT,0),\n                         getkey(MOVE_UP   ,0)-getkey(MOVE_DOWN,0),\n                         getkey(MOVE_FORW ,0)-getkey(MOVE_BACK,0));\n        \n        move.zy *= rot(rotcam.y);\n        move.zx *= rot(rotcam.x);\n        \n        vec3 newpos = data.xyz+movespeed*move*iTimeDelta;\n        \n        data.xyz = newpos;\n        \n        return data;\n    } else if (index == camrot) {\n        \n        if (refresh) {\n            return vec4(vec2(0,-0.5),0,1);\n        }\n        \n        if (min(iMouse2.z,iMouse.z) > 0.5) {\n            data.xy += (iMouse.xy-iMouse2.xy)/iResolution.y*sensitivity;\n        }\n        \n        return data;\n    }\n    \n    \n    return data;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    ivec2 coord = ivec2(fragCoord);\n    fragColor = updatedata(coord.x+coord.y*int(iResolution.x));\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsySzy.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 151, 215, 276, 464], [523, 589, 653, 714, 1469], [1595, 1595, 1640, 1640, 1913], [1915, 1915, 1966, 1966, 2458], [2460, 2460, 2499, 2499, 2620], [2622, 2622, 2671, 2671, 3095], [3097, 3097, 3145, 3145, 3267], [3269, 3269, 3292, 3292, 3331], [3333, 3333, 3371, 3371, 4096], [4098, 4098, 4123, 4123, 4248], [4250, 4250, 4289, 4289, 4425], [4427, 4427, 4526, 4526, 7756], [7758, 7758, 7796, 7796, 7814], [7816, 7816, 7877, 7877, 8277], [8279, 8279, 8339, 8365, 9825], [9827, 9827, 9884, 9934, 11474]], "test": "untested"}
{"id": "tl2yWm", "name": "Assembly line", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wtByDw]\"Industrial machinery\"[/url] shader.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 3, "viewed": 358, "published": 3, "date": "1594586473", "time_retrieved": "2024-07-30T20:55:41.087963", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define iterations 3\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1,float i){\n    //p += sin(p.yzx+iTime*i*9.0)/(i*27.0); //animation\n    return size-length(sin(p/vec3(length(p/20.0)))*size1)/1.8;\n}\n\nfloat vines(vec3 p,float size1){\n\treturn vines(p,size1,1.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float multiplier = 3.0+sin(iTime/100.0);\n    float i = multiplier;\n\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p*i)/i;\n        result = vines(p,size1,i)/i;\n        i *= multiplier;\n    }\n    return (result)*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p *= sin(p);\n    float v = vines(p,1.0);\n    return sin(vec3(v*6.0,v*4.0,v*3.0))/5.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    vec3 eye = vec3(50.0,1.6,iTime/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[608, 608, 648, 704, 769], [771, 771, 803, 803, 833], [835, 835, 859, 859, 1193], [1195, 1195, 1223, 1242, 1326], [1328, 1749, 1840, 1840, 2204], [2219, 2473, 2538, 2538, 2670], [2672, 2761, 2790, 2790, 3105], [3107, 3599, 3739, 3739, 4349], [4351, 4721, 4806, 4806, 5153], [5155, 5482, 5531, 5566, 5697], [5699, 5699, 5756, 5756, 6747]], "test": "untested"}
{"id": "td2GWt", "name": "Rock texture", "author": "BynaryCobweb", "description": "Rock texture shader used for world procedural generation\nhttps://github.com/BynaryCobweb/world/", "tags": ["texture", "rock"], "likes": 5, "viewed": 486, "published": 3, "date": "1594584868", "time_retrieved": "2024-07-30T20:55:41.863888", "image_code": "// between 0 and 1\nfloat rand(vec2 v) {\n    return fract(sin(dot(v + vec2(-8.5123, 23.2156), vec2(12.9898, 59.233))) * 4758.5453123);\n}\n\nvec2 rand2(vec2 v) {\n    return vec2(\n        rand(v * vec2(4562.223, 1232.465) + vec2(1122.0, 8325.0)), \n        rand(v * vec2(2312.843, 8621.456) + vec2(5133.2, 2462.7)));\n}\n\nfloat rand3(vec3 v) {\n    return fract(sin(dot(v + vec3(-8.5123, 23.2156, 0.0), vec3(12.9898, 6.233, 0.84261))) * 47583.5453123);\n}\n\n\nfloat noise(in vec2 uv) {\n    vec2 f = fract(uv);\n    vec2 i = floor(uv);\n    \n    float a = rand(i);\n    float b = rand(i + vec2(0.0, 1.0));\n    float c = rand(i + vec2(1.0, 0.0));\n    float d = rand(i + vec2(1.0, 1.0));\n    \n    vec2 u = -2. * f * f * f + 3. * f * f;\n    return mix(mix(a, b, u.y), mix(c, d, u.y), u.x);\n}\n\n\nfloat noise3lin(in vec3 uvx) {\n    vec3 f = fract(uvx);\n    vec3 i = floor(uvx);\n    \n    float a1 = rand3(i);\n    float b1 = rand3(i + vec3(0.0, 1.0, 0.0));\n    float c1 = rand3(i + vec3(1.0, 0.0, 0.0));\n    float d1 = rand3(i + vec3(1.0, 1.0, 0.0));\n    float a2 = rand3(i + vec3(0.0, 0.0, 1.0));\n    float b2 = rand3(i + vec3(0.0, 1.0, 1.0));\n    float c2 = rand3(i + vec3(1.0, 0.0, 1.0));\n    float d2 = rand3(i + vec3(1.0, 1.0, 1.0));\n    \n    vec3 u = -2. * f * f * f + 3. * f * f;\n    \n    float a = mix(a1, a2, f.z);\n    float b = mix(b1, b2, f.z);\n    float c = mix(c1, c2, f.z);\n    float d = mix(d1, d2, f.z);\n    \n    return mix(mix(a, b, u.y), mix(c, d, u.y), u.x);\n}\n\nfloat fbm(in vec2 uv) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 3; ++i) {\n        amp = amp / persistence + noise(st);\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\nfloat fbm2(in vec2 uv) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.8;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 6; ++i) {\n        amp = amp / persistence + noise(st);\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\n\nfloat fbm3(in vec3 uvx) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 0.7;\n    vec3 stz = uvx;\n    \n    for (int i = 0; i < 8; ++i) {\n        amp = amp / persistence + noise3lin(stz);\n        sum = sum / persistence + 1.;\n        stz *= 2.;\n    }\n    return amp / sum;\n}\n\nfloat afbm(in vec2 uv) {\n    float sum = 0.0;\n    float amp = 0.0;\n    float persistence = 1.;\n    vec2 st = uv;\n    \n    for (int i = 0; i < 5; ++i) {\n        amp = amp / persistence + abs(-1. + 2. * noise(st));\n        sum = sum / persistence + 1.;\n        st *= 2.;\n    }\n    return amp / sum;\n}\n\nconst int N = 8;\n\nfloat voronoi(in vec2 uv) {\n    // split in squares\n    const float space = 0.4;\n    vec2 rf = vec2(1.0, 0.5);\n    vec2 rs = vec2(0.5, 1.6);\n      \n    // take n sample in each square\n    vec2 uvi = vec2(floor(uv / space - 0.5));\n    vec2 p1 = uvi * space;\n    vec2 p2 = (uvi + vec2(0, 1)) * space;\n    vec2 p3 = (uvi + vec2(1, 0)) * space;\n    vec2 p4 = (uvi + vec2(1, 1)) * space;\n    float m = 10000.0;\n    \n    for (int i = 0; i < N; i++) {\n        p1 = (uvi + rand2(p1 * rf + rs)) * space;\n        m = min(m, distance(p1, uv));\n        p2 = (uvi + vec2(0, 1) + rand2(p2 * rf + rs)) * space;\n        m = min(m, distance(p2, uv));\n        p3 = (uvi + vec2(1, 0) + rand2(p3 * rf + rs)) * space;\n        m = min(m, distance(p3, uv));\n        p4 = (uvi + vec2(1, 1) + rand2(p4 * rf + rs)) * space;\n        m = min(m, distance(p4, uv));\n    }\n    \n    return 1. - pow(m, 0.5) / space * sqrt(float(N)) * 0.2;\n}\n\nvoid noiseCracks(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    float value = fbm2(uv + vec2(0.5, 0.5));\n    vec3 col = vec3(value);\n    float cracks = abs( -1. + 2. * fbm(uv * 6.));\n    cracks = clamp(pow(cracks, 2.3) * 10., 0., 1.);\n    cracks = 0.5 + sin(value * 20. * 3.14) * 0.5;\n    /*if (cracks <= 0.5) {\n        cracks = mix(1., 0.5, clamp((cracks - 0.45) * 20., 0., 1.));\n    }\n    else {\n        cracks = smoothstep(0.25, 1., clamp((cracks - 0.5) * 20., 0., 1.));\n    }*/\n    col = mix(col, vec3(0.4), cracks);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 a = vec2(voronoi(uv + vec2(4.2, 2.6)), voronoi(uv + vec2(8.2, 5.6)));\n    vec2 b = vec2(fbm2(uv), fbm2(uv + vec2(5.)));\n\t\n    // vec3 col = vec3(a, 1.0);\n    // vec3 col = vec3(voronoi(a * cos(iTime)));\n    // vec3 col = vec3(fbm2(a * cos(iTime)));\n    // vec3 col = vec3(voronoi(uv + fbm2(b) * cos(iTime)));\n    float t = sin(iTime - 0.4) * 0.2 + 0.4;\n    vec3 col = vec3(voronoi(uv + (b - 0.5) * t));\n    // vec3 col = vec3(voronoi(uv + a * cos(iTime)));\n    // vec3 col = vec3(voronoi(uv));\n    col *= fbm2(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td2GWt.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 19, 39, 39, 135], [137, 137, 157, 157, 312], [314, 314, 335, 335, 445], [448, 448, 473, 473, 772], [775, 775, 805, 805, 1455], [1457, 1457, 1480, 1480, 1739], [1740, 1740, 1764, 1764, 2023], [2025, 2025, 2050, 2050, 2317], [2319, 2319, 2343, 2343, 2617], [2637, 2637, 2664, 2688, 3545], [3547, 3547, 3604, 3654, 4250], [4252, 4252, 4309, 4359, 4961]], "test": "untested"}
{"id": "tljyWm", "name": "Windy grass", "author": "jarble", "description": "This animation was created using a modified version of my [url=https://www.shadertoy.com/view/wtByDw]\"industrial machinery\"[/url] shader.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 0, "viewed": 346, "published": 3, "date": "1594584826", "time_retrieved": "2024-07-30T20:55:42.634827", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 2.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1,float i){\n    p += sin(p.yzx+iTime*i*3.0)/(i*27.0); //animation\n    return size-length(sin(p/vec3(length(p/20.0)))*size1)/1.8;\n}\n\nfloat vines(vec3 p,float size1){\n\treturn vines(p,size1,1.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*250.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = multiplier;\n\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p.yzx*i)/i;\n        result = min(result,vines(p,size1,i)/(i));\n        i *= multiplier;\n    }\n    return (result+3.0)*scale/20.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n        viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    vec3 eye = vec3(50.0,1.6,iTime/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 631, 671, 671, 790], [792, 792, 824, 824, 854], [856, 856, 880, 880, 1193], [1195, 1195, 1223, 1223, 1371], [1373, 1794, 1885, 1885, 2209], [2224, 2478, 2543, 2543, 2675], [2677, 2766, 2795, 2795, 3110], [3112, 3604, 3744, 3744, 4354], [4356, 4726, 4811, 4811, 5158], [5160, 5487, 5536, 5571, 5702], [5704, 5704, 5761, 5761, 6753]], "test": "untested"}
{"id": "ttjyDw", "name": "Hextiled back image", "author": "mrange", "description": "License CC0: Hextiled back image\nMore experimenting with back images for webpages. This is less demanding than previous one.", "tags": ["2d", "backimage"], "likes": 8, "viewed": 468, "published": 3, "date": "1594576980", "time_retrieved": "2024-07-30T20:55:43.400779", "image_code": "// License CC0: Hextiled back image\n// More experimenting with back images for webpages. This is less demanding than previous one.\n//  Code copied from IQ, ollj and others\n    \n#define PI              3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define SCA(a)          vec2(sin(a), cos(a))\n\n// SABS - A very useful function copied from ollj - https://www.shadertoy.com/view/Ws2SDK\n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nuniform float iOffset;\n\nconst mat2 rot120   = MROT(TAU/3.0);\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst vec2 n1       = normalize(sz.yx);\nconst float radius  = 0.5/sqrt(3.0);\nconst vec2 off1     = 2.0*radius*n1;\nconst vec2 off2     = rot120*off1;\nconst vec2 off3     = rot120*off2;\n\nconst vec2 sca0 = SCA(0.0);\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\n// Various distance functions from: https://iquilezles.org/articles/distfunctions2d\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nfloat letteri(vec2 p) {\n  p.y -= 0.25;\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterm(vec2 p) {\n  p.y = -p.y;\n  float l = horseshoe(p - vec2(+0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  float r = horseshoe(p - vec2(-0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  return min(l, r);\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat impulse(vec2 p) {\n  p.x += 0.6;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float di = letteri(p - vec2(oi, 0.0));\n  float dm = letterm(p - vec2(om, 0.0));\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1E6;\n  d = min(d, di);\n  d = min(d, dm);\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n\n  return d;\n}\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz*1.0, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(length(p1) < length(p2)));\n  vec2 n = p3 - p;\n  p = p3;\n\n  return n;\n}\n\nfloat cell(vec2 p) {\n  float d0 = circle(p-off1, radius);\n  float d1 = circle(p-off2, radius);\n  float d2 = circle(p-off3, radius);\n   \n  float d = d0;\n  d = min(d, d1);\n  d = min(d, d2);\n  \n  return d;\n}\n\nfloat tnoise(vec2 p) {\n  const float width = 0.125;\n\n  vec2 nn = hextile(p);\n  nn = round(nn*10.0);\n  float r1 = hash(nn);\n  rot(p, floor(r1*6.0)* TAU/6.0);\n\n  float d = cell(p);\n  d = abs(d) - width;\n   \n  float r = clamp((-d+0.0125)/width, 0.0, 1.0);\n  float h = r*r*r*(r*(r*6.0-15.0)+10.0);\n\n  return h;\n}\n\nfloat warp(vec2 p, vec2 q) {\n  // The result of lot of experimenting and very little thought\n  q = -1.0 + 2.0*q;\n  float l = 1.0-1.0*length(q)/sqrt(2.0);\n  vec2 o = 10.75*normalize(vec2(1.0, 1.0));\n  rot(o, TIME*0.001);\n  p *= 0.25;\n  vec2 v = l*vec2(tnoise(p), tnoise(p+o));\n  rot(v, 1.0+TIME*0.075);\n  v = SABS(v, vec2(0.1));\n  return 0.75*(0.5 + 0.5*tanh(atan(v.y, v.x)));\n}\n\nfloat height(vec2 p, vec2 q) {\n  float a = 0.005*TIME;\n  p += 5.0*vec2(cos(a), sin(sqrt(0.5)*a));\n  return warp(p, q);\n}\n\nvec3 normal(vec2 p, vec2 q) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/RESOLUTION.y, 0.0);\n\n  vec3 n;\n\n  n.x = height(p + eps.xy, q) - height(p - eps.xy, q);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx, q) - height(p - eps.yx, q);\n\n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75));\n  col=col*0.6+0.4*col*col*(3.0-2.0*col);\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);\n  return col;\n}\n\nfloat df(vec2 p) {\n  p *= 3.0;\n  float d = impulse(p);\n  return d;\n}\n\nvec3 effect(vec2 p, vec2 q) {\n  const vec3 lp1 = vec3(0.8, -0.75, 0.8);\n  const vec3 lp2 = vec3(-0., -1.5, -1.0);\n  const vec3 eye = vec3(0.0, -2.0, 0.0);\n\n  float aa = 8.0/RESOLUTION.y;\n\n  vec3 col = vec3(0.0);\n  float h = height(p, q);\n  vec3 pp = vec3(p.x, h, p.y);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n  vec3 ed = normalize(eye - pp);\n\n  float off = iOffset;\n\n  vec2 bp = p;\n  vec2 lp = p;\n  bp.y += 0.5*off;\n  lp.y += off;\n\n  vec3 n = normal(bp, q);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n  float spe1 = max(dot(reflect(-ld1, n), ed), 0.0);\n  float spe2 = max(dot(reflect(-ld2, n), ed), 0.0);\n  const vec3 baseCol1 = vec3(0.6, 0.8, 1.0);\n  const vec3 baseCol2 = sqrt(baseCol1.zyx);\n\n  col += baseCol1*pow(diff1, 16.0);\n  col += 0.1*baseCol1*pow(diff1, 4.0);\n  col += 0.15*baseCol2*pow(diff2,8.0);\n  col += 0.015*baseCol2*pow(diff2, 2.0);\n  col += pow(spe1, 50.0)*sqrt(baseCol1)*1.0;\n  col += pow(spe2, 25.0)*sqrt(baseCol2)*1.0;\n\n  col = clamp(col, 0.0, 1.0);\n  col = mix(0.05*baseCol1, col, 1.0 - (1.0 - 0.5*diff1)*exp(- 2.0*smoothstep(-.1, 0.05, (h))));\n\n  float d = df(lp);\n  float bd = abs(d - 0.03) - 0.015;\n\n  float shd = pow(psin(-0.25*TIME+(lp.x-lp.y)*1.5), 4.0);\n  col += 1.0*baseCol1*(exp(-20.0*bd))*shd;\n  col += 0.5*baseCol1*(exp(-1.0*bd))*shd;\n  col -= 0.125*vec3(1.0)*(exp(-2.5*d));\n  col = clamp(col, 0.0, 1.0);\n\n  const float fadeIn = 6.0;\n  col *= smoothstep(0.0, fadeIn*fadeIn, TIME*TIME);\n\n  col = mix(col, vec3(1.0), smoothstep(0.0, aa, -d));\n\n  col = postProcess(col, q);\n  \n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n\n  vec3 col = effect(p, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjyDw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[959, 959, 983, 983, 1053], [1055, 1055, 1076, 1076, 1105], [1107, 1107, 1140, 1140, 1225], [1227, 1227, 1266, 1266, 1355], [1357, 1357, 1396, 1396, 1425], [1427, 1511, 1542, 1542, 1568], [1570, 1570, 1597, 1597, 1673], [1675, 1675, 1725, 1725, 1942], [1944, 1944, 1967, 1967, 2020], [2022, 2022, 2045, 2045, 2223], [2225, 2225, 2248, 2248, 2378], [2380, 2380, 2403, 2403, 2476], [2478, 2478, 2501, 2501, 2538], [2540, 2540, 2563, 2563, 2820], [2822, 2822, 2845, 2845, 2923], [2925, 2925, 2948, 2948, 3679], [3681, 3681, 3709, 3808, 3975], [3977, 3977, 3997, 3997, 4181], [4183, 4183, 4205, 4205, 4491], [4493, 4493, 4521, 4585, 4870], [4872, 4872, 4902, 4902, 4992], [4994, 4994, 5023, 5056, 5266], [5268, 5268, 5305, 5305, 5512], [5514, 5514, 5532, 5532, 5582], [5584, 5584, 5613, 5613, 7169], [7171, 7171, 7226, 7226, 7386]], "test": "untested"}
{"id": "Wl2yWm", "name": "Stellar evolution", "author": "michael0884", "description": "Toy model of a self-gravitating gas\nThe gas has pressure proportional to density^2 \nThe gravity is solved by an future estimating Jacobi like iterative thing, even that is not sufficient.", "tags": ["particles", "ca"], "likes": 75, "viewed": 2506, "published": 3, "date": "1594572776", "time_retrieved": "2024-07-30T20:55:44.350240", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    rho.z *= 5.;\n    //rho.w = tanh(rho.w);\n    vec3 dx = vec3(-3., 0., 3.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    float specular = pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0.5, fluid_rho*2., rho.z),0.1);\n   \n    col.xyz = 0.02*vec3(0.2, 0.5, 1.)*rho.w;\n    col.xyz += vec3(1., 0.7, 0.5)*rho.z;\n    \n    col.xyz = tanh(col.xyz);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define temporal_blurring 0.98\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(float rho)\n{\n    return 1.*rho*rho + 1.*pow(rho, 10.); //gas + supernova\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.2)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.6), R*vec2(1.5, 2.));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X; //\n    vec2 V; //velocity\n    float M; //mass\n    float I; //angular velocity\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.z;\n    P.I = data.w;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M, P.I);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 0.92\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n   \n    //pass 1 - get center of mass\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        \n        //add mass\n        P.M += m;\n    }\n    \n    //normalization\n    if(P.M != 0.)\n    {\n        P.X /= P.M;\n    }\n    \n    //moment of inertia\n    float I = 0.;\n    //pass 2 - get velocity and angular momentum\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        vec3 D = distribution(P0.X, pos, dif);\n       \n        //the deposited mass into this cell\n        float m = P0.M*D.z;\n        \n        vec2 dx = P0.X - P.X;\n      \n\t\tfloat W = P0.I; \n        //relative velocity of this part of the square\n        vec2 rel_V = P0.V + W*vec2(dx.y, -dx.x);\n        float v = length(P.V);\n    \trel_V /= (v > 2.)?v:1.;\n        \n        //add momentum\n        P.V += rel_V*m;\n        //add angular momentum\n        P.I += (dx.x*P0.V.y - dx.y*P0.V.x)*m;\n        //add moment of inertia\n        I += dot(dx, dx)*m;\n    }\n   // I = max(I, 0.1);\n    //normalization\n    if(P.M != 0.)\n    {\n        P.V /= P.M; //get velocity\n        P.I /= I;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, sampler2D chG, inout particle P, vec2 pos)\n{\n    //Compute the forces\n    vec2 F = vec2(0.);\n    float w = 0.;\n    vec3 avgV = vec3(0.);\n    //local gravity potential\n    float lU = pixel(chG, P.X).w;\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M*(Pf(P.M) + Pf(P0.M)); \n        //gas pressure\n        F -= 0.5*G(1.*dx)*avgP*dx;\n        \n        //neighbor gravity potential\n        float rU = pixel(chG, P0.X).w;\n        \n        //gas gravity\n        F -= 0.0015*P.M*dx*clamp(lU - rU, -15., 15.)*G(1.*dx);\n        avgV += G(1.*dx)*vec3(P0.V,1.);\n    }\n    \n    avgV /= avgV.z;\n\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/9.;\n        F += 0.003*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 2.*P.M*N.xy*exp(-abs(N.z));\n    if(N.z < 5.) \n    {\n        //P.X = pos;\n        P.V *= 0.;\n       // P.M = 2.*fluid_rho;\n    }\n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n    //angular momentum limit\n    P.I = P.M*clamp(P.I/P.M, -0.5, 0.5);\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    //particle velocity, mass and grid distributed density\n    vec2 F = vec2(0.);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 1.) \n        {\n            vec2 dC = pos - R*0.5;\n            P.X = pos;\n            P.V = 0.*(rand.xy-0.5) + 0.5*vec2(dC.y/R.x, -dC.x/R.x);\n            P.M = 0.005*mass;\n            P.I = 0.;\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = 1e-6;\n            P.I = 0.;\n        }\n    }\n    \n   \n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos); \n    \n   \n    if(P.M != 0.) //not vacuum\n    {\n        Simulation(ch0, ch1, P, pos);\n    }\n    \n   \n\t/*\n    if(length(P.X - R*vec2(0.2, 0.9)) < 10.) \n    {\n        P.X = pos;\n        P.V = 0.5*Dir(-PI*0.25 + 0.3*sin(0.3*time));\n        P.M = mix(P.M, vec2(fluid_rho, 0.), 0.4);\n    }*/\n    \n    if(length(pos - R*vec2(0.5, 0.1)) < 10.) \n    {\n      // P.I = 0.2;\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n//gravity solved by using a Jacobi-like solver with future estimation\n#define Rad 4\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    float U = 0.;\n    vec3 avgV = vec3(0.00, 0, 0.0000001);\n    vec4 avgU = vec4(0.00, 0, 0, 0.00000001);\n    vec4 dd = pixel(ch1, pos);\n    range(i, -Rad, Rad) range(j, -Rad, Rad)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        vec2 dx = pos - x0;\n        rho += 1.*vec4(P.V, P.M, P.I)*G(dx/1.5); \n       \n        //local potential\n        U += P0.M/(length(dx)+0.1);\n        //local average velocity\n        avgV += vec3(P0.V, 1.)*G(ij/1.)*P0.M; \n        \n        //advected blurring, \n        //i.e. estimating where the past potential could have moved \n        vec3 pU = pixel(ch1, pos + ij - dd.xy*dt).xyw;\n        avgU += vec4(pU, 1.)*G(ij/3.); //blurring field\n    }\n    \n    //spacio-temporally blurred velocity\n    rho.xy = mix(avgV.xy/avgV.z, avgU.xy/avgU.w, 0.95);\n                  \n    //spacio-temporally blurred gravitational potential\n    rho.w = U + temporal_blurring*avgU.z/avgU.w;\n                  \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 205], [207, 207, 243, 243, 293], [295, 295, 311, 311, 339], [341, 341, 386, 386, 1316]], "test": "untested"}
{"id": "ttByRm", "name": "Hacking the Gibson", "author": "dean_the_coder", "description": "Inspired by the 'Hackers' movie, when they 'hack the Gibson'.\n\nThe scene is made entirely out of accumulated 'glow', so the edges aren't as sharp as 'normal' raymarching. I liked the experiment though...\n(PS. The 'code' is obviously fake!)", "tags": ["3d", "raymarching", "glow", "hackers"], "likes": 43, "viewed": 1119, "published": 3, "date": "1594572040", "time_retrieved": "2024-07-30T20:55:45.121179", "image_code": "// 'Hacking the Gibson' dean_the_coder (Twitter: @deanthecoder)\n// https://www.shadertoy.com/view/ttByRm\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others for sharing their knowledge!\n// Thanks FabriceNeyret2 for the text code: https://www.shadertoy.com/view/llySRh\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time = 0.0;\n\n// Random number generator.\nfloat hash(float p) {\n    return fract(sin(dot(p, 123.45)) * 5432.3);\n}\n\n// 2D rotation matrix.\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\n// SDF box function.\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n// SDF line function.\nfloat sdLine(vec3 p, vec3 a, vec3 b) {\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n// SDF to a lightning bolt-stle line.\nfloat sdBolt(vec3 p, vec3 a, vec3 b, float id) \n{\n    float d = 1e7;\n    vec3 dp = (b - a) / 5.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = i + floor((time + id) * 2.0);\n        d = min(d, sdLine(p, a + vec3(0.0, hash(t), 0.0), a + dp + vec3(0.0, hash(t + 1.0), 0.0)));\n        a += dp;\n    }\n    \n    return d;\n}\n\n// SDF 'framed' box function.\nfloat sdFramedBox(vec3 p, vec3 b) {\n\t// Thanks iq.\n    p = abs(p) - b;\n    vec3 q = abs(p);\n    return min(min(\n        length(max(vec3(p.x, q.y, q.z), 0.0)) + min(max(p.x, max(q.y, q.z)), 0.0),\n        length(max(vec3(q.x, p.y, q.z), 0.0)) + min(max(q.x, max(p.y, q.z)), 0.0)),\n        length(max(vec3(q.x, q.y, p.z), 0.0)) + min(max(q.x, max(q.y, p.z)), 0.0));\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec4 minD(vec4 a, vec4 b) {\n    return a.x < b.x ? a : b;\n}\n\nconst vec3 s = vec3(2.0, 6.0, 2.0);\nvec2 sdTower(vec3 p) {\n    p.y -= s.y;\n    \n    // Frame glow.\n    float outline = sdFramedBox(p, s);\n    float glow = 0.001 / (0.001 + outline * outline);\n    \n    // Base glow.\n    float d = sdBox(p + vec3(0.0, s.y, 0.0), vec3(s.x, 0.01, s.z));\n    glow += 0.001 / (0.001 + d * d);\n    \n    // Writing glow.\n    d = sdBox(p, s);\n    if (d > 0.0 && d < 0.075) {\n        glow += 0.03;\n         \n        vec2 uv = (p.xy + s.xy) / (2.0 * s.xy);\n        uv.x *= 0.8;\n        uv.y = mod(uv.y * 1.6 - 0.5, 1.0);\n        glow += texture(iChannel0, uv).r;\n    }\n    \n\treturn vec2(d, glow);\n}\n\nvoid applyTowerGap(inout vec3 p) {\n    p.z = mod(p.z, 9.0) - 4.5;\n}\n\n// Distance to the lightning bolts.\nfloat bolt(vec3 p, float id) {\n    float t = fract(time * 0.04 * hash(id) + id);\n    if (id > 12.5) t = 1.0 - t;\n    float h = mix(-50.0, s.y * 1.95, t);\n    \n    vec3 a = vec3(s.x, h, -s.z);\n    vec3 b = vec3(s.x, h, s.z);\n\n    if (hash(id) > 0.5) {\n        a.x = -a.x;\n        b.x = -b.x;\n    }\n\n    return sdBolt(p, a, b, id);\n}\n\n// Collection of towers.\nvec4 sdTowers(vec3 p) {\n    float id = hash(floor(p.z / 9.0)) * 25.0;\n    p.x = mod(p.x, 12.0) - 6.0;\n    applyTowerGap(p);\n\n    // Lightning bolts.\n    float boltD = bolt(p, id);\n    float boltGlow = step(0.0, p.y) * 0.01 / (0.01 + boltD * boltD);\n    \n    return vec4(sdTower(p), 0.0, boltGlow);\n}\n\n// SDF to the floor.\nvec3 sdFloor(vec3 p) {\n    if (p.y > 3.0) {\n        // Ray not near the ground - Abort early.\n        return vec3(1e10, 0.0, 0.0);\n    }\n    \n    vec3 pp = p;\n    \n    applyTowerGap(p);\n    \n    p.x = abs(p.x + 1.6) - 0.4;\n    p.z -= 4.5;\n   \n    const vec2 wh = vec2(0.1, 0.01);\n    float d = sdBox(p, vec3(wh, 1e10));\n    d = min(d, sdBox(p.zyx - vec3(0.0, 0.0, 100.0), vec3(wh, 100.0)));\n\n    if (pp.x > 0.0) {\n    \td = min(d, sdBox(p - vec3(2.0, 0.0, 0.0), vec3(wh, 3.0)));\n    \td = min(d, sdBox(p - vec3(4.0, 0.0, -6.0), vec3(wh, 3.0)));\n    \td = min(d, sdBox(p - vec3(3.0, 0.0, -3.0), vec3(wh, 1.1).zyx));\n    } else {\n    \td = min(d, sdBox(p - vec3(2.5, 0.0, -8.0), vec3(wh, 1.5)));\n    }\n    \n    float glow = 0.001 / (0.001 + d * d);\n    float t = time * 10.0;\n    \n    float pulse1 = sin((pp.z + t) * 0.02);\n    float pulse2 = sin((pp.z + t) * 0.02 - 0.6);\n    float pulse = step(0.999, pow(0.5 + 0.5 * max(pulse1, pulse2), 10.0));\n    return vec3(d, glow - pulse, sqrt(glow) * pulse * 3.0);\n}\n\nvec4 map(vec3 p) {\n    // dist/white_glow/yellow_glow/blue_glow\n    return minD(sdTowers(p), vec4(sdFloor(p), 0.0));\n}\n\nvec3 calcNormal(in vec3 p) {\n    // Thanks iq.\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvoid initCamera(out vec3 ro, out vec3 rd, vec2 uv) {\n    vec3 lookat;\n    float intro = time / 32.0;\n\n    ro = vec3(2.0 * sin(time * 0.05), 1.5 + 11.0 * smoothstep(0.0, 1.0, (0.5 + 0.5 * cos(time * 0.05))), time - 32.0 + 6.4);\n    lookat = ro + vec3(-smoothstep(-2.0, 2.0, ro.x) * 0.5, -sin(time * 0.06) * 0.4, 2.0);\n    if (intro < 1.2) {\n        vec3 intro_ro = vec3(-6.0 * (1.0 - intro), 11.5 - time / 32.0, 6.7);\n        vec3 intro_lookat = intro_ro + vec3(0.0, -0.5, 1.0);\n        \n        {\n            float trans = clamp((intro - 1.0) * 5.0, 0.0, 1.0);\n            ro = mix(intro_ro, ro, trans);\n            lookat = mix(intro_lookat, lookat, trans);\n        }\n    }\n    \n    rd = getRayDir(ro, lookat, uv);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    time = iTime * 8.0;\n\n    // Position camera and view direction.\n    vec3 ro, rd;\n    initCamera(ro, rd, uv);\n\n    vec3 col = vec3(0.3, 0.1, 0.4) * max(0.0, rd.y * 0.2); // Sky gradient\n    \n    // Raymarch.\n    const float maxDist = 100.0;\n    float d = 0.0;\n    float alpha = 1.0;\n    for (float steps = 0.0; steps < 80.0; steps++) {\n        vec3 p = ro + rd * d;\n        vec4 h = map(p); // Distance, glow1, glow2, glow3\n\n        if (abs(h.x) < 0.005) {\n            // We've hit something. Reduce opacity and keep marching.\n            h.x = 0.1;\n            alpha *= 0.2;\n        }\n\n        if (d >= maxDist) // Max draw distance reached - Stop.\n            break;\n        if (p.y < -0.5) // Ray is below the ground - Stop.\n            break;\n\n        // Accumulate the glow.\n\t    float fog = pow(1.0 - d / maxDist, 3.0);\n        vec3 whiteGlow = vec3(0.5, 0.6, 1.0);\n        vec3 rgb = whiteGlow * max(0.0, (h.y - h.z)) + vec3(1.0, 0.4, 0.02) * h.z;\n        rgb += whiteGlow * max(0.0, (h.y - h.w)) + vec3(0.2, 0.3, 1.0) * h.w;\n        col += rgb * fog * alpha;\n\n        d += abs(h.x);\n    }\n\n    // Output to screen.\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23356, "src": "https://soundcloud.com/thanatos-ventrue/halcyon-on-on#t=2:30", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "buffer_a_code": "// 'Hacking the Gibson'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq and a bunch of others for sharing their knowledge!\n// Thanks FabriceNeyret2 for the text code: https://www.shadertoy.com/view/llySRh\n\n#define RET(a) uv.y += 1.0; uv.x += a * 0.45\n#define SPC uv.x -= 0.45\n#define CHR(x)  g += char(uv, x); SPC\n\nfloat char(vec2 p, int c) {\n    if (p.x < 0.0 || p.x > 1.0 || p.y < 0.0 || p.y > 1.0)\n        return 0.0;\n    vec2 dFdx = dFdx(p / 16.0), dFdy = dFdy(p / 16.0);\n\treturn textureGrad(iChannel0, p / 16.0 + fract(vec2(c, 15 - c / 16) / 16.), dFdx, dFdy).r;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    uv.y -= 1.0;\n    uv *= 16.0;\n    uv.y += 1.0;\n    \n\tfloat g = 0.0;\n    CHR(47); CHR(47); SPC; CHR(70); CHR(114); CHR(111); CHR(109); SPC; CHR(68); CHR(101); CHR(97); CHR(110); CHR(84); CHR(104); CHR(101); CHR(67); CHR(111); CHR(100); CHR(101); CHR(114); CHR(46);\n    RET(21.0);\n    CHR(119); CHR(104); CHR(105); CHR(108); CHR(101); SPC; CHR(40); CHR(49); CHR(41);\n    RET(9.0);\n    CHR(123);\n    RET(1.0); SPC; SPC; CHR(99); CHR(111); CHR(117); CHR(116); SPC; CHR(60); CHR(60); SPC; CHR(34); CHR(89); CHR(111); SPC; CHR(70); CHR(108); CHR(111); CHR(112); CHR(105); CHR(110); CHR(101); CHR(33); CHR(92); CHR(110); CHR(34); CHR(59);\n    RET(26.0); SPC; SPC; CHR(105); CHR(110); CHR(105); CHR(116); CHR(95); CHR(69); CHR(118); CHR(118); CHR(118); CHR(118); CHR(105); CHR(108); CHR(40); CHR(34); CHR(66); CHR(114); CHR(111); CHR(115); CHR(107); CHR(105); CHR(34); CHR(41); CHR(59);\n    RET(25.0); SPC; SPC; CHR(97); CHR(112); CHR(112); CHR(108); CHR(121); CHR(73); CHR(81); CHR(66); CHR(114); CHR(97); CHR(105); CHR(110); CHR(115); CHR(40); CHR(41); CHR(59);\n    RET(18.0);\n    SPC; SPC; CHR(65); CHR(114); CHR(116); CHR(79); CHR(102); CHR(67); CHR(111); CHR(100); CHR(101); SPC; CHR(43); CHR(61); SPC; CHR(66); CHR(105); CHR(103); CHR(87); CHR(105); CHR(110); CHR(103); CHR(115); CHR(59);\n    RET(24.0);\n    CHR(125);\n    RET(1.0);\n    RET(0.0);\n    CHR(118); CHR(111); CHR(105); CHR(100); SPC; CHR(72); CHR(97); CHR(99); CHR(107); CHR(84); CHR(104); CHR(101); CHR(80); CHR(108); CHR(97); CHR(110); CHR(101); CHR(116); CHR(40); CHR(41); SPC; CHR(123);\n    RET(22.0);\n    SPC; SPC; CHR(47); CHR(47); SPC; CHR(84); CHR(79); CHR(68); CHR(79); SPC; CHR(45); SPC; CHR(87); CHR(97); CHR(116); CHR(99); CHR(104); SPC; CHR(72); CHR(97); CHR(99); CHR(107); CHR(101); CHR(114); CHR(115); CHR(46);\n    RET(26.0);\n    SPC; SPC; CHR(114); CHR(101); CHR(116); CHR(117); CHR(114); CHR(110); CHR(59);\n    RET(9.0);\n    CHR(125);\n    \n\tvec3 col = vec3(g);\n    fragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByRm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[400, 428, 449, 449, 499], [501, 524, 543, 543, 619], [621, 642, 671, 671, 766], [768, 790, 828, 828, 953], [955, 993, 1042, 1042, 1322], [1324, 1354, 1389, 1404, 1718], [1720, 1720, 1767, 1767, 1972], [1974, 1974, 2001, 2001, 2033], [2071, 2071, 2093, 2093, 2655], [2657, 2657, 2691, 2691, 2724], [2726, 2762, 2792, 2792, 3093], [3095, 3120, 3143, 3143, 3419], [3421, 3442, 3464, 3464, 4445], [4447, 4447, 4465, 4510, 4565], [4567, 4567, 4595, 4613, 4813], [4902, 4902, 4943, 4943, 5084], [5086, 5086, 5138, 5138, 5803], [5805, 5805, 5860, 5860, 7199]], "test": "untested"}
{"id": "3l2cDm", "name": "Quad Glow", "author": "Paltoquet", "description": "animating a solid noise with a distance field from a quad", "tags": ["glow", "hover"], "likes": 3, "viewed": 431, "published": 3, "date": "1594571504", "time_retrieved": "2024-07-30T20:55:45.957942", "image_code": "// Author: Thibault Ober\n// Title: Glow Effect\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nuniform vec2 u_resolution;\nuniform vec2 u_mouse;\nuniform float u_time;\n\n#define PI 3.142\n#define tableSize 255.0\n#define numLayers 5.0\n\nfloat rect(vec2 p, vec2 size) {  \n  vec2 d = abs(p) - size;\n  return min(max(d.x, d.y), 0.0) + length(max(d,0.0));\n}\n\nfloat easingOut(float val) {\n    return 1.0 - pow(1.0 - val, 5.0);\n}\n\nfloat getAngle(vec2 pos) {\n    float coef = 1.0; //getCurrentTime();\n    float theta = atan(pos.y, pos.x);\n    theta = theta + coef * 2.0 * PI;\n    return theta;\n}\n\nfloat _smoothstep(float val){\n    return val * val * (3.0 - 2.0 * val); \n}\n\nfloat random (vec2 val) {\n    return fract(sin(dot(val,vec2(12.9898,78.233)))* 43758.513);\n}\n\nfloat noise(vec2 p){\n    float xi = floor(p.x); \n    float yi = floor(p.y); \n\n    float tx = p.x - xi; \n    float ty = p.y - yi; \n\n    float rx0 = mod(xi, tableSize); \n    float rx1 = mod(rx0 + 1.0, tableSize); \n    float ry0 = mod(yi, tableSize) ;\n    float ry1 = mod(ry0 + 1.0, tableSize); \n    \n    float c00 = random(vec2(rx0, ry0)); \n    float c10 = random(vec2(rx1, ry0)); \n    float c01 = random(vec2(rx0, ry1)); \n    float c11 = random(vec2(rx1, ry1));\n    \n    float sx = _smoothstep(tx);\n    float sy = _smoothstep(ty);\n    \n    float nx0 = mix(c00, c10, sx);\n    float nx1 = mix(c01, c11, sx);\n    \n    float result = mix(nx0, nx1, sy);\n    return result;\n}\n\nfloat fbm(vec2 pos){\n    float accelerator = 80.384;\n    float dt = iTime * accelerator;\n    \n    pos.x += dt;\n    pos.y += dt;\n    \n    float brownianNoise = 0.0; \n\tfloat rateOfChange = 2.0; \n    float baseFrequency = 0.03;\n    float noiseMax = 1.000;\n    float relight = 1.5 + sin(u_time) / 2.0;\n    for (float i = 0.0; i < numLayers; ++i) \n    {\n        float frequency = baseFrequency * pow(rateOfChange, i);\n        float amplitude = pow(rateOfChange, i);\n        brownianNoise += noise(pos * frequency) / amplitude; \n        noiseMax += 1.0 / amplitude;\n    } \n    \n    brownianNoise = brownianNoise / noiseMax;\n    brownianNoise *= relight;\n    brownianNoise = clamp(0.0, 1.0, brownianNoise);\n    \n    return brownianNoise;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float width = 0.8;\n    vec2 screenPos = fragCoord;\n    vec2 st = screenPos/iResolution.xy;\n    st = st * vec2(2.0) - vec2(1.0);\n    \n    float noise = fbm(screenPos);\n    float border = rect(st, vec2(width));\n    float glowRadius = 0.160;\n    float val = 0.0;\n    vec3 color = vec3(0.0);\n    if(border < glowRadius) {\n        vec4 firstColor = vec4(0.975,0.580,0.004,1.000);\n    \tvec4 secondColor = vec4(0.957,0.980,0.858,1.000);\t\n        float range = 1.0 - glowRadius;\n        float easing = 1.0 - border;\n        float coef = 1.0 / glowRadius;\n        float dist = (easing - range) * coef;\n        val = dist * noise;\n        \n        color = mix(firstColor.xyz, secondColor.xyz, val);\n        color = mix(vec3(0.0), color, dist);\n    } \n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2cDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[230, 230, 261, 261, 346], [348, 348, 376, 376, 416], [418, 418, 444, 444, 581], [583, 583, 612, 612, 657], [659, 659, 684, 684, 751], [753, 753, 773, 773, 1421], [1423, 1423, 1443, 1443, 2155], [2157, 2157, 2214, 2214, 2999]], "test": "untested"}
{"id": "3t2cDm", "name": "Sea cucumbers", "author": "jarble", "description": "This is an edit of my [url=https://www.shadertoy.com/view/wtSyDR]\"vine forest variations.\"[/url] These strange creatures look almost like sea cucumbers.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "recursion"], "likes": 2, "viewed": 304, "published": 3, "date": "1594566487", "time_retrieved": "2024-07-30T20:55:46.917377", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = 9.0;\n    for(int k = 0; k < 2; k++){\n    \tp = sin(p/i)*i-sin(p.yzx*i/(9.0)+iTime*9.0)/i;\n        //float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    \ti *= 9.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*600.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth/50.0+1.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(-35.0,1.0,iTime);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    p = eye+dist*worldDir;\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define image_scale 4.0\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = cos(p/size1);\n    p = (sin(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.83;\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = 9.0;\n    for(int k = 0; k < 2; k++){\n    \tp = sin(p/i)*i-sin(p.yzx*i/(9.0)+iTime*9.0)/i;\n        //float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    \ti *= 9.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*600.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(depth/50.0+1.0)*2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n        viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0); //wobble\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0); //wobble\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 83, 83, 502], [504, 504, 532, 532, 680], [683, 1104, 1195, 1195, 1518], [1533, 1787, 1852, 1852, 1984], [1986, 2075, 2104, 2104, 2414], [2416, 2908, 3048, 3048, 3658], [3660, 4030, 4115, 4115, 4462], [4464, 4791, 4840, 4875, 5006], [5008, 5008, 5035, 5035, 5184], [5186, 5186, 5243, 5243, 5914]], "test": "untested"}
{"id": "3tjcDm", "name": "Animated Sinusoid - TBOS 5.0", "author": "stungeye", "description": "Chapter 5 - The Book of Shaders - Shaping Functions\n\nSinusoidal background gradient with function plotted over top.", "tags": ["simple", "gradient", "sine", "tbos"], "likes": 1, "viewed": 364, "published": 3, "date": "1594565641", "time_retrieved": "2024-07-30T20:55:47.686321", "image_code": "// Working Through The Book of Shaders\n// Chapter 05 - Shaping Functions - https://thebookofshaders.com/05/\n// 5.0 - Animated Sinusoid - Details: https://shader-journey.netlify.app/docs/5-shaping-functions\n\n#define PI 3.14159265358979\n\n// Plot a line on Y using a value between 0.0-1.0\nfloat plot(vec2 st, float pct){ // (st = texture coordinates) (pct = percentage from 0.0 to 1.0)\n    \n  const float width_factor = 0.007;\n    \n  return  smoothstep(pct - width_factor, pct, st.y) \n          - smoothstep(pct, pct + width_factor, st.y);\n}\n\nvoid mainImage(out vec4 fragColor,  // Output (r, g, b, a) pixel color \n               in vec2 fragCoord) { // Input (x, y) image coordinate\n    \n\tconst vec3 plot_colour = vec3(1.,0.,1.); // Colour of our plot. \n    \n    vec2 st = fragCoord / iResolution.xy;    // Normalize texture coordinates from 0.0 to 1.0 in x and y.\n\n    float y = sin(st.x * PI + iTime);        // y is a sinusoid based on x position and time.\n          y = 0.5 * y + 0.5;                 // Scale and offset y to center plot.\n    \n    float plot = plot(st, y);                // Create a plot of y.\n    \n    vec3 colour = vec3(y, y, y);             // Black to white background gradient. Also: vec3(y) \n         colour *= 1. - plot;                // Remove gradient \"below\" where plot will be draw.\n         colour += plot * plot_colour;       // Paint the xy-plot.\n\n\tfragColor = vec4(colour, 1.0);           // Set pixel colour.\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[236, 286, 317, 382, 538], [540, 540, 647, 680, 1447]], "test": "untested"}
{"id": "Wt2cWm", "name": "Moebius Lizard - filled", "author": "FabriceNeyret2", "description": "filled version of \"Moebius Lizard\", Escher-like tiling on Moebius spiral, by iapafoto. [url]https://shadertoy.com/view/wtjyz1[/url]\nMouse control.", "tags": ["2d", "mobius", "escher", "lizard", "moebus"], "likes": 15, "viewed": 456, "published": 3, "date": "1594562888", "time_retrieved": "2024-07-30T20:55:48.457260", "image_code": "// === variant of \"Moebius Lizard\" by iapafoto. https://shadertoy.com/view/wtjyz1\n// see study here :  https://shadertoy.com/view/WtBcRD\n// Here: filled shapes\n\n// --- L() get the distance d of p=U-a to segment(a-a,b-a) \n// AND get whether pixel in/out shape by counting the number of intersection with [U,U+(0,inf)]\n//     for close contours, n is odd inside and even outside.\n// l get the label of the closest line\nvec2 q; float s,c,v,d=1e3; int k,n=0;\n#define L(p,l) v = length( q = p-b*( c = clamp( s = dot(p,b)/dot(b,b),0.,1.))); \\\n               if (v<d) d=v, k=l;                                               \\\n               c = clamp ( s = (p).y/b.y, 0.,1.);                               \\\n               if ( c == s && s * b.x > (p).x ) n++\n            \n// --- T encodes shape, turned 4x by Pi/2, + copied trough tiles.\n// note that a Lizard is contoured by 3 of these.        Vsame Yv                         Vsame xV\nint[] T = int[](6,0,9,2,12,5,6,10,0,20,  6,26,  12,20,11,17,14,17,17,18,15,22,11,26,16,26,22,18,22,27,25,28,28,30,30,26\n          // left hand  - left of head (10)head right of head                   -                right foot\n    ,     // completed contour. Used only with FILL=2\n    26,24,28,21,29,18,38,18,30,12,30,7,34,11,38,13,39,10,39,7,36,8,  30,2,    24,8,14,2,9,-4,6,-1,4,2, 6,0 );\n          //       ^same y^                        ^same x^           <- possible issues\n\nvoid drawTile(vec2 m, int i, int r) {\n    vec2 a = vec2(T[i  ],T[i+1]),\n         b = vec2(T[i+2],T[i+3]) - a;\n    L(m-a, 4*r);\n}\n    \nvoid mainImage(out vec4 O, vec2 u ) {\n    \n    vec2 R = iResolution.xy, D = vec2(6,2),\n         m = 2.*iMouse.xy/R,\n         U = (u - .5*R) / R.y ,z = U + vec2(1,0), \n         g = vec2(30,26), I;   \n    float w = 3.*48./R.y;\n#if 0                                    // tile plane\n    U *= 1.3; I = floor(U+.5); U *= 48.;\n#else \t                                 // tile Moebius spiral\n    U *= mat2(z,-z.y,z) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n\tU =  m + log(length(U)) *vec2(.5,-1) + iTime/20.\n           + a*D;\n // w = 48.* determinant(mat2(dFdx(U),dFdy(U)));  // Jacobian to eval distortions, see https://www.shadertoy.com/view/WlByRW\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // eliminate atan discont, see  https://www.shadertoy.com/view/WlScRW\n    float dax = dFdx(a), day = dFdy(a),\n           dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n           dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n    dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n    w = determinant(mat2(dFx,dFy));                  // corrected Jacobian det\n    w = 48.* 2.*sqrt(abs(w));            // pixel width, for antialiasing\n    U = 48.*fract( U ) - g;              // tiles\n#endif\n    \n    int nn=-1; float  e = 1e3;\n    for (int r=0; r < 4; r++)\n    {   \n        m = mod(U+g+8.,48.)-8.;\n        U = vec2(-U.y,U.x); \n        for (int i=0; i <  T.length()-2 ; i+=2) {\n            drawTile(m,i,r);\n        }\n      e = min(e, min(length(m-vec2(7.8,20)),length(m-vec2(4.5,20)))-.8);  // eyes\n\n        if (n%2>0) nn=r, n=0; // for checkered filling color\n    }\n    if(nn>=0) n=nn; \n    // --- returned values: d = distance to contour, n = fill parity, I = tileId\n\n    e = smoothstep(w,0.,abs(e));\n    d = smoothstep(w,0.,abs(d));\n  //O = .5 + vec4( n%2 > 0 ? 1. -d - e : e );   // just surfaces\n    O = .5 + vec4( n%2 > 0 ? 1. - e : e ) - d;  // + border\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1413, 1413, 1450, 1450, 1541], [1547, 1547, 1584, 1584, 3504]], "test": "untested"}
{"id": "Wt2cDw", "name": "GlowLife 3 : reaction diffusion", "author": "FabriceNeyret2", "description": "variant of \"GlowLife\" by savegor. [url]https://shadertoy.com/view/3tSyWm[/url]\njust adding buffB for background effect triggered by cells, + the last lines in Image tab to sum it\n\nAnother implementation of Conway's Game of Life", "tags": ["conwaysgameoflife"], "likes": 13, "viewed": 548, "published": 3, "date": "1594545518", "time_retrieved": "2024-07-30T20:55:49.335910", "image_code": "// Variant 2 of \"GlowLife\" by savegor. https://shadertoy.com/view/3tSyWm\n// Just adding buffB for background effect, + the last line here to sum it.\n\n\nfloat getGlow(vec2 cell, vec2 point) {\n    vec2 cell_uv = cell / (iResolution.xy * CELL_SIZE);\n    vec4 status = texture(iChannel0, cell_uv);\n    float alive = status.b;\n    \n    vec2 diff = point - cell;\n    float invSqrDist = CELL_SIZE / dot(diff, diff);\n    \n    return mix(0.0, invSqrDist, alive);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sumGlow = 0.0;\n    float averageArea = CELL_SIZE * GLOW_RAD_FACTOR;\n    \n    vec2 cell = floor(fragCoord / CELL_SIZE) * CELL_SIZE;\n    cell += CELL_SIZE * 0.5;\n    for(float i = -averageArea; i < averageArea + 1.0; i = i + CELL_SIZE) {\n        for(float j = -averageArea; j < averageArea + 1.0; j = j + CELL_SIZE) {\n            vec2 cell_ij = cell + vec2(i, j);\n            sumGlow += getGlow(cell_ij, fragCoord);\n        }\n    }\n    \n    // output color\n\tfloat red = sumGlow;\n    float green = sumGlow;\n    float blue = 2.0 * sumGlow;\n    fragColor = vec4(red, green, blue, 1.0);\n    \n    // --- Fabrice: added background effect\n    fragColor += .05*(.5+vec4(1,.2,0,0)) * texture(iChannel1,fragCoord/iResolution.xy); \n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float CELL_SIZE = 14.0;\nconst float GLOW_RAD_FACTOR = 8.0;\nconst int SLOWDOWN = 5;", "buffer_a_code": "\nfloat noise(vec2 st) {\n    return fract(sin(st.x * st.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // just lazy trick to generate first state \n    // sorry\n    if(iFrame == 0) { \n    \tfragColor = vec4(0.0,0.0,noise(fragCoord) > 0.5,1.0);\n    }\n    else {\n        vec4 mouse = iMouse;\n        mouse.xy /= CELL_SIZE;\n\t\t\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 status = texture(iChannel0, uv);\n\n\n        float was_alive = status.b;\n        float is_alive = 0.0;\n        vec2 diff = abs(fragCoord - mouse.xy);\n\t\t\n        // if left mouse button pressed\n        // just freeze world and revive selected cells\n        if(mouse.z > 0.0) {\n            is_alive = was_alive;\n            if(diff.x < 0.5 &&  diff.y < 0.5) {\n                is_alive = 1.0;    \n            }\n        }\n        else {\n            if( iFrame % SLOWDOWN == 0) {\n                int living_count = 0;\n                for(int i = -1; i < 2; i = i + 1) {\n                    for(int j = -1; j < 2; j = j + 1) {\n\n                        float not_center = float((abs(i) + abs(j)) != 0);\n                        vec2 uv_ij = (fragCoord + vec2(i, j)) / iResolution.xy;\n                        vec4 status_ij = texture(iChannel0, uv_ij);\n\n                        living_count += int(status_ij.z * not_center);\n                    }\n                }\n\n                float keepAlive = float(living_count == 2 || living_count == 3);\n                float revive = float(living_count == 3);\n\n                is_alive = mix(revive, keepAlive, was_alive);\n            }\n            else {\n                is_alive = was_alive;\n            }\n        }\n        fragColor = vec4(0.0,was_alive,is_alive,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// --- Fabrice: alife decorating background triggered by cells\n// here: reaction diffusion triggered by cells\n\n// https://en.wikipedia.org/wiki/Reaction%E2%80%93diffusion_system#Two-component_reaction–diffusion_equations\nfloat L = .5, K = .9, S = 1., du = 10., dv = 1., T = .5,  dt = .05; \n\n#define f(u)  L*u -u*u*u -K\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n\n    O =  texture(iChannel0,U);                            // previous step\n    \n    O.xy += dt* ( vec2(du,dv)*texture(iChannel0,U, 1.).xy // diffusion\n                 + vec2( f(O.x) - S*O.y ,  O.x - O.y )    // reaction\n                ) / vec2(1, T);\n    O.x += texture(iChannel1,U/CELL_SIZE).y;              // trigger source\n // if (iMouse.z>0.) O-=O;                                // reset (anti NaN ;-) )\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[151, 151, 189, 189, 454], [456, 456, 513, 513, 1245]], "test": "untested"}
{"id": "WljcDw", "name": "Mandelbrot and Julia Explorer", "author": "dr2", "description": "Interactively explore Mandelbrot and Julia sets (computed with emulated double precision) - see source for usage", "tags": ["fractal", "interactive", "precision", "ui", "double"], "likes": 14, "viewed": 432, "published": 3, "date": "1594544092", "time_retrieved": "2024-07-30T20:55:50.282380", "image_code": "// \"Mandelbrot and Julia Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Interactively explore Mandelbrot and Julia sets (computed with emulated double precision)\n \n See \"Mandelbrot Trillion-Fold Zoom\" and \"Julia Set Trillion-Fold Zoom\" for background.\n \n Usage -\n \n Buttons: cyan - color mode; green/red - select Mandelbrot or Julia modes ; blue - reset.\n Rings: green - shift display midpoint; red (only in Julia mode) - vary Julia parameters.\n Slider: vary zoom level.\n \n When switching to Julia mode the parameters are set to the current Mandelbrot midpoint\n (starting in the black is not a good idea).\n Reduced iteration count at low zoom (too much black causes slowdown).\n Reset sets parameters to their original values.\n Best color mode depends on scene parameters.\n Prior to mouse click the shader automatically cycles through all modes at low zoom levels.\n Scale factor is shown (log).\n*/\n\n#define AA   0  // set = 1 for antialiasing (recommended, slower)\n\n#define DP_VERS  1   // set in both shaders (= 0 for single precision)\n\n#if DP_VERS\nvec2 DvAdd (vec2 va, vec2 vb);\nvec2 DvSub (vec2 va, vec2 vb);\nvec2 DvMul (vec2 va, vec2 vb);\nvec2 DvFromF (float a);\nvoid DvInit ();\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\nvec4 Loadv4 (int idVar);\n\nvec2 wgVal[3];\nvec2 xMidv, yMidv, xJulv, yJulv;\nfloat nFrameF, scale, colTyp;\nint nFrame;\nbool isJulia;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  float ns, itLim, xyLim, w;\n  bool smoothCut;\n#if DP_VERS\n  vec2 x, y, xx, yy, cx, cy;\n#else\n  float x, y, xx, yy, cx, cy;\n#endif\n  if (isJulia) {   // = 1for linux\n#if DP_VERS\n    x = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n    y = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n    cx = xJulv;\n    cy = yJulv;\n#else\n    x = uv.x * scale + xMidv.x;\n    y = uv.y * scale + yMidv.x;\n    cx = xJulv.x;\n    cy = yJulv.x;\n#endif\n  } else {\n#if DP_VERS\n    x = DvFromF (0.);\n    y = DvFromF (0.);\n    cx = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n    cy = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n#else\n    x = 0.;\n    y = 0.;\n    cx = uv.x * scale + xMidv.x;\n    cy = uv.y * scale + yMidv.x;\n#endif\n  }\n#if DP_VERS\n  const float nsMax = 8192.;\n  w = (cx.x + 0.25) * (cx.x + 0.25) + cy.x * cy.x;\n#else\n  const float nsMax = 1024.;\n  w = (cx + 0.25) * (cx + 0.25) + cy * cy;\n#endif\n  ns = 0.;\n  col = vec3 (0.2);\n  if (w > 0.25) {\n    smoothCut = true;\n    if (scale <= 1./128.) itLim = isJulia ? 0.5 * nsMax : nsMax;\n    else itLim = isJulia ? 512. : 256.;\n    xyLim = smoothCut ? 256. * 256. : 4.;\n    for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n      ++ ns;\n#if DP_VERS\n      xx = DvMul (x, x);\n      yy = DvMul (y, y);\n      y = DvMul (x, y);\n      y = DvAdd (DvAdd (y, y), cy);\n      x = DvAdd (DvSub (xx, yy), cx);\n      if (DvAdd (xx, yy).x > xyLim || ns == itLim) break;\n#else\n      xx = x * x;\n      yy = y * y;\n      y = 2. * x * y + cy;\n      x = xx - yy + cx;\n      if (xx + yy > xyLim || ns == itLim) break;\n#endif\n    }\n    if (ns < itLim) {\n      if (smoothCut) {\n#if DP_VERS\n        ns -= log2 (log2 (DvAdd (xx, yy).x)) - 4.;\n#else\n        ns -= log2 (log2 (xx + yy)) - 4.;\n#endif\n      }\n      if      (colTyp == 0.) col = HsvToRgb (vec3 (mod (sqrt (ns) / 8., 1.), 1., 1.));\n      else if (colTyp == 1.) col = HsvToRgb (vec3 (mod (ns / 512., 1.), 1., 1.));\n      else if (colTyp == 2.) col = 0.55 + 0.45 * cos (3. + vec3 (0., 0.5, 1.) + 0.5 * sqrt (ns));\n      else if (colTyp == 3.) col = HsvToRgb (vec3 (mod (0.5 * log2 (ns) +\n         mod (0.001 * nFrameF, 1.), 1.), 1., 1.));\n      else if (colTyp == 4.) col = mix (vec3 (1.), vec3 (0.2), floor (mod (ns, 2.)));\n      else if (colTyp == 5.) col = mix (vec3 (1.), vec3 (0.2), floor (mod (4. * log2 (ns), 2.)));\n    }\n  }\n  return col;\n}\n\nvec3 ShowWg (vec2 uv, vec2 canvas, vec3 col)\n{\n  vec4 wgBx[6];\n  vec3 cc, c;\n  vec2 ut;\n  float asp, s;\n  asp = canvas.x / canvas.y;\n  wgBx[0] = vec4 (0.39, 0.15, 0.135, 0.);\n  wgBx[1] = vec4 (-0.39, 0.15, 0.135, 0.);\n  wgBx[2] = vec4 (0.39, -0.22, 0.03, 0.15);\n  wgBx[3] = vec4 (0.39, 0.4, 0.025, 0.025);\n  wgBx[4] = vec4 (-0.39, 0.4, 0.025, 0.025);\n  wgBx[5] = vec4 (-0.39, -0.4, 0.025, 0.025);\n  cc = vec3 (1., 0., 0.);\n  for (int k = 0; k <= 1; k ++) {\n    if (k == 0 || k == 1 && isJulia) {\n      ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n      s = (length (ut) - wgBx[k].z) * canvas.y;\n      if (s < 0.) {\n        c = (k == 0) ? cc.yxy : cc;\n        col = (s > -2. || min (abs (ut.x), abs (ut.y)) * canvas.y < 1.) ? c :\n           mix (vec3 (1.), c, 0.3);\n        col = mix (c.grb, col, smoothstep (1.5, 2.5, abs (length (ut - wgVal[k]) - 0.015) *\n           canvas.y));\n      }\n    }\n  }\n  for (int k = 2; k <= 2; k ++) {\n    ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n    s = max (abs (ut.x)- wgBx[k].z, abs (ut.y) - wgBx[k].w) * canvas.y;\n    if (s < 0.) {\n      col = (s > -2. || abs (ut.y) * canvas.y < 1.) ? cc.yxy : mix (vec3 (1.), cc.yxy, 0.3);\n      col = mix (cc, col, smoothstep (1.5, 2., abs (length (ut - wgVal[k]) - 0.015) * canvas.y));\n    }\n  }\n  for (int k = 3; k <= 5; k ++) { \n    ut = 0.5 * uv - wgBx[k].xy * vec2 (asp, 1.);\n    s = max (abs (ut.x) - wgBx[k].z, abs (ut.y) - wgBx[k].w) * canvas.y;\n    if (s < 0.) {\n      c = (k == 4) ? (isJulia ? cc : cc.yxy) : ((k == 3) ? cc.yxx : cc.yyx);\n      col = (s > -2.) ? c : mix (vec3 (1.), c, 0.3);\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec4 mPtr, stDat;\n  vec3 col;\n  vec2 canvas, uv;\n  float asp, sr;\n  bool mouseDn;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  nFrameF = float (nFrame);\n  stDat = Loadv4 (0);\n  mPtr.z = stDat.z;\n  stDat = Loadv4 (1);\n  wgVal[0] = stDat.xy;\n  wgVal[2] = stDat.zw;\n  stDat = Loadv4 (2);\n  xMidv = stDat.xy;\n  yMidv = stDat.zw;\n  mouseDn = (mPtr.z > 0.);\n  asp = canvas.x / canvas.y;\n  stDat = Loadv4 (3);\n  scale = stDat.x;\n  colTyp = stDat.z;\n  stDat = Loadv4 (4);\n  wgVal[1] = stDat.xy;\n  isJulia = (stDat.z > 0.);\n  stDat = Loadv4 (5);\n  xJulv = stDat.xy;\n  yJulv = stDat.zw;\n#if DP_VERS\n  DvInit ();\n#endif\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      col += (1. / naa) * ShowScene ( uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n         sr * (0.667 * a + 0.5) * pi));\n    }\n  } else col = vec3 (0.82);\n  col = ShowWg (uv, canvas, col);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.41 * asp, -0.47),\n      vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  if (mouseDn) {\n    uv = abs (uv) * canvas.y;\n    if (max (max (uv.x, uv.y) - 15., min (uv.x, uv.y) - 2.) < 0.) col = 1. - col;\n  }\n  fragColor = vec4 (col, 1.);\n}\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1   // set = 0 if GLSL compiler conforms (else get sp results), or for linux\n#define LESS_BAD_FP 0   // optional = 1 for linux: linux/nvidia(binary) and linux/intel(mesa)\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)  // must be 1\n\n#if ! BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return a + b;\n}\n\nfloat FFSub (float a, float b)\n{\n  return a - b;\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvoid DvInit ()\n{\n#if REAL_BAD_FP \n  nFrameF1 = nFrameF + 1.;\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n}\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if ! BAD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = - FFSub (FFSub2 (ma, va.x), ma);\n  sb1 = - FFSub (FFSub2 (mb, vb.x), mb);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nconst float txRow = 128.;\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// \"Mandelbrot and Julia Explorer\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define DP_VERS  1   // set in both shaders\n\n#if DP_VERS\nvec2 DvAdd (vec2 va, vec2 vb);\nvec2 DvFromF (float a);\nvoid DvInit ();\n#endif\n\nvec4 Loadv4 (int idVar);\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord);\n\nfloat nFrameF;\nconst float txRow = 128.;\n\nvoid mainImage (out vec4 fragColor, vec2 fragCoord)\n{\n  vec4 mPtr, mPtrP, stDat, wgBx[6];\n  vec2 iFrag, canvas, wgVal[3], ut, xMidv, yMidv, xJulv, yJulv,\n     xMidvMS, yMidvMS, xMidvJS, yMidvJS, xJulvS, yJulvS;\n  float tCur, asp, scale, sclLim, sclFac, colTyp, autoMd;\n  int pxId, nFrame;\n  bool isJulia;\n  canvas = iResolution.xy;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = iTime;\n  nFrame = iFrame;\n  iFrag = floor (fragCoord);\n  pxId = int (iFrag.x + txRow * iFrag.y);\n  if (pxId >= 6) discard;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n  wgBx[0] = vec4 (0.39, 0.15, 0.135, 0.);\n  wgBx[1] = vec4 (-0.39, 0.15, 0.135, 0.);\n  wgBx[2] = vec4 (0.39, -0.22, 0.03, 0.15);\n  wgBx[3] = vec4 (0.39, 0.4, 0.025, 0.025);\n  wgBx[4] = vec4 (-0.39, 0.4, 0.025, 0.025);\n  wgBx[5] = vec4 (-0.39, -0.4, 0.025, 0.025);\n  xMidvMS = vec2 (-1.2499080e+07 / (4096. * 4096.), 6.4092e-09);\n  yMidvMS = vec2 (2.2692490e+06 / (4096. * 4096.),  4.4428e-08);\n  xMidvJS = vec2 (-3.0709070e+06 / (4096. * 4096.), 4.0579e-08);\n  yMidvJS = vec2 (6.7450760e+06 / (4096. * 4096.),  4.2139e-08);\n  xJulvS = vec2 (2.7101420e+06 / (4096. * 4096.), 2.2352e-08);\n  yJulvS = vec2 (9.9288270e+06 / (4096. * 4096.), 2.4958e-08);\n  if (nFrame <= 5) {\n    mPtrP = mPtr;\n    autoMd = 1.;\n    wgVal[0] = vec2 (0.);\n    wgVal[2] = vec2 (0.);\n    xMidv = xMidvMS;\n    yMidv = yMidvMS;\n    scale = 2.;\n    sclFac = 1.;\n    colTyp = 0.;\n    wgVal[1] = vec2 (0.);\n    isJulia = false;\n    xJulv = xJulvS;\n    yJulv = yJulvS;\n  } else {\n    stDat = Loadv4 (0);\n    mPtrP.xyz = stDat.xyz;\n    autoMd = stDat.w;\n    stDat = Loadv4 (1);\n    wgVal[0] = stDat.xy;\n    wgVal[2] = stDat.zw;\n    stDat = Loadv4 (2);\n    xMidv = stDat.xy;\n    yMidv = stDat.zw;\n    stDat = Loadv4 (3);\n    scale = stDat.x;\n    sclFac = stDat.y;\n    colTyp = stDat.z;\n    stDat = Loadv4 (4);\n    wgVal[1] = stDat.xy;\n    isJulia = (stDat.z > 0.);\n    stDat = Loadv4 (5);\n    xJulv = stDat.xy;\n    yJulv = stDat.zw;\n  }\n#if DP_VERS\n  DvInit ();\n#endif\n  if (mPtr.z > 0.) {\n    if (autoMd > 0.) {\n      autoMd = 0.;\n      xMidv = xMidvMS;\n      yMidv = yMidvMS;\n      isJulia = false;\n      colTyp = 0.;\n      scale = 2.;\n    }\n  }\n  if (autoMd > 0.) {\n    isJulia = (floor (2. * mod (0.1 * tCur, 2.) - 1.) > 0.);\n    if (isJulia) {\n      xMidv = xMidvJS;\n      yMidv = yMidvJS;\n    } else {\n      xMidv = xMidvMS;\n      yMidv = yMidvMS;\n    }\n    colTyp = floor (6. * mod (0.1 * tCur, 1.));\n    scale = 2. * pow (0.25, 4. * mod (0.1 * tCur, 1.));\n  }\n  if (mPtr.z > 0.) {\n    ut = (mPtr.xy - wgBx[0].xy) * vec2 (asp, 1.);\n    wgVal[0] = (length (ut) < wgBx[0].z && length (ut) > 0.) ? ut : vec2 (0.);\n    if (isJulia) {\n      ut = (mPtr.xy - wgBx[1].xy) * vec2 (asp, 1.);\n      wgVal[1] = (length (ut) < wgBx[1].z && length (ut) > 0.) ? ut : vec2 (0.);\n    }\n    ut = (mPtr.xy - wgBx[2].xy) * vec2 (asp, 1.);\n    wgVal[2] = (abs (ut.x) < wgBx[2].z && abs (ut.y) < wgBx[2].w && abs (ut.y) > 0.) ?\n       vec2 (0., ut.y) : vec2 (0.);\n    ut = (mPtr.xy - wgBx[3].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[3].z, abs (ut.y) - wgBx[3].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        if (++ colTyp > 5.) colTyp = 0.;\n      }\n    }\n    ut = (mPtr.xy - wgBx[4].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[4].z, abs (ut.y) - wgBx[4].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        isJulia = ! isJulia;\n        if (isJulia) {\n          if (xMidv.x != 0. && yMidv.x != 0.) {\n            xJulv = xMidv;\n            yJulv = yMidv;\n          } else {\n            xJulv = xJulvS;\n            yJulv = yJulvS;\n          }\n          xMidv = vec2 (-0.05, 0.);\n          yMidv = vec2 (0.);\n        } else {\n          xMidv = vec2 (-0.75, 0.);\n          yMidv = vec2 (0.);\n        }\n        scale = 2.;\n        sclFac = 1.;\n      }\n    }\n    ut = (mPtr.xy - wgBx[5].xy) * vec2 (asp, 1.);\n    if (max (abs (ut.x)- wgBx[5].z, abs (ut.y) - wgBx[5].w) < 0.) {\n      if (mPtrP.z <= 0.) {\n        if (isJulia) {\n          xMidv = xMidvJS;\n          yMidv = yMidvJS;\n          xJulv = xJulvS;\n          yJulv = yJulvS;\n        } else {\n          xMidv = xMidvMS;\n          yMidv = yMidvMS;\n        }\n        scale = 2.;\n        sclFac = 1.;\n      }\n    }\n  } else {\n    wgVal[0] = vec2 (0.);\n    wgVal[1] = vec2 (0.);\n    wgVal[2] = vec2 (0.);\n  }\n  if (nFrame > 5) {\n    sclFac = 1. - (1./64.) * clamp (wgVal[2].y / wgBx[2].z, -1., 1.);\n    scale *= sclFac;\n#if DP_VERS\n    sclLim = isJulia ? 1e-11 : 1e-12;\n#else\n    sclLim = 1e-5;\n#endif\n    scale = clamp (scale, 2. * sclLim, 2.);\n#if DP_VERS\n    xMidv = DvAdd (xMidv, DvFromF ((1./8.) * scale * wgVal[0].x));\n    yMidv = DvAdd (yMidv, DvFromF ((1./8.) * scale * wgVal[0].y));\n#else\n    xMidv.x += (1./8.) * scale * wgVal[0].x;\n    yMidv.x += (1./8.) * scale * wgVal[0].y;\n#endif\n    if (isJulia) {\n#if DP_VERS\n      xJulv = DvAdd (xJulv, DvFromF ((1./1024.) * scale * wgVal[1].x));\n      yJulv = DvAdd (yJulv, DvFromF ((1./1024.) * scale * wgVal[1].y));\n#else\n      xJulv.x += (1./1024.) * scale * wgVal[1].x;\n      yJulv.x += (1./1024.) * scale * wgVal[1].y;\n#endif\n    }\n  }\n  if      (pxId == 0) stDat = vec4 (mPtr.xyz, autoMd);\n  else if (pxId == 1) stDat = vec4 (wgVal[0], wgVal[2]);\n  else if (pxId == 2) stDat = vec4 (xMidv, yMidv);\n  else if (pxId == 3) stDat = vec4 (scale, sclFac, colTyp, 0.);\n  else if (pxId == 4) stDat = vec4 (wgVal[1], (isJulia ? 1. : 0.), 0.);\n  else if (pxId == 5) stDat = vec4 (xJulv, yJulv);\n  Savev4 (pxId, stDat, fragColor, fragCoord);\n}\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1\n#define LESS_BAD_FP 0\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)\n\n#if ! BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return a + b;\n}\n\nfloat FFSub (float a, float b)\n{\n  return a - b;\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvoid DvInit ()\n{\n#if REAL_BAD_FP \n  nFrameF1 = nFrameF + 1.;\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n}\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\n#define txBuf iChannel0\n#define txSize iChannelResolution[0].xy\n\nvec4 Loadv4 (int idVar)\n{\n  float fi;\n  fi = float (idVar);\n  return texture (txBuf, (vec2 (mod (fi, txRow), floor (fi / txRow)) + 0.5) / txSize);\n}\n\nvoid Savev4 (int idVar, vec4 val, inout vec4 fCol, vec2 fCoord)\n{\n  vec2 d;\n  float fi;\n  fi = float (idVar);\n  d = abs (fCoord - vec2 (mod (fi, txRow), floor (fi / txRow)) - 0.5);\n  if (max (d.x, d.y) < 0.5) fCol = val;\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljcDw.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[1566, 1566, 1592, 1592, 3969], [3971, 3971, 4017, 4017, 5573], [5575, 5575, 5631, 5631, 7111], [10189, 10189, 10219, 10219, 10332], [10334, 10334, 10358, 10358, 10475], [10477, 10477, 10500, 10500, 10602], [10675, 10675, 10707, 10707, 11249], [11251, 11251, 11311, 11311, 11863], [11957, 11957, 11982, 11982, 12105]], "test": "untested"}
{"id": "3t2cWw", "name": "GlowLife 2 : oily fluid & more", "author": "FabriceNeyret2", "description": "variant of \"GlowLife\" by savegor. [url]https://shadertoy.com/view/3tSyWm[/url]\njust adding buffB for background effect triggered by cells, + the last lines in Image tab to sum it\n\nAnother implementation of Conway's Game of Life", "tags": ["conwaysgameoflife"], "likes": 14, "viewed": 460, "published": 3, "date": "1594536060", "time_retrieved": "2024-07-30T20:55:51.148066", "image_code": "// Variant of \"GlowLife\" by savegor. https://shadertoy.com/view/3tSyWm\n// Just adding buffB for background effect, + the last line here to sum it.\n\n\nfloat getGlow(vec2 cell, vec2 point) {\n    vec2 cell_uv = cell / (iResolution.xy * CELL_SIZE);\n    vec4 status = texture(iChannel0, cell_uv);\n    float alive = status.b;\n    \n    vec2 diff = point - cell;\n    float invSqrDist = CELL_SIZE / dot(diff, diff);\n    \n    return mix(0.0, invSqrDist, alive);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float sumGlow = 0.0;\n    float averageArea = CELL_SIZE * GLOW_RAD_FACTOR;\n    \n    vec2 cell = floor(fragCoord / CELL_SIZE) * CELL_SIZE;\n    cell += CELL_SIZE * 0.5;\n    for(float i = -averageArea; i < averageArea + 1.0; i = i + CELL_SIZE) {\n        for(float j = -averageArea; j < averageArea + 1.0; j = j + CELL_SIZE) {\n            vec2 cell_ij = cell + vec2(i, j);\n            sumGlow += getGlow(cell_ij, fragCoord);\n        }\n    }\n    \n    // output color\n\tfloat red = sumGlow;\n    float green = sumGlow;\n    float blue = 2.0 * sumGlow;\n    fragColor = vec4(red, green, blue, 1.0);\n    \n    // --- Fabrice: added background effect\n    fragColor += fract(iTime/6.) > .5 \n         ? .2*sin(texture(iChannel1,fragCoord/iResolution.xy))  // variant 1\n         : .05*(texture(iChannel1,fragCoord/iResolution.xy));   // variant 2\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "const float CELL_SIZE = 14.0;\nconst float GLOW_RAD_FACTOR = 8.0;\nconst int SLOWDOWN = 5;", "buffer_a_code": "\nfloat noise(vec2 st) {\n    return fract(sin(st.x * st.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // just lazy trick to generate first state \n    // sorry\n    if(iFrame == 0) { \n    \tfragColor = vec4(0.0,0.0,noise(fragCoord) > 0.5,1.0);\n    }\n    else {\n        vec4 mouse = iMouse;\n        mouse.xy /= CELL_SIZE;\n\t\t\n        vec2 uv = fragCoord / iResolution.xy;\n        vec4 status = texture(iChannel0, uv);\n\n\n        float was_alive = status.b;\n        float is_alive = 0.0;\n        vec2 diff = abs(fragCoord - mouse.xy);\n\t\t\n        // if left mouse button pressed\n        // just freeze world and revive selected cells\n        if(mouse.z > 0.0) {\n            is_alive = was_alive;\n            if(diff.x < 0.5 &&  diff.y < 0.5) {\n                is_alive = 1.0;    \n            }\n        }\n        else {\n            if( iFrame % SLOWDOWN == 0) {\n                int living_count = 0;\n                for(int i = -1; i < 2; i = i + 1) {\n                    for(int j = -1; j < 2; j = j + 1) {\n\n                        float not_center = float((abs(i) + abs(j)) != 0);\n                        vec2 uv_ij = (fragCoord + vec2(i, j)) / iResolution.xy;\n                        vec4 status_ij = texture(iChannel0, uv_ij);\n\n                        living_count += int(status_ij.z * not_center);\n                    }\n                }\n\n                float keepAlive = float(living_count == 2 || living_count == 3);\n                float revive = float(living_count == 3);\n\n                is_alive = mix(revive, keepAlive, was_alive);\n            }\n            else {\n                is_alive = was_alive;\n            }\n        }\n        fragColor = vec4(0.0,was_alive,is_alive,1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// --- Fabrice: alife decorating background triggered by cells\n// here: memory by relaxation with space-color deforming effect \n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    U /= iResolution.xy;\n    int i = int(iTime/6.)%3;                                      // distortion:\n    vec2 V =   i == 0 ?  U+ .002*vec2(1,sin(iTime))               //   wind effect\n             : i == 1 ? (U-.5)*mat2(cos(.01+vec4(0,11,33,0)))+.5  //   rotation effect\n             :          (U-.5)/1.03+.5;                           //   zoom effect\n    \n        // memory   space distortion   color-dependant relaxation time \n    O =   texture(iChannel0,V, 1.) * exp(-vec4(1,2,4,1)/100.)\n        + texture(iChannel1,U/CELL_SIZE).y; // trigger source\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 187, 187, 452], [454, 454, 511, 511, 1347]], "test": "untested"}
{"id": "3ljcWw", "name": "NoiseShadow", "author": "solacefy", "description": "Soft Shadow With Noise", "tags": ["3d"], "likes": 0, "viewed": 209, "published": 3, "date": "1594534389", "time_retrieved": "2024-07-30T20:55:52.003777", "image_code": "// IQ's SDF\n//https://iquilezles.org/\nfloat smin( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return min(a, b) - h*h*0.25/k;\n}\n\nmat2 Rot(float a)\n{\n\tfloat s =sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat N21(vec2 p)\n{\n\tp = fract(p*vec2(233.34,851.73));\n    p+= dot(p,p+23.45);\n    return fract(p.x*p.y);\n}\n\nvec2 N22(vec2 p)\n{\n\tfloat n = N21(p);\n    return vec2(n,N21(p+n));\n}\n\n\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdMagicCubesRows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    vec3 q1 = abs(p + vec3(0.,0., 0.)) - b;\n    vec3 q2 = abs(p + vec3(0.,-offset, 0.)) - b;\n    vec3 q3 = abs(p + vec3(0.,-2.*offset, 0.)) - b;\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r\n        ,length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r), length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n\n}\n\nfloat sdMagicCubes3Rows(vec3 p, vec3 b, float r)\n{\n\tvec3 h = p;\n    float offset = 0.49;\n    float c1 = sdMagicCubesRows(p + vec3(-offset,0.,0.), b, r);\n    float c2 = sdMagicCubesRows(p + vec3(-0.,0.,0.),b,r);\n    float c3 = sdMagicCubesRows(p + vec3(-offset *2.,0.,0.),b,r);\n    return min(c1,min(c2,c3));\n}\n\nfloat sdMagicCubes(vec3 p, vec3 b, float r)\n{\n    vec3 h = p;\n    float offset = .49;\n    float c1 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset), b,r);\n    float c2 = sdMagicCubes3Rows(p + vec3(0.,0.,-offset*2.), b,r);\n    float c3 = sdMagicCubes3Rows(p + vec3(0.,0.,-0.), b,r);\n    return min(c1,min(c2,c3));\n    \n}\n\nfloat sdCubes(vec3 p, vec3 b, float r, vec3 offset, vec3 rowoff)\n{\n\tvec3 q1 = (abs(p + rowoff) - b) ;\n    vec3 q2 = abs(p - offset + rowoff) - b;\n    vec3 q3 = abs(p - offset*2. + rowoff) - b;\n    \n    //vec3 q = q1+q2+q3;\n    //q1.xz *= Rot(iTime);\n    return min(min(length(max(q1,0.0)) + min(max(q1.x,max(q1.y,q1.z)),0.0) - r,\n               length(max(q2,0.0)) + min(max(q2.x,max(q2.y,q2.z)),0.0) - r),\n             length(max(q3,0.0)) + min(max(q3.x,max(q3.y,q3.z)),0.0) - r);\n    //return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat map(in vec3 pos)\n{\n    vec3 posr = pos;\n    posr.xz *= Rot(iTime);\n    vec3 posrX = pos;\n    posrX.yx *= Rot(iTime);\n    \n    float rt = 0.;\n    float t = clamp(fract(iTime),0.5,1.);\n\tfloat d1 = length(pos) - 0.25;\n    \n    float d2= pos.y - (-0.25);\n    \n    vec3 h = pos;\n    \n    h.xz = (mat2(3,4,-4,3)/5.0)*h.xz;\n    h.yz = (mat2(3,4,-4,3)/5.0)*h.yz;\n    \n    posrX.xz = (mat2(3,4,-4,3)/5.0)*posrX.xz;\n    posrX.yz = (mat2(3,4,-4,3)/5.0)*posrX.yz;\n    \n    \n    float d3 = sdTorus((posrX - vec3(-0,.5,0.6)).xzy * vec3(1.,1.,1.) + vec3(0.,0.,rt), vec2(.99, .082));\n    \n    float d4 = sdBoundingBox((pos - vec3(0.,0.8,0.)).xzy, vec3(1) ,.045);\n    \n    float d5 = sdRoundBox(pos, vec3(.2,.2,.2), .05);\n    \n    //float posr = pos;\n \n    float d6 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.5));\n    float d7 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,-0.5));\n\tfloat d8 = sdCubes(posr, vec3(.2,.2,.2), .05, vec3(0,.49,0), vec3(0.,0.,0.));\n    \n    float dm = sdMagicCubes(posr, vec3(.2,.2,.2), .05);\n    \n    \n    float dc = min(min(d6,d7),d8);\n    \n  \n    \n   \n    \n    //return smin(min(d2,dc),d3, .03);\n  \t//return smin(dc,d3, .03);\n\treturn smin( smin(dm, d3,.03),d2, .03);\n}\n\nfloat calcOcclusion(in vec3 pos, in vec3 nor, float time)\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i<5; i++)\n    {\n    \tfloat h = 0.01 + 0.11 * float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = map(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 2.0 * occ, 0.0, 1.0);\n\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    vec2 e = vec2(0.0001, 0.);\n\treturn normalize(vec3(map(pos+e.xyy) - map(pos-e.xyy),\n                         map(pos+e.yxy) - map(pos-e.yxy),\n                         map(pos+e.yyx) - map(pos-e.yyx)));\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float time )\n{\n    float res = 1.0;\n\n    float tmax = 12.0;\n    \n    float k = 10.0;\n    \n    float t = 0.02;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.05, 0.40 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat castRay(in vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    for(int i=0; i<100; i++)\n    {\n        vec3 pos = ro + t*rd;\n\n        float h = map(pos);\n        if(h<0.001)\n        {\n        \tbreak;\n        }\n        t+= h;\n        if(t>20.0) break;       \t         \n    }\n    if(t>20.0) t = -1.0;\n    return t;\n}\n\n\n#define AA 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 tot = vec3(0.0);\n    vec3 col = vec3(0.46,0.4,0.42);\n    for(int m=0; m<AA;m++)\n    for(int n=0; n<AA; n++)\n    {\n    \tvec2 off = -.5 + vec2(float(m),float(n))/ float(AA);\n        \n        vec2 p = (2.0*(fragCoord+off) - iResolution.xy)/iResolution.y;\n\n        //float an = 0.1 * iTime;\n        float an = 10.0 * iMouse.x/iResolution.x;\n        //oat anz = 10.0 * iMouse.y/iResolution.y;\n        vec3 ro =  2.5 * vec3(1.0*sin(an),.2, 1.0*cos(an));\n        vec3 ta = vec3(0.0,0.0,0.0);\n\n        vec3 ww = normalize(ta-ro);\n        vec3 uu = normalize(cross(ww, vec3(0,1,0)));\n        vec3 vv = normalize(cross(uu,ww));\n\n\n        vec3 rd = normalize(p.x*uu + p.y*vv + 1.1*ww);\n\n        //vec3 col = vec3(0.18,0.1,0.2) - .5 * rd.y;\n        \n        float noise = smoothstep(-0.05 , .99 , N21(p));\n        col *= max(vec3(noise), col*1.85);\n\n        float t = castRay(ro,rd);\n\n\n        if(t>0.0)\n        {\n            float time= iTime;\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            vec3 mate = vec3(0.18);\n            vec3 sun_lig = normalize(vec3(0.6,0.35,0.5));\n            float occ = calcOcclusion( pos, nor, time )* .8;\n            vec3 sun_dir = normalize(vec3(0.8,0.4,0.8));\n            float sun_dif = clamp(dot(nor,sun_dir), 0.0,1.0);\n            //float sun_sha = step(castRay(pos+nor*0.001, sun_dir), 0.0);\n            //soft one\n\n\n            float sun_sha = calcSoftshadow( pos, sun_lig, time );\n\n            float sky_dif = clamp(.5 + .5 * dot(nor, vec3(0.,1.,0.)), 0.0,1.0);\n            float bou_dif = clamp(.5 + .5 * dot(nor, vec3(0.,-1.,0.)), 0.0,1.0);\n            //col = mate*vec3(7.0,4.5,3.0) * sun_dif*sun_sha;\n\n            //Use black and white\n            col = vec3(1.5,1.5,1.5) * vec3(0.5,.5,.5) * sun_dif*sun_sha*occ;\n            //col += vec3(1.0,1.0,1.0)*vec3(0.1,0.0,0.0) * sky_dif;        \n            //col += vec3(1.0,1.0,1.0)*vec3(0.,0.0,0.0) * bou_dif;\n            col += mate*vec3(0.5,0.8,0.9) * sky_dif;        \n            col += mate*vec3(0.7,0.3,0.2) * bou_dif;\n\n            float noise = smoothstep(-0.05 , .99 , N21(pos.xy));\n            \n\n            col *= max(vec3(noise), col*1.85);\n            \n            //col = vec3(1.);\n            \n           \n        }\n        \n        \n        col = pow(col, vec3(0.4545));\n        tot += col;\n    }\n    \n    tot /= float(AA*AA);\n    // Output to screen\n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 79, 79, 151], [153, 153, 172, 172, 241], [243, 243, 262, 262, 350], [352, 352, 370, 370, 420], [424, 424, 457, 457, 522], [524, 524, 572, 572, 859], [861, 861, 906, 906, 997], [999, 999, 1048, 1048, 1446], [1448, 1448, 1498, 1498, 1757], [1759, 1759, 1804, 1804, 2073], [2075, 2075, 2141, 2141, 2628], [2630, 2630, 2654, 2654, 3857], [3859, 3859, 3918, 3918, 4198], [4200, 4200, 4230, 4230, 4437], [4439, 4439, 4499, 4499, 4814], [4816, 4816, 4852, 4852, 5126], [5143, 5143, 5200, 5200, 7622]], "test": "untested"}
{"id": "3tjcWw", "name": "Another twisted vine forest", "author": "jarble", "description": "I added some distortion to my \"alien megacity\" fractal, so it looks more a like a forest than a city.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 2, "viewed": 299, "published": 3, "date": "1594531202", "time_retrieved": "2024-07-30T20:55:52.846524", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    return size-length((sin(p/vec3(length((p/20.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p = vec3(30.0,0,0)+sin(p/30.0);\n    p /= scale*(1.0+.01*sin(p.yzx/5.0+p.zyx/25.0));\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = multiplier;\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p.yzx*i)/i;\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    else{\n    \tviewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    \tviewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    }\n    \n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[633, 633, 665, 665, 734], [737, 737, 761, 761, 1126], [1128, 1128, 1156, 1156, 1304], [1306, 1727, 1818, 1818, 2130], [2145, 2399, 2464, 2464, 2596], [2598, 2687, 2716, 2716, 3026], [3028, 3520, 3660, 3660, 4270], [4272, 4642, 4727, 4727, 5074], [5076, 5403, 5452, 5487, 5618], [5620, 5620, 5677, 5677, 6784]], "test": "untested"}
{"id": "Wl2yWw", "name": "Xor \"automaton\"", "author": "jarble", "description": "Another modification of my [url=https://www.shadertoy.com/view/wtlcR8]modified \"Circuit Diagram2.\"[/url] It looks almost like a cellular automaton.", "tags": ["xor"], "likes": 4, "viewed": 293, "published": 3, "date": "1594530822", "time_retrieved": "2024-07-30T20:55:53.607489", "image_code": "// \"Circuit Diagram2\" by ntsutae (modified by jarble)\n// https://twitter.com/ntsutae/status/1268820823952916486\n// https://www.openprocessing.org/sketch/912094\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  int x = int(fragCoord.x);\n  int y = int(fragCoord.y);\n  int r = (x+y+int(iTime*50.0))^(x-y);\n  bool b = abs(r*r*r/(y+x)) % (999970) < 100000;\n  fragColor = vec4(vec3(b ? 1.0 : 0.0), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yWw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 160, 215, 215, 407]], "test": "untested"}
{"id": "wtByDm", "name": "Dirac Helium?", "author": "wyatt", "description": "dirac equation model of helium atom maybe ", "tags": ["wave", "quantum"], "likes": 10, "viewed": 476, "published": 3, "date": "1594513138", "time_retrieved": "2024-07-30T20:55:54.391393", "image_code": "// Fork of \"Dirac Equation\" by wyatt. https://shadertoy.com/view/WdBBR3\n// 2020-07-12 00:13:44\n\n// Fork of \"Spinor Wave\" by wyatt. https://shadertoy.com/view/3dSBR3\n// 2020-05-26 02:37:41\n\nMain {\n    U -= 0.5*R;\n    U *= .5;\n    U += 0.5*R;\n    float\n        n = length(B(U+vec2(0,1)))+length(D(U+vec2(0,1))),\n        e = length(B(U+vec2(1,0)))+length(D(U+vec2(1,0))),\n        s = length(B(U-vec2(0,1)))+length(D(U-vec2(0,1))),\n        w = length(B(U-vec2(1,0)))+length(D(U-vec2(1,0)));\n\tvec4 a = A(U), b = B(U), c = C(U), d = D(U);  \n    vec3 no = normalize(vec3(e-w,n-s,1));\n    Q = atan(5.*vec4(length(b),0,length(d),1));\n\tQ *= 0.5+0.5*no.x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Neighborhood vec4 n = A(U+vec2(0,1)), e = A(U+vec2(1,0)), s = A(U-vec2(0,1)), w = A(U-vec2(1,0)), m = 0.25*(n+e+s+w);\n#define Neighborhood2 vec4 u = B(U+vec2(0,1)), r = B(U+vec2(1,0)), d = B(U-vec2(0,1)), l = B(U-vec2(1,0)), m2 = 0.25*(u+r+d+l);\n\n#define Main void mainImage(out vec4 Q, vec2 U)\n\n#define e(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\n#define dt .3\n#define K0 1.\n#define K1 1e-2\n#define K2 -5e-2", "buffer_a_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = (u-d);\n    vec4 dx = (r-l);\n    \n    Q.x += dt*(dx.z-dy.w);\n    Q.y += dt*(dx.w+dy.z);\n    Q.z += dt*(dx.x+dy.y);\n    Q.w += dt*(dx.y-dy.x);\n    \n    float m = 0.;\n    for (int x = -3; x<=3; x++)\n    for (int y = -3; y<=3; y++)\n    {\n        vec4 q = C(U+vec2(x,y));\n        float l = length(vec2(x,y));\n    \tm += dot(q,q)/(1.+l);\n    }\n    float p = -K0/(2.+length(U-0.5*R));\n    float p1 = K1*m;\n    vec4 q = C(U);\n    Q.xy *= e(-dt*(1.+p+p1+K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    Q.zw *= e(-dt*(1.+p+p1-K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    \n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(1);}\n    if (length(U-0.5*R)>0.3*R.y) Q *= 1.-1./R.x;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n    \n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = (u-d);\n    vec4 dx = (r-l);\n    \n    Q.x += dt*(dx.z-dy.w);\n    Q.y += dt*(dx.w+dy.z);\n    Q.z += dt*(dx.x+dy.y);\n    Q.w += dt*(dx.y-dy.x);\n    \n    float m = 0.;\n    for (int x = -3; x<=3; x++)\n    for (int y = -3; y<=3; y++)\n    {\n        vec4 q = C(U+vec2(x,y));\n        float l = length(vec2(x,y));\n    \tm += dot(q,q)/(1.+l);\n    }\n    float p = -K0/(2.+length(U-0.5*R));\n    float p1 = K1*m;\n    vec4 q = C(U);\n    Q.xy *= e(dt*(1.+p+p1+K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    Q.zw *= e(dt*(1.+p+p1-K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    \n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(1);}\n    if (length(U-0.5*R)>0.3*R.y) Q *= 1.-1./R.x;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = (u-d);\n    vec4 dx = (r-l);\n    \n    Q.x += dt*(dx.z-dy.w);\n    Q.y += dt*(dx.w+dy.z);\n    Q.z += dt*(dx.x+dy.y);\n    Q.w += dt*(dx.y-dy.x);\n    \n    float m = 0.;\n    for (int x = -3; x<=3; x++)\n    for (int y = -3; y<=3; y++)\n    {\n        vec4 q = C(U+vec2(x,y));\n        float l = length(vec2(x,y));\n    \tm += dot(q,q)/(1.+l);\n    }\n    float p = -K0/(2.+length(U-0.5*R));\n    float p1 = K1*m;\n    vec4 q = C(U);\n    Q.xy *= e(-dt*(1.+p+p1+K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    Q.zw *= e(-dt*(1.+p+p1-K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    \n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(1);}\n    if (length(U-0.5*R)>0.3*R.y) Q *= 1.-1./R.x;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n\tQ = A(U);\n    Neighborhood2;\n    \n    vec4 dy = (u-d);\n    vec4 dx = (r-l);\n    \n    Q.x += dt*(dx.z-dy.w);\n    Q.y += dt*(dx.w+dy.z);\n    Q.z += dt*(dx.x+dy.y);\n    Q.w += dt*(dx.y-dy.x);\n    \n    float m = 0.;\n    for (int x = -3; x<=3; x++)\n    for (int y = -3; y<=3; y++)\n    {\n        vec4 q = C(U+vec2(x,y));\n        float l = length(vec2(x,y));\n    \tm += dot(q,q)/(1.+l);\n    }\n    float p = -K0/(2.+length(U-0.5*R));\n    float p1 = K1*m;\n    vec4 q = C(U);\n    Q.xy *= e(dt*(1.+p+p1+K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    Q.zw *= e(dt*(1.+p+p1-K2*(dot(q.zw,q.zw)-dot(q.xy,q.xy))));\n    \n    \n    if (iFrame < 1) {Q = exp(-.01*dot(U-0.5*R,U-0.5*R))*vec4(1);}\n    if (length(U-0.5*R)>0.3*R.y) Q *= 1.-1./R.x;\n    if (iMouse.z>0.&&length(U-iMouse.xy)<13.)\n        Q.xz = vec2(-.1);\n    \n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByDm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtBcWm", "name": "Crazy distorted caves", "author": "jarble", "description": "This cave system is based on my [url=https://www.shadertoy.com/view/WtByDh]\"Alien megastructure.\"[/url]\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 392, "published": 3, "date": "1594510478", "time_retrieved": "2024-07-30T20:55:55.273036", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/4.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*100.0,0,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%3)))|t>>6&t>>5|t>>7;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 32000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = .01; //to prevent rendering artifacts\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat planet_surface(inout vec3 p,float i){\n    p -= p.zyx*(p/(size*10.0));\n    p = p/size;\n    p = (sin((p)/i+p))*size;\n    return length(p) - size;\n}\n\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n\nfloat sceneSDF(vec3 p,int iters) {\n    p = vec3(1000.0,0,0)+sin(p/1000.0)*1000.0;\n    p /= scale*(10.0+.5*sin(p.yzx/5.0+p/25.0));\n    \n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 1; i1 < 3; i1++){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n        //result += p.z*sin((p.x+p.y+p.z)/500.0);\n        i *= 3.0;\n        if(i1 == iters) break;\n    }\n    \n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,3);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))*(2.0+sin(sceneSDF(p*11.0)))/4.0+vec3(.5);\n}\n\n    \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/4.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 3) {iters += 1;}\n            else\n            return depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*100.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = length(eye-dmap);\n\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n    \n    float l2;\n    //if(l0 > .9 && l1 > 0.0){\n    //    l2 = max(log(l0),0.0);\n    //}\n    //else{\n        l2 = log(l0+1.0)*2.0;\n    //}\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, (dist-l0)*.9);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 481, 572, 572, 1018], [1020, 1020, 1047, 1047, 1196], [1198, 1198, 1255, 1255, 2266]], "test": "untested"}
{"id": "ttBcWm", "name": "Everflow", "author": "michael0884", "description": "Water flowing infinitely inside a looped space without gravity\nI think this shows the fully conservative nature of the algorithm quite well\n", "tags": ["particles", "ca"], "likes": 128, "viewed": 6374, "published": 3, "date": "1594507612", "time_retrieved": "2024-07-30T20:55:56.176620", "image_code": "// Fork of \"Paint streams\" by michael0884. https://shadertoy.com/view/WtfyDj\n// 2020-07-11 22:38:47\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvec3 mixN(vec3 a, vec3 b, float k)\n{\n    return sqrt(mix(a*a, b*b, clamp(k,0.,1.)));\n}\n\nvec4 V(vec2 p)\n{\n    return pixel(ch1, p);\n}\n\nvoid mainImage( out vec4 col, in vec2 pos )\n{\n\tR = iResolution.xy; time = iTime;\n    //pos = R*0.5 + pos*0.1;\n    ivec2 p = ivec2(pos);\n    \n    vec4 data = texel(ch2, pos);\n    particle P = getParticle(data, pos);\n    \n    //border render\n    vec3 Nb = bN(P.X);\n    float bord = smoothstep(2.*border_h,border_h*0.5,border(pos));\n    \n    vec4 rho = V(pos);\n    vec3 dx = vec3(-1., 0., 1.);\n    vec4 grad = -0.5*vec4(V(pos + dx.zy).zw - V(pos + dx.xy).zw,\n                         V(pos + dx.yz).zw - V(pos + dx.yx).zw);\n    vec2 N = pow(length(grad.xz),0.2)*normalize(grad.xz+1e-5);\n    vec3 n = normalize(vec3(N, 1));\n    vec3 r = reflect(vec3(0,0,1),n);\n    vec3 specular = 0.7*pow(texture(iChannel0, r).xyz,vec3(2.));//pow(max(dot(N, Dir(1.4)), 0.), 3.5);\n    float specularb = G(0.4*(Nb.zz - border_h))*pow(max(dot(Nb.xy, Dir(1.4)), 0.), 3.);\n    \n    float a = pow(smoothstep(fluid_rho*0., fluid_rho*2., rho.z),0.1);\n    float b = exp(-1.7*smoothstep(fluid_rho*1., fluid_rho*7.5, rho.z));\n    vec3 col0 = vec3(1., 0.5, 0.);\n    vec3 col1 = vec3(0.1, 0.4, 1.);\n    // Output to screen\n    float c = tanh(3.*(rho.w - 1.))*0.5 + 0.5;\n    col.xyz = mix(col0, col1, c)*(1.5*b + specular*3.)*a;\n    col.xyz = tanh(col.xyz*col.xyz);\n}", "image_inputs": [{"id": 25, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23309, "src": "https://soundcloud.com/stellardrone/stellardrone-eternity", "ctype": "musicstream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "#define Bf(p) mod(p,R)\n#define Bi(p) ivec2(mod(p,R))\n#define texel(a, p) texelFetch(a, Bi(p), 0)\n#define pixel(a, p) texture(a, (p)/R)\n#define ch0 iChannel0\n#define ch1 iChannel1\n#define ch2 iChannel2\n#define ch3 iChannel3\n\n#define PI 3.14159265\n\n#define loop(i,x) for(int i = 0; i < x; i++)\n#define range(i,a,b) for(int i = a; i <= b; i++)\n\n#define dt 1.5\n\n#define border_h 5.\nvec2 R;\nvec4 Mouse;\nfloat time;\n\n#define mass 1.\n\n#define fluid_rho 0.5\n\nfloat Pf(vec2 rho)\n{\n    //return 0.2*rho.x; //gas\n    float GF = 1.;//smoothstep(0.49, 0.5, 1. - rho.y);\n    return mix(0.5*rho.x,0.04*rho.x*(rho.x/fluid_rho - 1.), GF); //water pressure\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nvec2 Dir(float ang)\n{\n    return vec2(cos(ang), sin(ang));\n}\n\n\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat border(vec2 p)\n{\n    float bound = -sdBox(p - R*0.5, R*vec2(0.5, 0.5)); \n    float box = sdBox(Rot(0.*time)*(p - R*vec2(0.5, 0.6)) , R*vec2(0.05, 0.01));\n    float drain = -sdBox(p - R*vec2(0.5, 0.7), R*vec2(1.5, 2.5));\n    return max(drain,min(bound, box));\n}\n\n#define h 1.\nvec3 bN(vec2 p)\n{\n    vec3 dx = vec3(-h,0,h);\n    vec4 idx = vec4(-1./h, 0., 1./h, 0.25);\n    vec3 r = idx.zyw*border(p + dx.zy)\n           + idx.xyw*border(p + dx.xy)\n           + idx.yzw*border(p + dx.yz)\n           + idx.yxw*border(p + dx.yx);\n    return vec3(normalize(r.xy), r.z + 1e-4);\n}\n\nuint pack(vec2 x)\n{\n    x = 65534.0*clamp(0.5*x+0.5, 0., 1.);\n    return uint(round(x.x)) + 65535u*uint(round(x.y));\n}\n\nvec2 unpack(uint a)\n{\n    vec2 x = vec2(a%65535u, a/65535u);\n    return clamp(x/65534.0, 0.,1.)*2.0 - 1.0;\n}\n\nvec2 decode(float x)\n{\n    uint X = floatBitsToUint(x);\n    return unpack(X); \n}\n\nfloat encode(vec2 x)\n{\n    uint X = pack(x);\n    return uintBitsToFloat(X); \n}\n\nstruct particle\n{\n    vec2 X;\n    vec2 V;\n    vec2 M;\n};\n    \nparticle getParticle(vec4 data, vec2 pos)\n{\n    particle P; \n    P.X = decode(data.x) + pos;\n    P.V = decode(data.y);\n    P.M = data.zw;\n    return P;\n}\n\nvec4 saveParticle(particle P, vec2 pos)\n{\n    P.X = clamp(P.X - pos, vec2(-0.5), vec2(0.5));\n    return vec4(encode(P.X), encode(P.V), P.M);\n}\n\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat G(vec2 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec2 x)\n{\n    return exp(-length(x));\n}\n\n//diffusion amount\n#define dif 1.12\nvec3 distribution(vec2 x, vec2 p, float K)\n{\n    vec4 aabb0 = vec4(p - 0.5, p + 0.5);\n    vec4 aabb1 = vec4(x - K*0.5, x + K*0.5);\n    vec4 aabbX = vec4(max(aabb0.xy, aabb1.xy), min(aabb0.zw, aabb1.zw));\n    vec2 center = 0.5*(aabbX.xy + aabbX.zw); //center of mass\n    vec2 size = max(aabbX.zw - aabbX.xy, 0.); //only positive\n    float m = size.x*size.y/(K*K); //relative amount\n    //if any of the dimensions are 0 then the mass is 0\n    return vec3(center, m);\n}\n\n//diffusion and advection basically\nvoid Reintegration(sampler2D ch, inout particle P, vec2 pos)\n{\n    //basically integral over all updated neighbor distributions\n    //that fall inside of this pixel\n    //this makes the tracking conservative\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n       \n        particle P0 = getParticle(data, tpos);\n       \n        P0.X += P0.V*dt; //integrate position\n\n        float difR = 0.9 + 0.21*smoothstep(fluid_rho*0., fluid_rho*0.333, P0.M.x);\n        vec3 D = distribution(P0.X, pos, difR);\n        //the deposited mass into this cell\n        float m = P0.M.x*D.z;\n        \n        //add weighted by mass\n        P.X += D.xy*m;\n        P.V += P0.V*m;\n        P.M.y += P0.M.y*m;\n        \n        //add mass\n        P.M.x += m;\n    }\n    \n    //normalization\n    if(P.M.x != 0.)\n    {\n        P.X /= P.M.x;\n        P.V /= P.M.x;\n        P.M.y /= P.M.x;\n    }\n}\n\n//force calculation and integration\nvoid Simulation(sampler2D ch, inout particle P, vec2 pos)\n{\n    //Compute the SPH force\n    vec2 F = vec2(0.);\n    vec3 avgV = vec3(0.);\n    range(i, -2, 2) range(j, -2, 2)\n    {\n        vec2 tpos = pos + vec2(i,j);\n        vec4 data = texel(ch, tpos);\n        particle P0 = getParticle(data, tpos);\n        vec2 dx = P0.X - P.X;\n        float avgP = 0.5*P0.M.x*(Pf(P.M) + Pf(P0.M)); \n        F -= 0.5*G(1.*dx)*avgP*dx;\n        avgV += P0.M.x*G(1.*dx)*vec3(P0.V,1.);\n    }\n    avgV.xy /= avgV.z;\n\n    //viscosity\n    F += 0.*P.M.x*(avgV.xy - P.V);\n    \n    //gravity\n   // F += P.M.x*vec2(0., -0.0004);\n\n    if(Mouse.z > 0.)\n    {\n        vec2 dm =(Mouse.xy - Mouse.zw)/10.; \n        float d = distance(Mouse.xy, P.X)/20.;\n        F += 0.001*dm*exp(-d*d);\n       // P.M.y += 0.1*exp(-40.*d*d);\n    }\n    \n    //integrate\n    P.V += F*dt/P.M.x;\n\n    //border \n    vec3 N = bN(P.X);\n    float vdotN = step(N.z, border_h)*dot(-N.xy, P.V);\n    P.V += 0.5*(N.xy*vdotN + N.xy*abs(vdotN));\n    P.V += 0.*P.M.x*N.xy*step(abs(N.z), border_h)*exp(-N.z);\n    \n    if(N.z < 0.) P.V = vec2(0.);\n    \n    \n    //velocity limit\n    float v = length(P.V);\n    P.V /= (v > 1.)?v:1.;\n}\n\n\n", "buffer_a_code": "\nvoid mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos); \n    \n    particle P;// = getParticle(data, pos);\n       \n    Reintegration(ch0, P, pos);\n   \n    //initial condition\n    if(iFrame < 1)\n    {\n        //random\n        vec3 rand = hash32(pos);\n        if(rand.z < 0.2) \n        {\n            P.X = pos;\n            P.V = 0.5*(rand.xy-0.5) + vec2(sin(2.*pos.x/R.x), cos(2.*pos.x/R.x));\n            P.M = vec2(mass, 0.5 - 0.5*sin(10.*pos.x/R.x));\n        }\n        else\n        {\n            P.X = pos;\n            P.V = vec2(0.);\n            P.M = vec2(1e-6);\n        }\n    }\n    \n    U = saveParticle(P, pos);\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 U, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime; Mouse = iMouse;\n    ivec2 p = ivec2(pos);\n        \n    vec4 data = texel(ch0, pos); \n    \n    particle P = getParticle(data, pos);\n    \n    \n    if(P.M.x != 0.) //not vacuum\n    {\n        Simulation(ch0, P, pos);\n    }\n    \n   \n    U = saveParticle(P, pos);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "//density\n\nvoid mainImage( out vec4 fragColor, in vec2 pos )\n{\n    R = iResolution.xy; time = iTime;\n    ivec2 p = ivec2(pos);\n\n    vec4 data = texel(ch0, pos);\n    particle P = getParticle(data, pos);\n    \n    //particle render\n    vec4 rho = vec4(0.);\n    range(i, -1, 1) range(j, -1, 1)\n    {\n        vec2 ij = vec2(i,j);\n        vec4 data = texel(ch0, pos + ij);\n        particle P0 = getParticle(data, pos + ij);\n\n        vec2 x0 = P0.X; //update position\n        //how much mass falls into this pixel\n        rho += 1.*vec4(P.V, P.M)*G((pos - x0)/1.); \n    }\n    \n    fragColor = rho;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[101, 101, 128, 128, 306], [308, 308, 344, 344, 394], [396, 396, 412, 412, 440], [442, 442, 487, 487, 1675]], "test": "untested"}
{"id": "Mlfczf", "name": "triangle spiral", "author": "abje", "description": "I made this a long time ago, it is a part of [url]https://www.shadertoy.com/view/4ly3zc[/url].\nreminds me of sierpinski triangle.\nwith simple antialiasing.", "tags": ["2d", "triangle", "spiral"], "likes": 13, "viewed": 367, "published": 3, "date": "1594507023", "time_retrieved": "2024-07-30T20:55:56.939580", "image_code": "#define rot2(spin) mat2(sin(spin),cos(spin),-cos(spin),sin(spin))\n#define pi acos(-1.0)\n\n#define k 1.323\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 centered = fragCoord.xy*2.0-iResolution.xy;\n\tvec2 uv = centered/iResolution.y;\n    \n    float grey = 0.0;\n    \n    // instead of iTime i have pi/6.0 for a static shape\n    const mat2 rot = rot2(pi/6.0);\n    \n    // using pow for seamless \"infinite\" zoom\n    // it loops after 3 seconds, pow makes the zoom speed\n    // seamless between loops\n    float scale = 1.0/pow(k,fract(iTime/3.0)*6.0+3.0);\n    // there is a full rotation every 6 seconds.\n    \n    uv *= scale*rot2(pi*iTime/6.0);\n    int i;\n    for(i = 0; i < 40; i++) {\n        uv *= k * rot;\n        \n        if(uv.y > 1.0) {\n    \t\tbreak;\n        }\n    }\n    \n    scale *= pow(k,float(i));\n    grey = (uv.y-1.0)/scale*iResolution.y/3.0;\n\n    if (i%2 == 1) {\n        grey = 1.0-grey;\n    }\n    \n    uv /= scale;\n    \n    float len = dot(centered,centered);\n    if (len < 20.0*20.0) {\n        grey = mix(0.5,grey,sqrt(len)/20.0);\n    }\n\n    \n\tfragColor = vec4(grey);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlfczf.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 163, 163, 1098]], "test": "untested"}
{"id": "wtSyWm", "name": "Demofox WoS Interpolation 2D", "author": "demofox", "description": "Interpolate between boundary data in 2D.\nGeneralized interpolation using walk on spheres to solve the laplacian equation with a monte carlo method.\nBuffer A has the logic.\nFor a blog post coming shortly!", "tags": ["montecarlo", "interpolation", "laplace", "wos"], "likes": 12, "viewed": 1227, "published": 3, "date": "1594505469", "time_retrieved": "2024-07-30T20:55:57.712514", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the interpolated color\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rgb;\n    \n    // convert from linear to sRGB and output the color\n    fragColor = vec4(LinearToSRGB(color), 1.0);\n}\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// rainbow colors from\n// https://www.shadertoy.com/view/lsfBWs\n// level is [0,5], assumed to be a whole number\nvec3 rainbow(float level)\n{\n\t/*\n\t\tTarget colors\n\t\t=============\n\t\t\n\t\tL  x   color\n\t\t0  0.0 vec4(1.0, 0.0, 0.0, 1.0);\n\t\t1  0.2 vec4(1.0, 0.5, 0.0, 1.0);\n\t\t2  0.4 vec4(1.0, 1.0, 0.0, 1.0);\n\t\t3  0.6 vec4(0.0, 0.5, 0.0, 1.0);\n\t\t4  0.8 vec4(0.0, 0.0, 1.0, 1.0);\n\t\t5  1.0 vec4(0.5, 0.0, 0.5, 1.0);\n\t*/\n\t\n\tfloat r = float(level <= 2.0) + float(level > 4.0) * 0.5;\n\tfloat g = max(1.0 - abs(level - 2.0) * 0.5, 0.0);\n\tfloat b = (1.0 - (level - 4.0) * 0.5) * float(level >= 4.0);\n\treturn vec3(r, g, b);\n}\n\nvec3 smoothRainbow (float x)\n{\n    float level1 = floor(x*6.0);\n    float level2 = min(6.0, floor(x*6.0) + 1.0);\n    \n    vec3 a = rainbow(level1);\n    vec3 b = rainbow(level2);\n    \n    return mix(a, b, fract(x*6.0));\n}\n\n// sdLine() from\n// https://iquilezles.org/articles/distfunctions\nvoid LineTest(in vec2 p, vec2 a, vec2 b, vec3 cu,vec3 cv, inout vec4 dis_col)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    float d = length(pa-h*ba);\n    if( d<dis_col.x )\n    {\n        float s = pa.x*ba.y-pa.y*ba.x;\n        dis_col = vec4(d,(s<0.0)?cu:cv);\n    }\n}\n\nvoid CircleTest(in vec2 p, in vec3 centerRadius, in vec3 color, inout vec4 distanceAndColor)\n{\n    p -= centerRadius.xy;\n    float dist = length(p) - centerRadius.z;\n    if (dist < distanceAndColor.x)\n    {\n        distanceAndColor.x = dist;\n        distanceAndColor.yzw = color;\n    }\n}\n\nvec4 DistanceToBoundaryAndColor(vec2 p)\n{\n    vec4 ret = vec4(10000.0, 0.0, 0.0, 0.0);\n    \n    #if SCENE == 1 || SCENE == 2\n    {\n        float dist = -(length(p) - 0.4);\n        if (dist > -0.01)\n        {\n        \tfloat angle = atan(p.y, p.x);\n            if (angle < 0.0)\n                angle += c_pi * 2.0;\n            \n            #if SCENE == 2\n                float percent = angle / (2.0 * c_pi);\n            \tfloat shade = sin(angle * 10.0);\n            \tvec3 color = smoothRainbow(percent) * shade;\n            #else\n            \tfloat shade = sin(angle * 10.0);\n            \tvec3 color = vec3(shade, shade, shade);           \n            #endif\n        \tret.x = dist;\n        \tret.yzw = color;\n        }\n        else\n        {\n            ret = vec4(0.0, 0.8, 0.8, 0.8);\n        }\n        \n    }\n    #elif SCENE == 3\n    {\n    \tLineTest(p, vec2(0.0, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);\n    \tLineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);\n    \tLineTest(p, vec2(-0.3, 0.2), vec2(0.0, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);\n    }\n    #elif SCENE == 4\n    {\n    \tLineTest(p, vec2(0.3, -0.2), vec2(0.3, 0.2), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), ret);\n    \tLineTest(p, vec2(0.3, 0.2), vec2(-0.3, 0.2), vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 1.0), ret);\n    \tLineTest(p, vec2(-0.3, 0.2), vec2(-0.3, -0.2), vec3(0.0, 0.0, 1.0), vec3(1.0, 0.0, 0.0), ret);\n    }    \n    #elif SCENE == 5\n    {\n        CircleTest(p, vec3(0.0, -0.2, 0.03), vec3(1.0, 0.0, 0.0), ret);\n        CircleTest(p, vec3(0.3, 0.2, 0.03), vec3(0.0, 1.0, 0.0), ret);\n        CircleTest(p, vec3(-0.3, 0.2, 0.03), vec3(0.0, 0.0, 1.0), ret);\n\n        LineTest(p, vec2(-0.7, 0.4), vec2(-0.7, -0.4), vec3(0.0, 0.0, 0.0), vec3(0.8, 0.8, 0.8), ret); \n        LineTest(p, vec2( 0.7, 0.4), vec2( 0.7, -0.4), vec3(0.8, 0.8, 0.8), vec3(0.0, 0.0, 0.0), ret); \n    }\n    #endif\n    \n    return ret;\n}\n\nvec2 R2(int index)\n{\n    // Generalized golden ratio to 2d.\n    // Solution to x^3 = x + 1\n    // AKA plastic constant.\n    // from http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\n    float g = 1.32471795724474602596f;\n    float a1 = 1.0f / g;\n    float a2 = 1.0f / (g * g);\n\n    return vec2(fract(float(index) * a1), fract(float(index) * a2));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    vec3 thisFrameColor = vec3(0.0f, 0.0f, 0.0f);\n    for (int walkIndex = 0; walkIndex < c_numWalksPerFrame; ++walkIndex)\n    {\n        // this is our starting point\n        vec2 p = (fragCoord.xy / iResolution.xy); \n        if (BN != 0)\n            p.x = fract(p.x*2.0);\n        p -= 0.5;\n        p.x *= iResolution.x / iResolution.y;  // aspect ratio\n        \n        // first random number\n        vec2 offset = R2(iFrame) * vec2(1024.0, 1024.0);\n        float rnd = texelFetch(iChannel2, ivec2(fragCoord.xy + offset) % ivec2(1024, 1024),0).r;\n        rnd = fract(rnd + float(walkIndex) * c_goldenRatioConjugate);\n        if (BN == 0 || fragCoord.x < iResolution.x * 0.5)\n        {\n            rnd = RandomFloat01(rngState);              \n        }\n\n        // Walk on spheres algorithm\n        vec4 distanceAndColor;\n        for (int i = 0; i < c_numStepsMax; ++i)\n        {        \n            // Get distance to closest boundary.\n            // If it's close enough, we are done. Use the color of the boundary we are next to.\n            distanceAndColor = DistanceToBoundaryAndColor(p);\n            if (distanceAndColor.x < c_epsilon)\n                break;\n\n\n            // Otherwise, walk the distance to the nearest boundary, in a random direction.\n            float angle = rnd * 2.0 * c_pi;\n            vec2 direction = vec2(cos(angle), sin(angle));\n            p += direction * distanceAndColor.x;\n            \n            // next random number\n            rnd = RandomFloat01(rngState);\n        }\n        thisFrameColor += distanceAndColor.yzw / float(c_numWalksPerFrame);\n    }\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);  \n\n    // incremental average this new color with the old.\n    vec4 lastFrameColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    float blend = (iFrame < 2 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    #if BN\n    vec3 newColor = thisFrameColor;\n    #else\n    vec3 newColor = mix(lastFrameColor.rgb, thisFrameColor, blend);\n    #endif\n    fragColor = vec4(newColor, blend);    \n}\n", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// how close the random walk needs to get before it's considered a hit.\n// This is in a percentage of the screen\nconst float c_epsilon = 0.001;\n\n// how many steps to take on the random walk at maximum\nconst int c_numStepsMax = 32;\n\n// how many walks done per pixel, per frame.\n// useful for getting around being limited to 60fps\nconst int c_numWalksPerFrame = 64;\n\n// SCENE values:\n// 1 - a black and white circle\n// 2 - a rainbow circle\n// 3 - a triangle with sides RGB inside and out\n// 4 - same as 3, but made into a U shape instead of a triangle\n// 5 - 3 circles R,G,B with black borders on the sides\n#define SCENE 5\n\n#define BN 0\n#define BN_SEED_SHARE 1\n\nconst float c_goldenRatioConjugate = 0.618033988749895;\n\n// ==================================================================\n\nconst float KEY_SPACE = 32.5/256.0;\n\nconst float c_pi = 3.14159265359;\n\n// for converting from linear to sRGB\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        lessThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308))\n    );\n}\n\n// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyWm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 91, 269]], "test": "untested"}
{"id": "ttByDw", "name": "Demofox WoS Interpolation 1D", "author": "demofox", "description": "Interpolate between two points in 1D.\nGeneralized interpolation using walk on spheres to solve the laplacian equation with a monte carlo method.\nBuffer A has the logic.\nFor a blog post coming shortly!", "tags": ["montecarlo", "interpolation", "laplace", "wos"], "likes": 9, "viewed": 883, "published": 3, "date": "1594501696", "time_retrieved": "2024-07-30T20:55:58.482455", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // get the interpolated color\n    vec3 color = texelFetch(iChannel0, ivec2(fragCoord.xy),0).rgb;\n    \n    // convert from linear to sRGB and output the color\n    fragColor = vec4(LinearToSRGB(color), 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec4 DistanceToBoundaryAndColor(float x)\n{\n    // There is a boundary at x=0 and x=1. return the distance of whichever is closer.\n    // Also give the color at that boundary.\n    if (x <= 0.5)\n        return vec4(x, colorA);\n    else\n        return vec4(1.0 - x, colorB);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialize a random number state based on frag coord and frame\n    uint rngState = uint(uint(fragCoord.x) * uint(1973) + uint(fragCoord.y) * uint(9277) + uint(iFrame) * uint(26699)) | uint(1);    \n    \n    // this is our starting point\n\tfloat x = fragCoord.x / iResolution.x;\n    \n    // Walk on spheres algorithm\n\tvec4 distanceAndColor;\n    for (int i = 0; i < c_numStepsMax; ++i)\n    {\n        // Get distance to closest boundary.\n        // If it's close enough, we are done. Use the color of the boundary we are next to.\n        distanceAndColor = DistanceToBoundaryAndColor(x);\n        if (distanceAndColor.x < c_epsilon)\n            break;\n        \n        // Otherwise, walk the distance to the nearest boundary, in a random direction.\n        // A random direction on a numberline is just \"left or right\"\n        float direction = (RandomFloat01(rngState) < 0.5) ? -1.0 : 1.0;\n        x += direction * distanceAndColor.x;\n    }\n    \n    // see if space was pressed. if so we want to restart our render.\n    // This is useful for when we go fullscreen for a bigger image.\n    bool spacePressed = (texture(iChannel1, vec2(KEY_SPACE,0.25)).x > 0.1);  \n\n    // incremental average this new color with the old.\n    vec4 lastFrameColor = texelFetch(iChannel0, ivec2(fragCoord.xy),0);\n    float blend = (iFrame < 2 || spacePressed) ? 1.0 : 1.0 / (1.0 + (1.0 / lastFrameColor.a));\n    vec3 newColor = mix(lastFrameColor.rgb, distanceAndColor.yzw, blend);\n    fragColor = vec4(newColor, blend);    \n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// how close the random walk needs to get before it's considered a hit.\n// This is in a percentage of the screen\nconst float c_epsilon = 0.001;\n\n// how many steps to take on the random walk at maximum\nconst int c_numStepsMax = 32;\n\n// linear space colors we are interpolating between\nconst vec3 colorA = vec3(1.0, 0.0, 0.0);\nconst vec3 colorB = vec3(1.0, 1.0, 0.0);\n\n\n\n\n// ==================================================================\n\nconst float KEY_SPACE = 32.5/256.0;\n\n// for converting from linear to sRGB\nvec3 LinearToSRGB(vec3 rgb)\n{\n    rgb = clamp(rgb, 0.0, 1.0);\n    \n    return mix(\n        pow(rgb, vec3(1.0 / 2.4)) * 1.055 - 0.055,\n        rgb * 12.92,\n        lessThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308))\n    );\n}\n\n// RNG\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 91, 269]], "test": "untested"}
{"id": "tlByDw", "name": "Wax on Dope", "author": "blackle", "description": "my attempt to recreate dope on wax during the final of a shader showdown. took 25 minutes and I'm just happy to have made ferris smile <:", "tags": ["livecode"], "likes": 14, "viewed": 437, "published": 3, "date": "1594497268", "time_retrieved": "2024-07-30T20:55:59.359111", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat malboge(vec3 p) {\n  return dot(sin(p), cos(p));\n}\n\nfloat box(vec3 p, vec3 d) {\n  p = abs(p)-d;\n  return length(max(p,0.))+min(0.,max(p.x,max(p.y,p.z)));\n}\n\nfloat smin(float a, float b, float k) {\n  float h = max(0.,k-abs(b-a))/k;\n  return min(a,b) - h*h*h*k/6.;\n}\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(vec3(0),vec3(k)-abs(b-a))/k;\n  return min(a,b) - h*h*h*k/6.;\n}\n\nfloat scene(vec3 p) {\n  p = erot(p, vec3(0,0,1), sin(p.z*10.)/5.*sin(iTime)/2.);\n  vec3 p2 = p;\n  p2.z += malboge(vec3(p.xy*10.+iTime/4.,0))*.02;\n  p2.z += malboge(erot(vec3(p.xy*4.+iTime/2.,0),vec3(0,0,1),.4))*.06;\n  p2.z += malboge(erot(vec3(p.xy*20.+iTime/2.,0),vec3(0,0,1),.8))*.01;\n  \n  p += malboge(p*20.)*.005;\n  p += malboge(erot(p,normalize(vec3(1,2,3)),.5)*8.)*.01;\n  p += malboge(erot(p,normalize(vec3(3,2,1)),.5)*30.)*.005;\n  float bx = box(p2,vec3(1,1,.3))-.05;\n  p-=vec3(0,0,abs(sin(iTime))*.7+.5);\n  p = erot(p,normalize(vec3(1,2,3)),iTime);\n  float sph = length(-smin(.2-abs(p),vec3(.15),.1)  )-.18;\n  return smin(bx,sph,.5);\n}\n\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize( scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2])  ));\n}\n\nvec4 plas( vec2 v, float time )\n{\n  float c = 0.5 + sin( v.x * 10.0 ) + cos( sin( time + v.y ) * 20.0 );\n  return vec4( sin(c * 0.2 + cos(time)), c * 0.15, cos( c * 0.1 + time / .4 ) * .25, 1.0 );\n}\n\nvec3 skycol(vec3 p) {\n  \n  float s1 = length(sin(p*2.)*.5+.5)/sqrt(3.);\n  float s2 = length(sin(p*3.)*.5+.5)/sqrt(3.);\n  return pow(vec3(.2,0.1,0.4)*s1 + vec3(.4,0.1,.2)*s2,vec3(4)) + pow(max(dot(p,normalize(vec3(1))),0.),50.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  vec3 cam = normalize(vec3(1.5/*+fract(iTime/60.*26.*6.)/10.*/,uv));\n  vec3 init = vec3(-5,0,.3);\n  \n  float yrot = .6 + sin(iTime*.3)*.2;\n  float zrot = iTime/3.;\n  cam = erot(cam, vec3(0,1,0), yrot);\n  init = erot(init, vec3(0,1,0), yrot);\n  cam = erot(cam, vec3(0,0,1), zrot);\n  init = erot(init, vec3(0,0,1), zrot);\n  \n  \n  vec3 p =init;\n  bool hit = false;\n  vec3 atten = vec3(1);\n  for (int i = 0; i< 150 && !hit; i++) { \n    float dist = scene(p);\n    hit = dist*dist < 1e-6;\n    \n  float thing = fract(dot(vec3(1),p+iTime/10.));\n    if (hit && thing < .5) {\n      hit = false;\n      dist = .1;\n      vec3 n = norm(p);\n      atten  *= (1.-abs(dot(n,cam))*.97)*vec3(0.9,0.7,0.5);\n      cam = reflect(cam,n);\n    }\n    p += cam *dist;\n  }\n  vec3 n = norm(p);\n  vec3 r = reflect(cam, n);\n  float diff = length(sin(n*2.)*.5+.5)/sqrt(3.);\n  float spec = length(sin(r*2.)*.5+.5)/sqrt(3.);\n  float fres = 1. - abs(dot(n,cam))*.98;\n  vec3 wax = vec3(.9)*diff + pow(spec,10.)*fres;\n  mat3 dsat = mat3(.4)+mat3(vec3(.2),vec3(.2),vec3(.2));\n  vec3 dope = vec3(0.6,0.25,0.1)*spec*spec*spec*2. + pow(spec,20.)*fres*2.;\n  float thing = fract(dot(vec3(1.),p+iTime/10.));\n  vec3 col = mix(dope,wax,step(.5,thing));\n  fragColor.xyz = dsat*dsat*sqrt(hit ? col*atten : skycol(cam)*atten);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDw.jpg", "access": "api", "license": "cc0-1.0", "functions": [[195, 195, 233, 233, 293], [295, 295, 318, 318, 350], [352, 352, 379, 379, 455], [457, 457, 496, 496, 564], [565, 565, 601, 601, 679], [681, 681, 702, 702, 1324], [1327, 1327, 1346, 1346, 1461], [1463, 1463, 1496, 1496, 1661], [1663, 1663, 1684, 1684, 1892], [1894, 1894, 1951, 1951, 3289]], "test": "untested"}
{"id": "wtByDw", "name": "Industrial machinery", "author": "jarble", "description": "This fractal appears to be a large industrial complex.\nClick and drag the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 3, "viewed": 299, "published": 3, "date": "1594496801", "time_retrieved": "2024-07-30T20:56:00.147005", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 3.0\n#define iterations 4\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1,float i){\n    p += sin(p.yzx+iTime*i*9.0)/(i*27.0); //animation\n    return size-length(sin(p/vec3(length(p/20.0)))*size1)/1.8;\n}\n\nfloat vines(vec3 p,float size1){\n\treturn vines(p,size1,1.0);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    float i = multiplier;\n\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p*i)/i;\n        result = min(result,vines(p,size1,i)/(i));\n        i *= multiplier;\n    }\n    return (result)*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    //p *= sin(p);\n    float v = vines(p,1.0);\n    return sin(vec3(v*6.0,v*4.0,v*3.0))/5.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.0+.001*(1.0+depth);\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    \n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    \n    vec3 eye = vec3(50.0,1.6,iTime/10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[631, 631, 671, 671, 790], [792, 792, 824, 824, 854], [856, 856, 880, 880, 1183], [1185, 1185, 1213, 1232, 1316], [1318, 1739, 1830, 1830, 2206], [2221, 2475, 2540, 2540, 2672], [2674, 2763, 2792, 2792, 3107], [3109, 3601, 3741, 3741, 4351], [4353, 4723, 4808, 4808, 5155], [5157, 5484, 5533, 5568, 5699], [5701, 5701, 5758, 5758, 6835]], "test": "untested"}
{"id": "WlSczh", "name": "Enamel Pin", "author": "blackle", "description": "enamel pin of the transgender symbol (with a pentagram inside)\n4k exegfx for solskogen 2020\nbased on an actual pin: https://www.etsy.com/listing/728263195/trans-symbol-pentacle-enamel-pin-lapel", "tags": ["trans", "pentagram", "transgender"], "likes": 37, "viewed": 1312, "published": 3, "date": "1594487434", "time_retrieved": "2024-07-30T20:56:01.121399", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n//blessed be mattz for posting the code to fit garbor functions to arbitrary images!\n//from https://www.shadertoy.com/view/4ljSRR\n//this is used to hardcode the bloom >:3\nfloat gabor(vec2 p, float u, float v, float r, float ph, float l, float t, float s, float h) {\n    float cr = cos(r);\n    float sr = sin(r);\n        \n    vec2 st = vec2(s,t);\n\n    p = mat2(cr, -sr, sr, cr) * vec2(p.x-u,-p.y-v);    \n    return h * exp(dot(vec2(-0.5), p*p/(st*st))) * cos(p.x*6.2831853/l+ph);\n    \n}\n\nfloat hash(float a, float b) {\n    int x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y/ZOOM;\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    fragColor.xyz /= fragColor.w;\n    float k = 0.0;\n\n\tfloat sd = hash(uv.x,uv.y);\n#ifdef HARD_CODED_BLOOM\n\tk+=gabor(uv, 0.07, 0.03, 1.89, 1.08, 3.65, 0.13, 0.12, 1.82);\n\tk+=gabor(uv, -0.52, 0.94, 3.26, 2.84, 3.72, 0.53, 0.53, 0.21);\n\tk+=gabor(uv, 0.05, -0.16, 1.60, 1.52, 3.12, 0.09, 0.09, 1.50);\n\tk+=gabor(uv, 0.45, 0.94, 6.28, 2.33, 4.00, 0.48, 0.48, 0.17);\n\tk+=gabor(uv, 0.30, 0.03, 4.39, 6.27, 0.36, 0.13, 0.13, 0.11);\n\tk+=gabor(uv, 0.07, -0.08, 3.17, 1.22, 0.41, 0.16, 0.05, 0.15);\n\tk+=gabor(uv, 0.94, -0.55, 4.75, 4.04, 1.14, 1.06, 0.14, 0.18);\n\tk+=gabor(uv, -0.88, -0.18, 4.03, 3.94, 1.29, 0.49, 0.49, 0.05);\n\tk+=gabor(uv, 0.16, -0.05, 1.60, 6.28, 0.21, 0.05, 0.05, 0.18);\n\tk+=gabor(uv, -0.42, 0.45, 5.45, 1.03, 0.76, 0.35, 0.35, 0.05);\n    \n    \n    float bloom = k*.9+.2;\n    vec4 bbright = vec4(0xaf,0x84,0x6a,0)/128.;\n    vec4 bmid = vec4(0x15,0x17,0x19,0)/60.;\n    fragColor = mix(fragColor,mix(bmid, bbright,(max(bloom,0.1)-.1)/.9)*sqrt(bloom),0.6);\n#endif\n    fragColor += sd*sd*.02;\n\tfragColor *= (1.0 - dot(uv,uv)*0.30); //vingetting lol\n\tfragColor = (smoothstep(vec4(-.34),vec4(1.), log(fragColor+1.0))-.2)/.8; //colour grading\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec3 erot(vec3 p, vec3 ax, float ro) {\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = max(0.,k-abs(b-a))/k;\n    return min(a,b)-h*h*h*k/6.;\n}\n\nfloat super(vec2 p) { return sqrt(length(p*p));}\nfloat super(vec3 p) { return sqrt(length(p*p));}\nfloat box(vec2 p, vec2 d) {\n    vec2 q = sqrt(p*p+0.005)-d;\n    return super(max(q,0.))+min(0.,max(q.x,q.y));\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n    float k = dot(p-a,b-a)/dot(b-a,b-a);\n    return distance(p,mix(a,b,clamp(k,0.,1.)));\n}\n\nfloat pin_sdf(vec2 p) {\n    //p+=sin(p.y*10.)*sin(p.x*10.)*.005;\n    p+=sin(p.y*15.)*sin(p.x*15.)*.002;\n    float inner = length(p)-.73;\n    float angl = atan(p.y,p.x);\n    float angl2 = asin(sin(angl*5.-1.4)*.995)/5.;\n    angl = asin(sin(angl*1.3)*.99)/1.3;\n    vec2 p2 = vec2(cos(angl),sin(angl))*length(p);\n    vec2 p3 = vec2(cos(angl2),sin(angl2))*length(p);\n    float pentagram = linedist(p3, vec2(0.67,0.22),vec2(0.25,-0.07));\n    pentagram = smin(pentagram, linedist(p3, vec2(0.23,-0.07),vec2(0,0.60)) ,.05 );\n    float arms = box(p2-vec2(1.4,0), vec2(.6,.1));\n    \n    mat2 rot = mat2(.7,-.7,.7,.7);\n    float cplane1 = p.x;\n    float cplane2 = p.y*.95-p.x*.32-.1;\n    \n    float bars = min(box(p2-vec2(1.45,0), vec2(.1,.35)), box((abs(p2)-vec2(1.45,.35))*rot, vec2(.13)));\n\tarms = smin(arms, max(cplane2,bars),.05);\n    \n    float arrow = box((p2-vec2(1.9,0))*vec2(.6,1)*rot, vec2(.2,.2));\n    arrow = -smin(-arrow, p2.x-1.9, .03);\n    arms = smin(arms, max(cplane1,arrow),.05);\n\n    //bar on bottom of bottom leg\n    arms = smin(arms, box((p2-vec2(1.95,0))*rot, vec2(.12,.12)),.05);\n    \n    float body = smin(arms-.05,min(max(length(p)-1.,-inner),inner),.1);\n    body = -smin(-body,pentagram,0.05);\n    return body;\n}\n\nfloat hash(float a, float b) {\n    int x = floatBitsToInt(a*a/7.)^floatBitsToInt(a+.1);\n    int y = floatBitsToInt(b*b/7.)^floatBitsToInt(b+.1);\n    return float((x*x+y)*(y*y-x)-x)/2.14e9;\n}\n\nvec2 hash2(float a, float b) {\n    float s1 = hash(a,b);\n    float s2 = hash(s1,a);\n    return vec2(s1,s2);\n}\n\nfloat pin_edge;\nfloat fabric;\nfloat scene(vec3 p) {\n    vec3 p2 = erot(p,vec3(1,0,0),2.7),p3 = p;\n    p.y=p.y/1.5+1.2;\n    p.yz = asin(sin(p.yz/20.)*.6)*20.;\n    //weird space folding for the fabric texture.\n    mat2 rot = mat2(cos(2.6),-sin(2.6),sin(2.6),cos(2.6)); //erot is powerful, but slower here\n    for(int i = 0; i < 8; i++) {\n        p.yz-=float(i);\n    \tp.yz*=rot;\n    \tp.y = sqrt(p.y*p.y+float(i/2+1))-.5;\n    }\n    \n    vec3 edg = normalize(vec3(-1,1.,1.));\n    p2.yz += asin(sin(p.yz)*.9);\n    p2.yz=asin(sin(p2.yz*vec2(5.,8.))*.85)/vec2(5.,8.);\n    fabric = dot(p,edg);\n\n    p2.x=fabric/1.;\n    p2+=.005*dot(sin(p3.yz*8.4),cos(p3.xy*6.));\n    p2+=.001*dot(sin(p3.yz*50.),cos(p3.xy*40.));\n\n    fabric = smin(fabric,(mix(length(p2),super(p2),.7)-0.2),.2);\n    \n    p3.x-=6.;\n    p3=erot(p3,vec3(.997,0,-.075),2.45);\n    float pinsdf = pin_sdf(p3.yz/13.)*13.;\n    p3 += p2/30.;\n\tp3 += sin(p.yxz*10.)/1000.;\n    float ln = dot(p3.yz,p3.yz)/14.;\n    float bump = smoothstep(1.1,1.5,sin(p.y*60.+sin(p.y*4.6)*1.35)+sin(p.z*50.+sin(p.z*5.6)*1.5));\n    bump += smoothstep(1.1,1.3,sin(p.y*90.+sin(p.y*5.6)*1.45)+sin(p.z*80.+sin(p.z*7.6)*1.55));\n\tfloat pin_inside = box(vec2(pinsdf+2., p3.x-sqrt(sqrt(smoothstep(0.,-1.7,pinsdf)))*.1), vec2(2.,.85-ln*.005))-.2;\n\n    pin_edge = box(vec2(pinsdf, p3.x), vec2(.12+cos(p3.y/20.)*0.05-ln*.001,1.-ln*.005))-.12+bump/1500.;\n    pin_edge = mix(pin_edge, linedist(vec2(pinsdf, p3.x), vec2(0.5,1),vec2(0,-1))-.3,0.005);\n    return min(fabric,min(pin_edge,pin_inside));\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.001);\n    return normalize(scene(p)-vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nconst vec3 suncol = vec3(1.5,1.0,0.7);\nconst vec3 skycol = vec3(0.4,0.75,1.0);\nconst vec3 sundir = normalize(vec3(-1,0.,1.2));\nvec3 skybox(vec3 angle) {\n\treturn mix(vec3(1),skycol, angle.x*angle.x) \n        + pow(max(dot(angle, sundir),0.0),350.0)*suncol*15.0;\n}\n\nvec3 pixel_color( vec2 uv )\n{\n    uv/=ZOOM;\n    uv.y-=.02;uv.x+=.02;\n    vec2 mouse = (iMouse.xy-0.5*iResolution.xy)/iResolution.y;\n\n    vec2 h2 = tan(hash2(uv.x,uv.y));\n    vec3 cam = normalize(vec3(2.5,uv+h2*.02));\n    vec3 init = vec3(-120,-h2);\n    float yrot = -.6;\n    float xrot = 0.;\n    if (iMouse.z > 0.) {\n        yrot += -4.*mouse.y;\n        xrot = 4.*mouse.x;\n    }\n    cam = erot(cam,vec3(0,1,0),yrot);\n    init = erot(init,vec3(0,1,0),yrot);\n    cam = erot(cam, vec3(1,0,0), xrot);\n    init = erot(init, vec3(1,0,0), xrot);\n    vec3 p = init;\n    bool hit = false;\n    float atten = 1.;\n    float dist;\n    for (int i = 0; i < 200 && !hit; i++) {\n        dist = scene(p);\n        hit = dist*dist < 1e-7;\n        if (hit && dist == pin_edge) {\n            vec3 n = norm(p);\n    \t\tatten *= 1.-abs(dot(cam,n))*.5;\n            cam = reflect(cam,n);\n            dist = .1;\n            hit = false;\n        }\n        p += cam * dist;\n        if (distance(p,init) > 1000.)break;\n    }\n    float mat = dist == fabric ? 1. : 0.;\n    vec3 n = norm(p);\n    vec3 r = reflect(cam,n);\n    float spec = max(0.,dot(r,sundir));\n    float fres = 1.-abs(dot(cam,n))*.9;\n    float ao = smoothstep(-1.,2.,scene(p+n*.5+sundir*3.));\n    vec3 col = (spec*.3*skycol*(ao*.2+.7) + \n        ((pow(spec,8.)*.1*suncol+ pow(spec,20.))*4.)*mat+\n         (mat*.8+.2)*(pow(spec,80.)*3.+ step(0.999-mat*.01,spec)*10.))*fres*ao;\n    return (hit ? col : skybox(cam))*atten;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    //press space to reset the rendering.\n    if (texelFetch(iChannel1, ivec2(32,1), 0).x > 0. || iMouse.z > 0.) fragColor = vec4(0);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float sd = hash(uv.x,uv.y);\n    vec2 h2 = tan(hash2(sd, float(iFrame)));\n#ifndef HARD_CODED_BLOOM\n    if (iFrame %5!=0)h2=tan(h2)*iResolution.y/15.;\n#endif\n    vec2 uv2 = uv + h2/iResolution.y;\n    fragColor += vec4(pixel_color(uv2), 1)\n#ifndef HARD_CODED_BLOOM\n        *(iFrame%5!=0?.3:1.)\n#endif\n    ;\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "//comment out to get \"real\" bloom instead of the hardcoded gabor image.\n//make sure to reset the time when you do.\n#define HARD_CODED_BLOOM\n#define ZOOM 1.", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczh.jpg", "access": "api", "license": "cc0-1.0", "functions": [[194, 365, 459, 459, 679], [681, 681, 711, 711, 871], [872, 872, 929, 929, 2202]], "test": "untested"}
{"id": "3tBcWm", "name": "Music Cave", "author": "blackle", "description": "my qualifier round for the live code compo at solskogen 2020, ported to shadertoy. coded in 15 minutes live <:\nwatch the replay here: https://www.youtube.com/watch?v=5rjNcG7ioaU", "tags": ["livecode"], "likes": 30, "viewed": 697, "published": 3, "date": "1594478575", "time_retrieved": "2024-07-30T20:56:01.904306", "image_code": "//CC0 1.0 Universal https://creativecommons.org/publicdomain/zero/1.0/\n//To the extent possible under law, Blackle Mori has waived all copyright and related or neighboring rights to this work.\n\n\nvec3 erot(vec3 p, vec3 ax, float ro) {\n  return mix(dot(ax,p)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat edges;\nfloat comp(vec3 p) {\n  vec3 s = sin(p)*sin(p);\n  edges = max(max(edges,s.x),max(s.z,s.y));\n  p = asin(sin(p));\n  return dot(p,normalize(vec3(1)));\n}\n\nfloat stage;\nfloat cave;\nfloat pillars;\nfloat scene(vec3 p) {\n  edges = 0.;\n  float d1 = comp(erot(p,normalize(vec3(3,2,1)),0.5)+1.);\n  float d2 = comp(erot(p,normalize(vec3(2,1,3)),0.6)+2.);\n  float d3 = comp(erot(p,normalize(vec3(1,3,2)),0.7)+3.+iTime*mod(stage,2.));\n  cave = (d1+d2+d3)/3. - length(p.zy*vec2(1,.2))/3. + 2.;\n  pillars = length(asin(sin(p.xy/3.+2.))*3.)-.2 - pow(texture(iChannel0,vec2(abs(p.z)/400.,0)).r,4.)/2. - p.z*p.z/100.;\n  return min(cave,pillars);\n}\n\nvec3 norm(vec3 p) {\n  mat3 k = mat3(p,p,p)-mat3(0.01);\n  return normalize(scene(p) - vec3( scene(k[0]),scene(k[1]),scene(k[2]) ));\n}\n\n//hello world\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n\n  float t = iTime/60.*125.;\n  stage = floor(t/4.);\n  t += mod(stage,100.)*34.23;\n  vec3 cam = normalize(vec3(1.2+sin(stage),uv));\n  vec3 init= vec3(-4,0,0);\n  cam = erot(cam,vec3(1,0,0),t/6.*sign(cos(stage*32.3)));\n  if(cos(stage*7.)<0.)cam=cam.zxy;\n  init.x += mod(t,100.)*3.*sign(cos(stage*10.3));\n  vec3 p =init;\n  bool hit = false;\n  float dist;\n  float glow = 0.;\n  for (int i = 0; i < 150 && !hit ; i ++) {\n    dist = scene(p);\n    hit = dist*dist < 1e-6;\n    glow += smoothstep(.99,1.,edges)/(1.+abs(cave)*200.)*pow(abs(sin(p.x/40.+iTime)),20.)/2.;\n    glow += pow(texture(iChannel0,vec2(abs(p.z)/20.,0)).r,4.)/(1.+abs(pillars)*100.)/2.;\n    p+=cam*dist;\n  }\n  bool pl = pillars==dist;\n  float ms = step(0.999,edges);\n  float fog = smoothstep(80.,0.,distance(p,init));\n#define AO(p,n,t) smoothstep(-t,t,scene(p+n*t))\n  vec3 n = norm(p);\n  vec3 r = reflect(cam,n);\n  float ao = AO(p,n,1.)*AO(p,n,.5)*AO(p,n,.1);\n  float sss = AO(p,vec3(0.7),1.);\n  float spec = length(sin(r.xy*3.)*.4+.6)/sqrt(2.);\n  vec3 matcol = pl ? vec3 (0.9,0.1,0.05) : vec3(0.8);\n  vec3 col = mix(spec,sss,.5)*matcol;\n  if(!pl)col *= 1.-ms;\n  col += pow(spec,10.);\n  fragColor.xyz = sqrt((hit ? col*fog*ao : vec3(0.03)) + glow*glow + glow*vec3(0.5,0.7,1));\n  fragColor *= 1.-dot(uv,uv)*.7;\n}", "image_inputs": [{"id": 23306, "src": "https://soundcloud.com/anamanaguchi/kei-feat-pochi", "ctype": "musicstream", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcWm.jpg", "access": "api", "license": "cc0-1.0", "functions": [[195, 195, 233, 233, 293], [308, 308, 328, 328, 456], [498, 498, 519, 519, 935], [937, 937, 956, 956, 1069], [1071, 1085, 1142, 1142, 2470]], "test": "untested"}
{"id": "Wljczw", "name": "Basic Mandelbrot - Interactive", "author": "AmarnathMurugan", "description": "Control:\nX - Zoom In\nZ - Zoom Out\nArrow Keys - Movement", "tags": ["fractal"], "likes": 3, "viewed": 446, "published": 3, "date": "1594475960", "time_retrieved": "2024-07-30T20:56:02.787944", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    float col = 0.0;\n    vec2 z = vec2(0);\n    vec4 PrevState = texelFetch(iChannel0,ivec2(0,0),0);  \n    vec2 c = (uv+vec2(PrevState.y*PrevState.x*10.0-0.250,PrevState.z*PrevState.x*10.0))/(PrevState.x*10.0);\n    float MaxIter = mix(100.0,5000.0,PrevState.x*0.0007);\n    float iter = 0.0;\n    for(int i=0;i<int(MaxIter);i++)\n    {\n    \tz = vec2(z.x*z.x-z.y*z.y, 2.0*z.x*z.y)+ c;\n        if(length(z)>5.0)\n            break;\n        iter++;\n    }\n    col = iter/MaxIter; \n    vec3 fColor = vec3(col,col*=1.6,col*=2.0)*(2.0-col);\n    fragColor = vec4(fColor,1.0);\n    \n} ", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "const int KEY_Z  = 90;\nconst int KEY_X  = 88;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nfloat zoom = 0.05;\nvec2 offset = vec2(0);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    vec4 m = iMouse/iResolution.xyxy;\n    \n    zoom = texelFetch(iChannel0,ivec2(0,0),0).x;\n    zoom =max(0.05, mix(zoom,zoom+zoom*0.01,texelFetch(iChannel1,ivec2(KEY_X,0),0).x));\n    zoom =max(0.05, mix(zoom,zoom-zoom*0.01,texelFetch(iChannel1,ivec2(KEY_Z,0),0).x));\n    offset = texelFetch(iChannel0,ivec2(0,0),0).yz; \n    offset.x+= (texelFetch(iChannel1,ivec2(KEY_RIGHT,0),0).x - texelFetch(iChannel1,ivec2(KEY_LEFT,0),0).x)*0.001/zoom;\n    offset.y+= (texelFetch(iChannel1,ivec2(KEY_UP,0),0).x - texelFetch(iChannel1,ivec2(KEY_DOWN,0),0).x)*0.001/zoom;\n    fragColor = vec4(zoom,offset.x,offset.y,1.0);\n} ", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wljczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 724]], "test": "untested"}
{"id": "3lSyDw", "name": "Layered Noise Tests", "author": "cshenton", "description": "noise", "tags": ["noise"], "likes": 6, "viewed": 388, "published": 3, "date": "1594473246", "time_retrieved": "2024-07-30T20:56:03.633682", "image_code": "// Baked noise sampler\nfloat noise(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0, (p + vec2(0.5, 0.5)) / 256.0, 0.0).x;\n\tfloat b = textureLod(iChannel0, (p + vec2(1.5, 0.5)) / 256.0, 0.0).x;\n\tfloat c = textureLod(iChannel0, (p + vec2(0.5, 1.5)) / 256.0, 0.0).x;\n\tfloat d = textureLod(iChannel0, (p + vec2(1.5, 1.5)) / 256.0, 0.0).x;\n    return mix(mix( a, b, f.x), mix(c, d, f.x), f.y);\n}\n\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n// 1D 6 octave FBM noise\nfloat fbm6(vec2 p) {\n    float f = 0.0;\n\n    f += 0.500000 * noise(p); p = mtx*p*2.02;\n    f += 0.250000 * noise(p); p = mtx*p*2.03;\n    f += 0.125000 * noise(p); p = mtx*p*2.01;\n    f += 0.062500 * noise(p); p = mtx*p*2.04;\n    f += 0.031250 * noise(p); p = mtx*p*2.01;\n    f += 0.015625 * noise(p);\n\n    return f/0.96875;\n}\n\n// 2D 6 octave FBM noise\nvec2 fbm6_2(vec2 p) {\n    return vec2( fbm6(p+vec2(9.2)), fbm6(p+vec2(5.7)) );\n}\n\n// Domain Warped Noise\nvec2 pattern( in vec2 p) {\n    return fbm6_2(p + 8.0 * fbm6_2(p + 8.0 * fbm6_2(p + vec2(sin(iTime / 2.0), cos(iTime / 2.0)))));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalised Screen coordinates\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Sample an offset using domain warped noise\n    vec2 coord = pattern(uv * 4.0);\n    \n    // Use that to make a displaced sample of the image\n    fragColor = texture(iChannel1, uv + 0.2 * (coord - 0.5));\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 23, 47, 47, 461], [516, 541, 561, 561, 866], [868, 893, 914, 914, 973], [975, 998, 1024, 1024, 1127], [1129, 1129, 1184, 1221, 1473]], "test": "untested"}
{"id": "WtBcDw", "name": "penombra explained", "author": "FabriceNeyret2", "description": "When a large source is partly hidden behind an occluder, the penombra intensity at a given location is the % of source surface visible from there. \nFor a disc source clamped at x, it is thus 1.- capsule(ang), with ang = 2.acos(x)\nred: smoothstep, for comp", "tags": ["tuto", "short", "solidangle", "penombra"], "likes": 6, "viewed": 356, "published": 3, "date": "1594471257", "time_retrieved": "2024-07-30T20:56:04.515325", "image_code": "            //           normalized so that radius = 1\n#define illu(x) ( d = clamp( 2.*(x-.7) ,-1.,1.),                   \\\n                  1. - ( acos( d ) -  d*sqrt(1.-d*d) ) / 3.1416    )\n          // compl( ( caps =  sector  -  triangle  )   % plain disc area )\n                      \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 10.*u/R.y,\n         F = 2.*fract(U)-1.,\n         I = floor(U),\n         A = abs(F+vec2(.1*I.x-.1,0));\n    O-=O;\n    float d;\n    int y = int(U.y);\n    O +=  y==8 ? .2+.8*smoothstep(30./R.y,0.,length(F)-.5) \n                   - step(max(A.x,A.y),.7)\n        : y==6 ? illu(.1*I.x-.1)\n        : y==4 ? illu(.1*U.x-.1)\n        : y<=3 ? 1. - R.y/5.* abs( U.y/3.-.2 - illu(.1*U.x-.1) )\n        : 0.;\n    \n    if (y<=3) O.r = max( O.r, 1. - R.y/5.* abs( U.y/3.-.2 - smoothstep(0.,1.,.5+.5*d) )), // for comparison\n              O.b = max( O.b, 1. - R.y/5.* abs( U.y/3.-.2 -  (.5+.5*d) ));\n    O = pow(O, vec4(1./2.2));  // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcDw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[291, 291, 329, 329, 998]], "test": "untested"}
{"id": "wl2yDW", "name": "Toothpick sequence", "author": "Roninkoi", "description": "Emulating the toothpick sequence described by [url]https://arxiv.org/abs/1004.3036[/url] using a cellular automaton. It's not 100% exact, but the large-scale structure appears the same. LMB to reset", "tags": ["cellular", "sequence", "automaton", "toothpick"], "likes": 3, "viewed": 318, "published": 3, "date": "1594467471", "time_retrieved": "2024-07-30T20:56:05.403949", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float s = min(iTime * 0.1 + 0.05, 0.9);\n    vec2 uv = (fragCoord/iResolution.xy * s + 0.5) - s / 2.;\n    \n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iMouse.z > 0.) {\n        fragColor = vec4(0.);\n        return;\n    }\n    \n    vec2 p = (fragCoord)/iResolution.xy;\n    vec2 pp = fragCoord - iResolution.xy * 0.5;\n    \n    vec2 n = clamp((fragCoord + vec2(0.0, 1.0))/iResolution.xy, 0., 1.);\n    vec2 s = clamp((fragCoord + vec2(0.0, -1.0))/iResolution.xy, 0., 1.);\n    vec2 w = clamp((fragCoord + vec2(-1.0, 0.0))/iResolution.xy, 0., 1.);\n    vec2 e = clamp((fragCoord + vec2(1.0, 0.0))/iResolution.xy, 0., 1.);\n    \n    vec4 nc = texture(iChannel0, n);\n    vec4 sc = texture(iChannel0, s);\n    vec4 wc = texture(iChannel0, w);\n    vec4 ec = texture(iChannel0, e);\n    \n    vec4 c = texture(iChannel0, p);\n    fragColor = c;\n    \n    float rn = 0.1;\n    float rs = 0.6;\n    float bw = 0.2;\n    float be = 0.8;\n    \n    float g = 0.8;\n    \n    if ((wc.g == g && sc.g == g) || (nc.g == g && ec.g == g) ||\n       (wc.g == g && nc.g == g) || (sc.g == g && ec.g == g))\n        return;\n    \n    if (floor(pp.x) == 0. && floor(pp.y) == 0.) {\n        fragColor = vec4(rs, g, bw, 1.0);\n        return;\n    }\n    if (floor(pp.x) == 1. && floor(pp.y) == 1.) {\n        fragColor = vec4(rn, g, be, 1.0);\n        return;\n    }\n    \n    if (nc.g == g && nc.r == rs) {\n        fragColor = vec4(rs, g, nc.b == bw ? be : bw, 1.0);\n        return;\n    }\n    if (ec.g == g && ec.b == bw) {\n        fragColor = vec4(ec.r == rs ? rn : rs, g, bw, 1.0);\n        return;\n    }\n    if (wc.g == g && wc.b == be) {\n        fragColor = vec4(wc.r == rs ? rn : rs, g, be, 1.0);\n        return;\n    }\n    if (sc.g == g && sc.r == rn) {\n        fragColor = vec4(rn, g, sc.b == bw ? be : bw, 1.0);\n        return;\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 207]], "test": "untested"}
{"id": "WlBcWw", "name": "Shader Redstone 3", "author": "saidwho12", "description": "Fixed the DX9 issue, if you're running on '--use-angle=gl' then comment out '#define DX9_FIX' in common tab. In both modes all the basic logic circuits work (AND, XOR, RS Latch, NOT, etc...).", "tags": ["game", "simulation", "sdf", "blur", "aliasing", "shadow", "antialiasing", "antialiasing", "minecraft", "alias", "anti", "circuit", "logic", "redstone"], "likes": 11, "viewed": 1200, "published": 3, "date": "1594462191", "time_retrieved": "2024-07-30T20:56:06.853075", "image_code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n    \n    \nbool isKeyPressed (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 0), 0).x);\n}\n\nbool isKeyReleased (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 1), 0).x);\n}\n\nbool isKeyEnabled (in int key) {\n    return bool(texelFetch(iChannel2, ivec2(key, 1), 0).x);\n}\n\n#define _ADDRESS A_ D_ D_ R_ E_ S_ S_\n#define _COORDINATES C_ O_ O_ R_ D_ I_ N_ A_ T_ E_ S_\n#define _TYPE T_ Y_ P_ E_\n#define _ENERGIZED E_ N_ E_ R_ G_ I_ Z_ E_ D_\n#define _ENERGY E_ N_ E_ R_ G_ Y_\n#define _Void V_ o_ i_ d_\n#define BROWNRED cur.rgb = vec3(.63,.5,.25);\n#define PURPLE cur.rgb = vec3(.725, .12, .4);\n#define BERRY cur.rgb = vec3(.9, .12, .5);\n#define DARKGREEN cur.rgb = vec3(.04, .34, .03);\n#define DARKGREY cur.rgb = vec3(.3);\n#define DARKBLUE cur.rgb = vec3(0,0,.86);\n\n// line function, used in k, v, w, x, y, z, 1, 2, 4, 7 and ,\n// rest is drawn using (stretched) circle(g)\n\n// todo: distance fields of s,S, J { and }\n// todo before we can show shaders :)\n// \n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n\tvec2 pa = p - a;\n\tvec2 ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h);\n}\n\n//These functions are re-used by multiple letters\nfloat _u(vec2 uv, float w, float v) {\n    return length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,-(.4-v)-uv.y) ))-w)\n               ,max(0.,uv.y-.4)));\n}\nfloat _i(vec2 uv) {\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.4)));\n}\nfloat _j(vec2 uv) {\n    uv.x+=.2;\n    uv.y+=.55;\n    float x = uv.x>0.&&uv.y<0.?\n                abs(length(uv)-.25)\n               :min(length(uv+vec2(0.,.25)),\n                    length(vec2(uv.x-.25,max(0.,abs(uv.y-.475)-.475))));\n    return x;\n}\nfloat _l(vec2 uv) {\n    uv.y -= .2;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.6)));\n}\nfloat _o(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.15)))-.25);\n}\n\n// Here is the alphabet\nfloat aa(vec2 uv) {\n    uv = -uv;\n    float x = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.2)-.2))));\n    return min(x,(uv.x<0.?uv.y<0.:atan(uv.x,uv.y+0.15)>2.)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254)));\n}\nfloat bb(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    return min(x,_l(uv));\n}\nfloat cc(vec2 uv) {\n    float x = _o(uv);\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.15)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.15))),//makes df right \n                        length(uv+vec2(-.22734,-.254)));\n}\nfloat dd(vec2 uv) {\n    uv.x *= -1.;\n    return bb(uv);\n}\nfloat ee(vec2 uv) {\n    float x = _o(uv);\n    return min(uv.x<0.||uv.y>.05||atan(uv.x,uv.y+0.15)>2.?x:length(vec2(uv.x-.22734,uv.y+.254)),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.05)));\n}\nfloat ff(vec2 uv) {\n    uv.x *= -1.;\n    uv.x += .05;\n    float x = _j(vec2(uv.x,-uv.y));\n    uv.y -= .4;\n    x = min(x,length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat gg(vec2 uv) {\n    float x = _o(uv);\n    return min(x,uv.x>0.||atan(uv.x,uv.y+.6)<-2.?\n               _u(uv,0.25,-0.2):\n               length(uv+vec2(.23,.7)));\n}\nfloat hh(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x += .25;\n    uv.y *= -1.;\n    return min(x,_l(uv));\n}\nfloat ii(vec2 uv) {\n    return min(_i(uv),length(vec2(uv.x,uv.y-.6)));\n}\nfloat jj(vec2 uv) {\n    uv.x+=.05;\n    return min(_j(uv),length(vec2(uv.x-.05,uv.y-.6)));\n}\nfloat kk(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.4));\n    x = min(x,line(uv,vec2(-.15,.0), vec2(0.25,-0.4)));\n    uv.x+=.25;\n    return min(x,_l(uv));\n}\nfloat ll(vec2 uv) {\n    return _l(uv);\n}\nfloat mm(vec2 uv) {\n    //uv.x *= 1.4;\n    uv.y *= -1.;\n    uv.x-=.175;\n    float x = _u(uv,.175,.175);\n    uv.x+=.35;\n    x = min(x,_u(uv,.175,.175));\n    uv.x+=.175;\n    return min(x,_i(uv));\n}\nfloat nn(vec2 uv) {\n    uv.y *= -1.;\n    float x = _u(uv,.25,.25);\n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat oo(vec2 uv) {\n    return _o(uv);\n}\nfloat pp(vec2 uv) {\n    float x = _o(uv);\n    uv.x += .25;\n    uv.y += .4;\n    return min(x,_l(uv));\n}\nfloat qq(vec2 uv) {\n    uv.x = -uv.x;\n    return pp(uv);\n}\nfloat rr(vec2 uv) {\n    uv.x -= .05;\n    float x =atan(uv.x,uv.y-0.15)<1.14&&uv.y>0.?_o(uv):length(vec2(uv.x-.22734,uv.y-.254));\n    \n    //)?_o(uv):length(vec2(uv.x-.22734,uv.y+.254))+.4);\n    \n    uv.x+=.25;\n    return min(x,_i(uv));\n}\nfloat ss(vec2 uv) {\n    if (uv.y <.225-uv.x*.5 && uv.x>0. || uv.y<-.225-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)-.05),uv.y-.2))-.2);\n    float b = length(vec2(uv.x-.231505,uv.y-.284));\n    float x = atan(uv.x-.05,uv.y-0.2)<1.14?a:b;\n    return x;\n}\nfloat tt(vec2 uv) {\n    uv.x *= -1.;\n    uv.y -= .4;\n    uv.x += .05;\n    float x = min(_j(uv),length(vec2(max(0.,abs(uv.x-.05)-.25),uv.y)));\n    return x;\n}\nfloat uu(vec2 uv) {\n    return _u(uv,.25,.25);\n}\nfloat vv(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.4), vec2(0.,-0.4));\n}\nfloat ww(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.4), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.1)));\n}\nfloat xx(vec2 uv) {\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.4));\n}\nfloat yy(vec2 uv) {\n    return min(line(uv,vec2(.0,-.2), vec2(-.3,0.4)),\n               line(uv,vec2(.3,.4), vec2(-.3,-0.8)));\n}\nfloat zz(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.4), vec2(-0.25,-0.4));\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.4));\n    return min(x,l);\n}\n\n// Capitals\nfloat AA(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                max(0.0,uv.y-.35) ))-0.25)\n               ,min(0.,uv.y+.4)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1) ));\n}\n\nfloat BB(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.25))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat CC(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    uv.y= abs(uv.y);\n    return uv.x<0.||atan(uv.x,uv.y-0.25)<1.14?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n}\nfloat DD(vec2 uv) {\n    uv.y -=.1;\n    //uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                max(0.0,abs(uv.y)-.25)))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5)) ));\n}\nfloat EE(vec2 uv) {\n    uv.y -=.1;\n    uv.y = abs(uv.y);\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat FF(vec2 uv) {\n    uv.y -=.1;\n    float x = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat GG(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y -= .1;\n    float a = atan(uv.x,max(0.,abs(uv.y)-0.25));\n    x = uv.x<0.||a<1.14 || a>3.?x:\n                    min(length(vec2(uv.x+.25,max(0.0,abs(uv.y)-.25))),//makes df right \n                        length(uv+vec2(-.22734,-.354)));\n    x = min(x,line(uv,vec2(.22734,-.1),vec2(.22734,-.354)));\n    return min(x,line(uv,vec2(.22734,-.1),vec2(.05,-.1)));\n}\nfloat HH(vec2 uv) {\n    uv.y -=.1;\n    uv.x = abs(uv.x);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y));\n    return min(x,length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))));\n}\nfloat II(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    uv.y = abs(uv.y);\n    return min(x,length(vec2(max(0.,abs(uv.x)-.1),uv.y-.5)));\n}\nfloat JJ(vec2 uv) {\n    uv.x += .125;\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,max(-uv.x,uv.y-.6))));\n    return min(x,length(vec2(max(0.,abs(uv.x-.125)-.125),uv.y-.6)));\n}\nfloat KK(vec2 uv) {\n    float x = line(uv,vec2(-.25,-.1), vec2(0.25,0.6));\n    x = min(x,line(uv,vec2(-.1, .1), vec2(0.25,-0.4)));\n//    uv.x+=.25;\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5))));\n}\nfloat LL(vec2 uv) {\n    uv.y -=.1;\n    float x = length(vec2(max(0.,abs(uv.x)-.2),uv.y+.5));\n    return min(x,length(vec2(uv.x+.2,max(0.,abs(uv.y)-.5))));\n}\nfloat MM(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.35,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.35,.5),vec2(.0,-.1)));\n    x = min(x,line(uv,vec2(.0,-.1),vec2(.35,.5)));\n    return min(x,length(vec2(uv.x+.35,max(0.,abs(uv.y)-.5))));\n}\nfloat NN(vec2 uv) {\n    uv.y-=.1;\n    float x = min(length(vec2(uv.x-.25,max(0.,abs(uv.y)-.5))),\n                  line(uv,vec2(-.25,.5),vec2(.25,-.5)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y)-.5))));\n}\nfloat OO(vec2 uv) {\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n}\nfloat PP(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    return min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n}\nfloat QQ(vec2 uv) {\n    float x = abs(length(vec2(uv.x,max(0.,abs(uv.y-.1)-.25)))-.25);\n    uv.y += .3;\n    uv.x -= .2;\n    return min(x,length(vec2(abs(uv.x+uv.y),max(0.,abs(uv.x-uv.y)-.2)))/sqrt(2.));\n}\nfloat RR(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(max(0.0,uv.x),\n                                 uv.y-.35))-0.25)\n               ,min(0.,uv.x+.25)));\n    x = min(x,length(vec2(uv.x+.25,max(0.,abs(uv.y-.1)-.5)) ));\n    return min(x,line(uv,vec2(0.0,0.1),vec2(0.25,-0.4)));\n}\nfloat SS(vec2 uv) {\n    uv.y -= .1;\n    if (uv.y <.275-uv.x*.5 && uv.x>0. || uv.y<-.275-uv.x*.5)\n        uv = -uv;\n    float a = abs(length(vec2(max(0.,abs(uv.x)),uv.y-.25))-.25);\n    float b = length(vec2(uv.x-.236,uv.y-.332));\n    float x = atan(uv.x-.05,uv.y-0.25)<1.14?a:b;\n    return x;\n}\nfloat TT(vec2 uv) {\n    uv.y -= .1;\n    float x = length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5)));\n}\nfloat UU(vec2 uv) {\n    float x = length(vec2(\n                abs(length(vec2(uv.x,\n                                min(0.0,uv.y+.15) ))-0.25)\n               ,max(0.,uv.y-.6)));\n    return x;\n}\nfloat VV(vec2 uv) {\n    uv.x=abs(uv.x);\n    return line(uv,vec2(0.25,0.6), vec2(0.,-0.4));\n}\nfloat WW(vec2 uv) {\n    uv.x=abs(uv.x);\n    return min(line(uv,vec2(0.3,0.6), vec2(.2,-0.4)),\n               line(uv,vec2(0.2,-0.4), vec2(0.,0.2)));\n}\nfloat XX(vec2 uv) {\n    uv.y -= .1;\n    uv=abs(uv);\n    return line(uv,vec2(0.,0.), vec2(.3,0.5));\n}\nfloat YY(vec2 uv) {\n    return min(min(line(uv,vec2(.0, .1), vec2(-.3, 0.6)),\n                   line(uv,vec2(.0, .1), vec2( .3, 0.6))),\n                   length(vec2(uv.x,max(0.,abs(uv.y+.15)-.25))));\n}\nfloat ZZ(vec2 uv) {\n    float l = line(uv,vec2(0.25,0.6), vec2(-0.25,-0.4));\n    uv.y-=.1;\n    uv.y=abs(uv.y);\n    float x = length(vec2(max(0.,abs(uv.x)-.25),uv.y-.5));\n    return min(x,l);\n}\n\n//Numbers\nfloat _11(vec2 uv) {\n    return min(min(\n             line(uv,vec2(-0.2,0.45),vec2(0.,0.6)),\n             length(vec2(uv.x,max(0.,abs(uv.y-.1)-.5)))),\n             length(vec2(max(0.,abs(uv.x)-.2),uv.y+.4)));\n             \n}\nfloat _22(vec2 uv) {\n    float x = min(line(uv,vec2(0.185,0.17),vec2(-.25,-.4)),\n                  length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4)));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-0.63)<1.64?abs(length(uv)-.275):\n               length(uv+vec2(.23,-.15)));\n}\nfloat _33(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return atan(uv.x,uv.y)>-1.?abs(length(uv)-.25):\n           min(length(uv+vec2(.211,-.134)),length(uv+vec2(.0,.25)));\n}\nfloat _44(vec2 uv) {\n    float x = min(length(vec2(uv.x-.15,max(0.,abs(uv.y-.1)-.5))),\n                  line(uv,vec2(0.15,0.6),vec2(-.25,-.1)));\n    return min(x,length(vec2(max(0.,abs(uv.x)-.25),uv.y+.1)));\n}\nfloat _55(vec2 uv) {\n    float b = min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n                  length(vec2(uv.x+.25,max(0.,abs(uv.y-.36)-.236))));\n    uv.y += 0.1;\n    uv.x += 0.05;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.0)))-.3);\n    return min(b,abs(atan(uv.x,uv.y)+1.57)<.86 && uv.x<0.?\n               length(uv+vec2(.2,.224))\n               :c);\n}\nfloat _66(vec2 uv) {\n    uv.y-=.075;\n    uv = -uv;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _77(vec2 uv) {\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y-.6)),\n               line(uv,vec2(-0.25,-0.39),vec2(0.25,0.6)));\n}\nfloat _88(vec2 uv) {\n    float l = length(vec2(max(0.,abs(uv.x)-.08),uv.y-.1+uv.x*.07));\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    uv.y-=.245;\n    return min(abs(length(uv)-.255),l);\n}\nfloat _99(vec2 uv) {\n    uv.y-=.125;\n    float b = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.275)))-.25);\n    uv.y-=.175;\n    float c = abs(length(vec2(uv.x,max(0.,abs(uv.y)-.05)))-.25);\n    return min(c,cos(atan(uv.x,uv.y+.45)+0.65)<0.||(uv.x>0.&& uv.y<0.)?b:\n               length(uv+vec2(0.2,0.6)));\n}\nfloat _00(vec2 uv) {\n    uv.y-=.1;\n    return abs(length(vec2(uv.x,max(0.,abs(uv.y)-.25)))-.25);\n}\n\n//Symbols\nfloat ddot(vec2 uv) {\n    uv.y+=.4;\n    return length(uv)*0.97;//-.03;\n}\nfloat comma(vec2 uv) {\n    return min(ddot(uv),line(uv,vec2(.031,-.405),vec2(-.029,-.52)));\n}\nfloat exclam(vec2 uv) {\n    return min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y-.2)-.4)))-uv.y*.06);\n}\nfloat question(vec2 uv) {\n    float x = min(ddot(uv),length(vec2(uv.x,max(0.,abs(uv.y+.035)-.1125))));\n    uv.y-=.35;\n    uv.x += 0.025;\n    return min(x,abs(atan(uv.x,uv.y)-1.05)<2.?abs(length(uv)-.275):\n               length(uv+vec2(.225,-.16))-.0);\n}\nfloat open1(vec2 uv) {\n    uv.x-=.62;\n    return abs(atan(uv.x,uv.y)+1.57)<1.?\n            abs(length(uv)-.8)\n           :length(vec2(uv.x+.435,abs(uv.y)-.672));\n}\nfloat close1(vec2 uv) {\n    uv.x = -uv.x;\n    return open1(uv);\n}\nfloat dotdot(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return length(uv);\n}\nfloat dotcomma(vec2 uv) {\n    uv.y -= .1;\n    float x = line(uv,vec2(.0,-.28),vec2(-.029,-.32));\n    uv.y = abs(uv.y);\n    uv.y-=.25;\n    return min(length(uv),x);\n}\nfloat eequal(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.15));\n}\nfloat aadd(vec2 uv) {\n    uv.y -= .1;\n    return min(length(vec2(max(0.,abs(uv.x)-.25),uv.y)),\n               length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ssub(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y-.1));\n}\nfloat mmul(vec2 uv) {\n    uv.y -= .1;\n    uv = abs(uv);\n    return min(line(uv,vec2(0.866*.25,0.5*.25),vec2(0.))\n              ,length(vec2(uv.x,max(0.,abs(uv.y)-.25))));\n}\nfloat ddiv(vec2 uv) {\n    return line(uv,vec2(-0.25,-0.4),vec2(0.25,0.6));\n}\nfloat lt(vec2 uv) {\n    uv.y-=.1;\n    uv.y = abs(uv.y);\n    return line(uv,vec2(0.25,0.25),vec2(-0.25,0.));\n}\nfloat gt(vec2 uv) {\n    uv.x=-uv.x;\n    return lt(uv);\n}\nfloat hash(vec2 uv) {\n    uv.y-=.1;\n    uv.x -= uv.y*.1;\n    uv = abs(uv);\n    return min(length(vec2(uv.x-.125,max(0.,abs(uv.y)-.3))),\n               length(vec2(max(0.,abs(uv.x)-.25),uv.y-.125)));\n}\nfloat and(vec2 uv) {\n    uv.y-=.44;\n    uv.x+=.05;\n    float x = abs(atan(uv.x,uv.y))<2.356?abs(length(uv)-.15):1.0;\n    x = min(x,line(uv,vec2(-0.106,-0.106),vec2(0.4,-0.712)));\n    x = min(x,line(uv,vec2( 0.106,-0.106),vec2(-0.116,-0.397)));\n    uv.x-=.025;\n    uv.y+=.54;\n    x = min(x,abs(atan(uv.x,uv.y)-.785)>1.57?abs(length(uv)-.2):1.0);\n    return min(x,line(uv,vec2( 0.141,-0.141),vec2( 0.377,0.177)));\n}\nfloat or(vec2 uv) {\n    uv.y -= .1;\n    return length(vec2(uv.x,max(0.,abs(uv.y)-.5)));\n}\nfloat und(vec2 uv) {\n    return length(vec2(max(0.,abs(uv.x)-.25),uv.y+.4));\n}\nfloat open2(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    return min(length(vec2(uv.x+.125,max(0.,abs(uv.y)-.5))),\n               length(vec2(max(0.,abs(uv.x)-.125),uv.y-.5)));\n}\nfloat close2(vec2 uv) {\n    uv.x=-uv.x;\n    return open2(uv);\n}\nfloat open3(vec2 uv) {\n    uv.y -= .1;\n    uv.y = abs(uv.y);\n    float x = length(vec2(\n                abs(length(vec2((uv.x*sign(uv.y-.25)-.2),\n                            max(0.0,abs(uv.y-.25)-.05) ))-0.2)\n               ,max(0.,abs(uv.x)-.2)));\n    return  x;\n    \n}\nfloat close3(vec2 uv) {\n    uv.x=-uv.x;\n    return open3(uv);\n}\n\nvec2 clc(vec2 uv, float cp, float w, float ital) {\n    return uv-vec2(cp-(w*.5)+uv.y*ital,0.);\n}\nbool hit(vec2 uv,inout float cp,float w, float px) {\n    return abs((cp+=w)-uv.x)<w+.2;\n}\n\n//Render char if it's up\n#define ch(l,w) if (hit(uv,cp,w,px)) { x=min(x,l(clc(uv,cp,w,ital))); us=cur;}\n\n//Render char always (no effects anymore)\n//#define ch(l,w) x = min(x,l(clc(uv,cp+=w,w,ital)));\n\n//Make it a bit easier to type text\n#define a_ ch(aa,0.7);\n#define b_ ch(bb,0.7);\n#define c_ ch(cc,0.7);\n#define d_ ch(dd,0.7);\n#define e_ ch(ee,0.7);\n#define f_ ch(ff,0.6);\n#define g_ ch(gg,0.7);\n#define h_ ch(hh,0.7);\n#define i_ ch(ii,0.3);\n#define j_ ch(jj,0.3);\n#define k_ ch(kk,0.7);\n#define l_ ch(ll,0.3);\n#define m_ ch(mm,0.9);\n#define n_ ch(nn,0.7);\n#define o_ ch(oo,0.7);\n#define p_ ch(pp,0.7);\n#define q_ ch(qq,0.7);\n#define r_ ch(rr,0.7);\n#define s_ ch(ss,0.7);\n#define t_ ch(tt,0.7);\n#define u_ ch(uu,0.7);\n#define v_ ch(vv,0.7);\n#define w_ ch(ww,0.9);\n#define x_ ch(xx,0.8);\n#define y_ ch(yy,0.8);\n#define z_ ch(zz,0.7);\n#define A_ ch(AA,0.7);\n#define B_ ch(BB,0.7);\n#define C_ ch(CC,0.7);\n#define D_ ch(DD,0.7);\n#define E_ ch(EE,0.7);\n#define F_ ch(FF,0.7);\n#define G_ ch(GG,0.7);\n#define H_ ch(HH,0.7);\n#define I_ ch(II,0.5);\n#define J_ ch(JJ,0.5);\n#define K_ ch(KK,0.7);\n#define L_ ch(LL,0.5);\n#define M_ ch(MM,0.9);\n#define N_ ch(NN,0.7);\n#define O_ ch(OO,0.7);\n#define P_ ch(PP,0.7);\n#define Q_ ch(QQ,0.7);\n#define R_ ch(RR,0.7);\n#define S_ ch(SS,0.7);\n#define T_ ch(TT,0.7);\n#define U_ ch(UU,0.7);\n#define V_ ch(VV,0.7);\n#define W_ ch(WW,0.9);\n#define X_ ch(XX,0.8);\n#define Y_ ch(YY,0.8);\n#define Z_ ch(ZZ,0.7);\n#define _1 ch(_11,0.7);\n#define _2 ch(_22,0.7);\n#define _3 ch(_33,0.7);\n#define _4 ch(_44,0.7);\n#define _5 ch(_55,0.7);\n#define _6 ch(_66,0.7);\n#define _7 ch(_77,0.7);\n#define _8 ch(_88,0.7);\n#define _9 ch(_99,0.7);\n#define _0 ch(_00,0.7);\n#define _dot ch(ddot,0.3);\n#define _comma ch(comma,0.3);\n#define _exclam ch(exclam,0.3);\n#define _question ch(question,0.8);\n#define _open1 ch(open1,0.7);\n#define _close1 ch(close1,0.7);\n#define _dotdot ch(dotdot,0.3);\n#define _dotcomma ch(dotcomma,0.3);\n#define _equal ch(eequal,0.7);\n#define _add ch(aadd,0.7);\n#define _sub ch(ssub,0.7);\n#define _mul ch(mmul,0.7);\n#define _div ch(ddiv,0.7);\n#define _lt ch(lt,0.7);\n#define _gt ch(gt,0.7);\n#define _hash ch(hash,0.7);\n#define _and ch(and,0.9);\n#define _or ch(or,0.3);\n#define _und ch(und,0.7);\n#define _open2 ch(open2,0.6);\n#define _close2 ch(close2,0.6);\n#define _open3 ch(open3,0.7);\n#define _close3 ch(close3,0.7);\n    \n//Space\n#define _ cp+=.5;\n\n//Markup\n#define BOLD cur.w = 1.5;\n#define NOBOLD cur.w = 0.0;\n#define ITAL ital = 0.15;\n#define NOITAL ital = 0.0;\n#define BLACK cur.rgb = vec3(0);\n#define WHITE cur.rgb = vec3(1);\n#define RED cur.rgb = vec3(1,0,0);\n#define GREEN cur.rgb = vec3(0,1,0);\n#define BLUE cur.rgb = vec3(0,0,1);\n#define ENERGIZED cur.rgb = getEnergyColor(MAX_REDSTONE_POWER);\n#define UNENERGIZED cur.rgb = getEnergyColor(0u);\n\n#define true_ t_ r_ u_ e_\n#define false_ f_ a_ l_ s_ e_\n\n//Next line\n#define crlf uv.y += 2.0; cp = 0.;\n\n\n#define HEX(X)\\\n{\\\n_0 x_;\\\n    for (uint I = 0u; I < 8u; ++I)\\\n    {\\\n        uint _X = (X >> ((7u - I) * 4u)) & 0xFu;\\\n        switch (_X)\\\n        {\\\n            case 0u: _0; break;\\\n            case 1u: _1; break;\\\n            case 2u: _2; break;\\\n            case 3u: _3; break;\\\n            case 4u: _4; break;\\\n            case 5u: _5; break;\\\n            case 6u: _6; break;\\\n            case 7u: _7; break;\\\n            case 8u: _8; break;\\\n            case 9u: _9; break;\\\n            case 10u: A_; break;\\\n            case 11u: B_; break;\\\n            case 12u: C_; break;\\\n            case 13u: D_; break;\\\n            case 14u: E_; break;\\\n            case 15u: F_; break;\\\n        }\\\n    }\\\n}\n\n#define DECIMAL(X)\\\n{\\\n    for (int I = 0; I < 4; ++I)\\\n    {\\\n    \tfloat Y = float(X) / (10. * exp(float(4 - I)));\\\n        switch (int(floor(Y)))\\\n        {\\\n            case 0: _0 break;\\\n            case 1: _1 break;\\\n            case 2: _2 break;\\\n            case 3: _3 break;\\\n            case 4: _4 break;\\\n            case 5: _5 break;\\\n            case 6: _6 break;\\\n            case 7: _7 break;\\\n            case 8: _8 break;\\\n            case 9: _9 break;\\\n        }\\\n    }\\\n}\n\nfloat segment(vec2 uv, float e, vec2 a, vec2 b)\n{         \n    b -= a;\n    uv -= a;\n    return smoothstep(0.0, e, \n                      length( uv - b * clamp(dot(b, uv) / dot(b, b), 0.0, 1.0)));\n}\n\nfloat segment_line(vec2 uv, float e, vec2 a, vec2 b) \n{\n    b -= a;\n    uv -= a;\n    vec2 d = normalize(b);\n    \n    float sd1 = smoothstep(e*0.1, 2.0*e, abs(dot(vec2(-d.y, d.x), uv)));\n    float sd2 = smoothstep(e*0.1, e, abs(dot(vec2(-d.y, d.x), uv)));\n    float t = min(step(0.0, dot(d, uv)), step(0.0, dot(d, b - uv)));\n    \n    float fo = clamp(0.0, 1.0, pow(length(uv - b*0.5)/(length(b)*4.0), 4.0));\n    \n \treturn mix(mix(0.8 + 0.2*sd2,1.0, fo) , sd1, t); \n}\n\nfloat point(vec2 uv, float e, vec2 p) \n{\n\treturn 0.4 + 0.6*smoothstep(1.5*e, 3.0*e, length(uv - p)); \n}\n\nfloat cpoint(vec2 uv, float e, vec2 p)\n{\n    const float s = 1.5;\n\treturn 0.4 + 0.6\n        * segment(uv, 1.5*e, p + e*vec2(s), p - e*vec2(s)) *\n          segment(uv, 1.5*e, p + e*vec2(s, -s), p - e*vec2(s, -s));\n}\n\nfloat bezier(vec2 uv, float e, vec2 b0, vec2 b1, vec2 b2)\n{   \n    // Nehab and Hoppe quadratic bezier distance aproximation.\n    // http://hhoppe.com/ravg.pdf\n    b0 -= uv;\n    b1 -= uv;\n    b2 -= uv;\n    \n    float a = determinant(mat2(b0, b2));\n    float b = 2.0 * determinant(mat2(b1, b0));\n    float d = 2.0 * determinant(mat2(b2, b1));\n    \n    float f = b*d - a*a;\n    vec2 d21 = b2 - b1;\n    vec2 d10 = b1 - b0;\n    vec2 d20 = b2 - b0;  \n    \n    vec2 gf = 2.0 * (b*d21 + d*d10 + a*d20);  \n    gf = vec2(gf.y, -gf.x);\n    \n    vec2 pp = -f*gf / dot(gf, gf);\n    vec2 d0p = b0 - pp;  \n    float ap = determinant(mat2(d0p, d20));\n    float bp = 2.0 * determinant(mat2(d10, d0p)); \n    float t = clamp((ap + bp) / (2.0*a + b + d), 0.0, 1.0);\n    \n    vec2 dist = vec2(length(mix(mix(b0, b1, t), mix(b1, b2, t), t)), length(pp));\n\n    float fo = clamp(0.0, 1.0, pow(length(b1)/(length(d20)*4.0), 4.0));\n    \n    return min(smoothstep(e*0.1, 2.0*e, dist.x), \n               \t\t\t  mix(0.8 + 0.2*smoothstep(e*0.1, e, dist.y), 1.0, fo));\n}\n\nfloat move_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tp = to;\n    return point(uv, e, to);\n}\n\nfloat line_to(inout vec2 p, vec2 to, vec2 uv, float e)\n{\n\tfloat d = segment_line(uv, e, p, to) * point(uv, e, to);\n    p = to;\n    return d;\n}\n\nfloat conic_to(inout vec2 p, vec2 c, vec2 to, vec2 uv, float e)\n{\n\tfloat d = bezier(uv, e, p, c, to) * cpoint(uv, e, c) * point(uv, e, to);\n    p = to;\n    return d;\n}\n\nfloat glyph(vec2 uv, float e) \n{\n    vec2 p = vec2(0.0);\n\n    float r = 1.0;\n    r = min(r, move_to(p, vec2(57, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -96), vec2(107, -39), uv, e) );\n    r = min(r, conic_to(p, vec2(158, 18), vec2(246, 43), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 100), vec2(156, 225), uv, e) );\n    r = min(r, conic_to(p, vec2(156, 321), vec2(219, 395), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 475), vec2(123, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(123, 727), vec2(219, 816), uv, e) );\n    r = min(r, conic_to(p, vec2(315, 905), vec2(455, 905), uv, e) );\n    r = min(r, conic_to(p, vec2(578, 905), vec2(672, 831), uv, e) );\n    r = min(r, conic_to(p, vec2(770, 927), vec2(889, 928), uv, e) );\n    r = min(r, conic_to(p, vec2(942, 928), vec2(967, 895), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 862), vec2(993, 827), uv, e) );\n    r = min(r, conic_to(p, vec2(993, 796), vec2(973, 781), uv, e) );\n    r = min(r, conic_to(p, vec2(954, 766), vec2(934, 766), uv, e) );\n    r = min(r, conic_to(p, vec2(909, 766), vec2(891, 782), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 799), vec2(874, 825), uv, e) );\n    r = min(r, conic_to(p, vec2(874, 868), vec2(907, 881), uv, e) );\n    r = min(r, conic_to(p, vec2(901, 883), vec2(887, 883), uv, e) );\n    r = min(r, conic_to(p, vec2(787, 883), vec2(702, 803), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 725), vec2(786, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(786, 483), vec2(690, 394), uv, e) );\n    r = min(r, conic_to(p, vec2(594, 305), vec2(455, 305), uv, e) );\n    r = min(r, conic_to(p, vec2(340, 305), vec2(252, 369), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 328), vec2(217, 272), uv, e) );\n    r = min(r, conic_to(p, vec2(217, 221), vec2(248, 181), uv, e) );\n    r = min(r, conic_to(p, vec2(279, 141), vec2(326, 135), uv, e) );\n    r = min(r, line_to(p, /*vec2(340, 133),*/ vec2(479, 133), uv, e) );\n    r = min(r, line_to(p, /*vec2(561, 133),*/ vec2(606, 131), uv, e) );\n    r = min(r, conic_to(p, vec2(651, 129), vec2(715, 115), uv, e) );\n    r = min(r, conic_to(p, vec2(780, 102), vec2(831, 76), uv, e) );\n    r = min(r, conic_to(p, vec2(964, 2), vec2(965, -158), uv, e) );\n    r = min(r, conic_to(p, vec2(965, -275), vec2(830, -348), uv, e) );\n    r = min(r, conic_to(p, vec2(696, -422), vec2(510, -422), uv, e) );\n    r = min(r, conic_to(p, vec2(322, -422), vec2(189, -347), uv, e) );\n    r = min(r, conic_to(p, vec2(57, -273), vec2(57, -162), uv, e) );\n    r = min(r, move_to(p, vec2(164, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -246), vec2(263, -310), uv, e) );\n    r = min(r, conic_to(p, vec2(362, -375), vec2(512, -375), uv, e) );\n    r = min(r, conic_to(p, vec2(659, -375), vec2(758, -311), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -248), vec2(858, -162), uv, e) );\n    r = min(r, conic_to(p, vec2(858, -101), vec2(823, -62), uv, e) );\n    r = min(r, conic_to(p, vec2(788, -23), vec2(716, -7), uv, e) );\n    r = min(r, conic_to(p, vec2(645, 8), vec2(595, 11), uv, e) );\n    r = min(r, line_to(p, /*vec2(545, 14),*/ vec2(453, 14), uv, e) );\n    r = min(r, line_to(p, vec2(332, 14), uv, e) );\n    r = min(r, conic_to(p, vec2(262, 10), vec2(213, -41), uv, e) );\n    r = min(r, conic_to(p, vec2(164, -92), vec2(164, -162), uv, e) );\n    r = min(r, move_to(p, vec2(276, 604), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 352), vec2(455, 352), uv, e) );\n    r = min(r, conic_to(p, vec2(545, 352), vec2(600, 434), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 489), vec2(633, 606), uv, e) );\n    r = min(r, conic_to(p, vec2(633, 858), vec2(455, 858), uv, e) );\n    r = min(r, conic_to(p, vec2(365, 858), vec2(309, 776), uv, e) );\n    r = min(r, conic_to(p, vec2(276, 721), vec2(276, 604), uv, e) );\n    \n\treturn r;    \n}\n\n\nconst float MENU_SCALE                 = .18;\nconst float MENU_MARGIN_Y              = .06;\nconst float ITEM_SELECTOR_SCALE        = .9;\nconst int ITEM_SELECTOR_PARTICLE_COUNT = 25;\n\nfloat getSelectorWave(void) { return .1+(sin(iTime*6.28)*.5+.5)*.7; }\n\nvec4\npaintMenuVoxel (in vec2 pos, in float invScale, in uint type)\n{\n    return drawVoxelTypeIcon(pos, invScale, type);\n}\n\nvec2\ngetParticlePos (in vec2 initialPos, in vec2 vel,\n                in float initialTime, in float lifeTime,\n                in float time)\n{\n    float t = mod(time - initialTime, lifeTime);\n\treturn initialPos + vel * t;// - waveAmp * sin(t * TAU * waveFreq) * normalize(vec2(-vel.y, vel.x));\n}\n\nfloat\ngetParticleAlpha (in float initialTime, in float lifeTime, in float time, in float falloff)\n{\n\treturn SATURATE(exp(-max(falloff, 0.) * mod(time - initialTime, lifeTime) / lifeTime));\n}\n/*\nvoid\npaintItem (inout vec4 ioColor, in vec2 iCoord, in uint iItemIndex)\n{\n    uint selectedItemIndex = uint(readVar(itemIndexLocation));\n \tbool isActive = selectedItemIndex == iItemIndex;   \n    \n    vec2 itemPos = vec2(float(TOP_PANEL_SIZE) * (float(iItemIndex) + .5) - .5 * float(TOP_PANEL_SIZE) * float(itemTypeList.length()),\n                        1. - .5 * float(TOP_PANEL_SIZE));\n\n    uint itemType = itemTypeList[iItemIndex];\n    \n    float itemBoxScale = float(ITEM_SELECTOR_SCALE) * float(TOP_PANEL_SIZE);\n    if (!isActive) itemBoxScale *= .75;\n  \t\n    //iPos -= itemPos;\n    //iPos /= itemBoxScale * .5;\n    \n    //invScale *= itemBoxScale * .5;\n    \n    //float t = sdBox(iPos, vec2(1.));\n    //float alpha = smoothstep(3., 0., t * invScale);\n    //float outlineAlpha = smoothstep(3., 0., (abs(t) - (isActive ? .015 : .0075)) * invScale);\n  \t\n    //vec4 itemColor = drawVoxelTypeIcon(iPos, invScale, itemType);\n    \n    //ioColor.rgb = mix(ioColor.rgb, itemColor.rgb, itemColor.a * alpha);\n    \n    //ioColor.rgb = mix(ioColor.rgb, getEnergyColor(isActive ? MAX_REDSTONE_POWER : 0u), outlineAlpha);\n\t/*\n    if (isActive)\n    {\n        for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n        {\n            float seed = float(itemIndex * REDSTONE_PARTICLE_COUNT + i * 4u);\n\n            float angle = hash11(seed++) * TAU;\n            float speed = .2 + hash11(seed++) * 1.5;\n            vec2 dir = vec2(sin(angle), cos(angle));\n            vec2 vel = dir * speed;\n            float lifeTime = .3 + .85  * hash11(seed++);\n            float initialTime = hash11(seed++) * lifeTime;\n\n            float radius = (.025 + hash11(seed++) * .02);\n\n            vec2 initialPos = dir;\n\n            vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n            float particleAlpha = getParticleAlpha(initialTime, lifeTime, iTime, 1.7);\n\n            float t = length(pos - particlePos) - radius;\n            float alpha = smoothstep(3., 0., t * invScale) * particleAlpha;\n            color.rgb = mix(color.rgb, getEnergyColor(MAX_REDSTONE_POWER), alpha);\n        }\n    }\n}\n\n*/\n\n// x: distance, y: bar index\nvec2 paintIcon0(in vec2 p)\n{\n    vec2 p0 = rotate(radians(-20.)) * vec2(p.x, abs(p.y));\n    float t0 = length(max(abs(p0.xy)-vec2(0,.95),0.0)) - .12;\n    p0 = rotate(radians(-20.)) * vec2(p.x - .5, abs(p.y));\n    float t1 = length(max(abs(p0.xy)-vec2(0,.95),0.0)) - .12;\n    \n    float t = min(t0, t1);\n    float i = t == t1 ? t == t0 ? 0.0 : 1.0 : -1.0;\n    \n\treturn vec2(t, i);\n}\n\n/*\n\nvoid Paint_Inventory0(inout vec4 ioColor, in vec2 pos)\n{\n    float ratio = float(PANEL0_SIZE) / float(INVENTORY0_CELL_SIZE);\n\tuint N = uint(floor(ratio));\n    \n    vec3 p = vec3(pos,1) / float(INVENTORY0_CELL_SIZE);\n    \n    vec2 pf = fract(p.xy);\n    vec2 pi = floor(p.xy);\n    \n    if (pi.x < float(N))\n    {\n    \tioColor.rg = pf;\n    }\n}\n\nvoid paintSidePanel(inout vec4 fragColor, in vec3 blurredColor, in vec2 coord, in float valOpen, in bool isOpen)\n{\n   \tvalOpen = SATURATE(valOpen);\n    float x_offset = valOpen * float(PANEL0_SIZE);\n    //coord.x -= x_offset;\n    \n    vec2 coord0 = coord - vec2(x_offset, 0);\n    \n    float energy = 0.;\n    float emissive = 0.;\n    \n    vec3 color = vec3(1);//vec3(.85 + .15 * sin(coord.x + coord.y));\n    \n#define TO_COORD_BTN0(v) (v - vec2(float(BUTTON0_SIZE_X)*.5, (iResolution.y - float(TOP_PANEL_SIZE))*.5))\n    \n    float t = min(coord0.x, sdBox(coord0 - vec2(0, (iResolution.y - float(TOP_PANEL_SIZE))*.5 ), vec2(1,.5)*vec2(BUTTON0_SIZE_X, BUTTON0_SIZE_Y)));\n    //t = max(t, coord.y - iResolution.y + float(TOP_PANEL_SIZE));\n    \n    float a = smoothstep(1., -1., t);\n    \n    float ao = (1.-.3*SATURATE(exp(-.5 * t)));\n    \n    float t1 = coord0.x + 8.;\n    float a1 = smoothstep(1.5, -1.5, t1);\n    float ao1 = 1. - .1 * SATURATE(exp(-.7*t1)) * (1.-a1);\n    \n    fragColor.rgb *= ao;\n    // GUI_TRANSLUCENCY * (1. - emissive)\n    //fragColor.rgb = mix(fragColor.rgb, mix(mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY * (1. - emissive)) * ao1, color, a1), a);\n    fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY * (1. - emissive)), a);\n    //fragColor.rgb = mix(fragColor.rgb, mix(blurredColor * ao, color, GUI_TRANSLUCENCY), a);\n\n\t{\n        vec2 mouseCoord = iMouse.xy - vec2(x_offset, 0);\n        // draw panel button\n        \n        vec2 c = TO_COORD_BTN0(coord0);\n        vec2 mc = TO_COORD_BTN0(mouseCoord);\n        \n#undef TO_LOCAL_POS\n        \n        vec3 p = vec3(c,1.) / (float(BUTTON0_SIZE_X)*.5);\n        vec2 m = mc / (float(BUTTON0_SIZE_X)*.5);\n        \n        if (isOpen)\n        {\n            p.x = -p.x;\n            m.x = -m.x;\n        }\n        \n        vec2 v0 = paintIcon0(p.xy);\n        vec2 v1 = paintIcon0(m);\n        \n        float emissive = smoothstep(1., -1., (v0.x) / p.z);\n        \n        float s = .5 + .5 * sin( PI_2 * (iTime - v0.y*.3) );\n        \n        bool isHot = all(greaterThan(m, vec2(-1))) && all(lessThan(m, vec2(1)));\n        bool isActive = true;//isKeyPressed(keyPrimaryAction);\n        \n        energy = (isHot?isActive?1.:.35:0.) * s;\n        vec3 col = vec3(.45);//getEnergyColor( energy );\n        \n        fragColor.rgb = mix(fragColor.rgb, col, emissive);\n    }\n\t\n    if ( isOpen )\n    {\n        //Paint_Inventory0(fragColor, coord);\n        \n    \t// Draw options\n        float value = fract(.2*iTime);\n       \t\n        const float SLIDER_HEIGHT = 20.;\n        const float SLIDER_HALF_WIDTH = float(PANEL0_SIZE) * .33;\n        const float SLIDER_HALF_HEIGHT = SLIDER_HEIGHT * .5;\n        \n        float R0 = SLIDER_HALF_HEIGHT * .8;\n        float R1 = R0 * .2;\n        float R2 = R0 * .25;\n        \n        vec2 sliderCoord = (coord - vec2(0, iResolution.y - float(TOP_PANEL_SIZE)) ) - vec2(PANEL0_SIZE, -SLIDER_HEIGHT-4.)*.5;\n        \n        float t0 = length(max(abs(sliderCoord)-vec2(SLIDER_HALF_WIDTH,0),0.)) - R1;//length(vec2(abs(sliderCoord.x)-SLIDER_HALF_WIDTH, sliderCoord.y))-R1*.25;\n        float a0 = smoothstep(1.5, -1.5, t0);\n        \n        vec2 sliderCoord0 = sliderCoord - vec2(-1.+2.*value,0) * SLIDER_HALF_WIDTH;\n        \n        float t1 = length(sliderCoord0)-R0;\n        float a1 = smoothstep(1.5, -1.5, t1);\n        \n        float t2 = length(sliderCoord0)-R2;\n        float a2 = smoothstep(1.5, -1.5, t2);\n        \n        float energy = float((sliderCoord.x + SLIDER_HALF_WIDTH) / (2.*SLIDER_HALF_WIDTH) < value);\n        \n        float ao0 = 1. - .4 * SATURATE(exp(-.95 * -t0)) * a0;\n        fragColor.rgb = mix(fragColor.rgb, getEnergyColor(energy), a0);\n        fragColor.rgb *= ao0;\n        \n        float ao1 = 1. - .4 * SATURATE(exp(-.95 * t1));\n        fragColor.rgb *= ao1;\n        fragColor.rgb = mix(fragColor.rgb, vec3(1), a1);\n        \n        float ao2 = 1. - .4 * SATURATE(exp(-.95 * -t2)) * a2;\n        //fragColor.rgb = mix(fragColor.rgb, getEnergyColor(value), a2);\n        //fragColor.rgb *= ao2;\n\t\t\n    }\n}\n\n*/\nfloat GaussianG(in float x, in float y, in float sigma )\n{\n    float sigma2 = sigma * sigma;\n    float x2 = x * x;\n    float y2 = y * y;\n\treturn 1./(PI_2*sigma2) * exp(-(x2+y2)/(sigma2+sigma2));\n}\n\nvec3 GaussianBlur(in vec2 co, in int dim, in float sigma, in float sep)\n{\n    vec3 c = vec3(0);\n    float z = 0.;\n    for (int i=-dim; i < dim; ++i)\n    {\n\t\tfor (int j=-dim; j < dim; ++j)\n        {\n\t\t\tfloat g = GaussianG(float(i), float(j), sigma);\n            vec2 p = (co + (vec2(i,j)+.5) * sep);\n            vec3 col;\n            \n            if ( all(greaterThanEqual(ivec2(p), ivec2(0)))\n                && all(lessThan(ivec2(p), ivec2(iResolution.xy))) )\n            {\n            \tcol = texture(iChannel1,  p / iResolution.xy).rgb;\n            }\n            else\n            {\n                col = vec3(1);\n            }\n            \n            c += g * col;\n            z += g;\n\t\t}\n\t}\n    return c/z;\n}\n\n/*\n\nvoid\npaintGui (inout vec4 fragColor, in vec3 blurredColor, in vec2 coord)\n{\n    // Panels rendering\n    float aspect = iResolution.x / iResolution.y;\n    float t1 = -(coord.y - (iResolution.y - float(.1)));\n    float s1 = smoothstep(1., -1., t1);\n    \n    vec4 topPanelColor = vec4(1);\n    \n    float valOpen = readVar(guiStatePtr).x;\n    bool isOpen = bool(valOpen);\n    paintSidePanel(fragColor, blurredColor, coord, valOpen, isOpen);\n    \n    float ao = (1.-.2*SATURATE(exp(-.6 * t1)));\n    fragColor.rgb *= ao;\n    fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, TRANSLUCENT_COLOR, GUI_TRANSLUCENCY), s1);\n\t    \n\t//paintCreeper(fragColor, coord - vec2(0, iResolution.y - float(TOP_PANEL_SIZE)), .65);\n    \n    \n    // Overlay info\n    if (false)\n    {\n       \t// Overlay text\n        float scale = 10.;\n        vec2 uv = coord / iResolution.y * iResolution.y / scale;\n        float px = 1. / iResolution.y * iResolution.y / scale;\n        \n        float x = 100.;\n        float cp = 0.;\n        vec4 cur = vec4(0,0,0,.01);\n        vec4 us = cur;\n        float ital = 0.0;\n\n        int lnr = int(floor(uv.y/2.));\n        uv.y = mod(uv.y,2.0)-1.0;\n        \n        if (lnr == 0)\n        {\n            ITAL DARKGREY W_ o_ r_ l_ d_ _ D_ i_ m_ _dotdot _;\n            BLACK _open1 _close1;\n\n            float weight = 0.05+cur.w*.02;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n            fragColor.rgb = mix(fragColor.rgb, us.rgb, smoothstep(weight+px, weight-px, x));\n        }\n    }\n}\n*/\n\nfloat SinFBM(in float x)\n{\n    float f = 0.0;\n    f += .5 * sin(x * PI);\n    f += .25 * sin((x - .333) * PI * 2.);\n    f += .125 * sin((x - .666) * PI * 4.);\n    f += .0625 * sin((x - 1.) * PI * 8.);\n    \n    return f;\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nvoid paintStartupCreeper(inout vec4 finalColor, in vec3 bgColor, in vec2 uv, float tAnim)\n{\n    vec3 p = vec3(uv, 1./iResolution.y);\n    \n    float tPanel = (p.y - 1.);\n    float aPanel = smoothstep(1.5, -1.5, tPanel / p.z);\n    float aoPanel = 1.0 - .25 * exp(-16. * max(tPanel,0.));\n    \n    const float margin = .525;\n    //vec3 p = vec3(uv, 1) / theme.menu_scale;\n    \n    //p = p * 2. - vec3(1,1,0);\n    p /= margin;\n    \n    const float STRIPE_W = 0.0807;\n    float invStr = p.z / STRIPE_W;\n    float xStr = (p.x + p.y) / STRIPE_W;\n    float yStr = (p.y - p.x) / STRIPE_W;\n    float tStripes = abs(mod(xStr + .115 + .195*sin(.615*yStr), 2.) - 1.) - .591;\n    \n    p = p * .5 + vec3(.5,.5,0.);\n    \n    p *= 6.;\n    \n    vec2 p0 = p.xy;\n    p0.x = -abs(p0.x - 3.) + 3.;\n    \n\tfloat t = min(abs(sdBox(p0 - vec2(1, 5), vec2(1))),\n                  sdBox(p0 - vec2(1.5), vec2(.5, 1.5)) );\n    \n    t = min(t, min(sdBox(p.xy - vec2(3,2), vec2(2,1)),\n                  sdBox(p.xy - vec2(3,2.5), vec2(1,1.5)) ));\n    \n    t = abs(t)-.364;\n    //t /= p.z;\n    float tEdge = t/p.z;\n    t = max(t / p.z, tStripes / invStr);\n    \n    float a = smoothstep(1.5, -1.5, t);\n    \n    vec3 mainColor = UI_BACKGROUND_COLOR.rgb;\n    mainColor = mix(mainColor, bgColor, a);\n    \n    //finalColor.rgb = mix(aoPanel * finalColor.rgb, mainColor, aPanel);\n   \n    //finalColor.rgb *= 1. - .425 * exp(.342 * min(t,0.)) *(.55+.45*texture(iChannel3,p.xy*.0981125).r)* a;\n    mainColor.rgb = mix(mainColor.rgb, vec3(.39515) + .7 * (1.-SATURATE(exp(-.152 * abs(tEdge)) )) , smoothstep(1.5,-1.5,abs(t)-3.25));\n    finalColor.rgb = mix(mainColor.rgb, finalColor.rgb, exp(-2.*(2.-clamp(tAnim,0.,2.))));\n}\n/*\nvoid Paint_Creeper(inout vec4 dest, in vec2 p, in float inverse_scale)\n{\n    bool is_hot = false;\n    bool is_active = is_hot && false;\n    \n    uv = rotate(radians(45.)) * p);\n    \n    float t0 = sdBox(p, vec2(.8));\n    float t = max(min(abs(uv.x), abs(uv.y)), t0)-.025;\n    \n    float a = smoothstep(1.5, 0., t * inverse_scale);\n    \n    vec4 color;\n    if (is_active)\n    {\n        color = theme.active_color;\n    }\n    else if (is_hot)\n    {\n     \tcolor = theme.hot_color;   \n    }\n    else\n    {\n        color = theme.inactive_color;\n    }\n    \n    dest = mix(dest, color, a); \n}\n\nvoid Paint_XButton(inout vec4 dest, in vec2 uv)\n{\n    bool is_hot = false;\n    bool is_active = is_hot && false;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    float button_scale = theme.menuSize;\n    \n    uv.x *= aspect;\n    uv = rotate(radians(45.)) * (uv - vec2(aspect,1) + button_scale * .5);\n    \n    float t0 = sdBox(uv, vec2(button_scale*.35));\n    float t = max(min(abs(uv.x), abs(uv.y)), t0) - .025*button_scale;\n    \n    float a = smoothstep(1.5, 0., t * iResolution.y);\n    \n    vec4 color;\n    if (is_active)\n    {\n        color = theme.active_color;\n    }\n    else if (is_hot)\n    {\n     \tcolor = theme.hot_color;   \n    }\n    else\n    {\n        color = theme.inactive_color;\n    }\n    \n    dest = mix(dest, color, a);\n}\n\nvoid paintMainButton(inout vec4 dest, in vec2 uv, in bool isOpen)\n{\n\tbool isHot = false;\n    bool isAlive = isHot && false;\n    \n    float aspect = iResolution.x / iResolution.y;\n    \n    float button_scale = theme.menuSize;\n    \n    float t = 1000.0;\n    \n    const int N = 3;\n    for (int i = 0; i < N; ++i)\n    {\n        vec2 uv0 = uv - vec2(0, 0.02 * button_scale);//(isOpen ? vec2(uv.x, 0.5*button_scale - uv.y) : uv) - vec2(0, 0.2*button_scale);\n        uv0.y += 0.7 * button_scale * ((float(i) + 0.5) / float(N));\n        uv0.x *= aspect;\n    \tuv0 = (uv0 - vec2(aspect,1) + button_scale * .5);\n        \n        uv0 = (isOpen ? vec2(uv0.x, 0.5*button_scale - uv0.y) : uv0) - vec2(0, 0.2*button_scale);\n\t    uv0 = rotate(radians(60.)) * vec2(abs(uv0.x), uv0.y);\n\n        float t0 = sdBox(uv0, vec2(button_scale*.35));\n    \tfloat t1 = max(abs(uv0.x), t0) - .025*button_scale;//max(min(abs(uv.x), abs(uv.y)), t0) - .025*button_scale;\n    \tt = min(t, t1);\n    }    \n    t *= iResolution.y;\n    \n    float a = smoothstep(1.5, 0.0, t);\n    //float ao = exp(-2.0 * t) * a;\n    \n    vec4 color = isAlive ? UI_ALIVE_COLOR : (isHot ? UI_HOT_COLOR : UI_DEAD_COLOR);\n    \n    //dest.rgb *= (1.0 - 0.9 * ao);\n    dest = mix(dest, color, a);\n}\n\n*/\n// pos is top left corner\n// size is bounds size\n// uv is normalized coordinates, starting from bottom left\n// value is slider value, from 0 to 1\nvoid paintSliderFloat(inout vec4 guiCol, in vec2 uv, in vec2 pos, in vec2 size, in float value)\n{\n    vec2 R = iResolution.xy;\n    float aspect = R.x / R.y;\n    uv.x *= aspect;\n    vec2 halfSize = 0.5 * size;\n    //float t = sdBox((uv - pos) - vec2(halfSize.x, -halfSize.y), halfSize);\n    vec2 centerPos = (uv - pos) - vec2(halfSize.x, -halfSize.y);\n    \n    const float W = 0.75;\n    \n    float t0 = (length( vec2(max(abs(centerPos.x) - W*halfSize.x, 0.0), centerPos.y) ) - 0.17*halfSize.y) * R.y;\n    float a0 = smoothstep(1.5, -1.5, t0);\n    \n    float t1 = (length( vec2((centerPos.x + W*halfSize.x) - W*size.x * value, centerPos.y) ) - 0.95*halfSize.y) * R.y;\n\tfloat a1 = smoothstep(1.5, -1.5, t1);\n    \n    float sliderAlpha = smoothstep(1.5, -1.5, ((centerPos.x + W*halfSize.x) - W*size.x * value) * R.y);\n    \n    vec4 sliderColor = sliderAlpha > 0.0 ? UI_ALIVE_COLOR : UI_DEAD_COLOR;\n    \n    float ao0 = clamp(exp(1.25 * t0), 0.0, 1.0) * a0;\n    guiCol.rgb *= (1.0 - 0.4 * ao0);\n    guiCol = mix(guiCol, sliderColor, a0);\n    \n    float ao1 = clamp(exp(-1.25 * t1), 0.0, 1.0) * (1.0-a1);\n    guiCol.rgb *= (1.0 - 0.4 * ao1);\n    guiCol = mix(guiCol, UI_ALIVE_COLOR, a1);\n    \n}\n\nvoid paintItemBar(inout vec4 finalColor, in vec3 bgColor, in vec4 mainColor, in vec2 coord)\n{\n    float aspect = iResolution.x / iResolution.y;\n    float halfAspect = 0.5 * aspect;\n    \n    vec2 uu = coord / iResolution.y;\n    \n    float halfHeight = 0.5 * ITEM_BOX_HEIGHT;\n    float halfWidth = 0.5 * float(ITEM_TYPE_COUNT) * ITEM_BOX_HEIGHT;\n    \n    vec2 halfItemBarSize = vec2(halfWidth, halfHeight);\n    \n    float tSelectionPanel = sdBox(uu - vec2(halfAspect, 0.1), halfItemBarSize);//abs(length(p)-0.8)-0.12;\n    float aSelectionPanel = smoothstep(1.5, -1.5,tSelectionPanel * iResolution.y);\n    finalColor.rgb *= 1. - .512*SATURATE(exp(-0.51*tSelectionPanel * iResolution.y));\n    \n    vec3 itemBarColor = mix(bgColor, mainColor.rgb, mainColor.a);\n    \n    vec2 itemUV = (uu - (vec2(halfAspect, 0.1) - halfItemBarSize)) / ITEM_BOX_HEIGHT;\n    int itemIndex = int(floor(itemUV.x));\n   \titemUV.x = fract(itemUV.x);\n    \n    finalColor.rgb = mix(finalColor.rgb, itemBarColor, aSelectionPanel);\n    int selectedItemIndex = int(readVar(SELECTED_ITEM_INDEX_ADDR)) % ITEM_TYPE_COUNT;\n    \n    if (itemIndex >= 0 && itemIndex < ITEM_TYPE_COUNT)\n    {\n        // Draw item into bar\n        vec2 itemP = itemUV * 2. - 1.;\n        \n        float invScale = iResolution.y * ITEM_BOX_HEIGHT;\n        float randAngle = UI_ENABLE_RANDOM_ITEM_ROT ? (.1*(hash11(float(itemIndex)+82.)*2.-1. ) * PI * .7) : 0.0;\n        \n        bool isChosen = selectedItemIndex == itemIndex;\n        \n        float itemBoxScale = DARK_ITEM_BOX_SIZE * (isChosen ? 1.0 : 0.8);\n        vec2 darkItemBoxP = rotate(randAngle) * itemP / itemBoxScale;\n        float darkItemBoxInvScale = invScale * itemBoxScale;\n        \n        float tDarkItemBox = sdBox(darkItemBoxP, vec2(1));\n        float aDarkItemBox = smoothstep(1.5, -1.5, tDarkItemBox*darkItemBoxInvScale );\n        float aEdgeItemBox = smoothstep(1.5, -1.5, (abs(tDarkItemBox)-.05)* darkItemBoxInvScale );\n        //float aoDarkItemBox = UI_ButtonAO( tDarkItemBox * darkItemBoxInvScale );\n        //finalColor.rgb *= aoDarkItemBox;\n        \n        finalColor.rgb = mix(finalColor.rgb, mix(bgColor, vec3(1), UI_ALPHA), aDarkItemBox);\n        \n        float itemScale = 1. - ITEM_BOX_Y_PADDING;\n        float invScale0 = darkItemBoxInvScale * itemScale;\n        vec2 itemP0 = darkItemBoxP / itemScale;\n        \n        vec4 menuVoxelColor = paintMenuVoxel(darkItemBoxP, darkItemBoxInvScale, ITEM_TYPE_ARRAY[itemIndex]);\n        float tItemBox = sdBox(darkItemBoxP, vec2(1));\n        float aItemBox = smoothstep(1.5, -1.5, tItemBox * darkItemBoxInvScale);\n        \n        finalColor.rgb = mix(finalColor.rgb, menuVoxelColor.rgb, menuVoxelColor.a * aDarkItemBox);\n        finalColor.rgb = mix(finalColor.rgb, vec3(0.25), aEdgeItemBox*.6);\n        //finalColor.rgb += .9 * illumItem * aDarkItemBox;\n        \n        if (isChosen)\n        {\n        \t// Draw item selector over everything\n            \n            #if 1\n            // Square shape for now\n            float tItemSelected = abs(tDarkItemBox)-.05;\n            float aItemSelected = smoothstep(3.,0.,tItemSelected * invScale);\n            float w = getSelectorWave();\n            finalColor.rgb = mix(finalColor.rgb, vec3(0,0,1), w * aItemSelected);\n            \n\t\t\t#else\n            // N-Gon selector (Hexagon by default)\n            \n            const float N = 5.;\n            float l = length(darkItemBoxP);\n            float a = atan(darkItemBoxP.y,darkItemBoxP.x)/TAU + .5;\n            a = ((fract(a * N)*2.-1.) / N)*.5*PI_2;\n\n            darkItemBoxP = vec2(cos(a), sin(a)) * l;\n            float tItemSelected = abs(darkItemBoxP.x-1.2)-.02;\n            float aItemSelected = smoothstep(3.,0.,tItemSelected * invScale);\n            finalColor.rgb = mix(finalColor.rgb, vec3(0,0,0), aItemSelected);\n            \n            #endif\n        }\n    }\n\n    float invScale = iResolution.y * ITEM_BOX_HEIGHT;\n    vec2 pos = (uu - (vec2(halfAspect, 0.1) - halfItemBarSize)) / ITEM_BOX_HEIGHT;\n    pos.x -= float(selectedItemIndex);\n    pos = pos*2.-1.;\n    \n    // Draw selector particles\n\tif(UI_ENABLE_REDSTONE_PARTICLES)\n    {\n        for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n        {\n            float seed = float(uint(selectedItemIndex) * REDSTONE_PARTICLE_COUNT + i * 8U);\n\n            float angle = hash11(seed++) * PI_2;\n            float speed = .4 + hash11(seed++) * 0.5;\n            vec2 dir = vec2(sin(angle), cos(angle)) * 0.9;\n            vec2 vel = dir * speed;\n            float lifeTime = .2 + 1.4  * hash11(seed++);\n            float initialTime = hash11(seed++) * lifeTime;\n\n            float radius = (.02 + hash11(seed++) * .05);\n\n            vec2 initialPos = dir;\n\n            vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n            float particleAlpha = getParticleAlpha(initialTime, lifeTime, iTime, 1.7);\n\n\n            float t = length(pos - particlePos) - radius;\n            float alpha = smoothstep(3., 0., t * invScale) * particleAlpha;\n            finalColor.rgb = mix(finalColor.rgb, vec3(.2), alpha);\n        }\n    }\n}\n\nvoid paintConfigButton(inout vec4 finalColor, in vec3 bgColor, in vec2 uu, in Button data)\n{\n    float invScale = iResolution.y * 2.;\n    float t = sdBox(uu - data.base.pos, data.base.scale);\n    float a = smoothstep(1.5, -1.5, t * invScale);\n    float ao = UI_ButtonAO(t * invScale);\n\tfinalColor.rgb = mix(finalColor.rgb * ao, mix(bgColor, UI_BACKGROUND_COLOR.rgb, UI_BACKGROUND_COLOR.a), a);\n    \n    // p inside button\n    vec2 p = (uu - data.base.pos) / data.base.scale;\n    float invScaleIcon = invScale * data.base.scale.y;\n    \n    if (t <= 0.)\n    {\n        const float R1 = 0.3, R2 = 0.6, R3 = 0.75;\n        const float N = 8.;\n        const float W = .15;\n\n        float l = length(p);\n        float angle = atan(p.y,p.x)/TAU + .5;\n        angle = ((fract(angle * N)*2.-1.) / N)*.5*PI_2;\n        vec2 pTeeth = vec2(cos(angle), sin(angle)) * l;\n\n        float tTeeth = max( length(p)-R3,  abs(pTeeth.y)-W );\n        float tIcon = max( min(length(p)-R2, tTeeth), -(length(p)-R1));\n\n    \t/*\n        const float N = 6.;\n        float l = length(darkItemBoxP);\n        float a = atan(darkItemBoxP.y,darkItemBoxP.x)/TAU + .5;\n        a = ((fract(a * N)*2.-1.) / N)*.5*PI_2;\n        */\n        float aIcon = smoothstep(1.5, -1.5, tIcon * invScaleIcon);\n\n        finalColor.rgb = mix(finalColor.rgb, vec3(0), aIcon);\n    }\n    \n}\n\nvoid paintUI(inout vec4 finalColor, in vec3 bgColor, in vec2 coord, in bool is_open)\n{\n    vec2 uv = coord / iResolution.xy;\n    vec2 p = (2.*coord - iResolution.xy) / iResolution.y;\n\n    float aspect = iResolution.x / iResolution.y;\n    // Fake UI reflections kinda based on Windows 7 Aero\n    vec2 uu = coord / iResolution.y;\n    //uu.y = 1.0 - uu.y;\n    float fakeReflX = mix(uu.x, uu.y, 0.3) - 3.2;\n    float fakeReflT0 = abs(fract(fakeReflX) * 2.0 - 1.0) - 0.5;\n    float fakeReflT1 = abs(fract(fakeReflX * 2.0 - 1.3) * 2.0 - 1.0) - 0.2;\n    float fakeReflT2 = abs(fract(fakeReflX * 8.0 - 3.7) * 2.0 - 1.0) - 0.1;\n    float fakeRefl = 0.2*smoothstep(64.0, 0.0, fakeReflT0 * iResolution.y) * pow(uv.y, 0.5)\n                   + 0.4*smoothstep(32.0, 0.0, fakeReflT1 * iResolution.y/4.0) * pow(uv.y, 0.8)\n                   + 0.4*smoothstep(24.0, 0.0, fakeReflT2 * iResolution.y/16.0 ) * pow(uv.y, 16.0);\n    \n    float t0 = sdBox(uu - vec2(0.1), vec2(0.07));//-(uv.y - 1.) - theme.menuSize;\n    //float t1 = -(t0 + theme.menu_band_scale);\n    \n    float a0 = smoothstep(3., 0., t0*iResolution.y);\n    \n    float a = false ? 1.0 : a0;\n\n    float w0 = SATURATE(exp(-2.5*abs(uv.x*2.-1.)));\n    //float menu_light = a1 * SATURATE(exp(2. * t0/theme.menu_band_scale)) * w0;\n    \n    vec4 mainColor = UI_BACKGROUND_COLOR;//vec4(mix(UI_BACKGROUND_COLOR.rgb, bg_color, UI_BACKGROUND_COLOR.a) + 0.5 * fakeRefl, 1.0);\n    //mainColor.rgb += 0.25 * fakeRefl;\n    //Paint_Creeper(main_color, uv);\n\n    \n    bool isOpen = false;//bool(fract(iTime)*2.0-1.0);\n    \n    //paintMainButton(mainColor, uv, isOpen);\n\t\n    if (isOpen)\n    {\n        paintSliderFloat(mainColor, uv, vec2(0, 1.0), vec2(0.4, 0.05), fract(iTime));\n        \n        //main_color = mix(main_color, theme.active_color, menu_light);\n\n        finalColor.rgb = mix(bgColor, mainColor.rgb, mainColor.a);\n    \t//float ao0 = 1. - .2 * SATURATE(exp(-60.*t0)) * w0 * (1.-a0);\n        //dest.rgb *= ao0;\n        //dest.rgb = mix(dest.rgb, vec3(0), pow(w0, 0.8) * smoothstep(1.5 / iResolution.y, 0.0, abs(t0)));\n        float s = 50.*64.;\n        float e = s/iResolution.x;\n        vec2 uv = coord * e;\n        uv -= vec2(0.34, 0.20)*s;\n        float alpha = 1.0-pow(glyph(uv, e)*0.8, 0.4545);\n        //dest = vec4(vec3(),1.0);\n        \n        finalColor.rgb = mix(finalColor.rgb, vec3(0), alpha * 0.25);\n        \n    }\n    else\n    {\n    \tpaintItemBar(finalColor, bgColor, mainColor, coord);\n        \n        //paintConfigButton(finalColor, bgColor, uu, UI_CONFIG_BUTTON);\n    \t//main_color = mix(main_color, theme.active_color, menu_light);\n    \t//float ao0 = 1. - SATURATE(exp(-0.95*t0 * iResolution.y));\n        //finalColor.rgb *= ao0;\n        \n        //bgColor = mix(bgColor, mainColor.rgb, mainColor.a);\n        \n        //finalColor.rgb = mix(finalColor.rgb, bgColor, a);\n        //dest.rgb = mix(dest.rgb, vec3(0), pow(w0, 0.8) * smoothstep(1.5 / iResolution.y, 0.0, abs(t0)));\n    }\n}\n\n\n\n\nfloat CURSOR_SIZE = 0.06;\nconst uint CURSOR_TEXT_SIZE = 8u;\n\nvoid\npaintCursor (inout vec4 dest, in vec3 bg_color, in uvec2 sCoord, in uvec2 sMouseCoord,\n             in uvec2 wCoord, in uvec2 wMouseCoord, in bool showBox )\n{\n    vec3 p = vec3(vec2(sCoord) - vec2(sMouseCoord), 1) / iResolution.y / CURSOR_SIZE;\n    p.xy = rotate(-radians(32.)) * p.xy;\n    //pos = pos * .5 + vec3(.5,.5,0);\n    \n    float t = (rotate(radians(65.)) * vec2(abs(p.x), p.y)).y;\n    t = max(t, -(p.y + .9));\n    //t = max(t, -(length(p.xy + vec2(0,1.5)) - .7));\n    \n    float t0 = length(p.xy)-.5;\n    \n    float alpha = smoothstep(1.5, -1.5, t / p.z * 2.);\n    vec3 color = getEnergyColor(cos(iTime * PI_2 * 4.) * .5 + .5);\n    \n    //ioColor.rgb *= 1. - .5 * pow(t, .2);\n    //fragColor.rgb *= 1.- .4 * exp(-25. * t / p.z) * (1.-alpha);\n    \n    vec3 invCol = Contrast(dest.rgb);\n    \n    dest.rgb = mix(dest.rgb, invCol, alpha*.86);\n    //ioColor.rgb *= 1. - .5 * smoothstep(1.5, 0., abs(t) / p.z);\n}\n\n\nvoid paintCursorSelectionInfo(inout vec4 finalColor, in vec3 bgColor, in uvec2 sCoord, in uvec2 sMouseCoord, in uvec2 wMouseCoord)\n{\n    vec4 mainColor = UI_BACKGROUND_COLOR;\n    \n    int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX).x);\n    \n    int selectedLayerIndex = layerIndex;\n    \n    int mode = int(readVar(VARIABLE_LOCATION_MODE).x);\n    if (mode == 0)\n    {\n        while (selectedLayerIndex > 0)\n        {\n            if (readVoxel(ivec3(wMouseCoord, selectedLayerIndex)).type != VOXEL_TYPE_VOID)\n                break;\n            --selectedLayerIndex;\n        }\n    }\n    \n    \n    Voxel voxel = readVoxel(ivec3(wMouseCoord, selectedLayerIndex));\n    \n    if (voxel.type != VOXEL_TYPE_VOID)\n    {\n        // Draw box\n        vec2 halfInfoScale = 0.5 * UI_INFO_BOX_SCALE;\n    \tvec2 uuv = vec2(ivec2(sCoord) - ivec2(sMouseCoord)) / iResolution.y;\n        float t = sdBox(uuv - vec2(halfInfoScale), vec2(halfInfoScale));\n        float a = smoothstep(1.5, -1.5, t * iResolution.y);\n        float ao = 1. - .4 * SATURATE(exp(-1.5*t * iResolution.y));\n        \n        finalColor.rgb *= ao;\n        //bgColor = mix(bgColor, mainColor.rgb, mainColor.a);\n        \n        finalColor.rgb = mix(finalColor.rgb, mix(bgColor, vec3(1), UI_ALPHA), a);\n        //finalColor.rgb = mix(finalColor.rgb, vec3(0.0), a);\n        \n        // Draw text info\n        \n        float scale = 1.;\n        float gly = 1. / UI_INFO_BOX_SCALE.x * 15.;\n        float boxPadding = 0.5;\n        vec2 uv = uuv * gly - boxPadding;\n        float px = gly / iResolution.y;\n\n        float x = 100.;\n        float cp = 0.;\n        vec4 cur = vec4(0,0,0,.01);\n        vec4 us = cur;\n        float ital = 0.0;\n\n        int lnr = int(floor(uv.y/2.));\n        uv.y = mod(uv.y,2.0)-0.5;\n        \n        if (lnr >= 0 && lnr <= 3 && voxel.type != VOXEL_TYPE_VOID)\n        {\n            //ITAL;\n\n            DARKGREY;\n            \n            if (lnr == 3)\n            {\n                // TODO: Add quotation marks\n                _TYPE _dotdot _ BLACK;\n                if (voxel.type == VOXEL_TYPE_VOID)\n                {\n                    V_ o_ i_ d_\n                }\n                else if (voxel.type == VOXEL_TYPE_STONE)\n                {\n                    S_ t_ o_ n_ e_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ D_ u_ s_ t_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ T_ o_ r_ c_ h_\n                }\n                else if (voxel.type == VOXEL_TYPE_LEVER)\n                {\n                    L_ e_ v_ e_ r_\n                }\n                else if (voxel.type == VOXEL_TYPE_BUTTON)\n                {\n                    B_ u_ t_ t_ o_ n_\n                }\n                else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP)\n                {\n                    R_ e_ d_ s_ t_ o_ n_ e_ _ L_ a_ m_ p_\n                }\n            }\n            else if (lnr == 2)\n            {\n                _ENERGIZED _dotdot _;\n\n                if (voxel.energy > 0u)\n                {\n                    ENERGIZED true_;\n                }\n                else\n                {\n                    UNENERGIZED false_;\n                }\n            }\n            else if (lnr == 1)\n            {\n                _ENERGY _dotdot _;\n\n                uint e = voxel.energy;\n\n                cur.rgb = getEnergyColor(e);\n                HEX(e)\n            }\n            else if (lnr == 0)\n            {\n                _ADDRESS _dotdot _;\n\n                int addr = getWorldVirtualToAddr(globalWorld, globalImage, ivec3(wMouseCoord, layerIndex));\n\n                BLACK;\n                HEX(uint(addr));\n                //BLACK ITAL _0 x_;\n            }\n\n            vec3 clr = vec3(0.0);\n\n            float weight = 0.04+cur.w*.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n            finalColor = mix(finalColor, vec4(us.rgb, 1.0), .8*smoothstep(weight+px, weight-px, x));\n        }\n        \n        //bgColor = mix(mainColor.rgb, bgColor, 1.0-mainColor.a);\n    }\n    \n/*\n    float boxPadding = 4.;\n    vec2 boxScale = vec2(scale * 5. * 1.5, scale * 5.);\n\n\n    vec2 uv = (uu - boxPadding - vec2(0,4.)) / iResolution.y * iResolution.y / scale;\n    float px = 1. / iResolution.y * iResolution.y / scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,.01);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    int lnr = int(floor(uv.y/2.));\n    uv.y = mod(uv.y,2.0)-1.0;\n\t*/\n    /*\n    uint layerIndex = uint(readVar(layerIndexLocation).x);\n    Voxel voxel = readVoxel(ivec3(wMouseCoord, layerIndex));\n\n    if (lnr >= 0 && lnr < 4 && voxel.type != VOXEL_TYPE_VOID)\n    {\n        //ITAL;\n\n        DARKGREY\n            if (lnr == 4)\n            {\n                _COORDINATES _dotdot;\n            }\n        else if (lnr == 3)\n        {\n            // TODO: Add quotation marks\n            _TYPE _dotdot _ BLACK;\n\n            if (voxel.type == VOXEL_TYPE_VOID)\n            {\n                _Void;\n            }\n            else if (voxel.type == VOXEL_TYPE_STONE)\n            {\n                _Stone;\n            }\n            else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n            {\n                _RedstoneDust;\n            }\n            else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n            {\n                _RedstoneTorch;\n            }\n        }\n        else if (lnr == 2)\n        {\n            _ENERGIZED _dotdot _;\n\n            if (voxel.energy > 0u)\n            {\n                ENERGIZED true_;\n            }\n            else\n            {\n                UNENERGIZED false_;\n            }\n        }\n        else if (lnr == 1)\n        {\n            _ENERGY _dotdot _;\n\n            uint e = voxel.energy;\n\n            cur.rgb = getEnergyColor(e);\n            HEX(e)\n                }\n        else if (lnr == 0)\n        {\n            _ADDRESS _dotdot _;\n\n            int addr = getWorldVirtualToAddr(globalWorld, globalImage, ivec3(wMouseCoord, layerIndex));\n\n            BLACK;\n            HEX(uint(addr));\n            //BLACK ITAL _0 x_;\n        }\n\n        vec3 clr = vec3(0.0);\n\n        float weight = 0.05+cur.w*.02;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        mainColor = mix(mainColor, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n\n    if (voxel.type != VOXEL_TYPE_VOID)\n    {\n        float t1 = sdBox(coord - boxScale - boxPadding - vec2(0,4.), boxScale + boxPadding);\n        float a = smoothstep(1., -1., t1);\n        bgColor = mix(mainColor.rgb, bgColor, 1.0-mainColor.a);\n        finalColor.rgb *= 1. - .2 * SATURATE(exp(-.6 * t1));\n        finalColor.rgb = mix(finalColor.rgb, bgColor, a);\n        //fragColor.rgb = mix(fragColor.rgb, mix(blurredColor, color, GUI_TRANSLUCENCY), smoothstep(1., -1., t1));\n    }*/\n}\n\nvoid paintModeText(inout vec4 col, in uvec2 coord, in vec3 bg)\n{   \n    vec2 uuv = vec2(coord) / iResolution.y;\n    //float H = 10.;\n    //float gly = 1. / H * 400.;\n    float scale = 3.2;\n    vec2 uv = /*uuv * gly - vec2(.5,gly-1.-.5)*/ vec2(coord.x, float(coord.y) - iResolution.y) / iResolution.x * 22.0 * scale + vec2(-.5,1.5);\n    float px = 22. / iResolution.x * scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    //int lnr = int(floor(uv.y/2.));\n    //uv.y = mod(uv.y,2.0)-0.5;\n\n    if (uv.y >= -1.0 && uv.y <= 1.0) {\n        BLACK M_ o_ d_ e_ _dotdot _\n        \n    \tint mode = int(readVar(VARIABLE_LOCATION_MODE));\n       \t\n        NOITAL DARKBLUE\n        switch (mode)\n        {\n            case MODE_LOWEST_NONVOID_Z:\n            \tL_ o_ w_ e_ s_ t_ _ N_ o_ n_ _sub V_ o_ i_ d_ _ Z_\n                break;\n            case MODE_CURRENT_Z:\n            \tC_ u_ r_ r_ e_ n_ t_ _ Z_\n            \tbreak;\n            \t\n        }\n\n        vec3 clr = vec3(0.0);\n\n        float weight = 0.008+cur.w*.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        col = mix(col, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n}\n\nvoid paintWorldDimText(inout vec4 col, in uvec2 coord, in vec3 bg)\n{   \n    vec2 uuv = vec2(coord) / iResolution.y;\n    //float H = 10.;\n    //float gly = 1. / H * 400.;\n    float scale = 3.2;\n    vec2 uv = /*uuv * gly - vec2(.5,gly-1.-.5)*/ vec2(coord) / iResolution.x * 22.0 * scale - vec2(.5,1.);\n    float px = 22. / iResolution.x * scale;\n\n    float x = 100.;\n    float cp = 0.;\n    vec4 cur = vec4(0,0,0,0.5);\n    vec4 us = cur;\n    float ital = 0.0;\n\n    //int lnr = int(floor(uv.y/2.));\n    //uv.y = mod(uv.y,2.0)-0.5;\n\n    if (uv.y >= -1.0 && uv.y <= 1.0) {\n        ITAL W_ o_ r_ l_ d_ _ D_ i_ m_ _dotdot _\n        \n    \tuvec3 virtualDim = uvec3(globalWorld.virtualDim);\n       \t\n        NOITAL /*DARKBLUE u_ v_ e_ c_ _3*/ BLACK _open3\n        \n\t\tfor (int i = 0; i < 3; ++i)\n        {\n            DARKGREEN\n            DECIMAL(x)\n            if (i != 2) { _ _ }\n            \n        }\n        \n        BLACK _ _close3\n       \n        vec3 clr = vec3(0.0);\n\n        float weight = 0.01+cur.w*0.05;//min(iTime*.02-.05,0.03);//+.03*length(sin(uv*6.+.3*iTime));//+0.02-0.06*cos(iTime*.4+1.);\n        col = mix(col, vec4(us.rgb, 1.0), smoothstep(weight+px, weight-px, x));\n    }\n    \n}\n\nmat2 rot (in float x)\n{\n\tfloat c = cos(x), s = sin(x);\n    return mat2(c, s, -s, c);\n}\n\nvoid\npaintGrid (inout vec4 fragColor,\n           in Camera cam,\n           in vec2 wPos, in float alpha01)\n{\n    alpha01 = SATURATE(alpha01);\n    float alpha = 0., time;\n    vec2 pos;\n    float zScale = getScaleZ(cam);\n    \n    for (uint q = 0u; q < WORDL_GRID_QUADRILLAGE_DEPTH; ++q)\n    {\n        float scale = pow(2., float(q));\n    \tpos = abs(fract(wPos / scale + .5) - .5);\n        time = min(pos.x, pos.y);\n        \n        float tmpAlpha = pow((float(q) + 1.5) / float(WORDL_GRID_QUADRILLAGE_DEPTH), 1.5);\n        \n        alpha = max(alpha, tmpAlpha * smoothstep(3./iResolution.y, 0., time * zScale * scale));\n    }\n    \n    fragColor.rgb *= 1. - alpha01 * alpha;\n}\n\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1);\n    initializeAPI(fragCoord);\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    \n    uvec2 sMouseCoord = uvec2(floor(iMouse.xy));\n    uvec2 sCoord = uvec2(floor(fragCoord));\n    \n    vec2 res = iResolution.xy, sPos = (2.*fragCoord - res) / res.y,\n         sMousePos = (2.*iMouse.xy - res) / res.y;\n    \n    vec2 uv = fragCoord / res;\n    \n    mat3 MVP = getWorldToScreen( cam );\n    vec2 wPos = vec2(MVP * vec3(sPos, 1));\n    vec2 wMousePos = vec2(MVP * vec3(sMousePos, 1));\n\tuvec2 wCoord = uvec2(floor(wPos));\n    uvec2 wMouseCoord = uvec2(floor(wMousePos));\n    \n    float scaleZ = getScaleZ( cam );\n    float inverseScale = scaleZ * res.y;\n\n    fragColor.rgb = texture(iChannel1, uv).rgb;\n    \n    if(ENABLE_WORLD_GRID)\n    {\n        paintGrid(fragColor, cam, wPos, /*.25 * min(pow(SATURATE(scaleZ) * 3.25, 1.5), 1.0)*/ .15 );\n    }\n    \n    {\n        vec2 wSize = vec2(getWorld().virtualDim.xy);\n    \tfloat t = sdBox(wPos - wSize*.5, wSize * .5);\n        float alpha = smoothstep(-.25, .25, t);\n        \n        //fragColor.rgb *= 1. - .125 * alpha;\n        fragColor.rgb *= 1. - .3 * smoothstep(3.0, 0.0, -t * inverseScale);\n    }\n    \n    {\n\t    vec2 p = vec2(wMouseCoord) + .5;\n        float t1 = sdBox(wPos - p, vec2(.5));\n        float t2 = abs(t1);\n        float a1 = smoothstep(3., 0., t1 * inverseScale);\n        float a2 = smoothstep(3., 0., t2 * inverseScale);\n        \n        //float w = .1+(sin(3.*iTime*6.28)*.5+.5)*.1;\n        float w = getSelectorWave();\n        \n        //fragColor.rgb *= 1. - .05*w * a1;\n        //fragColor.rgb *= 1. - w * a1;\n        fragColor.rgb *= 1. - a2 * w;\n    }\n    \n    vec3 bgColor = vec3(0,0,0);\n    if (UI_ENABLE_BLUR)\n    {\n    \tbgColor = GaussianBlur(fragCoord, 4, 10.0, 2.0);\n        //bgColor = fragColor.rgb;//mix(fragColor.rgb, vec3(1), UI_ALPHA);\n    }\n    else\n    {\n     \tbgColor =    vec3(1,1,1);//texture(iChannel1, uv).rgb;\n    }\n    \n    paintUI(fragColor, bgColor, fragCoord, true);\n    //bgColor = fragColor.rgb;//1ix(fragColor.rgb, vec3(1), UI_ALPHA);\n    paintCursor(fragColor, bgColor, sCoord, sMouseCoord, wCoord, wMouseCoord, true);\n    //bgColor = fragColor.rgb;\n    paintCursorSelectionInfo(fragColor, bgColor, sCoord, sMouseCoord, wMouseCoord);\n    paintModeText(fragColor, sCoord, bgColor);\n    //paintWorldDimText(fragColor, sCoord, bgColor);\n    \n    #if 1\n    vec2 p = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    \n    float tStartupAnim = max(iTime - 2.,0.);\n    \n    if (tStartupAnim <= 4.0) // 2.0 the distance on y to travel, plus some for the AO\n    {\n    \tpaintStartupCreeper(fragColor, bgColor, p, tStartupAnim);\n    }\n    #endif\n    \n    if (ENABLE_VIGNETTE)\n    {\n        // From IQ's \"Mike\"\n    \tfragColor.rgb *= 0.2 + 0.8 * pow( clamp(16.0 * uv.x * uv.y * (1.0-uv.x) * (1.0-uv.y),0.,1.), 0.05 );\n    }\n    \n    float gamma = 1.1;\n    fragColor.rgb = pow(fragColor.rgb, vec3(1.0 / gamma));\n    //fragColor = vec4(Contrast(vec3(uv.x), 2.));\n\t//fragColor = texture(iChannel0, fragCoord/res);\n}\n", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n\nbool isWindowResized (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    return (all(equal(pos, ivec2(VARIABLE_LOCATION_RESOLUTION, 0)))\n        && !any(equal(readVar(VARIABLE_LOCATION_RESOLUTION).xy, iResolution.xy))\n       );\n}\n\nbool isKeyPressed (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 0), 0).x);\n}\n\nbool isKeyReleased (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 1), 0).x);\n}\n\nbool isKeyEnabled (in int key) {\n    return bool(texelFetch(iChannel1, ivec2(key, 2), 0).x);\n}\n\nCamera\ngetDefaultCamera (in float zOffset)\n{\n    Camera cam;\n    cam.pos = vec3(vec2(globalWorld.virtualDim.xy) * .5, zOffset);\n    \n    return cam;\n}\n\nvoid\ninitializeChannel (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    if (pos.y == 0)    \n    {\n        Camera cam = getDefaultCamera(1.75);\n        writeCamera(VARIABLE_LOCATION_CAMERA, cam);\n        \n        vec2 resolution = iResolution.xy;\n        writeVar(VARIABLE_LOCATION_RESOLUTION, resolution);\n        \n        writeVar(VARIABLE_LOCATION_LAYER_INDEX, 0.);\n    }\n    if (isInsideWorldReal(getWorld(), pos))\n    {\n        Voxel voxel = getDefaultVoxel(VOXEL_TYPE_VOID);\n        writeVoxel(voxel);\n    }\n}\n\nuint maxPowerFromCoord (in ivec3 coord, in bool isAboveOpaque)\n{\n    uint maxPower = 0u;\n    \n    Voxel voxel = readVoxel(coord);\n\tif (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        maxPower = max(maxPower, voxel.energy);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST\n             && voxel.energy > 0u)\n    {\n        maxPower = max(maxPower, voxel.energy - 1u);\n    }\n    else if (voxel.type == VOXEL_TYPE_VOID)\n    {\n        Voxel voxelMinusZ = readVoxel(coord + ivec3(0,0,-1)),\n            voxelPlusZ = readVoxel(coord + ivec3(0,0,1));\n        \n        if (voxelMinusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelMinusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelMinusZ.energy - 1u);\n        }\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelPlusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy - 1u);\n        }\n    }\n    else if (voxel.type == VOXEL_TYPE_STONE && !isAboveOpaque)\n    {\n    \tVoxel voxelPlusZ = readVoxel(coord + ivec3(0,0,1));\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST\n            && voxelPlusZ.energy > 0u)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy - 1u);\n        }\n    }\n    \n    return maxPower;\n}\n\nconst uint MAX_PATHFINDER_STEPS = MAX_REDSTONE_POWER;\nconst uint MAX_NODE_COUNT = 50u;\n\n#define size_t uint\n\nbool isEnergizedTorch (in Voxel voxel)\n{\n\treturn voxel.type == VOXEL_TYPE_REDSTONE_TORCH && voxel.energy > 0u;\n}\n\nbool isEnergized (in Voxel voxel)\n{\n\treturn (voxel.type == VOXEL_TYPE_REDSTONE_TORCH\n        || voxel.type == VOXEL_TYPE_REDSTONE_DUST) && voxel.energy > 0u;\n}\n\nbool isEnergizedAt (in ivec3 coord)\n{\n\treturn isEnergized(readVoxel(coord));\n}\n\nstruct Node\n{\n    uvec3 key;\n  \tuint value;\n};\n    \nconst uint NODE_STATE_NEW    = 0u;\nconst uint NODE_STATE_OPEN   = 1u;\nconst uint NODE_STATE_CLOSED = 2u;\n    \nuint hash (in uvec3 key)\n{\n\treturn uint(hash13(key) * 43454.7678) % MAX_NODE_COUNT;\n}\n\nstruct Hashtable\n{\n\tNode data [MAX_NODE_COUNT];\n    size_t size;\n};\n    \nvoid hashtable_init (inout Hashtable thiz)\n{\n    thiz.size = MAX_NODE_COUNT;\n\tfor (uint i = 0u; i < thiz.size; ++i)\n    {\n       thiz.data[i].key = uvec3(0);\n       thiz.data[i].value = NODE_STATE_NEW;\n    }\n}\n\nvoid hashtable_insert (inout Hashtable thiz, in Node node)\n{\n    uint index = hash(node.key);\n    \n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        index = (index + 1u) % MAX_NODE_COUNT;\n    }\n    \n    thiz.data[index] = node;\n}\n\nbool hashtable_get (inout Hashtable thiz, in uvec3 key, inout Node node)\n{\n    uint index = hash(key);\n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        if (all(equal(key, thiz.data[index].key)))\n        {\n            node = thiz.data[index];\n            return true;\n        }\n        else\n        {\n            index = (index + 1u) % MAX_NODE_COUNT;\n        }\n    }\n    return false;\n}\n\nbool hashtable_delete (inout Hashtable thiz, in uvec3 key)\n{\n\tuint index = hash(key);\n   \n\tNode node;\n    while (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        if (all(equal(key, thiz.data[index].key)))\n        {\n            break;\n        }\n        else\n        {\n            index = (index + 1u) % MAX_NODE_COUNT;\n        }\n    }\n    \n    if (thiz.data[index].value != NODE_STATE_NEW)\n    {\n        return false;\n    }\n    \n    thiz.data[index].value = NODE_STATE_NEW;\n    for (index = (index + 1u) % MAX_NODE_COUNT;\n         thiz.data[index].value != NODE_STATE_NEW;\n         index = (index + 1u) % MAX_NODE_COUNT)\n    {\n        node = thiz.data[index];\n        thiz.data[index].value = NODE_STATE_NEW;\n        hashtable_insert(thiz, node);\n    }\n    \n    return true;\n}\n\nNode hashtable_get (inout Hashtable thiz, in uint index)\n{\n\treturn thiz.data[int(index)];\n}\n\n#define Vector(T, N) struct { T data[N]; size_t size; }\n#define vector_init(_this) { _this.size = 0u; }\n\n#define vector_push(_this, _item)\\\nif (_this.size < size_t(_this.data.length()))\\\n{\\\n    _this.size ++; _this.data[_this.size - 1u] = _item;\\\n}\n\n#define vector_pop_at(_this, _index)\\\nif (_index < _this.size)\\\n{\\\n    for (size_t i_ = 0U; i_ < _this.size - 1u; ++i_)\\\n    {\\\n        if (i_ >= _index)\\\n        _this.data[i_] = _this.data[i_ + 1u];\\\n    }\\\n \t--_this.size;\\\n}\n\n/*\n#define vector_pop_at(_this, _index)\\\nif (_index < _this.size)\\\n{\\\n    size_t i_ = _index;\\\n    while (true)\\\n    {\\\n        if (i_ >= _this.size) break;\\\n        _this.data[i_] = _this.data[i_ + 1u];\\\n        ++i_;\\\n    }\\\n \t--_this.size;\\\n}\n*/\nbool pathfind (in ivec3 coord, inout uint pathLength)\n{\n    Vector(ivec3, 16u) openCoords;\n    Vector(ivec3, 32u) closedCoords;\n    vector_init(openCoords);\n    vector_push(openCoords, coord);\n    vector_init(closedCoords);\n    \n    ivec3 coordList[12];\n#define IS_COORD_BELOW(x) ((x) < 4U)\n#define IS_COORD_LEVEL(x) ((x) > 3U && (x) < 8U)\n#define IS_COORD_ABOVE(x) ((x) > 7U)\n\n    bool isClosedList[12];\n    bool isOpenList[12];\n    \n    for (uint i = 0u; i < MAX_REDSTONE_POWER; ++i)\n    {\n        pathLength = i;\n        for (size_t _j = openCoords.size, j = _j - 1u; _j > 0u; j = --_j - 1u)\n        {\n            /*\n    \t\tisClosedList = isOpenList\n                = bool[12](false, false, false, false, false, false, false, false, false, false, false, false);\n            */\n            isClosedList[0] = isOpenList[0] = false;\n            isClosedList[1] = isOpenList[1] = false;\n            isClosedList[2] = isOpenList[2] = false;\n            isClosedList[3] = isOpenList[3] = false;\n            isClosedList[4] = isOpenList[4] = false;\n            isClosedList[5] = isOpenList[5] = false;\n            isClosedList[6] = isOpenList[6] = false;\n            isClosedList[7] = isOpenList[7] = false;\n            isClosedList[8] = isOpenList[8] = false;\n            isClosedList[9] = isOpenList[9] = false;\n            isClosedList[10] = isOpenList[10] = false;\n            isClosedList[11] = isOpenList[11] = false;\n            \n            coordList[0]  = openCoords.data[j] + ivec3(-1,0,-1);\n            coordList[1]  = openCoords.data[j] + ivec3(1,0,-1);\n            coordList[2]  = openCoords.data[j] + ivec3(0,-1,-1);\n            coordList[3]  = openCoords.data[j] + ivec3(0,1,-1);\n            \n            coordList[4]  = openCoords.data[j] + ivec3(-1,0,0);\n            coordList[5]  = openCoords.data[j] + ivec3(1,0,0);\n            coordList[6]  = openCoords.data[j] + ivec3(0,-1,0);\n            coordList[7]  = openCoords.data[j] + ivec3(0,1,0);\n            \n            coordList[8]  = openCoords.data[j] + ivec3(-1,0,1);\n            coordList[9]  = openCoords.data[j] + ivec3(1,0,1);\n            coordList[10] = openCoords.data[j] + ivec3(0,-1,1);\n            coordList[11] = openCoords.data[j] + ivec3(0,1,1);\n            \n            for (size_t _k = closedCoords.size, k = _k - 1u; _k > 0u; k = --_k - 1u)\n            {\n                for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n                {\n                    ivec3 voxelCoord = coordList[voxelIdx];\n                    if (!isClosedList[voxelIdx] && isInsideWorldVirtual(globalWorld, voxelCoord))\n                    {\n                        isClosedList[voxelIdx] = all(equal( closedCoords.data[k], voxelCoord ));\n                    }\n                }\n            }\n            \n            for (size_t _k = openCoords.size, k = _k - 1u; _k > 0u; k = --_k - 1u)\n            {\n                if (i != j)\n                {\n                    for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n                    {\n                    \tivec3 voxelCoord = coordList[voxelIdx];\n                    \tif (!isOpenList[voxelIdx] && isInsideWorldVirtual(globalWorld, voxelCoord))\n                        {\n                            isOpenList[voxelIdx] = all(equal( openCoords.data[k], coordList[voxelIdx] ));\n                        }\n                    }\n                }\n            }\n            \n            // Actual spread code\n            for (size_t voxelIdx = 0U; voxelIdx < size_t(coordList.length()); ++voxelIdx)\n            {\n                ivec3 currCoord = coordList[voxelIdx];\n                Voxel currVoxel = readVoxel(currCoord);\n                if (!isOpenList[voxelIdx] && !isClosedList[voxelIdx] && isInsideWorldVirtual(globalWorld, currCoord))\n                {\n                    if (isEnergizedTorch(currVoxel) && IS_COORD_LEVEL(voxelIdx))\n                    {\n                        return true;\n                    }\n                    else if (currVoxel.type == VOXEL_TYPE_REDSTONE_DUST)\n                    {\n                        if (IS_COORD_BELOW(voxelIdx))\n                        {\n                            // Check if opaque block is blocking the energy\n                            Voxel aboveVoxel = readVoxel(currCoord + ivec3(0,0,1));\n                            if (!isVoxelOpaque(aboveVoxel))\n                            {\n                        \t\tvector_push(openCoords, currCoord);\n                            }\n                        }\n                        else if (IS_COORD_ABOVE(voxelIdx))\n                        {\n                        \t// Check if opaque block is blocking the energy\n                            Voxel aboveVoxel = readVoxel(openCoords.data[j] + ivec3(0,0,1));\n                            if (!isVoxelOpaque(aboveVoxel))\n                            {\n                        \t\tvector_push(openCoords, currCoord);\n                            }\n                        }\n                        else\n                        {\n                        \tvector_push(openCoords, currCoord);\n                        }\n                    }\n                }\n            }\n            \n            vector_push(closedCoords, openCoords.data[j]);\n            vector_pop_at(openCoords, j);\n        }\n    }\n    \n    return false;\n}\n\n// DirectX 9 ANGLE fix for force unroll loop issue\nvoid calculateEnergyDirectX9(inout Voxel voxel, in ivec3 worldCoord)\n{\n    uint maxTorchEnergy = 0U;\n    uint maxDustEnergy = 0U;\n\n    // Voxels on the same level\n    Voxel levelVoxels[4] = Voxel[4](\n        readVoxel(worldCoord + ivec3(-1, 0, 0)),\n        readVoxel(worldCoord + ivec3(1,  0, 0)),\n        readVoxel(worldCoord + ivec3(0,  1, 0)),\n        readVoxel(worldCoord + ivec3(0, -1, 0))\n    );\n\n    for (int i = 0; i < levelVoxels.length(); ++i)\n    {\n        if (levelVoxels[i].energy > 0U)\n        {\n            switch (levelVoxels[i].type)\n            {\n                case VOXEL_TYPE_REDSTONE_DUST:\n                maxDustEnergy = max(maxDustEnergy, levelVoxels[i].energy - 1U);\n                break;\n\n                case VOXEL_TYPE_REDSTONE_TORCH:\n                maxTorchEnergy = max(maxTorchEnergy, levelVoxels[i].energy);\n                break;\n            }\n        }\n    }\n\n    Voxel aboveVoxel = readVoxel(worldCoord + ivec3(0,0,1));\n\n    if (worldCoord.z > 0)\n    {\n        // Voxels below\n        Voxel voxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, -1)),\n            readVoxel(worldCoord + ivec3(1,  0, -1)),\n            readVoxel(worldCoord + ivec3(0,  1, -1)),\n            readVoxel(worldCoord + ivec3(0, -1, -1))\n        );\n\n\n        for (int i = 0; i < voxels.length(); ++i)\n        {\n            if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST\n                && voxels[i].energy > maxDustEnergy\n                && levelVoxels[i].type != VOXEL_TYPE_STONE)\n            {\n                maxDustEnergy = voxels[i].energy - 1U;\n            }\n        }\n    }\n\n    if (worldCoord.z <= globalWorld.virtualDim.z && aboveVoxel.type != VOXEL_TYPE_STONE)\n    {\n        // Voxels above\n        Voxel voxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, 1)),\n            readVoxel(worldCoord + ivec3(1,  0, 1)),\n            readVoxel(worldCoord + ivec3(0,  1, 1)),\n            readVoxel(worldCoord + ivec3(0, -1, 1))\n        );\n\n\n        for (int i = 0; i < voxels.length(); ++i)\n        {\n            if (voxels[i].type == VOXEL_TYPE_REDSTONE_DUST\n                && voxels[i].energy > maxDustEnergy)\n            {\n                maxDustEnergy = voxels[i].energy - 1U;\n            }\n        }\n    }\n\n\n    if (maxTorchEnergy > 0U)\n        voxel.energy = max(voxel.energy, maxTorchEnergy);\n    else\n        voxel.energy = maxDustEnergy;\n}\n\n\n// NOTE: this is also used for stone-like blocks such as lamps\nuint calculateStoneMaxPower(in Voxel voxel, in ivec3 worldCoord)\n{\n    uint maxPower = 0U;\n\n    Voxel voxelMinusZ = readVoxel(worldCoord + ivec3(0,0,-1));\n    if (voxelMinusZ.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        maxPower = max(maxPower, voxelMinusZ.energy);\n    }\n    else\n    {\n        int dummyOutInt;\n        Voxel voxelMinusX, voxelPlusX, voxelMinusY, voxelPlusY, voxelPlusZ;\n\n        voxelMinusX = readVoxel(worldCoord + ivec3(-1,0,0));\n        voxelPlusX = readVoxel(worldCoord + ivec3(1,0,0));\n        voxelMinusY = readVoxel(worldCoord + ivec3(0,-1,0));\n        voxelPlusY = readVoxel(worldCoord + ivec3(0,1,0));\n        voxelPlusZ = readVoxel(worldCoord + ivec3(0,0,1));\n\n        bool voxelAboveOpaque = checkFlag(readVoxel(worldCoord + ivec3(-1,0,1)).type,\n                                          VOXEL_TYPE_OPAQUE);\n\n        bool leftConnected, rightConnected, forwardConnected;\n\n        if (voxelMinusX.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,-1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-2,0,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelMinusX.energy);\n            }\n        }\n\n        if (voxelPlusX.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,-1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(2,0,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelPlusX.energy);\n            }\n        }\n        if (voxelMinusY.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,-1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,-1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(0,-2,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelMinusY.energy);\n            }\n        }\n\n        if (voxelPlusY.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            leftConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(1,1,0), dummyOutInt, voxelAboveOpaque);\n            rightConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(-1,1,0), dummyOutInt, voxelAboveOpaque);\n            forwardConnected = isVoxelAtCoordDustConnectable(worldCoord + ivec3(0,2,0), dummyOutInt, voxelAboveOpaque);\n\n            if (  forwardConnected && !(leftConnected || rightConnected)\n                || !(forwardConnected || leftConnected || rightConnected)\n               )\n            {\n                maxPower = max(maxPower, voxelPlusY.energy);\n            }\n        }\n\n        if (voxelPlusZ.type == VOXEL_TYPE_REDSTONE_DUST)\n        {\n            maxPower = max(maxPower, voxelPlusZ.energy);\n        }\n\n    }\n\n    return maxPower;\n}\n\n\nvoid simlateWorld (inout Voxel voxel, in ivec3 worldCoord)\n{\n    if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n#ifdef DX9_FIX\n        \n        calculateEnergyDirectX9(voxel, worldCoord);\n        \n#else\n        voxel.energy = 0u;\n        uint pathLength = 0u;\n        if (pathfind(worldCoord, pathLength))\n        {\n            voxel.energy = MAX_REDSTONE_POWER - pathLength;\t\n        }\n#endif\n    }\n    else if (voxel.type == VOXEL_TYPE_STONE)\n    {\n        voxel.energy = calculateStoneMaxPower(voxel, worldCoord);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH\n             && isRedstoneTorchFacing(voxel.facing))\n    {\n        Voxel voxelAttached;\n        ivec3 voxelAttachedOffset;\n\n        if (voxel.facing == VOXEL_FACING_MINUS_X)\n        {\n            voxelAttachedOffset = ivec3(-1,0,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_X)\n        {\n            voxelAttachedOffset = ivec3(1,0,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_MINUS_Y)\n        {\n            voxelAttachedOffset = ivec3(0,-1,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_Y)\n        {\n            voxelAttachedOffset = ivec3(0,1,0);\n        }\n        else if (voxel.facing == VOXEL_FACING_PLUS_Z)\n        {\n            voxelAttachedOffset = ivec3(0,0,-1);\n        }\n\n        voxelAttached = readVoxel(worldCoord + voxelAttachedOffset);\n\n        if (voxelAttached.type == VOXEL_TYPE_STONE)\n        {\n            voxel.energy = uint(!bool(voxelAttached.energy > 0u)) * MAX_REDSTONE_POWER;\n        }\n        else\n        {\n        \tvoxel.energy = getDefaultVoxelEnergy(voxel.type);\n        }\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP)\n    {\n        uint maxPower = calculateStoneMaxPower(voxel, worldCoord);\n        \n        // In addition to typical stone block mechanics,\n        // the lamp can receive power directly from a neighboring\n        // redstone torch.\n        Voxel levelVoxels[4] = Voxel[4](\n            readVoxel(worldCoord + ivec3(-1, 0, 0)),\n            readVoxel(worldCoord + ivec3(1,  0, 0)),\n            readVoxel(worldCoord + ivec3(0,  1, 0)),\n            readVoxel(worldCoord + ivec3(0, -1, 0))\n        );\n\n        for (int i = 0; i < levelVoxels.length(); ++i)\n        {\n            if (levelVoxels[i].type == VOXEL_TYPE_REDSTONE_TORCH || levelVoxels[i].type == VOXEL_TYPE_STONE)\n            {\n                maxPower = max(maxPower, levelVoxels[i].energy);\n            }\n        }\n\n        voxel.energy = maxPower;\n    }\n}\n\n/*\nGUI_Extent Button0_Extent(in bool isOpen) // side panel button\n{\n    uint xOffset = uint(isOpen) * PANEL0_SIZE;\n    uint yOffset = uint(SATURATE(BUTTON0_YOFFSET) * (iResolution.y - float(TOP_PANEL_SIZE))) - BUTTON0_SIZE_Y/2U;\n    \n    GUI_Extent extent;\n    extent.x0 = uvec2(xOffset, yOffset);\n    extent.x1 = extent.x0 + uvec2(BUTTON0_SIZE_X, BUTTON0_SIZE_Y);\n    \n    return extent;\n}\n\nbool Do_Button0(in bool isOpen)\n{\n    ivec2 p = ivec2(iMouse.xy);\n \t\n    GUI_Extent extent = Button0_Extent(isOpen);\n    \n    bool isHit = hitPointAABB(ivec2(extent.x0), ivec2(extent.x1), p);\n    return isHit && isKeyReleased(keyPrimaryAction);\n}\n*/\n\nvoid\nupdateChannel (void)\n{\n    ivec2 pos = ivec2(floor(globalCoord));\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    mat3 viewProj = getWorldToScreen(cam);\n\n    vec2 _mousePos = (2.*iMouse.xy - iResolution.xy) / iResolution.y;\n    ivec2 mousePos = ivec2(floor(viewProj * vec3(_mousePos, 1)));        \n\n    if (pos.y == 0)\n    {\n        writeVar(pos.x, readVar(pos.x));\n        \n        // Handle zooming\n        float zoomSpeed = 0.;\n        \n        Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n        \n        if (isKeyPressed(KEY_ZOOM_PLUS))\n        {\n        \tzoomSpeed -= CAMERA_ZOOM_SPEED;\n        }\n        if (isKeyPressed(KEY_ZOOM_MINUS))\n        {\n        \tzoomSpeed += CAMERA_ZOOM_SPEED;\n        }\n        \n        // Handle motion\n        vec2 motionSpeed = vec2(0);\n        \n        if (isKeyPressed(KEY_MOVE_MINUS_X))\n        {\n        \tmotionSpeed.x -= CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_PLUS_X))\n        {\n        \tmotionSpeed.x += CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_MINUS_Y))\n        {\n        \tmotionSpeed.y -= CAMERA_MOTION_SPEED;\n        }\n        if (isKeyPressed(KEY_MOVE_PLUS_Y))\n        {\n        \tmotionSpeed.y += CAMERA_MOTION_SPEED;\n        }\n        \n        if (isKeyPressed(KEY_FAST_MOVE))\n        {\n        \tmotionSpeed *= 2.;\n        }\n        \n        cam.pos.xy += motionSpeed * iTimeDelta;\n        cam.pos.z += zoomSpeed * iTimeDelta;\n        \n        ///cam.pos.z = 2. + sin(iTime)*1.5;\n        writeCamera(VARIABLE_LOCATION_CAMERA, cam);\n        \n        int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n        \n        if (isKeyReleased(KEY_LAYER_MINUS))\n        {\n            --layerIndex;\n        }\n        if (isKeyReleased(KEY_LAYER_PLUS))\n        {\n            ++layerIndex;\n        }\n        \n        layerIndex = clamp(layerIndex, 0, getWorld().virtualDim.z);\n        \n        writeVar(VARIABLE_LOCATION_LAYER_INDEX, float(layerIndex));\n        \n        // Handle item selection\n        int itemIndex = int(readVar(SELECTED_ITEM_INDEX_ADDR));\n        \n        if (isKeyReleased(KEY_SELECTOR_LEFT))\n        {\n            --itemIndex;\n        }\n        if (isKeyReleased(KEY_SELECTOR_RIGHT))\n        {\n            ++itemIndex;\n        }\n        \n        itemIndex = int(mod(float(itemIndex), float(ITEM_TYPE_ARRAY.length())));\n        \n        writeVar(SELECTED_ITEM_INDEX_ADDR, float(itemIndex));\n        \n        {\n            // Change edit mode\n            int mode = int(readVar(VARIABLE_LOCATION_MODE).x);\n            mode += int(isKeyReleased(KEY_CHANGE_MODE));\n            writeVar(VARIABLE_LOCATION_MODE, float(mode % 2));\n        }\n        \n        /*\n        bool isPanelOpen = bool(readVar(guiStatePtr).x);\n        \n        if (Do_Button0(isPanelOpen))\n        {\n            isPanelOpen = !isPanelOpen;\n        }\n        \n        writeVar(guiStatePtr, float(isPanelOpen));*/\n    }\n    else if (isInsideWorldReal(getWorld(), pos))\n    {\n        // Update world from UI interaction\n        ivec2 realWorldPos = getImageToWorldReal(getWorld(), getImage(), pos);\n        ivec3 worldCoord = getImageToWorldVirtual(getWorld(), getImage(), pos);\n\n        int layerIndex = int(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n\n        Voxel voxel = readVoxel(worldCoord);\n        uint selectedItemType = ITEM_TYPE_ARRAY[int(readVar(SELECTED_ITEM_INDEX_ADDR))];\n\n        // Find lowest block which isn't void\n        int selectedLayerIndex = layerIndex;\n        \n        int mode = int(readVar(KEY_CHANGE_MODE).x);\n        if (mode == 0)\n        {\n            while (selectedLayerIndex > 0)\n            {\n                if (readVoxel(ivec3(mousePos, selectedLayerIndex)).type != VOXEL_TYPE_VOID)\n                    break;\n            \t--selectedLayerIndex;\n            }\n        }\n\n        ivec3 selectedCoordZeroZ = ivec3(mousePos, selectedLayerIndex);\n        ivec3 selectedCoordOneZ = selectedCoordZeroZ + ivec3(0,0,1);\n        bool selectedZeroZ = all(equal(worldCoord, selectedCoordZeroZ));\n        bool selectedOneZ = all(equal(worldCoord, selectedCoordOneZ)) && selectedLayerIndex != layerIndex;\n\n        if (isKeyReleased(KEY_PRIMARY_ACTION) && (selectedZeroZ || selectedOneZ))\n        {\n            if (selectedOneZ)\n            {\n                Voxel voxelZeroZ = readVoxel(selectedCoordZeroZ);\n                if (voxel.type == VOXEL_TYPE_VOID\n                    && voxelZeroZ.type != VOXEL_TYPE_VOID\n                    && !checkFlag(voxelZeroZ.type, VOXEL_TYPE_FACING)\n                   ) \n                {\n                    voxel = getDefaultVoxel(selectedItemType);\n                }\n            }\n\n            if (selectedZeroZ)\n            {\n                if (voxel.type == VOXEL_TYPE_VOID)\n                {\n                    voxel = getDefaultVoxel(selectedItemType);\n                }\n                else if (checkFlag(voxel.type, VOXEL_TYPE_FACING)\n                         && selectedItemType == voxel.type)\n                {\n                    // Changing voxel facing direction\n                    voxel.facing = getNextVoxelFacing(voxel);\n                }\n            }\n        }\n        else if (isKeyReleased(KEY_SECONDARY_ACTION) && selectedZeroZ)\n        {\n            voxel = getDefaultVoxel(VOXEL_TYPE_VOID);\n        }\n        \n        // Simulate redstone in world\n        simlateWorld(voxel, worldCoord);\n        writeVoxel(voxel);\n    }\n}\n\nvoid\nmainImage (out vec4 fragColor, in vec2 fragCoord)\n{   \n    initializeAPI(fragCoord);\n    \n    \n    if (iFrame == 0)\n    {\n        initializeChannel();\n    }\n    else\n    {\n        updateChannel();\n    }\n    \n    fragColor = terminate();\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\n/*\n\tControls are set in 'Common' tab.\n*/\n\nDEFINE_DEFAULT_API(iChannel0, 0)\n\nvoid blendOver(out vec4 Co, in vec3 Ca, in vec3 Cb, in float alpha_a, in float alpha_b)\n{\n\tCo.a = alpha_a + alpha_b * (1.0 - alpha_a);\n    Co.rgb = /*Ca + Cb * (1.0 - alpha_a);*/(Ca * alpha_a + Cb * alpha_b * (1.0 - alpha_a)) / Co.a;\n}\n\n\nvoid\ndrawRedstoneLamp(inout vec4 color,\n        in vec2 pos,\n        in float alphaScale,\n        in float invScale,\n        in float power) // 0-1 power\n{\n    const float W = .13;\n    float t1 = -sdBox(pos,vec2(1))-W/2.;\n    float t2 = min(abs(pos.x),abs(pos.y));\n    float t3 = length(vec2(abs(pos.x), abs(pos.y)))-.5;\n    float tt = min(min(t1,t2),t3);\n    float alpha = smoothstep(1.5, -1.5, (abs(tt)-W) * invScale );\n    vec4 tmp = vec4(mix(LAMP_COLOR*power,WOOD_COLOR,alpha),1);\n    color = mix(color, tmp, alphaScale);\n}\n\nvoid\ndrawRedstoneDust (inout vec4 color,\n                  in vec2 pos,\n                  in ivec3 coord, in float alphaScale, in float invScale)\n{\n    float t = 1000.;\n    \n    Voxel voxel = readVoxel(coord);\n    \n    bool magicBool = isVoxelAtCoordOpaque(coord + ivec3(0, 0, 1));\n    int dummyZOffset;\n\t\n    bool connectableLeft = isVoxelAtCoordDustConnectable(coord + ivec3(-1, 0, 0), dummyZOffset, magicBool);\n    bool connectableRight = isVoxelAtCoordDustConnectable(coord + ivec3(1, 0, 0), dummyZOffset, magicBool);\n\tbool connectableBottom = isVoxelAtCoordDustConnectable(coord + ivec3(0, -1, 0), dummyZOffset, magicBool);\n    bool connectableTop = isVoxelAtCoordDustConnectable(coord + ivec3(0, 1, 0), dummyZOffset, magicBool);\n    \n    bvec4 voxelsAroundConnectable = bvec4(connectableLeft, connectableRight, connectableBottom, connectableTop);  \n    \n    if (!any(voxelsAroundConnectable))\n    {\n        t = min(abs(pos.x), abs(pos.y));\n    }\n    else if (any(voxelsAroundConnectable.xy) && !any(voxelsAroundConnectable.zw))\n    {\n    \tt = abs(pos.y);\n    }\n    else if (!any(voxelsAroundConnectable.xy) && any(voxelsAroundConnectable.zw))\n    {\n    \tt = abs(pos.x);\n    }\n    else\n    {\n        if (voxelsAroundConnectable[0])\n        {\n        \tt = min(t, max(abs(pos.y), pos.x) );\n        }\n        if (voxelsAroundConnectable[1])\n        {\n        \tt = min(t, max(abs(pos.y), -pos.x) );\n        }\n        if (voxelsAroundConnectable[2])\n        {\n        \tt = min(t, max(abs(pos.x), pos.y) );\n        }\n        if (voxelsAroundConnectable[3])\n        {\n        \tt = min(t, max(abs(pos.x), -pos.y) );\n        }\n    }\n    \n    t -= REDSTONE_DUST_WIDTH*.5;\n    \n    float alpha = smoothstep(3., 0., t * invScale);\n    \n    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS,\n                    alpha * alphaScale);\n    \n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);\n    color = mix(color, voxelColor, voxelColor.a /** (1.0 - color.a)*/);\n}\n\n\nvoid\ndrawRedstoneTorch (inout vec4 color,\n                   in vec2 pos,\n                   in ivec3 coord, in float alphaScale, in float invScale)\n{\n    Voxel voxel = readVoxel(coord);\n    \n    float tHandle, handleAlpha, tHead = length(pos) - REDSTONE_TORCH_RADIUS, headAlpha;\n    \n    \n    if (voxel.facing != VOXEL_FACING_PLUS_Z)\n    {\n    \n        if      (voxel.facing == VOXEL_FACING_MINUS_X)\n            tHandle = max(abs(pos.y), pos.x);\n        else if (voxel.facing == VOXEL_FACING_PLUS_X)\n            tHandle = max(abs(pos.y), -pos.x);\n        else if (voxel.facing == VOXEL_FACING_MINUS_Y)\n            tHandle = max(abs(pos.x), pos.y);\n        else if (voxel.facing == VOXEL_FACING_PLUS_Y)\n            tHandle = max(abs(pos.x), -pos.y);\n    \n    \ttHandle -= REDSTONE_TORCH_HANDLE_WIDTH * .5;\n    \n        handleAlpha = smoothstep(3., 0., tHandle * invScale);\n        vec4 handleColor = vec4(REDSTONE_TORCH_HANDLE_COLOR, handleAlpha * alphaScale);\n        //handleColor.rgb *= handleColor.a;\n        //blendOver(color, color.rgb, handleColor.rgb, color.a, handleColor.a);\n        color = mix(color, handleColor, handleColor.a /** (1.0 - color.a)*/);\n        //color.a = (1.0 - color.a) * handleColor.a;\n    }\n\n    headAlpha = smoothstep(3., 0., tHead * invScale);\n    //color.rgb = mix(color.rgb, getRedstoneColor(voxel.power), alphaScale * headAlpha);\n    \n    vec4 voxelColor = vec4(getEnergyColor(voxel.energy) * ENERGY_BRIGHTNESS, headAlpha * alphaScale);\n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(color, color.rgb, voxelColor.rgb, color.a, voxelColor.a);\n    \n    \n    color = mix(color, voxelColor, voxelColor.a);\n    //color.a = voxelColor.a;\n    //color.rgb *= 1. - .1 * exp(-10. * t) * (1.-alpha);\n    /*\n    uint uniqueIndex = uint(getWorldVirtualToIndex(getWorld(), getImage(), coord));\n    \n    for (uint i = 0u; i < REDSTONE_PARTICLE_COUNT; ++i)\n    {\n    \tfloat seed = float(uniqueIndex * REDSTONE_PARTICLE_COUNT + i * 4u);\n\n        float angle = hash11(seed++) * TAU;\n        float speed = .1 + hash11(seed++) * .4;\n        vec2 dir = vec2(sin(angle), cos(angle));\n        vec2 vel = dir * speed;\n        float lifeTime = .4 + .6  * hash11(seed++);\n        float initialTime = hash11(seed++) * lifeTime;\n\n        float radius = (.03 + pow(hash11(seed++), 2.) * .22) * REDSTONE_TORCH_RADIUS;\n\n        vec2 initialPos = dir * REDSTONE_TORCH_RADIUS;\n\n        vec2 particlePos = getParticlePos(initialPos, vel, initialTime, lifeTime, iTime);\n        float particleAlpha = .7 * getParticleAlpha(initialTime, lifeTime, iTime, 2.5);\n\n        float t = length(pos - particlePos) - radius;\n        float alpha = smoothstep(3., 0., t * invScale) * particleAlpha * alphaScale;\n        color.rgb = mix(color.rgb, getRedstoneColor(MAX_REDSTONE_POWER), alpha);\n    }\n\t*/\n}\n\nvoid\npaintVoxel ( inout vec4 fragColor, in vec2 mPos, in ivec3 wCoord, in float alpha01, in float inverseScale )\n{\n    Voxel voxel = readVoxel(wCoord);\n    \n\n    if (voxel.type == VOXEL_TYPE_STONE)\n    {\n        vec4 voxelColor = vec4(STONE_COLOR, SATURATE(alpha01));\n        //voxelColor.rgb *= voxelColor.a;\n        //blendOver(fragColor, fragColor.rgb, voxelColor.rgb, fragColor.a, voxelColor.a);\n        fragColor = mix(fragColor, voxelColor, voxelColor.a);\n\n\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n        drawRedstoneDust(fragColor, mPos, wCoord, alpha01, inverseScale);\n    }\n    else if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        drawRedstoneTorch(fragColor, mPos, wCoord, alpha01, inverseScale);\n    } else if (voxel.type == VOXEL_TYPE_REDSTONE_LAMP) {\n        drawRedstoneLamp(fragColor, mPos, alpha01, inverseScale, float(voxel.energy > 0u));\n    }\n}\n\nfloat customLength(float x, float y)\n{\n    //return max(x,y);\n    return abs(x + y);\n}\n\nfloat AO_Falloff (in float x)\n{\n\treturn exp(-8.0 * (1.0-x));\n}\n\nvoid\npaintVoxelAO (inout vec4 color, in vec2 p, in ivec3 coord, in float alphaScale)\n{\n    float ao = 0.;\n    float t = MAX_SDF_DISTANCE;\n    \n    bool opaqueLeft, opaqueRight, opaqueBottom, opaqueTop;\n    opaqueLeft = opaqueRight = opaqueBottom = opaqueTop = false;\n    \n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,0,0)))\n    {\n        opaqueLeft = true;\n        ao += AO_Falloff((1.-(p.x + 1.)*.25));\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,0,0)))\n    {\n        opaqueRight = true;\n        ao += AO_Falloff(1.-(-(p.x - 1.)*.25));\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(0,-1,0)))\n    {\n        opaqueBottom = true;\n        ao += AO_Falloff(1.-(p.y + 1.)*.25);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(0,1,0)))\n    {\n        opaqueTop = true;\n        ao += AO_Falloff(1.-(-(p.y - 1.)*.25));\n    }\n    \n    \n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,-1,0)) && !(opaqueBottom || opaqueLeft))\n    {\n        float a = 1.-clamp(customLength(p.x + 1., p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,-1,0)) && !(opaqueBottom || opaqueRight))\n    {\n        float a = 1.-clamp((customLength(-p.x + 1., p.y + 1.)*.25), 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(-1,1,0)) && !(opaqueTop || opaqueLeft))\n    {\n        float a = 1.-clamp(customLength(p.x + 1., -p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);;\n    }\n    if (isVoxelAtCoordOpaque(coord + ivec3(1,1,0)) && !(opaqueTop || opaqueRight))\n    {\n        float a = 1.-clamp(customLength(-p.x + 1., -p.y + 1.)*.25, 0., 1.);\n        ao += AO_Falloff(a);\n    }\n    \n    vec4 voxelColor = vec4(0, 0, 0, alphaScale *  clamp(ao*.3, 0., 1.));\n    //voxelColor.rgb *= voxelColor.a;\n    //blendOver(fragColor, fragColor.rgb, voxelColor.rgb, fragColor.a, voxelColor.a);\n    color = mix(color, voxelColor, voxelColor.a * (1.0 - color.a));\n    ;//color.rgb *= (1. - clamp(ao*.3, 0., 1.) * alphaScale);\n    \n}\n\nvec3 toGrayscale(in vec3 col)\n{\n\tfloat x = (col.x + col.y + col.z) / 3.0;\n    return vec3(x);\n}\n\nvoid\npaintWorld ( inout vec4 fragColor, in vec2 wPos, in float inverseScale )\n{\n    vec2 mPos = fract(wPos) * 2. - 1.;\n \tinverseScale /= 2.;\n    \n    Voxel voxel;\n    ivec3 wCoord;\n    \n    uint selectedLayerIndex = uint(readVar(VARIABLE_LOCATION_LAYER_INDEX));\n    uint layersToLoop = max(selectedLayerIndex, MAX_VISIBLE_LAYERS);\n\n    for (uint i = 1u; i <= layersToLoop; ++i)\n    {\n       \tuint layerIndex = selectedLayerIndex - (layersToLoop - i);\n\t\twCoord = ivec3(ivec2(floor(wPos)), layerIndex);\n        \n        if (!isInsideWorldVirtual(getWorld(), wCoord)) continue;\n        \n        float layerDistance = 1. - float(i) / float(layersToLoop);\n        \n        voxel = readVoxel(wCoord);\n        \n        //if (voxel.type == VOXEL_TYPE_VOID) continue;\n\t\t\n        //float alphaScale = 1.;\n        //float alphaScale = (i == 0u) ? 1.\n        //    : exp(-7. * float(i + 1u) / float(MAX_VISIBLE_LAYERS) * GHOST_LAYER_ALPHA);\n\n        float alphaScale = exp(-1.9 * layerDistance);\n        \n        if (ENABLE_AMBIENT_OCCLUSION && voxel.type != VOXEL_TYPE_STONE)\n        {\n        \tpaintVoxelAO(fragColor, mPos, wCoord, alphaScale);\n        }\n        \n        paintVoxel(fragColor, mPos, wCoord, alphaScale, inverseScale);\n        \n        //if (i != selectedLayerIndex + 1u) tmpColor.rgb = mix(tmpColor.rgb, toGrayscale(tmpColor.rgb), 1.0);\n        \n        //blendOver(fragColor, fragColor.rgb, tmpColor.rgb, fragColor.a, tmpColor.a);\n        //fragColor = mix(fragColor, tmpColor, tmpColor.a);\n        \n    }\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(1.0, 1.0, 1.0, 0.0);\n    initializeAPI(fragCoord);\n    \n    Camera cam = readCamera(VARIABLE_LOCATION_CAMERA);\n    \n    uvec2 sMouseCoord = uvec2(floor(iMouse.xy));\n    uvec2 sCoord = uvec2(floor(fragCoord));\n    \n    vec2 res = iResolution.xy, sPos = (2.*fragCoord - res) / res.y,\n         sMousePos = (2.*iMouse.xy - res) / res.y;\n    \n    mat3 MVP = getWorldToScreen( cam );\n    vec2 wPos = vec2(MVP * vec3(sPos, 1));\n    vec2 wMousePos = vec2(MVP * vec3(sMousePos, 1));\n\tuvec2 wCoord = uvec2(floor(wPos));\n    uvec2 wMouseCoord = uvec2(floor(wMousePos));\n    \n    float inverseScale = getScaleZ( cam ) * res.y;\n\n    paintWorld(fragColor, wPos, inverseScale);\n    \n    /*\n    {\n        vec2 wSize = vec2(getWorld().virtualDim.xy);\n    \tfloat t = sdBox(wPos - wSize*.5, wSize * .5);\n        float alpha = smoothstep(-.25, .25, t);\n        \n        fragColor.rgb *= 1. - .125 * alpha;\n    }\n    */\n    //fragColor = clamp(fragColor, 0.0, 1.0);\n    //paintGrid(fragColor, cam, wPos, .1);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "/*\n\tShader Redstone 3 (c) by saidwho12\n\n    Shader Redstone 3 is licensed under a\n    Creative Commons Attribution 3.0 Unported License.\n\n    You should have received a copy of the license along with this\n    work.  If not, see <http://creativecommons.org/licenses/by/3.0/>.\n*/\n\n#define PI 3.14159\n#define PI_2 6.28318\n\n#define SATURATE(x) clamp(x,0.,1.)\n\n#define size_t uint\n\n// Comment if you fixed your browser\n#define DX9_FIX\n\n// Key code constants\nconst int KEY_BSP   = 8;\nconst int KEY_SHIFT_LEFT = 16;\nconst int KEY_CTRL_LEFT = 17;\nconst int KEY_SPACE    = 32;\nconst int KEY_LEFT  = 37;\nconst int KEY_UP    = 38;\nconst int KEY_RIGHT = 39;\nconst int KEY_DOWN  = 40;\nconst int KEY_A     = 65;\nconst int KEY_B     = 66;\nconst int KEY_C     = 67;\nconst int KEY_D     = 68;\nconst int KEY_E     = 69;\nconst int KEY_F     = 70;\nconst int KEY_G     = 71;\nconst int KEY_H     = 72;\nconst int KEY_I     = 73;\nconst int KEY_J     = 74;\nconst int KEY_K     = 75;\nconst int KEY_L     = 76;\nconst int KEY_M     = 77;\nconst int KEY_N     = 78;\nconst int KEY_O     = 79;\nconst int KEY_P     = 80;\nconst int KEY_Q     = 81;\nconst int KEY_R     = 82;\nconst int KEY_S     = 83;\nconst int KEY_T     = 84;\nconst int KEY_U     = 85;\nconst int KEY_V     = 86;\nconst int KEY_W     = 87;\nconst int KEY_X     = 88;\nconst int KEY_Y     = 89;\nconst int KEY_Z     = 90;\nconst int KEY_COMMA = 188;\nconst int KEY_PER   = 190;\nconst int KEY_0     = 48;\nconst int KEY_1     = 49;\nconst int KEY_2     = 50;\nconst int KEY_3     = 51;\nconst int KEY_4     = 52;\nconst int KEY_5     = 53;\nconst int KEY_6     = 54;\nconst int KEY_7     = 55;\nconst int KEY_8     = 56;\nconst int KEY_9     = 57;\n\n#define AABB(T, N) struct { T x0[N], x1[N]; }\n\n// Key bindings\nconst int KEY_MOVE_MINUS_X     = KEY_A;\nconst int KEY_MOVE_PLUS_X      = KEY_D;\nconst int KEY_MOVE_MINUS_Y     = KEY_S;\nconst int KEY_MOVE_PLUS_Y      = KEY_W;\nconst int KEY_FAST_MOVE        = KEY_SHIFT_LEFT;\nconst int KEY_ZOOM_MINUS       = KEY_Q;\nconst int KEY_ZOOM_PLUS        = KEY_E;\nconst int KEY_SELECTOR_LEFT    = KEY_LEFT;\nconst int KEY_SELECTOR_RIGHT   = KEY_RIGHT;\nconst int KEY_LAYER_MINUS      = KEY_DOWN;\nconst int KEY_LAYER_PLUS       = KEY_UP;\nconst int KEY_PRIMARY_ACTION   = KEY_F;\nconst int KEY_SECONDARY_ACTION = KEY_R;\nconst int KEY_CHANGE_MODE      = KEY_M;\n\n// Shader constants for the game (Overrides GUI options if available && possible)\nconst uint  TICKS_PER_SECOND             = 20U;\nconst uint  MIN_TICKS_PER_SECOND         = 10U;\nconst uint  MAX_TICKS_PER_SECOND         = 60U;\nconst uint  MAX_FRAME_SKIP               = 10U;\nconst uint  MAX_VISIBLE_LAYERS           = 8U;\nconst float MAX_SDF_DISTANCE             = 1e3;\nconst uint  MAX_REDSTONE_POWER           = 16U;\nconst float GHOST_LAYER_ALPHA            = .91;\nconst uint  REDSTONE_PARTICLE_COUNT      = 16U;\nconst float REDSTONE_DUST_WIDTH          = .3;\nconst float REDSTONE_TORCH_RADIUS        = .4;\nconst float REDSTONE_TORCH_HANDLE_WIDTH  = .3;\nconst float CAMERA_MOTION_SPEED          = 5.;\nconst float CAMERA_ZOOM_SPEED            = .75;\nconst bool  ENABLE_AMBIENT_OCCLUSION     = false; // LOOKS SO UGLY!\nconst bool  ENABLE_VIGNETTE              = false;\nconst float ENERGY_BRIGHTNESS            = 1.0;\nconst float ITEM_BOX_HEIGHT              = 0.11; // 0 -> 2\nconst float ITEM_BOX_Y_PADDING           = 0.1; // 0 -> 1\nconst float DARK_ITEM_BOX_SIZE           = 0.812;\nconst bool  ENABLE_WORLD_GRID            = true;\nconst uint  WORDL_GRID_QUADRILLAGE_DEPTH = 1U;\n\n// Shader constants for UI rendering\nconst vec4  UI_BACKGROUND_COLOR       = vec4(1,1,1,.5);//vec3(0.68, 0.75, 0.74);\nconst vec4  UI_DEAD_COLOR             = vec4(0.7, 0.7, 0.7, 1.0);\nconst vec4  UI_HOT_COLOR              = vec4(0.9, 0.9, 0.9, 1.0);\nconst vec4  UI_ALIVE_COLOR            = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec2  UI_INFO_BOX_SCALE         = vec2(0.3, 0.18);\nconst bool  UI_ENABLE_RANDOM_ITEM_ROT = false;\nconst bool  UI_ENABLE_ITEM_ANIM       = true;\nconst bool  UI_ENABLE_BLUR = false;\nconst bool  UI_ENABLE_REDSTONE_PARTICLES = false;\nconst float UI_ALPHA = 0.8;\n\nconst vec3 WOOD_COLOR = vec3(.46,.375,.253);\nconst vec3 LAMP_COLOR = vec3(1.,.95,.745);\nconst vec3 STONE_COLOR = vec3(.715);//vec3(1,1,0);//vec3(0.84);//vec3(.35);\nconst vec3 REDSTONE_TORCH_HANDLE_COLOR = WOOD_COLOR;\nconst vec3 GRAY_STONE_COLOR = vec3(.415);\n\n#define POINTER int\n\n// Storage variable locations\nconst int VARIABLE_LOCATION_RESOLUTION = 0;\nconst int VARIABLE_LOCATION_CAMERA = 1;\nconst int VARIABLE_LOCATION_LAYER_INDEX = 2;\nconst int VARIABLE_LOCATION_MODE = 3;\n\nconst POINTER SELECTED_ITEM_INDEX_ADDR = 4;\n\n#define MODE_LOWEST_NONVOID_Z 0\n#define MODE_CURRENT_Z 1\n\n//const int editorModeLocation = 4;\n\n//const int sliderState04Ptr = 6;\n\nconst uint EDITOR_MODE_EDIT = 0U;\nconst uint EDITOR_MODE_ROTATE = 1U;\nconst uint EDITOR_MODE_COPY = 2U; // TODO: Actually implement\nconst uint EDITOR_MODE_COUNT = 3U;\nconst float GUI_TRANSLUCENCY = 0.75;\n\n#define PI 3.14159\n#define TAU (2.*PI)\n#define ONE_OVER_THREE .333333\n\nfloat logn (in float x, in float n) { return log(x * 10./n); }\nfloat cuberoot (in float x) { return pow(abs(x), ONE_OVER_THREE); }\n\n#define WIDGET_TYPE uint\n#define WIDGET_TYPE_LABEL        0U\n#define WIDGET_TYPE_BUTTON       1U\n#define WIDGET_TYPE_CHECKBOX     2U\n#define WIDGET_TYPE_SLIDER_FLOAT 3U\n#define WIDGET_TYPE_SLIDER_INT   4U\n\n// Widget base, this stays constant accross frames\nstruct Widget\n{\n    POINTER addr;\n    WIDGET_TYPE type;\n    vec2 pos;\n    vec2 scale;\n};\n    \nstruct Button\n{\n    Widget base;\n\tbool value;\n};\n    \nstruct Checkbox\n{\n\tWidget base;\n    bool value;\n};\n\nstruct Slider_Float\n{\n    Widget base;\n    float minValue;\n    float maxValue;\n    float value;\n};\n    \nstruct Slider_Int\n{\n    Widget base;\n    int minValue;\n    int maxValue;\n    int value;\n    int stepSize;\n};\n\nfloat UI_ButtonAO(in float t)\n{\n\treturn 1.0 - .7 * exp(-.5 * max(t,0.));\n}\n\nfloat Brightness(in vec3 c)\n{\n\treturn (c.r + c.g + c.b) / 3.0;\n}\n\nvec3 Contrast(in vec3 c)\n{\n    float alpha = Brightness(c);\n    alpha = SATURATE(alpha);\n    \n    float w = .5;\n    return vec3(smoothstep(w, -w, alpha - .5));//max((1. + pow(1. - 2. * alpha, 1. / (1. + 2. * n) )) / 2., 0.);\n}\n    \nButton BUTTON_ARRAY[] = Button[](\n    Button( Widget(0x5, WIDGET_TYPE_BUTTON, vec2(0), vec2(0)), false )\n);\n\nButton UI_CONFIG_BUTTON = Button( Widget(6, WIDGET_TYPE_BUTTON, vec2(0.1), vec2(0.045)), false);\n\n\nfloat sdBox (in vec2 p, in vec2 b)\n{\n\tvec2 d = abs(p) - b;\n \treturn length(max(d,0.0)) + min(max(d.x,d.y),0.0); \n}\n\n\nivec3\ngetMaxWorldDim (in ivec2 R)\n{\n    return ivec3(floor(cuberoot(float(R.x * R.y))));\n}\n\nstruct Camera\n{\n\tvec3 pos;\n};\n    \nmat3 translate (in vec2 x)\n{\n\treturn mat3(1,0,0,0,1,0,x,1);\n}\n\nmat2 rotate (in float x)\n{\n\tfloat c = cos(x), s = sin(x);\n    return mat2(c, s, -s, c);\n}\n\nfloat\ngetScaleZ (in Camera cam)\n{\n\treturn exp(-cam.pos.z);\n}\n\nmat3\ngetWorldToScreen (in Camera cam)\n{\n    float z_scale = getScaleZ(cam);\n    \n    mat3 m = /*mat3(rotate(radians(44.))) * */ translate(cam.pos.xy) * mat3(1./z_scale, 0, 0, 0, 1./z_scale, 0, 0, 0, 1);\n    \n    return m;\n}\n\nbool\nhitPointAABB (in ivec2 x0, in ivec2 x1, in ivec2 p)\n{\n\treturn all(greaterThanEqual(p, x0)) && all(lessThanEqual(p, x1));\n}\n\nbool\nhitPointAABB (in ivec3 x0, in ivec3 x1, in ivec3 p)\n{\n\treturn all(greaterThanEqual(p, x0)) && all(lessThanEqual(p, x1));\n}\n\nstruct Image_t\n{\n    int id;\n    ivec2 dim;\n};\n    \nstruct World_t\n{\n\tivec2 realPos;\n    ivec2 realDim;\n    ivec3 virtualDim;\n};\n\nivec2\ngetImageToWorldReal (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos -= world.realPos;\n    int index = pos.y * image.dim.x + pos.x;\n    pos = ivec2(index % world.realDim.x, index / world.realDim.x);\n    return pos;\n}\n\nivec3\ngetImageToWorldVirtual (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos -= world.realPos;\n    int index = pos.y * image.dim.x + pos.x;\n    \n    return ivec3(\n    index % world.virtualDim.x,\n    (index % (world.virtualDim.x * world.virtualDim.y)) / world.virtualDim.x,\n    index / (world.virtualDim.x * world.virtualDim.y));\n}\n\nivec2\ngetWorldRealToImage (in World_t world, in Image_t image, in ivec2 pos)\n{\n\tpos += world.realPos;\n    int index = pos.y * world.realDim.x + pos.x;\n    pos = ivec2(index % image.dim.x, index / image.dim.x);\n    return pos;\n}\n\nivec2\ngetWorldVirtualToImage (in World_t world, in Image_t image, in ivec3 pos)\n{\n    int i0 = (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n    \n    int i1 = world.realPos.y * image.dim.x + world.realPos.x;\n    \n    int index = i0 + i1;\n    \n\treturn ivec2(index % image.dim.x, index / image.dim.x);\n}\n\nPOINTER\ngetWorldVirtualToAddr(in World_t world, in Image_t image, in ivec3 pos)\n{\n\tint i0 = (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n    \n    int i1 = world.realPos.y * image.dim.x + world.realPos.x;\n    \n    return i0 + i1;\n}\n\nint\ngetWorldVirtualToIndex (in World_t world, in Image_t image, in ivec3 pos)\n{\n    return (pos.y * world.virtualDim.x + pos.x)\n        + (world.virtualDim.x * world.virtualDim.y) * pos.z;\n}\n\nbool isInsideWorldVirtual (in World_t world, in ivec2 pos)\n{\n    return hitPointAABB(ivec2(0), world.virtualDim.xy, pos);\n}\n\nbool isInsideWorldVirtual (in World_t world, in ivec3 pos)\n{\n    return hitPointAABB(ivec3(0), world.virtualDim, pos);\n}\n\nbool isInsideWorldReal (in World_t world, in ivec2 pos)\n{\n    return hitPointAABB(world.realPos, world.realPos + world.realDim, pos);\n}\n\n/*\n\nivec2 getCoordWorldToImage (in ivec3 worldCoord)\\\n{\\\n    int i = (p.y * getWorld().virtualDim.x + p.x)\\\n        + (getWorld().virtualDim.x * getWorld().virtualDim.y) * p.z;\\\n \t\\\n\tivec2 x0 = getWorld().realPos;\\\n    ivec2 x1 = ivec2(i / getWorld().realDim.x, i % getWorld().realDim.y);\\\n    \\\n    ivec2 x = x0 + x1;\\\n    return x;\\\n}\\\n*/\n\nconst uint VOXEL_TYPE_VOID              = 0x0U;\nconst uint VOXEL_TYPE_STONE             = 0x1U;\nconst uint VOXEL_TYPE_REDSTONE_DUST     = 0x2U;\nconst uint VOXEL_TYPE_REDSTONE_TORCH    = 0x4U;\nconst uint VOXEL_TYPE_LEVER             = 0x8U;\nconst uint VOXEL_TYPE_BUTTON            = 0x10U;\nconst uint VOXEL_TYPE_REDSTONE_REPEATER = 0x20U;\nconst uint VOXEL_TYPE_REDSTONE_LAMP     = 0x40U;\n\nconst uint VOXEL_TYPE_OPAQUE = VOXEL_TYPE_STONE | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_MONOCHROME =\n      VOXEL_TYPE_STONE\n    | VOXEL_TYPE_REDSTONE_DUST\n    | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_POLYCHROME =\n      VOXEL_TYPE_REDSTONE_TORCH\n    | VOXEL_TYPE_LEVER\n    | VOXEL_TYPE_BUTTON\n    | VOXEL_TYPE_REDSTONE_REPEATER\n    | VOXEL_TYPE_REDSTONE_LAMP;\n\nconst uint VOXEL_TYPE_FACING =\n      VOXEL_TYPE_REDSTONE_TORCH\n    | VOXEL_TYPE_LEVER\n    | VOXEL_TYPE_REDSTONE_REPEATER;\n\nconst uint VOXEL_FACING_NOWHERE = 0U;\nconst uint VOXEL_FACING_MINUS_X = 1U;\nconst uint VOXEL_FACING_PLUS_X  = 2U;\nconst uint VOXEL_FACING_MINUS_Y = 3U;\nconst uint VOXEL_FACING_PLUS_Y  = 4U;\nconst uint VOXEL_FACING_PLUS_Z  = 5U;\n\nbool isRedstoneTorchFacing (in uint x)\n{\n\treturn x == VOXEL_FACING_MINUS_X\n        || x == VOXEL_FACING_PLUS_X\n        || x == VOXEL_FACING_MINUS_Y\n        || x == VOXEL_FACING_PLUS_Y\n        || x == VOXEL_FACING_PLUS_Z;\n}\n\nstruct Voxel\n{\n    uint type;\n    uint energy; // 0;16\n    uint facing; // variation in placement orientation\n};\n\nbool isVoxelFacing (in Voxel voxel)\n{\n\treturn voxel.facing > 0U;\n}\n\n    \nVoxel readVoxel (in ivec3 coord);\n\nbool\ncheckFlag (uint x, uint y) { return (x & y) > 0U; }\n\nbool isVoxelOpaque (in Voxel voxel)\n{\n\treturn checkFlag(voxel.type, VOXEL_TYPE_OPAQUE);\n}\n\nuint getNextVoxelFacing (in Voxel voxel)\n{\n    if (voxel.type == VOXEL_TYPE_REDSTONE_TORCH)\n\t\treturn (voxel.facing + 1U) % 5U + 1U;\n}\n\nuint getDefaultVoxelEnergy (in uint type)\n{\n    if (type == VOXEL_TYPE_REDSTONE_TORCH) return MAX_REDSTONE_POWER;\n    else return 0U;\n}\n\nVoxel getDefaultVoxel (in uint type)\n{\n\tVoxel voxel;\n\n    voxel.type = type;\n    \n    voxel.energy = getDefaultVoxelEnergy(type);\n    voxel.facing = checkFlag(type, VOXEL_TYPE_FACING) ? VOXEL_FACING_PLUS_Z\n        : VOXEL_FACING_NOWHERE;\n    \n    return voxel;\n}\n\nVoxel getDefaultMenuVoxel (in uint type)\n{\n\tVoxel voxel;\n    \n    voxel.type = type;\n    \n    if (type == VOXEL_TYPE_REDSTONE_TORCH) voxel.energy = MAX_REDSTONE_POWER;\n    else voxel.energy = 0u;\n    \n    voxel.facing = checkFlag(type, VOXEL_TYPE_FACING) ? VOXEL_FACING_PLUS_Z\n        : VOXEL_FACING_NOWHERE;\n    \n    return voxel;\n}\n\nvec3 getEnergyColor (in float iEnergy01)\n{\n    //return vec3(iEnergy01 > 0.0, 0, 0);\n    return vec3(.1 + .9 * SATURATE(iEnergy01), 0, 0);\n\t//return vec3(/*.15 + .85 * SATURATE(iEnergy01)*/ iEnergy01 == 0.0 ? 0.15 : 1.0, 0, 0);\n}\n\nvec3 getEnergyColor (in uint energy)\n{\n\tenergy = min(energy, MAX_REDSTONE_POWER);\n    return getEnergyColor(float(energy) / float(MAX_REDSTONE_POWER));\n}\n\nconst uint ITEM_TYPE_ARRAY[] = uint[](\n    VOXEL_TYPE_STONE,\n    VOXEL_TYPE_REDSTONE_DUST,\n    VOXEL_TYPE_REDSTONE_TORCH,\n    VOXEL_TYPE_LEVER,\n    VOXEL_TYPE_BUTTON,\n    VOXEL_TYPE_REDSTONE_REPEATER,\n    VOXEL_TYPE_REDSTONE_LAMP\n);\n\nconst int ITEM_TYPE_COUNT = ITEM_TYPE_ARRAY.length();\n\nvec4\ndrawVoxelTypeIcon (in vec2 pos, in float invScale, in uint type)\n{\n    vec4 color;\n\tif (type == VOXEL_TYPE_STONE)\n    {\n        color = vec4(STONE_COLOR, 1);\n    }\n    else if (type == VOXEL_TYPE_REDSTONE_DUST)\n    {\n        float t = min(abs(pos.x), abs(pos.y)) - REDSTONE_DUST_WIDTH * .5;\n        color.rgb = getEnergyColor(0U);\n        color.a = smoothstep(3., 0., t * invScale);\n    }\n    else if (type == VOXEL_TYPE_REDSTONE_TORCH)\n    {\n        color.rgb = getEnergyColor(MAX_REDSTONE_POWER);\n        float t = length(pos) - REDSTONE_TORCH_RADIUS;\n        color.a = smoothstep(3., 0., t * invScale);\n    } else if (type == VOXEL_TYPE_LEVER) {\n        vec3 energyCol = getEnergyColor(0u);\n        \n        // base\n        float t1 = sdBox(pos,vec2(.45,.72));\n        float a1 = smoothstep(3., 0., t1 * invScale);\n        \n        // hole\n        float t2 = sdBox(pos,vec2(.2,.47));\n        float a2 = smoothstep(3., 0., t2 * invScale);\n        \n        // lever\n        float t3 = sdBox(pos-vec2(0,-.41),vec2(.2));\n        float a3 = smoothstep(3., 0., t3 * invScale);\n        \n        color = vec4(0,0,0,0);\n        color.rgb = STONE_COLOR;\n        color.a = a1;\n        color = mix(color,vec4(energyCol,1.),a2);\n        color = mix(color,vec4(WOOD_COLOR,1.),a3);\n    } else if (type == VOXEL_TYPE_REDSTONE_LAMP) {\n        const float W = .13;\n        float t1 = -sdBox(pos,vec2(1))-W/2.;\n        float t2 = min(abs(pos.x),abs(pos.y));\n        float t3 = length(vec2(abs(pos.x), abs(pos.y)))-.5;\n        float tt = min(min(t1,t2),t3);\n        float alpha = smoothstep(1.5, -1.5, (abs(tt)-W) * invScale );\n        color.a = 1.;\n        color.rgb = mix(LAMP_COLOR,WOOD_COLOR,alpha);\n    }\n    \n    return color;\n}\n\n#define DEFINE_DEFAULT_API( CHANNEL, CHANNEL_ID ) \\\nImage_t globalImage;\\\nWorld_t globalWorld;\\\nvec2 globalCoord;\\\nvec4 globalPixel;\\\nvoid \\\ninitializeAPI (in vec2 fragCoord)\\\n{\\\n    globalPixel = vec4(0);\\\n    globalCoord = fragCoord;\\\n    globalImage.id = CHANNEL_ID;\\\n    globalImage.dim = ivec2(floor(iChannelResolution[CHANNEL_ID]));\\\n    globalWorld.realPos = ivec2(0, 1);\\\n    globalWorld.realDim = globalImage.dim - ivec2(0, 1);\\\n    globalWorld.virtualDim = getMaxWorldDim(globalWorld.realDim);\\\n}\\\nvec4 \\\nterminate (void) { return globalPixel; }\\\nvec4 \\\nreadVar (in int x)\\\n{\\\n    return texelFetch(CHANNEL, ivec2(x,0), 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in vec4 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = var;\\\n}\\\nvoid \\\nwriteVar (in int x, in vec3 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in vec2 var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0, 0);\\\n}\\\nvoid \\\nwriteVar (in int x, in float var)\\\n{\\\n    ivec2 coord = ivec2(floor(globalCoord));\\\n    if (all(equal(coord, ivec2(x,0)))) globalPixel = vec4(var, 0, 0, 0);\\\n}\\\nvoid \\\nwriteCamera (in int x, in Camera cam)\\\n{\\\n    writeVar(x, cam.pos);\\\n}\\\nCamera \\\nreadCamera (in int x)\\\n{\\\n\tvec4 var;\\\n    Camera cam;\\\n    var = readVar(x);\\\n    cam.pos = var.xyz;\\\n    return cam;\\\n}\\\nImage_t getImage (void) { return globalImage; } \\\nWorld_t getWorld (void) { return globalWorld; } \\\nivec3 getWorldVirtual (void) { return getImageToWorldVirtual(getWorld(), getImage(), ivec2(floor(globalCoord))); }\\\nbool isCurrentWorldPos (in ivec3 pos) { return all(equal(getWorldVirtual(), pos)); }\\\nVoxel \\\nreadVoxel (in ivec3 pos)\\\n{\\\n    Voxel dst;\\\n    vec4 data = texelFetch(CHANNEL, getWorldVirtualToImage(getWorld(), getImage(), pos), 0);\\\n    dst = Voxel(uint(data.x), uint(data.y), uint(data.z));\\\n    return dst;\\\n}\\\nbool isVoxelAtCoordOpaque (in ivec3 p)\\\n{\\\n\treturn checkFlag(readVoxel(p).type, VOXEL_TYPE_OPAQUE);\\\n}\\\nbool isVoxelAtCoordDustConnectable (in ivec3 coord, out int zOffset, bool isVoxelAboveOpaque)\\\n{\\\n    Voxel voxels[3] = Voxel[3](\\\n        readVoxel(coord + ivec3(0,0,-1)),\\\n        readVoxel(coord),\\\n        readVoxel(coord + ivec3(0,0,1))\\\n    );\\\n    \\\n    bool isConnectable = ((voxels[0].type == VOXEL_TYPE_REDSTONE_DUST && voxels[1].type != VOXEL_TYPE_STONE\\\n        || voxels[1].type == VOXEL_TYPE_REDSTONE_DUST\\\n        || voxels[2].type == VOXEL_TYPE_REDSTONE_DUST)\\\n        && !isVoxelAboveOpaque)\\\n        || voxels[1].type == VOXEL_TYPE_REDSTONE_TORCH\\\n        || voxels[1].type == VOXEL_TYPE_LEVER;\\\n    \\\n    if (voxels[0].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = -1;\\\n    }\\\n    \\\n    if (voxels[1].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = 0;\\\n    }\\\n    \\\n    if (voxels[2].type == VOXEL_TYPE_REDSTONE_DUST && !isVoxelAboveOpaque)\\\n    {\\\n    \tzOffset = 1;\\\n    }\\\n    \\\n    return isConnectable;\\\n}\\\nvoid \\\nwriteVoxel (in Voxel voxel)\\\n{\\\n    globalPixel = vec4(voxel.type, voxel.energy, voxel.facing, 0);\\\n}\n\n\n\n// Creative Commons Attribution-ShareAlike 4.0 International Public License\n// Created by David Hoskins. May 2018\n\n\n// Almost a direct copy of most of \"Simplest Fastest 2D Hash\" with additional hash types.\n// https://www.shadertoy.com/view/MdcfDj\n\n// For use in WebGL 2 shaders.\n// The float versions should still be in integer steps, but they can be negetive.\n\n\n// The defines don't need to change for scaling purposes,\n// but I'll keep them in for any future needs.\n\n#define UI0 1597334673U\n#define UI1 3812015801U\n#define UI2 uvec2(UI0, UI1)\n#define UI3 uvec3(UI0, UI1, 2798796415U)\n#define UIF (1.0 / float(0xffffffffU))\n\n// The labeling refers to the number of values - hash(out)(in)...\n//---------------------------------------------------------------------------------------------------------------\nfloat hash11(uint q)\n{\n\tuvec2 n = q * UI2;\n\tq = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\nfloat hash11(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tuint q = (n.x ^ n.y) * UI0;\n\treturn float(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash12(uvec2 q)\n{\n\tq *= UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash12(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p)) * UI2;\n\tuint n = (q.x ^ q.y) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nfloat hash13(uvec3 q)\n{\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\nfloat hash13(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq *= UI3;\n\tuint n = (q.x ^ q.y ^ q.z) * UI0;\n\treturn float(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash21(uint q)\n{\n\tuvec2 n = q * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash21(float p)\n{\n\tuvec2 n = uint(int(p)) * UI2;\n\tn = (n.x ^ n.y) * UI2;\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash22(uvec2 q)\n{\n\tq *= UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\nvec2 hash22(vec2 p)\n{\n\tuvec2 q = uvec2(ivec2(p))*UI2;\n\tq = (q.x ^ q.y) * UI2;\n\treturn vec2(q) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec2 hash23(uvec3 q)\n{\n\tq *= UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\treturn vec2(n) * UIF;\n}\n\nvec2 hash23(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tuvec2 n = (q.x ^ q.y ^ q.z) * UI2;\n\n\treturn vec2(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash31(uint q)\n{\n\tuvec3 n = q * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\nvec3 hash31(float p)\n{\n\n\tuvec3 n = uint(int(p)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash32(uvec2 q)\n{\n\tuvec3 n = q.xyx * UI3;\n\tn = (n.x ^ n.y ^n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\nvec3 hash32(vec2 q)\n{\n\tuvec3 n = uvec3(ivec3(q.xyx)) * UI3;\n\tn = (n.x ^ n.y ^ n.z) * UI3;\n\treturn vec3(n) * UIF;\n}\n\n//---------------------------------------------------------------------------------------------------------------\nvec3 hash33(uvec3 q)\n{\n\tq *= UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n\nvec3 hash33(vec3 p)\n{\n\tuvec3 q = uvec3(ivec3(p)) * UI3;\n\tq = (q.x ^ q.y ^ q.z)*UI3;\n\treturn vec3(q) * UIF;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcWw.jpg", "access": "api", "license": "cc-by-sa-3.0", "functions": [[322, 322, 354, 354, 416], [418, 418, 451, 451, 513], [515, 515, 547, 547, 609], [1291, 1291, 1327, 1327, 1452], [1454, 1504, 1541, 1541, 1700], [1701, 1701, 1720, 1720, 1774], [1775, 1775, 1794, 1794, 2025], [2026, 2026, 2045, 2045, 2115], [2116, 2116, 2135, 2135, 2199], [2201, 2225, 2244, 2244, 2494], [2495, 2495, 2514, 2514, 2581], [2582, 2582, 2601, 2601, 2840], [2841, 2841, 2860, 2860, 2898], [2899, 2899, 2918, 2918, 3101], [3102, 3102, 3121, 3121, 3284], [3285, 3285, 3304, 3304, 3452], [3453, 3453, 3472, 3472, 3581], [3582, 3582, 3601, 3601, 3654], [3655, 3655, 3674, 3674, 3746], [3747, 3747, 3766, 3766, 3920], [3921, 3921, 3940, 3940, 3961], [3962, 3962, 3981, 4000, 4157], [4158, 4158, 4177, 4177, 4267], [4268, 4268, 4287, 4287, 4308], [4309, 4309, 4328, 4328, 4411], [4412, 4412, 4431, 4431, 4470], [4471, 4471, 4490, 4490, 4708], [4709, 4709, 4728, 4728, 4990], [4991, 4991, 5010, 5010, 5148], [5149, 5149, 5168, 5168, 5197], [5198, 5198, 5217, 5217, 5290], [5291, 5291, 5310, 5310, 5441], [5442, 5442, 5461, 5461, 5526], [5527, 5527, 5546, 5546, 5655], [5656, 5656, 5675, 5675, 5834], [5836, 5848, 5867, 5867, 6092], [6094, 6094, 6113, 6113, 6376], [6377, 6377, 6396, 6396, 6697], [6698, 6698, 6717, 6717, 6995], [6996, 6996, 7015, 7015, 7241], [7242, 7242, 7261, 7261, 7465], [7466, 7466, 7485, 7485, 7920], [7921, 7921, 7940, 7940, 8098], [8099, 8099, 8118, 8118, 8275], [8276, 8276, 8295, 8295, 8554], [8555, 8555, 8574, 8574, 8770], [8771, 8771, 8790, 8790, 8927], [8928, 8928, 8947, 8947, 9196], [9197, 9197, 9216, 9216, 9415], [9416, 9416, 9435, 9435, 9502], [9503, 9503, 9522, 9522, 9751], [9752, 9752, 9771, 9771, 9956], [9957, 9957, 9976, 9976, 10260], [10261, 10261, 10280, 10280, 10554], [10555, 10555, 10574, 10574, 10710], [10711, 10711, 10730, 10730, 10905], [10906, 10906, 10925, 10925, 10998], [10999, 10999, 11018, 11018, 11149], [11150, 11150, 11169, 11169, 11250], [11251, 11251, 11270, 11270, 11455], [11456, 11456, 11475, 11475, 11648], [11650, 11660, 11680, 11680, 11884], [11885, 11885, 11905, 11905, 12178], [12179, 12179, 12199, 12199, 12373], [12374, 12374, 12394, 12394, 12584], [12585, 12585, 12605, 12605, 12957], [12958, 12958, 12978, 12978, 13273], [13274, 13274, 13294, 13294, 13415], [13416, 13416, 13436, 13436, 13598], [13599, 13599, 13619, 13619, 13900], [13901, 13901, 13921, 13921, 13999], [14001, 14011, 14032, 14032, 14083], [14084, 14084, 14106, 14106, 14177], [14178, 14178, 14201, 14201, 14281], [14282, 14282, 14307, 14307, 14535], [14536, 14536, 14558, 14558, 14699], [14700, 14700, 14723, 14723, 14765], [14766, 14766, 14789, 14789, 14867], [14868, 14868, 14893, 14893, 15033], [15034, 15034, 15057, 15057, 15154], [15155, 15155, 15176, 15176, 15309], [15310, 15310, 15331, 15331, 15389], [15390, 15390, 15411, 15411, 15562], [15563, 15563, 15584, 15584, 15639], [15640, 15640, 15659, 15659, 15749], [15750, 15750, 15769, 15769, 15806], [15807, 15807, 15828, 15828, 16007], [16008, 16008, 16028, 16028, 16421], [16422, 16422, 16441, 16441, 16511], [16512, 16512, 16532, 16532, 16590], [16591, 16591, 16613, 16613, 16776], [16777, 16777, 16800, 16800, 16840], [16841, 16841, 16863, 16863, 17111], [17112, 17112, 17135, 17135, 17175], [17177, 17177, 17227, 17227, 17273], [17274, 17274, 17326, 17326, 17363], [21450, 21450, 21499, 21499, 21648], [21650, 21650, 21705, 21705, 22115], [22117, 22117, 22157, 22157, 22220], [22222, 22222, 22262, 22262, 22436], [22438, 22438, 22497, 22597, 23476], [23478, 23478, 23534, 23534, 23574], [23576, 23576, 23632, 23632, 23718], [23720, 23720, 23785, 23785, 23887], [23889, 23889, 23921, 23921, 27658], [27844, 27844, 27873, 27873, 27913], [27915, 27915, 27983, 27983, 28036], [28038, 28038, 28181, 28181, 28334], [28336, 28336, 28435, 28435, 28526], [30644, 30673, 30701, 30701, 31054], [31056, 35472, 35530, 35530, 35668], [35670, 35670, 35743, 35743, 36382], [37931, 37931, 37957, 37957, 38151], [38153, 38153, 38201, 38201, 38286], [38288, 38288, 38379, 38379, 39966], [39967, 42694, 42791, 42791, 43882], [43884, 43884, 43977, 43977, 48970], [48972, 48972, 49064, 49064, 50303], [50305, 50305, 50391, 50391, 53249], [53315, 53315, 53478, 53478, 54236], [63662, 63662, 63685, 63685, 63748], [64426, 64426, 64484, 64484, 67514]], "test": "untested"}
{"id": "ttjyWD", "name": "Planetoids", "author": "jarble", "description": "This galaxy of planets has an interesting fractal pattern.", "tags": ["3d", "raymarching", "planets"], "likes": 2, "viewed": 299, "published": 3, "date": "1594417219", "time_retrieved": "2024-07-30T20:56:07.757656", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n//rotation from https://www.shadertoy.com/view/MlyBzG\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*10.0;\n\n\n\t\n    float result1 = 0.0;\n    const float size = 1000.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0*3.0; i *= 3.0){\n        //float d1 = 5.0;\n        float i2 = i*i;\n        p += sin(p.yzx/size/i2/5.0)*size;\n        p = sin(p/i/size)*i2*size;\n        result += (length(p)-size/i2)/i2;\n        p /= 1.1;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p += sin(p);\n    p /= scale*100.0;\n    return sin(vec3(sceneSDF(p*5.0)+.5,sceneSDF(p.yzx*2.0),sceneSDF(p.zxy*3.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(40.0,0.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjyWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[617, 617, 641, 641, 1076], [1078, 1078, 1106, 1106, 1252], [1255, 1676, 1767, 1767, 2079], [2094, 2348, 2413, 2413, 2545], [2547, 2636, 2665, 2665, 2975], [2977, 3469, 3609, 3609, 4219], [4221, 4591, 4676, 4676, 5091], [5093, 5420, 5469, 5504, 5635], [5637, 5637, 5694, 5694, 6798]], "test": "untested"}
{"id": "Wl2cW1", "name": "Curl Noise Animation", "author": "JonManatee", "description": "Demo of using Curl Noise generated from a tiling input of simplex noise to create an effect similar to the \"Shadow Move\" effect from Killer Instinct (2013). This was created as an example to accompany this blog post: \nhttps://www.jonmanatee.com/blog/2020/", "tags": ["noise"], "likes": 9, "viewed": 1192, "published": 3, "date": "1594411138", "time_retrieved": "2024-07-30T20:56:08.660243", "image_code": "// Demo of using Curl Noise generated from a tiling input of simplex noise to create\n// an effect similar to the \"Shadow Move\" effect from Killer Instinct (2013)\n// this was created as an example to accompany this blog post:\n// https://www.jonmanatee.com/blog/2020/7/3/shadow-move-rendering-in-killer-instinct-season-3html\n\n// most of the interesting bits are in other files\n// Buffer A: noise + curl calculation\n// Buffer B: video input + green screen removal\n// Buffer C: effect simulation + feedback\n\n// for more information about curl noise, this paper is a great resource:\n// https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph2007-curlnoise.pdf\n\n// set this to 1 to see a side by side visualization\n#define DISPLAY_NOISE_PREVIEW 0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 UV = fragCoord.xy/iResolution.xy;\n\tvec3 color = vec3(0.0);\n    \n#if DISPLAY_NOISE_PREVIEW\n    // noise value on left, curl on right\n    vec4 bufferA = texture(iChannel2, UV);\n    if (UV.x <= 0.5) \n    {\n        color.rgb = vec3(bufferA.b);\n    }\n    else\n    {\n        vec2 flowVector = bufferA.rg * 2.0 - 1.0;\n        // multiply by a large number so that vectors are easier to see\n        float visualizationMultiplier = 25.0; \n        color.rg = (flowVector * visualizationMultiplier) * 0.5 + 0.5; \n    }\n    \n\t\n\tcolor *= smoothstep(0.0, 0.005, abs(0.5-UV.x)); // draw divider line\n\t\n#else    \n    // composite shadow effect\n    {\n        vec4 bufferC = texture(iChannel0, UV);\n        color = mix(color, bufferC.rgb, bufferC.a);\n    }\n    \n    // composite raw video on top\n    {\n        vec4 bufferB = texture(iChannel1, UV);\n        color = mix(color, bufferB.rgb, bufferB.a);\n    }\n#endif\n    \n\tfragColor = vec4(color, 1.0);\n\n    return;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Buffer A: holds 256x256 tiled curl flow map in RG, source data in B for visualization purposes\n// this could be replaced with other vector fields\n// for example: instead of mapping to a tiling texture, \n// sample 3D noise directly with screenXY in two dimensions and time in the third\n// analytic gradients could be used to avoid finite differences, \n// see: https://www.shadertoy.com/view/4dffRH\n\n\n// A 2D tiling field can be created by mapping UV to a torus in 3D noise\n// 3D simplex noise code here cribbed from \"Improved 3D Simplex Noise\" \n// https://www.shadertoy.com/view/lt3SRX\n// Any 2D tiling input works for this example\n#define MOD3 vec3(.1031,.11369,.13787)\nvec3 random3(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\n// map U + V to Torus and sample noise\nfloat TiledNoise( in vec2 Coord )\n{\n    float U = Coord.x * 2.0 * 3.14159;\n    float V = Coord.y * 2.0 * 3.14159;\n    float A = 0.5;\n    float C = 1.20;\n    \n\tfloat X = (C + A * cos(V)) * cos(U);\n    float Y = (C + A * cos(V)) * sin(U);\n    float Z = A * sin(V);\n    \n    return simplex3d(vec3(X, Y, Z));\n}\n\n// interpolate between two noise samples offset by 0.5 in each dimension\nfloat InterpolatedNoise( in vec2 Coord, in float tValue )\n{\n\tfloat NoiseSampleA = TiledNoise(Coord);\n    float NoiseSampleB = TiledNoise(Coord + vec2(0.5,0.5));\n\treturn mix(NoiseSampleA, NoiseSampleB, tValue);\n}\n\n// calculate the Curl using finite differences with 4 samples in each direction\nvec2 ComputeCurl( in vec2 Coord, in float tValue, in vec2 StepSize, in float FlowMultiplier )\n{\n    // integration using 5 points\n    // ( n1 - 8n2 + 8n3 - n4 ) / (12 * t)\n    // where n1 is f(x - 2t), n2 is f(x - t), n3 is f(x + t), and n4 is f(x + 2t)\n    \n    // vertical direction\n    float n1 = InterpolatedNoise(Coord - vec2(0.0, 2.0 * StepSize.y), tValue) * FlowMultiplier;\n    float n2 = InterpolatedNoise(Coord - vec2(0.0, 1.0 * StepSize.y), tValue) * FlowMultiplier;\n    float n3 = InterpolatedNoise(Coord + vec2(0.0, 1.0 * StepSize.y), tValue) * FlowMultiplier;\n    float n4 = InterpolatedNoise(Coord + vec2(0.0, 2.0 * StepSize.y), tValue) * FlowMultiplier;\n    \n    float a = (n1 - 8.0 * n2 + 8.0 * n3 - n4) * (1.0 / 12.0);\n    \n    // horizontal direction\n   \tn1 = InterpolatedNoise(Coord - vec2(2.0 * StepSize.x, 0.0), tValue) * FlowMultiplier;\n    n2 = InterpolatedNoise(Coord - vec2(1.0 * StepSize.x, 0.0), tValue) * FlowMultiplier;\n    n3 = InterpolatedNoise(Coord + vec2(1.0 * StepSize.x, 0.0), tValue) * FlowMultiplier;\n    n4 = InterpolatedNoise(Coord + vec2(2.0 * StepSize.x, 0.0), tValue) * FlowMultiplier;\n    \n    float b = (n1 - 8.0 * n2 + 8.0 * n3 - n4) * (1.0 / 12.0);\n                 \n    return vec2(a, -b);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float cNoiseAnimationSpeed = 0.5;\n    float cNoiseMultipler = 0.1;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // interpolate t value back in forth in [0,1] range\n    float ip;\n\tfloat tValue = modf(iTime * cNoiseAnimationSpeed, ip);\n\ttValue = mod(ip, 2.0) > 0.0 ? tValue : 1.0 - tValue;\n    tValue = smoothstep(0.0, 1.0, tValue);\n    \n    vec4 color = vec4(0.0);\n    \n    // tile 256x256 noise across screenspace buffer and get curl\n    {\n    \tvec2 UV = fragCoord.xy / 256.0;\n        vec2 StepSize = vec2(1.0/256.0);\n\t\tvec2 curl = ComputeCurl(UV, tValue, StepSize, cNoiseMultipler);\n        color.rg = vec2(0.5 + 0.5*curl);\n        float noiseValue = InterpolatedNoise(UV, tValue);\n        color.b = 0.5 + 0.5*noiseValue;\n    }\n    \n\tfragColor = color;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Buffer B: video input for alpha compositing in other passes\n// this is similar to how character color was injected into the effect for KI Seasons 1+2\n// as detailed in my blog, this could be expanded upon for other arbitrary data beyond color\n\n// matte composite from green screen input\n// credit to iq: https://www.shadertoy.com/view/XsfGzn\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 q = fragCoord.xy / iResolution.xy;\n    \n\tvec3 fg = texture( iChannel0, q ).xyz;\t\n    \n    float maxrb = max( fg.r, fg.b );\n    float k = clamp( (fg.g-maxrb)*5.0, 0.0, 1.0 );   \n\n    float dg = fg.g; \n    fg.g = min( fg.g, maxrb*0.8 ); \n    fg += dg - fg.g;\n\n    fragColor = vec4( fg, 1.0 - k );\n}", "buffer_b_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "// Buffer C: feedback simulation\n// reads history buffer with a distorted vector from the flow map, decreases opacity of each pixel over time\n// does not inject with new data every frame to allow the effect to breathe a little more\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float decayRate = 0.25; // rate effect fades out\n    float flowSpeed = 0.25; // multiplier on offset to slow down flow\n    int injectEveryNFrames = 6; // inject image into feedback every N frames\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // sample video input\n    vec4 color = texture(iChannel1, uv);\n\t\n    // sample flow vector and sample history\n    vec2 flowVector = texture(iChannel0, uv).xy * 2.0 - vec2(1.0);\n    flowVector *= flowSpeed;\n    vec4 historyColor = texture(iChannel2, uv - flowVector);\n    \n    // inject if needed\n    if (iFrame % injectEveryNFrames == 0)\n    {\n    \tcolor = historyColor * (1.0 - color.a) + color * color.a;\n    }\n    else\n    {\n     \tcolor = historyColor;   \n    }\n    \n    // decay\n    color.a = clamp(color.a - decayRate * iTimeDelta, 0., 1.);\n        \n    fragColor = color;\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2cW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[740, 740, 797, 797, 1750]], "test": "untested"}
{"id": "3ljyDD", "name": "Hexagonal tiling + cog wheels", "author": "mrange", "description": "License CC0: Hexagonal tiling + cog wheels\nNothing fancy, just hexagonal tiling + cog wheels\n", "tags": ["2d", "tiling", "cogs"], "likes": 45, "viewed": 901, "published": 3, "date": "1594399136", "time_retrieved": "2024-07-30T20:56:09.556846", "image_code": "// License CC0: Hexagonal tiling + cog wheels\n//  Nothing fancy, just hexagonal tiling + cog wheels\n\n#define PI      3.141592654\n#define TAU     (2.0*PI)\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat modPolar(inout vec2 p, float repetitions) {\n  float angle = 2.0*PI/repetitions;\n  float a = atan(p.y, p.x) + angle/2.;\n  float r = length(p);\n  float c = floor(a/angle);\n  a = mod(a,angle) - angle/2.;\n  p = vec2(cos(a), sin(a))*r;\n  // For an odd number of repetitions, fix cell index of the cell in -x direction\n  // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n  if (abs(c) >= (repetitions/2.0)) c = abs(c);\n  return c;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst float smallCount = 16.0;\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz*1.0, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(length(p1) < length(p2)));\n  vec2 n = p3 - p;\n  p = p3;\n\n  return n;\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat unevenCapsule(vec2 p, float r1, float r2, float h) {\n  p.x = abs(p.x);\n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(p,vec2(-b,a));\n  if( k < 0.0 ) return length(p) - r1;\n  if( k > a*h ) return length(p-vec2(0.0,h)) - r2;\n  return dot(p, vec2(a,b) ) - r1;\n}\n\nfloat cogwheel(vec2 p, float innerRadius, float outerRadius, float cogs, float holes) {\n  float cogWidth  = 0.25*innerRadius*TAU/cogs;\n  \n  float d0 = circle(p, innerRadius);  \n    \n  vec2 icp = p;\n  modPolar(icp, holes);\n  icp -= vec2(innerRadius*0.55, 0.0);\n  float d1 = circle(icp, innerRadius*0.25);  \n\n  vec2 cp = p;\n  modPolar(cp, cogs);\n  cp -= vec2(innerRadius, 0.0);\n  float d2 = unevenCapsule(cp.yx, cogWidth, cogWidth*0.75, (outerRadius-innerRadius));\n\n  float d3 = circle(p, innerRadius*0.20);  \n  \n  float d = 1E6;  \n  d = min(d, d0);\n  d = pmin(d, d2, 0.5*cogWidth);\n  d = min(d, d2);\n  d = max(d, -d1);\n  d = max(d, -d3);\n  \n  return d;\n}\n\nfloat ccell1(vec2 p, float r) {\n  float d = 1E6;\n  const float bigCount = 60.0;\n  \n  vec2 cp0 = p;\n  rot(cp0, -iTime*TAU/bigCount);\n  float d0 = cogwheel(cp0, 0.36, 0.38, bigCount, 5.0);\n  \n  vec2 cp1 = p;\n  float nm = modPolar(cp1, 6.0);\n\n  cp1 -= vec2(0.5, 0.0);\n  rot(cp1, 0.2+TAU*nm/2.0 + iTime*TAU/smallCount);\n  float d1 = cogwheel(cp1, 0.11, 0.125, smallCount, 5.0);\n\n  d = min(d, d0);\n  d = min(d, d1);\n  return d;\n}\n\nfloat ccell2(vec2 p, float r) {\n  float d = 1E6;\n  vec2 cp0 = p;\n  float nm = modPolar(cp0, 6.0);\n  vec2 cp1 = cp0;\n  const float off = 0.275;\n  const float count = smallCount + 2.0;\n  cp0 -= vec2(off, 0.0);\n  rot(cp0, 0.+TAU*nm/2.0 - iTime*TAU/count);\n  float d0 = cogwheel(cp0, 0.09, 0.105, count, 5.0);\n  \n\n  cp1 -= vec2(0.5, 0.0);\n  rot(cp1, 0.2+TAU*nm/2.0 + iTime*TAU/smallCount);\n  float d1 = cogwheel(cp1, 0.11, 0.125, smallCount, 5.0);\n  \n  float l = length(p);\n  float d2 = l - (off+0.055);\n  float d3 = d2 + 0.020;;\n  \n  vec2 tp0 = p;\n  modPolar(tp0, 60.0);\n  tp0.x -= off;\n  float d4 = box(tp0, vec2(0.0125, 0.005));\n\n  float ctime = -(iTime*0.05 + r)*TAU;\n\n  vec2 tp1 = p;\n  rot(tp1, ctime*12.0);\n  tp1.x -= 0.13;\n  float d5 = box(tp1, vec2(0.125, 0.005));\n\n  vec2 tp2 = p;\n  rot(tp2, ctime);\n  tp2.x -= 0.13*0.5;\n  float d6 = box(tp2, vec2(0.125*0.5, 0.0075));\n\n  float d7 = l - 0.025;\n  float d8 = l - 0.0125;\n\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  d = max(d, -d3);\n  d = min(d, d4);\n  d = min(d, d5);\n  d = min(d, d6);\n  d = min(d, d7);\n  d = max(d, -d8);\n\n  return d;\n}\n\nfloat df(vec2 p, float scale, inout vec2 nn) {\n  p /= scale;\n  nn = hextile(p);\n  nn = round(nn);\n  float r = hash(nn);\n\n  float d;;\n  \n  if (r < 0.5) {\n    d = ccell1(p, r);  \n  } else {\n    d = ccell2(p, r);\n  }\n  \n  return d*scale;\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  //col = saturate(col);\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n  float tm = iTime*0.1;\n  p += vec2(cos(tm), sin(tm*sqrt(0.5)));\n  float z = mix(0.5, 1.0, pcos(tm*sqrt(0.3)));\n  float aa = 4.0 / iResolution.y;\n\n  vec2 nn = vec2(0.0);\n  float d = df(p, z, nn);\n\n  vec3 col = vec3(160.0)/vec3(255.0);\n  vec3 baseCol = vec3(0.3);\n  vec4 logoCol = vec4(baseCol, 1.0)*smoothstep(-aa, 0.0, -d);\n  col = mix(col, logoCol.xyz, pow(logoCol.w, 8.0));  \n  col += 0.4*pow(abs(sin(20.0*d)), 0.6);  \n  \n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyDD.jpg", "access": "api", "license": "cc0-1.0", "functions": [[209, 209, 233, 233, 303], [305, 305, 326, 326, 355], [357, 357, 390, 390, 475], [477, 477, 526, 526, 928], [930, 930, 969, 969, 1058], [1166, 1166, 1194, 1293, 1460], [1462, 1462, 1493, 1493, 1519], [1521, 1521, 1548, 1548, 1624], [1626, 1626, 1684, 1684, 1909], [1911, 1911, 1998, 1998, 2564], [2566, 2566, 2597, 2597, 2990], [2992, 2992, 3023, 3023, 4095], [4097, 4097, 4143, 4143, 4333], [4335, 4335, 4372, 4397, 4646], [4648, 4648, 4700, 4700, 5289]], "test": "untested"}
{"id": "Wl2yDW", "name": "Wavy thing", "author": "z0rg", "description": "Bleep bloop", "tags": ["2d", "waves", "sdf", "pattern"], "likes": 9, "viewed": 198, "published": 3, "date": "1594383559", "time_retrieved": "2024-07-30T20:56:10.439485", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.141592653;\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat sub(float a, float b)\n{\n  return max(a,-b);\n}\nfloat sdloz(vec2 p, float r)\n{\n  return lenny(p)-r;\n}\n\nfloat sdf_sin(vec2 p, float freq, float amp, float th)\n{\n  return sub(p.y - sin(p.x*freq)*amp, p.y - sin(p.x*freq)*amp+th);\n}\n\nfloat cir(vec2 p, float r)\n{\n  float a =p.x;// atan(p.y,p.x)+r*sin(2.*r+time*.1);\n  return p.y-sin(a*7.-iTime)*.15\n  +sin(a*3.-iTime)*.2\n  +sin(a*5.+sin(a))*.02;\n}\n\n\nfloat border(vec2 p, float th, float r)\n{\n  return sub(cir(p,r),cir(p+vec2(0.,th),r));\n}\nvec3 rdr(vec2 uv)\n{\n  vec2 ouv = uv;\n  uv-= vec2(0.,.7);\n  vec3 col;\n  int i = 0;\n  while (i<32)\n  {\n    float fi = float(i);\n    col += vec3(sat(pow(abs(uv.y),4.))*2.,.8,sat(abs(uv.x)+.5))*(1.-sat(border(uv+vec2(0.,fi*.2),0.02*fi, .8+fi)*100.));\n    ++i;\n  }\n\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\nuv -= vec2(.5)*iResolution.xy/iResolution.xx;\nuv*=6.;\n\nvec3 col = rdr(uv)+(rdr(uv*vec2(.5,1.)))*.2;\n\nif (abs(uv.x)<1.5)\ncol = 1.-col;\n  fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2yDW.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[427, 427, 445, 445, 520], [522, 522, 543, 543, 573], [574, 574, 594, 594, 621], [623, 623, 652, 652, 674], [675, 675, 705, 705, 728], [730, 730, 786, 786, 855], [857, 857, 885, 885, 1020], [1023, 1023, 1064, 1064, 1111], [1112, 1112, 1131, 1131, 1388], [1390, 1390, 1447, 1447, 1656]], "test": "untested"}
{"id": "3ljyDW", "name": "Wavy Weave", "author": "Oggbog", "description": "Wobbly repeating weave pattern", "tags": ["pattern", "repeating"], "likes": 7, "viewed": 394, "published": 3, "date": "1594382392", "time_retrieved": "2024-07-30T20:56:11.339080", "image_code": "float box(vec2 uv, float r, float t){\n    float m = (step(r,abs(uv.x)))*.5-step(abs(uv.y),.5-r-t);\n    m = max(m,(step(r,abs(uv.y)))*.5);\n    m += (step(r+t,abs(uv.x)))-step(abs(uv.y),.5-r-t/4.);\n    m = max(m,(step(r+t,abs(uv.y))));\n    float p = (step(r,abs(uv.x))-step(r+t,abs(uv.x))-step(abs(uv.y),r+t))/2.;\n    if (p>0.) m -= .5;\n    return m;\n}\nfloat cros(vec2 uv, float r, float t){\n    float m = step(abs(uv.x),r+t)*0.5;\n    m = max(m,step(abs(uv.y),r+t)*0.5);\n    m += step(abs(uv.x),r);\n    m = max(m,step(abs(uv.y),r)-step(abs(uv.x),r+t));\n    \n    \n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv.y += cos(uv.y*3.+uv.x*4.+iTime*2.)*.05;\n    float a = 3.142/4.;  \n    uv = uv*mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    uv = fract(uv * 5.)-.5;\n    vec3 col = vec3(0.);\n\t\n    float m = cros(uv,.15,.04);\n    col += m;\n    m = box(uv,.3,.04);\n    \n    if (m>0.) col = vec3(m);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 350], [351, 351, 389, 389, 581], [583, 583, 640, 640, 1051]], "test": "untested"}
{"id": "3t2yWW", "name": "Silver / Pell Spiral", "author": "jeyko", "description": "https://www.shadertoy.com/view/wljyWh       - I learned about this from this shader\nhttps://en.wikipedia.org/wiki/Silver_ratio  - Wikipedia page\nhttps://www.youtube.com/watch?v=7lRgeTmxnlg - Numberphile video ", "tags": ["spiral", "silver", "mean", "ratio", "pell"], "likes": 12, "viewed": 416, "published": 3, "date": "1594373688", "time_retrieved": "2024-07-30T20:56:12.391267", "image_code": "// How can I make this zoom nicely?\n// The zoom is currently... number-crunched\n\n// https://www.shadertoy.com/view/wljyWh       - I learned about this from this shader\n// https://en.wikipedia.org/wiki/Silver_ratio  - Wikipedia page\n// https://www.youtube.com/watch?v=7lRgeTmxnlg - Numberphile video  \n\n\n#define ratio 1./(1. + sqrt(2.))\n\n\nfloat sdBox(vec2 p, float s){\n\tp = abs(p) - s;\n\treturn max(p.y, p.x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    \n    float d = 10e6;\n    \n    uv /= pow(2.,mod(iTime,  2.543106606327)); // this line thanks to Fabrice! \n    \n    uv.x += sqrt(2.);\n    \n    \n\n    \n    float s = 1.;\n    \n    \n        \n    \n    float iters = 9.;\n    \n    vec2 p = uv;\n    \n    for(float i = 0.; i < 2.; i++){\n        if (i == 0.){\n            // left spiral\n            float firstBox = sdBox(uv, s);\n            d = min(d,abs(firstBox));\n            d = min(d,abs(max(length(uv - vec2(s,-s)) - s*2., firstBox)));\n        }\n        if (i == 1.){\n            // right spiral\n        \tp = uv; s = 1.;\n\n            p.x -= s*2. + s * ratio*2.;\n\n            p.x = - p.x;\n            p.y = - p.y;\n\n            float firstBox = sdBox(p, s);\n            d = min(d,abs(firstBox));\n            d = min(d,abs(max(length(p - vec2(s,-s)) - s*2., firstBox)));        \n        }\n        \n        \n        \n        for(float j = 0.; j < iters; j++){\n\n            float dSpiral;\n            if ( mod(j, 4.) == 0. ){\n                p.xy -= vec2(s,s);\n                s *= ratio;\n                p.xy -= vec2(s,-s);\n\n                dSpiral = length(p - vec2(-s,-s)) - s*2.;\n            } else if ( mod(j, 4.) == 1. ){\n                p.xy -= vec2(s,-s);\n                s *= ratio;\n                p.xy -= vec2(-s,-s);\n\n                dSpiral = length(p - vec2(-s,s)) - s*2.;\n            } else if ( mod(j, 4.) == 2. ){\n\n                p.xy -= vec2(-s,-s);\n                s *= ratio;\n                p.xy -= vec2(-s,s);\n\n                dSpiral = length(p - vec2(s,s)) - s*2.;\n            } else if ( mod(j, 4.) == 3. ){\n\n                p.xy -= vec2(-s,s);\n                s *= ratio;\n                p.xy -= vec2(s,s);\n\n                dSpiral = length(p - vec2(s,-s)) - s*2.;\n            }\n\n            float dBox = sdBox(p, s);\n\n            d = min(d,\n                    ( min( abs(dBox), max( dSpiral, dBox)))\n                   );\n        }\n    }\n    \n    \n    \n    col = mix(col,vec3(1),smoothstep(abs(dFdx(uv.x)),0.,abs(d)));\n    \n    col = pow(col,vec3(0.4545)); // gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[338, 338, 367, 367, 409], [411, 411, 468, 468, 2648]], "test": "untested"}
{"id": "wlScWD", "name": "方块显隐2", "author": "miracleYang", "description": "方块显隐2", "tags": ["2d"], "likes": 2, "viewed": 261, "published": 3, "date": "1594359404", "time_retrieved": "2024-07-30T20:56:13.408547", "image_code": "float PI=3.1415926;\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\nfloat aa = 0.;\nfloat radio=0.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x*=iResolution.x/iResolution.y;\n    //uv.x+=.011;\n    radio=iResolution.x/iResolution.y;\n    \n    \n    //uv= (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //vec2 screen = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float backgroundColor =1.0;\n    \n    vec3 col = vec3(0);\n    uv *= 5.;\n    \n    vec2 c = fract(uv);\n    \n    vec2 id = floor(uv)+.5;\n    float n=Hash21(id);\n    \n    float width=.1;\n    \n    float t = iTime;\n    aa = abs(sin(t));    \n    vec2 edge =sin(c*PI);\n    //edge.x-=clamp(aa*2.-n,width,1.);\n    edge.x-=width;\n    edge.y-=width*radio;\n    \n    float x= step(.01,edge.x);\n    float y= step(.01,edge.y);\n    if(x== 0.&& y==0.)\n    {\n        col=vec3(0);\n    }\n    else if(x== 1. && y==1.)\n    {\n        col=vec3(1);\n    }\n    if(n<1.)\n    {\n        n-=aa;\n        n=clamp(n,0.,1.);\n    }\n    col=n*col;\n    \n    //col.z=1.;\n    //col+=step(.01,edge.x);\n    //col*=step(.01,edge.y);\n    //col.y=edge.y;\n    col=mix(vec3(0.),col,backgroundColor);\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlScWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 132], [133, 133, 150, 150, 270], [302, 302, 359, 409, 1476]], "test": "untested"}
{"id": "tlScWD", "name": "方块Noise", "author": "miracleYang", "description": "方块显隐", "tags": ["2d"], "likes": 0, "viewed": 240, "published": 3, "date": "1594359326", "time_retrieved": "2024-07-30T20:56:14.326094", "image_code": "float PI=3.1415926;\nfloat Hash21(vec2 p){\n    p = fract(p*vec2(234.34,435.345));\n    p+=dot(p,p+34.23);\n    return fract(p.x*p.y);\n}\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx*vec3(123.34,234.34,345.65));\n    a+=dot(a,a+34.45);\n    return fract(vec2(a.x*a.y,a.y*a.z));\n}\nfloat aa = 0.;\nfloat width=.1;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //uv= (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    //vec2 screen = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    //float backgroundColor =smoothstep(-.01,.01, cos(screen.x*PI)+.035);\n    \n    vec3 col = vec3(0);\n    uv *= 5.;\n    \n    float t = iTime;\n    aa = abs(sin(t));\n    \n    //vec2 c = fract(uv);\n    \n    vec2 id = floor(uv)+0.5;\n    float n=Hash21(id);\n    \n   \n    \n\n    fragColor = vec4(n,n,n,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScWD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 41, 41, 132], [133, 133, 150, 150, 270], [302, 302, 359, 409, 888]], "test": "untested"}
{"id": "wsBfzK", "name": "Wavelet Noise", "author": "BigWIngs", "description": "See comments for details.", "tags": ["noise", "wavelet"], "likes": 86, "viewed": 3847, "published": 3, "date": "1594353749", "time_retrieved": "2024-07-30T20:56:15.078083", "image_code": "// \"Wavelet Noise\" \n// The MIT License\n// Copyright © 2020 Martijn Steinrucken\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// I needed something as a base for a cheap water effect and thought this\n// might help someone. This has probably been done before cuz its quite a \n// simple concept. \n// See below for an expanded version if you wanna understand how it works!\n\nfloat WaveletNoise(vec2 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<4.; i++) {\n        vec2 q = p*s, g=fract(floor(q)*vec2(123.34,233.53));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3;// +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5)*mat2(cos(a),-sin(a),sin(a),cos(a));\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = p*mat2(.54,-.84, .84, .54)+i;\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    \n    col += WaveletNoise(uv*5., iTime, 1.24)*.5+.5; \n    if(col.r>.99) col= vec3(1,0,0); \n    if(col.r<0.01) col = vec3(0,0,1);\n    \n    fragColor = vec4(col,1.0);\n}\n\n/* The function above is a minification of the code below\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat GetWavelet(vec2 p, float z, float scale) {\n\tp *= scale;\n    \n    vec2 id = floor(p);\n    p = fract(p)-.5;\n    \n    float n = Hash21(id);\n    p *= Rot(n*100.);\n    float d = sin(p.x*10.+z);\n\n    d *= smoothstep(.25, .0, dot(p,p));\n    return d/scale;\n}\n\nfloat WaveletNoise(vec2 p, float phase, float scaleFactor) {\n    float d = 0.;\n    float scale = 1.;\n    float mag=0.;\n    for(float i=0.; i<4.; i++) {\n        d += GetWavelet(p, phase, scale);\n        p = p*mat2(.54,-.84, .84, .54)+i;\n        mag += 1./scale;\n        scale *= scaleFactor; \n    }\n    d /= mag;\n    return d;\n}\n*/\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsBfzK.jpg", "access": "api", "license": "mit", "functions": [[1513, 1513, 1559, 1604, 2051], [2053, 2053, 2110, 2110, 2404]], "test": "untested"}
{"id": "ttBcDW", "name": "Mossy jungle", "author": "jarble", "description": "Another interesting \"jungle\" fractal.", "tags": ["3d", "raymarching", "fractal", "rainforest"], "likes": 0, "viewed": 335, "published": 3, "date": "1594344793", "time_retrieved": "2024-07-30T20:56:16.080404", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= -3000.0;\n    return sin(vec3(sin(p/5.0)+sin(p/3.0)+sin(p/2.0)))/5.0+vec3(.3,.6,.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,sin(iTime/3.0)*20.0,cos(iTime/3.0)*20.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p*10.0))*.4+surface_color((p*100.0))*.6;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 20000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    p = (sin(sin(p.yzx+p)+p.yzx/i))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*10.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        p = p/200.0;\n    \tresult = max(result, result+planet_surface(p,i)/(i*i));\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 199], [202, 623, 714, 714, 1068], [1083, 1337, 1402, 1402, 1534], [1536, 1625, 1654, 1654, 1964], [1966, 2458, 2598, 2598, 3208], [3210, 3580, 3665, 3665, 4080], [4082, 4409, 4458, 4493, 4624], [4626, 4626, 4683, 4683, 5833]], "test": "untested"}
{"id": "wtSyDW", "name": "Fractal Starships", "author": "jarble", "description": "These fractal objects remind me of the spacecraft from Star Wars.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "spaceship"], "likes": 1, "viewed": 320, "published": 3, "date": "1594335148", "time_retrieved": "2024-07-30T20:56:17.051806", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    p = (sin(sin(p.yzx+p/i)+p.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*10.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n        p = p*i/size;\n    \tresult = max(result, result+planet_surface(p,i)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 2000.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0))/4.0)/4.0+vec3(.6);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*.1)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 891], [905, 905, 932, 932, 1081], [1083, 1083, 1140, 1140, 1811]], "test": "untested"}
{"id": "3lSyDD", "name": "ball lighting", "author": "VechirkoIgor", "description": "ball with dynamic lighting", "tags": ["dynamiclight"], "likes": 1, "viewed": 231, "published": 3, "date": "1594320395", "time_retrieved": "2024-07-30T20:56:17.857652", "image_code": "\nvec3 getLightDirection()\n{\n    vec3 direction;\n    direction.x = sin(iTime ) / 2.0f;\n    direction.y = direction.x;\n    direction.z = ( cos(iTime ) );\n    \n    return normalize(direction);\n}\n\nvec3 getViewDirection()\n{\n    return vec3( 0.0f, 0.0f, 1.0f );\n}\nvec3 getBallPointNormal( in vec2 vecFromBallCenter, in float ballRadius )\n{\n    vec3 result = vec3( 0.0f );\n    result.xy = vecFromBallCenter;\n    result.z = -sqrt( pow( ballRadius, 2.0f ) - ( pow(result.x, 2.0f ) + pow(result.y, 2.0f ) ) );\n    \n    return normalize(result);\n}\nvec4 calcAmbienComponent( in vec4 ambLight, in vec4 ambMat )\n{\n    return ambLight * ambMat;\n}\nvec4 calcDiffuseComponent( in vec4 diffuseLight, in vec4 diffMat, in vec3 pointNormal )\n{\n    float intesity = dot( -normalize(pointNormal), getLightDirection() );\n    \n    if ( intesity < 0.0f )\n    {\n        intesity = 0.0f;\n    }\n    \n    return diffuseLight * diffMat * intesity;\n}\nvec4 calcSpecularComponent( in vec4 specularLight, in vec4 specMat, in float shine, in vec3 pointNormal )\n{\n    vec3 reflectVec = reflect( -getLightDirection(), pointNormal );\n    float intensity = pow( max( 0.0f, dot( reflectVec, getViewDirection() ) ), 64.0f );\n    vec4 specLight = specularLight * specMat * intensity;\n    \n    return specLight;\n}\nvec4 getPointColor( in vec3 pointNormal, in vec4 matAmbient, vec4 matDiffuse, vec4 matSpecular, in float shine )\n{   \n    vec4 lightColor = vec4( 1.0f, 1.0f, 1.0f, 1.0f );\n    \n    vec4 result = calcAmbienComponent(lightColor, matAmbient);\n    result = result + calcDiffuseComponent( lightColor, matDiffuse, pointNormal );\n    result = result + calcSpecularComponent( lightColor, matSpecular, shine, pointNormal );\n    \n    return result;\n}\nvec4 getBackColor()\n{\n    return vec4( 0.2f, 0.2f, 0.2f, 1.0f );\n}\n\nstruct sBall\n{\n    vec3 pos;\n    float radius;\n    \n    vec4 matAbient;\n    vec4 matDiffuse;\n    vec4 matSpecular;\n    float shine;\n};\n\n\nsBall[] balls = sBall[]( sBall(vec3(0.5f, 0.5f, 0.0f), 0.1f * 800.0f, vec4( 0.329412f, 0.223529f, 0.027451f, 1.0f ), vec4( 0.780392f, 0.568627f, 0.113725f, 1.0f ) , vec4( 0.992157f, 0.941176f, 0.807843f, 1.0f ), 27.8974f ),\n                       \t sBall(vec3(0.8f, 0.3f, 0.0f), 0.09f * 800.0f, vec4( 0.329412f, 0.223529f, 0.027451f, 1.0f ), vec4( 0.780392f, 0.568627f, 0.113725f, 1.0f ) , vec4( 0.992157f, 0.941176f, 0.807843f, 1.0f ), 27.8974f ) \n                       );\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 resultColor;\n    \n    for( int ballIndx = 0; ballIndx < 1; ballIndx++ )\n    {\n        vec2 offsetFromBallCenter = fragCoord - vec2(balls[ballIndx].pos.xy) * iResolution.xy;\n        float distToBallCenter = length( offsetFromBallCenter );\n\n        if ( distToBallCenter <= balls[ballIndx].radius )\n        {\n            vec3 normalToBallPoint = getBallPointNormal( offsetFromBallCenter, balls[ballIndx].radius );\n            resultColor = getPointColor( normalToBallPoint, balls[ballIndx].matAbient, balls[ballIndx].matDiffuse, balls[ballIndx].matSpecular, balls[ballIndx].shine );\n            break;\n        }\n        else\n        {\n            resultColor = getBackColor();\n        }\n    }\n    \n    fragColor = resultColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyDD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 27, 27, 191], [193, 193, 218, 218, 257], [258, 258, 333, 333, 536], [537, 537, 599, 599, 631], [632, 632, 721, 721, 917], [918, 918, 1025, 1025, 1268], [1269, 1269, 1383, 1383, 1709], [1710, 1710, 1731, 1731, 1776], [2392, 2392, 2449, 2449, 3185]], "test": "untested"}
{"id": "WtByDW", "name": "Geometric cubes", "author": "Oggbog", "description": "A recreation of the classic geometric cube pattern", "tags": ["pattern", "geometric"], "likes": 3, "viewed": 309, "published": 3, "date": "1594305687", "time_retrieved": "2024-07-30T20:56:18.909838", "image_code": "vec2 tile(vec2 uv, float s){\n    // thanks to book of shaders for the brick tile algorithm :-)\n    // https://thebookofshaders.com/09/\n    uv *= s;\n    uv.x += step(1., mod(uv.y,2.0)) * 0.5;\n\n    return fract(uv);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.y;\n    uv.x += iTime/2.;\n    uv.y += sin(iTime)*.2;\n    \n   \tvec3 col = vec3(0.);\n    \n\tuv = tile(uv,6.)-.5;\n    \n    col = (uv.x>0. && uv.y<0.) || (uv.x<0. && uv.y>.0) ? vec3(.1,.4,.1): vec3(0.2,0.7,0.2);\n    \n    float y = uv.y, y1 = uv.y-.5;\n    float x = uv.x, x1 = uv.x-.5;\n    float b = .03;\n    float t = smoothstep(y1,y1+b,x)*smoothstep(y1,y1+b,-x);\n    t -= smoothstep(y,y+b,-x-.5)+smoothstep(y,y+b,x1);\n    \n    if (t>0.) col = vec3(.3,.9,.3);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByDW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 134, 215], [218, 218, 275, 275, 809]], "test": "untested"}
{"id": "WtSyDW", "name": "Simple hexagonal truchet pattern", "author": "mrange", "description": "License CC0: Simple hexagonal truchet pattern\nNothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n", "tags": ["truchet"], "likes": 10, "viewed": 513, "published": 3, "date": "1594302729", "time_retrieved": "2024-07-30T20:56:20.000921", "image_code": "// License CC0: Simple hexagonal truchet pattern\n//  Nothing fancy, wanted a simple shader that illustrated simple hexagonal truchet patterns\n\n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat pcos(float a) {\n  return 0.5 + 0.5*cos(a);\n}\n\n#define MROT(a) mat2(cos(a), sin(a), -sin(a), cos(a))\n\nconst mat2 rot120   = MROT(TAU/3.0);\nconst vec2 sz       = vec2(1.0, sqrt(3.0));\nconst vec2 hsz      = 0.5*sz;\nconst vec2 n1       = normalize(sz.yx);\nconst vec2 n2       = n1*vec2(-1.0, 1.0);\nconst float radius  = 0.5/sqrt(3.0);\nconst vec2 off1     = 2.0*radius*n1;\nconst vec2 off2     = rot120*off1;\nconst vec2 off3     = rot120*off2;\n\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz*1.0, sz)-hsz;\n  vec2 p3 = mix(p2, p1, vec2(length(p1) < length(p2)));\n  vec2 n = p3 - p;\n  p = p3;\n\n  return round(n*2.0)*0.5;\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat cell0(vec2 p) {\n  float d0 = abs(p.y);\n  float d1 = abs(dot(n1, p));\n  float d2 = abs(dot(n2, p));\n  float d3 = circle(p, radius);\n \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n  d = min(d, d3);\n   \n  return d;\n}\n\nfloat cell1(vec2 p) {\n  p = abs(p);\n  float d0 = circle(p-off1, radius); \n  return d0;\n}\n\nfloat cell2(vec2 p) {\n  float d0 = circle(p-off1, radius);\n  float d1 = circle(p-off2, radius);\n  float d2 = circle(p-off3, radius);\n   \n  float d = 1E6;\n  d = min(d, d0);\n  d = min(d, d1);\n  d = min(d, d2);\n \n  return d;\n}\n\nfloat df(vec2 p, float scale, float width, inout vec2 nn) {\n   p /= scale;   \n   nn = hextile(p);\n   nn = round(nn);\n   float r1 = hash(nn);\n   float r2 = fract(23.0*r1);\n   rot(p, floor(r2*6.0)* TAU/6.0);\n   float d = 1E6;\n   if (r1 < 0.5) {\n     d = cell2(p);\n   } else if (r1 < 0.8) {\n     d = cell1(p);\n   } else {\n     d = cell0(p);\n   }\n   d *= scale;\n    \n   float d1 = abs(d) - width;\n   float d2 = abs(d) - width*2.0;\n   d2 = abs(d2) - width*0.5;\n   \n   return min(d1, d2);\n\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord / iResolution.xy;\n  vec2 p = -1.0 + 2.0*q;\n  p.x *= iResolution.x/iResolution.y;\n    \n  float aa = 4.0 / iResolution.y;\n  float tm = iTime*0.1;\n    \n  p += vec2(cos(tm), sin(tm*sqrt(0.5)));\n\n  vec2 nn = vec2(0.0);\n  float d = df(p, 0.25, 0.01, nn);\n\n  vec3 col = vec3(0.0);\n  \n  col += vec3(0.5 + 0.5*sin(nn*10.0), 1.0)*smoothstep(0.0, aa, -d);\n//  col += vec3(0.5, 0.3, 0.9)*pcos(500*d);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSyDW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[189, 189, 213, 213, 283], [285, 285, 306, 306, 335], [730, 730, 758, 857, 1039], [1041, 1041, 1074, 1074, 1159], [1161, 1161, 1192, 1192, 1218], [1220, 1220, 1241, 1241, 1465], [1467, 1467, 1488, 1488, 1555], [1557, 1557, 1578, 1578, 1780], [1782, 1782, 1841, 1841, 2267], [2269, 2269, 2324, 2324, 2769]], "test": "untested"}
{"id": "3lSyWW", "name": "Emulated barycentric interpol...", "author": "hanfling", "description": "...lation over linear filtering. Testing for mixing of quads and triangles for interpolation.\n\nNow i can emulate barycentric interpolation over linear interpolation over barycentric interpolation.", "tags": ["barycentric", "linear", "interpolation"], "likes": 2, "viewed": 287, "published": 3, "date": "1594297413", "time_retrieved": "2024-07-30T20:56:21.028175", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 Colors[4];\n    \n    Colors[0] = vec4(1.0,0.0,0.0,1.0); // Upper left.\n    Colors[1] = vec4(0.0,1.0,0.0,1.0); // Lower left.\n    Colors[2] = vec4(0.0,0.0,1.0,1.0); // Upper right.\n    Colors[3] = vec4(1.0,0.5,0.0,1.0); // Lower right.\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 UV = fragCoord/iResolution.xy;\n    UV.t = 1.0-UV.t;\n    \n    // Direct barycentric.\n    vec4 BarycentricResult;\n    if ( (1.0-UV.s)>UV.t ) // Upper left.\n    {\n        float Areas[3];\n        Areas[0] = 0.5*length(cross(vec3(1.0,0.0,0.0),vec3(UV,0.0)));\n        Areas[1] = 0.5*length(cross(vec3(0.0,1.0,0.0),vec3(UV,0.0)));\n        Areas[2] = 0.5-Areas[0]-Areas[1];\n\n        float Weights[3];       \n        Weights[0] = Areas[0]/0.5;\n        Weights[1] = Areas[1]/0.5;\n        Weights[2] = Areas[2]/0.5;\n\n    \tBarycentricResult = Weights[0]*Colors[2]+Weights[1]*Colors[1]+Weights[2]*Colors[0];\n    }\n    else // Lower right.\n    {\n        float Areas[3];\n        Areas[0] = 0.5*length(cross(vec3(1.0,0.0,0.0),vec3(vec2(1.0)-UV,0.0)));\n        Areas[1] = 0.5*length(cross(vec3(0.0,1.0,0.0),vec3(vec2(1.0)-UV,0.0)));\n        Areas[2] = 0.5-Areas[0]-Areas[1];\n\n        float Weights[3];       \n        Weights[0] = Areas[0]/0.5;\n        Weights[1] = Areas[1]/0.5;\n        Weights[2] = Areas[2]/0.5;\n\n    \tBarycentricResult = Weights[0]*Colors[1]+Weights[1]*Colors[2]+Weights[2]*Colors[3];\n    }\n    \n    // Emulated barycentric.\n    vec4 LinearResult;\n    if ( (1.0-UV.s)>UV.t ) // Upper left.\n    {\n        // Geometry shader would supply this fake vertex for linear interpolation over adjacency information.\n        \n        // Replace lower right color with additive inverse of upper left color.\n        Colors[3] = -Colors[0];\n        \n        // Now set lower right colors alpha to 0, so we have a of missing weight we need to normalize for.\n        Colors[3].a = 0.0;\n        \n        // Fragment shader part would start here.\n\n        // Two dimensional linear interpolation as usual.\n    \tLinearResult = mix(mix(Colors[0],Colors[1],UV.s),mix(Colors[2],Colors[3],UV.s),UV.t);\n        \n        // This is counter intuitive. --han\n        LinearResult += (1.0-LinearResult.a)*(Colors[1]+Colors[2]);\n    }\n    else // Lower right.\n    {\n        Colors[0] = -Colors[3];\n        Colors[0].a = 0.0;\n\n    \tLinearResult = mix(mix(Colors[0],Colors[1],UV.s),mix(Colors[2],Colors[3],UV.s),UV.t);\n        \n        LinearResult += (1.0-LinearResult.a)*(Colors[1]+Colors[2]);\n        \n        // Test match hack.\n        //LinearResult = BarycentricResult;\n    }\n\n    fragColor = mix(LinearResult,BarycentricResult,pow(0.5+0.5*cos(2.0*iTime),4.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyWW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2706]], "test": "untested"}
{"id": "wt2cWh", "name": "Shaders are coming back in style", "author": "koo1ant", "description": "Someone said my last shader reminded him of Twin Peaks, so I fixed it :)", "tags": ["3d", "checkerboard", "ball"], "likes": 4, "viewed": 277, "published": 3, "date": "1594270306", "time_retrieved": "2024-07-30T20:56:21.956692", "image_code": "#define t iTime\n#define resolution iResolution\n\n// Original shader: https://www.shadertoy.com/view/3tByzw\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.65; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 - ((t * 10.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 - spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv, float offset) {\n    vec2 guv = uv;\n    guv.x = abs(fract(guv.x*1.50)*2.-1.);\n\n    guv.y = fract(guv.y*2.70)*1.50 + offset + -1.00;\n    // Sine checkers\n    //p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n    p -=  1.-step(0.00,guv.x+guv.y) -1.0 +step(0.77, guv.x + guv.y);\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y - 2.);\n    p *= 1.-smoothstep(0.0, 3.5, length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = -t*0.8; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    float w = 1.50;\n    ground(p, pv, 0.00);\n    ground(p, pv, -w);\n    ground(p, pv, +w);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += -abs(uv.y)*0.1;\n    \n    return vec4(color, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 158, 158, 292], [294, 294, 321, 321, 457], [459, 459, 500, 500, 577], [579, 579, 598, 598, 628], [630, 630, 704, 704, 2060], [2062, 2062, 2113, 2113, 2383], [2385, 2385, 2420, 2420, 2537], [2539, 2539, 2570, 2570, 2728], [2730, 2730, 2744, 2744, 3346], [3347, 3347, 3404, 3404, 3431]], "test": "untested"}
{"id": "WtjcW1", "name": "Iridescent opals", "author": "jarble", "description": "As the camera angle changes, the colors also appear to change.", "tags": ["3d", "raymarching", "iridescent", "opal"], "likes": 4, "viewed": 490, "published": 3, "date": "1594250870", "time_retrieved": "2024-07-30T20:56:22.707684", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float scale = EPSILON*1000.0;\n\nvec3 animate(vec3 p){\n    vec3 p1 = p;\n    //p1 /= 1.1;\n    float d = 200.0;\n    return p+(sin(p1.zxy/d)+cos(p1.zxy/d))*d;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF(vec3 p) {\n    p /= scale*2.0;\n\n\n    float to_return = 4.5 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0);\n    for(int i = 1; i < 3; i++){\n    \t//p += sin(iTime);\n        p += animate(p*2.0-to_return)/3.0;\n        p /= 2.0;\n        to_return -= .5;\n        to_return = min(to_return,4.5 +sin(length(p*10.0)/10.0) + sin(p.x/5.0)+cos(p.y/5.0)+cos(p.z/5.0));\n        //to_return -= 1.5;\n    }\n    \n    return (to_return-.4) * scale/1.0;\n}\n\nvec3 surface_color(in vec3 uv)\n{\n   uv *= 10.0;\n   return sin(vec3(sceneSDF(uv/2.0),sceneSDF(uv/3.0),sceneSDF(uv/5.0))/5.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    vec3 eye = scale*vec3(sin(iTime/5.0), cos(iTime/5.0), -iTime)*10.0; \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * -viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p)*.4+surface_color(p+viewDir*50.0)*.6;\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjcW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 289, 310, 310, 413], [415, 655, 679, 679, 1124], [1126, 1126, 1158, 1158, 1252], [1254, 1675, 1766, 1766, 2084], [2099, 2353, 2418, 2418, 2550], [2552, 2641, 2670, 2670, 2980], [2982, 3474, 3614, 3614, 4204], [4206, 4576, 4661, 4661, 5020], [5022, 5349, 5398, 5433, 5564], [5566, 5566, 5623, 5623, 6671]], "test": "untested"}
{"id": "3ljcDh", "name": "Strange rainbow tunnel", "author": "jarble", "description": "This tunnel has a colorful fractal pattern. \nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 3, "viewed": 321, "published": 3, "date": "1594241015", "time_retrieved": "2024-07-30T20:56:23.502559", "image_code": "\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*depth) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n        viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    float speed = 50.0;\n\tvec3 eye = vec3(iTime*50.0,55.0+sin(iTime/2.0)*50.0,-10.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 50.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    \n    vec3 p1 = p/size/i;\n    p = (sin(sin(p1)+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*6.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 9.0*81.0; i *= 3.0){\n        p = p*i;\n        p -= p*sin(p/size/i);\n    \tresult = max(result, result-planet_surface(p,i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/10.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0))*10.0)/4.0+vec3(.2);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 424, 515, 515, 827], [842, 1096, 1161, 1161, 1293], [1295, 1384, 1413, 1413, 1723], [1725, 2217, 2357, 2357, 2967], [2969, 3339, 3424, 3424, 3839], [3841, 4168, 4217, 4252, 4383], [4385, 4385, 4442, 4442, 5546]], "test": "untested"}
{"id": "Wt2yWh", "name": "Trig pattern", "author": "Oggbog", "description": "Experimenting with atan and others from the trig family", "tags": ["trig"], "likes": 1, "viewed": 283, "published": 3, "date": "1594234569", "time_retrieved": "2024-07-30T20:56:24.442047", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    float t = iTime/2.;\n    uv = uv * mat2(cos(t),-sin(t),sin(t),cos(t));\n    uv = fract(uv * .5*sin(-iTime)*4.)-.5;\n    float a = atan(uv.y,uv.x);\n    a = mod((a+3.141)/6.282,.1)*10.;\n    a -= step(.4+sin((uv.y+uv.x)*88.)*.2,length(uv));\n    uv = fract(uv * .5*cos(iTime-1.)*8.)-.5;\n    float b = mod((a+3.141)/6.282,.1)*10.;\n    b -= step(.4+sin((uv.y+uv.x)*88.)*.2,length(uv));\n    vec3 col = vec3(a*2.,0.,5.);\n    col = mix(col,vec3(0.,b*2.,.3),.5);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 613]], "test": "untested"}
{"id": "WtjyWh", "name": "Basic optical illusion", "author": "Nrx", "description": "Simple optical illusion.", "tags": ["illusion"], "likes": 6, "viewed": 394, "published": 3, "date": "1594233103", "time_retrieved": "2024-07-30T20:56:25.322692", "image_code": "void mainImage (out vec4 a, vec2 b) {\n\tvec2 c = iResolution.xy, d = (b + b - c) / c.y * 6.,\t/* Normalization of the fragment coordinates\t*/\n\t\te = d + 5. * cos (vec2 (0., 1.57) + iTime);\t\t\t/* Position of the little black circle\t\t\t*/\n\tc = floor (d) * .5;\t\t\t\t\t\t\t\t\t\t/* The plan is seen as a grid of squares\t\t*/\n\ta = vec4 (0., .5 + .5 * fract (c.x + c.y), .5, 1.);\t\t/* Squares' colors (light/dark green)\t\t\t*/\n\tc = round (d) / .1;\t\t\t\t\t\t\t\t\t\t/* Get the ID of the green squares' corners\t\t*/\n\ta = mix (a, vec4 (1., vec2 (cos (c.x + c.y) > 0.), 1.),\t/* Crosses' colors are cosines of these IDs\t\t*/\n\t\tsmoothstep (.4, .41, dot (d = fract (d) - .5, d)))\t/* Add crosses in the green squares' corners\t*/\n\t\t* smoothstep (0., .1, dot (e, e));\t\t\t\t\t/* Little black circle\t\t\t\t\t\t\t*/\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 762]], "test": "untested"}
{"id": "tlBcD1", "name": " 大龙猫 - OpArt #1", "author": "totetmatt", "description": "Native attempt to implement opArt algo. (Based on book Graphisme Scientifique sur Micro-Ordinateur, R.Dony )\nStarted with simple implementation, then went crazy with simple glsl trick :p\n\nStill using some coordinate, wondering if it's possible to avoid it", "tags": ["opart"], "likes": 16, "viewed": 547, "published": 3, "date": "1594232170", "time_retrieved": "2024-07-30T20:56:26.071690", "image_code": "#define PI  3.1415\n#define TAU 2.0*PI\n#define zero vec2(0.,0.)\n\n#define K .05\n#define RECUR 45.\n#define BASE_SIZE 1.0\nfloat det(vec2 a,vec2 b) {\n    return (a.x * b.y) - (a.t * b.x);\n}\nvec2 intersect(vec2 a, vec2 b,vec2 p,vec2 q) {\n       vec2 xdiff = vec2(a.x-b.x,p.x-q.x);\n       vec2 ydiff = vec2(a.y-b.y,p.y-q.y);\n      \n       float div = det(xdiff,ydiff);\n       \n       vec2 d = vec2(det(a,b),det(p,q));\n       return vec2(det(d,xdiff),det(d,ydiff))/div ;\n       \n    }\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\nvec2 coord(float a,float r) {\n    return vec2(cos(a),sin(a))*r;\n}\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv =( fragCoord.xy-.5* iResolution.xy)/iResolution.y;\n    uv*=2.;\n    uv +=vec2(cos(iTime),sin(iTime))*.1;\n    uv*=r(3.*sin(atan(uv.x,uv.y)*.45));\n    vec2 id = floor(uv);\n    uv=fract(uv)-.5;\n    float d = 0.;\n    vec3 col = vec3(0.);\n    float q = 6.+cos(floor(iTime)+pow(fract(iTime),2.))*2.;\n    float stepT = TAU/q;\n   \n   float D =1./20.;\n   \n   float loop_start;\n   float loop_end;\n   float stp;\n   if(mod(id.x,2.)==0.){\n      uv.x = -uv.x;\n      \n   } \n   if(mod(id.y,2.) == 0.){\n   uv.y = -uv.y;\n   }\n  \n   for(float j=0.;j<1.;j+=1./RECUR){\n        for(float i=0.;i<=TAU;i+=stepT) {\n         d += smoothstep(0.018,0.003,\n         sdSegment(uv,coord(i,BASE_SIZE), coord(i+stepT,BASE_SIZE)  ));\n      }\n      vec2 ipoint = intersect(zero,coord(0.+K,BASE_SIZE),coord(stepT,BASE_SIZE),coord(0.,BASE_SIZE));\n      float dst = length(ipoint);\n      uv*=1./dst;\n     uv *=r(K) ;\n    col += d*(palette(j + mod(iTime*.2,2.),vec3(.5),vec3(.5),vec3(1.),vec3(0.50, 0.10, 0.33))/RECUR);\n     \n    }\n     //col = mix(vec3(.1),vec3(.2,.3,.5),col);\n    //vec3 col = vec3(d);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 144, 144, 184], [185, 185, 231, 231, 476], [477, 477, 529, 529, 648], [649, 649, 678, 678, 714], [715, 715, 731, 731, 789], [791, 791, 863, 863, 906], [907, 907, 962, 962, 2077]], "test": "untested"}
{"id": "tlByRm", "name": "dicker", "author": "maxim", "description": "shader that draw dicks", "tags": ["dick"], "likes": 2, "viewed": 270, "published": 3, "date": "1594231836", "time_retrieved": "2024-07-30T20:56:27.034116", "image_code": "#define S smoothstep\n\nfloat N21(vec2 p){\n\treturn fract(sin(p.x*123.230+p.y*2345.36)*256.753);\n}\n\nvec3 t(float d,float k1, float k2, float k3){\n    return vec3(S(.005,0.,d-.015)*(sin(iTime+k1)*.5+.5),S(.005,0.,d-.015)*(sin(iTime+k2)*.5+.5),S(.005,0.,d-.015)*(sin(iTime+k3)*.5+.5));;\n}\n\n\nvec3 dick(vec2 uv, vec2 p){\n\tvec3 col = vec3(0);\n    float d = length(uv-p+vec2(-.015, +.05)-.1);\n    col += t(d, N21(p+vec2(12.,312.))*500.,N21(p+vec2(19.,372.))*500.,N21(p+vec2(53.,362.))*500.);\n    \n    d = length(uv-p+vec2(.015, +.05)-.1);\n    col += t(d, N21(p+vec2(162.,312.))*500.,N21(p+vec2(12.,3122.))*500.,N21(p+vec2(22.,82.))*500.);\n    \n    vec2 uv1 = uv - p - .1;\n    d = length(uv1-vec2(0, clamp(uv1.y,-0.027,.07)));\n    col += t(d, N21(p+vec2(42.,352.))*500.,N21(p+vec2(126.,132.))*500.,N21(p+vec2(12.,352.))*500.);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    uv += iTime*.2;\n    \n    \n    vec2 gv = floor(uv*3.)/3.;\n    \n    float angle = iTime * (N21(gv)*2.-1.) + N21(gv);\n    uv -= gv + vec2(0.1);\n    uv *= mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n    //vec2 rf = uv;\n    uv += gv + vec2(0.1);\n\n    vec3 col;\n    \n    col = dick(uv,gv); //+N21(gv)*.3\n    //col.rg = gv-iTime*.2+1.;//fract(uv*2.)/2.;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 40, 40, 95], [97, 97, 142, 142, 283], [286, 286, 313, 313, 839], [841, 841, 898, 898, 1362]], "test": "untested"}
{"id": "wtScD1", "name": "3D Landau Ginzburg", "author": "michael0884", "description": "Trying out cubemap based simulations. A 128^3 simulation domain.\nQuantum vortex rings", "tags": ["2d", "3d", "data", "landau", "ginsburg"], "likes": 15, "viewed": 486, "published": 3, "date": "1594231207", "time_retrieved": "2024-07-30T20:56:27.923738", "image_code": "// Fork of \"Wave equation 3D\" by michael0884. https://shadertoy.com/view/WtBcDz\n// 2020-07-08 14:45:14\n\n// Fork of \"Cubemap utils\" by rory618. https://shadertoy.com/view/wdsBRn\n// 2020-07-06 22:07:44\n\n//bilinear sampling\nvec4 S(vec3 x)\n{\n    vec4 X = vec4(x, 0.);\n    float zf = fract(X.z);\n    float zi = floor(X.z);\n    X.z = zi;\n    vec3 r0 = XYFaceToRayDir(getC(X));\n    vec3 r1 = XYFaceToRayDir(getC(X+vec4(0,0,1,0)));\n    return mix(texture(iChannel0, r0),texture(iChannel0, r1),zf);\n}\n\nfloat rho(vec3 x)\n{\n    x = x + vec3(B)*0.5;  \n    vec3 b = step(2., x)*step(x, vec3(B) -2.);\n    vec4 v = S(x);\n    return b.x*b.y*b.z*abs(1. - dot(v.xy,v.xy));\n}\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(0.25,-0.25, 0.25, -0.25);\n    return   (e.zwwz*rho( pos + e.xyy ) + \n  \t\t\t  e.wwzz*rho( pos + e.yyx ) + \n\t\t\t  e.wzwz*rho( pos + e.yxy ) + \n              e.zzzz*rho( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\nvec3 ray; vec3 cpos; vec2 angles;\nmat3 rmat;\nvec2 p;\nvec3 getRay(vec2 pos)\n{\n    rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float size = min(iResolution.y/3., iResolution.x/4.);\n    \n    //setup camera\n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.2*iTime, PI*0.5+0.5*sin(0.1*iTime));\n    cpos = -camd*getRay(R*0.5);\n    ray = getRay(I);\n    \n    vec4 c = vec4(0., 0., 0., 1.);\n    float td = 0.;\n    float dtd = 5.; //+ 10.*InterleavedGradientNoise(I, iFrame);\n    for(int i = 0; i < 150; i++)\n    {\n        float r = rho(cpos + ray*td);\n        vec3 col = 0.1*(0.5 - 0.5*cos(1.*vec3(1,2,3)*r*r));\n        dtd = 1./(0.7 + 10.*r*r);\n        td += dtd;\n        float alpha = smoothstep(1.,0.8, r);\n        c.w = c.w*alpha;\n        if(c.w < 0.01) break;\n        c.xyz += col*(1. - alpha)*dtd; \n    }\n    \n    if(c.w < 0.05)\n    {\n        vec3 p = cpos + ray*td;\n        vec4 g = calcGrad(p);\n        vec3 n = -normalize(g.xyz);\n        vec3 r = reflect(ray, n);\n        c.xyz += 0.5*n.z + 0.5 + texture(iChannel3, r.xzy).xyz;\n    }\n    else\n    {\n        c.xyz += 0.5*texture(iChannel2, ray.xzy).xyz;\n    }\n   \n    \n    \n    \n    \n    O = tanh(1.3*c);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define dt 0.6\n#define freq 0.04\n\n//sample the domain\nvec4 S(ivec4 X)\n{\n    vec3 r = XYFaceToRayDir(getC(vec4(X)));\n    return texture(iChannel0, r);\n}\n\nvoid mainCubemap( out vec4 Q, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{        \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n   \tivec4 X = getX(XYFace);\n    \n    if(X.w == 0)\n    {\n    \tQ = S(X);\n    \tvec4 L = (S(X + DX.zyyy) + S(X + DX.xyyy) +\n        \t\t  S(X + DX.yzyy) + S(X + DX.yxyy) +\n         \t\t  S(X + DX.yyzy) + S(X + DX.yyxy))/6. -  Q;\n    \n        //schrodinger equation integraion\n        if(iFrame%2 == 0)\n        \tQ.x += dt*(L.y - Q.y*F(Q.xy));\n        else\n        \tQ.y -= dt*(L.x - Q.x*F(Q.xy));\n        \n    \tQ.xy = Rot(freq*dt)*Q.xy;\n        \n        vec3 x = vec3(X.xyz);\n        vec3 border = smoothstep(3.,0., x)*smoothstep(vec3(B)-3.,vec3(B),x);\n        \n       \n        \n        //normalization border conditions\n        Q.xy = mix(Q.xy, vec2(0,0.), border.x*border.y*border.z);\n        \n        //vortex generator\n        vec3 tpos = vec3(B)*vec3(0.6, 0.6, 0.5)-   vec3(0, 15, 0)*sin(iTime);\n        float am = max(cos(iTime), 0.);\n         Q.xy *= mix(1.,smoothstep(-1., 1., sdTorus(x - tpos, vec2(15.,2.))), am);\n        \n        \n        tpos = vec3(B)*vec3(0.3, 0.3, 0.5)- vec3(15, 0,0)*cos(iTime);\n        am = max(sin(iTime), 0.);\n        Q.xy *=  mix(1.,smoothstep(-1., 1., sdTorus((x - tpos).yxz, vec2(15.,2.))), am);\n        \n        \n        \n        if(iFrame < 100)\n        {\n            Q = vec4(1., 0., 0., 0.);\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.14159265\n\n//render range\n#define range 500.\n#define FOV 2.\n#define camd 75.\n\n//number of variables\n#define VAR 3\n\n#define CUBE 1024\n\n//the domain\n#define B ivec3(128,128,128)\n\n#define DX ivec3(-1, 0, 1)\n\n\n//nonlinear potential\nfloat F(vec2 psi)\n{\n    return -0.46*(1. - length(psi));\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n//convert to domain coordinates\nivec4 getX(ivec3 XYface)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int var = XYface.z/s;\n    ivec2 z2 = XYface.xy/B.xy;\n    int Z = z2.x + z2.y*N.x + (XYface.z%s)*N.x*N.y;\n    ivec2 XY = XYface.xy%B.xy;\n    \n    return ivec4(XY, Z, var);\n}\n\n//convert to cubemap coordinates\nvec3 getC(vec4 p)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int pz = int(p.z);\n    ivec3 z3 = ivec3(pz%N.x, (pz/N.x)%N.y, pz/(N.x*N.y));\n    vec2 XY = p.xy + vec2(z3.xy*B.xy);\n    \n    return vec3(XY, p.w*float(s) + float(z3.z));\n}\n\n\nfloat G(vec3 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec3 x)\n{\n    return exp(-length(x));\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1,     0,        0,\n                         0,  cos(a.y), sin(a.y), \n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x),  sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0,            0,    1); \n   return phi_rot*theta_rot;\n}\n\n\n\nvec3 XYFaceToRayDir(vec3 p){\n    vec2 x = vec2(p-512.) + 0.5;\n           if (p.z==0.){     return vec3( 512.,-x.y,-x.x);\n    } else if (p.z==1.){     return vec3( x.x, 512., x.y);\n    } else if (p.z==2.){     return vec3( x.x,-x.y, 512.);\n    } else if (p.z==3.){     return vec3(-512.,-x.y, x.x);\n    } else if (p.z==4.){     return vec3( x.x,-512.,-x.y);\n    } else if (p.z==5.){     return vec3(-x.x,-x.y,-512.);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512., -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 221, 237, 237, 491], [493, 493, 512, 512, 656], [658, 658, 688, 688, 906], [961, 961, 984, 984, 1111], [1391, 1391, 1432, 1432, 2482]], "test": "untested"}
{"id": "tdjcWz", "name": "Aztec Walls", "author": "evvvvil", "description": "Winning shader made at REVISION 2020 demoparty Shader Showdown. Round 1 against Nusan / Cookies\nLive coded on stage in 25 minutes. Code was prepared before, not an improv.\nVideo of the battle is here: https://youtu.be/4GRD1gCX7fk?t=6058", "tags": ["fire", "demoscene", "particles", "beam", "glow", "pattern", "face", "revision", "dark", "walls", "inside", "aztec", "mexican"], "likes": 46, "viewed": 1283, "published": 3, "date": "1594229593", "time_retrieved": "2024-07-30T20:56:28.971936", "image_code": "// Winning shader made at REVISION 2020 demoparty Shader Showdown. Round 1 against Nusan / Cookies\n// Video of the battle is here: https://youtu.be/4GRD1gCX7fk?t=6058\n\n// The \"Shader Showdown\" is a demoscene live-coding shader battle competition.\n// 2 coders battle for 25 minutes making a shader on stage. No google, no cheat sheets.\n// The audience votes for the winner by making noise or by voting on their phone.\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,g2; vec3 np,bp,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 fb( vec3 p)\n{ \n    pp=p;pp.xz*=r2(.785);\n    vec2 h,t=vec2(bo(pp,vec3(4)),6);  \n    t.x=max(t.x,-(length(p)-1.));  \n    t.x=max(abs(abs(t.x)-.8)-.3,abs(p.y)-1.);  \n    t.x=max(t.x,abs(p.z)-3.5);\n    h=vec2(bo(pp,vec3(4)),3);  \n    h.x=max(h.x,-(length(p)-1.));  \n    h.x=max(abs(abs(h.x)-.8)-.15,abs(p.y)-1.3);\n    h.x=max(h.x,abs(p.z)-3.3);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(pp,vec3(4)),5);  \n    h.x=max(h.x,-(length(p)-1.));  \n    h.x=max(abs(abs(h.x)-.8)-.4,abs(p.y)-.7);  \n    h.x=max(h.x,abs(p.z)-3.7);  \n    t=t.x<h.x?t:h;\n    h=vec2(bo(pp,vec3(4)),6);  \n    h.x=max(h.x,-(length(p)-1.)); \n    h.x=max(abs(h.x),abs(p.y));  \n    h.x=max(h.x,abs(p.z)-3.);  \n    g+=0.1/(0.1+h.x*h.x*(10.-sin(bp.y*bp.z*.005+tt*5.)*9.));\n    t=t.x<h.x?t:h;   \n    t.x*=0.7;return t;\n}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n     f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp(vec3 p)\n{\n    np=bp=p;\n    for(int i=0;i<4;i++){\n    \tnp=abs(np)-vec3(7,1.5,5);\n        np.xz*=r2(.3925);\n    }\n    vec2 h,t=fb(np);\n    h=fb(p*.085);h.x*=10.;\n    h.x=max(h.x,-(length(p.xz)-17.));  \n    t=t.x<h.x?t:h;   \t\n    h=vec2(.5*(abs(p.y)-4.+6.*texNoise(p.xz*.05).r),7);  \n    h.x=max(h.x,-(length(p.xz)-17.));        \n    t=t.x<h.x?t:h;    \n    h=vec2(length(abs(p.xz)-vec2(5.,0.))-.5+(np.y*.06),6);      \n    g2+=1./(0.1+h.x*h.x*(10.-cos(np.y*.2-tt*5.)*9.));    \n    t=t.x<h.x?t:h;   \n    h=vec2(length(abs(p.xz)-vec2(11.,29.))-.5+(np.y*.06),6);      \n    g+=1./(0.1+h.x*h.x*(10.-cos(np.y*.2-tt*5.)*9.));    \n    t=t.x<h.x?t:h;    \n    pp=p+vec3(0,sin(p.x*p.z*.01)*3.,0);pp.xz*=r2(sin(p.y*.1)*.7+tt);\n    h=vec2(length(sin(pp*.5-vec3(0,tt*5.,0))),6);  \n    h.x=max(h.x,(length(p.xz)-17.));  \n    g+=0.1/(0.1+h.x*h.x*(100.-sin(bp.y*bp.z*.005+tt*5.)*99.));\n    t=t.x<h.x?t:h;  \n    return t;\n}\nvec2 tr( vec3 ro, vec3 rd )\n{\n  vec2 h,t= vec2(.1);\n  for(int i=0;i<128;i++){\n    h=mp(ro+rd*t.x);       \n    if(h.x<.0001||t.x>120.) break;\n    t.x+=h.x;t.y=h.y; \n  }\n  if(t.x>120.) t.y=0.;\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n  tt=mod(iTime,62.82);\n  vec3 ro=mix(vec3(sin(tt*.5)*5.,-cos(tt*.5)*50.,5.),vec3(cos(tt*.5-.5)*5.,35.,sin(tt*.5-.5)*45.),ceil(sin(tt*.5))),\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n  ld=normalize(vec3(.2,.5,.0));\n  v=vec2(abs(atan(rd.x,rd.z)),rd.y-tt*.2);  \n  co=fo=(vec3(.1)-length(uv)*.1-rd.y*.1)*3.*texNoise(v*.4).r;\n  z=tr(ro,rd);t=z.x;\n  if(z.y>0.){ \n    po=ro+rd*t; \n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x);\n    al=mix(vec3(.7,.05,0),vec3(.5,.1,0),.5+.5*sin(np.x*.5));\n    if(z.y<5.) al=vec3(0);\n    if(z.y>5.) al=vec3(1);\n    if(z.y>6.) al=vec3(.7,.2,.1);\n    float dif=max(0.,dot(no,ld)),\n    fr=pow(1.+dot(no,rd),4.);    \n    co=mix(mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.3)+.2)*(dif+s(25.)),fo,min(fr,.2));\n    co=mix(fo,co,exp(-.000005*t*t*t)); \n  }pp=co+g*.2*mix(vec3(.7,.1,0),vec3(.5,.2,.1),.5+.5*sin(np.z*.2));\n  fragColor = vec4(pow(pp+g2*.2*vec3(.1,.2,.5),vec3(0.55)),1);\n} ", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdjcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 492, 516, 516, 557], [558, 558, 575, 575, 618], [619, 619, 637, 637, 1395], [1396, 1396, 1419, 1419, 1621], [1622, 1622, 1639, 1639, 2531], [2532, 2532, 2561, 2561, 2736], [2826, 2826, 2883, 2883, 4032]], "test": "untested"}
{"id": "tlBcDh", "name": "Alien megacity", "author": "jarble", "description": "  This alien city is based on my [url=https://www.shadertoy.com/view/3lBcWz]recursive vine forest[/url].\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "recursion"], "likes": 4, "viewed": 538, "published": 3, "date": "1594220219", "time_retrieved": "2024-07-30T20:56:29.777781", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define multiplier 9.0\n#define iterations 2\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0,\nMAX_DIST = 1000.0,\nEPSILON = 0.001,\nsize = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    return size-length((sin(p/vec3(length((p/20.0)))))*size1)/1.8;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float\n        size1 = 1100.0,\n    \tresult = vines(p,size1),\n    \ti = multiplier;\n    for(int j = 0; j < iterations; j++){\n        p = sin(p/i)*i-sin(p*i)/i;\n        result = min(result,vines(p,size1)/(i));\n        i *= multiplier;\n    }\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(vines(p,6.0),vines(p,4.0),vines(p,3.0)))/5.0+vec3(.5);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p),\n    L = normalize(lightPos - p),\n    V = normalize(eye - p),\n    R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    vec3 eye = vec3(-35.0+sin(iTime/2.0)/2.0,1.0+cos(iTime/2.0)/2.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color(p);\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 7.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 100.0);\n    t = (t>>4&t*2&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 6; i++){\n        if(i>1){\n        \tresult += sound1(time*factor)/(factor);\n        }\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[597, 597, 629, 629, 698], [701, 701, 725, 725, 1015], [1017, 1017, 1045, 1045, 1122], [1124, 1545, 1636, 1636, 2000], [2015, 2269, 2334, 2334, 2466], [2468, 2557, 2586, 2586, 2896], [2898, 3390, 3530, 3530, 4125], [4127, 4497, 4582, 4582, 4929], [4931, 5258, 5307, 5342, 5473], [5475, 5475, 5532, 5532, 6573]], "test": "untested"}
{"id": "ttBcDh", "name": "3D blobs (field isosurface)", "author": "michael0884", "description": "Trying out cubemap based simulations. A 128^3 simulation domain.\nThis time im actually shading the isosurface. ", "tags": ["2d", "3d", "data", "landau", "ginsburg"], "likes": 11, "viewed": 439, "published": 3, "date": "1594220005", "time_retrieved": "2024-07-30T20:56:30.654437", "image_code": "// Fork of \"Wave equation 3D\" by michael0884. https://shadertoy.com/view/WtBcDz\n// 2020-07-08 14:45:14\n\n// Fork of \"Cubemap utils\" by rory618. https://shadertoy.com/view/wdsBRn\n// 2020-07-06 22:07:44\n\n//bilinear sampling\nvec4 S(vec3 x)\n{\n    vec4 X = vec4(x, 0.);\n    float zf = fract(X.z);\n    float zi = floor(X.z);\n    X.z = zi;\n    vec3 r0 = XYFaceToRayDir(getC(X));\n    vec3 r1 = XYFaceToRayDir(getC(X+vec4(0,0,1,0)));\n    return mix(texture(iChannel0, r0),texture(iChannel0, r1),zf);\n}\n\nfloat rho(vec3 x)\n{\n    x = x + vec3(B)*0.5;  \n    vec3 b = step(0., x)*step(x, vec3(B));\n    vec4 v = S(x);\n    return b.x*b.y*b.z*length(v.xy);\n}\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(2.,-2., 0.25, -0.25);\n    return   (e.zwwz*rho( pos + e.xyy ) + \n  \t\t\t  e.wwzz*rho( pos + e.yyx ) + \n\t\t\t  e.wzwz*rho( pos + e.yxy ) + \n              e.zzzz*rho( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\nvec3 ray; vec3 cpos; vec2 angles;\nmat3 rmat;\nvec2 p;\nvec3 getRay(vec2 pos)\n{\n    rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float size = min(iResolution.y/3., iResolution.x/4.);\n    \n    //setup camera\n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.5*iTime, PI*0.5+0.5*sin(0.4*iTime));\n    cpos = -camd*getRay(R*0.5);\n    ray = getRay(I);\n    \n    vec4 c = vec4(0., 0., 0., 1.);\n    float td = 0.;\n    float dtd = 5.; //+ 10.*InterleavedGradientNoise(I, iFrame);\n    for(int i = 0; i < 64; i++)\n    {\n        float r = rho(cpos + ray*td);\n        vec3 col = 0.*(0.5 - 0.5*cos(1.*vec3(1,2,3)*r*r));\n        dtd = 8./(1. + 10.*r);\n        td += dtd;\n        float alpha = smoothstep(5., 0.5, r);\n        c.w = c.w*alpha;\n        if(c.w < 0.05) break;\n        c.xyz += col*(1. - alpha)*dtd; \n    }\n    \n    if(c.w < 0.05)\n    {\n        vec3 p = cpos + ray*td;\n        vec4 g = calcGrad(p);\n        vec3 n = -normalize(g.xyz);\n        vec3 r = reflect(ray, n);\n        c.xyz += 0.5*texture(iChannel3, r.xzy).xyz +  texture(iChannel2, r.xzy).xyz;\n    }\n    else\n    {\n        c.xyz += 0.5*texture(iChannel2, ray.xzy).xyz;\n    }\n   \n    \n    \n    \n    \n    O = tanh(1.3*c);\n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define dt 0.5\n\n//sample the domain\nvec4 S(ivec4 X)\n{\n    vec3 r = XYFaceToRayDir(getC(vec4(X)));\n    return texture(iChannel0, r);\n}\n\nvoid mainCubemap( out vec4 Q, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{        \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n   \tivec4 X = getX(XYFace);\n    \n    if(X.w == 0)\n    {\n    \tQ = S(X);\n    \tvec4 laplacian = (S(X + DX.zyyy) + S(X + DX.xyyy) +\n        \t\t\t\t  S(X + DX.yzyy) + S(X + DX.yxyy) +\n        \t\t\t\t  S(X + DX.yyzy) + S(X + DX.yyxy))/6. -  Q;\n    \n    \tQ.zw += dt*(laplacian.xy - 0.05*Q.xy*cos(length(Q.xy)) - 0.05*Q.xy);//*cos(length(Q.xy)));\n        Q.xy += dt*Q.zw;\n        \n        vec3 x = vec3(X.xyz);\n        vec3 border = smoothstep(0.,3., x)*smoothstep(vec3(B),vec3(B)-3.,x);\n        Q.xy *= pow(border.x*border.y*border.z, 0.2);\n        \n        if(iFrame < 10)\n        {\n            Q = vec4(PI, 0., 0., PI)*G(vec3(X.xyz - B/2)/20.)\n                + vec4(1.*PI, 0., 0., 1.*PI)*G(vec3(X.xyz - B/3)/5.)\n                + vec4(1.*PI, 0., 0., 1.*PI)*G((vec3(X.xyz) - vec3(B)*vec3(0.7, 0.5,0.2))/5.);\n            Q*=3.;\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.14159265\n\n//render range\n#define range 500.\n#define FOV 2.\n#define camd 180.\n\n//number of variables\n#define VAR 3\n\n#define CUBE 1024\n\n//the domain\n#define B ivec3(128,128,128)\n\n#define DX ivec3(-1, 0, 1)\n\n\n//nonlinear potential\nfloat F(vec2 psi)\n{\n    return -0.2*(1. - length(psi));\n}\n\n\n//convert to domain coordinates\nivec4 getX(ivec3 XYface)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int var = XYface.z/s;\n    ivec2 z2 = XYface.xy/B.xy;\n    int Z = z2.x + z2.y*N.x + (XYface.z%s)*N.x*N.y;\n    ivec2 XY = XYface.xy%B.xy;\n    \n    return ivec4(XY, Z, var);\n}\n\n//convert to cubemap coordinates\nvec3 getC(vec4 p)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int pz = int(p.z);\n    ivec3 z3 = ivec3(pz%N.x, (pz/N.x)%N.y, pz/(N.x*N.y));\n    vec2 XY = p.xy + vec2(z3.xy*B.xy);\n    \n    return vec3(XY, p.w*float(s) + float(z3.z));\n}\n\n\nfloat G(vec3 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec3 x)\n{\n    return exp(-length(x));\n}\n\nmat2 Rot(float ang)\n{\n    return mat2(cos(ang), -sin(ang), sin(ang), cos(ang)); \n}\n\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1,     0,        0,\n                         0,  cos(a.y), sin(a.y), \n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x),  sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0,            0,    1); \n   return phi_rot*theta_rot;\n}\n\n\n\nvec3 XYFaceToRayDir(vec3 p){\n    vec2 x = vec2(p-512.) + 0.5;\n           if (p.z==0.){     return vec3( 512.,-x.y,-x.x);\n    } else if (p.z==1.){     return vec3( x.x, 512., x.y);\n    } else if (p.z==2.){     return vec3( x.x,-x.y, 512.);\n    } else if (p.z==3.){     return vec3(-512.,-x.y, x.x);\n    } else if (p.z==4.){     return vec3( x.x,-512.,-x.y);\n    } else if (p.z==5.){     return vec3(-x.x,-x.y,-512.);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512., -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 221, 237, 237, 491], [493, 493, 512, 512, 640], [642, 642, 672, 672, 886], [941, 941, 964, 964, 1091], [1371, 1371, 1412, 1412, 2479]], "test": "untested"}
{"id": "ttBcWh", "name": "Intricate circles", "author": "z0rg", "description": "Don't ", "tags": ["2d", "circles", "abstract"], "likes": 26, "viewed": 571, "published": 3, "date": "1594211842", "time_retrieved": "2024-07-30T20:56:31.534085", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\nconst float PI = 3.141592653;\n\nfloat lenny(vec2 v)\n{\n  return abs(v.x)+abs(v.y);\n}\nfloat sat(float a)\n{\n  return clamp(a,0.,1.);\n}\n\nfloat sub(float a, float b)\n{\n  return max(a,-b);\n}\n\nfloat cir(vec2 p, float r)\n{\n  float a = atan(p.y,p.x)+r*sin(2.*r+iTime*.1);\n  return (length(p)-r)-sin(a*7.-iTime)*.15\n  +sin(a*3.-iTime)*.2\n  +sin(a*5.+sin(a))*.02;\n}\n\nfloat border(vec2 p, float th, float r)\n{\n  return sub(cir(p,r),cir(p,r-th));\n}\nvec3 rdr(vec2 uv)\n{\n  vec3 col;\n  int i = 0;\n  while (i<32)\n  {\n    float fi = float(i);\n      col += vec3(sat(pow(abs(uv.y),4.))*2.,.8,sat(abs(uv.x)+.5))*(1.-sat(border(uv,0.0005, .8+.02*fi)*80.));\n    col += .005*vec3(sat(pow(abs(uv.y),4.))*2.,.8,sat(abs(uv.x)+.5)).yxx*(1.-sat(border(uv*.5*vec2(-1.,1.)*(sin(iTime*.2)*.5+1.),0.0005, .8+.02*fi)*40.));\n    \n      ++i;\n  }\n\n  return col;\n}\n\nvec3 tone(vec3 col, vec2 uv)\n{\n  vec3 col2 = .7*mix(vec3(.76,.37,.18).zyx,vec3(.54,.85,.23).yzx,sat(.2*length(uv)));\n  col *= col2;\n  col += col2*.0008;\n  col = pow(col,vec3(1./1.8*(sin(iTime)*.1+.5)));\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = fragCoord.xy / iResolution.xx;\n  uv -= vec2(.5)*iResolution.xy/iResolution.xx;\n  uv*=8.;\n\n  vec3 col = rdr(uv);\n  col = tone(col,uv);\n  vec3 colMult = mix(vec3(.37,.25,.56).zxy, vec3(.37,.25,.56), sin(iTime*.5)*.5+.5);\n  fragColor = vec4(col*colMult*3., 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcWh.jpg", "access": "api", "license": "cc-by-nc-4.0", "functions": [[428, 428, 449, 449, 479], [480, 480, 500, 500, 527], [529, 529, 558, 558, 580], [582, 582, 610, 610, 750], [752, 752, 793, 793, 831], [832, 832, 851, 851, 1222], [1224, 1224, 1254, 1254, 1442], [1444, 1444, 1501, 1501, 1775]], "test": "untested"}
{"id": "wljcRw", "name": "Octagon and Square Truchet v2", "author": "Oggbog", "description": "A curvier version than the last.", "tags": ["truchet"], "likes": 12, "viewed": 338, "published": 3, "date": "1594211273", "time_retrieved": "2024-07-30T20:56:32.424704", "image_code": "#define PI 3.141592653589793\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(144.34, 1051.74));\n    p += dot(p, p + 230.45);\n    return fract(p.x * p.y + p.y + p.x);\n}\n\nvec2 rot(vec2 st, float a){\n   return st * mat2(cos(a),-sin(a),sin(a),cos(a)); \n}\n\nfloat arc(vec2 uv, vec2 centre, float r, float s, float e,float th){\n    \n    float d = length(uv-centre);\n    float a = atan(uv.x-centre.x,uv.y-centre.y);\n    \n    if (a>s && a<e){\n    \td = smoothstep(d,d+.01,r+th/2.)-smoothstep(d,d+.01,r-th/2.);\n    } else {\n        d = 0.;\n    }\n    return d;\n}\n\nfloat vline(vec2 p,float s, float e, float th){\n    float d = length(p-vec2(0.,clamp(p.y,s,e)));\n    d = smoothstep(d,d+.005,th/2.);\n    return d;\n}\n\nfloat hline(vec2 p,float s, float e, float th){\n    float d = length(p-vec2(clamp(p.x,s,e),0.));\n    d = smoothstep(d,d+.005,th/2.);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 qv = uv - 0.5;\n    \n    float g = 15.; // has to be an odd number to work correctly\n    \n    vec2 id = floor(uv * g);\n    uv = fract(uv * g)-.5;\n    vec2 qd = floor(qv * g);\n    qv = fract(qv * g)-.5;\n    vec2 gv = uv;\n    \n    float c = 2./3.;\n    float m = 0.;\n    float m1 = 0.;\n    float th = 0.19;\n  \n    \n    float t =(iTime*.5)*PI/4.;\n    float tq = (iTime * .5)*PI/2.;\n    float r = hash21(id);\n    float q = hash21(qd);\n    \n    uv = rot(uv,id.x*floor(t*r)*PI/4.);\n    qv = rot(qv,qd.x*floor(tq*q)*PI/2.);\n    \n    \n    // Octagon pattern\n#if 1\n    m += hline(uv,-.5,.5,th);\n    m += vline(uv,.3,.5,th);\n    m += vline(uv,-.5,-.3,th);\n    \n    m += arc(uv,vec2(0.,-.77),.55,-.8,.8,th);\n    m += arc(uv,vec2(0.,.77),.55,-3.142,-2.4,th);\n    m += arc(uv,vec2(0.,.77),.55,2.4,3.142,th);\n#endif\n    \n    // Square pattern\n#if 1\n    m1 += arc(qv,vec2(0.,-.4),.3,-.63,.63,th);\n    m1 += arc(qv,vec2(0.,.4),.3,-3.142,-2.57,th);\n    m1 += arc(qv,vec2(0.,.4),.3,2.57,3.142,th);\n    m += m1;\n#endif\n    \n    // Grid\n#if 0\n    m += gv.x<-0.48 && gv.y<c/3.5 && gv.y>-c/3.5 ? 1.:0.;\n    m += gv.y<-0.48 && gv.x<c/3.5 && gv.x>-c/3.5 ? 1.:0.;\n    m += smoothstep(gv.x,gv.x+b,gv.y-c)-smoothstep(gv.x,gv.x+b,gv.y-c-.02);\n\tm += smoothstep(-gv.x,-gv.x+b,gv.y-c)-smoothstep(-gv.x,-gv.x+b,gv.y-c-.02);\n    m += smoothstep(-gv.x,-gv.x+b,-gv.y-(c))-smoothstep(-gv.x,-gv.x+b,-gv.y-(c)-.02);\n    m += smoothstep(gv.x,gv.x+b,-gv.y-(c))-smoothstep(gv.x,gv.x+b,-gv.y-(c)-.02);\n#endif\n    \n    vec3 col =vec3(m);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 166], [168, 168, 195, 195, 249], [251, 251, 319, 319, 549], [551, 551, 598, 598, 699], [701, 701, 748, 748, 849], [851, 851, 908, 908, 2508]], "test": "untested"}
{"id": "tlScWh", "name": "Sparse spheric volume", "author": "Leria", "description": "Test of pushing bubble https://www.shadertoy.com/view/MscyRf in 3D", "tags": ["noise", "color", "nebula"], "likes": 5, "viewed": 519, "published": 3, "date": "1594210610", "time_retrieved": "2024-07-30T20:56:33.563658", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//enable-disable distorsion (0/1)\n#define DISTORSION_ON\t\t0\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n\t#define STRETCH\t\t\t0\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* clamp( noise(p)/.178 +.5 ,0.,1.) )\n#define Psnoise(p) (2.* clamp( snoise(p)/.178 +.5 ,0.,1.) )\n#define  rnd(v)  fract(sin( v * vec2(12.9898, 78.233) ) * 43758.5453)\n#define srnd(v) ( 2.* rnd(v) - 1. )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n    f = Pnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 m_vec = m.pos - p;\n    float d = dot(m_vec,m_vec);\n    vec3 res = normalize(m_vec) * (DISTORSION*m.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nfloat sdf_capsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n\n            float r_p = abs(RADIUS/length(center));\n            float l = 1./r_p;\n            \n\t\t\tvec3 dU = vec3(0.);\n\t\t\tl = max(0., sqrt(1.-l*l));             // sphere push\n            vec3 S = vec3(p.x,p.y-floor(k/d)*d, p.z);\n             S -= p;\n            if (l>0.) \n                dU += l*S;           // cumulate push applied later\n\n\n            float acceleration_p = (clamp(r_p*r_p-4.,0., -4.));\n            \n            l = exp(-.5*sqrt(l/.7));\n            float n = 0.;\n            \n            //if(r_p < 1.)\n            \tn = abs( fbm( p/4.*l+acceleration_p) );\n            //else\n                //n = abs( fbm( p/4.+l) );\n\n\n;\t\n            //sort of \"iso-value\" : .1*max(0., abs(sin(20.*fbm(p/4.))  )); //iso valeur\n            //complement : n = max(0., 1.-10.*abs(fbm(p/4.)))\n\n            \n            float mask = smoothstep(0., \n                                    1.*RADIUS,\n                                    (RADIUS-length(center))- 0.3*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  )*n; \n            \n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 4.* f(p.x) * dens, \n                      \tk * 4.* dens,\n              \t      \tk * 2.* f(p.z) * dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        #if DISTORSION_ON\n        space_time_bending(r, p, k); \n        #endif\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlScWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[922, 995, 1017, 1017, 1190], [1860, 1860, 1917, 1917, 2086], [2088, 2111, 2133, 2386, 3303], [3305, 3305, 3331, 3331, 4156], [4259, 4259, 4284, 4297, 4671], [4673, 4673, 4698, 4711, 5059], [5061, 5061, 5080, 5080, 5173], [5175, 5175, 5236, 5236, 5430], [5431, 5450, 5526, 5526, 5573], [5575, 5575, 5607, 5607, 5627], [5629, 5629, 5663, 5663, 5685], [5787, 5787, 5811, 5811, 5971], [5973, 5973, 5997, 5997, 6082], [6084, 6113, 6141, 6141, 6311], [6313, 6335, 6381, 6381, 7004], [7054, 7054, 7095, 7095, 7131], [7133, 7133, 7219, 7219, 7254], [7256, 7256, 7299, 7299, 7339], [7341, 7341, 7395, 7395, 7516], [7518, 7518, 7542, 7542, 7590], [7592, 7592, 7632, 7632, 7936], [7938, 7938, 7962, 7962, 8025], [8027, 8027, 8074, 8074, 8126], [8128, 8128, 8211, 8211, 8350], [8353, 8353, 8406, 8406, 8763], [8766, 8766, 8818, 8818, 12122], [12125, 12125, 12182, 12182, 12807]], "test": "untested"}
{"id": "WlScD1", "name": "Comical", "author": "hamoid", "description": "Simple edjes and color quantization", "tags": ["toon"], "likes": 4, "viewed": 378, "published": 3, "date": "1594203028", "time_retrieved": "2024-07-30T20:56:34.837253", "image_code": "void mainImage( out vec4 fragColor, in vec2 pos ) {\n    vec2 px = 1.0 / iResolution.xy;\n    vec2 p = pos * px;\n    vec4 c0 = texture(iChannel0, p);\n    vec4 c1 = texture(iChannel0, p + vec2(px.x, 0.0));\n    vec4 c2 = texture(iChannel0, p - vec2(px.x, 0.0));\n    vec4 c3 = texture(iChannel0, p + vec2(0.0, px.y));\n    vec4 c4 = texture(iChannel0, p - vec2(0.0, px.y));\n    float cut = 0.9;\n    float bri = step(cut, 1.0-distance(c0, c1)) *\n                step(cut, 1.0-distance(c0, c2)) *\n                step(cut, 1.0-distance(c0, c3)) *\n                step(cut, 1.0-distance(c0, c4));\n    vec3 quant = floor(c0.rgb * 4.0) / 3.0;\n    fragColor = vec4(vec3(bri * quant), 1.0);\n}", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 51, 51, 679]], "test": "untested"}
{"id": "WlByD1", "name": "Animated ChebychevVoronoi", "author": "mosaic", "description": "This is just copied from https://www.shadertoy.com/view/WlByWh  by @treize , with a few *sin(iTime) added to the offsets ", "tags": ["voronoi", "noise"], "likes": 2, "viewed": 333, "published": 3, "date": "1594202217", "time_retrieved": "2024-07-30T20:56:35.864506", "image_code": "float max_abs(vec2 p)\n{\n    return max(abs(p.x), abs(p.y));\n}\n\n\nvec2 voronoi_noise_randomVector(vec2 UV, vec2 offset)\n{\n\tmat2 m = \tmat2(15.27, 47.63, 99.41, 89.98);\n\tUV = fract(sin(UV* m) * 46839.32);\n\treturn vec2(sin(UV.y * +offset.x*cos(iTime/3.)) * 0.5 + 0.5, cos(UV.x * offset.y*sin(iTime/20.)) * 0.5 + 0.5);\n}\n\nvoid ChebychevVoronoi(vec2 UV, vec2 AngleOffset, vec2 CellDensity, out float Out, out float Cells, out float Lines,out float Points)\n{\n\tvec2 g = floor(UV * CellDensity);\n\tvec2 f = fract(UV * CellDensity);\n\t\n\tfloat res = 8.0;\n\tfloat md=8.0;\n    vec2 mr;\n\tfor (int y = -1; y <= 1; y++)\n \t{\n\t    for (int x = -1; x <= 1; x++)\n\t\t{\n\t\t    vec2 lattice = vec2(x, y);\n            vec2 offset = voronoi_noise_randomVector(lattice + g, AngleOffset);\n            vec2 r = lattice +offset -f;\n            float d = max_abs(r);\n\t\t\tif (d < res)\n\t\t\t{\n\t\t\t    res = d;\n                mr=r;\n\t\t\t}\n\t\t}\n\t}\n    res = 8.0;\n\tfor (int y = -1; y <= 1; y++)\n \t{\n\t    for (int x = -1; x <= 1; x++)\n\t\t{\n\t\t    vec2 lattice = vec2(x, y);\n            vec2 offset = voronoi_noise_randomVector(lattice + g, AngleOffset);\n            vec2 r = lattice +offset -f;\n           \tfloat d = max_abs(r);\n\t\t\tif (d < res)\n\t\t\t{\n\t\t\t    res = d;\n\t\t\t    Out = res;\n\t\t\t    Cells = offset.x;\n\t\t\t}\n\t\t\tif( dot(mr-r,mr-r)>0.00001)\n\t\t\t{\n                md = min( md, dot( 0.5*(mr+r), normalize(r-mr) ) );\n\t\t\t}\n\t\t}\n\t}\n\tLines = mix(1.0, 0.0, smoothstep( 0.03, 0.06, md ));\n\tPoints =1.0-smoothstep( 0.0, 0.3, res );\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 p = fragCoord/iResolution.xy;\n   \tp=p*2.0-1.0;\n\tp.x *= iResolution.x / iResolution.y;\n    vec3 col;\n    float a,b,c,d;\n    //ChebychevVoronoi(p,vec2(3.0+cos(iTime)),vec2(5.0,5.0),a,b,c,d);\n    ChebychevVoronoi(p,vec2(7.0),vec2(5.0,5.0),a,b,c,d);\n    //col=vec3(a);\n    col=vec3(b);\n    //col=vec3(c);\n    //col=vec3(d);\n\tfragColor = vec4(col,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByD1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 61], [64, 64, 119, 119, 314], [316, 316, 450, 450, 1477], [1478, 1478, 1535, 1535, 1893]], "test": "untested"}
{"id": "WtBcW1", "name": "Mellifera Simplified", "author": "mla", "description": "Trying to understand sl2c's very interesting \"Mellifera I\" : [url]https://www.shadertoy.com/view/3tBczh[/url] so here's a version cut down to essentials (with extras).\n\nSee also: [url]https://www.researchgate.net/publication/242950405[/url]", "tags": ["hyperbolic", "manifold", "lobell"], "likes": 11, "viewed": 393, "published": 3, "date": "1594198103", "time_retrieved": "2024-07-30T20:56:36.881787", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Simplified version of sl2c's https://www.shadertoy.com/view/3tBczh\n//\n// It's a horospheric slice through H3, showing the cells of a honeycomb\n// generated by a 14-sided polyhedron described by Löbell in 1931. Eight\n// coloured polyhedra are glued together and external faces identified to form\n// a manifold.\n//\n// Some extra controls:\n// <mouse>: apply inversion\n// c: show inversion circles\n// s: show inversion count rather than polyhedron color\n// z: zoom behaviour\n//\n// For more on Löbell polyhedra, see:\n// https://www.researchgate.net/publication/242950405\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Original header:\n////////////////////////////////////////////////////////////////////////////////\n// Copyright 2020 Google LLC\n// SPDX-License-Identifier: Apache-2.0\n// NOT an official Google project; see Google Open Source guidelines for more info on copyright transfer\n// written by William Cadegan-Schlieper \n////////////////////////////////////////////////////////////////////////////////\n\nbool tryinvert(inout vec3 z, vec3 c, float r) {\n  // Invert z in sphere centre c radius r if \"inside\".\n  // If r < 0, \"inside\" means outside.\n  vec3 z1 = z - c;\n  if ((dot(z1,z1) < r*r == r < 0.0)) return false;\n  z = z1*r*r/dot(z1,z1) + c;\n  return true;\n}\n\nvec3 getcol(ivec4 flips) {\n  return 0.8*vec3(notEqual(ivec3(flips.w),flips.xyz));\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  const int[14] m = int[](0,1,2,0,1,2,0,1,2,0,1,2,3,3);\n  vec3[14] c; // 14 circles\n  float r1 = sqrt(sqrt(3.0) - sqrt(2.0));\n  c[12] = vec3(0,0,r1);\n  float r2 = r1;\n  float x2 = sqrt(r1*r1+r2*r2);\n  float r3 = r2 / ( x2 * x2 - r2 * r2);\n  float x3 = -x2 / ( x2 * x2 - r2 * r2);\n  for (int i=0; i<6; i++) {\n    float theta = PI*float(i)/3.0;\n    vec2 eit = vec2(cos(theta), sin(theta));\n    c[i] = vec3(x2 * eit,r2);\n    c[i+6] = vec3(x3 * vec2(eit.y,-eit.x),r3);\n  }\n  float r4 = -1.0/r1; // Inverse circle\n  c[13] = vec3(0,0,r4);\n\n  float scale = 2.0;\n  vec2 z = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n  z *= scale;\n  if (iMouse.x > 0.0) {\n    vec2 m = (2.0*iMouse.xy - iResolution.xy)/iResolution.y;\n    m *= scale;\n    z -= m;\n    z /= dot(z,z);\n    z += m;\n    z /= dot(z,z);\n  }\n\n  vec3 p = vec3(z,0.25); // p is in H3, z is horosphere (Euclidean) distance from boundary\n  if (!key(CHAR_Z)) {\n    p.z = exp(-mod(0.5*iTime,8.0));\n  } else {\n    float period = -4.0 * log(r1);\n    float d = mod(iTime * 0.2, period) - period * 0.5;\n    p *= exp(-d);\n  }\n\n  ivec4 flips = ivec4(0);\n  int flipcount = 0;\n  for (int i=0; i<12; i++) {\n    int flipcount1 = 0;\n    for (int j=0; j<14; j++) {\n      if (tryinvert(p, vec3(c[j].xy,0), c[j].z)) {\n        flips[m[j]] = 1-flips[m[j]];\n        flipcount1++;\n      }\n    }\n    if (flipcount1 == 0) break;\n    flipcount += flipcount1;\n  }\n  float d = 1e8;\n  int j;\n  for (int i = 0; i < 14; i++) {\n    float d1 = abs(length(p-vec3(c[i].xy,0))-abs(c[i].z));\n    if (d1 < d) {\n      j = i; d = d1;\n    }\n  }\n  ivec4 flips1 = flips;\n  flips1[m[j]] = 1-flips1[m[j]];\n  vec3 col =\n    key(CHAR_S) ?\n    hsv2rgb(vec3(float(flipcount)/10.0,1,1)) :\n    mix(getcol(flips1),getcol(flips),smoothstep(-0.01,0.01,d));\n  col = 0.1+0.8*col;\n  if (!key(CHAR_C)) {\n    float d = 1e8;\n    for (int i = 0; i < 14; i++) {\n      d = min(d,abs(length(z-c[i].xy)-abs(c[i].z)));\n    }\n    col = mix(vec3(1.0),col,smoothstep(0.0,0.02,d));\n    //col = mix(vec3(0.8),col,smoothstep(0.0,0.02,abs(length(z)-1.0)));\n  }\n  col = pow(col, vec3(0.4545));\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float PI = 3.1415927;\n\nvec3 hsv2rgb(vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int KEY_PAGE_UP = 33;\nconst int KEY_PAGE_DOWN = 34;\nconst int KEY_LEFT = 37;\nconst int KEY_RIGHT = 39;\nconst int KEY_UP = 38;\nconst int KEY_DOWN = 40;\n\nconst int CHAR_0 = 48;\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcW1.jpg", "access": "api", "license": "apache-2.0", "functions": [[1137, 1137, 1184, 1278, 1394], [1396, 1396, 1422, 1422, 1479]], "test": "untested"}
{"id": "3lSyW1", "name": "DMT GRADIENT", "author": "Pairtial", "description": "DMT", "tags": ["dmt"], "likes": 0, "viewed": 313, "published": 3, "date": "1594187025", "time_retrieved": "2024-07-30T20:56:37.746475", "image_code": "void mainImage( out vec4 o, in vec2 FC )\n{\n    vec3 u=normalize(vec3(2.*cos(iTime)*FC-iResolution.xy,iResolution.xy.y))*1.2*cos(iTime);\n    for(float i=0.;i<4.;i++)\n        u.y+=cos(u.y*i*5.)*.1*cos(iTime),\n        u.z+=sin(u.x*cos(iTime)*u.x+u.y*u.y-iTime*.3),\n        u+=cos(u*cos(iTime)*i*cos(iTime)*7.*cos(iTime))*.1*cos(iTime),\n        o=max(o,cos(3.*dot(u,u)*cos(iTime)+vec4(.3*cos(iTime),.1*cos(iTime),cos(iTime),cos(iTime))));\n    \n for(float i=0.;i<4.;i++)\n        u.y+=cos(u.y*i*5.)*.1*cos(iTime),\n        u.z+=sin(u.x*cos(iTime)*u.x+u.y*u.y-iTime*.3),\n        u+=cos(u*cos(iTime)*i*cos(iTime)*7.*cos(iTime))*.1*cos(iTime),\n        o=max(o,cos(3.*dot(u,u)*cos(iTime)+vec4(.3*cos(iTime),.1*cos(iTime),cos(iTime),cos(iTime))));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 737]], "test": "untested"}
{"id": "3tSyW1", "name": "Inside brain´s neurone", "author": "Pairtial", "description": "Mods on @evvvvil's work\nhttps://www.shadertoy.com/user/evvvvil", "tags": ["noise", "cells", "brain"], "likes": 1, "viewed": 351, "published": 3, "date": "1594186225", "time_retrieved": "2024-07-30T20:56:38.690950", "image_code": "//Originally CREATED by https://www.twitch.tv/evvvvil_ https://www.shadertoy.com/user/evvvvil\n//***\n\nvec2 z,v,e=vec2(.015,-.0035); float t,tt,bb,b,b2,g,g2,td,cn,texNoi; vec3 pp,po,no,ld,al,lp; //global vars: same old garbage, just like any Coldplay album.\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function, yeah I know it's boring but then so is sitting next to you at a Wedding.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function. Short and sweet, just like the meaningless chat we're gonna have at that wedding.\nfloat smin(float a,float b,float h){float k=clamp((a-b)/h*.5+.5,0.,1.);return mix(a,b,k)-k*(1.-k)*h;} // Smooth merge - Merging geometry softly. Bit like a wedding actually, you know, being an excuse for two people eventually physically merging.\nfloat noi(vec3 p){ // Noise function. I don't really understand any of this, I was so bored at that wedding that I spent all my neurones on halucinagenics, so much so I even forgot how to spell halucinogenics\n  vec3 f=floor(p),s=vec3(7,157,113); \n  p-=f;vec4 h=vec4(0,s.yz,s.y+s.z)+dot(f,s);\n  p=p*p*(3.-2.*p);\n  h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n  h.xy=mix(h.xz,h.yw,p.y);\n  return mix(h.x,h.y,p.z);\n}\nvec2 pounder( vec3 p )\n{ //Phallic symbol incoming, why be subtle when you can litterally fuck a planet's core? You're just not ambitious enough broski: I once fucked the sea.\n  pp=abs(t+vec3(0,-1.,0))-vec3(0,5.+bb,0); //make new position pp out of p for the half spheres, abs symetry along y and animate. Give it some serious pumping action (that's what she said)\n  vec2 h,t=vec2(length(pp)-2.2,6.); //WHITE SPHERE soon to be slashed in half, just like public services funding under Boris Johnson.\n  t.x=abs(t.x)-.3; //Onion trick to make the sphere hollow, carving holes basically, this time with math rather than the smallest part of your body.\n  t.x=max(t.x,-pp.y); //Slash sphere in half and reveal it hollow, just like those brexit promises. \n  h=vec2(length(pp)-2.2,3.); //BLACK SPHERE soon to be slashed in half, just like the UK's international reputation under Boris Johnson.\n  h.x=abs(t.x)-.1; //Onion trick to make the sphere hollow, with smaller radius so it creates edge.\n  h.x=max(h.x,-pp.y-.5); //Slash sphere in half and reveal it as a hollow, just like those brexit promises. \n  pp.xz*=r2(1.2+sin(p.y*(1.-0.07*bb))*.5); // reusing pp as new position for splines, rotate and twist a bit.\n  h.x=min(h.x,bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.2,20.0,0.15))); //BLACK SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  t=t.x<h.x?t:h; //Merge all geometries from both black and white materials. There is an interratial sex joke to be made here but I'm too scared of offended millenials.\n  t.x=max(t.x,-(length(p.xz)-1.)); //HOLE IN MIDDLE, digs hole through both half spheres, letting the blue core through it. Noone will hear you scream in space but there is still time for sexual inuendos \n  h=vec2(bo(abs(abs(pp)-vec3(0.5,0.0,.6))-vec3(1,0,0.3),vec3(0.3,20.0,0.01)),6.); //GLOW SPLINES Made out of couple of abs symetry cloning a bunch of fucking boxes.\n  g+=0.1/(0.1+h.x*h.x*(150.-sin(p.y*0.5+tt*2.)*149.)); //First glow, making the splines above glow and sweeping the glow along Y axis. It's like building fireworks but without the fun of burning things.\n  t=t.x<h.x?t:h; //Merge the glow splines with the rest. Like putting fairy lights around your room to pretend you are not the twisted fucker your neighbour knows you are.\n  h=vec2(  length(p.xz+texNoi*12.5)-(1.5+0.2*sin(p.y*2.+tt*2.)),5.); //BLUE CORE, inifinte cylinder with bit of displacement along y and reusing texNoi for crunchy effect.\n  g2+=0.1/(0.1+h.x*h.x*(15.-sin(p.y*0.5+tt*2.-0.5)*4.9)); //Second glow, making blue core glow and sweeping along y axis with a bit of an offset so it comes in a little after white.\n  t=t.x<h.x?t:h; t.x*=1.9; //Merge the core with rest and tweak distance field a bit to avoid artifact (t.x*=0.9)\n  return t;\n}\n// Rough shadertoy approximation of the bonzomatic noise texture by yx - https://www.shadertoy.com/view/tdlXW4\nfloat texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5;\n    f+=texture(iChannel0,uv*.25).r*.25;f+=texture(iChannel0,uv*.5).r*.125;\n    f+=texture(iChannel0,uv*1.).r*.125;f=pow(f,1.2);return f*.45+.05;\n}// We miss you on Twitch Luna... Sending some love.\nvec2 mp( vec3 p )\n{ \n  texNoi=texNoise(0.35*vec2(p.y,dot(p.xz,vec2(.7))))*.2; //texture based noise with naive triplanar uvs, adds really nice tiny crunchy details hard to recreate with a 3d noise function\n  td=noi(p*.2+1.5)*4.-noi(p*2.-.5)*.1-noi(p*.05)*2.+noi(p*.03)*5.-noi(p*.5)+texNoi; //td = terain displacement = a whole bunch of noise calls at different scales to create natural terrain. Bit like jamming your fingers in the socket and getting out an expensive haircut.\n  float ripple=sin(5.*(length((p.xz+vec2(2,2))*.7)-(0.2))-tt*10.)*0.5*b2; //Ripple motion for the pounding.\n  pp=p+td;//Make new position pp for terrain and add all the noise to displace it.\n  pp.y-=sin(p.x*.1)-sin(p.x*30.)*0.01; //Bit more displacement for the terrain and a subtl frill along the x axis\n  vec2 h,t=vec2(pp.y+5.+ripple,5.); //Create base terrain from a displaced plane\n  cn=noi(p*1.5+ripple)*.2; //To make terrain more interesting than plane we gonna add some displaced infinite cylinders, but we need to tweak them even more with more noise. It's like seeing Autechre live, but as if it's wasn't fucked up enough, you also took some acid.\n  t.x=smin(t.x,length(abs(pp.xz+cn)-vec2(5,5))-(1.1+ripple*.2-sin(p.y*.2)+sin(p.y*30.)*0.02),3.); //Add some vertical infinite tweaked out cylinder and do smooth merge with terrain. It's like genetrification, it's ok because hipsters are actually \"nice guys\".\n  t.x=smin(t.x,length(abs(pp.xy+cn-vec2(0,3))-vec2(12,0))-(1.1+ripple*.2-sin(p.z*.2)),13.); //More infinite cylinders this time horizontal. Making caves makes me feel like a man... I miss the days of slaying sabre tooth tigers to impress the ladies.\n  t.x*=0.55; //Remove the atrifact, fix me beautiful, baby.\n  h=pounder(p+vec3(2,5,2)); //MAKE IT POUND! Yeah could have been boring but then we have major earth pounding action, who doesn't love pumping hey? Even Donald Trump is a fan.\n  t=t.x<h.x?t:h; // Ah yeah make it pound but we gotta merge the columns with the rest, while retaining material IDs. It's like international diplomacy, everyone wants war, but let's have some tea and discuss these borders.\n  h=vec2(length(cos((p*.3-td*.2)+vec3(0,tt*1.,0))),6.); //MAKE IT SNOW! I know winter is finished but I live in England were it's always bleak and we like it like this. Yeah you can keep your sunshine, Europe!\n  g+=0.1/(cos(iTime)+h.x*h.x*1400.); //Yeah make them little snow particles glow, it might lift the mood a bit, we sort of miss the European sunshine since Brexit.\n  t=t.x<h.x?t:h; //Add particles to rest, like sprinkling glitter over your dick to make up for its lack of girth.\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(.1); //Near plane because when it all started there were no craft beer shops and boating shoes were for sailors.\n  for(int i=0;i<128;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft (get distance to geom)\n    if(h.x<.0001||t.x>40.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>40.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs\n  tt=mod(iTime+32.,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some life you've lived, Steve.\n  b=clamp(sin(tt*iTime),10.,1.),b2=clamp(sin(tt*2.-2.2),0.,1.),bb=smoothstep(0.,1.,b); //some global animation variables. Because cranking automatons is almost as fun as maturbation, my friends.\n  vec3 ro=mix(vec3(iTime-cos(tt*.4)*tt,5.,-17.+sin(tt*.2+1.)*-3.),vec3(cos(tt*.2)*tt,sin(tt*.4)*5.+tt,-12),ceil(sin(tt*.5))),//Ro=ray origin=camera position We bild camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0,cos(tt*.1)*5.,0)-ro), //cw camera forward?      \n  cu=normalize(cross(cw,vec3(0,1,0))), \t\t//cv camera up??\n  cv=normalize(cross(cu,cw)), \t\t\t\t//cu camera left vector??? Not sure broh, too busy burning fossil fuels and maximizing my carbon footprint.\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo,lp; //rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  lp=vec3(12,cos(iTime),2);//POINT LIGHT position is where the pounder is to create fake illumination from the core... Area lights I will do the day after I give up drinking, I promise.\n  co=fo=vec3(cos(iTime))-length(uv)*.09-rd.y*.07; //background is grey with vignette and subtle vertical gradient based on ray direction y axis. It's grey like the heart of people from Birmingham.\n  z=tr(ro,rd);t=z.x;//Trace the trace in the loop de loop. Aka sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(1),vec3(0.0,.12,.3),min(td*.4+0.1*abs(sin(pp*1.)),cos(iTime))); //by default albedo is mix between white and blue but the mix is done with noise of terrain so give really nice details in hues of blue\n    if(z.y<5.) al=vec3(cos(iTime)); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    ld=normalize(lp-po);   //Point light direction shit, get light dir from light pos.\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    attn=1.0-pow(min(1.0,length(lp-po)/20.),4.0), //Point light attenuation\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),30.);//Sp=specular, stolen from Shane, who is \"da man\"\n    co=attn*mix(sp+al*(a(.1)*a(.3)+.2)*(dif+(z.y==5.?s(0.8):0.)),fo,fr);//Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=clamp(mix(fo,co,exp(-.0001*t*t*t)),0.,1.);//Fog soften things, but it won't stop hipsters from gentrifying the north of England.\n  }  \n  fragColor = vec4(pow(co+g*0.1+g2*0.20*vec3(0.0,.2,.3),vec3(0.45)),1);// Naive gamma correction\n} //Thank you and good night brooooooski", "image_inputs": [{"id": 9, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tSyW1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[193, 256, 280, 280, 321], [322, 421, 438, 438, 481], [482, 583, 619, 619, 684], [685, 829, 847, 1037, 1257], [1258, 1258, 1282, 1433, 4026], [4027, 4138, 4162, 4162, 4360], [4360, 4412, 4431, 4431, 7019], [7020, 7020, 7102, 7102, 7869], [7959, 7959, 8088, 8088, 11342]], "test": "untested"}
{"id": "WlBcDh", "name": "Fire on Black", "author": "brunoliv", "description": "this is a copy shader without a background", "tags": ["fire"], "likes": 23, "viewed": 826, "published": 3, "date": "1594185878", "time_retrieved": "2024-07-30T20:56:39.646395", "image_code": "// I started working a bit on the colors of Remix 2, ended up with something like this. :)\n// Remix 2 here: https://www.shadertoy.com/view/MtcGD7\n// Remix 1 here: https://www.shadertoy.com/view/llc3DM\n// Original here: https://www.shadertoy.com/view/XsXXRN\n\nfloat rand(vec2 n) {\n    return fract(sin(cos(dot(n, vec2(12.9898,12.1414)))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nfloat fbm(vec2 n) {\n    float total = 0.0, amplitude = 1.0;\n    for (int i = 0; i <5; i++) {\n        total += noise(n) * amplitude;\n        n += n*1.7;\n        amplitude *= 0.47;\n    }\n    return total;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    const vec3 c1 = vec3(0.5, 0.0, 0.1);\n    const vec3 c2 = vec3(0.9, 0.1, 0.0);\n    const vec3 c3 = vec3(0.2, 0.1, 0.7);\n    const vec3 c4 = vec3(1.0, 0.9, 0.1);\n    const vec3 c5 = vec3(0.1);\n    const vec3 c6 = vec3(0.9);\n\n    vec2 speed = vec2(0.1, 0.9);\n    float shift = 1.327+sin(iTime*2.0)/2.4;\n    float alpha = 1.0;\n    \n\tfloat dist = 3.5-sin(iTime*0.4)/1.89;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = fragCoord.xy * dist / iResolution.xx;\n    p += sin(p.yx*4.0+vec2(.2,-.3)*iTime)*0.04;\n    p += sin(p.yx*8.0+vec2(.6,+.1)*iTime)*0.01;\n    \n    p.x -= iTime/1.1;\n    float q = fbm(p - iTime * 0.3+1.0*sin(iTime+0.5)/2.0);\n    float qb = fbm(p - iTime * 0.4+0.1*cos(iTime)/2.0);\n    float q2 = fbm(p - iTime * 0.44 - 5.0*cos(iTime)/2.0) - 6.0;\n    float q3 = fbm(p - iTime * 0.9 - 10.0*cos(iTime)/15.0)-4.0;\n    float q4 = fbm(p - iTime * 1.4 - 20.0*sin(iTime)/14.0)+2.0;\n    q = (q + qb - .4 * q2 -2.0*q3  + .6*q4)/3.8;\n    vec2 r = vec2(fbm(p + q /2.0 + iTime * speed.x - p.x - p.y), fbm(p + q - iTime * speed.y));\n    vec3 c = mix(c1, c2, fbm(p + r)) + mix(c3, c4, r.x) - mix(c5, c6, r.y);\n    vec3 color = vec3(1.0/(pow(c+1.61,vec3(4.0))) * cos(shift * fragCoord.y / iResolution.y));\n    \n    color=vec3(1.0,.2,.05)/(pow((r.y+r.y)* max(.0,p.y)+0.1, 4.0));;\n    color += (texture(iChannel0,uv*0.6+vec2(.5,.1)).xyz*0.01*pow((r.y+r.y)*.65,5.0)+0.055)*mix( vec3(.9,.4,.3),vec3(.7,.5,.2), uv.y);\n    color = color/(1.0+max(vec3(0),color));\n    fragColor = vec4(color.x, color.y, color.z, alpha);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[258, 258, 278, 278, 352], [354, 354, 375, 375, 581], [583, 583, 602, 602, 787], [789, 789, 846, 846, 2375]], "test": "untested"}
{"id": "WtScDh", "name": "Another alien megastructure", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/WtByDh]\"alien megastructure\"[/url] fractal. It reminds me of the Death Star from Star Wars.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal"], "likes": 0, "viewed": 335, "published": 3, "date": "1594180235", "time_retrieved": "2024-07-30T20:56:40.783355", "image_code": "\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(iTime*10.0,0,0);\n\tvec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t/(2*2*2*2))*(t>>(24*(t/(2*2*2*2*2*2*2*2*2*2*2*2))))|(t>>(7+(t/(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2))))|t/4;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 1000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 2.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    p -= p*sin(p/size/i)/(i);\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale*6.0;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}", "buffer_a_code": "\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfor (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n    }\n    \n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[3, 424, 515, 515, 882], [897, 1151, 1216, 1216, 1348], [1350, 1439, 1468, 1468, 1778], [1780, 2272, 2412, 2412, 3022], [3024, 3394, 3479, 3479, 3894], [3896, 4223, 4272, 4307, 4438], [4440, 4440, 4467, 4467, 4616], [4618, 4618, 4675, 4675, 5597]], "test": "untested"}
{"id": "WtByDh", "name": "Alien megastructure", "author": "jarble", "description": "This is based on my [url=https://www.shadertoy.com/view/tl2yDzttps://www.shadertoy.com/view/WtjyDz]\"Amazing cave fractal.\"[/url]", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 335, "published": 3, "date": "1594178998", "time_retrieved": "2024-07-30T20:56:41.739798", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON*8.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(depth+1.0)) {\n\t\t\tif(iters < num_iters){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n        vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t+(t/(4096))))|t/2/32|t/3/32|t/5/32;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 6000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n#define num_iters 3\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    p -= p.zyx*(p/(size*10.0));\n    vec3 p1 = p/size;\n    p = (sin((p1)/i+p1))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i1 = 1.0;\n    for(int i = -1; i < num_iters; i ++){\n        p = p*i1;\n    \tresult = max(result, -planet_surface(p,i1)/(i1));\n        i1 *= 3.0;\n        if(i == num_iters) break;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,num_iters);\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON*8.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(depth+1.0)*image_scale*2.0) {\n\t\t\tif(iters < num_iters){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+log(length(eye-dmap)+1.0)*2.0, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByDh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 206], [209, 630, 721, 721, 1257], [1272, 1526, 1591, 1591, 1723], [1725, 1814, 1843, 1843, 2153], [2155, 2647, 2787, 2787, 3397], [3399, 3769, 3854, 3854, 4269], [4271, 4598, 4647, 4682, 4813], [4815, 4815, 4842, 4842, 4991], [4993, 4993, 5050, 5050, 5989]], "test": "untested"}
{"id": "3lByWh", "name": "Tunnel of Bones", "author": "jarble", "description": "This fractal has many strange bone-like structures.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 292, "published": 3, "date": "1594172438", "time_retrieved": "2024-07-30T20:56:42.583542", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    \n    vec3 p1 = p/size-sin((p+p.yzx/i)/size)*i;\n    p = (sin((p1.yzx/i)))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 27.0; i *= 3.0){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/30.0+vec3(.7);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale/10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByWh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 627, 627, 741], [743, 743, 778, 778, 1030], [1032, 1032, 1055, 1055, 1082], [1084, 1084, 1112, 1112, 1243], [1246, 1667, 1758, 1758, 2087], [2102, 2356, 2421, 2421, 2553], [2555, 2644, 2673, 2673, 2983], [2985, 3477, 3617, 3617, 4227], [4229, 4599, 4684, 4684, 5099], [5101, 5428, 5477, 5512, 5643], [5645, 5645, 5702, 5702, 6795]], "test": "untested"}
{"id": "tl2yDz", "name": "Amazing cave fractal", "author": "jarble", "description": "This is a modification of my [url=https://www.shadertoy.com/view/WtjyDz]\"alien hive\"[/url] fractal. it vaguely resembles a distorted Mandelbox.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 327, "published": 3, "date": "1594168541", "time_retrieved": "2024-07-30T20:56:43.513057", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n        i *= 3.0;\n        if(iters == k) break;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,4);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/16.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if ((dist) < eps*(1.0+depth)) {\n\t\t\tif(iters < 4){iters += 1;}\n            else {return depth;}\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    float dist = length(depth_map(fragCoord).xyz-eye);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.0001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*100.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(inout vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nfloat sceneSDF(vec3 p,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        p = p*i;\n    \tresult = max(result, -planet_surface(p,i)/(i));\n        i *= 3.0;\n        if(iters == k) break;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    return sceneSDF(p,4);\n}\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON/16.0;\n    int iters = 0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 4){iters += 1;}\n            else {return depth;}\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = log(length(dmap-eye)+1.0)*2.0;\n\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 92, 92, 404], [406, 406, 429, 429, 457], [460, 460, 488, 488, 606], [609, 1030, 1121, 1121, 1559], [1574, 1828, 1893, 1893, 2025], [2027, 2116, 2145, 2145, 2455], [2457, 2949, 3089, 3089, 3699], [3701, 4071, 4156, 4156, 4571], [4573, 4900, 4949, 4984, 5115], [5117, 5117, 5144, 5144, 5199], [5202, 5202, 5259, 5259, 6307]], "test": "untested"}
{"id": "Xt3Sz4", "name": "Ray Marching Experiment n°78", "author": "aiekick", "description": "Ray Marching Experiment n°78", "tags": ["ray", "experiment", "marching", "78"], "likes": 7, "viewed": 350, "published": 3, "date": "1594161122", "time_retrieved": "2024-07-30T20:56:44.263051", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define SMOOTH 0.5\n// thick 0.01 is like weird planet\n#define THICK 0.01\n\n///////////////////////////////////////////\nvec4 displacement(vec3 p)\n{\n    p/=5.;\n    p.y += sin(p.x) * cos(p.z);\n\tvec2 uv = vec2(length(p.xz*1.8 * sin(p.y*1.5)*1.2));\n\tuv.x -= mod(iTime, 10.)*.1;\n\treturn texture(iChannel1, uv, SMOOTH);\n}\n\nvec4 map(vec3 p)\n{\n    p.y = abs(p.y);\n   \tvec4 disp = displacement(p);\n  \tfloat dist = length(p) - 4. + disp.x;\n    return vec4(dist, disp.rgb);\n}\n\n///////////////////////////////////////////\n//FROM IQ Shader https://www.shadertoy.com/view/Xds3zN\nfloat sha( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat aoc( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\n///////////////////////////////////////////\nvec3 nor( in vec3 p, float prec )\n{\n\tvec2 e = vec2( prec, 0.);\n\tvec3 n = vec3(\n\t    map(p+e.xyy).x - map(p-e.xyy).x,\n\t    map(p+e.yxy).x - map(p-e.yxy).x,\n\t    map(p+e.yyx).x - map(p-e.yyx).x );\n\treturn normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd, float rmPrec, float maxd, float mapPrec)\n{\n    float s = rmPrec;\n    float d = 0.;\n    for(int i=0;i<200;i++)\n    {      \n        if (s<rmPrec||s>maxd) break;\n        s = map(ro+rd*d).x;\n\t\ts *= (s>0.1?0.2:0.01);\n        d += s;\n    }\n    return d;\n}\n\n////////MAIN///////////////////////////////\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime * 0.1;\n    float cam_a = time; // angle z\n    \n    float cam_e = 5.52; // elevation\n    float cam_d = 1.88; // distance to origin axis\n    \n    vec3 camUp=vec3(0,1,0);//Change camere up vector here\n  \tvec3 camView=vec3(0,0,0); //Change camere view here\n  \tfloat li = 0.6; // light intensity\n    float prec = 0.00001; // ray marching precision\n    float maxd = 4.5; // ray marching distance max\n    float refl_i = 0.45; // reflexion intensity\n    float refr_a = 0.7; // refraction angle\n    float refr_i = 0.8; // refraction intensity\n    float bii = 0.35; // bright init intensity\n    float marchPrecision = 0.3; // ray marching tolerance precision\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. -1.;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec3 ro = vec3(-sin(cam_a)*cam_d, cam_e+1., cos(cam_a)*cam_d); //\n  \tvec3 rov = normalize(camView-ro);\n    vec3 u = normalize(cross(camUp,rov));\n  \tvec3 v = cross(rov,u);\n  \tvec3 rd = normalize(rov + uv.x*u + uv.y*v);\n    \n    float b = bii;\n    \n    float d = march(ro, rd, prec, maxd, marchPrecision);\n    \n    if (d<maxd)\n    {\n        vec3 p = ro+rd*d;\n        vec3 n = nor(p, 0.1);\n        \n        b=li;\n        \n        vec3 reflRay = reflect(rd, n);\n\t\tvec3 refrRay = refract(rd, n, refr_a);\n        \n        vec3 cubeRefl = texture(iChannel0, reflRay).rgb * refl_i;\n        vec3 cubeRefr = texture(iChannel0, refrRay).rgb * refr_i;\n        \n        col = cubeRefl + cubeRefr + pow(b, 15.);\n        \n       \t// lighting        \n        float occ = aoc( p, n );\n\t\tvec3  lig = normalize( vec3(-0.6, 0.7, -0.5) );\n\t\tfloat amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( n, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-p.y,0.0,1.0);\n        float dom = smoothstep( -0.1, 0.1, reflRay.y );\n        float fre = pow( clamp(1.0+dot(n,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( reflRay, lig ), 0.0, 1.0 ),16.0);\n        \n        dif *= sha( p, lig, 0.02, 2.5 );\n       \tdom *= sha( p, reflRay, 0.02, 2.5 );\n\n\t\tvec3 brdf = vec3(0.0);\n        brdf += 1.20*dif*vec3(1.00,0.90,0.60);\n\t\tbrdf += 1.20*spe*vec3(1.00,0.90,0.60)*dif;\n        brdf += 0.30*amb*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.40*dom*vec3(0.50,0.70,1.00)*occ;\n        brdf += 0.30*bac*vec3(0.25,0.25,0.25)*occ;\n        brdf += 0.40*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tbrdf += 0.02;\n\t\tcol = col*brdf;\n\n    \tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0005*d*d ) );\n        \n       \tcol = mix(col, map(p).yzw, 0.5);\n    }\n    else\n    {\n        b+=0.1;\n        col = texture(iChannel0, rd).rgb;\n    }\n    \n\tfragColor.rgb = col;\n}\n\n", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt3Sz4.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[212, 256, 283, 283, 451], [453, 453, 471, 471, 600], [602, 701, 768, 768, 1028], [1030, 1030, 1069, 1069, 1368], [1371, 1415, 1450, 1450, 1633], [1635, 1635, 1707, 1707, 1914], [1916, 1960, 2017, 2017, 4713]], "test": "untested"}
{"id": "wt2cWR", "name": "flamey circle tail thing", "author": "sh1boot", "description": "not finished", "tags": ["circle", "mask", "dissipation"], "likes": 1, "viewed": 321, "published": 3, "date": "1594157618", "time_retrieved": "2024-07-30T20:56:45.012049", "image_code": "float random(in float x) {\n    x = log2(abs(x) + 0.000001);\n    x = fract(sin(x) * 21.56789 + cos(x) * 11.98765);\n    return fract(x + 2.0);\n}\n\nfloat random(in float x, in float y) {\n    return random(sin(x * 7.1010101) + cos(y * 9.3131313) + 2.1);\n}\n\nvec2 bubble(int slice, int i) {\n    float fs = fract(float(slice) * 0.1);\n    float f = float(i) + 123.45 * fs;\n    return vec2(\n        random(1.5 * f, 3.1415926 * f) * 2.0,\n        random(2.5 * f, 1.6180340 * f) * 0.1 + fs);\n}\n\nfloat tail(float y, float t) {\n    return (sin(t - y) + sin((t - y) * 3.1)) * 0.2 + 0.5;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.xy;\n#if 1\n    uv.y = (uv.y - .5) * iResolution.y / iResolution.x + .5;\n#else\n    uv.x = (uv.x - .5) * iResolution.x / iResolution.y + .5;\n#endif\n    #if 0\n    float radius = 0.04;\n#else\n    float radius = 0.005 + uv.y * 0.15;\n#endif\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5 * cos(iTime+uv.xyx+vec3(0,2,4));\n\n    float t = fract(iTime * 0.3);\n    float y = fract(uv.y - t);\n    for (int j = -1; j < 2; ++j) {\n        int row = int(y * 10.0) + j;\n        for (int i = 0; i < 45; i++) {\n            vec2 bub = bubble(row, i);\n            bub.y = fract(bub.y + t);\n            float x = tail(bub.y, iTime * 0.3);\n            if (distance(x, bub.x) < 0.075) bub.x += 0.15;\n\n            col *= smoothstep(radius, radius*1.01, distance(uv, bub));\n        }\n    }\n    float p = tail(uv.y, iTime * 0.3);\n    col *= 1.0 - smoothstep(0.1,0.11, distance(p, uv.x));\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 142], [144, 144, 182, 182, 250], [252, 252, 283, 283, 480], [482, 482, 512, 512, 572], [574, 574, 629, 629, 1571]], "test": "untested"}
{"id": "wljyDR", "name": "Twisted vine forest", "author": "jarble", "description": "This \"twisted\" vine forest is a modification of my [url=https://www.shadertoy.com/view/3lBcWz]recursive vine forest.[/url]\n", "tags": ["3d", "raymarching", "recursion"], "likes": 1, "viewed": 270, "published": 3, "date": "1594156013", "time_retrieved": "2024-07-30T20:56:45.800940", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = sin(p/size1);\n    p = (cos(p/vec3(length((p/81.0)))))*size1;\n    return size-length(p)/1.86;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    for(float i = 9.0; i < 729.0; i *= 9.0){\n    \t//float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines(p*i-result,size1)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*200.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime/5.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 621, 621, 740], [743, 743, 767, 767, 1101], [1103, 1103, 1131, 1131, 1279], [1282, 1703, 1794, 1794, 2112], [2127, 2381, 2446, 2446, 2578], [2580, 2669, 2698, 2698, 3008], [3010, 3502, 3642, 3642, 4252], [4254, 4624, 4709, 4709, 5056], [5058, 5385, 5434, 5469, 5600], [5602, 5602, 5659, 5659, 6759]], "test": "untested"}
{"id": "ttjyDR", "name": "Sharpness filter with intensity", "author": "palash", "description": "Simple sharpness filter with intensity. Move mouse up down for intensity.", "tags": ["convolution", "sharpness", "intensity"], "likes": 3, "viewed": 409, "published": 3, "date": "1594155117", "time_retrieved": "2024-07-30T20:56:46.551931", "image_code": "// from https://www.shadertoy.com/view/llXGWf\n\n// Sharpness kernel\n// -x   -x    -x\n// -x  x*8+1  -x\n// -x   -x    -x\n\nvec3 texsample(const int x, const int y, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy / iResolution.xy * iChannelResolution[0].xy;\n\tuv = (uv + vec2(x, y)) / iChannelResolution[0].xy;\n\treturn texture(iChannel0, uv).xyz;\n}\n\nvec3 texfilter(in vec2 fragCoord, in float intensity)\n{\n    vec3 sum = texsample(-1, -1, fragCoord) * -intensity\n             + texsample(-1,  0, fragCoord) * -intensity\n             + texsample(-1,  1, fragCoord) * -intensity\n             + texsample( 0, -1, fragCoord) * -intensity\n             + texsample( 0,  0, fragCoord) * (intensity * 8. + 1.) // sum should always be +1\n             + texsample( 0,  1, fragCoord) * -intensity\n             + texsample( 1, -1, fragCoord) * -intensity\n             + texsample( 1,  0, fragCoord) * -intensity\n             + texsample( 1,  1, fragCoord) * -intensity;\n    \n\treturn sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float u = fragCoord.x / iResolution.x;\n    float m = iMouse.x / iResolution.x;\n    float i = iMouse.y / iResolution.y * 2.0;\n    \n    float l = smoothstep(0., 1. / iResolution.y, abs(m - u));\n    \n    vec2 fc = fragCoord.xy;\n    fc.y = iResolution.y - fragCoord.y;\n    \n    vec3 cf = texfilter(fc, i);\n    vec3 cl = texsample(0, 0, fc);\n    vec3 cr = (u < m ? cl : cf) * l;\n    \n    fragColor = vec4(cr, 1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 180, 180, 342], [344, 344, 399, 399, 971], [973, 973, 1030, 1030, 1444]], "test": "untested"}
{"id": "tl2yWR", "name": "Fractal tunnel", "author": "jarble", "description": "A simple tunnel, based on my [url=https://www.shadertoy.com/view/wljyWR]\"swiss cheese caves\"[/url] fractal.", "tags": ["3d", "raymarching", "fractal"], "likes": 5, "viewed": 324, "published": 3, "date": "1594152278", "time_retrieved": "2024-07-30T20:56:47.383708", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    return length(sin((p*(i+1.0)/size))*size) - size;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n    \tresult += planet_surface(p*i,i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*5.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 621, 621, 677], [679, 679, 714, 714, 942], [944, 944, 967, 967, 994], [996, 996, 1024, 1024, 1154], [1157, 1578, 1669, 1669, 1975], [1990, 2244, 2309, 2309, 2441], [2443, 2532, 2561, 2561, 2871], [2873, 3365, 3505, 3505, 4115], [4117, 4487, 4572, 4572, 4987], [4989, 5316, 5365, 5400, 5531], [5533, 5533, 5590, 5590, 6666]], "test": "untested"}
{"id": "wljyWR", "name": "Swiss cheese caves", "author": "jarble", "description": "This fractal is based on my [url=https://www.shadertoy.com/view/WtjyDz]\"alien hive.\"[/url] It looks more like a cave than a hive.", "tags": ["3d", "raymarching", "fractal"], "likes": 3, "viewed": 282, "published": 3, "date": "1594151414", "time_retrieved": "2024-07-30T20:56:48.217478", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx*i/3.0+p1/i)+p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 3;k++){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    float i = 3.0;\n    for(int k = 0; k < 3; k++){\n        //add bumps to the surface\n    \tresult -= sceneSDF1(p*i)/(i*9.0);\n        i *= 3.0;\n    }\n    return result*scale*200.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0),sceneSDF(p*3.0),sceneSDF(p*2.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*10.0,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 622, 622, 722], [726, 726, 751, 751, 1017], [1019, 1019, 1042, 1042, 1257], [1259, 1259, 1287, 1287, 1405], [1408, 1829, 1920, 1920, 2244], [2259, 2513, 2578, 2578, 2710], [2712, 2801, 2830, 2830, 3140], [3142, 3634, 3774, 3774, 4384], [4386, 4756, 4841, 4841, 5256], [5258, 5585, 5634, 5669, 5800], [5802, 5802, 5859, 5859, 6931]], "test": "untested"}
{"id": "3ljcDz", "name": "pixelbased edge detection offset", "author": "thefox231", "description": "it looks funny when you point it at a stop sign\nuse mouse to select a point to offset from", "tags": ["edgedetection"], "likes": 1, "viewed": 271, "published": 3, "date": "1594149290", "time_retrieved": "2024-07-30T20:56:49.054242", "image_code": "#define amp 0.9\n#define transform 0.9\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = texture(iChannel0, uv).rgb;\n    vec3 newCol;\n\n    float offset = 0.02;\n    \n    for (int i = 0; i < 3; i++) {\n      \tvec2 uv = uv;\n        \n        vec2 dist = vec2(\n        \t(\n            \ttexture(iChannel0, uv)[i] - texture(iChannel0, uv + vec2(-1.0, 0.0) * offset)[i] +\n            \ttexture(iChannel0, uv)[i] - texture(iChannel0, uv + vec2(1.0, 0.0) * offset)[i]\n\t\t\t) / 2.0,\n        \t(\n            \ttexture(iChannel0, uv)[i] - texture(iChannel0, uv + vec2(0.0, -1.0) * offset)[i] +\n            \ttexture(iChannel0, uv)[i] - texture(iChannel0, uv + vec2(0.0, 1.0) * offset)[i]\n        \t) / 2.0\n\t\t);\n        \n      \tuv = (iMouse.xy / iResolution.xy) + dist * amp;\n        uv = fract(uv);\n        newCol[i] = texture(iChannel0, uv)[i];\n    }\n    \n    fragColor = vec4(mix(newCol, texture(iChannel0, uv).rgb, 1.0 - transform), 1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 94, 94, 983]], "test": "untested"}
{"id": "WtjyDz", "name": "Alien hive", "author": "jarble", "description": "Another interesting fractal structure.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 408, "published": 3, "date": "1594143681", "time_retrieved": "2024-07-30T20:56:50.077506", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS/8; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (dist < eps*(1.0+depth)) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n        }\n        depth += dist;\n        //eps *= 1.01;\n        if (depth >= end) {\n            return depth;\n        }\n    }\n    return depth;\n}\n            \n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    vec4 dmap = depth_map(fragCoord);\n    //float dist = dmap.x;\n\tvec3 p =  eye + dmap.x * worldDir;\n    //vec3 worldDir = normalize(p-eye);\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, dmap.x, MAX_DIST);\n    //float dist = length(eye-p);\n    \n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\n/*\nvec2 sound1(int t)\n{\n    int t1 = t>>2-t>>1;\n    t = (t/(t>>7))&t/(t>>5)/(t1|-t1);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 5000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.1;\n    }\n    return result;\n}\n\n*/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        if(i>3){\n        \tresult += sound1(time*factor)/(factor);\n        }\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n\n", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end,out float steps) {\n    float depth = start;\n    int iters = 1;\n    float eps = EPSILON*4.0;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        steps += 1.0;\n        float dist = sceneSDF(eye + depth * marchingDirection,iters);\n        if (abs(dist) < eps*(1.0+depth)*image_scale/2.0) {\n\t\t\tif(iters < 3){\n                iters += 1;\n                eps /= 2.0;\n            }\n            else\n            return depth-dist;\n            \n        }\n        depth += dist*1.5;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \nfloat min_edge(vec2 coord){\n    float minimum = depth_map(coord).y;\n    for(float i = -1.0; i < 2.0; i++){\n        for(float j = -1.0; j < 2.0; j++){\n            vec4 dmap = depth_map(vec2(coord.x+i,coord.y+j));\n            minimum = min(minimum,dmap.y);\n        }\n    }\n    return minimum;\n}\n\n\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 dmap = depth_map(fragCoord);\n    //float edge_dist = min_edge(fragCoord);\n    \n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord = fragCoord * image_scale;\n    fragCoord+= vec2(image_scale/2.0);\n    \n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime*speed,0,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    \n    \n    float steps;\n    float steps1 = dmap.z;\n    //float l1 = (sceneSDF(eye+dmap.y*worldDir/2.0));\n    \n    //float l0 = dmap.x-log(1.0+dmap.x);\n    float l0;\n    l0 = sqrt(dmap.x);\n    \n    //if(abs(dmap.x-dmap.y) < 10.0){\n        //l0 = edge_dist*.9;\n    //}\n    //else{\n        \n        //l0 = edge_dist/2.0;\n        //l0 = dmap.x*.9*hash11(dmao);\n    ///}\n\n    \n    //float l0 = dmap.x;\n\n    \n    //if(dmap.y > 0.1){\n    //    l0 = max(0.0,log(l0)/2.0);\n    //}\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST,steps);\n    \n    //if(l0 > .1){\n        //dist = dist;\n    //}\n    \n    //if(dist > dmap.x){\n        //dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST,steps);\n    //}\n    \n    \n\n    // The closest point on the surface to the eyepoint along the view ray\n    //vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(dist,min(dmap.x,dist),steps,0);\n    //buffer needs to be repeat instead of clamp\n    }\n}", "buffer_a_inputs": [], "common_code": "\n#define SHADOW_ITER 20\n#define image_scale 2.0\n//change Z-buffer resolution\n\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\n\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nconst float MIN_DIST = EPSILON;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\nfloat planet_surface(vec3 p,float i){\n    \n    vec3 p1 = p/size;\n    p = (sin(sin(p1.yzx+p1/i)+p1.yzx))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim,int iters) {\n    p /= scale*2.0;\n    float result = 0.0;\n    float i = 1.0;\n    for(int i1 = 0; i1 < 4; i1++){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n        if(i1 > iters) break;\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/1.5;\n}\n\nfloat sceneSDF(vec3 p,int iters){\n\treturn sceneSDF(p,1.0,iters);\n}\n\nfloat sceneSDF(vec3 p,float anim){\n\treturn sceneSDF(p,anim,4);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0,4);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 estimateNormal_(vec3 p) {\n    //surface color for bump mapping\n    return (vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\n\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 479, 570, 570, 1086], [1101, 1101, 1128, 1128, 1273], [1275, 1275, 1332, 1332, 2366]], "test": "untested"}
{"id": "Wt2yWz", "name": "shufflin blur", "author": "thefox231", "description": "interesting little shader, gets very messy at high amp values\nuse mouse to control amp value", "tags": ["blur", "texture", "rainbow"], "likes": 4, "viewed": 376, "published": 3, "date": "1594134934", "time_retrieved": "2024-07-30T20:56:51.074839", "image_code": "#define amp iMouse.x/12.0\n#define PI 3.1415\n#define blur_samples 20\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec4 edge = (\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(1.0, 0.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(0.0, 1.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(-1.0, 0.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(0.0, -1.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(1.0, -1.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(-1.0, 1.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(1.0, 1.0))/iResolution.xy)) +\n       abs(texture(iChannel0, uv) - texture(iChannel0, (fragCoord + vec2(-1.0, -1.0))/iResolution.xy))\n    ) / 8.0;\n\n    vec3 finalCol = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n    \tfloat effectAmp = amp * (edge[i] + .1);\n    \n    \tfloat angle = iTime + float(i) + uv.y - uv.x * tan(effectAmp * uv.y);\n    \n    \tvec3 col = vec3(0.0);\n    \n    \tfor (int i = -2; i < blur_samples; i++) {\n        \tfloat blurAmp = effectAmp * (float(i)/float(blur_samples));\n        \t//blurAmp *= float(iFrame % 2) - .5;\n        \n        \tcol = mix(col, texture(iChannel0, uv + vec2(blurAmp * cos(angle), blurAmp * sin(angle))).rgb, float(i) / float(blur_samples));\n    \t}\n        \n    \tfinalCol[i] = col[i];\n    }\n    \n    fragColor = vec4(finalCol,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "WtBcDz", "name": "Wave equation 3D", "author": "michael0884", "description": "Trying out cubemap based simulations. A 128^3 simulation domain", "tags": ["2d", "3d", "data", "landau", "ginsburg"], "likes": 21, "viewed": 598, "published": 3, "date": "1594128869", "time_retrieved": "2024-07-30T20:56:51.870711", "image_code": "// Fork of \"Cubemap utils\" by rory618. https://shadertoy.com/view/wdsBRn\n// 2020-07-06 22:07:44\n\n//trilinear sampling\nvec4 S(vec3 x)\n{\n    vec4 X = vec4(x, 0.);\n    float zf = fract(X.z);\n    float zi = floor(X.z);\n    X.z = zi;\n    vec3 r0 = XYFaceToRayDir(getC(X));\n    vec3 r1 = XYFaceToRayDir(getC(X+vec4(0,0,1,0)));\n    return mix(texture(iChannel0, r0),texture(iChannel0, r1),zf);\n}\n\nfloat rho(vec3 x)\n{\n    x = x + vec3(B)*0.5;  \n    vec3 b = step(0., x)*step(x, vec3(B));\n    vec4 v = S(x);\n    return b.x*b.y*b.z*length(v.xy);\n}\n\nvec4 calcGrad( in vec3 pos )\n{\n    vec4 e = vec4(1.,-1., 0.25, -0.25);\n    return   (e.zwwz*rho( pos + e.xyy ) + \n  \t\t\t  e.wwzz*rho( pos + e.yyx ) + \n\t\t\t  e.wzwz*rho( pos + e.yxy ) + \n              e.zzzz*rho( pos + e.xxx ) )/vec4(e.xxx, 1.);\n}\n\nvec3 ray; vec3 cpos; vec2 angles;\nmat3 rmat;\nvec2 p;\nvec3 getRay(vec2 pos)\n{\n    rmat = getRot(angles);\n    vec2 uv = FOV*(pos - R*0.5)/R.x;\n    return normalize(rmat[0]*uv.x + rmat[1]*uv.y + rmat[2]);\n}\n\n// this noise, including the 5.58... scrolling constant are from Jorge Jimenez\nfloat InterleavedGradientNoise(vec2 pixel, int frame) \n{\n    pixel += (float(frame) * 5.588238f);\n    return fract(52.9829189f * fract(0.06711056f*float(pixel.x) + 0.00583715f*float(pixel.y)));  \n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    float size = min(iResolution.y/3., iResolution.x/4.);\n    \n    //setup camera\n    angles = (iMouse.z>0.)?(iMouse.xy/R)*vec2(2.*PI, PI):vec2(0.5*iTime, PI*0.5+0.5*sin(0.15*iTime));\n    cpos = -camd*getRay(R*0.5);\n    ray = getRay(I);\n    \n    vec4 c = vec4(0., 0., 0., 1.);\n    float td = 0.;\n    float dtd = 5.; //+ 10.*InterleavedGradientNoise(I, iFrame);\n    for(int i = 0; i < 64; i++)\n    {\n        float r = rho(cpos + ray*td);\n        vec3 col = 0.5*(0.5 - 0.5*cos(1.*vec3(1,2,3)*r*r));\n        dtd = 8./(1. + 10.*r);\n        td += dtd;\n        float alpha = smoothstep(3., 0.4, r);\n        c.w = c.w*alpha;\n        if(c.w < 0.05) break;\n        c.xyz += col*(1. - alpha)*dtd; \n    }\n    \n    if(c.w < 0.05)\n    {\n        vec3 p = cpos + ray*td;\n        vec4 g = calcGrad(p);\n        vec3 n = -normalize(g.xyz);\n        vec3 r = reflect(ray, n);\n        c.xyz += texture(iChannel2, r.xzy).xyz;\n    }\n   \n    \n    \n    c.xyz += c.w*texture(iChannel2, ray.xzy).xyz;\n    \n    O = tanh(c);\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "cube_a_code": "#define dt 0.5\n\n//sample the domain\nvec4 S(ivec4 X)\n{\n    vec3 r = XYFaceToRayDir(getC(vec4(X)));\n    return texture(iChannel0, r);\n}\n\nvoid mainCubemap( out vec4 Q, in vec2 fragCoord, in vec3 rayOri, in vec3 rayDir )\n{        \n    ivec3 XYFace = RayDirToXYFace(rayDir);\n   \tivec4 X = getX(XYFace);\n    \n    if(X.w == 0)\n    {\n    \tQ = S(X);\n    \tvec4 laplacian = (S(X + DX.zyyy) + S(X + DX.xyyy) +\n        \t\t\t\t  S(X + DX.yzyy) + S(X + DX.yxyy) +\n        \t\t\t\t  S(X + DX.yyzy) + S(X + DX.yyxy))/6. -  Q;\n    \n    \tQ.zw += dt*(laplacian.xy - 0.05*Q.xy*cos(length(Q.xy)) - 0.05*Q.xy);//*cos(length(Q.xy)));\n        Q.xy += dt*Q.zw;\n        \n        vec3 x = vec3(X.xyz);\n        vec3 border = smoothstep(0.,3., x)*smoothstep(vec3(B),vec3(B)-3.,x);\n        Q.xy *= pow(border.x*border.y*border.z, 0.2);\n        \n        if(iFrame < 10)\n        {\n            Q = vec4(PI, 0., 0., PI)*G(vec3(X.xyz - B/2)/30.)\n                + vec4(1.*PI, 0., 0., 1.*PI)*G(vec3(X.xyz - B/3)/5.)\n                + vec4(1.*PI, 0., 0., 1.*PI)*G((vec3(X.xyz) - vec3(B)*vec3(0.7, 0.5,0.2))/5.);\n            Q*=2.;\n        }\n    }\n}", "cube_a_inputs": [{"id": 41, "src": "/media/a//media/previz/cubemap00.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define PI 3.14159265\n\n//render range\n#define range 500.\n#define FOV 2.\n#define camd 180.\n\n//number of variables\n#define VAR 3\n\n#define CUBE 1024\n\n//the domain\n#define B ivec3(128,128,128)\n\n#define DX ivec3(-1, 0, 1)\n\n//convert to domain coordinates\nivec4 getX(ivec3 XYface)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int var = XYface.z/s;\n    ivec2 z2 = XYface.xy/B.xy;\n    int Z = z2.x + z2.y*N.x + (XYface.z%s)*N.x*N.y;\n    ivec2 XY = XYface.xy%B.xy;\n    \n    return ivec4(XY, Z, var);\n}\n\n//convert to cubemap coordinates\nvec3 getC(vec4 p)\n{\n    int s = 6/VAR;\n    ivec2 N = CUBE/B.xy; //number of slices\n    \n    int pz = int(p.z);\n    ivec3 z3 = ivec3(pz%N.x, (pz/N.x)%N.y, pz/(N.x*N.y));\n    vec2 XY = p.xy + vec2(z3.xy*B.xy);\n    \n    return vec3(XY, p.w*float(s) + float(z3.z));\n}\n\n\nfloat G(vec3 x)\n{\n    return exp(-dot(x,x));\n}\n\nfloat G0(vec3 x)\n{\n    return exp(-length(x));\n}\n\nmat3 getRot(vec2 a)\n{\n    \n   mat3 theta_rot = mat3(1,     0,        0,\n                         0,  cos(a.y), sin(a.y), \n                         0, -sin(a.y), cos(a.y)); \n        \n   mat3 phi_rot = mat3(cos(a.x),  sin(a.x), 0,\n        \t\t       -sin(a.x), cos(a.x), 0,\n        \t\t        0,            0,    1); \n   return phi_rot*theta_rot;\n}\n\n\n\nvec3 XYFaceToRayDir(vec3 p){\n    vec2 x = vec2(p-512.) + 0.5;\n           if (p.z==0.){     return vec3( 512.,-x.y,-x.x);\n    } else if (p.z==1.){     return vec3( x.x, 512., x.y);\n    } else if (p.z==2.){     return vec3( x.x,-x.y, 512.);\n    } else if (p.z==3.){     return vec3(-512.,-x.y, x.x);\n    } else if (p.z==4.){     return vec3( x.x,-512.,-x.y);\n    } else if (p.z==5.){     return vec3(-x.x,-x.y,-512.);\n    } else return vec3(0);\n}\nivec3 RayDirToXYFace(vec3 dir){\n    \n    if        (dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /= dir.x/512.;\n        return ivec3(-dir.z+512., -dir.y+512., 0);\n    } else if (dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /= dir.y/512.;\n        return ivec3(dir.x+512., dir.z+512.,1);\n    } else if (dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /= dir.z/512.;\n        return ivec3(dir.x+512.,-dir.y+512.,2);\n    } else if (-dir.x>max(abs(dir.y),abs(dir.z))){\n        dir /=-dir.x/512.;\n        return ivec3(dir.z+512.,-dir.y+512.,3);\n    } else if (-dir.y>max(abs(dir.z),abs(dir.x))){\n        dir /=-dir.y/512.;\n        return ivec3(dir.x+512.,-dir.z+512.,4);\n    } else if (-dir.z>max(abs(dir.x),abs(dir.y))){\n        dir /=-dir.z/512.;\n        return ivec3(-dir.x+512.,-dir.y+512.,5);\n    } else return ivec3(0,0,-1);\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 118, 134, 134, 388], [390, 390, 409, 409, 537], [539, 539, 569, 569, 783], [838, 838, 861, 861, 988], [1268, 1268, 1309, 1309, 2307]], "test": "untested"}
{"id": "3tjyDR", "name": "circle vs spiral illusion (203)", "author": "FabriceNeyret2", "description": "reference:\n[img]https://i.redd.it/7zm03eo01ma41.jpg[/img]", "tags": ["illusion", "2tweets", "perception", "short", "golf"], "likes": 14, "viewed": 341, "published": 3, "date": "1594127708", "time_retrieved": "2024-07-30T20:56:53.034599", "image_code": "// 203   without time\n#define S(r,s)  smoothstep (.01, -.01, abs(l-r) -.025 )  \\\n              * cos( s 18.* abs(a) - 79.*l )            //                  \nvoid mainImage(out vec4 O, vec2 u) {\n    vec2  R = iResolution.xy,\n          U = u+u - R;\n    float l = length(U)/R.y, a = atan(U.x,U.y) - .3*iTime;\n    O += .5 + .2 * (   S(.8, - ) + S(.6, )  )\n                 * ( 1. +  sin(72.*a)   );}             /*\n //; O = sqrt(O)\n\n\n\n// --- 257 chars\n\n#define S(v)  smoothstep (.01, -.01, v )\nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = ( u+u - R ) / R.y;\n    float l = length(U), a = abs( atan(U.x,U.y) );\n    O-=O;\n    O += .4* (   S( abs(l-.8)-.02 ) * sin( -18.* a -6.3*l/.08 )\n               + S( abs(l-.7)-.02 ) * sin(  18.* a -6.3*l/.08 ) \n             )* (.5+.5*sin(72.*a))\n      + .5;\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "Wt2cWR", "name": "Synesthetic Rings", "author": "isaacchurchill", "description": "I enjoyed playing around with this :)\nFeel free to experiment with different values for num_rings and circles_per_ring.", "tags": ["2d", "sound", "colors", "audio", "visualizer", "musicvisualizer", "soundcloud"], "likes": 12, "viewed": 428, "published": 3, "date": "1594125192", "time_retrieved": "2024-07-30T20:56:53.908263", "image_code": "//#define XOR_COLORING\n\n#define PI 3.14159265\n\nvec3 palette(float f)\n{\n#ifdef XOR_COLORING\n    return vec3(mod(f, 2.0));\n#else\n    f *= 0.09 * PI * 2.0;\n    return clamp(\n        vec3(sin(f + 2.0), sin(f + 1.0), sin(f + 0.0)),\n        0.0, 1.0);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n\n    float circle_radii = abs(texture(iChannel0, vec2(iTime,0.0)).x) * 0.7;\n    const float ring_spread = 0.35;\n\tconst float circle_spread = 0.2;\n    \n    int intersections = 0;\n    float closest_dist = 999.9;\n    \n    const int num_rings = 4;\n    const int circles_per_ring = 16;\n    for (int j = 0; j < num_rings; j++) {\n        float theta = (float(j) / float(num_rings)) * PI * 2.0;\n        theta += iTime;\n        vec2 ring_center = uv + vec2(sin(theta), cos(theta)) * ring_spread;\n        \n        for (int i = 0; i < circles_per_ring; i++) {\n            float theta2 = (float(i) / float(circles_per_ring)) * PI * 2.0;\n\t        theta2 -= iTime * 0.2;\n            vec2 circle_pos = ring_center + vec2(sin(theta2), cos(theta2)) * circle_spread;\n            \n            float dist = length(circle_pos) - circle_radii;\n            closest_dist = min(abs(dist), closest_dist);\n            if (dist < 0.0) {\n\t\t\t\tintersections++;\n            }\n        }\n    }\n    \n    vec3 col = vec3(0.25);\n    if (intersections > 2) {\n\t    col = palette(float(intersections + 2));\n        col /= log(closest_dist * 120.0 + exp(0.8));\n    } else {\n        col /= log(closest_dist * 15.0 + exp(0.8));\n        col.z += (sin(closest_dist * 130.0) + 1.0)\n               * 0.07 / (closest_dist * 15.0 + 1.0);\n    }\n    col = clamp(col, 0.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[47, 47, 70, 70, 254]], "test": "untested"}
{"id": "tlSyDz", "name": "Mellifera I  - golfed ( 465 ch )", "author": "FabriceNeyret2", "description": "golfing 1361 char sl2c's  [url]https://shadertoy.com/view/3tBczh[/url]", "tags": ["circles", "hyperbolic", "golf", "4tweets", "horosphere"], "likes": 12, "viewed": 417, "published": 3, "date": "1594107491", "time_retrieved": "2024-07-30T20:56:54.768962", "image_code": "// golfing 1361 chars  sl2c's https://shadertoy.com/view/3tBczh\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 o = iResolution.xy, e;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - o, 0, 1) / o.y / .1;\n         z.z++; o-=o;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8 * log(r)\n    \n    float Z, r; // sqrt(sqrt(3) - sqrt(2))\n    for ( int J,j,i=0; i<84; i++ )\n        J = int[] (3,0,1,2,0,1,2,0,2,1,0,2,1,3) [ j = i%14 ],\n        r = .564, e = 1.414 * sin( 1.047 * vec2(j%6-1) + vec2(1.57,0) ),\n        z -= k = vec4(  j<1  ?            o\n                      : j>12 ? r = -1./r, o\n                      : j>6  ? r =  1./r,-e.yx\n                      :                   e   \n                      , o ) *r,\n        Z = dot(z,z) / r ,\n        Z < r ? Z = r*r/Z, z *= Z/r , r : f[J] *= -1.,\n        t[J] = min( t[J], .5* ( Z - r ) / z.w ),\n        z += k;\n    t*= f;                    // Col0        Col1   Col2\n // O = sqrt( .5 + t.w * mat4( .25,o,    o,  .3,o, -.13*z/z ,o,o) * t );\n    O = sqrt( .5 + t.w * mat4( .25,o,o.x,o.y,.3,o, -.13*z/z ,o,o) * t );\n} /*\n\n\n\n\n\n\n// --- 466 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 o = iResolution.xy, e;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - o, 0, 1) / o.y / .1;\n         z.z++; o-=o;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8 * log(r)\n    \n    float Z, r; // sqrt(sqrt(3) - sqrt(2))\n    for ( int J,j,i=0; i<84; i++ )\n        J = int[] (3,0,1,2,0,1,2,0,2,1,0,2,1,3) [ j = i%14 ],\n        r = .564, e = 1.414 * sin( 1.047 * vec2(j%6-1) + vec2(1.57,0) ),\n        z -= k = vec4(  j<1  ?            o\n                      : j>12 ? r = -1./r, o\n                      : j>6  ? r =  1./r,-e.yx\n                      :                   e   \n                      , o ) *r,\n        Z = dot(z,z) / r / r,\n        r * Z < r ? z *= Z = 1./Z , r : f[J] *= -1.,\n        t[J] = min( t[J], .5* ( r*Z - r ) / z.w ),\n        z += k;\n    t*= f;                    // Col0 Col1   Col2\n    O = sqrt( .5 + t.w * mat4( .25,o,o,.3,o, -.13*z/z ,o,o) * t );\n} /*\n\n\n\n\n\n\n// --- 474 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 o = iResolution.xy, e;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - o, 0, 1) / o.y / .1;\n         z.z++; o-=o;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8 * log(r)\n    \n    float Z, b, r = .564; // sqrt(sqrt(3) - sqrt(2))\n    for ( int J,j,i=0; i<84; i++ )\n        J = int[] (3,0,1,2,0,1,2,0,2,1,0,2,1,3) [ j = i%14 ],\n        b = r, e = 1.414 * sin( 1.047 * vec2(j%6-1) + vec2(1.57,0) ),\n        z -= k = vec4(  j<1  ?            o\n                      : j>12 ? b = -1./r, o\n                      : j>6  ? b =  1./r,-e.yx/ r\n                      :                   e   * r\n                      , o ),\n        Z = b*b / dot(z,z),\n        b / Z < b ? z *= Z , r : f[J] *= -1.,\n        t[J] = min( t[J], .5* ( dot(z,z)/b - b ) / z.w ),\n        z += k;\n    t*= f;                    // Col0 Col1   Col2\n    O = sqrt( .5 + t.w * mat4( .25,o,o,.3,o, -.13*z/z ,o,o) * t );\n} /*\n\n\n\n\n\n\n// --- 488 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 R = iResolution.xy, e, c, o=R-R;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - R, 0, 1) / R.y / .1;\n         z.z++;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8. * log(r);\n    \n    float Z, b, r = .564; // sqrt(sqrt(3.) - sqrt(2.));\n    for ( int J,j,i=0; i<84; i++ )\n        j = i%14,  b = r,\n        e = 1.414 * cos( 1.047 * vec2(j%6-1) + vec2(0,-1.57) ),\n        c =  j<1  ?            o\n           : j>12 ? b = -1./r, o\n           : j>6  ? b =  1./r,-e.yx/ r\n           :                   e   * r,\n        z -= k = vec4(c,o),\n        Z = dot(z,z),\n        J = int[](3,0,1,2,0,1,2,0,2,1,0,2,1,3) [j],\n        Z*b < b*b*b ? z *= b*b / Z , r : f[J] *= -1.,\n        t[J] = min( t[J], .5* ( dot(z,z)/b - b ) / z.w ),\n        z += k;\n    t*= f;                    // Col0 Col1   Col2\n    O = sqrt( .5 + t.w * mat4( .25,o,o,.3,o, -.13*z/z ,o,o) * t );\n} /*\n\n\n\n\n\n\n// --- 497 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 R = iResolution.xy, e, c, o=R-R;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - R, 0, 1) / R.y / .1;\n         z.z++;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8. * log(r);\n    \n    float Z, b, r = .564; // sqrt(sqrt(3.) - sqrt(2.));\n\n    for ( int J,j,i=0; i<84; i++ )\n        j = i%14,\n        e = 1.414 * cos( 1.047 * float(j%6-1) + vec2(0,-1.57) ),\n        c =  j<1  ? b =  r,    o\n           : j>12 ? b = -1./r, o\n           : j<7  ? b =  r,    e   * r\n           :      ( b =  1./r,-e.yx/ r ),\n        z -= k = vec4(c,o),\n        Z = dot(z,z),\n        J = int[](3,0,1,2,0,1,2,0,2,1,0,2,1,3) [j],\n        Z*b < b*b*b ? z *= b*b / Z : ( f[J] *= -1., z ),\n        t[J] = min( t[J], .5* ( dot(z,z)/b - b ) / z.w ),\n        z += k;\n    t*= f;                    // Col0 Col1   Col2\n    O = sqrt( .5 + t.w * mat4( .25,o,o,.3,o, -.13*z/z ,o,o) * t );\n} /*\n\n\n\n\n\n\n// --- 533 chars\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 R = iResolution.xy, e;\n    vec4 f = vec4(1), t = f, k,\n         z = vec4( U+U - R, 0, 1) / R.y / .1;\n         z.z++;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); // -8. * log(r);\n    \n    float Z, b, r = .564; // sqrt(sqrt(3.) - sqrt(2.));\n\n    for ( int J,j,i=0; i<84; i++ ) {\n        j = i%14;\n        e = sqrt(2.) * cos(1.047 * float(j%6-1) + vec2(0,-1.57) );\n        vec3 c = j<1  ? vec3( 0, 0, r )\n                :j>12 ? vec3( 0, 0,-1 ) / r\n                :j<7  ? vec3(  e  , 1 ) * r\n                :       vec3( -e.yx,1 ) / r;\n        z -= k = vec4(c.xy,0,0);\n        b = c.z,  Z = dot(z,z);\n        J = int[](3,0,1,2,0,1,2,0,2,1,0,2,1,3) [j];\n        Z*b < b*b*b ? z *= b*b / Z : ( f[J] *= -1., z );\n        t[J] = min( t[J], .5* ( dot(z,z)/b - b ) / z.w );\n        z += k;\n    }\n\n    O = sqrt( .5 + t[3]*f[3]* mat3x4( .25,z-z,.3,0,0, -.13*z/z ) * (t*f).xyz );\n} /*\n\n\n\n\n\n\n// --- 620 chars\n\n// golfing 1361 chars  sl2c's https://shadertoy.com/view/3tBczh\n\nvoid mainImage( out vec4 O, vec2 U )\n{    \n    vec2 R = iResolution.xy, e;\n    vec4 z = vec4( U+U - R, 0, 1) / R.y / .1;\n         z.z++;\n    z *= exp( 2.29 - mod(iTime*.2, 4.58) ); //  -8. * log(r);\n    \n    float Z=0., r = .564; // sqrt(sqrt(3.) - sqrt(2.));\n    vec3[14] c; \n    c[0] =       vec3( 0, 0, r );\n     for (int i=0; i<6; i++)\n        e = sqrt(2.) * cos(1.047 * Z++ + vec2(0,-1.57) ),\n        c[i+1] = vec3( e   , 1 ) * r,\n        c[i+7] = vec3(-e.yx, 1 ) / r;\n    c[13] =      vec3( 0, 0,-1 ) / r;         \n\t\n    vec4 f = vec4(1), t = f, k;\n    for ( int J,j=0; j<84; j++ )\n            z -= k = vec4(c[j%14].xy,0,0),\n            r = c[ j%14 ].z,  Z = dot(z,z),\n            J = int[](3,0,1,2,0,1,2,0,2,1,0,2,1,3) [ j%14 ],\n            Z*r < r*r*r ? z *= r*r / Z : ( f[J] *= -1., z ),\n            t[J] = min( t[J], .5* ( dot(z,z)/r - r ) / z.w ),\n            z += k;\n    O-=O;\n    for ( int i=0; i<3; i++ )\n        O +=   mat3x4( .25,0,0,0,  0,.3,0,0, vec4(-.13) ) [i] \n             * t[i]*f[i];\n\n    O = pow( .5 + t[3]*f[3]* O, vec4(1./2.2) );\n}\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtBcWz", "name": "Julia Set Trillion-Fold Zoom", "author": "dr2", "description": "Deep zoom into three different Julia sets using double-precision emulation - see source for activation.", "tags": ["fractal", "precision", "double"], "likes": 5, "viewed": 316, "published": 3, "date": "1594106838", "time_retrieved": "2024-07-30T20:56:55.765298", "image_code": "// \"Julia Set Trillion-Fold Zoom\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Deep zoom into three different Julia sets using double-precision emulation -\n see below for activation.\n \n Background discussion appears in \"Mandelbrot Trillion-Fold Zoom\".\n\n Based on original mandelbrot version which was unsuccessful on Windows and had to be\n modified using additional \"fake\" variables to prevent optimizer from ignoring parentheses.\n All this should be unnecessary!\n\n Scale factor is shown (log of value).\n\n Please report success/failure and specify platform; works on linux/nvidia(binary) and\n linux/intel(mesa), but no access to other platforms where the problems may be more serious.\n If ok, I can use this technique in the earlier mandelbrot shader.\n*/\n\n#define DP_VERS  0   // NOTE: must change 0->1 for this to work (not by default) !!!\n\n#define AA       0   // set = 1 for antialiasing (recommended)\n\n#if 0\n#define VAR_ZERO min (nFrame, 0)\n#else\n#define VAR_ZERO 0\n#endif\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nint nFrame;\nfloat nFrameF, scale, sclTarg, frmCyc;\nconst float pi = 3.1415927;\n\n#if DP_VERS\n\n#define REAL_BAD_FP 1   // set = 0 if the GLSL compiler behaves (else just get sp results), = 0 for linux\n#define LESS_BAD_FP 0   // set = 1 for linux: linux/nvidia(binary) and linux/intel(mesa), else = 0\n\n#define BAD_FP (REAL_BAD_FP || LESS_BAD_FP)\n\n#if LESS_BAD_FP\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : 0.);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : 0.);\n}\n\n#define FFSub2 FFSub\n\n#endif\n\n#if REAL_BAD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)  // following iq's suggestion\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (b, a + b, (a != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (- b, a - b, (a != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if ! BAD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if ! BAD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = - FFSub (FFSub2 (ma, va.x), ma);\n  sb1 = - FFSub (FFSub2 (mb, vb.x), mb);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nstruct JPar {\n#if DP_VERS\n  vec2 xJulv, yJulv, xMidv, yMidv;\n#else\n  float xJul, yJul, xMid, yMid;\n#endif\n};\n\nvec3 ShowScene (vec2 uv)\n{\n  JPar jPar, jPar1, jPar2, jPar3;\n  vec3 col;\n  float ns, jsTyp;\n#if DP_VERS\n  vec2 x, y, xx, yy, cx, cy, s;\n  float mm;\n#else\n  float x, y, xx, yy, cx, cy, s;\n#endif\n#if DP_VERS\n  mm = 4096. * 4096.;\n#endif\n  jPar1 = JPar (\n#if DP_VERS // (externally) converted values\n     vec2 (-2.9841080000e+06 / mm, 3.0644734555e-08), vec2 (-1.1053949000e+07 / mm, 3.6843623819e-08),\n     vec2 ( 1.1825392000e+07 / mm, 2.7743463415e-08), vec2 ( 1.0691197000e+07 / mm, 9.5534800071e-09)\n#else // original values (extra precision for conversion)\n     -1.7786666667e-01, -6.5886666667e-01, 7.0484831723e-01, 6.3724500896e-01\n#endif\n  );\n  jPar2 = JPar (\n#if DP_VERS\n     vec2 (-2.8856820000e+06 / mm, 5.0544738783e-08), vec2 (-1.0955523000e+07 / mm, 5.6743621801e-08),\n     vec2 ( 1.0162006000e+07 / mm, 3.3276162492e-08), vec2 ( 5.0303820000e+06 / mm, 3.6449204266e-08)\n#else\n     -1.7200000000e-01, -6.5300000000e-01, 6.0570279111e-01, 2.9983416864e-01\n#endif\n  );\n  jPar3 = JPar (\n#if DP_VERS\n     vec2 ( 2.7101420000e+06 / mm, 2.2351880596e-08), vec2 ( 9.9288270000e+06 / mm, 2.4957934830e-08),\n     vec2 (-3.0709070000e+06 / mm, 4.0579411109e-08), vec2 ( 6.7450760000e+06 / mm, 4.2139466805e-08)\n#else\n     1.6153707355e-01, 5.9180423133e-01, -1.8304028029e-01, 4.0203790110e-01\n#endif\n  );\n#if DP_VERS\n  const float nsMax = 4096.;\n#else\n  const float nsMax = 2048.;\n#endif\n  jsTyp = floor (mod (float (nFrame) / frmCyc, 3.));\n  if (jsTyp == 0.) jPar = jPar1;\n  else if (jsTyp == 1.) jPar = jPar2;\n  else jPar = jPar3;\n#if DP_VERS\n  x = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), jPar.xMidv);\n  y = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), jPar.yMidv);\n  cx = jPar.xJulv;\n  cy = jPar.yJulv;\n#else\n  x = uv.x * scale + jPar.xMid;\n  y = uv.y * scale + jPar.yMid;\n  cx = jPar.xJul;\n  cy = jPar.yJul;\n#endif\n  ns = 0.;\n  col = vec3 (0.);\n  for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n    ++ ns;\n#if DP_VERS\n    xx = DvMul (x, x);\n    yy = DvMul (y, y);\n    y = DvMul (x, y);\n    y = DvAdd (DvAdd (y, y), cy);\n    x = DvAdd (DvSub (xx, yy), cx);\n    s = DvAdd (xx, yy);\n    if (s.x + s.y > 256. * 256.) break;\n#else\n    xx = x * x;\n    yy = y * y;\n    y = 2. * x * y + cy;\n    x = xx - yy + cx;\n    s = xx + yy;\n    if (s > 256. * 256.) break;\n#endif\n  }\n  if (ns < nsMax - 1.) {\n#if DP_VERS\n    ns -= log2 (log2 (s.x + s.y)) - 4.;\n#else\n    ns -= log2 (log2 (s)) - 4.;\n#endif\n    col = HsvToRgb (vec3 (mod (0.5 + ns / 512., 1.), 1., 1.));\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n#if DP_VERS\n#if REAL_BAD_FP \n  nFrameF1 = float (nFrame + 1);\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n#endif\n  frmCyc = 4000.;\n#if DP_VERS\n  sclTarg = 1e-12;\n#else\n  sclTarg = 3e-6;\n#endif\n  scale = 4. * pow (sclTarg, SmoothBump (0.25, 0.75, 0.23, mod (nFrameF / frmCyc, 1.)));\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.4 * asp, -0.4),\n     vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcWz.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [], "test": "untested"}
{"id": "ttScz1", "name": "terrain-mesh", "author": "xiaosong0911", "description": "naive fbm terrrian", "tags": ["terrian"], "likes": 2, "viewed": 343, "published": 3, "date": "1594092217", "time_retrieved": "2024-07-30T20:56:56.637965", "image_code": "float board(vec3 uv, float dx) {\n    uv = (0.5 - abs(fract(uv/dx)-0.5)) * dx;\n    return min(min(uv.x,uv.y),uv.z);\n}\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat fbm(vec2 p) {\n    float r = 0.;\n    p = (p + 0.5) / 512.;\n    float s = 15.;\n    for (int i = 0; i < 6; i++) {\n        s /= 2.; p *= 2.;\n    \tr += texture(iChannel0, p).r * s;\n    }\n    return r - 0.5;\n}\n\nfloat sdf(vec3 r) {\n    return r.y - fbm(r.xz) * smoothstep(0.,10.,length(r.xz));\n}\n\nvec3 trace(vec3 o, vec3 d) {\n    vec3 p = o;\n    float s;\n    for(int i = 0; i < 50; i++) {\n        s = sdf(p);\n        p += d * s * 0.5;\n    }\n    if (s > 1e1) return o;\n    else return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    float theta = (iMouse.x * 2. - iResolution.x) * 3. / iResolution.x;\n    float phi = (iMouse.y * 2. - iResolution.y) / iResolution.y / 3.;\n    mat3 rot = mat3(\n            cos(theta), 0, sin(theta),\n            0, 1, 0,\n            -sin(theta), 0, cos(theta)\n            ) * mat3(\n                1, 0, 0,\n                0, cos(phi), sin(phi),\n                0, -sin(phi), cos(phi)\n                );\n    vec3 ori = vec3(0,3.,0);\n    vec3 dir = rot * normalize(vec3(uv, -2));\n    vec3 hit = trace(ori, dir);\n    float depth = length(hit - ori);\n    if (depth == 0.) fragColor = vec4(0.);\n    else {\n        fragColor.xyz = vec3(smoothstep(0.,0.1,board(hit * 10., 1.)));\n        fragColor.a = 1.;\n    }\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttScz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 116], [118, 118, 140, 140, 257], [259, 259, 278, 278, 468], [470, 470, 489, 489, 553], [555, 555, 583, 583, 746], [748, 748, 805, 805, 1579]], "test": "untested"}
{"id": "tlByDR", "name": "Fractal vines", "author": "jarble", "description": "These strange hollow structures were created using a modified version of a [url=https://www.shadertoy.com/view/wtSyDR]\"vine forest.\"[/url]", "tags": ["3d", "raymarching", "fractal", "vines"], "likes": 2, "viewed": 291, "published": 3, "date": "1594091275", "time_retrieved": "2024-07-30T20:56:57.579447", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    //p += p.yzx;\n    p = cos(p/size1);\n    p = (cos(p/vec3(length((p/30.0)))))*size1;\n    return size-length(p);\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    for(float i = 9.0; i < 729.0; i *= 9.0){\n    \t//float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*scale*40.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(iMouse.y/iResolution.y*3.14-3.14*0.5);\n            viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n        }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 621, 639, 737], [739, 739, 763, 763, 1106], [1108, 1108, 1136, 1136, 1284], [1287, 1708, 1799, 1799, 2105], [2120, 2374, 2439, 2439, 2571], [2573, 2662, 2691, 2691, 3001], [3003, 3495, 3635, 3635, 4245], [4247, 4617, 4702, 4702, 5049], [5051, 5378, 5427, 5462, 5593], [5595, 5595, 5652, 5652, 6748]], "test": "untested"}
{"id": "wtSyDR", "name": "Vine forest variations", "author": "jarble", "description": "This is a more realistic version of my [url=https://www.shadertoy.com/view/3lBcWz]recursive vine forest[/url], with many twists and curves.", "tags": ["3d", "raymarching", "recursion", "jungle"], "likes": 3, "viewed": 368, "published": 3, "date": "1594081181", "time_retrieved": "2024-07-30T20:56:58.330439", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n \nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = cos(p/size1);\n    p = (cos(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.83;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    for(float i = 9.0; i < 729.0; i *= 9.0){\n    \t//float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines((p-result*i/81.0)*i,size1)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*600.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 236], [239, 660, 751, 751, 1075], [1089, 1178, 1207, 1207, 1517], [1519, 2011, 2151, 2151, 2761], [2763, 3133, 3218, 3218, 3565], [3568, 3568, 3595, 3595, 3744], [3746, 3746, 3803, 3803, 4498]], "test": "untested"}
{"id": "ttBcWR", "name": "My Very First Working Fractal", "author": "Zi7ar21", "description": "EPIC OH MY GOSH I DID IT\nand a fractal yeet", "tags": ["3d", "ray", "raymarch", "mandelbulb", "sphere", "marcher", "epic", "yeet"], "likes": 12, "viewed": 567, "published": 3, "date": "1594080138", "time_retrieved": "2024-07-30T20:56:59.088413", "image_code": "// Zi7ar21's Mandelbulb Ray Marcher -- July 6th, 2020\n// I Deem You Allowed to Use My Code even Commercially and Even Modify it as Long as:\n// You keep this disclaimer.\n// You keep the links to source I used (I don't want to get in trouble)\n// You keep the link to this on ShaderToy\n// You do not modify the terms\n\n// You do not have to keep my credits, however I urge you to leave them here in the source.\n// If you are absolutely not able to follow these terms, that is OK and I allow you I guess.\n\n// If this Code is Being Reused Entirely,\n// Then the Original and Possibly Updated Version Can be Found Here:\n// https://www.shadertoy.com/view/ttBcWR\n// Fork of \"My Very First Working Raymarcher\" by Zi7ar21. [2020-07-06 23:50:09]\n// https://shadertoy.com/view/WlBcDz\n\n// Learn the Basics of Raymarching Like I Did Here:\n// https://youtu.be/PGtv-dBi2wE\n\n// Change these Parameters to Your Liking!\n#define MAX_MARCHES 32\n#define MAX_DISTANCE 8.0\n#define COLLISION_DISTANCE 0.01\n#define bailout 4.0\n#define iterations 6\n\n// Constants\n#define pi 3.14159265\n\n// Mandelbulb Distance Estimator\n// Adapted from:\n// http://blog.hvidtfeldts.net/index.php/2011/09/distance-estimated-3d-fractals-v-the-mandelbulb-different-de-approximations/\nfloat mandelbulb(vec3 pos){\n\tfloat power = float(8.0);\n\tvec3 z = pos;\n\tfloat dr = 1.0;\n\tfloat r = 0.0;\n\tfor (int i = 0; i < iterations; i++){\n\t\tr = length(z);\n\t\tif (r>bailout) break;\n\t\t// Convert to Polar Coordinates\n\t\tfloat theta = acos(z.z/r);\n\t\tfloat phi = atan(z.y,z.x);\n\t\tdr =  pow(r, power-1.0)*power*dr+1.0;\n\t\t// Scale and Rotate the Point\n\t\tfloat zr = pow(r, power);\n\t\ttheta = theta*power;\n\t\tphi = phi*power;\n\t\t// Convert Back to Cartesian Coordinates\n\t\tz = zr*vec3(sin(theta)*cos(phi), sin(phi)*sin(theta), cos(theta));\n\t\tz+=pos;\n\t}\n\treturn 0.5*log(r)*r/dr;\n}\n\n// Compute/March the Ray\nfloat raymarch(vec3 camerapos, vec3 raydir){\n\tfloat distorigin;\n    float distsurface;\n    vec3 raypos = camerapos;\n    for(int i=0; i<MAX_MARCHES; i++){\n        distsurface = mandelbulb(raypos);\n    \traypos += raydir*distsurface;\n        distorigin = distance(camerapos, raypos);\n        if(distsurface<COLLISION_DISTANCE){break;}\n    }\n    return distorigin;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos){\n\tfloat dis = mandelbulb(raypos);\n    vec2 e = vec2(0.01, 0.0);\n    vec3 normal = dis-vec3(mandelbulb(raypos-e.xyy),\n                           mandelbulb(raypos-e.yxy),\n                           mandelbulb(raypos-e.yyx));\n    return normalize(normal);\n}\n\n// Shade Scene\nvec3 shade(vec3 march){\n\t// Light Positions\n    vec3 lightpositiona = vec3(0.0, 8.0, 0.0);\n\tvec3 lightpositionb = vec3(0.0, 0.0, 0.0);\n    vec3 lightpositionc = vec3(0.0,-8.0, 0.0);\n\t// Animate Lights\n    lightpositiona.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n    lightpositionb.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n    lightpositionc.xz += vec2(sin(iTime*pi), cos(iTime*pi))*4.0;\n\t// Compute Lighting\n    vec3 lightinga = normalize(lightpositiona-march);\n    vec3 lightingb = normalize(lightpositionb-march);\n    vec3 lightingc = normalize(lightpositionc-march);\n\t// Compute Surface Normal\n    vec3 surfacenormal = normal(march);\n\t// Compute Diffuse\n    float diffuseshader = clamp(dot(surfacenormal, lightinga), 0.0, 1.0);\n    float diffuseshadeg = clamp(dot(surfacenormal, lightingb), 0.0, 1.0);\n    float diffuseshadeb = clamp(dot(surfacenormal, lightingc), 0.0, 1.0);\n\t// Compute Geometry\n    float distancesurfa = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightinga);\n    float distancesurfb = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingb);\n    float distancesurfc = raymarch(march+surfacenormal*COLLISION_DISTANCE, lightingc);\n\t// Shade Geometry\n    if(distancesurfa<length(lightpositiona-march)) diffuseshader *= 1.0;\n    if(distancesurfa<length(lightpositionb-march)) diffuseshadeg *= 1.0;\n    if(distancesurfb<length(lightpositionc-march)) diffuseshadeb *= 1.0;\n    // Return Shading\n    return vec3(diffuseshader, diffuseshadeg, diffuseshadeb);\n}\n\n// Render the Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 1.0;\n\tvec3 camerapos = vec3(sin(iTime*pi), 0.0, -4.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir+uv.y*ydir)+zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n\t// Compute and Shade\n\tfloat mandelbulbdistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos+raydir*mandelbulbdistance;\n    vec3 diffuse = shade(march);\n\n    // Output to Screen\n    fragColor = vec4(pow(diffuse, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBcWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1057, 1233, 1260, 1260, 1801], [1803, 1828, 1872, 1872, 2190], [2192, 2206, 2231, 2231, 2486], [2488, 2503, 2526, 2546, 3996], [3998, 4018, 4072, 4096, 4719]], "test": "untested"}
{"id": "WlBcDz", "name": "My Very First Working Raymarcher", "author": "Zi7ar21", "description": "EPIC OH MY GOSH I DID IT", "tags": ["3d", "ray", "raymarch", "sphere", "raymarcher", "first"], "likes": 1, "viewed": 299, "published": 3, "date": "1594074818", "time_retrieved": "2024-07-30T20:56:59.846386", "image_code": "#define MAX_MARCHES 256\n#define MAX_DISTANCE 8.0\n#define COLLISION_DISTANCE 0.01\n\n// Distance Estimator\nfloat sphere(vec3 point) {\n\tvec4 spheredef = vec4(0, 0, 2.5, 2);\n    \n    float sphereDist =  length(point-spheredef.xyz)-spheredef.w;\n    return sphereDist;\n}\n\n// March a Ray\nfloat raymarch(vec3 camerapos, vec3 raydir) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_MARCHES; i++) {\n    \tvec3 raypos = camerapos + raydir*dO;\n        float dS = sphere(raypos);\n        dO += dS;\n        if(dO>MAX_DISTANCE || dS<COLLISION_DISTANCE) break;\n    }\n    \n    return dO;\n}\n\n// Get Normal\nvec3 normal(vec3 raypos) {\n\tfloat dis = sphere(raypos);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 normal = dis - vec3(\n        sphere(raypos-e.xyy),\n        sphere(raypos-e.yxy),\n        sphere(raypos-e.yyx));\n    \n    return normalize(normal);\n}\n\n// Shade with Lights\nfloat shade(vec3 march) {\n    vec3 lightposition = vec3(0, 4, 0);\n    lightposition.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 lighting = normalize(lightposition-march);\n    vec3 surfacenormal = normal(march);\n    \n    float diffuseshade = clamp(dot(surfacenormal, lighting), 0., 1.);\n    float distancesurf = raymarch(march+surfacenormal*COLLISION_DISTANCE*2., lighting);\n    if(distancesurf<length(lightposition-march)) diffuseshade *= .1;\n    \n    return diffuseshade;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\t// Camera Orientation\n\tvec3 xdir = vec3(1,0,0);\n\tvec3 ydir = vec3(0,1,0);\n\tvec3 zdir = vec3(0,0,1);\n\tfloat FOV = 45.0;\n\tvec3 camerapos = vec3(0.0, 0.0, 0.0);\n\n    // Undistorted Normalized Pixel Coordinates (From 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\tvec3 raydir = normalize(FOV*(uv.x*xdir + uv.y*ydir) + zdir);\n\tfloat collide = raymarch(camerapos, raydir);\n\n    // Pixel Color\n    vec3 col = vec3(collide / 4.0);\n\n\t// Shaded Pixel Color\n\tfloat spheredistance = raymarch(camerapos, raydir);\n    vec3 march = camerapos + raydir * spheredistance;\n    float diffuse = shade(march);\n    col = vec3(diffuse);\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[82, 104, 130, 130, 263], [265, 280, 325, 325, 566], [568, 582, 608, 608, 827], [829, 850, 875, 875, 1328], [1330, 1330, 1387, 1411, 2084]], "test": "untested"}
{"id": "WtScDz", "name": "Pixelated rainbow clouds + Blue!", "author": "Yambam", "description": "My 2nd fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK", "tags": ["hash"], "likes": 2, "viewed": 303, "published": 3, "date": "1594073937", "time_retrieved": "2024-07-30T20:57:00.802829", "image_code": "// Fork of \"Pixelated rainbow clouds + Pink!\" by Yambam. https://shadertoy.com/view/Wtjczw\n// 2020-07-06 22:16:34\n\n// Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK\n// 2020-07-05 23:08:47\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord*.3/pow(1.2,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.,mag),0)*3.*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color1 = vec3(0,0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    fragColor = vec4(color1/maximum,0.0);\n    fragColor.r = mix(fragColor.r, 1., max(0., 3.3 - 3.*fragColor.b - 4.*fragColor.g));\n    fragColor.b += .2*fragColor.r;\n    fragColor.g -= .1*fragColor.b;\n    fragColor.r *= .6;\n    fragColor.g *= .5;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScDz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[222, 284, 305, 305, 441], [444, 444, 483, 483, 535], [537, 537, 580, 580, 643], [645, 645, 702, 702, 1103]], "test": "untested"}
{"id": "3lBcWz", "name": "Recursive vine forest", "author": "jarble", "description": "This is a more complicated version of my [url=https://www.shadertoy.com/view/3lByDR]vine forest[/url], with vines at several different scales.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "recursion"], "likes": 3, "viewed": 328, "published": 3, "date": "1594068542", "time_retrieved": "2024-07-30T20:57:02.046503", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    \n\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define image_scale 8.0\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat vines(vec3 p,float size1){\n    p += p.yzx;\n    p = sin(p/size1);\n    p = (cos(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.83;\n}\n\nfloat sceneSDF1(vec3 p) {\n    p /= scale*60.0;\n\n    float size1 = 1100.0;\n\n\n    float result = vines(p,size1);\n    for(float i = 9.0; i < 729.0; i *= 9.0){\n    \t//float i = 10.0;\n        //p /= 1.1;\n        result = min(result,vines(p*i,size1)/(i*i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result;\n}\n\nfloat sceneSDF(vec3 p){\n    float result = sceneSDF1(p);\n    float multiplier = 9.0;\n    for(float i = multiplier; i < multiplier*multiplier; i*= multiplier){\n        //add bumps to the surface\n    \tresult -= sceneSDF1(p*i)/(i*6.0);\n    }\n    return result*scale*200.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*10.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth)*2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-35.0,1.0,iTime);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lBcWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 236], [239, 660, 751, 751, 1069], [1084, 1338, 1403, 1403, 1535], [1537, 1626, 1655, 1655, 1965], [1967, 2459, 2599, 2599, 3209], [3211, 3581, 3666, 3666, 4013], [4015, 4342, 4391, 4426, 4557], [4559, 4559, 4586, 4586, 4735], [4737, 4737, 4794, 4794, 5466]], "test": "untested"}
{"id": "WtScWz", "name": "Ero Cells", "author": "yacodes", "description": "Voronoi inspired cells", "tags": ["cellsvoronoi"], "likes": 1, "viewed": 261, "published": 3, "date": "1594066529", "time_retrieved": "2024-07-30T20:57:03.324088", "image_code": "const int POINTS_COUNT = 32;\n\nfloat random (float i) {\n  return fract(sin(i)* 43758.5453123);\n}\n\nfloat noise(float x) {\n  float i = floor(x);\n  float f = fract(x);\n  return mix(random(i), random(i + 1.0), smoothstep(0.,1.,f));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 st = fragCoord.xy / iResolution.xy;\n  st.x *= iResolution.x / iResolution.y;\n  st.x -= 0.35;\n  vec3 color = vec3(.0);\n  vec2 point[POINTS_COUNT];\n  for (int i = 0; i < POINTS_COUNT; i++) {\n    point[i] = vec2(noise(float(i) + sin(iTime)), noise(float(i) + 1. + iTime));\n  }\n\n  float m_dist = 1.;\n  for (int i = 0; i < POINTS_COUNT; i++) {\n    float dist = distance(st, point[i] + sin(iTime * (noise(float(i)) + 2.5)) / 4.);\n    m_dist = min(m_dist, dist);\n  }\n\n  color += vec3(\n\t\tsmoothstep(0.1, 0.3, m_dist),\n\t\tsmoothstep(-0.1, -0.3, (1. - m_dist)),\n\t\tm_dist\n  );\n\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScWz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 95], [97, 97, 119, 119, 228], [230, 230, 285, 285, 892]], "test": "untested"}
{"id": "3lByDR", "name": "Vine forest", "author": "jarble", "description": "This endless forest is based on one of my [url=https://www.shadertoy.com/view/WlByRh]\"jungle\" fractals[/url].", "tags": ["3d", "raymarching", "forest"], "likes": 2, "viewed": 340, "published": 3, "date": "1594060552", "time_retrieved": "2024-07-30T20:57:04.141901", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = vec3(-10.0,0,iTime*10.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*100.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(vines(p,10.0),vines(p,20.0),vines(p,30.0)))/10.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n    vec3 eye = vec3(-10.0,0,iTime*10.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = -viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat vines(vec3 p,float size1){\n    float i = size1;\n    p = ((cos(p/size1)/i))*i;\n    p = (cos(p/vec3(length((p/20.0)))))*size1;\n    return size-length(p)/1.6;\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*5.0;\n\n    float size1 = 1000.0;\n    p += (sin(p.yzx/size1))*(size1);\n\n    float result = vines(p,size1);\n    //for(float i = 10.0; i < 100.0; i *= 10.0){\n    \tfloat i = 10.0;\n        result += vines(p*i,size1)/(i*i);\n    //}\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 237], [240, 661, 752, 752, 1118], [1133, 1387, 1452, 1452, 1584], [1586, 1675, 1704, 1704, 2014], [2016, 2508, 2648, 2648, 3258], [3260, 3630, 3715, 3715, 4062], [4064, 4391, 4440, 4475, 4606], [4608, 4608, 4635, 4635, 4784], [4786, 4786, 4843, 4843, 5406]], "test": "untested"}
{"id": "WtByDR", "name": "Chords Experiment", "author": "MysteryPancake", "description": "Small sound experiment, might try to add more to it later", "tags": ["sound", "music", "audio", "synthesis", "synth", "saw", "song", "sawtooth", "gpusound", "chords"], "likes": 11, "viewed": 458, "published": 3, "date": "1594060018", "time_retrieved": "2024-07-30T20:57:04.883917", "image_code": "// From https://www.shadertoy.com/view/ltfSRr\nfloat message(vec2 uv) {\n\tuv -= vec2(1.0, 10.0);\n\tif ((uv.x < 0.0) || (uv.x >= 32.0) || (uv.y < 0.0) || (uv.y >= 3.0)) return -1.0;\n\tint i = 1, bit = int(exp2(floor(32.0 - uv.x)));\n\tif (int(uv.y) == 2) i = 928473456 / bit;\n\tif (int(uv.y) == 1) i = 626348112 / bit;\n\tif (int(uv.y) == 0) i = 1735745872 / bit;\n\treturn float(i - 2 * (i / 2));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tif (iResolution.y < 2000.0) {\n\t\tfloat c = message(fragCoord / 8.0);\n\t\tif (c >= 0.0){\n\t\t\tfragColor = vec4(c);\n\t\t\treturn;\n\t\t}\n\t}\n\tvec2 uv = fragCoord / iResolution.xy;\n\tfragColor = vec4(uv, 0.5 + 0.5 * mod(iTime, 0.25), 1.0);\n}", "image_inputs": [], "sound_code": "const float PI = 3.1415926;\n\n// MIDI note to frequency formula\nfloat noteFreq(float note) {\n\treturn 440.0 * exp2(floor(note - 69.0) / 12.0);\n}\n\n// From https://www.shadertoy.com/view/llByWR\nfloat sawtooth(float time, float x) {\n    // Smooth harsh attack\n    float smoothAttack = min(1.0, time * 50.0);\n\treturn (1.0 - 2.0 * acos((1.0 - time) * -cos(x / 2.0)) / PI) * (2.0 * atan(sin(x / 2.0) / time) / PI) * smoothAttack;\n}\n\nfloat arpeggiate(float time, float baseNote, float range, float notesPerSecond, float repeat) {\n\treturn mod(floor(time / notesPerSecond), repeat) * range + baseNote;\n}\n\nvec2 mainSound(in int samp, float time) {\n\t\n\tconst float phaseOffset = 0.01;\n\n\tfloat bass = arpeggiate(time, 69.0, 3.0, 2.0, 2.0);\n\tfloat low = arpeggiate(time, 81.0, 3.0, 2.0, 2.0);\n\tfloat mid = arpeggiate(time, 85.0, 2.0, 1.0, 4.0);\n\tfloat high = arpeggiate(time, 93.0, 3.0, 2.0, 2.0);\n\tfloat higher = arpeggiate(time, 97.0, 2.0, 1.0, 4.0);\n\tif (mod(floor(time / 16.0), 2.0) != 0.0) {\n\t\tbass = arpeggiate(time, 69.0, 2.0, 2.0, 2.0);\n\t\tlow = arpeggiate(time, 81.0, 2.0, 2.0, 2.0);\n\t\tmid = arpeggiate(time, 81.0, 2.0, 2.0, 4.0);\n\t\thigh = arpeggiate(time, 93.0, 2.0, 2.0, 2.0);\n\t\thigher = arpeggiate(time, 105.0, 2.4, 0.25, 4.0);\n\t}\n\t\n\tfloat[] notes = float[] (bass, low, mid, high, higher);\n\tfloat[] amplitudes = float[] (1.2, 1.0, 1.2, 0.6, 0.3);\n\t\n    vec2 result = vec2(0.0);\n\t\n\tfor (int i = 0; i < notes.length(); i++) {\n\t\tfloat repeat = mod(time, 0.25) * (5.0 - cos(time) * 2.0);\n\t\tif (i == 0) {\n\t\t\trepeat = mod(time, 0.125) * (2.0 - cos(time));\n\t\t}\n\t\trepeat = min(repeat, 0.7 + cos(time * 0.25) * 0.3);\n        \n\t\tfloat offsetLeft = sin(float(i)) * phaseOffset;\n\t\tresult.x += sawtooth(repeat, (time + offsetLeft) * noteFreq(notes[i])) * amplitudes[i];\n        \n\t\tfloat offsetRight = cos(float(i)) * phaseOffset;\n\t\tresult.y += sawtooth(repeat, (time + offsetRight) * noteFreq(notes[i])) * amplitudes[i];\n\t}\n    \n\treturn result / float(notes.length());\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByDR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 46, 70, 70, 387], [389, 389, 444, 444, 671]], "test": "untested"}
{"id": "3lScWR", "name": "Trigonometric pasta", "author": "jarble", "description": "Using only a few trigonometric functions, you can make many different kinds of pasta.", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 252, "published": 3, "date": "1594052774", "time_retrieved": "2024-07-30T20:57:05.627928", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    p = sin(p/50000.0)*2500.0;\n    float i = 27.0;\n    p = p*i;\n    vec3 p1 = (p + sin(p.yzx/300.0)*(300.0))/3.0;\n    p = p1*(cos(p1/size));\n    result = (length(p) - size)/i;\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*1.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(.5+sin(p/3.0)/4.0)/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,70.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[523, 523, 547, 547, 858], [860, 860, 888, 888, 949], [952, 1373, 1464, 1464, 1770], [1785, 2039, 2104, 2104, 2236], [2238, 2327, 2356, 2356, 2666], [2668, 3160, 3300, 3300, 3910], [3912, 4282, 4367, 4367, 4782], [4784, 5111, 5160, 5195, 5326], [5328, 5328, 5385, 5385, 6292]], "test": "untested"}
{"id": "3tScWR", "name": "Simple Ball", "author": "MysteryPancake", "description": "Used in http://mysterypancake.github.io/Waveform", "tags": ["sphere", "ball", "bevel"], "likes": 4, "viewed": 339, "published": 3, "date": "1594052098", "time_retrieved": "2024-07-30T20:57:06.365955", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 circCoord = (fragCoord - iResolution.xy * 0.5) / iResolution.y;\n\tvec2 cxy = vec2(2.0, 2.0) * circCoord;\n\tfloat radius = dot(cxy, cxy);\n\tconst vec3 ambient = vec3(0.5, 0.2, 0.1);\n\tconst vec3 diffuse = vec3(1, 0.5, 0.2);\n\tvec3 direction = normalize(vec3(cos(iTime), sin(iTime), -0.5));\n\tvec3 normal = vec3(cxy, sqrt(1.0 - radius));\n\tfloat color = max(dot(normal, direction), 0.0);\n\tfloat delta = fwidth(radius);\n\tfloat alpha = 1.0 - smoothstep(1.0 - delta, 1.0 + delta, radius);\n\tconst vec4 bgColor = vec4(0, 0.1, 0.2, 1);\n\tvec4 circColor = vec4(ambient + diffuse * color, alpha);\n\tfragColor = mix(bgColor, circColor, circColor.a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tScWR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 696]], "test": "untested"}
{"id": "wt2czm", "name": "rotate box", "author": "FabriceNeyret2", "description": "rotation of a box around the center.\nMouse control rotation.\ngreen dot = box intersection with plane Z=0.", "tags": ["mm"], "likes": 6, "viewed": 405, "published": 3, "date": "1594046172", "time_retrieved": "2024-07-30T20:57:07.374260", "image_code": "// extracted from https://shadertoy.com/view/WtScRm\n\n\n#define rot(a) mat2(cos(a+vec4(0,-1.5708,1.5708,0)));\n#define rotBBox()                                           \\\n    X0.yz *= rot(a0); X1.yz *= rot(a0); X2.yz *= rot(a0);   \\\n    X0.xz *= rot(a1); X1.xz *= rot(a1); X2.xz *= rot(a1);   \\\n    X0.xy *= rot(a2); X1.xy *= rot(a2); X2.xy *= rot(a2);\n\n  #define proj(P) ( (P).xy )                      // flat projection\n//#define proj(P) ( 1.5* (P).xy / (2.+(P).z) )    // perspective projection\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec3 A,vec3 B, out vec3 Z0) {      // --- segment with disc ends: seamless distance to segment\n    float l = -A.z/(B-A).z;                           // hack: also show intersection with z=0.\n    Z0 = l>=0. && l<=1. ? mix(A,B,l) : vec3(0);\n    vec2 a = proj(A), b = proj(B);                    // 3D projection\n    p -= a, b -= a;                                   // --- classical 2D draw part\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    Z0.z = mix(A.z,B.z,h);                            // export current depth\n    return length(p - b * h);                         // dist to segment\n}\nvec3 z; float _d;\n#define line(u,a,b) ( _d = line(u,a,b,z), vec4(_d,z) )// hack to carry the z=0 plane information\n#define Min(v0,v1)  ( v0.x < v1.x ? v0 : v1 ) \n\n#define spot(P)  S( length( proj(P) - U ) -.01 )      // draw dot\n\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y;\n    \n    vec3   P = vec3(1.1, .3, -.2),                   // bounding box at P, axis X0,X1,X2\n          X0 = vec3(.3,0,0), X1 = vec3(0,.5,0) , X2 = vec3(0,0,.4);\n    vec2  M = iMouse.xy==vec2(0) ? vec2(.5,.3) : (2.*iMouse.xy/R-1.)*3.14;\n    float a0 = .2+iTime, a1 = M.y, a2 = M.x;        // Bbox rotation\n\n    vec3 C = P + (X0+X1+X2)/2.;                      // center of the box\n    rotBBox();                                       // Bbox rotation\n    P = C - (X0+X1+X2)/2.;                           // recomputed corner\n    \n    vec4 d; d.x = 1e5;\n    vec3 p = P;\n    d = Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ), // draw box\n              Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n            );\n    p += X2;\n    d = Min( d,\n             Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ),\n                   Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n          )      );\n    p = P;\n    d = Min( d,\n             Min ( Min ( line(U,p+X0,p+X0+X2),  line(U,p,p+X2) ),\n                   Min ( line(U,p+X1,p+X1+X2),  line(U,p+X0+X1,p+X0+X1+X2) ) \n          )      );\n    float z = .7-d.w;                           // thickness/grey from depth\n    O = vec4( S(d.x/(z*3.)) * z);                            // draw the line\n    if (length(d.yzw)!=0.) O.g +=  spot( vec3(d.yz,0.) );    // green spot at intersection with Z=0 plane\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2czm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[569, 569, 617, 682, 1210], [1442, 1442, 1480, 1480, 2884]], "test": "untested"}
{"id": "wtByzh", "name": "Heptagon-Pentagon Tiling", "author": "Shane", "description": "A transformed heptagon-pentagon tiling of the plane.", "tags": ["inversion", "tile", "transform", "pentagon", "heptagon"], "likes": 47, "viewed": 750, "published": 3, "date": "1594043161", "time_retrieved": "2024-07-30T20:57:08.430435", "image_code": "/*\n\n\tHeptagon-Pentagon Tiling\n\t------------------------\n\n\tYou can learn a lot from looking at stock images on the internet.\n\tThis particular aesthetic is my own, but it encompasses a few\n\tcommon geometric vector graphics cliches -- Colorful highlights, \n    vector borders and weird canvas coordinate manipulation. All are \n    very simple to produce.\n\n\tThis is a heptagon and pentagon tiling arrangement that you may\n\thave seen around. I have a nice neat example somewhere, but I \n\tcouldn't find it, so I've hacked in a function from an extruded\n\t3D tiling I made a while back that needs a bit of a tidy up. By\n\tthe way, I'll post that too at some stage.\n\n\tThe tiling method I've used is OK, but there are better ways to \n    produce a heptagon pentagon tiling, so I wouldn't pay too much\n\tattention to it. Having said that, it works, and will work in\t\n\tan extruded 3D setting as well.\n\n\tI've used a standard circle inversion based transformation to mix\n\tthings up a bit and give some extra perspective. It was tempting\n\tto apply some post processing, like hatching or something along\n\tthe lines of Flockaroo's pencil sketch algorithm, but I figured\n\tI should keep things simple.\n\n\n*/\n\n// Show the individual tile boundaries.\n//#define SHOW_GRID\n\n// Perform a coordinate transform. Commenting this out will show the regular pattern.\n#define TRANSFORM\n\n// Standard 2D rotation formula.\nmat2 rot2(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\n\n\n// IQ's vec2 to float hash.\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.619, 57.583)))*43758.5453); }\n\n\n// Very handy. I should write my own, but this works. I\n// rearranged it a bit, but it's the same function.\n//\n// Smooth Floor - Anastadunbar \n// https://www.shadertoy.com/view/lljSRV\nfloat floorSm(float x, float c) {\n    \n    float ix = floor(x); x -= ix;\n    return (pow(x, c) - pow(1.- x, c))/2. + ix;\n}\n\n\n// Signed distance to a regular heptagon -- Based on IQ's pentagon function.\nfloat sdHeptagon( in vec2 p, in float r){\n    \n    // PI/7: cos, sin, tan.\n    const vec3 k = vec3(.9009688679, .43388373911, .4815746188); \n    p.y = -p.y;\n    p.x = abs(p.x);\n    p -= 2.*min(dot(vec2(-k.x, k.y), p), 0.)*vec2(-k.x, k.y);\n    p -= 2.*min(dot(vec2(k.x, k.y), p), 0.)*vec2(k.x, k.y);\n    p -= 2.*min(dot(vec2(-k.x, k.y), p), 0.)*vec2(-k.x, k.y);\n\tp -= vec2(clamp(p.x, -r*k.z, r*k.z), r);    \n    return length(p)*sign(p.y);\n    \n}\n\n// Convex pentagon routine -- Adapted from IQ's triangle routine. \nfloat sdPent(in vec2 p, in vec2[5] v){\n    \n    vec2[5] e;\n    for(int i = 0; i<4; i++) e[i] = v[i + 1] - v[i];\n    e[4] = v[0] - v[4];\n   \n    float s = sign( e[0].x*e[4].y - e[0].y*e[4].x );\n    vec2 d = vec2(1e5);\n    \n    for(int i = 0; i<5; i++){\n        v[i] = p - v[i];\n        vec2 pi = v[i] - e[i]*clamp( dot(v[i], e[i])/dot(e[i], e[i]), 0., 1.);\n        d = min(d, vec2(dot(pi, pi), s*(v[i].x*e[i].y - v[i].y*e[i].x)));\n    }\n\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\n// Some constants that help determine the geometry. This is a messy function. I have a \n// cleaner one somewhere, so I'll drop that in at some stage. These are just heptagon\n// and pentagon heights, widths and apothems (center to mid edge point).\nconst float PI = 3.14159;\nconst float rad7 = .5;\nconst float apothem7 = (rad7*cos(PI/7.));\nconst float side7 = rad7*sin(PI/7.)*2.;\nconst float width7s = side7*cos(2.*PI/7.);\nconst float width7 = (side7*cos(PI/7.) + side7/2.);\nconst float yDiff = (2.*apothem7*sin(.5*PI/7.));\nconst float h = sqrt(apothem7*apothem7*4. - (width7 + width7s)*(width7 + width7s));\n\nconst vec2 s = vec2(width7*2. + width7s*2., (apothem7 + apothem7 + h));\nconst vec2 s2 = s*vec2(1, 2);\nconst float yh = s.y - apothem7 - rad7;\n\n// Extra variables hacked in at the last miniute. I needed the local coordinates and\n// needed to calculate the pentagon dots seperately... I'll tidy these up later.\nvec2 pL;\nfloat pDots;\n\n// The heptagon-pentagon distance field: By the way, I poached this from a 3D extruded \n// tiling example I did a while back, so you can actually render this in a more efficient \n// manner in 2D.\n//\n// Off the top of my head, the easier 2D way involves rendering two sets of repeat heptagons \n// on a tile of dimensions that involve the figures above, and the remaining space will be \n// that of the slightly irregular pentagon. There's some alternate tile flipping involved, \n// but that's about it. \n//\n// I might produce the simpler form at some stage and post it. As mentioned, the benefit\n// of the following procedure is that it'll work in an extruded setting. Plus, you have\n// access to vertex information, etc. For more advanced imagery, you need the vertex \n// information, and so forth.\n//\nvec4 distField(vec2 p){\n    \n    \n    // Shape distance field holder. There are six in all. Four heptagons and two pentagons.\n    float[6] pl;\n    // Centers of the six individual polygons that represent a single tile. Use the show\n    // grid borders option to see more clearly.\n    vec2[6] pCntr = vec2[6](vec2(0, 0), vec2(width7s + width7, yDiff), \n                            vec2(0, -apothem7*2.), vec2(width7s + width7, apothem7*2. + yDiff),\n                            vec2(0, yDiff/2.), vec2(0, yDiff/2.));\n    \n    // Shape IDs and local coordinates.\n    vec2[6] ip;\n    vec2[6] pLoc;\n    \n    // Using the information above to produce four heptagons.\n    vec2 oP = p - pCntr[0];\n    ip[0] = floor(p/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[0] = p;\n    pl[0] = sdHeptagon(p, apothem7);\n   \n    p = oP - pCntr[1];\n    ip[1] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[1] = p;\n    pl[1] = sdHeptagon((p)*vec2(1, -1), apothem7); \n    \n    p = oP - pCntr[2];\n    ip[2] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[2] = p;\n    pl[2] = sdHeptagon((p)*vec2(1, -1), apothem7); \n    \n    p = oP - pCntr[3];\n    ip[3] = floor((p)/s2);\n    p = mod(p, s2) - s2/2.;\n    pLoc[3] = p;\n    pl[3] = sdHeptagon(p, apothem7); \n\n\n    // Producing the two pentagons, plus some outer vertex dots.\n    p = oP - pCntr[4];\n    ip[4] = floor((p)/s);\n    \n    \n    if(mod(ip[4].y, 2.)<.5){\n       p.x -= s.x/2.;\n       ip[4] = floor((p)/s);\n    }\n\n    p = mod(p, s) - s/2.;\n    \n    ip[5] = ip[4];\n   \n    // Pentagon vertices.\n    vec2[5] v;\n    v[0] = vec2(-s.x/2. + side7/2., 0);\n    v[1] =  v[0] + rot2(-PI*2./7.)*vec2(side7, 0);\n    v[2] = vec2(0, yh);\n    v[3] = vec2(0, -yh);\n    v[4] =  v[0] + rot2(PI*2./7.)*vec2(side7, 0);\n    \n    // Pentagon one.\n    pl[4] = sdPent(p, vec2[5]( v[0], v[1], v[2], v[3], v[4]));\n    \n    pCntr[4] = (v[0] + v[1] + v[2] + v[3] + v[4])/5.;\n    \n    // The pentagon outer dots.\n    pDots = 1e5;\n    for(int i = 0; i<5; i++){\n      pDots = min(pDots, length(p - v[i]));\n    }\n    \n    pLoc[4] = p - pCntr[4];\n  \n    // Pentagon two. Same vertices, but with the local coordinates mirrored\n    // acress the X-axis.\n    pl[5] = sdPent(p*vec2(-1, 1), vec2[5]( v[0], v[1], v[2], v[3], v[4]));\n    pLoc[5] = p;\n    pCntr[5] = (v[0] + v[1] + v[2] + v[3] + v[4])*vec2(-1, 1)/5.;\n    pLoc[5] = p - pCntr[5];\n    \n    // Other pentagon outer dots.\n    for(int i = 0; i<5; i++){\n      pDots = min(pDots, length(p*vec2(-1, 1) - v[i]));\n    }    \n    \n    // Iterate through each of the six polygons, then return the minimum\n    // distance, local coordinates, ID, etc.\n    float minD = 1e5;\n    vec2 pID = vec2(0);\n    vec2 si = s2;\n    \n    int cID; \n    for(int i = 0; i<6; i++){\n        \n        if(i>3) si = s;\n        if(pl[i]<minD){\n            \n             minD = pl[i];\n             pID = ip[i]*si + pCntr[i];\n             cID = i;\n             pL = pLoc[i];\n           \n        }\n        \n    } \n    \n    // Retrun the minimum distance, shape center ID, and shape number.\n    return vec4(minD, pID, cID);\n}\n\n// The tile grid borders. Alternate rows are offset by\n// half a grid cell.\nfloat gridField(vec2 p){\n    \n    vec2 ip = floor(p/s);\n    if(mod(ip.y, 2.)<.5) p.x += s.x/2.;\n    ip = floor(p/s);\n    p = abs(mod(p, s) - s/2.);\n    return abs(max(p.x - .5*s.x, p.y - .5*s.y)) - .01;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\n    // Aspect correct screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.5)/iResolution.y;\n   \n   \n    // For all intents and purposes, this is just a fancy coordinate transformation.  For \n    // instance, \"uv = vec2(log(length(uv)), atan(uv.y, uv.x)/PI/2.*(width7 + width7s)*2.5)\" \n    // will polar transform things, and something like \"uv.y += sin(uv.x*a)*b\" will make\n    // things look wavy. This particular one is a cool circle inversion formula that people \n    // like MLA, S2C, Mattz, etc, use when they're putting together hyperbolic geometry and \n    // so forth. On a side note, I'll be putting a couple of those up pretty soon. \n    #ifdef TRANSFORM\n    // I can't remember who uses this particular style (MLA?), but many use it, and it's the \n    // one I prefer.\n    //vec2 m = vec2((2.*iMouse.xy - iResolution.xy)/iResolution.y);\n    vec2 m = vec2(cos(iTime/8.), -sin(iTime/4.))*.5;\n    float k = 1./dot(m, m);\n    vec2 c = k*m; // Circle inversion.\n    float tk = (k - 1.)/dot(uv - c, uv - c);\n    uv = tk*uv + (1. - tk)*c;\n    uv.x = -uv.x; // Maintain chirality.\n    uv = rot2(-iTime/8.)*uv;\n    #endif\n    \n    \n    // Scaling and translation.\n    float gSc = 4.;\n    vec2 p = uv*gSc - vec2(-1, -.5)*iTime/2.;\n    // Smoothing factor.\n     float sf = 1./iResolution.y*gSc;\n    \n    // The pentagon and heptagon tiling.\n    vec4 d = distField(p);\n    // The individual shape ID.\n    float cID = d.w;\n    \n     \n    // Set the background color to white.\n    vec3 col = vec3(1);\n    \n     \n    // Use the pixel angle within each individual shape to produce some angular\n    // colors, which gives the effect of light bouncing offs of cones.\n\n    // Using the shape ID to set the vertice number.\n    float n = cID<3.5? 7. : 5.;\n    // Rotate each shape, depending on its ID.\n    float oN = 0.;\n    if(cID == 1. || cID == 2.) oN = .5;\n    if(cID == 4.) oN = .25;\n    if(cID == 5.) oN = .75;\n    \n    // Rotate the shape's local coordinates.\n    vec2 q = pL;\n    q *= rot2(-oN/n*PI*2.);\n    \n    // Get the pixel angle.\n    float ang = mod(atan(q.x, q.y), 6.2831);\n    // Snapping the angle to one of five or seven palette colors. Note the smooth floor\n    // function to give smoother edges. I can thank Anastadunbar for that. :)\n    float iang = floorSm(ang*n/(PI*2.), .15)/n;\n    // The pentagons aren't nice symmetrical reqular pentagons, so the colored wedges\n    // aren't evenly spread out. This is just a quick hack to move a couple of lines.\n    if(cID == 5. && n==5. && abs(iang - 4./5.)<.1) iang = floorSm((ang - .2)*n/(PI*2.), .15)/n;\n    if(cID == 5. && n==5. && abs(iang - 4./5.)<.1) iang = floorSm((ang + .2)*n/(PI*2.), .15)/n;\n    if(cID == 4. && n==5. && abs(iang - 1./5.)<.1) iang = floorSm((ang - .2)*n/(PI*2.), .15)/n;\n    if(cID == 4. && n==5. && abs(iang - 1./5.)<.1) iang = floorSm((ang + .2)*n/(PI*2.), .15)/n;\n    \n     \n    \n    // Utilizing IQ's versatile palette formula to produce some angular colors. If\n    // I were only allowed to use one simple palette formula, this would be it.\n    vec3 lCol = .55 + .45*cos(iang*6.2831 + vec3(0, 1, 2));\n    // Flat shading override.\n    //lCol = vec3(1);\n    //float rnd = hash21(d.yz);\n    //lCol = .5 + .45*cos(rnd*6.28 + vec3(1, 2, 3));\n    \n    \n \n    // Producing some dots at the heptagonal vertices, then joining them with\n    // the pentagon dots. As an aside, the pentagon vertices where produced \n    // seperatly in the distance function, which is hacky, but it was the best\n    // way I could think of at the time.\n    float hDots = 1e5;\n    vec2 v0 = rot2(-oN/n*PI*2.)*vec2(0, .5);\n    for(int i = 0; i<7; i++){\n        if(n == 5.) break;\n        hDots = min(hDots, length(pL - v0));\n        v0 = rot2(PI*2./float(n))*v0;\n    }\n    // Combining with the pentagon dots. \n    hDots = min(hDots, pDots);\n    \n     \n    // Outer shape borders with some white dots over the top for dotted lines.\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, abs(d.x) - .01)));\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, hDots - .15)));\n\n \n    // Rendering the outer borders.\n    //col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x + .09 - .035))*.35);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d.x + .09)));\n    col = mix(col, lCol, (1. - smoothstep(0., sf, d.x + .09 + .05)));\n  \n    // Rendering the outer dots.\n    col = mix(col, vec3(0), 1. - smoothstep(0., sf, hDots - .04));\n    // Rings.\n    //col = mix(col, vec3(0), 1. - smoothstep(0., sf, abs(hDots - .04) - .02));\n   \n     \n    #ifdef SHOW_GRID\n    // Grid to show individual tiles.\n    float grid = gridField(p);\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, grid - .025))*.9);\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, grid)));\n    #endif\n\n    // Output to screen\n    fragColor = vec4(sqrt(max(col, 0.)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtByzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1353, 1386, 1408, 1408, 1466], [1469, 1497, 1518, 1518, 1581], [1584, 1768, 1801, 1801, 1890], [1893, 1970, 2011, 2044, 2415], [7743, 7819, 7843, 7843, 8023], [8026, 8026, 8080, 8123, 12891]], "test": "untested"}
{"id": "wl2yRm", "name": "Impulse backdrop", "author": "mrange", "description": "License CC0: Impulse backdrop\nCreated a backdrop for a webpage. I liked the result so sharing it.\nCode borrowed from the usual suspects: IQ, Shane, Shau, EvilRyu and otaviogood", "tags": ["2d", "fbm"], "likes": 16, "viewed": 619, "published": 3, "date": "1594040022", "time_retrieved": "2024-07-30T20:57:09.188437", "image_code": "#define PI               3.141592654\n#define TAU             (2.0*PI)\n#define TIME            iTime\n#define RESOLUTION      iResolution\n#define SCA(a)          vec2(sin(a), cos(a))\n \n#define LESS(a,b,c)     mix(a,b,step(0.,c))\n#define SABS(x,k)       LESS((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\nconst vec2 sca0 = SCA(0.0);\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b) {\n  vec2 d = abs(p)-b;\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat horseshoe(vec2 p, vec2 c, float r, vec2 w) {\n  p.x = abs(p.x);\n  float l = length(p);\n  p = mat2(-c.x, c.y, c.y, c.x)*p;\n  p = vec2((p.y>0.0)?p.x:l*sign(-c.x),(p.x>0.0)?p.y:l);\n  p = vec2(p.x,abs(p.y-r))-w;\n  return length(max(p,0.0)) + min(0.0,max(p.x,p.y));\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat letteri(vec2 p) {\n  p.y -= 0.25;\n  return box(p, vec2(0.125, 0.75));\n}\n\nfloat letterm(vec2 p) {\n  p.y = -p.y;\n  float l = horseshoe(p - vec2(+0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  float r = horseshoe(p - vec2(-0.5, 0.0), sca0, 0.5, vec2(0.5, 0.1));\n  return min(l, r);\n}\n\nfloat letterp(vec2 p) {\n  float b = box(p - vec2(-0.45, -0.25), vec2(0.1, 0.75));\n  float c = max(circle(p, 0.5), -circle(p, 0.3));\n  return min(b, c);\n}\n\nfloat letteru(vec2 p) {\n  return horseshoe(p - vec2(0.0, 0.125), sca0, 0.5, vec2(0.375, 0.1));\n}\n\nfloat letterl(vec2 p) {\n  return box(p, vec2(0.125, 0.5));\n}\n\nfloat letters(vec2 p) {\n  rot(p, -PI/6.0);\n  rot(p, -PI/2.0);\n  float u = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1)) - 0.0;\n  rot(p, PI);\n  float l = horseshoe(p - vec2(-0.25*3.0/4.0, -0.125/2.0), sca0, 0.375, vec2(0.2, 0.1));\n  return min(u,l);\n}\n\nfloat lettere(vec2 p) {\n  return min(box(p, vec2(0.4, 0.1)), max(circle(p, 0.5), -circle(p, 0.3)));\n}\n\nfloat impulse(vec2 p) {\n  p.x += 0.6;\n  const float oi = -3.00;\n  const float om = -1.65;\n  const float op = +0.10;\n  const float ou = +1.25;\n  const float ol = +2.10;\n  const float os = +2.80;\n  const float oe = +3.85;\n  float di = letteri(p - vec2(oi, 0.0));\n  float dm = letterm(p - vec2(om, 0.0));\n  float dp = letterp(p - vec2(op, 0.0));\n  float du = letteru(p - vec2(ou, 0.0));\n  float dl = letterl(p - vec2(ol, 0.0));\n  float ds = letters(p - vec2(os, 0.0));\n  float de = lettere(p - vec2(oe, 0.0));\n  float oo = 0.1;\n  float dx = abs(p.y) - oo;\n  dx = abs(dx) - oo*0.5;\n  float d = 1000000.0;\n  d = min(d, di);\n  d = min(d, dm);\n  d = min(d, dp);\n  d = min(d, du);\n  d = min(d, dl);\n  d = min(d, ds);\n  d = min(d, de);\n  d = max(d, -dx);\n  \n  return d;\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU/1.25*(a*b+a+b)));\n  \n  return c;\n}\n\nfloat cell0(vec2 p) {\n  float d1 = length(p+vec2(0.5)) - 0.5;\n  float d2 = length(p-vec2(0.5)) - 0.5;\n  float d = min(d1, d2);\n  return d;\n}\n\nfloat cell1(vec2 p) {\n  float d1 = abs(p.x);\n  float d2 = abs(p.y);\n  float d3 = length(p) - 0.25;\n  float d = min(d1, d2);\n  d = min(d, d3);\n  return d;\n}\n\nfloat tnoise(vec2 p) {\n  p *= 0.125;\n  p += 0.5;\n  vec2 nn = floor(p);\n  vec2 pp = fract(p) - 0.5;\n  float r = hash(nn);\n  vec2 rot = -1.0 + 2.0*vec2(step(fract(r*13.0), 0.5), step(fract(r*23.0), 0.5));\n  pp *= rot;\n  const float w = 0.1;\n  float d = 1E6;\n  if(r < 0.75) {\n    d = cell0(pp);\n  } else  {\n    d = cell1(pp);\n  }\n  d = abs(d) - w;\n  float h = smoothstep(0.0, w, -d);  \n  return h;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm(vec2 p) {\n  const int mid = 3;\n  const int mx = 7;  \n  const float aa = 0.4;\n  const float pp = 2.3;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  vec2 op = p;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < mid; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n\n  for (int i = mid; i < mx; ++i) {\n    h += a*tnoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return 0.5*mix(-1.0, 1.0, smoothstep(0.0, 1.2, (vnoise(0.50*op))))*(h/d);\n}\n\nfloat warp(vec2 p) {\n  vec2 v = vec2(fbm(p), fbm(p+10.7*vec2(1.0, 1.0)));\n  rot(v, 1.0+TIME*0.125);\n  return mix(0., 1.0, v.x - v.y);\n}\n\nfloat height(vec2 p) {\n  float a = 0.005*TIME;\n  p += 5.0*vec2(cos(a), sin(sqrt(0.5)*a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n//  return 0.75*tanh(rs*h)/rs;\n  return 0.75*h;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/RESOLUTION.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // saturation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nfloat df(vec2 p) {\n  p *= 3.0;\n  float d = impulse(p);\n  return d;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n \n  const vec3 lp1 = vec3(0.8, -0.75, 0.8);\n  const vec3 lp2 = vec3(-0., -1.5, -1.0);\n\n  float aa = 10.0/RESOLUTION.y;\n  \n  vec3 col = vec3(0.0);\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n \n  const vec3 baseCol1 = vec3(0.6, 0.8, 1.0);\n  const vec3 baseCol2 = sqrt(baseCol1.zyx);\n  \n  col += baseCol1*pow(diff1, 16.0);\n  col += 0.1*baseCol1*pow(diff1, 4.0);\n  col += 0.15*baseCol2*pow(diff2,8.0);\n  col += 0.015*baseCol2*pow(diff2, 2.0);\n\n  col = clamp(col, 0.0, 1.0);\n  col = mix(0.05*baseCol1, col, 1.0 - (1.0 - 0.5*diff1)*exp(- 2.0*smoothstep(-.1, 0.05, (h))));\n  \n  float d = df(p);\n  float bd = abs(d - 0.03) - 0.015;\n  \n  float shd = pow(psin(-0.25*TIME+(p.x-p.y)*1.5), 4.0);\n  col += 1.0*baseCol1*(exp(-20.0*bd))*shd;\n  col += 0.5*baseCol1*(exp(-1.0*bd))*shd;\n  col -= 0.125*vec3(1.0)*(exp(-5.0*d));\n  col = clamp(col, 0.0, 1.0);\n  col = mix(col, vec3(1.0), smoothstep(0.0, aa, -d));\n\n  col = postProcess(col, q);\n\n  const float fadeIn = 3.0;\n  col *= smoothstep(0.0, fadeIn*fadeIn, TIME*TIME);\n  \n  fragColor = vec4(col, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[319, 319, 343, 343, 413], [415, 415, 436, 436, 465], [467, 467, 498, 498, 524], [526, 526, 553, 553, 629], [631, 631, 681, 681, 898], [900, 900, 933, 933, 1018], [1020, 1020, 1043, 1043, 1096], [1098, 1098, 1121, 1121, 1299], [1301, 1301, 1324, 1324, 1454], [1456, 1456, 1479, 1479, 1552], [1554, 1554, 1577, 1577, 1614], [1616, 1616, 1639, 1639, 1896], [1898, 1898, 1921, 1921, 1999], [2001, 2001, 2024, 2024, 2763], [2765, 2765, 2787, 2787, 2909], [2911, 2911, 2932, 2932, 3051], [3053, 3053, 3074, 3074, 3208], [3210, 3210, 3232, 3232, 3606], [3608, 3608, 3630, 3630, 4197], [4199, 4199, 4218, 4218, 4785], [4787, 4787, 4807, 4807, 4922], [4924, 4924, 4946, 4946, 5127], [5129, 5129, 5150, 5183, 5390], [5392, 5392, 5429, 5429, 5679], [5681, 5681, 5699, 5699, 5749], [5751, 5751, 5806, 5806, 7121]], "test": "untested"}
{"id": "tl2yRm", "name": "The Confetti", "author": "yasuo", "description": "This code is based on https://www.shadertoy.com/view/tljcRW\n @BigWIngs Thank you for the awesome tutorial code!\n", "tags": ["confetti"], "likes": 6, "viewed": 630, "published": 3, "date": "1594038397", "time_retrieved": "2024-07-30T20:57:10.018190", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n#define T (iTime)\n#define matRotateZ(rad) mat3(cos(rad),-sin(rad),0,sin(rad),cos(rad),0,0,0,1)\n#define DEBUG 0\n\n// https://iquilezles.org/articles/distfunctions2d\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 Transform(vec3 p, float angle) {\n    p.xz*=Rot(angle);\n    p.xy*=Rot(angle*.7);\n    return p;\n}\n\nfloat Confetti(vec3 ro, vec3 rd,vec3 pos, float angle, int type) {\n    float t = dot(pos-ro,rd);\n    vec3 p = ro+rd*t;\n    float y = length(pos-p);\n    vec2 bsize = vec2(0.2,0.25);\n    float d = 1.0;\n    if(type == 0 && y<1.0) {\n        float x = sqrt(1.0-y);\n        \n        // front\n        vec3 pF = ro+rd*(t-x)-pos;\n        pF = Transform(pF,angle);\n        vec2 uvF = vec2(atan(pF.x,pF.z),pF.y);\n        float f = sdBox(uvF,bsize);\n        \n        // back\n        vec3 pB = ro+rd*(t+x)-pos;\n        pB = Transform(pB,angle);\n        vec2 uvB = vec2(atan(pB.x,pB.z),pB.y);\n        float b = sdBox(uvB,bsize);\n        d = min(f,b);\n    }\n    \n    y = sdCappedCylinder((pos-p)*matRotateZ(radians(90.0)), 0.3,0.001);\n    bsize = vec2(1.0,0.02);\n    if(type == 1 && y<0.07) {\n\t\tp = pos-p;\n\t\t\n        vec2 uv = p.xy;\n        uv*=Rot(radians(30.0));\n        uv.y-=T*0.2;\n        \n        uv.y = mod(uv.y,0.1)-0.05;\n        d = sdBox(uv,bsize);\n    }\n    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 M = iMouse.xy/iResolution.xy-.5;\n\n    vec3 bg = .9*max(mix(vec3(1.2)+(.1-length(uv.xy)/3.),vec3(1),.1),0.);\n    vec4 col = vec4(bg,0.0);\n    vec3 ro = vec3(0.0,0.0,-3.0);\n    vec3 rd = normalize(vec3(uv,1));\n\t    \n    #if DEBUG\n        float confetti = Confetti(ro,rd,vec3(0.0),iTime,1);\n        col = mix(col,vec4(vec3(1.0,0.0,0.0),1.0),S(confetti,0.0));\n\t#else\n        for(float i = 0.; i<1.0; i+=1.0/60.0) {\n            float x = mix(-8.0,8.0,fract(i))+M.x;\n            float y = mix(-5.,5.,fract((sin(i*564.3)*4570.3)-T*.3))+M.y;\n            float z = mix(5.0,0.0,i);\n            float a = T+i*563.34;\n            float ratio = clamp(fract((sin(i*1564.3)*9570.3)),0.0,1.0);\n            int type = (i<ratio)?0:1;\n\n            vec3 ccol = 0.5 + 0.5*cos(T+uv.xyx+vec3(i,2,4));\n            float confetti = Confetti(ro,rd,vec3(x,y,z),a,type);\n            col = mix(col,vec4(ccol,1.0),S(confetti,0.0));\n        }\n    #endif\n        \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tl2yRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 321, 358, 358, 438], [440, 440, 492, 492, 599], [601, 601, 638, 638, 701], [703, 703, 769, 769, 1673], [1675, 1675, 1732, 1732, 2755]], "test": "untested"}
{"id": "3tjczm", "name": "Bilinear Patch - distance", "author": "iq", "description": "Attempting to compute the SDF of a bilinear patch (p0,p1,p2,p3), by searching for roots of a quintic equation in parametric space. In its default settings it has artifacts, so set INITIAL to 1 to fix most of them at some performance cost.", "tags": ["3d", "raymarching", "sdf", "bilinear", "hyperboloid", "patch", "bilinearpatch"], "likes": 39, "viewed": 2738, "published": 3, "date": "1594036681", "time_retrieved": "2024-07-30T20:57:10.887864", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n\n// Attempting to compute the SDF of a bilinear \n// patch (p0,p1,p2,p3), by searching for the roots of\n// a quintic polynomial in parametric space. It works,\n// but it's unstable. So, not successfull. I might try\n// to find an implicit form instead, another time. But\n// for now, this is the derivation:\n//\n// q(u,v) = p0 + u(p1-p0) + v(p3-p0) + uv(p2-p3-p1+p0)\n//\n// D²(uv) = |p-q(u,v)|² = |D+uA+vB+uvC|²\n//\n// ∇D²(uv) = 2(uAA + uv²CC + v(AB+CD) + 2uvAC +  v²*BC + AD,\n//             vBB + u²vCC + u(AB+CD) +  u²AC + 2uv*BC + BD)\n//\n// ∇D²(uv) = 0 gives two equations\n//\n// Isolating u in one and replacing in the other produces\n// an equation of degree 9, which we cannot solve in \n// closed form. So, we need another method. I implemented\n// two method to find the roots:\n// \n// Method 0 is to isolate u and v anywways, and iterate:\n//\n//   v = -(u²AC + u(AB+CD) + BD) / |B+uC|²\n//   u = -(v²BC + v(AB+CD) + AD) / |A+vC|²\n//\n// Method 1 is using the Newton method: https://en.wikipedia.org/wiki/Newton%27s_method_in_optimization\n//\n//   Gradient G=2*( uAA + uv²CC + v(AB+CD) + 2uvAC +  v²BC + AD,\n//                  vBB + u²vCC + u(AB+CD) +  u²AC + 2uvBC + BD)\n//\n//   Hessian H = 2*( AA + v²CC + 2vAC, \n//                   2uvCC + ABCD + 2uAC + 2vBC,\n//                   2uvCC + ABCD + 2uAC + 2vBC,\n//                   BB + u²CC + 2uBC )\n//\n//   uv = uv - inverse(H(uv))*G(uv)\n//\n// I implemented two ways to initialize the root finders:\n//\n// Initial 0 just starts at the center of the patch\n// Initial 1 computes 15 geodesics and picks the uv's of the\n//           closest point in any geodesic\n//\n// The cube is from from fizzer's bilinear-patch\n// intersection shader: https://www.shadertoy.com/view/3dXGWs\n\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n\n// 0: hack\n// 1: newtown\n#define METHOD 0\n\n// 0: middle      ---> fast but bad\n// 1: line scans  ---> much better, but slower\n#define INITIAL 1\n\n\n// enable SHADOWS and floor plane if you have a fast machine\n#define SHADOWS\n\n\n//-------------------------------------------------------\n\nfloat dot2( in vec3 v ) { return dot(v,v); }\n\nvec3 sdBilinearPatch( in vec3 p,\n                      in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3 )\n{    \n    vec3 A = p1-p0;\n    vec3 B = p3-p0;\n    vec3 C = p2-p3-p1+p0;\n    vec3 D = p0-p;\n\n    // initial guess\n\n#if INITIAL==0\n    vec2 uv = vec2(0.5,0.5);\n#endif\n#if INITIAL==1\n    vec2 uv = vec2(0.0,0.0);\n    float d = dot2(p-p0);\n    for( int i=0; i<16; i++ )\n    {\n        float u = float(i)/15.0;\n        vec3 ba = mix( B,p2-p1,u);\n        vec3 pa = mix(-D,p -p1,u);\n\t\tfloat v = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\tfloat t = dot2(pa-ba*v);\n        if( t<d ) { d=t; uv=vec2(u,v); }\n    }\n    //return vec3(sqrt(d),uv);\n#endif\n    \n    // find roots\n    \n#if METHOD==0\n    vec2  k2 = vec2(dot(A,C),dot(B,C));\n    vec2  k0 = vec2(dot(B,D),dot(A,D));\n    float k1 = dot(A,B)+dot(C,D);\n    for( int i=0; i<16; i++ )\n    {\n      uv.yx = clamp( -(uv*uv*k2 + uv*k1 + k0 ) /\n                     vec2( dot2(B+uv.x*C), dot2(A+uv.y*C) ),\n                     0.0, 1.0);\n    }\n    vec3 pq = D+uv.x*A+uv.y*B+uv.x*uv.y*C;\n    vec3 nor = cross(A+uv.y*C,B+uv.x*C); // normal\n\treturn vec3( length(pq), uv );\n#endif\n    \n#if METHOD==1\n    float AA = dot(A,A);\n    float BB = dot(B,B);\n    float CC = dot(C,C);\n    float BC = dot(B,C);\n    float AC = dot(A,C);\n    float ABCD = dot(A,B)+dot(C,D);\n    float AD = dot(A,D);\n    float BD = dot(B,D);\n    for( int i=0; i<6; i++ )\n    {\n        vec2 gra = vec2(\n         uv.x*AA + uv.x*uv.y*uv.y*CC + uv.y*ABCD + 2.0*uv.x*uv.y*AC +     uv.y*uv.y*BC + AD,\n         uv.y*BB + uv.x*uv.x*uv.y*CC + uv.x*ABCD +     uv.x*uv.x*AC + 2.0*uv.x*uv.y*BC + BD);\n\n        float k1 = 2.0*uv.x*uv.y*CC + ABCD + 2.0*uv.x*AC + 2.0*uv.y*BC;\n        mat2x2 hes = mat2x2(\n         AA + uv.y*uv.y*CC + 2.0*uv.y*AC,\n         k1, k1, \n         BB + uv.x*uv.x*CC + 2.0*uv.x*BC );\n        \n        uv -= inverse(hes)*gra;\n        \n        uv = clamp(uv,0.0,1.0);\n    }\n    vec3 nor = cross(A+uv.y*C,B+uv.x*C); // normal\n\treturn vec3( length(D+uv.x*A+uv.y*B+uv.x*uv.y*C), uv );\n#endif    \n}\n\n//-------------------------------------------------------\n\nvec3 gVerts[8]; // Deformed cube geometry\n\nconst float kRoundness = 0.03;\n\n// sdf\nvec3 map( in vec3 p )\n{\n    vec3 res = vec3(length(p-gVerts[0]),0.0,0.0);\n\n    \n    //   2---3\n    //  /   /|\n    // 6---7 |\n    // |   | 1\n    // 4---5/\n    \n    vec3 tmp;\n    tmp = sdBilinearPatch(p, gVerts[0], gVerts[2], gVerts[3], gVerts[1]); if( tmp.x<res.x ) res = tmp;\n    tmp = sdBilinearPatch(p, gVerts[7], gVerts[6], gVerts[4], gVerts[5]); if( tmp.x<res.x ) res = tmp;\n    tmp = sdBilinearPatch(p, gVerts[0], gVerts[1], gVerts[5], gVerts[4]); if( tmp.x<res.x ) res = tmp;\n    tmp = sdBilinearPatch(p, gVerts[2], gVerts[6], gVerts[7], gVerts[3]); if( tmp.x<res.x ) res = tmp;\n    tmp = sdBilinearPatch(p, gVerts[0], gVerts[4], gVerts[6], gVerts[2]); if( tmp.x<res.x ) res = tmp;\n    tmp = sdBilinearPatch(p, gVerts[1], gVerts[3], gVerts[7], gVerts[5]); if( tmp.x<res.x ) res = tmp;\n    \n    res.x -= kRoundness; // round it a bit\n    return res;\n}\n\n// https://iquilezles.org/articles/intersectors\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n    h = sqrt(h);\n\treturn vec2(-b-h,-b+h);\n}\n\nint raycast( in vec3 ro, in vec3 rd, out vec3 oUVT)\n{\n    int   obj = 0;\n    float tmin = 2.0;\n    float tmax = 5.0;\n    vec2  uv = vec2(0.0);\n\n    // floor\n    #ifdef SHADOWS\n    float tf = (-2.0 - ro.y) / rd.y;\n    if( tf>0.0 ) { tmax=min(tmax,tf); obj=1; oUVT = vec3(0.0,0.0,tf); }\n    #endif\n\n    // bounding sphere\n    vec2 bs = iSphere(ro,rd,vec4(0.0,0.0,0.0,sqrt(3.0)+kRoundness));\n    if( bs.y>0.0 )\n    {\n        tmin = max(tmin,bs.x); // clip search space\n        tmax = min(tmax,bs.y); // clip search space\n        \n        // rayamarch cube\n        float t = tmin;\n        for( int i=0; i<256; i++ )\t\n        {\n            vec3 pos = ro + t*rd;\n            vec3 duv = map(pos);\n            uv = duv.yz;\n            if( (duv.x)<0.001 ) break;\n            t += duv.x;\n            if( t>tmax ) break;        \n        }\n\n        if( t<tmax )\n        {\n            obj = 2;\n            oUVT = vec3(uv,t);\n        }\n    }\n\n    return obj;\n}\n\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float tmin = 0.001;\n    float tmax = 8.0;\n\n    float res = 1.0;\n    \n    // bounding sphere\n    vec2 bs = iSphere(ro,rd,vec4(0.0,0.0,0.0,sqrt(3.0)+kRoundness+0.2));\n    if( bs.y>0.0 )\n    {\n        tmin = max(tmin,bs.x); // clip search space\n        tmax = min(tmax,bs.y); // clip search space\n        \n        float t = tmin;\n        for( int i=0; i<64; i++ )\n        {\n            float h = map( ro + rd*t ).x;\n            float s = clamp(8.0*h/t,0.0,1.0);\n            res = min( res, s*s*(3.0-2.0*s) );\n            t += clamp( h, 0.02, 0.5 );\n            if( res<0.005 || t>tmax ) break;\n        }\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(0,iFrame); i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec2 rot( vec2 p, float an )\n{\n    return mat2(cos(an), sin(an), -sin(an), cos(an)) * p;\n}\n\nconst float N = 32.0;\nfloat gridTexture( in vec2 p )\n{\n\t// filter kernel\n    vec2 w = fwidth(p) + 0.01;\n\n\t// analytic (box) filtering\n    vec2 a = p + 0.5*w;                        \n    vec2 b = p - 0.5*w;           \n    vec2 i = (floor(a)+min(fract(a)*N,1.0)-\n              floor(b)-min(fract(b)*N,1.0))/(N*w);\n    //pattern\n    return (1.0-i.x)*(1.0-i.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.0*fragCoord-iResolution.xy) / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 4.0);\n    vec3 rd = normalize(vec3(uv, -1.6));\n\n    // vertex deformation, from https://www.shadertoy.com/view/3dXGWs\n    float time = iTime;\n    float amp = smoothstep(0.0,0.2,0.5-0.5*cos(6.2831*time/15.0));\n    for(int i = 0; i<8; i++)\n    {\n        vec3 p = vec3((ivec3(i)>>ivec3(0,1,2))&1)*2.0-1.0;\n\n        p.xz = rot(p.xz,  amp*cos(time*3.0*6.2831/15.0+p.y+0.0)/2.0 );\n        p.yz = rot(p.yz, -amp*cos(time*1.0*6.2831/15.0+p.x+2.0)/1.0 );\n        p.xz = rot(p.xz,  4.0 + time*1.0*6.2831/15.0 );\n        \n        gVerts[i] = p;\n    }\n\n    // render\n    \n    vec3 col = vec3(0.0);\n\n    vec3 uvt;\n    int obj = raycast(ro, rd, uvt);\n    if( obj>0 )\n    {\n        float t = uvt.z;\n        vec3 pos = ro + t*rd;\n    \tvec3 nor = vec3(0.0,1.0,0.0);\n        vec2 uv = pos.xz*0.25;\n        #ifdef SHADOWS\n    \tif( obj==2 )\n        #endif\n        {\n            uv = uvt.xy;\n        \tnor = calcNormal(pos);\n        }\n\n        // shade and illuminate (oldscool way)\n        vec3 tex = texture(iChannel0,uv).xyz;\n    \t//tex *= gridTexture(4.0*uv);\n        \n    \tvec3  lig = normalize(vec3(6, 5,-1));\n        vec3  hal = normalize(lig-rd);\n        float dif = clamp(dot(nor,lig),0.0,1.0);\n        float spe = pow(max(0.0, dot(nor,hal)), 16.0);\n        float amb = 0.5+0.5*nor.y;\n        float bou = 0.5+0.5-nor.y;\n\n        #ifdef SHADOWS\n        if( dif>0.0 )\n        {\n    \t\tdif *= calcSoftshadow(pos+0.01*nor, lig);\n        }\n        #endif\n\n        spe *= 0.04 + 0.96*pow(clamp(1.0-dot(lig,hal),0.0,1.0),5.0);\n        col = tex*(4.0*dif*vec3(1.00,0.70,0.70) + \n                   1.0*amb*vec3(0.15,0.10,0.05)+\n                   1.0*bou*vec3(0.20,0.07,0.02)) + \n              tex.x*spe*dif*20.0;\n        col *= exp2(-t*0.1);\n    }\n    \n    // gain\n    col = col*2.0/(1.0+col);\n\t// gamma\n    col = pow(col,vec3(0.4545));\n    \n    // grade\n    col.z += 0.02;\n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": 6, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjczm.jpg", "access": "api", "license": "mit", "functions": [[3233, 3233, 3258, 3258, 3277], [3279, 3279, 3384, 3384, 5287], [5423, 5430, 5453, 5453, 6286], [6288, 6336, 6389, 6389, 6576], [6578, 6578, 6631, 6631, 7524], [7527, 7572, 7620, 7620, 8268], [8271, 8317, 8349, 8349, 8888], [8890, 8890, 8920, 8920, 8980], [9004, 9004, 9036, 9054, 9341]], "test": "untested"}
{"id": "wl2yRw", "name": "Mystify", "author": "Zi7ar21", "description": "One of my first shaders, experimenting with fBm noise.", "tags": ["2d", "fractal", "noise", "fbm", "trippy"], "likes": 1, "viewed": 339, "published": 3, "date": "1594021007", "time_retrieved": "2024-07-30T20:57:11.745572", "image_code": "#define NUM_OCTAVES 8\n#define pi 3.14159265\n\nfloat mod289(float x){return x-floor(x*(1.0/289.0))*289.0;}\nvec4 mod289(vec4 x){return x-floor(x*(1.0/289.0))*289.0;}\nvec4 perm(vec4 x){return mod289(((x*34.0)+1.0)*x);}\n\nfloat noise(vec3 p){\n    vec3 a = floor(p);\n    vec3 d = p-a;\n    d = d*d*(3.0-2.0*d);\n    vec4 b = a.xxyy+vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 k1 = perm(b.xyxy);\n    vec4 k2 = perm(k1.xyxy+b.zzww);\n    vec4 c = k2+a.zzzz;\n    vec4 k3 = perm(c);\n    vec4 k4 = perm(c+1.0);\n    vec4 o1 = fract(k3*(1.0/41.0));\n    vec4 o2 = fract(k4*(1.0/41.0));\n    vec4 o3 = o2*d.z+o1*(1.0-d.z);\n    vec2 o4 = o3.yw*d.x+o3.xz*(1.0-d.x);\n    return o4.y*d.y+o4.x*(1.0-d.y);\n}\n\n// 2D fBm Noise, basically justs adds noise, scales it by 2, adds it back with 1/2 the effect, and repeat.\nfloat fbm(vec3 x){\n\tfloat v = 0.0;\n\tfloat a = 0.5;\n\tfor (int i = 0; i < NUM_OCTAVES; i++){\n\t\tv += a*noise(x);\n\t\tx = x*2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n// Draw Image\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    // Normalized Pixel Coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\n    // Time Varying Pixel Color\n    vec3 col = vec3(fbm(vec3(uv*4.0*(sin(iTime*pi)+8.0), (iTime*0.25)+0.0)),\n                    fbm(vec3(uv*4.0*(sin(iTime*pi)+8.0), (iTime*0.25)+1.0)),\n                    fbm(vec3(uv*4.0*(sin(iTime*pi)+8.0), (iTime*0.25)+2.0)));\n\n    // Output to Screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 67, 67, 104], [105, 105, 125, 125, 162], [163, 163, 181, 181, 214], [216, 216, 236, 236, 672], [674, 781, 799, 799, 931], [933, 947, 1001, 1051, 1436]], "test": "untested"}
{"id": "Wtjczw", "name": "Pixelated rainbow clouds + Pink!", "author": "Yambam", "description": "Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK", "tags": ["hash"], "likes": 6, "viewed": 382, "published": 3, "date": "1593990716", "time_retrieved": "2024-07-30T20:57:12.943369", "image_code": "// Fork of \"Pixelated rainbow clouds\" by jarble. https://shadertoy.com/view/ttjXDK\n// 2020-07-05 23:08:47\n\n//this function is from https://www.shadertoy.com/view/4djSRW\nvec3 hash32(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\n\nvec3 magnify(vec2 fragCoord,float mag){\n\treturn hash32(floor(fragCoord*.3/pow(1.2,mag)));\n}\n\nvec3 pixel_above(vec2 fragCoord,float mag){\n\treturn magnify(fragCoord+vec2(pow(2.,mag),0)*3.*iTime,mag);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color1 = vec3(0,0,0);\n    float maximum = 5.0;\n    for(float i = 1.0; i < 1.0+maximum; i++){\n    \tcolor1 += pixel_above(fragCoord,i+1.0);\n    }\n    fragColor = vec4(color1/maximum,0.0);\n    fragColor.r = mix(fragColor.r, 1., max(0., 3.3 - 3.*fragColor.b - 4.*fragColor.g));\n    fragColor.b += .2*fragColor.r;\n    fragColor.g -= .1*fragColor.b;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtjczw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 169, 190, 190, 326], [329, 329, 368, 368, 420], [422, 422, 465, 465, 528], [530, 530, 587, 587, 942]], "test": "untested"}
{"id": "3ljcRw", "name": "Strange trigonometric surface", "author": "jarble", "description": "This bizarre surface is defined using sine and cosine functions.", "tags": ["3d", "raymarching"], "likes": 2, "viewed": 279, "published": 3, "date": "1593984946", "time_retrieved": "2024-07-30T20:57:14.269822", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat surface1(vec3 p){\n    //p.z += .0;\n    p += sin(p.zxy/2000.0)*(3000.0);\n    vec3 p1 = p/size/3.0;\n    p = p1*(cos(p1))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    p = sin(p/40000.0)*40000.0;\n    p /= 20.0;\n    float i = 27.0;\n    result = surface1(p*i)/(i);\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale*1.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(.5+sin(p/3.0)/4.0)/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,70.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[517, 517, 540, 557, 678], [682, 682, 706, 706, 940], [942, 942, 970, 970, 1031], [1034, 1455, 1546, 1546, 1852], [1867, 2121, 2186, 2186, 2318], [2320, 2409, 2438, 2438, 2748], [2750, 3242, 3382, 3382, 3992], [3994, 4364, 4449, 4449, 4864], [4866, 5193, 5242, 5277, 5408], [5410, 5410, 5467, 5467, 6374]], "test": "untested"}
{"id": "Wt2yRw", "name": "Fractal sandstone canyons", "author": "jarble", "description": "I modified the formula of a [url=https://www.shadertoy.com/view/WtByzw]\"fractal foliage\"[/url] shader to create these canyons.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 306, "published": 3, "date": "1593982719", "time_retrieved": "2024-07-30T20:57:15.030787", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(.5+sin(p/3.0)/4.0)/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n            viewDir.xz *= rot(-iMouse.x/iResolution.x*3.14*2.0+3.14);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat planet_surface(vec3 p){\n    //p.z += .0;\n    p += sin(p.zxy/200.0)*500.0;\n    p = p/size/3.0;\n    return (length(p*cos(p)) - 1.0);\n}\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = 0.0;\n    p /= 10.0;\n    p = sin(p/5000.0)*5000.0;\n\n\n    for(float i = 1.0; i < 27.0; i *= 3.0){\n        result += planet_surface(p*i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return -result*size*scale*3.0;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2yRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 87, 87, 148], [151, 572, 663, 663, 969], [984, 1238, 1303, 1303, 1435], [1437, 1526, 1555, 1555, 1865], [1867, 2359, 2499, 2499, 3109], [3111, 3481, 3566, 3566, 3981], [3983, 4310, 4359, 4394, 4525], [4527, 4527, 4584, 4584, 5686]], "test": "untested"}
{"id": "3lByzm", "name": "Octagon and Square Truchet", "author": "Oggbog", "description": "Thought I'd have a go at a truchet pattern using octagons and squares seeing as they tessellate nicely.\nIt's looking a bit rough around the edges at the moment...\nLooks better full screen.", "tags": ["truchet"], "likes": 3, "viewed": 280, "published": 3, "date": "1593974896", "time_retrieved": "2024-07-30T20:57:15.906446", "image_code": "#define PI 3.141592653589793\n\nfloat hash21(vec2 p) {\n    p = fract(p * vec2(144.34, 1051.74));\n    p += dot(p, p + 230.45);\n    return fract(p.x * p.y + p.y + p.x);\n}\n\n\nvec2 rot(vec2 st, float a){\n   return st * mat2(cos(a),-sin(a),sin(a),cos(a)); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 qv = uv - 0.5;\n    \n    float g = 5.; // has to be an odd number to work correctly\n    \n    vec2 id = floor(uv * g);\n    uv = fract(uv * g)-.5;\n    vec2 qd = floor(qv * g);\n    qv = fract(qv * g)-.5;\n    \n    float c = .71;\n    float m = 0.;\n\t\n    vec2 sv = uv;\n    \n    float t =(iTime*.5)*PI/4.;\n    float tq = (iTime * .5)*PI/2.;\n    float r = hash21(id);\n    float q = hash21(qd);\n    \n    uv = rot(uv,id.x*floor(t*r)*PI/4.);\n    qv = rot(qv,qd.x*floor(tq*q)*PI/2.);\n    \n    \n    // Octagon pattern\n    m+= uv.y < .05 && uv.y > -.05  && uv.x > -.5 && uv.x < -.3 ? 1.:0.;\n  \tm+= uv.y < .5 && uv.y > .3 && uv.x < .05 && uv.x > -.05 ? 1.:0.;\n    m+= uv.y < uv.x+.35 && uv.y > uv.x +.2  && uv.x < .05  && uv.y > -0.05 ? 1.:0.;\n\t\n    uv = rot(uv,PI);\n    m+= uv.y < .05 && uv.y > -.05  && uv.x > -.5 && uv.x < -.3 ? 1.:0.;\n  \tm+= uv.y < .5 && uv.y > .3 && uv.x < .05 && uv.x > -.05 ? 1.:0.;\n    m+= uv.y < uv.x+.35 && uv.y > uv.x +.2  && uv.x < .05  && uv.y > -0.05 ? 1.:0.;\n \t\n    m += uv.y >-uv.x - .071 && uv.y < -uv.x + .071 && uv.y > uv.x-c && uv.y < uv.x + c ? 1.:0.;\n    uv = rot(uv,PI/2.);\n    m += uv.y >-uv.x - .071 && uv.y < -uv.x + .071 && uv.y > uv.x-c && uv.y < uv.x + c ? 1.:0.;\n    \n    // Square pattern\n    m += qv.x>-.2 && qv.x<-.11 && qv.y<0.18 && qv.y > -0.18 ? 1.:0.;\n   \tm += qv.x<.2 && qv.x>.11 && qv.y<0.18 && qv.y > -0.18 ? 1.:0.;\n   \n    vec3 col =vec3(m);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByzm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 52, 52, 166], [169, 169, 196, 196, 250], [252, 252, 309, 309, 1800]], "test": "untested"}
{"id": "tlBcRw", "name": "Analytic rasterizatio of an edge", "author": "Schrompf", "description": "Analytic Rasterization: determines how much of a (square) pixel area is covered by an arbitrary triangle. An attempt to recreate the UnrealEngine5 micro triangle rasterizer. Click and drag somewhere. \nThis is one edge only, going for real triangles later", "tags": ["antialiasing"], "likes": 1, "viewed": 318, "published": 3, "date": "1593950377", "time_retrieved": "2024-07-30T20:57:16.758169", "image_code": "const float GridSize = 16.0f;\n\nfloat edgeIntegral( vec2 pa, vec2 pb, vec2 rectMin, vec2 rectMax)\n{\n    vec2 dir = normalize( pb - pa);\n    vec2 dirSign = mix( vec2( 1.0f), vec2( -1.0f), lessThan( dir, vec2( 0.0f)));\n\tfloat len = length( pb - pa);\n\n    vec2 areaMin = max( rectMin, min( pa, pb));\n    vec2 areaMax = min( rectMax, max( pa, pb));\n    \n    vec2 rectCenter = 0.5f * (rectMin + rectMax);\n    vec2 rectSize = rectMax - rectMin;\n    \n    vec2 middleIntersecPos = mix( (rectCenter - pa) / dir, vec2( 10000.0f), equal( dir, vec2( 0.0f)));\n    vec2 intersecSize = dirSign * mix( rectSize / dir, vec2( 10000.0f), equal( dir, vec2( 0.0f)));\n \n    vec2 entryDist = middleIntersecPos - 0.5f * intersecSize;\n    vec2 exitDist = middleIntersecPos + 0.5f * intersecSize;\n\n    float latestEntry = max( 0.0f, max( entryDist.x, entryDist.y));\n    float earliestExit = min( len, min( exitDist.x, exitDist.y));\n    \n    // line segment inside the integration area\n    vec2 areaEntryPos = pa + latestEntry * dir;\n    vec2 areaExitPos = pa + earliestExit * dir;\n    \n    areaEntryPos = max( areaMin, min( areaMax, areaEntryPos));\n    areaExitPos = max( areaMin, min( areaMax, areaExitPos));\n    \n    // XY: base +X vector, ZW: base +Y vector. Might turn out we only need the absolute\n    vec4 rotMatrix = ((dirSign.x * dirSign.y) < 0.0f ? vec4( 0, 1, -1, 0) : vec4( 1, 0, 0, 1)) * (dirSign.y < 0.0f ? -1.0f : 1.0f);\n    vec4 rotAbsMatrix = abs( rotMatrix);\n    \n    vec2 innerDir = areaExitPos - areaEntryPos;\n    float diagonalArea = abs( 0.5f * innerDir.x * innerDir.y);\n\n    float lowerBorder = dot( rotAbsMatrix.zw, dot( rotMatrix.zw, vec2( 1)) < 0.0f ? areaMax : areaMin);\n\tfloat areaBelow = abs(dot( rotAbsMatrix.zw, areaEntryPos) - lowerBorder) * dot( rotMatrix.xy, innerDir);\n    \n    float rightBorder = dot( rotAbsMatrix.xy, dot( rotMatrix.xy, vec2( 1)) < 0.0f ? areaMin : areaMax);\n    float areaRight = max( 0.0f, (dirSign.y < 0.0f ? -1.0f : 1.0f) * (rightBorder - dot( rotAbsMatrix.xy, areaExitPos))) \n        \t\t\t* max( 0.0f, dot( rotAbsMatrix.zw, areaMax - areaMin));\n\n    return (diagonalArea + areaBelow + areaRight) / (rectSize.x * rectSize.y);\n}\n\nvec3 triangleIntegral( vec2 pa, vec2 pb, vec2 pc, vec2 rectMin, vec2 rectMax)\n{\n    float edge1 = edgeIntegral( pa, pb, rectMin, rectMax);\n//    float edge2 = edgeIntegral( pc, pa, rectMin, rectMax);\n    \n    vec3 demoColour = edge1 * vec3( 0.0f, 1.0f, 0.0f);\n    return demoColour;\n}\n\nfloat drawEdge( in vec2 fragCoord, in vec2 pa, in vec2 pb)\n{\n    vec2 edgeMin = min( pa, pb), edgeMax = max( pa, pb);\n    vec2 dirToPb = normalize( pb - pa);\n    vec2 orthoToPb = vec2( 1, -1) * dirToPb.yx;\n    \n    float dist = dot(fragCoord.xy - pa, orthoToPb);\n    \n\tdist = (fragCoord.x >= edgeMin.x && fragCoord.y >= edgeMin.y && fragCoord.x <= edgeMax.x && fragCoord.y <= edgeMax.y) ? dist : 0.0f;\n    \n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    // construct an edge from some point at the left and some angle\n    vec2 pa = vec2( iMouse.x, iMouse.y);\n    float angleToPb = 8.0f * (iMouse.x / iResolution.x - 0.5f);\n    vec2 dirToPb = vec2( cos( angleToPb), -sin( angleToPb));\n    vec2 pb = pa + 0.6f * iResolution.x * dirToPb;\n\n    float angleToPc = angleToPb + 0.6f;\n    vec2 dirToPc = vec2( cos( angleToPc), -sin( angleToPc));\n    vec2 pc = pa + 0.4f * iResolution.x * dirToPc;\n    \n    // a grid of rectangles\n    ivec2 gridpos = ivec2(fragCoord.xy / GridSize);\n    vec2 rectMin = vec2( gridpos) * GridSize;\n    vec2 rectMax = rectMin + vec2( GridSize, GridSize);   \n    vec3 tri = triangleIntegral( pa, pb, pc, rectMin, rectMax);\n    \n    float edge1 = clamp( 0.0f, 1.0f, drawEdge( fragCoord, pa, pb));\n    float allEdges = edge1;\n    vec3 gridColour = tri + vec3( 0, 0, clamp( 0.0f, 1.0f, allEdges));\n    \n    fragColor = vec4( gridColour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcRw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[31, 31, 98, 98, 2155], [2157, 2157, 2236, 2236, 2441], [2443, 2443, 2503, 2503, 2868], [2870, 2870, 2926, 2994, 3837]], "test": "untested"}
{"id": "WtSczm", "name": "Mandelbrot Trillion-Fold Zoom", "author": "dr2", "description": "Deep zoom (x10^12) into Mandelbrot set using double-precision emulation  (single-precision is limited to about 10^5). See source for activation.", "tags": ["fractal", "precision"], "likes": 7, "viewed": 978, "published": 3, "date": "1593946888", "time_retrieved": "2024-07-30T20:57:17.515145", "image_code": "// \"Mandelbrot Trillion-Fold Zoom\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n Deep zoom (x10^12) into Mandelbrot set using double-precision emulation\n (single-precision is limited to about 10^5).\n 3 color modes (Julia version coming soon)\n*/\n\n#define DP_VERS  0   // NOTE: must change 0->1 for this to work (not by default) !!!\n\n#define AA       0   // set = 1 for antialiasing (recommended)\n\n/*\n Based on an (interactive) CUDA-GPU learning exercise from the distant past.\n\n Double-precision emulation in software:\n \n Some of the earlier web reference material has disappeared.\n Discussion in blog.hvidtfeldts.net/index.php/2012/07/double-precision-in-opengl-and-webgl.\n Code available at hvidtfeldts.net/WebGL-DP/webgl.html.\n Double emulation based on GLSL Mandelbrot Shader by Thasler (www.thasler.org/blog - gone!).\n Also appears in NVIDIA CUDA Mandelbrot example.\n Modified code to prevent GLSL compiler screwup: LMLB / Mandelbrot WebGL Example (Syntopia 2012).htm.\n Idea goes back to Knuth, Dekker and others; survey in andrewthall.org/papers/df64_qf128.pdf.\n Emulation originated with Fortran-90 double-single package by Bailey (crd.lbl.gov/~dhbailey/mpdist -\n gone/redirected, no mention on new website).\n\n Software emulated dp can be faster than hardware dp - depends on GPU (emulated dp Mandelbrot\n using CUDA on Quadro P4000 is 1.5-2x faster than hw dp).\n (Note: Quadro P4000 dp hardware is nominally 1/32x speed of sp; contrast with Tesla K20 where\n it is 1/2x-1/3x.)\n\n \"Do-nothing\" functions are used prevent GLSL compiler destructively rearranging code;\n used only where needed, unlike LMLB version which uses them for all ops (CUDA version of\n program doesn't need them - Linux NVIDIA driver 384.130).\n\n Apparently even this trick is not enough for some compilers - see below.\n This could probably be simplified but I have no machine for testing.\n\n Scale factor is shown (log of value).\n*/\n\n#define VAR_ZERO min (nFrame, 0)\n\nvec2 Rot2D (vec2 q, float a);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 HsvToRgb (vec3 c);\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val);\n\nint nFrame;\nfloat nFrameF, scale, sclTarg, frmCyc;\nconst float pi = 3.1415927;\n\n#if DP_VERS\n\n#define GOOD_FP  0   // set = 1 if the GLSL compiler behaves (else just get sp results)\n    \n#if ! GOOD_FP \n\nfloat nFrameF1, nFrameF2, nFrameF3;\n\n#define VAR_ZERO1 min (nFrameF1, 0.)  // following iq's suggestion\n#define VAR_ZERO2 min (nFrameF2, 0.)\n#define VAR_ZERO3 min (nFrameF3, 0.)\n\nfloat FFAdd (float a, float b) \n{\n  return mix (a, a + b, (b != 0.) ? 1. : VAR_ZERO1);\n}\n\nfloat FFSub (float a, float b)\n{\n  return mix (a, a - b, (b != 0.) ? 1. : VAR_ZERO2);\n}\n\nfloat FFSub2 (float a, float b)\n{\n  return mix (a, a - b, (b != 0.) ? 1. : VAR_ZERO3);\n}\n\n#endif\n\nvec2 DvFromF (float a)\n{\n  return vec2 (a, 0.);\n}\n\nvec2 DvAdd (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if GOOD_FP\n  t1 = va.x + vb.x;\n  e = t1 - va.x;\n  t2 = ((vb.x - e) + (va.x - (t1 - e))) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x + vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (vb.x, e), va.x - FFSub2 (t1, e)) + va.y + vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\nvec2 DvSub (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float t1, t2, e;\n#if GOOD_FP\n  t1 = va.x - vb.x;\n  e = t1 - va.x;\n  t2 = ((- vb.x - e) + (va.x - (t1 - e))) + va.y - vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  t1 = va.x - vb.x;\n  e = FFSub (t1, va.x);\n  t2 = FFAdd (FFSub (- vb.x, e), va.x - FFSub2 (t1, e)) + va.y - vb.y;\n  vc.x = t1 - t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#define DSPLIT 8193.\n\nvec2 DvMul (vec2 va, vec2 vb)\n{\n  vec2 vc;\n  float ma, mb, sa1, sa2, sb1, sb2, c1, c2, t, t1, t2, e;\n#if GOOD_FP\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = ma - (ma - va.x);\n  sb1 = mb - (mb - vb.x);\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = t1 - c1;\n  t2 = ((c2 - e) + (c1 - (t1 - e))) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - (vc.x - t1);\n#else\n  ma = va.x * DSPLIT;\n  mb = vb.x * DSPLIT;\n  sa1 = FFSub (ma, FFSub2 (ma, va.x));\n  sb1 = FFSub (mb, FFSub2 (mb, vb.x));\n  sa2 = va.x - sa1;\n  sb2 = vb.x - sb1;\n  c1 = va.x * vb.x;\n  c2 = va.x * vb.y + va.y * vb.x;\n  t = (((sa1 * sb1 - c1) + sa1 * sb2) + sa2 * sb1) + sa2 * sb2;\n  t1 = c1 + c2;\n  e = FFSub (t1, c1);\n  t2 = FFAdd (FFSub (c2, e), c1 - FFSub2 (t1, e)) + t + va.y * vb.y;\n  vc.x = t1 + t2;\n  vc.y = t2 - FFSub (vc.x, t1);\n#endif\n  return vc;\n}\n\n#endif // DP_VERS\n\nvec3 ShowScene (vec2 uv)\n{\n  vec3 col;\n  float ns, w, colTyp;\n#if DP_VERS\n  vec2 xMidv, yMidv, x, y, xx, yy, cx, cy, s;\n#else\n  float xMid, yMid, x, y, xx, yy, cx, cy, s;\n#endif\n#if DP_VERS\n  xMidv = vec2 (-1.2499080e+07 / (4096. * 4096.), 6.40919e-09); // (externally) converted values\n  yMidv = vec2 (2.2692490e+06 / (4096. * 4096.),  4.4428e-08);\n  const float nsMax = 8192.;\n#else\n  xMid = -7.45003217010e-01; // original values (extra precision for conversion)\n  yMid = 1.35257824980e-01;\n  const float nsMax = 1024.;\n#endif\n  colTyp = floor (mod (float (nFrame) / frmCyc, 3.));\n#if DP_VERS\n  cx = DvAdd (DvMul (DvFromF (uv.x), DvFromF (scale)), xMidv);\n  cy = DvAdd (DvMul (DvFromF (uv.y), DvFromF (scale)), yMidv);\n  w = (cx.x + 0.25) * (cx.x + 0.25) + cy.x * cy.x;\n  x = DvFromF (0.);\n  y = DvFromF (0.);\n#else\n  cx = uv.x * scale + xMid;\n  cy = uv.y * scale + yMid;\n  w = (cx + 0.25) * (cx + 0.25) + cy * cy;\n  x = 0.;\n  y = 0.;\n#endif\n  ns = 0.;\n  col = vec3 (0.);\n  if (w > 0.25) {\n    for (float n = float (VAR_ZERO); n < nsMax; n ++) {\n      ++ ns;\n      if (scale > 0.02 && n > 512.) break; // reduced initial iterations\n#if DP_VERS\n      xx = DvMul (x, x);\n      yy = DvMul (y, y);\n      y = DvMul (x, y);\n      y = DvAdd (DvAdd (y, y), cy);\n      x = DvAdd (DvSub (xx, yy), cx);\n      s = DvAdd (xx, yy);\n      if (s.x + s.y > 256. * 256.) break;\n#else\n      xx = x * x;\n      yy = y * y;\n      y = 2. * x * y + cy;\n      x = xx - yy + cx;\n      s = xx + yy;\n      if (s > 256. * 256.) break;\n#endif\n    }\n    if (ns < nsMax - 1.) {\n#if DP_VERS\n      ns -= log2 (log2 (s.x + s.y)) - 4.;  // see iq's article on color smoothing \n#else\n      ns -= log2 (log2 (s)) - 4.;\n#endif\n      if (colTyp == 0.) col = HsvToRgb (vec3 (mod (ns / 512., 1.), 1., 1.));\n      else if (colTyp == 1.) col = 0.55 + 0.45 * cos (3. + vec3 (0., 0.5, 1.) + 0.15 * ns);\n      else if (colTyp == 2.) col = HsvToRgb (vec3 (mod (0.5 * log2 (ns) +\n         mod (4. * float (nFrame) / frmCyc, 1.), 1.), 1., 1.));\n    }\n  }\n  return col;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  vec3 col;\n  vec2 canvas, uv, uvv;\n  float asp, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  nFrame = iFrame;\n  asp = canvas.x / canvas.y;\n  nFrameF = float (nFrame);\n#if DP_VERS\n#if ! GOOD_FP \n  nFrameF1 = float (nFrame + 1);\n  nFrameF2 = nFrameF1 - 0.1;\n  nFrameF3 = nFrameF1 - 0.2;\n#endif\n#endif\n  frmCyc = 3000.;\n#if DP_VERS\n  sclTarg = 1e-12;\n#else\n  sclTarg = 3e-6;\n#endif\n  scale = 2. * pow (sclTarg, SmoothBump (0.25, 0.75, 0.23, mod (nFrameF / frmCyc, 1.)));\n  if (abs (uv.x) < 1.) {\n#if ! AA\n    const float naa = 1.;\n#else\n    const float naa = 3.;\n#endif  \n    col = vec3 (0.);\n    sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n    for (float a = float (VAR_ZERO); a < naa; a ++) {\n      uvv = uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi);\n      col += (1. / naa) * ShowScene (uvv);\n    }\n  } else col = vec3 (0.82);\n  col = mix (col, vec3 (0., 0., 0.5), ShowInt (0.5 * uv - vec2 (0.4 * asp, -0.4),\n     vec2 (0.06 * asp, 0.05), 2., floor (1. - log2 (scale) / log2 (10.))));\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nfloat DigSeg (vec2 q)\n{\n  return (1. - smoothstep (0.13, 0.17, abs (q.x))) *\n     (1. - smoothstep (0.5, 0.57, abs (q.y)));\n}\n\n#define DSG(q) k = kk;  kk = k / 2;  if (kk * 2 != k) d += DigSeg (q)\n\nfloat ShowDig (vec2 q, int iv)\n{\n  float d;\n  int k, kk;\n  const vec2 vp = vec2 (0.5, 0.5), vm = vec2 (-0.5, 0.5), vo = vec2 (1., 0.);\n  if (iv == -1) k = 8;\n  else if (iv < 2) k = (iv == 0) ? 119 : 36;\n  else if (iv < 4) k = (iv == 2) ? 93 : 109;\n  else if (iv < 6) k = (iv == 4) ? 46 : 107;\n  else if (iv < 8) k = (iv == 6) ? 122 : 37;\n  else             k = (iv == 8) ? 127 : 47;\n  q = (q - 0.5) * vec2 (1.8, 2.3);\n  d = 0.;\n  kk = k;\n  DSG (q.yx - vo);  DSG (q.xy - vp);  DSG (q.xy - vm);  DSG (q.yx);\n  DSG (q.xy + vm);  DSG (q.xy + vp);  DSG (q.yx + vo);\n  return d;\n}\n\nfloat ShowInt (vec2 q, vec2 cBox, float mxChar, float val)\n{\n  float nDig, idChar, s, sgn, v;\n  q = vec2 (- q.x, q.y) / cBox;\n  s = 0.;\n  if (min (q.x, q.y) >= 0. && max (q.x, q.y) < 1.) {\n    q.x *= mxChar;\n    sgn = sign (val);\n    val = abs (val);\n    nDig = (val > 0.) ? floor (max (log2 (val) / log2 (10.), 0.) + 0.001) + 1. : 1.;\n    idChar = mxChar - 1. - floor (q.x);\n    q.x = fract (q.x);\n    v = val / pow (10., mxChar - idChar - 1.);\n    if (idChar == mxChar - nDig - 1. && sgn < 0.) s = ShowDig (q, -1);\n    if (idChar >= mxChar - nDig) s = ShowDig (q, int (mod (floor (v), 10.)));\n  }\n  return s;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtSczm.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[4698, 4698, 4724, 4724, 6721], [6723, 6723, 6779, 6779, 7939], [7941, 7941, 7971, 7971, 8084], [8086, 8086, 8143, 8143, 8226], [8228, 8228, 8252, 8252, 8369], [8371, 8371, 8394, 8394, 8496], [8569, 8569, 8601, 8601, 9143], [9145, 9145, 9205, 9205, 9757]], "test": "untested"}
{"id": "tljyzD", "name": "Path", "author": "Arseny", "description": "Thanks to spalmer, who find cause of CE", "tags": ["procedural", "2d"], "likes": 1, "viewed": 282, "published": 3, "date": "1593944555", "time_retrieved": "2024-07-30T20:57:18.500510", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 col = texture(iChannel0, uv);\n    //fragColor = vec4(col.rgb, 1.);\n    fragColor = col;\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define eps (0.003)\n\n\n#define red (vec4(1., 0., 0., 1.))\n#define green (vec4(0., 1., 0., 1.))\n#define blue (vec4(0., 0., 1., 1.))\n#define pi (acos(-1.))\n\n\nfloat k = 2.; // chage scale\nfloat parts = 6.;\nfloat lineWidth = 0.02; // no more than 0.02 with k * parts > 8 else some artefacts\n\n//----------https://www.shadertoy.com/view/4djSRW\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n    p *= 532.152;\n    p += 50.;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n#define flr(x, a) (floor((x) * (a)) / (a))\n\n#define frct(x, a) (fract((x) * (a)) / (a))\n\nvec4 get(vec2 uv){\n    return texture(iChannel0, uv);\n}\n\nvec2 to01(vec2 uv){\n    return (uv * iResolution.y) / iResolution.xy / 2. + 0.5;\n}\n\nvec2 PathId(vec2 uv, vec2 pathType){\n    float ansy = flr(uv.y, parts * k);\n    float ansx = flr(uv.x + pathType.x * pathType.y * (uv.y - flr(uv.y, parts * k) - 0.5 / parts / k) / 2.41, parts * k );\n    ansy = flr(uv.y + pathType.y * pathType.x * (uv.x - flr(uv.x, parts * k) - 0.5 / parts / k) / 2.41, parts * k );\n    return vec2(ansx, ansy) * parts * k;\n}\n\nvec2 IdToCenter(vec2 id){\n    return (id + 0.5) / parts / k;\n    //return (id + vec2(id.y * 5. / 8.)) / parts / k;\n}\n\nvec2 IdToLeftCntr(vec2 id){\n    return (id + vec2(0., 0.5)) / parts / k;\n}\n\nbool lesseq(vec2 ida, vec2 idb){\n    return (ida.x <= idb.x && ida.y <= idb.y);\n}\n\nvec2 to(vec2 id, vec2 beg, vec2 end){\n    vec2 sz = abs(end - id);\n    vec2 pathType = sign(end - beg);\n    float edge = sz.x / (sz.x + sz.y);\n    float pathHash = hash12(vec2(hash12(beg), hash12(end)));\n    float dir = step(edge, hash12(vec2(pathHash, hash12(id) + floor(iTime / 2.) * 0.162)));\n    vec2 ans = (dir < 0.5) ? vec2(pathType.x, 0.) : vec2(0., pathType.y);\n    return ans;\n}\n\nbool is_good(vec2 id, vec2 beg, vec2 end){\n    return get(to01(IdToCenter(id))).a > 1. - eps;\n}\n\nfloat crs(vec2 a, vec2 b){\n    return a.x * b.y - a.y * b.x;\n}\n\n// https://iquilezles.org/articles/distfunctions\nvec4 sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n    vec2 pa = p - a, ba = b - a;\n    //float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float h = dot(pa,ba)/dot(ba,ba);\n    vec4 ans;\n    ans.z = 1. - length( pa - ba*h ) / r;\n    ans.y = length( pa - ba*h ) / r * sign(crs(pa, ba));\n    ans.x = h * length(ba) / r;\n    // temp\n    //ans.xy *= r;\n    ans.a = 1.;\n    return ans;\n}\n\nvec4 make_line(vec2 id, vec2 uv, vec2 from, vec2 to_){\n    vec2 cntr = IdToCenter(id);\n    //vec2 or = IdToLeftCntr(id);\n    //float hlf = (cntr - or).x;\n    float hlf = abs(IdToCenter(id).x - IdToCenter(id + from).x) / 2.;\n    vec2 beg = cntr + hlf * from;\n    vec2 end = cntr + hlf * to_;\n    vec4 tmp = sdCapsule(uv, beg, end, lineWidth);\n    //tmp.x += get(to01(beg + hlf * from * eps)).x;\n    //tmp.x = get(to01(beg)).a;\n    \n    //tmp.xy = beg + normalize(beg - end) * eps * 2.;\n    tmp.x /= 2.;\n    cntr = IdToCenter(id + from);\n    vec2 ch = cntr + to(id + from, beg, end) * (hlf - 0.005);\n    //tmp.x += get(to01(ch)).r + length(ch - beg);\n    tmp.xy = ch;\n    tmp.zw = beg;\n    return tmp;\n}\n\nvoid Path(in vec2 uv, in vec2 beg, in vec2 end, inout vec4 col){\n    vec2 pathType = sign(end - beg);\n    beg = PathId(beg, pathType);\n    end = PathId(end, pathType);\n    vec2 id = PathId(uv, pathType);\n    if (lesseq(id, max(end, beg)) && lesseq(min(end, beg), id)){\n        \n        vec2 from = vec2(0.);\n        vec2 checkId = id + vec2(-pathType.x, 0.);\n        bool hor = is_good(checkId, beg, end) && checkId + to(checkId, beg, end) == id;\n        from = (hor) ? vec2(-pathType.x, 0.) : from;\n        \n        checkId = id + vec2(0, -pathType.y);\n        bool ver = is_good(checkId, beg, end) && checkId + to(checkId, beg, end) == id;\n        from = (ver) ? vec2(0, -pathType.y) : from;\n        \n        col.a = (hor || ver) ? 1. : col.a;\n        \n        // making mask\n        vec4 line = (hor || ver) ? make_line(id, uv, from, to(id, beg, end)) : vec4(0.);\n        //col.rgb = (hor || ver) ? vec3(line.xx / 10., 0.) : col.rgb;\n        \n        //col.rgb = vec3(smoothstep(0., 0.01, length(line.xy * lineWidth)));\n        \n        //col = (hor || ver) ? vec4(vec3(length(line.xy - uv) < 0.03), float((hor || ver))) : col;\n        //line.x /= 10.;\n        col = (hor || ver) ? vec4(line.xxx / 2., line.w) : col;\n    }\n    vec2 cntr = IdToCenter(id);\n    vec2 or = IdToLeftCntr(id);\n    float hlf = (cntr - or).x;\n    vec4 tmp = sdCapsule(uv, cntr, cntr + hlf * to(id, beg, end), lineWidth);\n    tmp.z = (tmp.x < 0.) ? 0. : tmp.z;\n    //col.a = (id == beg) ? 1. : col.a;\n    col = (id == beg) ? vec4(tmp.xxx / 2., tmp.w) : col;\n    col = (length(tmp.xy - tmp.zw) > eps * 4.) ? vec4(0., 0., 1., 0.) : col;\n    //col = (length(tmp.zw - uv) < 0.3) ? vec4(0., 1., 0., 0.) : col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1 by y bx proportional)\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy)/iResolution.y * 2.;\n    vec4 col = vec4(0.);\n    float T = floor(iTime) / 20. * pi;\n    vec2 beg = vec2(cos(T), sin(T)) * 0.8;\n    vec2 end = vec2(cos(pi + T), sin(pi + T)) * 0.8;\n    \n    vec2 pathType = sign(end - beg);\n    vec2 id = PathId(uv, pathType);\n    col =  vec4(id / 10., 0., 0.);\n    Path(uv, beg, end, col);\n    //col.xyz = pow(col.xyz, vec3(0.4545)); // don't know how it works but gamma correction\n    fragColor = col;\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljyzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 200]], "test": "untested"}
{"id": "ttSczW", "name": "tinface", "author": "olli666", "description": "Process Web Camera image as if it were polished metal surface in desert landscape.", "tags": ["reflection", "camera", "metalsurface"], "likes": 4, "viewed": 748, "published": 3, "date": "1593940436", "time_retrieved": "2024-07-30T20:57:19.276436", "image_code": "// Process Web Camera image as reflective metal surface. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\n// - Buffer B averages the web camera image to reduce camera noise. This is non-critical step.\n// - Buffer A calculates normal vector from the camera image lightness gradient.\n// - The mainImage() renders image as if the camera picture were a polished reflective surface\n\nvec3 VEC_LIGHT1 = normalize(vec3(0.5, -0.5, -1));\n\nconst vec4 COLOR_SKY1 = vec4(0.0,0.1,1.0,0);\nconst vec4 COLOR_SKY2 = vec4(0.6,0.7,1.0,0);\nconst vec4 COLOR_GROUND2 = vec4(0.6,0.4,0.0,0);\nconst vec4 COLOR_GROUND1 = vec4(0.9,0.7,0.5,0);\n\n// Render simple background of sky and dunes\nvec4 background(in vec2 coord)\n{    \n    // to-do: smoothen boundary layer between horizon and sky\n    float h = 0.5+0.05*cos(8.0*coord.x) + 0.04*cos(13.0*coord.x);\n    if (coord.y < h) {\n        // ground\n        float c = 0.5*(1.0+cos(10.0*coord.x)+cos(25.0*coord.y+15.0*coord.x))*cos(20.0*coord.y-1.0*cos(10.0*coord.x)) + 1.0;\n        return mix(COLOR_GROUND1, COLOR_GROUND2,c*(h-coord.y));\n    } else {\n        // sky\n        return mix(COLOR_SKY1, COLOR_SKY2, 3.0*(1.0-coord.y));\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 dx = vec2(1.0, 0)/iChannelResolution[0].xy;\n    vec2 dy = vec2(0, 1.0)/iChannelResolution[0].xy;\n\n    // channel0 has normal vector calculated from camera image.\n    // filter the normal vector by -FILTER..FILTER square to\n    // create smoother surface\n    vec4 pix = vec4(0);\n    const int FILTER = 3;\n    for (int i = -FILTER; i <= FILTER; i ++) {\n        vec2 fi = float(i) * dy;\n        for (int j = -FILTER; j <= FILTER; j ++) {\n            vec2 fj = float(j) * dx;\n            pix += texture(iChannel0, uv + fj + fi);\n        }\n    }\n    const float ISCALE = 1.0/float((2*FILTER+1)*(2*FILTER+1));\n    pix *= ISCALE;\n\n    // calculate reflection vector\n    vec3 camera = normalize(vec3(0,0,-1));\n    vec3 normal = pix.xyz;\n    vec3 vreflect = normalize(reflect(camera, normal));\n      \n\t// apply a spotlight beam highlight:\n    float l1 = smoothstep(0.8, 1.0, dot(vreflect, -VEC_LIGHT1));\n    fragColor = 0.3 *vec4(l1);\n\n    // apply some of original camera image lighting\n    float cameraLight = 0.5*(1.0*texture(iChannel2, uv).a + 1.0*pix.a);\n   \tfragColor += 0.4*vec4(cameraLight);\n    \n\t// reflect background image:\n   \tfragColor += 0.6*background(uv + 3.0 * vreflect.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Calculate \"normal vector\" for camera image based on lightness gradient.\n// Stores the normal vector into result .xyz and pixel brigtness into .a\n//\n// Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\n\nconst float THIRDTH = 1.0/3.0;\nconst vec3 vec3THIRDTH = vec3(THIRDTH);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 dx = vec2(1.0, 0)/iChannelResolution[0].xy;\n    vec2 dy = vec2(0, 1.0)/iChannelResolution[0].xy;\n\n    // calculate brigthness gradient\n    vec4 ax = (texture(iChannel0, uv+dx) - texture(iChannel0, uv-dx));\n    vec4 ay = (texture(iChannel0, uv+dy) - texture(iChannel0, uv-dy));\n    \n    vec3 gradx = vec3(1.0,   0, dot(ax.rgb, vec3THIRDTH));\n    vec3 grady = vec3(  0, 1.0, dot(ay.rgb, vec3THIRDTH));\n\n    vec4 a = texture(iChannel0, uv);\n    float brightness = dot(a.rgb, vec3THIRDTH);\n    \n    fragColor = vec4(normalize(cross(gradx, grady)), brightness);\n}\n                     ", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Filter camera image to reduce noise. Written by Olli Parviainen\n// Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    fragColor = mix(texture(iChannel1, uv), texture(iChannel0, uv), 0.2);\n}\n", "buffer_b_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSczW.jpg", "access": "api", "license": "cc-by-nc-sa-4.0", "functions": [[681, 726, 758, 824, 1218], [1220, 1220, 1277, 1277, 2511]], "test": "untested"}
{"id": "WlBcRm", "name": "low poly box (0 triangles)", "author": "samzanemesis", "description": "@samzanemesis\ninspired by a gag chain from twitter\nbox intersection code from https://www.shadertoy.com/view/ld23DV", "tags": ["box", "lowpoly", "joke"], "likes": 2, "viewed": 413, "published": 3, "date": "1593935984", "time_retrieved": "2024-07-30T20:57:20.375498", "image_code": "// @samzanemesis\n// inspired by a gag chain from twitter\n// box intersection code from https://www.shadertoy.com/view/ld23DV\n\nfloat cubeTex[] = float[](\n0.35,0.35,0.35,0.35,0.35,0.35,0.35,0.35,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.5,0.5,0.5,0.5,0.35,0.5,\n0.5,0.35,0.35,0.35,0.35,0.35,0.35,0.5,\n0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,\n0.7,0.7,0.7,0.7,0.7,0.7,0.7,0.7);\n\n// https://iquilezles.org/articles/boxfunctions\nvec4 iBox( in vec3 ro, in vec3 rd, in mat4 txx, in mat4 txi, in vec3 rad ) \n{\n    // convert from ray to box space\n\tvec3 rdd = (txx*vec4(rd,0.0)).xyz;\n\tvec3 roo = (txx*vec4(ro,1.0)).xyz;\n\n\t// ray-box intersection in box space\n    vec3 m = 1.0/rdd;\n    vec3 n = m*roo;\n    vec3 k = abs(m)*rad;\n\t\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\tif( tN > tF || tF < 0.0) return vec4(-1.0);\n\n\tvec3 nor = -sign(rdd)*step(t1.yzx,t1.xyz)*step(t1.zxy,t1.xyz);\n\n    // convert to ray space\n\t\n\tnor = (txi * vec4(nor,0.0)).xyz;\n\n\treturn vec4( tN, nor );\n}\n\n\nmat4 rotationAxisAngle( vec3 v, float angle )\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\nmat4 translate( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,   y,   z,   1.0 );\n}\n\nfloat sampleCubeTexture(vec2 uv)\n{\n    uv += 0.3;\n    uv /= 0.6;\n    return cubeTex[int(uv.x*8.0) + ( int(uv.y*8.0) * 8 ) ];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n\n     // camera movement\t\n\tfloat an = 0.4*iTime;\n\tvec3 ro = vec3( 2.5*cos(an), 1.0, 2.5*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n    // rotate and translate box\t\n\tmat4 txi = translate( 0.0, 0.0, 0.0 ); \n    if(iMouse.w > 0.1)\n    {\n    \tmat4 rot = rotationAxisAngle( normalize(vec3(0.0,1.0,0.0)), -iMouse.x * 0.01 );\n    \trot *= rotationAxisAngle( normalize(vec3(1.0,0.0,0.0)), -iMouse.y * 0.01 );\n        txi*= rot;\n    }\n\tmat4 txx = inverse( txi );\n\n    // raytrace\n\tfloat tmin = 10000.0;\n\tvec3  nor = vec3(0.0);\n\tvec3  pos = vec3(0.0);\n\t\n\t// raytrace-plane\n\tfloat oid = 0.0;\n\tfloat h = (0.0-ro.y)/rd.y;\n\tif( h>0.0 ) \n\t{\n\t\tpos = ro + h*rd;\n        if( mod(pos.z,1.0) < 0.02 || mod(pos.x,1.0) < 0.02 )\n        {\n            tmin = h; \n            nor = vec3(0.0,1.0,0.0); \n            oid = 1.0;\n        }\n\t}\n\n\t// trace box\n\tvec3 box = vec3(0.3,0.3,0.3) ;\n\tvec4 res = iBox( ro, rd, txx, txi, box);\n\tif( res.x>0.0 && res.x<tmin )\n\t{\n\t\ttmin = res.x; \n\t\tnor = res.yzw;\n\t\toid = 2.0;\n\t}\n\n    // shading/lighting\t\n\tvec3 col = vec3(0.3);\n\tif( tmin<100.0 )\n\t{\n\t\tpos = ro + tmin*rd;\n\t\t\n        // Floor\n\t\tfloat occ = 1.0;\n\t\tfloat mate = 1.0;\n\t\tif( oid<1.5 ) // plane\n\t\t{\n\t\t    mate = 0.4;\n\t\t}\t\t\n\t\telse // box\n\t\t{\n            // recover box space data (we want to do shading in object space)\t\t\t\n\t\t    vec3 opos = (txx*vec4(pos,1.0)).xyz;\n\t\t\tvec3 onor = (txx*vec4(nor,0.0)).xyz;\n            mate = abs(onor.x)*sampleCubeTexture(opos.zy) + \n                   abs(onor.y)*0.5 + \n                   abs(onor.z)*sampleCubeTexture(opos.xy);\n\n\t\t}\n\t\t\n        // material * lighting\t\t\n\t\tcol = vec3(mate);\n\t}\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlBcRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[439, 487, 564, 601, 1119], [1122, 1122, 1169, 1169, 1569], [1571, 1571, 1616, 1616, 1732], [1862, 1862, 1919, 1919, 3840]], "test": "untested"}
{"id": "WtScRm", "name": "box nearest intersection 3D ", "author": "FabriceNeyret2", "description": "3D version of https://shadertoy.com/view/wtjyRW\ncamera in Z=0 plane. blue dots = box/plane intersections.\nGives closest positive ray-box intersection. Comment #44 for just that. Default =  BBox mode: d=0 inside.\nClick + drag mouse to chose ray start + dir", "tags": ["raytracing", "intersection", "mm", "bbox"], "likes": 14, "viewed": 676, "published": 3, "date": "1593930513", "time_retrieved": "2024-07-30T20:57:21.235199", "image_code": "// 3D version of \"box nearest intersection\"  https://shadertoy.com/view/wtjyRW\n\n#define CALCOUTPOINT 1   // 0 to trim (most of) the code for out point\n#define showOut ( CALCOUTPOINT > 0 && texelFetch(iChannel3,ivec2(32,2),0).x <= 0.)\n\n\nvec3  P = vec3(1.1, .3, -.2),                    // bounding box at P, axis X0,X1,X2\n     X0 = vec3(.3,0,0), X1 = vec3(0,.5,0) , X2 = vec3(0,0,.4);\nfloat a0 = 0.2, a1 = 0.3, a2 = 0.5;              // Bbox rotation\n#define rot(a) mat2(cos(a+vec4(0,-1.5708,1.5708,0)));\n#define rotBBox()                                           \\\n    X0.yz *= rot(a0); X1.yz *= rot(a0); X2.yz *= rot(a0);   \\\n    X0.xz *= rot(a1); X1.xz *= rot(a1); X2.xz *= rot(a1);   \\\n    X0.xy *= rot(a2); X1.xy *= rot(a2); X2.xy *= rot(a2);\n\n  #define proj(P) ( (P).xy )                      // flat projection\n//#define proj(P) ( 1.5* (P).xy / (2.+(P).z) )    // perspective projection\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec3 A,vec3 B, out vec3 Z0) {      // --- segment with disc ends: seamless distance to segment\n    float l = -A.z/(B-A).z;                           // hack: also show intersection with z=0.\n    Z0 = l>=0. && l<=1. ? mix(A,B,l) : vec3(0);\n    vec2 a = proj(A), b = proj(B);                    // 3D projection\n    p -= a, b -= a;                                   // --- classical 2D draw part\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\nvec3 z; float _d;\n#define line(u,a,b) ( _d = line(u,a,b,z), vec4(_d,z) )// hack to carry the z=0 plane information\n#define Min(v0,v1)  ( v0.x < v1.x ? v0 : v1 ) \n\n#define spot(P)    S( length( proj(P) - U ) -.01 )    // draw dot\n\n\n// --- v2. maybe a bit cheaper\nfloat intersect(vec3 C, vec3 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec3  L = vec3(length(X0), length(X1), length(X2) ), I; // box radii \n    mat3  F = mat3( X0/dot(X0,X0), X1/dot(X1,X1), X2/dot(X2,X2) );   // orthogonal normalized box frame\n    float d = 1e5, l;  _d=d;\n    \n    C = (C-P) * F;    D *= F;                         // to normalized coordinates in box frame\n    I = abs(C-.5); bool inside = max(I.x, max(I.y,I.z)) <= .5;\n    if ( inside && !showOut ) return 0.; // if inside the Bbox. Comment for box intersection\n    \n    // C+lD = 0|1 -> l = ( 0|1 - C ) / D    We want smallest positive l\n\n    // --- global _d stores the out point (attention, also used in line() ).\n#define test(i)                                                           \\\n    /* first, get the nearest positive per direction */                   \\\n    l =  D[i] > 0. ?  C[i] < 0. ? -C[i]   : C[i] < 1. ? 1.-C[i] : -1.     \\\n                   :  C[i] > 1. ? 1.-C[i] : C[i] > 0. ? -C[i]   :  1.;    \\\n    l /= D[i];                                                            \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */ \\\n    I = C+l*D;                                                            \\\n    if ( l > 0. && l < d                                                  \\\n         && I[(i+1)%3] >= 0. && I[(i+1)%3] <= 1.                          \\\n         && I[(i+2)%3] >= 0. && I[(i+2)%3] <= 1.                          \\\n       )  d = l\n        \n    test(0); // test in each directions\n    test(1);\n    test(2);\n#if CALCOUTPOINT                // delete if not interested in out point\n    if (showOut) {\n#define testO(i)                                                          \\\n    /* first, get the nearest positive per direction */                   \\\n    l =  D[i] > 0. ?  C[i] < 1. ? 1.-C[i] : -1.                           \\\n                   :  C[i] > 0. ? -C[i]   :  1.;                          \\\n    l /= D[i];                                                            \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */ \\\n    I = C+l*D;                                                            \\\n    if ( l > 0.   && l < _d                                               \\\n         && I[(i+1)%3] >= 0. && I[(i+1)%3] <= 1.                          \\\n         && I[(i+2)%3] >= 0. && I[(i+2)%3] <= 1.                          \\\n       ) _d = l\n        \n    testO(0); // test in each directions\n    testO(1);\n    testO(2);\n    }\n    if (inside) _d = d, d = 0.;\n#endif\n    return d==1e5 ? -1. : d;  // global _d contains the out point\n}\n\n/* // --- first version ( costlier ? )\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) * / ), I; // box radii \n    mat2  F = mat2( X0/L.x, X1/L.y /* , X2/L.z * / ); // orthogonal unitary box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to box frame\n    // C+lD = 0|L -> l = ( 0|L - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction * /                        \\\n    l =  D[i] > 0. ?  C[i] < 0.   ? -C[i]     : C[i] < L[i] ? L[i]-C[i] : -1.  \\\n                   :  C[i] > L[i] ? L[i]-C[i] : C[i] > 0.   ? -C[i]     :  1.; \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box * /      \\\n    I = C+l*D;                                                                 \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^   * /                   \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] * /                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n // test(2);\n    return d==1e5 ? -1. : d;\n}\n*/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y,\n         M1 = iMouse.xy/R.y,\n         M0 = iMouse.zw/R.y, \n         D2 = normalize(M1-M0);\n    if (M1==vec2(0)) M1 = vec2(.4);\n    if (M0.x<=0.) M0 = M1, D2 = cos(iTime+vec2(0,11)), M1=M0+.2*D2;   \n    \n    vec3 C = vec3(M0,0), D = normalize(vec3(D2,0));          // setup camera\n    rotBBox();                                               // setup Bbox\n    \n    vec4 d ,bg; d.x = 1e5;\n    vec3 p = P;\n    d = Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ), // draw box\n              Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n            );\n    p += X2;\n    d = Min( d,\n       (bg = Min ( Min ( line(U,p,p+X0),  line(U,p+X0,p+X0+X1) ),\n                   Min ( line(U,p,p+X1),  line(U,p+X1,p+X0+X1) ) \n          )      ));\n    p = P;\n    d = Min( d,\n             Min ( Min ( line(U,p+X0,p+X0+X2),  line(U,p,p+X2) ),\n                   Min ( line(U,p+X1,p+X1+X2),  line(U,p+X0+X1,p+X0+X1+X2) ) \n          )      );\n    O = vec4( S(d.x) ) * (d==bg?.5:1.);                      // draw the line\n    if (length(d.yzw)!=0.) O.b +=  spot( d.yzw );            // blue spot at intersection with Z=0 plane\n  \n    O.r += spot(C);\n    O.r += S( line(U, C, C+9.*D).x );                        // draw cam\n    \n    float l = intersect( C, D );                             // shortest distance or -1.\n    if (l>=0.) \n        O.g += spot( C + l*D );                              // draw hit point ( if exist )\n    if (showOut && _d<1e5)\n        O.g += .5*spot( C + _d*D );\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtScRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[965, 965, 1013, 1078, 1528], [6032, 6032, 6070, 6070, 7592]], "test": "untested"}
{"id": "wlfyWs", "name": "Golden Fractal ", "author": "Pairtial", "description": "Based on @evvvvil's work ", "tags": ["fracta", "gold", "pairtial"], "likes": 0, "viewed": 244, "published": 3, "date": "1593926413", "time_retrieved": "2024-07-30T20:57:22.146761", "image_code": "//Originally created by https://www.twitch.tv/evvvvil_ https://www.shadertoy.com/user/evvvvil\n\n\nvec2 z,v,e=vec2(.000035,-.000035);float t,tt,b,g,g2,bb; vec3 np,bp,pp,po,no,al,ld;//global vars. The city of Norwich, pronounced \"shit-hole\", will be the butt of today's jokes. \nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);} //box primitive function // Norwich is the capital of middle class England and home to 142000 boring cyclists.\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));} //rotate function // People from Norwich actually live in London, they can be found near Bethnal Green, pricing out the locals with their East-Anglian petro Dollars.\nvec2 fb( vec3 p, float m)\n{ \n  p.y+=bb*.05; //Make those pesky blue lines dash at the top of the fractal. Racing like art students offended by the lack of houmous served on Norwich university campuses.\n  vec2 h,t=vec2(bo(p,vec3(35,31,33)),3); //Blue box base, East Anglia's finest shape since Allan Partridge's striped ties.\n  t.x=max(t.x,-(length(p)-1.5)); //Dig fucking hole in box base, because sanctions against the city of Norwich for breeding hipsters should be debated in parliament.\n  t.x=max(abs(t.x)-.6,(p.y-6.4));  //Onion trick + cut that shit with horizontal plane . \n  h=vec2(bo(p,vec3(9,1,2.9)),6);  //Another fucking box this time white. Nothing exciting, neither here nor in Norwich. \n  h.x=max(h.x,-(length(p)-2.5)); //Dig another fucking hole, this time in the white box. \n  h.x=max(abs(h.x)-.4,(p.y-5.4)); //Onion trick + cut that shit with horizontal plane.\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(p+vec3(0,0.4,0),vec3(5.4,0.4,3.4)),m); //Blue or orange box, material ID passwed in fb function call\n  h.x=max(h.x,-(length(p)-2.5)); //Bored of all this digging hole bullshit but had to be this way with the onion trick fucking with my drilling rig\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(p)-2.,m); //Finally, stick a ball in the hole (that's what she said)\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  t.x*=0.7; return t; //Tweak distance field to avoid artifact and return the whole shit\n}\nvec2 mp( vec3 p )\n{ \n  pp=bp=p; //Setup bullshit new postions pp and bp based on p,  \n  bp.yz=p.yz*=r2(sin(pp.x*.3-tt*.5)*.4); //add twist along z axis (due to line below bullshit x axis will become z axis. I know, dumb as fuck, but not as dumb as a vegetarian sausage)\n  p.yz*=r2(1.57);//This is some real bullshit, whoever thought it was a good fucking idea to rotate the whole fucking thing rather than flip variables in fb, is a fucking bell-end... Ah, yes, that would be me.\n  b=sin(pp.x*.7+tt); //Setup animation variable used all over the shop, you gotta punch the math in if you wanna wiggle\n  bb=cos(pp.x*.2+tt);//Setup animation variable used all over the shop, the opposite of above, sort of\n  p.x=mod(p.x-tt*2.,10.)-5.; //Modulo along z axis (x is now z, yeah I know, still dumb as fuck, but not as dumb as giving 2.5k fines to the homeless. Yeah I'm looking at you, Oxford, you cruel bastard.\n  vec4 np=vec4(p*.4,.4); //make new position np a vec4 for fractal so we can track the scale changes in the .w scalar and reuse that shit later to spank the distance field into shape to avoid artifact \n  for(int i=0;i<4;i++){ //\"Less is more\" when it comes to iterations, same could be said about prison time.\n    np.xyz=abs(np.xyz)-vec3(1,1.2,0); //Kaleidoscopic mandelbullshit\n    np.xyz = 2.*clamp(np.xyz, -vec3(0), vec3(2,0.,4.3+bb)) - np.xyz; //Adding the box in \"mandelbox\", thgankx to alkama for the help there\n    np=np*(1.3)/clamp(dot(np.xyz,np.xyz),0.1,.92); //each iter with scale and clamp the mess into beauty. Bit like rhinoplasty, but without the black eyes\n  }  \n  vec2 h,t=fb(abs(np.xyz)-vec3(2,0,0),5.);//Fuck it we still gonna abs symetry kaleidoscope that shit one more time for more details\n  t.x/=np.w; //Yeah that's where the trick is to render fractal without artifact by tweaking domain using the .w scaling scalar \n  t.x=max(t.x,bo(p,vec3(5,5,10))); //Contain the fractal within a box, cuts the sides a bit\n  np*=0.5; np.yz*=r2(.785); np.yz+=2.5; //reuse np fractal positions to create another bigger orange fractal on the side\n  h=fb(abs(np.xyz)-vec3(0,4.5,0),7.); //np on line above was scaled, rotated and shifted a bit, once again another abs symetry to increase amount of geom\n  h.x=max(h.x,-bo(p,vec3(25,5,5))); //remove inside bits of bigger orange fractal\n  h.x/=np.w*1.5; //Again trik to render fractal without artifact reusing .w scaling scalar\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(bo(np.xyz,vec3(3.0,b*10.,0.0)),3); //Mega glowy light sweeper is here broski, time to take your pants off and indulge.\n  h.x/=np.w*1.5; //Since we're using fractal position np again but this itme inside box, still we have to do the scaling scalar trick again to improve rendering\n  g2+=0.1/(0.1*h.x*h.x*(1000.-b*998.)); //Balkhan's super sick glow trick, with my added sweep along z axis hot sauce. Things are getting too fucking spicy for the pepper!\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(0.6*bp.y+sin(p.y*5.)*0.03,6); //Make a terrain out of a frilled horizontal plane, resue bp position to get the twist as well\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  h=vec2(length(cos(bp.xyz*.6+vec3(tt,tt,0)))+0.003,6); //Make it fucking rain sparkly little fucking particles. Because everything looks better when sprinkled with glitter, even Norwich city centre.\n  g+=0.1/(0.1*h.x*h.x*9000.); //Make the particle glow and pack the glow with that 4000\n  t=t.x<h.x?t:h; //Merge geometries while retaining material ID\n  return t;\n}\nvec2 tr( vec3 ro, vec3 rd ) // main trace / raycast / raymarching loop function \n{\n  vec2 h,t= vec2(7.1); //Near plane because when it all started the hipsters still lived in Norwich and they only wore tweed.\n  for(int i=0;i<728;i++){ //Main loop de loop \n    h=mp(ro+rd*t.x); //Marching forward like any good fascist army: without any care for culture theft. (get distance to geom)\n    if(h.x<.0001||t.x>140.) break; //conditional break we hit something or gone too far. Don't let the bastards break you down!\n    t.x+=h.x;t.y=h.y; //Huge step forward and remember material id. Let me hold the bottle of gin while you count the colours.\n  }\n  if(t.x>540.) t.y=0.;//If we've gone too far then we stop, you know, like Alexander The Great did when he realised he left his iPhone charger in Greece. (10 points whoever gets the reference)\n  return t;\n}\n#define a(d) clamp(mp(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )//2 lines above are a = ambient occlusion and s = sub surface scattering\n{\n  vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1); //get UVs, nothing fancy, \n  tt=mod(iTime,62.8318);  //Time variable, modulo'ed to avoid ugly artifact. Imagine moduloing your timeline, you would become a cry baby straight after dying a bitter old man. Christ, that's some fucking life you've lived, Steve.\n  vec3 ro=mix(vec3(1),vec3(-0.5,1,-1),ceil(sin(tt*.5)))*vec3(10,2.8+0.75*smoothstep(-1.5,1.5,1.5*cos(tt+0.2)),cos(tt*0.3)*3.1),//Ro=ray origin=camera position We build camera right here broski. Gotta be able to see, to peep through the keyhole.\n  cw=normalize(vec3(0)-ro), cu=normalize(cross(cw,normalize(vec3(0,1,0)))),cv=normalize(cross(cu,cw)),\n  rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;//rd=ray direction (where the camera is pointing), co=final color, fo=fog color\n  ld=normalize(vec3(.2,.4,-.3)); //ld=light direction\n  co=fo=vec3(8.3,3.7,1.32)-length(uv)*.1-rd.y*.2; //background is blueish with vignette and subtle vertical gradient based on ray direction y axis. It's dark like the heart of people from Norwich.\n  z=tr(ro,rd);t=z.x; //Trace the trace in the loop de loop. Sow those fucking ray seeds and reap them fucking pixels.\n  if(z.y>0.){ //Yeah we hit something, unlike you trying it with that mediocre looking waitress\n    po=ro+rd*t; //Get ray pos, know where you at, be where you is.\n    no=normalize(e.xyy*mp(po+e.xyy).x+e.yyx*mp(po+e.yyx).x+e.yxy*mp(po+e.yxy).x+e.xxx*mp(po+e.xxx).x); //Make some fucking normals. You do the maths while I count how many instances of Holly Willoughby there really is.\n    al=mix(vec3(0.1,18.2,5.4),vec3(0.1,0.4,.7),.5+0.5*sin(bp.y*7.)); //al=albedo=base color, by default it's a mix between blue/turquoise and darker blue. mix is done by reusing bp in a sin, weird I know but not as weird as Norwich's suburban dogging scene\n    if(z.y<5.) al=vec3(0); //material ID < 5 makes it black\n    if(z.y>5.) al=vec3(1); //material ID > 5 makes it white\n    if(z.y>6.) al=mix(vec3(1,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*7.)); //Material ID 7 gives us greadient orange -> red colour, again mixing between colours by reusing bp in a sin\n    float dif=max(0.,dot(no,ld)), //Dumb as fuck diffuse lighting\n    fr=pow(1.+dot(no,rd),4.), //Fr=fresnel which adds background reflections on edges to composite geometry better\n    sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.); //Sp=specular, stolen from Shane, below you will find: mix(vec3(.8),vec3(1),abs(rd))*al is a sick trick by crundle to tweak colour depending on ray direction\n    co=mix(sp+mix(vec3(.8),vec3(1),abs(rd))*al*(a(.1)*a(.2)+.2)*(dif+s(2.)),fo,min(fr,.2)); //Building the final lighting result, compressing the fuck outta everything above into an RGB shit sandwich\n    co=mix(fo,co,exp(-.0003*t*t*t)); //Fog soften things, but it won't stop failed art students from becoming dictators.\n  }\n  fragColor = vec4(pow(co+g*.2+g2*mix(vec3(1.,.5,0),vec3(.9,.3,.1),.5+.5*sin(bp.y*3.)),vec3(0.65)),1);// Naive gamma correction and glow applied at the end\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlfyWs.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 274, 298, 298, 339], [340, 451, 468, 468, 511], [512, 678, 705, 705, 2185], [2186, 2186, 2205, 2205, 5725], [5726, 5726, 5808, 5808, 6574], [6664, 6664, 6793, 6793, 9789]], "test": "untested"}
{"id": "3lByRm", "name": "Blurred div over video", "author": "Pairtial", "description": "Great effect for modern websites", "tags": ["video", "blur", "div", "content"], "likes": 4, "viewed": 354, "published": 3, "date": "1593926369", "time_retrieved": "2024-07-30T20:57:22.992500", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uvv = fragCoord/fragCoord;\n    //change uv.x > to uv.x < to invert the portion of the div\n    if(uv.x > (iResolution.y/iResolution.x)/(iResolution.x/iResolution.y)+(iResolution.y/iResolution.x)/(iResolution.x/iResolution.y)){\n        fragColor = vec4(texture( iChannel0, uv).xyz, 1.0);\n        return;\n    }\n\n    // Define the bluring radius/strength (direction independant)\n    vec2 radius = vec2(40.0);\n    // Calculate the value at the corners so that the matrix can be easily inverted\n    float max = sqrt(radius.x * radius.x + radius.y * radius.y);\n    // Define the variable which will hold the blured values\n    vec3 blur = vec3(0.0);\n\n    // Define the variable which will be used to normalize the image\n    float sum = 0.0;\n    // The kernel is dynamically created based on the bluring radius\n    for(float u = -radius.x; u<=radius.x; u++){\n        for(float v = -radius.y; v<=radius.y; v++){\n            // The pixel weight used by the kernel is defined as: the distance from the kernel origin (0,0)\n            // to the current kernel position, subtracted from the maximum possible distance. This leads\n            // to a gradient from 0% relative weight on the edges to 100% relative weight at the origin of the kernel\n            float weight = max - sqrt(u * u + v * v);\n            // The weight is then exponentialized which seams to sleightly maintain more of the origianl detail\n            //weight = pow(weight, 2.0);\n            // The weight is then multiplied by the texture being sampled and added to the overall blurred values\n            blur += weight * texture( iChannel0, uv + (vec2(u, v)/iResolution.xy)).xyz;\n            // The weight is then added for normalizing purposes\n            sum += weight;\n        }\n    }\n    // Finally the blurred image is normalized\n    blur /= sum;\n\n    // Output to screen\n    fragColor = vec4(blur , 0.0);\n}", "image_inputs": [{"id": 11, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByRm.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 2031]], "test": "untested"}
{"id": "WtByzw", "name": "Fractal foliage 3", "author": "jarble", "description": "What kind of forest is this?", "tags": ["3d", "raymarching", "fractal", "forest", "jungle"], "likes": 1, "viewed": 287, "published": 3, "date": "1593908666", "time_retrieved": "2024-07-30T20:57:23.775407", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 p){\n    vec3 a = p.zxy;\n    return (sin(a)+cos(a))*500.0;\n}\n\nfloat planet_surface(vec3 p){\n    p = (p + warp(p/1000.0))/size;\n    p = (sin(p.yzx*(cos(p)+sin(p.yxz))))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    p = sin(p/500000.0)*50000.0;\n\n    for(float i = 1.0; i < 9.0; i *= 3.0){\n        result += planet_surface(p*i)/(i*i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)+.5,sceneSDF(p),sceneSDF(p*10.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14+3.14*0.5);\n            viewDir.xz *= rot(-iMouse.x/iResolution.x*3.14*2.0+3.14);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtByzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[299, 299, 317, 317, 373], [375, 375, 404, 404, 517], [521, 521, 545, 545, 804], [806, 806, 834, 834, 948], [951, 1372, 1463, 1463, 1824], [1839, 2093, 2158, 2158, 2290], [2292, 2381, 2410, 2410, 2720], [2722, 3214, 3354, 3354, 3964], [3966, 4336, 4421, 4421, 4836], [4838, 5165, 5214, 5249, 5380], [5382, 5382, 5439, 5439, 6541]], "test": "untested"}
{"id": "3tByzw", "name": "Bouncing Marble", "author": "koo1ant", "description": "Trying out some transformation matrices + using SDFs to fake lighting and shadow/AO. \nThe marble has a specular and bottom reflection made with offset'd SDFs as well. \nGot here experimenting with fake 3D. There are probably better ways to do this.", "tags": ["3d", "checkerboard", "ball", "bounce", "marble", "flyby"], "likes": 14, "viewed": 809, "published": 3, "date": "1593908657", "time_retrieved": "2024-07-30T20:57:24.904388", "image_code": "#define t iTime\n#define resolution iResolution\n\nprecision highp float;\n\nmat4 rotX(in float angle) {\n    return mat4(\n        1, 0, 0, 0,\n        0, cos(angle), - sin(angle), 0,\n        0, sin(angle), cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nmat4 rotY(in float angle) {\n    return mat4(\n        cos(angle), 0, sin(angle), 0,\n        0, 1.0, 0, 0,\n        - sin(angle), 0, cos(angle), 0,\n    0, 0, 0, 1);\n}\n\nvec2 setupSpace(in vec2 f, in vec2 res)\n{\n    return\n    (f.xy / res.xy - 0.5) *\n    vec2(res.x / res.y, 1.0) * 2.0;\n}\n\nfloat sat(float v){\n    return clamp(v, 0.,1.);\n}\n\n// Fake a bouncing ball in screen-space UV\nvoid ball(inout float buf, vec2 uv, float phase, float radius, float bh) {\n    float bounce = abs(sin(t * 3.0 + phase)) * bh;\n    float bd = 1.00 + pow(abs(sin(t * 3.0 + 3.14 / 2.0 - 0.1 + phase)), 50.00) * 0.17;\n    float ballRadius = radius;\n    float shadowSize = abs(sin(t * 3.0 + phase)) * 1.00 + 1.00;\n    float a = atan(uv.y - bounce + 0.02, uv.x + -0.37);\n\n    // Shadow\n    float shadow = 1.0 - smoothstep(-0.5, 0.8, length(vec2(uv.x * (shadowSize*2.), uv.y * 1.75 * (shadowSize*2.)) - vec2(0.00, - 0.36)) - ballRadius + 0.0);\n    buf -= smoothstep(0.0, 0.8, shadow) * 0.8; // Soften the shadow a little bit\n\t\n    // Cut a hole in the buffer\n    buf *= step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius);\n\n    // Add specular\n    float mask = sat(1.0 - step(0.00, length(vec2(uv.x/bd, uv.y * bd) - vec2(0.01, bounce)) - ballRadius));\n    float impulse = sin(t*6.+1.20); // Spin a little faster when it hits the ground\n    float spin = sin(a * 18.0 + ((t * 12.0) + impulse)) * 0.03;\n    float specular = smoothstep(\n        0.30 + spin,\n        -0.02,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) *  mask +\n        // Fake reflection\n        smoothstep(\n            0.30 + sin(a * 18.0 + t*10.) * 0.03,\n            +0.52,\n        length(vec2(uv.x / bd, uv.y * bd) - vec2(0.02, bounce + 0.14)) - ballRadius + 0.23) * mask;;\n\n    buf += specular;\n}\n\nvoid ground(inout float p, vec2 uv) {\n    // Sine checkers\n    p += step(sin(uv.y * 10.00) * sin(t), sin(uv.x * 10.0));\n}\n\nvoid light(inout float p, vec2 pv){\n    vec2 lightPos = vec2(pv.x, pv.y);\n    p *= 1.-smoothstep(0.0, 10., length(lightPos - vec2(sin(t), 0.0)));\n}\n\nvoid projection(inout vec2 pv){\n\t vec4 m =\n        vec4(pv.x, pv.y, 0.00, 0.00) *\n        rotY(sin(t * 1.0) * 0.1) *\n        rotX(0.60) *\n        1.2 + 0.2;\n    \n    pv /= abs(0.8 - m.z);\n}\n\nvec4 image()\n{\n    vec2 pv = setupSpace(gl_FragCoord.xy, resolution.xy); // Perspective UV\n    vec2 uv = setupSpace(gl_FragCoord.xy, resolution.xy); // Screen-space UV\n    float camPos = t; // Camera speed\n    float p; // Image\n    \n   \tprojection(pv);\n    \n    pv.y += camPos;\n   \n    // Scene\n    ground(p, pv);\n    light(p, vec2(pv.x, pv.y - camPos));\n    ball(p, vec2(uv.x + 0.180 + sin(t*0.9+0.4)*0.1 , uv.y + -0.40), 1.00 , 0.18, 0.2);\n    \n    vec3 color = vec3(p);\n    color.r += 0.1;\n    color.b += 0.05;\n    \n    return vec4(color, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = image();\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByzw.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 99, 99, 233], [235, 235, 262, 262, 398], [400, 400, 441, 441, 518], [520, 520, 539, 539, 569], [571, 614, 688, 688, 2043], [2045, 2045, 2082, 2103, 2166], [2168, 2168, 2203, 2203, 2315], [2317, 2317, 2348, 2348, 2506], [2508, 2508, 2522, 2522, 3057], [3059, 3059, 3116, 3116, 3143]], "test": "untested"}
{"id": "ttjcRD", "name": "Corroded megastructure", "author": "jarble", "description": "This fractal resembles the ruins of a large corroded building, or the interior of a shipwreck.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "corrosion"], "likes": 2, "viewed": 298, "published": 3, "date": "1593891811", "time_retrieved": "2024-07-30T20:57:25.846869", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return (1.0+sin(vec3(sceneSDF(p/2.0),sceneSDF(p/3.0),sceneSDF(p))))/10.0+vec3(.5,.4,.4);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(depth+1.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01; //increase epsilon with each step\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat speed = 100.0;\n\tvec3 eye = vec3(-110.0,-180.0,iTime*speed);\n    vec3 p = depth_map(fragCoord);\n        vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n\nvec3 warp(vec3 p){\n    vec3 a = p.zxy;\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    //p = sin(p/500000.0)*500000.0;\n    //p += warp(p/500.0);\n    vec3 p1 = p/size;\n    p = (sin(sin(p1+cos(p1+warp(p1/size)*100.0))))*size;\n    return length(p)-size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= 3.0){\n        result += planet_surface(p*i)/(i);\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y))).xyz;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(depth+1.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01; //increase epsilon with each step\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(-iMouse.y/iResolution.y*3.14-3.14*0.5);\n        viewDir.xz *= rot(iMouse.x/iResolution.x*3.14*2.0-3.14);\n    }\n    \n    float speed = 100.0;\n\tvec3 eye = vec3(-110.0,-180.0,iTime*speed);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    vec3 dmap = depth_map(fragCoord);\n    float l0 = length(eye-dmap);\n\n    float l1 = texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w;\n    \n    float l2;\n    if(l0 > .9 && l1 > 0.0){\n        l2 = max(log(l0),0.0);\n    }\n    else{\n        l2 = l0;\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l2, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, (dist-l0)*.9);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[304, 304, 332, 332, 449], [452, 873, 964, 964, 1358], [1373, 1627, 1692, 1692, 1824], [1826, 1915, 1944, 1944, 2254], [2256, 2748, 2888, 2888, 3498], [3500, 3870, 3955, 3955, 4370], [4372, 4699, 4748, 4783, 4914], [4916, 4916, 4943, 4943, 5092], [5094, 5094, 5151, 5151, 5642]], "test": "untested"}
{"id": "wl2yRD", "name": "Color Warp", "author": "yozic", "description": "Inspired by https://www.shadertoy.com/view/MsyGRm", "tags": ["colorful", "psychedelic", "trippy"], "likes": 28, "viewed": 994, "published": 3, "date": "1593890174", "time_retrieved": "2024-07-30T20:57:26.692608", "image_code": "#define WARP true\n#define BALLS 10.\n#define CONTRAST 3\n#define GLOW .1\n#define ORB_SIZE 0.492519\n#define PI 3.14159265359\n\nvec2 kale(vec2 uv, vec2 offset, float splits) {\n  float angle = atan(uv.y, uv.x);\n  angle = ((angle / PI) + 1.0) * 0.5;\n  angle = mod(angle, 1.0 / splits) * splits;\n  angle = -abs(2.0 * angle - 1.0) + 1.0;\n  float y = length(uv);\n  angle = angle * (y);\n  return vec2(angle, y) - offset;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord) {\n  vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= 2.2;\n  fragColor = vec4(0.);\n  float dist = distance(uv, vec2(0.));\n  uv = WARP ? uv * kale(uv, vec2(0.), 2.) : uv;\n  for (float i = 0.; i < BALLS; i++) {\n    float t = iTime/2. - i * PI / BALLS * cos(iTime / max(i, 0.0001));\n    vec2 p = vec2(cos(t), sin(t)) / sin(i / BALLS * PI / dist + iTime);\n    vec3 c = cos(vec3(0, 5, -5) * PI * 2. / PI + PI * (iTime / (i+1.) / 5.)) * (GLOW) + (GLOW);\n    fragColor += vec4(vec3(dist * .35 / length(uv - p * ORB_SIZE) * c), 1.0);\n  }\n  fragColor.xyz = pow(fragColor.xyz, vec3(CONTRAST));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2yRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[123, 123, 170, 170, 411], [413, 413, 469, 469, 1098]], "test": "untested"}
{"id": "tt2czW", "name": "Bumpy fractal lattice", "author": "jarble", "description": "I modified the formula of my [url=https://www.shadertoy.com/view/tlByz1]\"Stalactites\"[/url] shader to make this lattice.\n\nThe resolution of the Z-buffer is defined in the \"Common\" tab.", "tags": ["3d", "raymarching", "fractal"], "likes": 2, "viewed": 367, "published": 3, "date": "1593887455", "time_retrieved": "2024-07-30T20:57:27.599183", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.01)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t/(4))|(t/8)/((t*2)%16)|t/1024|t/1024*5|t/1024*3;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 1000.0;\n    float factor = 1.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}\n// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\n/*\nvec2 sound1(int t,float factor)\n{\n    t = t%2000000;\n    t /= (t%(1000));\n    t = (t/8)*t>>((t))|(t/8);\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 80000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 2; i++){\n    \tresult += sound1(int(time*factor),factor)*factor;\n        factor /= 1.5;\n    }\n    return result/1000.0;\n}\n*/\n\n/*\n\n// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t/(2*2*2*2*2))*(t>>(24*(t/(2*2*2*2*2*2*2*2*2*2*2*2*2))))|(t>>(7+(t/(2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2*2))))|t/4;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 8000.0;\n    float factor = 1.5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 4; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 2.0;\n    }\n    return result/100.0;\n}\n*/", "sound_inputs": [], "common_code": "#define image_scale 4.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = 0.01; //to prevent rendering artifacts\n//change to 1.0 for high-quality\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p = (sin(sin(p1+cos(p1))))*size;\n    return length(p)-size;\n}\n\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        result += planet_surface(p*i)/(i);\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)+.5,sceneSDF(p),sceneSDF(p*10.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x), (coord.y))).xyz;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.01)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    //re-use the depth from the previous frame\n    vec3 dmap = depth_map(fragCoord);\n    \n    float l0 = length(eye-dmap);\n    \n    if(texture(iChannel0, vec2((fragCoord.x), (fragCoord.y))).w > .9){\n        l0 = 0.0; //avoid overstepping if the previous depth is too far away\n    }\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, abs(l0-dist)*.9);\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2czW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 480, 571, 571, 935], [951, 1040, 1069, 1069, 1379], [1381, 1873, 2013, 2013, 2623], [2625, 2995, 3080, 3080, 3495], [3497, 3497, 3524, 3524, 3673], [3675, 3675, 3732, 3732, 4269]], "test": "untested"}
{"id": "wt2yzW", "name": "first shader2333", "author": "James_Braga", "description": "tag", "tags": ["tag"], "likes": 1, "viewed": 367, "published": 3, "date": "1593884221", "time_retrieved": "2024-07-30T20:57:28.421984", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec3 conversion = vec3(255, 255, 255);\n    \n\tvec3 webcam_pixel = texture(iChannel0, p).rgb;\n\tvec3 noise_pixel = texture(iChannel1, p).rgb;\n\n    float gray_scale = dot(webcam_pixel, conversion);\n\n    if(gray_scale > .5) fragColor = vec4(webcam_pixel, 1);\n    else fragColor = vec4(noise_pixel, 1);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 402]], "test": "untested"}
{"id": "tljcRW", "name": "Feathers in the Wind", "author": "BigWIngs", "description": "The end result of a YouTube tutorial I made.", "tags": ["tutorial", "wind", "feather", "feathers", "artofcode"], "likes": 48, "viewed": 1487, "published": 3, "date": "1593881406", "time_retrieved": "2024-07-30T20:57:29.179957", "image_code": "// Feathers in the Wind - by Martijn Steinrucken aka BigWings 2020\n// Email:countfrolic@gmail.com Twitter:@The_ArtOfCode\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// An effect created for a YouTube tutorial. You can watch it here:\n// Part 1: https://youtu.be/68IFmCCy_AM\n// Part 2: https://youtu.be/hlM940IqpRU\n\n#define S smoothstep\n#define T (iTime*.5)\n\nmat2 Rot(float a) {\n\tfloat s=sin(a), c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat Feather(vec2 p) {\n\tfloat d = length(p-vec2(0,clamp(p.y, -.3, .3)));\n    float r = mix(.1, .03, S(-.3, .3, p.y));\n    float m = S(.01, .0, d-r);\n    \n    float side = sign(p.x);\n    float x = .9*abs(p.x)/r;\n    float wave = (1.-x)*sqrt(x) + x*(1.-sqrt(1.-x));\n    float y = (p.y-wave*.2)*80.+side*56.;\n    float id = floor(y+20.);\n    float n = fract(sin(id*564.32)*763.); \n    float shade = mix(.5, 1., n);\n    float strandLength = mix(.7, 1., fract(n*34.));\n    \n    float strand = S(.4, .0, abs( fract(y)-.5 )-.35);\n    strand *= S(.1,-.2, x-strandLength);\n    \n    d = length(p-vec2(0,clamp(p.y, -.45, .1)));\n    float stem = S(.01,.0, d+p.y*.025);\n    \n    return max(strand*m*shade, stem);\n}\n\nvec3 Transform(vec3 p, float angle) {\n\tp.xz *= Rot(angle);\n    p.xy *= Rot(angle*.7);\n    \n    return p;\n}\n\nvec4 FeatherBall(vec3 ro, vec3 rd, vec3 pos, float angle) {\n\t\n    vec4 col = vec4(0);\n    \n    float t = dot(pos-ro, rd);\n    vec3 p = ro + rd * t;\n    float y = length(pos-p);\n    \n    if(y<1.) {\n        float x = sqrt(1.-y*y);\n        vec3 pF = ro + rd * (t-x) - pos; // front intersection\n        float n = pF.y*.5+.5;\n        \n        pF = Transform(pF, angle);\n        vec2 uvF = vec2(atan(pF.x, pF.z), pF.y); // -pi<>pi, -1<>1\n        uvF *= vec2(.25,.5);\n        float f = Feather(uvF);\n        vec4 front = vec4(vec3(f), S(0., .6, f));\n        \n        front.rgb *= n*n;\n        \n        vec3 pB = ro + rd * (t+x) - pos; // back intersection\n        n = pB.y*.5+.5;\n        pB = Transform(pB, angle);\n        vec2 uvB = vec2(atan(pB.x, pB.z), pB.y); // -pi<>pi, -1<>1\n        uvB *= vec2(.25, .5);\n        float b = Feather(uvB);\n        vec4 back = vec4(vec3(b), S(0., .6, b));\n        back.rgb *= n*n;//*.5+.5;\n        \n    \tcol = mix(back, front, front.a);\n    }\n    col.rgb = sqrt(col.rgb);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 M = iMouse.xy/iResolution.xy -.5;\n    \n    vec3 bg = vec3(.2, .2, .7)*(uv.y+.5)*2.5;\n    bg += vec3(.8, .6, .4)*(-uv.y+.5);\n    \n    vec4 col = vec4(bg, 0);\n\t\n    vec3 ro = vec3(0,0,-3);\n    vec3 rd = normalize(vec3(uv, 1));\n   \n    for(float i=0.; i<1.; i+=1./80.) {\n        \n        float n = fract(sin(i*564.3)*4570.3);\n        float x = mix(-8., 8., fract(fract(n*10.)+T*.1))+M.x;\n        float y = mix(-2., 2., n)+M.y;\n        float z = mix(5., 0., i);\n        float a = T+i*563.34;\n        \n    \tvec4 feather = FeatherBall(ro, rd, vec3(x, y, z), a);\n        \n        feather.rgb = mix(bg, feather.rgb, mix(.3, 1., i));\n        feather.rgb = sqrt(feather.rgb);\n        \n        col = mix(col, feather, feather.a);\n    }\n    \n    col = pow(col, vec4(.4545)); // gamma correction\n    \n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tljcRW.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[403, 403, 422, 422, 478], [480, 480, 503, 503, 1182], [1184, 1184, 1221, 1221, 1290], [1292, 1292, 1351, 1351, 2317], [2319, 2319, 2376, 2376, 3252]], "test": "untested"}
{"id": "wtjcRW", "name": "Fractured", "author": "Oggbog", "description": "kaleidoscopic type thing with added swoosh", "tags": ["trig"], "likes": 1, "viewed": 255, "published": 3, "date": "1593880837", "time_retrieved": "2024-07-30T20:57:29.938927", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\t\n    uv += vec2(tan(mod(uv.x,uv.y)+iTime)/4.,sin(mod(uv.y,uv.x)+iTime)/2.);\n    \n    uv = fract(uv * 2.5)-.5;\n    float a = iTime*2.;\n    uv *= mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    \n    \n    float w = abs(sin(iTime*.5)/4.)+.2;\n    float s = step(uv.x,-w)-step(uv.x,w);\n    s *= step(uv.y,-w)-step(uv.y,w);\n    \n    vec3 col = vec3(s,s/4.,s/2.);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 515]], "test": "untested"}
{"id": "wtjyRW", "name": "box nearest intersection", "author": "FabriceNeyret2", "description": "Computes closest positive ray-box intersection, if exist.\nComment line 23 for just that. Default = BBox mode: d = 0 inside.\nClick + drag mouse to chose a ray start + dir.\n", "tags": ["raytracing", "intersection", "mm", "bbox"], "likes": 9, "viewed": 458, "published": 3, "date": "1593877944", "time_retrieved": "2024-07-30T20:57:30.697898", "image_code": "const float r0 = .3, r1 = .5 /* , r2 */;\nconst vec2  P = vec2(1.1,.3),                        // bounding box at P, axis X0,X1\n      A = cos( -.5 + vec2(0,1.57) ),                 // ex: defined by angle -> frame <A,Aortho> \n     X0 = r0*A, X1 = r1*vec2(-A.y,A.x) /* , X2 */;   // axis X0,X1\n\n#define S(d) smoothstep( 1.5/R.y, 0., d )     // --- draw antialiased\nfloat line(vec2 p, vec2 a,vec2 b) {           // --- segment with disc ends: seamless distance to segment\n    p -= a, b -= a;\n    float h = clamp(dot(p, b) / dot(b, b), 0., 1.);   // proj coord on line\n    return length(p - b * h);                         // dist to segment\n}\n\n#define spot(P)  S( length( P - U ) -.01 )            // draw dot\n\n// --- v2. maybe a bit cheaper\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) */ ), I; // box radii \n    mat2  F = mat2( X0/dot(X0,X0), X1/dot(X1,X1) /* , X2/dot(X2,X2) */ );   // orthogonal normalized box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to normalized coordinates in box frame\n    I = abs(C-.5); if ( /*max(I.z,*/ max(I.x,I.y) <=.5 ) return 0.; // if inside the Bbox. Comment for box intersection\n    // C+lD = 0|1 -> l = ( 0|1 - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction */                        \\\n    l =  D[i] > 0. ?  C[i] < 0. ? -C[i]   : C[i] < 1. ? 1.-C[i] : -1.          \\\n                   :  C[i] > 1. ? 1.-C[i] : C[i] > 0. ? -C[i]   :  1.;         \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box */      \\\n    I = (C+l*D)*L;                                                             \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^     */                 \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] */                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); */\n    return d==1e5 ? -1. : d;\n}\n\n/* // --- first version ( costlier ? )\nfloat intersect(vec2 C, vec2 D) {                     // --- camera, direction. Return closest hit or -1\n    // you probably want to precompute these 2 : \n    vec2  L = vec2(length(X0), length(X1) /* , length(X2) * / ), I; // box radii \n    mat2  F = mat2( X0/L.x, X1/L.y /* , X2/L.z * / ); // orthogonal unitary box frame\n    float d = 1e5, l;\n    \n    C = (C-P) * F;    D *= F;                         // to box frame\n    // C+lD = 0|L -> l = ( 0|L - C ) / D    We want smallest positive l\n\n#define test(i)                                                                \\\n    /* first, get the nearest positive per direction * /                        \\\n    l =  D[i] > 0. ?  C[i] < 0.   ? -C[i]     : C[i] < L[i] ? L[i]-C[i] : -1.  \\\n                   :  C[i] > L[i] ? L[i]-C[i] : C[i] > 0.   ? -C[i]     :  1.; \\\n    l /= D[i];                                                                 \\\n    /* second, takes the min l>0 such that C+lD fits is inside the box * /      \\\n    I = C+l*D;                                                                 \\\n    if ( l > 0. &&  l < d                                                      \\\n         && I[(i+1)%2] >= 0. && I[(i+1)%2] <= L[(i+1)%2]                       \\\n                /*  ^     3 in 3D       ^             ^    * /                  \\\n      /* && I[(i+2)%3] >= 0. && I[(i+2)%3] <= L[(i+2)%3] * /                    \\\n       ) d = l\n        \n    test(0); // test in each directions\n    test(1);\n /* test(2); * /\n    return d==1e5 ? -1. : d;\n}\n*/\n    \nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy,\n          U = u/R.y,\n         M1 = iMouse.xy/R.y,\n         M0 = iMouse.zw/R.y, C = M0,\n          D = normalize(M1-M0);\n    if (M1==vec2(0)) M1 = vec2(.4);\n    if (M0.x<=0.) C = M1, D = cos(iTime+vec2(0,11)), M1=M0+.2*D;     \n    O-=O;\n    O += S( min ( min ( line(U,P,P+X0),  line(U,P+X0,P+X0+X1) ), // draw box\n                  min ( line(U,P+X1,P),  line(U,P+X0+X1,P+X1) ) \n          )     );\n\n    if (D == vec2(0)) return;   \n    O.r += spot(C);\n    O.r += S( line(U, C, C+D ) );              // draw cam\n    \n    float d = intersect( C, D );               // shortest distance or -1.\n    if (d<0.) return;\n    \n    O.g += spot( C + d*D );                    // draw hit point ( if exist )\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjyRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[363, 363, 398, 468, 639], [3978, 3978, 4016, 4016, 4742]], "test": "untested"}
{"id": "3tsyWl", "name": "BoS - Shaping Functions Table", "author": "zeta", "description": "Recreating [url]https://thebookofshaders.com/05/kynd.png[/url]\nTODO:\n- add little movement indicators like https://easings.net/\n- fix proportions, plot tiles should be squares.", "tags": ["2d", "bookofshaders", "shapingfunctions"], "likes": 13, "viewed": 490, "published": 3, "date": "1593875479", "time_retrieved": "2024-07-30T20:57:31.452880", "image_code": "// Fork of \"BoS - Shaping Functions Exercise\" by zeta. https://shadertoy.com/view/3lfyR4\n// 2020-06-29 11:30:30\n\n\n#define plot_thickness 3.0\n\n// Thanks FabriceNeyret2 for suggesting these (see comments).\n#define plot_var(uv, pct, n, var)     smoothstep(plot_thickness*(n_tiles/R).var, 0., abs(uv.var-(pct)))\n#define plot_y(uv, pct, n)            plot_var(uv, pct, n, y)\n#define plot_x(uv, pct, n)            plot_var(uv, pct, n, x)\n#define tiles(uv, n_tiles)            fract(uv * n_tiles)\n#define put(shape, color, bg)         mix(bg, color, shape)\n\n\nconst float PI = 3.14159265359;\n\nconst float[] prms = float[](0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5);\n\n\nconst vec3\n    paper_color = vec3(215,210,154) / 255.,\n    axes_color = vec3(.7);\n\n\n// https://stackoverflow.com/a/17897228\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n\nvoid mainImage(out vec4 O, in vec2 fc)\n{\n    vec2 R = iResolution.xy;\n    vec2 uv = fc / R.xy;\n    vec3 color = paper_color;\n\n    // Number of functions we want to plot.\n    // Make sure to update this number when adding or removing functions.\n\tfloat n_funs = 5.0;\n    // Number of parametrizations to plot for each function.\n    float n_prms = float(prms.length());\n    \n    // Fit variations of the same function horizontally and different functions vertically.\n    vec2 n_tiles = vec2(n_prms, n_funs);\n    vec2 tile_size = R.xy / n_tiles.xy;\n    \n    // Create a tiled space for function plots.\n    vec2 ts = tiles(uv, n_tiles);\n    \n    // Plot functions on range x = [-1, 1] and y = [0, 1] as in the original image,\n    // plus some margin space.\n    float a = 2.7;\n    ts.x = a * ts.x - a / 2.0;\n    ts.y = a * ts.y - a / 3.0;\n        \n    // Find out which tile this pixel belongs to.\n    vec2 tile_id = floor(fc.xy / tile_size.xy);\n    // Get the param to plot in this tile.\n    float p = prms[int(tile_id.x)];\n\n    // Plot the function belonging to this row of tiles.\n    float shape;\n    float i_fun = 0.0;\n    \n    if (tile_id.y >= (n_funs - ++i_fun)) {\n        \n    \tshape = 1.0 - pow(abs(ts.x), p);\n        \n    } else if (tile_id.y >= (n_funs - (++i_fun))) {\n        \n         shape = pow(cos(PI * ts.x / 2.0), p);\n        \n    } else if (tile_id.y >= (n_funs - ++i_fun)) {\n        \n        shape = 1.0 - pow(min(abs(sin(PI * ts.x / 2.0)), 1.0), p);\n        \n    } else if (tile_id.y >= (n_funs - ++i_fun)) {\n        \n        shape = pow(min(cos(PI * ts.x / 2.0), 1.0 - abs(ts.x)), p);\n        \n    } else if (tile_id.y >= (n_funs - ++i_fun)) {\n        \n        shape = 1.0 - pow(max(0.0, abs(ts.x) * 2.0 - 1.0), p);\n    \n    }\n\n    // Plot the function shape in the x = [-1, 1] interval\n    // (thanks FabriceNeyret2 for the step(abs) trick).\n    float pct = plot_y(ts, shape, n_tiles)\n        * step(abs(ts.x), 1.0); \n\n    // Assign a different hue to each row.\n    vec3 pct_col = hsv2rgb(vec3(\n        tile_id.y / n_tiles.y,\n        1.,\n        .7\n    ));\n\n    // Draw axes at (0, 0), plus some margin.\n    float axes = max(plot_y(ts, 0., n_tiles), plot_x(ts, 0., n_tiles))\n        * step(abs(ts.x), 1.2)\n        * step(-0.2, ts.y)\n        * step(ts.y, 1.2);\n\n    color = put(axes, axes_color, color);\n    color = put(pct, pct_col, color);\n    \n    O = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tsyWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[736, 776, 798, 798, 967], [970, 970, 1010, 1010, 3357]], "test": "untested"}
{"id": "Wl2czD", "name": "CappedSegment", "author": "jj99", "description": "CappedSegment - iso lines look better", "tags": ["cappedsegment"], "likes": 1, "viewed": 359, "published": 3, "date": "1593871994", "time_retrieved": "2024-07-30T20:57:32.209856", "image_code": "// Capped line segment, should be ok now, Use at your own risk!! :)\n\nfloat sdSegmentCapped( in vec2 p, in vec2 a, in vec2 b, float thickness )\n{\n  vec2 sz = vec2(length(b-a)*0.5,thickness);\n  vec2 d = normalize(b-a);\n  vec2 pp = p - (a+d*sz.x);\n  float ang = radians(90.0)+atan(-d.x,d.y);\n  float c = cos(ang), s = sin(ang);\n  pp *= mat2(c, s, -s, c);\n  vec2 dd = abs(pp)-sz;\n  return length(max(dd,0.0)) + min(max(dd.x,dd.y),0.0);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    p *= 1.4;\n    \n    vec2 v1 = cos( iTime + vec2(0.0,2.00) + 0.0 );\n\tvec2 v2 = cos( iTime + vec2(0.0,1.50) + 1.5 );\n    float th = 0.1*(0.5+0.5*sin(iTime*1.1));\n    \n\tfloat d = sdSegmentCapped( p, v1, v2, th );\n    \n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-3.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(120.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wl2czD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 144, 144, 437], [439, 439, 496, 496, 987]], "test": "untested"}
{"id": "3l2yzD", "name": "ParabolaCapped", "author": "jj99", "description": "Modded version of IQ's parabola segment (Capped) - not sure if this is 100% correct!\n( original here: https://www.shadertoy.com/view/3lSczz )", "tags": ["cappedparabolasegment"], "likes": 3, "viewed": 282, "published": 3, "date": "1593869190", "time_retrieved": "2024-07-30T20:57:32.972816", "image_code": "// Modded version of IQ's parabola segment (Capped) - not sure if this is 100% correct!\n// Use at your own risk!! :)\n\nfloat sdParabolaCapped( in vec2 pos, in float wi, in float he, float thickness )\n{\n    pos.x = abs(pos.x);\n\n    float ik = wi*wi/he;\n    float p = ik*(he-pos.y-0.5*ik)/3.0;\n    float q = pos.x*ik*ik*0.25;\n    \n    float h = q*q - p*p*p;\n    float r = sqrt(abs(h));\n\n    float x = (h>0.0) ? \n        // 1 root\n        pow(q+r,1.0/3.0) - pow(abs(q-r),1.0/3.0)*sign(r-q) :\n        // 3 roots\n        2.0*cos(atan(r/q)/3.0)*sqrt(p);\n    \n    x = min(x,wi);\n    \n    float d =  length(pos-vec2(x,he-x*x/ik))-thickness;\t// * sign(ik*(pos.y-he)+pos.x*pos.x);\n    \n    // cap test...\n    vec2 ep = pos-vec2(wi,0.0);\n    vec2 mp = pos-vec2(0.0,he);\n    return max(d, dot(ep,normalize(mp-ep)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        \n    // animate\n    float t = iTime/2.0;\n    \n\tfloat w = 0.7+0.69*sin(iTime*1.1+0.0);\n    float h = 0.3+0.55*sin(iTime*1.3+2.0);\n    \n    // sdf\n    float d = sdParabolaCapped( p, w, h, 0.05 );\n    \n    // colorize\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(1.0,1.1,1.2);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.7 + 0.2*cos(110.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n\n\tfragColor = vec4(col,1.0);\n}\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2yzD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[118, 118, 200, 200, 804], [806, 806, 861, 861, 1363]], "test": "untested"}
{"id": "3t2yRD", "name": "Come fly with me", "author": "Oggbog", "description": "Messing about with perspective. Thanks to izutionix for the inspiration https://www.shadertoy.com/view/wlGGRy", "tags": ["perspective", "fly"], "likes": 3, "viewed": 263, "published": 3, "date": "1593868861", "time_retrieved": "2024-07-30T20:57:33.790630", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv.y += .5*sin(iTime)-.2,.5;\n    float a = cos(iTime)*.6;\n    uv = uv*mat2(cos(a),-sin(a),sin(a),cos(a));\n    \n    \n    const float h = -.1; // horizon\n    const float sc = 8.; // scale\n    const float sp = 10.; // speed\n    \n    float f = distance(uv,vec2(a,-0.08));\n    float e = smoothstep(f,f+1.,.9)*step(h,uv.y);\n    e += smoothstep(f,f+.01,.2);\n\n    float d = 1./abs(uv.y*2.); //depth\n    vec2 pv = vec2(uv.x*d, d); //perspective\n    pv.x += a;\n    pv.y += iTime*1./sc*sp; //offset\n    pv *= sc; \n    pv = abs((fract(pv)-.5)*2.); //grid vector\n    \n    \n    float c = smoothstep(length(pv),length(pv)+1./sc,.6)*smoothstep(uv.y,uv.y+1.2/sc,h);\n    \n    c *= abs(uv.y*2.);\n    vec3 col = vec3(c,0.,0.1);\n    \n    col = mix(col,vec3(e,e/2.,1.-e)*step(h,uv.y),.5);\n\n    fragColor = vec4(pow(col,vec3(1./2.2))*1.5,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2yRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 943]], "test": "untested"}
{"id": "tlsyDl", "name": "complex rational function", "author": "unnick", "description": "this shader just plots the phase of a random rational function, the left side plots it with the hue while the right side plots lines where the phase is 90 or -90 degrees (red and blue colors respectively).", "tags": ["2d", "complex", "multipass"], "likes": 15, "viewed": 378, "published": 3, "date": "1593868311", "time_retrieved": "2024-07-30T20:57:34.574533", "image_code": "/* resemblance to the sun's magnetic field is purely coincidental :)\n *\n * but the lines on the right side do correspond\n * to the field lines of a bunch of electrons and protons\n * placed at the poles and zeros of the rational function\n */\n\nvoid mainImage(out vec4 col, in vec2 coord) {\n    ivec2 pos = ivec2(coord);\n    \n    col = fetch(pos);\n    \n    vec2 phase = col.xy;\n    float detail;\n    \n    #ifdef use_analytic_derivatives\n    detail = length(col.zw) / res.y * 2. * zoom * phase_mul;\n    #else\n    {\n        vec2 c = col.xy;\n        vec2 r = fetch(pos + ivec2(1,0)).xy;\n        vec2 u = fetch(pos + ivec2(0,1)).xy;\n        vec2 l = fetch(pos - ivec2(1,0)).xy;\n        vec2 d = fetch(pos - ivec2(0,1)).xy;\n        float a = angle_diff(u, c) + angle_diff(c, d);\n        float b = angle_diff(r, c) + angle_diff(c, l);\n        detail = length(vec2(a,b)) * .5 * phase_mul;\n    }\n    #endif\n    \n    for(int i = 0; i < phase_doublings; i++) phase = sqr(phase);\n    \n    if(coord.x < (iMouse.w == 0. ? res.x / 2. : iMouse.x)) {\n        col.rgb = mat2x3(1,-.5,-.5, 0,sqrt(3.)/2.,-sqrt(3.)/2.) * phase;\n        detail *= .8;\n        if(detail > .05) col.rgb *= detail < tau * .5 ? sin(detail)/detail : 0.;\n        col.rgb = col.rgb * .5 + .5;\n    } else {\n        float ld = abs(phase.x) / detail;\n        col.rgb = (phase.y < 0. ? vec3(0,0,1) : vec3(1,0,0)) * (ld > 1. ? 0. : 1. - ld);\n    }\n    \n    col.rgb = sqrt(col.rgb);\n}\n", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "vec2 randpos(int i) {\n    vec4 rand = hash(i);\n    vec2 tmp = sincos(iTime * (rand.x + 1.) * 1. + rand.y * tau);\n    return mul(tmp * vec2(rand.z - .5, 1.), sincos(rand.w * tau));\n}\n\nvoid mainImage(out vec4 col, in vec2 _coord) {\n    ivec2 coord = ivec2(_coord);\n    if(coord.x >= width || coord.y >= height) discard;\n    int idx = (coord.x << (1 + height_log2)) + (coord.y << 1);\n    col.xy = randpos(idx  ) + offset;\n    col.zw = randpos(idx+1) - offset;\n}\n", "buffer_a_inputs": [], "common_code": "#define res iResolution.xy\n#define tau 6.283185\n#define fetch(pos) texelFetch(iChannel0, pos, 0)\n\n#define zero min(iFrame, 0)\n\n//#define use_analytic_derivatives\n#define zoom 1.5\n#define height_log2 4\n#define width 16\n#define phase_doublings 1\n#define offset vec2(0,.05)\n\n#define height (1 << height_log2)\n#define phase_mul float(1 << phase_doublings)\n\nvec4 hash(int x) {\n    x *= 0x7feb352d;\n    x ^= x >> 16;\n    x *= 0x846ca68b;\n    return vec4(\n        (x >>  0) & 0xFF,\n        (x >>  8) & 0xFF,\n        (x >> 16) & 0xFF,\n        (x >> 24) & 0xFF\n    ) / 256.;\n}\n\n//complex multiplication\nvec2 mul(vec2 a, vec2 b) {\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\n//complex div\nvec2 div(vec2 a, vec2 b) {\n    return vec2(a.x*b.x + a.y*b.y, a.y*b.x - a.x*b.y);\n}\n\n//complex square\nvec2 sqr(vec2 z) {\n    return vec2(z.x*z.x - z.y*z.y, z.x*z.y*2.);\n}\n\nvec2 sincos(float a) {\n    return vec2(cos(a), sin(a));\n}\n\nfloat angle_diff(vec2 a, vec2 b) {\n    return atan(a.y*b.x - a.x*b.y, a.x*b.x + a.y*b.y);\n}\n", "buffer_b_code": "void mainImage(out vec4 col, in vec2 coord) {\n    vec2 pos = (coord * 2. - res) / res.y * zoom;\n    vec2 phase = vec2(1,0);\n    vec2 phase_grad = vec2(0);\n    for(int y = 0; y < height + zero; y++) {\n        for(int x = 0; x < width + zero; x++) {\n            vec4 tmp = fetch(ivec2(x, y));\n            vec2 z;\n            z = pos - tmp.xy;\n\n            phase = mul(phase, z);\n            \n            #ifdef use_analytic_derivatives\n            phase_grad += z / dot(z,z);\n            #endif\n            z = pos - tmp.zw;\n            \n            phase = normalize(mul(phase, z * vec2(-1,1)));\n            #ifdef use_analytic_derivatives\n            phase_grad -= z / dot(z,z);\n            #endif\n        }\n    }\n    \n    col.xy = phase;\n    col.zw = phase_grad;\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlsyDl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[242, 242, 287, 287, 1430]], "test": "untested"}
{"id": "Wt2cR1", "name": "Electronic Gems - Gem", "author": "frhun", "description": "the gem from the intro of electronic gems", "tags": ["gem"], "likes": 6, "viewed": 368, "published": 3, "date": "1593818883", "time_retrieved": "2024-07-30T20:57:35.325525", "image_code": "const float pi = 3.14159;\nconst float pifi = pi / 5.0;\nconst float pifih = pifi / 2.0;\nconst float r = 0.4;\nconst float ri = 0.3;\nconst float ri2 = 0.36;\nconst float h = 0.6;\nconst float hu = 0.5;\nconst float huh = 0.55;\n\nstruct line {\n    vec3 a;\n    vec3 b;\n};\n\nfloat segment(vec2 u, line l){\n    vec2 a = l.a.xy;\n    vec2 b = l.b.xy;\n    b -= a, u -= a;\n    return length( u - b * clamp(dot(b, u) / dot(b, b), 0., 1.));\n}\n\nvoid addCol(inout vec3 col, float dist){\n    col += vec3(clamp(\n    \t1.0 - (( dist - 0.002) / 0.003)\n        , 0.0\n        , 1.0\n    ));\n}\n\nbool drawLine(line l){\n    return l.b.z > -0.1 && l.a.z > -0.1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - (iResolution.xy / 2.0)) / iResolution.y;\n    uv *= 2.0;\n    uv /= 1.5;\n\n    vec3 col = vec3(0.);\n    \n    float ao = -iTime / 4.0;\n    vec3 base = vec3(0.0, - h / 2.0, 0.0);\n    \n    for(float i = 0.0; i < 10.0; i = i + 1.0){\n        vec3 mainEdge = vec3(\n            sin(pifi * i + ao) * r,\n            hu,\n            cos(pifi * i + ao) * r\n        );\n        vec3 upperMidpoint = vec3(\n            sin(pifi * i + pifih + ao) * r,\n            hu,\n            cos(pifi * i + pifih + ao) * r\n        );\n        vec3 prevUpperMidpoint = vec3(\n            sin(pifi * i - pifih + ao) * r,\n            hu,\n            cos(pifi * i - pifih + ao) * r\n        );\n        vec3 upperMainEdgeEnd = vec3(\n            sin(pifi * i + ao) * ri2,\n            huh,\n            cos(pifi * i + ao) * ri2\n        );\n        vec3 topMidpoint = vec3(\n            sin(pifi * i + pifih + ao) * ri,\n            h,\n            cos(pifi * i + pifih + ao) * ri\n        );\n        vec3 prevTopMidpoint = vec3(\n            sin(pifi * i - pifih + ao) * ri,\n            h,\n            cos(pifi * i - pifih + ao) * ri\n        );\n        \n        line lineToDraw = line(\n        \tbase,\n            base + mainEdge\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge * 0.33,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge * 0.33,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + mainEdge,\n            base + upperMainEdgeEnd\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + upperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + prevUpperMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + topMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + upperMainEdgeEnd,\n            base + prevTopMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n        \n        lineToDraw = line(\n        \tbase + topMidpoint,\n            base + prevTopMidpoint\n        );\n        if(drawLine(lineToDraw))\n        \taddCol(col, segment(uv, lineToDraw ));\n    }\n    \n    col = clamp(col, 0.0, 1.0);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2cR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[264, 264, 294, 294, 424], [426, 426, 466, 466, 564], [566, 566, 588, 588, 631], [633, 633, 690, 690, 4003]], "test": "untested"}
{"id": "3lGGWK", "name": "mushroom", "author": "zxxuan1001", "description": "mushroom", "tags": ["mushroom"], "likes": 64, "viewed": 2891, "published": 3, "date": "1593815097", "time_retrieved": "2024-07-30T20:57:36.244069", "image_code": "#define MAX_DISTANCE 80.0\n#define MAX_STEP 120\n#define EPSILON 0.0001\n#define PI 3.1415\n#define RIM_COLOR vec3(0.1,0.05,0.2)\n#define LIGHT_COLOR vec3(0.15,0.1,0.3)\n#define LIGHT_DIR vec3(cos(iTime),1.0,sin(iTime))\n#define SPHERE_COLOR vec3(0.2, 0.6, 1.0)\n#define GLOW vec3(0.1, 0.8, 1.0)\n\n//https://iquilezles.org/articles/smin\nvec3 sdMin (vec3 d1, vec3 d2)\n{\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 sdMax (vec3 d1, vec3 d2)\n{\n    return d1.x > d2.x ? d1 : d2;\n}\n\nfloat sdSmoothMin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\n\nfloat smin(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return min(a,b) - h*h*0.25/k;\n}\n\nfloat smax(in float a, in float b, in float k)\n{\n    float h = max( k - abs(a-b), 0.0);\n    return max(a,b) + h*h*0.25/k;\n}\n\nfloat sphereSDF(vec3 p, float r) \n{\n    return length(p) - r;\n}\n\nfloat sdVerticalCapsule( vec3 p, float h, float r )\n{\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat disp (vec3 p) \n{\n    float n = texture(iChannel2, p.xy+p.yz+p.xz).r;\n    return  (sin(p.z * 25.2 + 10.0*n) + sin(p.x * 28.9 + 10.0*n));\n}\n\nfloat disp1 (vec3 p)\n{\n    //return (sin(p.x) + sin(p.z)) * sin(p.y);\n    return texture(iChannel1, p.xz*0.1).r;\n}\n\nfloat leg(vec3 p, float h, float r) \n{\n    vec3 q = p-vec3(0.0,-1.0,0.0) ;\n    q.xz += 0.5*sin(q.y*0.3);\n    float scale = mix(1.0, 2.2, smoothstep(h-10.0,h, q.y));\n    r *= scale;\n    float d = sdVerticalCapsule(q, h, r);\n    d += 0.008*disp(q*0.5);\n    return d;\n}\n\nfloat shell(vec3 p, float r) \n{\n    float t = iTime*0.1;\n    float scale = mix(0.6+0.2*sin(t), 2.2+0.8*sin(t), smoothstep(-1.2,2.5, -0.6*p.y));\n    r *= scale;\n    float s1 = sphereSDF(p , r);\n    s1 = abs(s1)-0.1;\n    \n    s1 += 0.18*disp1(p*2.3)*(0.5+0.5*sin(t)); // holes\n    s1 *= 0.5;\n    \n    float plane = dot(p, normalize(vec3(0.0,-1.0,0.0)))-3.65;\n    \n    //plane -= 0.08*disp1(p*8.0);;\n    float d = s1 > plane ? s1 : plane;\n    \n    return d;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) \n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n\nfloat noise(in vec2 uv) {\n    return texture(iChannel1, uv/64.0).r;\n}\n\nfloat smoothNoise(in vec2 uv) {\n    vec2 luv = fract(uv); //range from 0.0 to 1.0\n    vec2 id = floor(uv); //the integer part of uv, 0, 1, 2\n    luv = luv*luv*(3.0 - 2.0*luv); //similar to smoothstep\n    \n    //get values from the cordinates of a square\n    float bl = noise(id);\n    float br = noise(id + vec2(1.0, 0.0));\n    float tl = noise(id + vec2(0.0, 1.0));\n    float tr = noise(id + vec2(1.0, 1.0));\n    \n    float b = mix(bl, br, luv.x); //interpolate between bl and br\n    float t = mix(tl, tr, luv.x); //interpolate between tl and tr\n    \n    return mix(b, t, luv.y);\n}\n\nfloat hash21(vec2 p) {\n    p = fract(p*vec2(133.7, 337.1));\n    p += dot(p, p+vec2(37.1,17.33));\n    return fract(p.x*p.y);\n}\n\nvec3 offset = vec3(0.0);\nvec4 sceneSDF(vec3 p) \n{\n    \n    vec3 q = p; // org pos\n    \n    //head\n    float d1 = shell(q, 3.5);\n    \n    //leg\n    float h = 15.0;\n    float r = 0.9;\n    vec3 q1 = q - vec3(0.0, -h, 0.0);\n    float d2 = leg(q1, h, r);\n    \n    //ground\n    float d3 = q1.y + 2.0*texture(iChannel1, q1.xz*0.01).r;\n    \n    float d = sdSmoothMin(d1, d2, 0.5);\n    d = sdSmoothMin(d, d3, 2.0);\n    vec3 rst = vec3(d, 1.0, 0.0);\n    \n    //glow\n    float v = 0.2;\n    vec3 npos = v*(p-vec3(0.0, -h-1.0, 0.0));\n    vec2 nid = floor(vec2(npos.x+0.5, npos.z+0.5));\n    vec3 fid = vec3(fract(npos.x+0.5)-0.5, npos.y, fract(npos.z+0.5)-0.5);\n    float nn = hash21(nid*3.0);\n    vec3 fpos = fid + 0.2*vec3(sin(nn*112.33), 0.0, cos(nn*171.3));\n    float rr = pow(nn,3.0);\n    fpos.y += 0.08*sin(nid.x * nid.y + iTime*5.0);\n    float s2 = sphereSDF(fpos, 0.02+0.2*rr)/v;\n    rst = sdMin(rst, vec3(s2, 2.0, 0.0));\n    return vec4(rst, s2);\n}\n\nvec4 marching( in vec3 ro, in vec3 rd )\n{\n    vec4 rst = vec4(0.0);\n    float t = 0.01;\n    float minDist = MAX_DISTANCE;\n    for ( int i = 0; i < MAX_STEP; ++i )\n    {\n        vec3 p = ro + t * rd;\n        vec4 dist = sceneSDF(p);\n        minDist = min(minDist, dist.w/t);\n        rst = vec4(t, dist.y, minDist, dist.w);\n        if ( abs(dist.x)< EPSILON || t>MAX_DISTANCE) break;\n        t += dist.x; \n    }\n    \n    if ( t>MAX_DISTANCE )\n    {\n        rst = vec4(MAX_DISTANCE, -1.0, minDist, MAX_DISTANCE);\n    }\n    \n    return rst;\n}\n\nvec3 getNormal(vec3 p) \n{\n    return normalize(\n            vec3(\n                sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).x - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).x,\n                sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).x - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).x,\n                sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).x - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).x\n            )\n    \t);\n}\n\nvec3 testSurf(vec2 p)\n{\n    float f0 = mod(floor(p.x*2.0) + floor(p.y*2.0), 4.0);\n    float f1 = mod(floor(p.x*4.0) + floor(p.y*4.0), 2.0);\n    vec3 col = mix(vec3(0.8, 0.5, 0.4), vec3(0.5, 0.3, 0.7), f0);\n    col = mix(col, vec3(0.2, 0.4, 0.3), f1);\n    \n    return col;\n}\n\nvec3 shading(vec4 hit, vec3 ro, vec3 rd) \n{\n    vec3 p = ro + hit.x * rd;\n    vec3 nor = getNormal(p);\n    \n    vec3 col = vec3(0.0);\n    vec3 surfCol = vec3(0.0);\n    vec3 coeff = vec3(0.04, 1.0, 1.0); //ambient, diffuse, specular\n    vec3 p1 = p - offset;\n    float n = texture(iChannel2, p.xz*0.2).r;\n    float nf = texture(iChannel2, floor(p1.xz)).r;\n    vec2 polar = vec2(atan(p1.z, p1.x), 0.5+0.1*n);\n    float detail = texture(iChannel1,  polar).r;\n    vec3 w0 = nor * nor;\n    vec3 p2 = 0.2*p1;\n    vec3 noiseTex = w0.xxx * texture(iChannel2, p2.yz).rgb \n        \t\t\t+ w0.yyy * texture(iChannel2, p2.xz).rgb\n        \t\t\t+ w0.zzz * texture(iChannel2, p2.xy).rgb;\n    float rimPow = 8.0;\n    float t = iTime;\n    if (hit.y < 1.5)\n    {\n        float h = 0.5+0.5*sin(p.y*0.5+1.3); \n        surfCol = mix(vec3(0.1,0.58,0.85), vec3(0.0), h);\n        surfCol *= detail;\n        float tk = 0.5+0.5*(sin(length(p)+t*3.0)*cos(length(p)+t*2.0));\n        surfCol += pow(n,64.0)*vec3(0.0, 100.0,100.0)*tk;\n        surfCol *= smoothstep(-10.0, 0.0, p1.y);   \n        \n        vec3 lightDir = normalize(LIGHT_DIR); \n        vec3 viewDir = normalize(-rd);\n        vec3 reflectDir = normalize(reflect(-viewDir, nor));\n        float spec = pow(max(dot(reflectDir, viewDir), 0.0), 32.0); \n        float diff = max( dot(nor, lightDir), 0.0);\n\n        float rim = 1.0-max(dot(nor, viewDir), 0.0);\n        float rimS = pow(rim, rimPow);\n        vec3 rimCol = RIM_COLOR*rimS;\n        vec3 refCol = texture(iChannel0, reflectDir).rgb;\n\n        surfCol = coeff.x*surfCol + (coeff.y*surfCol*diff + coeff.z*spec)*LIGHT_COLOR;\n        surfCol += rimCol;\n    } \n    else if (hit.y < 2.5)\n    {\n        surfCol = vec3(0.01);\n    }\n    return surfCol;\n}\n\nvec3 render(in vec2 fragCoord) \n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y; \n    vec2 mo = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mo = -1.0 + 2.0 * mo;\n    \n    vec3 ro = vec3(25.0 * cos(mo.x * 2.0 * PI), 0.0, 25.0 * sin(mo.x * 2.0 * PI));\n    vec3 ta = vec3(0.0, -5.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n    vec4 hit = marching(ro, rd);\n    vec3 col = vec3(0.0,0.001,0.003);\n    if (hit.x < MAX_DISTANCE) \n    {\n       col = shading(hit, ro, rd);\n    }\n   \n    //glow\n    vec3 p = ro + rd * hit.x;\n    hit.z = clamp(hit.z, 0.0, 3.0);\n    float glow0 = exp(-180.0*hit.z);\n    float glow1 = min(pow(0.0013/hit.z, 32.0), 1.0);\n    vec3 glowCol = vec3(0.0);\n    \n    float v = 0.2;\n    vec3 npos = v*p;\n    vec3 nid = floor(npos+0.5);\n    float vc = hash21(nid.xz);\n    vec3 vCol = vec3(0.0,1.0,4.0)*vec3(0.0,1.0,4.0);\n    vCol.r += 3.0*vc;\n    vCol.g += 1.0*fract(vc*111.77);\n    glowCol += 0.4*vCol*glow0;  \n    glowCol += vCol*glow1; \n    float t = sin(iTime+vc*5.0);\n    float y = 3.0*t*(1.0-t); \n    glowCol *= 0.5+0.5*y;\n    col += glowCol;\n    // fog\n    col = mix( col, vec3(0.0), 1.0-exp( -0.001*hit.x*hit.x ) );\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = render(fragCoord);\n    \n    col = pow(col, vec3(1.0/2.2));  \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 27, "src": "/media/a/0681c014f6c88c356cf9c0394ffe015acc94ec1474924855f45d22c3e70b5785.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 47, "src": "/media/a/ad56fba948dfba9ae698198c109e71f118a54d209c0ea50d77ea546abad89c57.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lGGWK.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[289, 328, 359, 359, 395], [397, 397, 428, 428, 464], [466, 466, 516, 516, 616], [619, 619, 667, 667, 742], [744, 744, 792, 792, 867], [869, 869, 904, 904, 932], [934, 934, 987, 987, 1046], [1048, 1048, 1070, 1070, 1191], [1193, 1193, 1215, 1262, 1307], [1309, 1309, 1347, 1347, 1575], [1577, 1577, 1608, 1608, 2033], [2035, 2035, 2077, 2077, 2247], [2250, 2250, 2275, 2275, 2319], [2321, 2321, 2352, 2352, 2902], [2904, 2904, 2926, 2926, 3029], [3056, 3056, 3080, 3080, 3974], [3976, 3976, 4017, 4017, 4514], [4516, 4516, 4541, 4541, 4914], [4916, 4916, 4939, 4939, 5189], [5191, 5191, 5234, 5234, 6920], [6922, 6922, 6955, 6955, 8177], [8179, 8179, 8236, 8236, 8370]], "test": "untested"}
{"id": "tlBcRW", "name": "Square Dance", "author": "mla", "description": "Lots of squares. Variation on Fabrice's [url]https://www.shadertoy.com/view/WlByRW[/url]\n\nProbably best full screen.", "tags": ["square", "jacobian"], "likes": 5, "viewed": 434, "published": 3, "date": "1593812946", "time_retrieved": "2024-07-30T20:57:37.146656", "image_code": "////////////////////////////////////////////////////////////////////////////////\n// Variant on https://www.shadertoy.com/view/WlByRW by @FabriceNeyret2\n// mla, 2020\n////////////////////////////////////////////////////////////////////////////////\n\nfloat square(vec2 z, float r) {\n  float d = max(abs(z.x),abs(z.y));\n  return 1.0-smoothstep(0.0,0.1,abs(d-r));\n}\n\nvoid mainImage(out vec4 outcolor, vec2 fragcoord) {\n  vec2 z = (2.0*fragcoord - iResolution.xy)/iResolution.y;\n  float scale = 8.0;\n  z *= scale;\n  float tt = iTime;\n  z += 0.5*z*mat2(cos(0.25*z+tt),sin(0.25*z-tt));\n  \n  // If f(z) is our function, then f(z+dz) = f(z)+J*dz\n  // ie. J approximates f locally as a linear function.\n  mat2 J = mat2(dFdx(z),dFdy(z))*iResolution.y/(2.0*scale);\n\n  // Fold in to [-1,1]\n  z /= 2.0;\n  vec2 index = round(z);\n  z -= round(z);\n  z *= 2.0;\n  vec2 z1 = z;\n\n  // Apply inverse coordinate transform\n  z = inverse(J)*z;\n\n  vec3 col = vec3(0);\n  // red channel shows distances (from the cell centre) in transformed coordinates\n  col.r = (0.5+0.5*sin(length(20.0*z1)))*0.6;\n  // blue shows distances in the inverse transformed coordinates\n  col.b = (0.5+0.5*sin(length(20.0*z)))*0.6;\n  col.g = abs(1.0-pow(abs(determinant(J)),0.5));\n\n  // A square in inverse coordinates, so (approximately) screen aligned\n  // and the same size.\n  //float t = fract(0.5*iTime);\n  // Phased and random square by Fabrice, thanks.\n  //float t = fract(0.5*iTime+0.1*(index.x+10.0*index.y));\n  float t = fract(0.5*iTime+sin(dot(index,iResolution.xy)));\n  col = mix(col,vec3(1),0.75*square(z,t));\n\n  // Transformed cell boundaries\n  z1 = abs(z1);\n  if (z1.y > z1.x) z1 = z1.yx;\n  col *= 0.25+0.75*smoothstep(0.0,0.2,1.0-z1.x);\n\n  // Inverse transformed cell axes.\n  z = abs(z);\n  if (z.y > z.x) z = z.yx;\n  col *= 0.25+0.75*smoothstep(0.0,0.1,z.y);\n  col = pow(col,vec3(0.4545));\n  outcolor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 247, 278, 278, 359], [361, 361, 412, 412, 1880]], "test": "untested"}
{"id": "ttByRD", "name": "Planet with craters", "author": "jarble", "description": "This planet has a \"cratered\" fractal surface with many mountains.", "tags": ["fractal", "planet", "crater"], "likes": 3, "viewed": 312, "published": 3, "date": "1593811760", "time_retrieved": "2024-07-30T20:57:37.999376", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(1.0,.5,.3+sin(p+sin(p.yzx))/5.0)/1.1;\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float speed = 10.0;\n    vec3 eye = scale*(1.5+sin(iTime/speed)*.7)*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float planet_size = 1000.0;\nconst float size = 10.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\nfloat craters(vec3 p,float i){\n    float scale1 = 32.0;\n    p -= (i+sin(p.yzx/scale1))*scale1;\n    p /= planet_size;\n    p *= i;\n\treturn length(sin(i*p*length(sin(p))))*scale1*sqrt(scale1)/i;\n}\n\n\nfloat sphere(vec3 p,float radius){\n    return length(p)-radius;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\tfloat result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        result += craters(p,i)/i;\n        i *= 2.0;\n    }\n    return (result+sphere(p,planet_size))*scale/10.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*image_scale*2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*(1.5+sin(iTime/speed)*.7)*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*planet_size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    \n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttByRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 86, 86, 142], [144, 565, 656, 656, 978], [993, 1082, 1111, 1111, 1421], [1423, 1915, 2055, 2055, 2665], [2667, 3037, 3122, 3122, 3894], [3896, 3896, 3923, 3923, 4072], [4074, 4074, 4131, 4131, 4902]], "test": "untested"}
{"id": "wtBcRW", "name": "Alien Skin", "author": "mrange", "description": "License CC0: Alien skin\nMore playing around with warped FBMs", "tags": ["fbm", "warp"], "likes": 21, "viewed": 1017, "published": 3, "date": "1593800739", "time_retrieved": "2024-07-30T20:57:38.756352", "image_code": "// License CC0: Alien skin\n//  More playing around with warped FBMs\n//  https://iquilezles.org/articles/warp\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define TIME        iTime\n#define RESOLUTION  iResolution\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU*tanh(a*b+a+b)));\n  \n  return c;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm(vec2 p, int mx) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < mx; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat warp(vec2 p) {\n  const int mx1 = 8;\n  const int mx2 = 3;\n  const int mx3 = 3;\n  vec2 v = vec2(fbm(p, mx1), fbm(p+0.7*vec2(1.0, 1.0), mx1));\n  \n  rot(v, 1.0+TIME*0.1);\n  \n  vec2 vv = vec2(fbm(p + 3.7*v, mx2), fbm(p + -2.7*v.yx+0.7*vec2(1.0, 1.0), mx2));\n\n  rot(vv, -1.0+TIME*0.2315);\n\n    \n  return fbm(p + 1.4*vv, mx3);\n}\n\nfloat height(vec2 p) {\n  float a = 0.005*TIME;\n  p += 5.0*vec2(cos(a), sin(sqrt(0.5)*a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n  return 0.4*tanh(rs*h)/rs;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)  {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x*=RESOLUTION.x/RESOLUTION.y;\n \n  const vec3 lp1 = vec3(0.8, -0.75, 0.8);\n  const vec3 lp2 = vec3(-0., -1.5, -1.0);\n\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n \n  const vec3 baseCol1 = vec3(0.6, 0.8, 1.0);\n  const vec3 baseCol2 = sqrt(baseCol1.zyx);\n  \n  vec3 col = vec3(0.0);\n  col += baseCol1*pow(diff1, 16.0);\n  col += 0.1*baseCol1*pow(diff1, 4.0);\n  col += 0.15*baseCol2*pow(diff2,8.0);\n  col += 0.015*baseCol2*pow(diff2, 2.0);\n\n  col = clamp(col, 0.0, 1.0);\n  col =mix(0.05*baseCol1, col, 1.0 - (1.0 - 0.5*diff1)*exp(- 2.0*smoothstep(-.1, 0.05, (h))));\n\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtBcRW.jpg", "access": "api", "license": "cc0-1.0", "functions": [[229, 229, 262, 262, 347], [349, 349, 373, 373, 443], [445, 445, 465, 465, 563], [565, 565, 586, 586, 615], [617, 617, 639, 639, 760], [762, 762, 784, 784, 1351], [1353, 1353, 1380, 1380, 1755], [1757, 1757, 1777, 1777, 2084], [2086, 2086, 2108, 2108, 2269], [2271, 2271, 2292, 2325, 2533], [2535, 2535, 2572, 2572, 2821], [2823, 2823, 2879, 2879, 3750]], "test": "untested"}
{"id": "WtBcRD", "name": "Moebius Lizard - study", "author": "FabriceNeyret2", "description": "studying \"Moebius Lizard\" by iapafoto. [url]https://shadertoy.com/view/wtjyz1[/url]\nT encodes shape, turned 4x by Pi/2, + copied trough tiles.\nVoronoi coloring identify lines.\nTrying to #FILL the shape, but uneasy since we never draw a close contour !", "tags": ["2d", "lizard", "moebus"], "likes": 8, "viewed": 346, "published": 3, "date": "1593790939", "time_retrieved": "2024-07-30T20:57:39.661931", "image_code": "// === Studying \"Moebius Lizard\" by iapafoto. https://shadertoy.com/view/wtjyz1\n\n//#define FILL 2           // 1 : try shape filling   2: better: with close contour\n#define FILL ( fract(iTime/3.)<.5 ? 0 : 2 )\n//#define mod(a,b) a     // uncomment to see only 1 tile \n\n// --- L() get the distance d of p=U-a to segment(a-a,b-a) \n// AND get whether pixel in/out shape by counting the number of intersection with [U,U+(0,inf)]\n//     for close contours, n is odd inside and even outside.\n// l get the label of the closest line\nvec2 q; float s,c,v,d=1e3; int k,n=0;\n#define L(p,l) v = length( q = p-b*( c = clamp( s = dot(p,b)/dot(b,b),0.,1.))); \\\n               if (v<d) d=v, k=l;                                               \\\n               c = clamp ( s = p.y/b.y, 0.,1.);                                 \\\n               if ( c == s && s * b.x > (p).x ) n++\n            \n// --- T encodes shape, turned 4x by Pi/2, + copied trough tiles.\n// note that a Lizard is contoured by 3 of these.        Vsame Yv                         Vsame xV\nint[] T = int[](6,0,9,2,12,5,6,10,0,20,  6,26,  12,20,11,17,14,17,17,18,15,22,11,26,16,26,22,18,22,27,25,28,28,30,30,26\n          // left hand  - left of head (10)head right of head                   -                right foot\n    ,     // completed contour. Used only with FILL=2\n    26,24,28,21,29,18,38,18,30,12,30,7,34,11,38,13,39,10,39,7,36,8,  30,2,    24,8,14,2,9,-4,6,-1,4,2, 6,0 );\n          //       ^same y^                        ^same x^\n\nvoid drawTile(vec2 m, int i, int r) {\n    vec2 a = vec2(T[i],T[i+1]),\n         b = vec2(T[i+2],T[i+3])-a,\n         p = m-a;\n    L(p, 4*r);                                      // ok alone with m = mod(U+g+12.,48.)-12.\n/*\n#if 1\n    L(p-vec2(48,0), 4*r+1);                         //  with m = mod(U+g, 48.)\n#else\n    L(p-h,4*r+0); L(p-h.yx,4*r+0); L(p-h.yy,4*r+0); // with m = U + g \n#endif \n*/\n}\n    \nvoid mainImage(out vec4 O, vec2 u ) {\n    \n    vec2 R = iResolution.xy,\n         m = 2.*iMouse.xy/R,\n         U = (u - .5*R) / R.y , _U,_m, h = vec2(0,48), g = vec2(30,26), I;     \n    U *= 1.3;\n    I = floor(U+.5);\n  //U =(fract(U+.5)-.5); // no longer needed with m = mod(U+g...\n    U *= 48.;\n\n    int nn=-1;\n    for (int r=0; r < (true?4:1); r++)\n    {   \n      //m = U + g; \n      //m = mod(U+g, 48.);\n        m = mod(U+g+8.,48.)-8.;\n        U = vec2(-U.y,U.x); \n        for (int i=0; i < ( FILL==2 ? T.length()-2 : 34 ); i+=2) {\n            drawTile(m,i,r);\n            if (FILL==1){      // 1: manually close contour per lizard  \n                _U = U; _m=m;  // 2: T already complete\n                if (i<10) U =  U - vec2(48,0);\n                else      U = -U;\n                m = mod(U+g+12.,48.)-12.;\n                drawTile(m,i,r);\n                U = _U; m = _m;\n            }\n        }\n        if (n%2>0) nn=r, n=0; // for checkered filling color\n    }\n    if(nn>=0) n=nn;\n    \n    // --- returned values: d = distance to contour, n = fill parity, I = tileId\n\n    float ch = mod(I.x+I.y,2.);\n    O = vec4( ( clamp(d,0.,1.)+.5*sin(10.*d) )   // contour + isovals\n             * ( .7+.3*ch ) );                   // checkered tiles\n    O = .5*O + .5* (.6 + .6 * cos( float(k) + vec4(0,23,21,0)  )); // Voronoi contour coloring\n    if (FILL>0) O = mix( O , vec4(n%2), .6 );    // shape filling\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtBcRD.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1491, 1491, 1528, 1528, 1886], [1892, 1892, 1929, 1929, 3302]], "test": "untested"}
{"id": "WlSczW", "name": "shuffle color flattening v2?????", "author": "thefox231", "description": "???????????????????????????????/\nlooks cool doe", "tags": ["glitch", "colorflattening"], "likes": 9, "viewed": 432, "published": 3, "date": "1593782772", "time_retrieved": "2024-07-30T20:57:40.524624", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(texture(iChannel0, uv));\n    \n    vec3 newCol = vec3(0.0);\n    \n    for (int i = 0; i < 3; i++) {\n        float color = col[i];\n        \n    \tfloat range1 = mod(iTime + uv.y - abs(uv.x - .5) + float(i) / 3.0, 3.0) - 1.0;\n    \tfloat range2 = mod(iTime * 1.5 - uv.x + abs(uv.y - .5) + float(i) / 2.0 + 0.5, 3.0) - 1.0;\n        \n        /*\n    \tif (color > range1 && color < range2) {\n    \t\tnewCol[i] = 1.0;\n    \t}\n    \n    \tif (color < range1 && color > range2) {\n    \t\tnewCol[i] = 0.0;\n    \t}\n\t\t*/\n        \n        newCol[i] = (abs(color - range1) + abs(color - range2)) / 2.0;\n    }\n    \n    fragColor = vec4(newCol, 1.0);\n}", "image_inputs": [{"id": 29, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSczW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 743]], "test": "untested"}
{"id": "WlByzW", "name": "Evolution of nebulae-like volume", "author": "Leria", "description": "Stable with additive noise\nI tried to make it looks like a nebulae without any light effects of course\n--> the movements are only for the beauty, not realistic\n", "tags": ["noise", "time", "evolution", "nebulae"], "likes": 18, "viewed": 638, "published": 3, "date": "1593780965", "time_retrieved": "2024-07-30T20:57:41.629670", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//enable-disable distorsion (0/1)\n#define DISTORSION_ON\t\t0\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t1\n\n\n//Stretch or not the colored volume\n\t#define STRETCH\t\t\t1\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* clamp( noise(p)/.178 +.5 ,0.,1.) )\n#define Psnoise(p) (2.* clamp( snoise(p)/.178 +.5 ,0.,1.) )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1., pow( 1.4, -3. ) );\n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    \n    #if STRETCH\n   \tp *= stretching;\n    s = 2./pow(stretching,vec3(.333));\n    #endif\n    \n    f = noise(p+iTime/10.); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching;\n    s = 2./pow(stretching,vec3(.333));\n    #endif\n\n    f = Pnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  2.*Pnoise( p ); p = p*s;\n    f *=  4.*Pnoise( p ); p = p*s;\n    f *=  8.*Pnoise( p ); p = p*s;\n    f *= 16.*Pnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 m_vec = m.pos - p;\n    float d = dot(m_vec,m_vec);\n    vec3 res = normalize(m_vec) * (DISTORSION*m.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    //RATE\n    float acc_rate = 0.8; // To control the acceleration rate\n\n    \n    int s = 0;\n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {            \n            #if COLOR     \n            float r_p = RADIUS/length(center);\n            float acceleration_p = sin(clamp(-r_p*r_p+4.,0., 4.));\n            \n            \n            float n = 0.;\n            if(r_p < 2.)\n            \tn = abs( fbm( p/8.+( acc_rate*acceleration_p) ) );\n             else\n                 n = abs( fbm( p/8. ) );          \n            \n            float mask = smoothstep(0., \n                                   \t1.*RADIUS,\n                                    (RADIUS-length(center))- 128.*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 6.* f(p.x) * dens, \n                      \tk * 3.*  \t\t dens,\n              \t      \tk * 3.* f(p.z) * dens);    \n           \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.0, .*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        #if DISTORSION_ON\n        space_time_bending(r, p, k); \n        #endif\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n\tc = exp(-t_acc);\n\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    cam.pos = C;\n\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n    \n    fragColor = vec4(color, 1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByzW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 889, 911, 911, 1084], [1754, 1754, 1811, 1811, 1980], [1982, 2005, 2027, 2280, 3197], [3199, 3199, 3225, 3225, 4050], [4161, 4161, 4186, 4199, 4561], [4563, 4563, 4588, 4601, 4934], [4936, 4936, 4955, 4955, 5048], [5050, 5050, 5111, 5111, 5305], [5306, 5325, 5401, 5401, 5448], [5450, 5450, 5482, 5482, 5502], [5504, 5504, 5538, 5538, 5560], [5662, 5662, 5686, 5686, 5846], [5848, 5848, 5872, 5872, 5957], [5959, 5988, 6016, 6016, 6186], [6188, 6210, 6256, 6256, 6879], [6929, 6929, 6970, 6970, 7006], [7008, 7008, 7094, 7094, 7129], [7131, 7131, 7174, 7174, 7214], [7216, 7216, 7240, 7240, 7288], [7290, 7290, 7330, 7330, 7634], [7636, 7636, 7660, 7660, 7723], [7725, 7725, 7772, 7772, 7824], [7826, 7826, 7909, 7909, 8048], [8051, 8051, 8104, 8104, 8461], [11412, 11412, 11469, 11469, 12087]], "test": "untested"}
{"id": "WlScRW", "name": "Tuto: managing atan discontinuit", "author": "FabriceNeyret2", "description": "Left: atan() discontinuity spoils the hardware derivatives  ( white arc ) used for antialiasing circles (or anything else).\nRight: managing it.\nClick to directly display fwidth(U) or Jacobian", "tags": ["antialiasing", "derivative", "fwidth", "tuto", "discontinuity", "jacobian"], "likes": 7, "viewed": 504, "published": 3, "date": "1593779781", "time_retrieved": "2024-07-30T20:57:42.384651", "image_code": "// --- Managing discontinuity when computing hardware derivatives ( -> Jacobian, fwidth )\n// See also: computing Jacobian to cancel distortions https://www.shadertoy.com/view/WlByRW\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, z, \n         U = (u - .5*R) / R.y,                           // normalized coordinates\n         D = vec2(6,-1);\n\n    U*=2.; U-=.5; U/=dot(U,U); U+=.5;                    // distortion\n    float a = atan(U.y, U.x)/6.283;   \n    U = log(length(U)) +  a * D - .3*iTime;              // spiraling\n                       // a cause a discontinuity. unseen in spiral because param fits.\n    vec2 dFx = dFdx(U), dFy = dFdy(U); // but derivatives (fwidth,dFdx,dFdy) will get a +1 or -1 jump\n    if (u.x/R.x<.5)                                      // --- left: the naive way\n        z = fwidth(U);\n    else {                                               // --- right: eliminating the jump trough discontinuity\n        float dax = dFdx(a), day = dFdy(a),\n               dx = abs(dax) > .5 ? sign(dax) : 0.,      // detect the jump\n               dy = abs(day) > .5 ? sign(day) : 0.;      // ( jump is +- 1 since atan/2PI, 0.5 threshold is large )\n        dFx -= D*dx, dFy -= D*dy,                        // eliminates in derivatives\n        z = abs(dFx)+abs(dFy);                           // recomputes fwidth manually\n/* shorter:\n    dax = dFdx(a), day = dFdy(a);\n    dFX = dFdx(U) - ( abs(dax) > .5 ? D*sign(dax) : R-R ),\n    dFY = dFdy(U) - ( abs(day) > .5 ? D*sign(day) : R-R );  \n    -> Jacobian, det, width, length...\n*/     \n    }\n                                                         // --- display\n    U.x+=.5; I = round(U); U = fract(U);                 // show distorted checker  \n    O = vec4(.5*U,0,0); \n    \n    if (iMouse.z <= 0.)                                  // draw antialiased circles\n        O += smoothstep(3.*length(z),0., abs(length(U*2.-1.) - .5)-.01 ); \n    else {                                               // draw derivatives\n#if 1                                                    //   fwidth   \n        O += vec4(z,0,0);                                  \n     // O += length(z);              \n#else                                                    //   Jacobian   \n        mat2 M = inverse(transpose(mat2(dFx, dFy)))/R.y; // Jacobian to go back to screen\n        O  = vec4( .5+ M);\n     // O += max( 0., -30.*determinant(M)*R.y );\n#endif\n    }\n    if (abs(u.x-R.x/2.)<2.) O.b ++;                      // separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlScRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[183, 183, 220, 220, 2504]], "test": "untested"}
{"id": "WlByRW", "name": "Tuto: Jacobians and undistortion", "author": "FabriceNeyret2", "description": "Distorted parameterization (checker) where red circles are drawn.\nJacobian matrix store the local distorted frame. Assuming distortion locally flat:\n-> U*inv(J) is back to undistorted frame : green circles.\ndet(J) shows compression of distortion.", "tags": ["screenspace", "fwidth", "tuto", "jacobian"], "likes": 29, "viewed": 1250, "published": 3, "date": "1593775674", "time_retrieved": "2024-07-30T20:57:43.139633", "image_code": "// --- Computing Jacobian to cancel distortions\n// See also: managing discontinuity when computing hardware derivatives https://www.shadertoy.com/view/WlScRW\n\n#define Circle(U,r) smoothstep(50./R.y,0., abs(length(U)-r)-.02 )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y, I, L;                  // normalized coordinates\n    \n    U += .5*U*mat2(cos(2.*U+iTime),sin(2.*U-iTime));   // distorted coordinates \n    U *= 4.; \n    \n    I =floor(U); L = 2.*fract(U)-1.;                   // draw distorted checker\n    O = vec4 (.4*mod(I.x+I.y,2.) );\n    \n    O.r += Circle(L,.4);                               // draw circle in distorted space\n    \n    mat2 J = transpose(mat2(dFdx(U),dFdy(U))) *R.y/8.; // the Jacobian store the local distorted frame\n    L *= inverse(J);                                   // undistort by applying the inverse transform\n // or if you prefer right-multiplying matrices :\n // mat2 J = mat2(dFdx(U),dFdy(U)) *R.y/8.;            // the Jacobian store the local distorted frame\n // L = inverse(J)*L;                                  // undistort by applying the inverse transform\n    O.g += Circle(L,.4);                               // draw circle in undistorted space\n    \n    O.b = ( .5+.5*determinant(J) ) *.6;                // det(J) shows compression in distortion\n  //O.b = length(vec4(J))/3.;\n\n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByRW.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[226, 226, 264, 264, 1383]], "test": "untested"}
{"id": "tt2cz1", "name": "Mandelbrot Golf (138/111 chars)", "author": "isaacchurchill", "description": "My attempt at the shortest working Mandelbrot GLSL code.\nNo added variable declarations! Other than the function parameters ;)\nThe 111-character version unfortunately does not scale when the window resolution changes.", "tags": ["2d", "fractal", "mandelbrot", "golf"], "likes": 8, "viewed": 424, "published": 3, "date": "1593766322", "time_retrieved": "2024-07-30T20:57:43.901596", "image_code": "// 138 chars (proper scaling and nicer colors)\n\nvoid mainImage(out vec4 a, vec2 u)\n{\n    a = u.xyxy / iResolution.x * 7. - 2.;\n    for (u -= u; u++.x < 25.; )\n        a.xy = a.xx * a.xy + a.yy * vec2(-a.y, a.x) + a.zw;\n    a = abs(a.xyyy);\n}\n\n\n// 111 chars\n/*\nvoid mainImage(out vec4 a, vec2 u)\n{\n    a = u.xyxy / 1e2 - 2.;\n    for (u -= u; u++.x < 25.; )\n        a.xy = a.xx * a.xy + a.yy * vec2(-a.y, a.x) + a.zw;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2cz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 84, 84, 241]], "test": "untested"}
{"id": "wt2yz1", "name": "cheap simple buffer bloom", "author": "thefox231", "description": "kind of just more experimenting\nuse mouse to control", "tags": ["simple", "cheap", "bloom", "buffers"], "likes": 4, "viewed": 573, "published": 3, "date": "1593762620", "time_retrieved": "2024-07-30T20:57:44.664556", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define strength iMouse.x / iResolution.x\n#define darken iMouse.y / iResolution.y\n\nfloat greenscreen(vec3 col) {\n    float g = length(col - vec3(0.,1.,0.));\n    return g;\n}\nfloat brightness(vec3 col) {\n    return (col.r + col.g + col.b) / 3.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n\tvec3 col = texture(iChannel0, uv).rgb;\n    \n    float scale = 0.98;\n    \n    vec2 uv2 = uv - 0.5;\n    uv2 = uv2 + 0.5 - (scale - 1.0) * 0.5;\n    uv2 *= scale;\n   \n    vec3 buffer = texture(iChannel1, uv2).rgb;\n  \tcol += min(buffer * greenscreen(buffer) * brightness(buffer), 1.0) * strength - darken;\n    \n    fragColor = vec4(col,1.);\n}", "buffer_a_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2yz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "wljyz1", "name": "Sinusoids Wave 2D - v4: bump2", "author": "FabriceNeyret2", "description": "analytic version of [url]https://shadertoy.com/view/ttBczh[/url]\nbump map ( with constrant-contrast blending over 7x7 neighborhood )\n\n", "tags": ["bump", "2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 4, "viewed": 303, "published": 3, "date": "1593762552", "time_retrieved": "2024-07-30T20:57:45.416545", "image_code": "// analytic version of https://shadertoy.com/view/ttBczh\n// variant of https://shadertoy.com/view/wtSczh\n// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y,  C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    float d, o = 0., t = o, v;\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(0.,1.-.05*dot(C,C)), d*=d*d*d,\n        v = length(V), V *= 36./v * cos(36.*v +(U-.2*C).x) ,\n        o += ( .4 + dot( V , cos(2.*iTime+vec2(0,11)) ) ) * d,\n        t += d*d;\n    t = ( .5 + .003*o/sqrt(t) )* smoothstep(1.,-1.,U.y -37.);\n    O += sqrt( t );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 239, 239, 793]], "test": "untested"}
{"id": "wl2cR1", "name": "idk really", "author": "thefox231", "description": "werid buffer experimenting", "tags": ["greenscreen", "experimental", "buffer"], "likes": 1, "viewed": 258, "published": 3, "date": "1593761433", "time_retrieved": "2024-07-30T20:57:46.206433", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wl2cR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 136]], "test": "untested"}
{"id": "tt2cR1", "name": "Grayscale plus Colored", "author": "landicefu", "description": "none", "tags": ["demo"], "likes": 3, "viewed": 354, "published": 3, "date": "1593759439", "time_retrieved": "2024-07-30T20:57:46.958424", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    vec3 conversion = vec3(0.3, 0.59, 0.11);\n    \n\tvec3 webcam_pixel = texture(iChannel0, p).rgb;\n\n    float gray_scale = dot(webcam_pixel, conversion);\n\n    if (gray_scale > 0.4) {\n        fragColor = vec4(webcam_pixel, 1.0);\n    } else {\n    \tfragColor = vec4(vec3(gray_scale), 1.0);        \n    }\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2cR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 401]], "test": "untested"}
{"id": "wt2czh", "name": "Video effects on webcam", "author": "landicefu", "description": "from https://www.shadertoy.com/view/XsX3z8", "tags": ["webcam"], "likes": 5, "viewed": 521, "published": 3, "date": "1593750624", "time_retrieved": "2024-07-30T20:57:47.708417", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy/iResolution.xy;\n    \n\tvec4 col = texture(iChannel0, p);\n\t\n\t\n\t// Desaturate\n    if(p.x < .25) {\n\t\tcol = vec4( (col.r+col.g+col.b)/3. );\n\t}\n\t// Invert\n\telse if (p.x < .5) {\n\t\tcol = vec4(1.) - texture(iChannel0, p);\n\t}\n\t// Chromatic aberration\n\telse if (p.x < .75) {\n\t\tvec2 offset = vec2(.01,.0);\n\t\tcol.r = texture(iChannel0, p + offset.xy).r;\n\t\tcol.g = texture(iChannel0, p            ).g;\n\t\tcol.b = texture(iChannel0, p + offset.yx).b;\n\t}\n\t// Color switching\n\telse {\n\t\tcol.rgb = texture(iChannel0, p).brg;\n\t}\n\t\n\t\n\t//Line\n\tif( mod(abs(p.x + .5/iResolution.y),.25) < 1./iResolution.y )\n\t\tcol = vec4(1.);\n\t\n\t\n    fragColor = col;\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2czh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 711]], "test": "untested"}
{"id": "WdXfD4", "name": "Tutorial from progur", "author": "landicefu", "description": "https://progur.com/2017/03/how-to-create-animated-shaders-in-shadertoy.html", "tags": ["tutorial"], "likes": 1, "viewed": 245, "published": 3, "date": "1593749481", "time_retrieved": "2024-07-30T20:57:48.460407", "image_code": "#define SMOOTH_EDGE_LENGTH 0.01\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // value between 0~1 based on current frame\n    float frame = (float(iFrame % 400)) / 400.0;\n \n    // Normalize the coordinate to 0-1 based on height of the view port\n    // Assume the view port is (1200, 600), (300, 300) -> (0.5, 0.5)\n    vec2 uv = fragCoord.xy / iResolution.yy;\n\n\tvec2 center1 = vec2(0.4 + frame, 0.5);\n    float radius1 = 0.3;\n    float distance1 = distance(center1, uv);\n    float red = smoothstep(radius1, radius1 - SMOOTH_EDGE_LENGTH, distance1);\n\n\tvec2 center2 = vec2(0.8 - frame, 0.5);\n    float radius2 = 0.1;\n\tfloat distance2 = distance(center2, uv);\n\tfloat green = smoothstep(radius2, radius2 - SMOOTH_EDGE_LENGTH, distance2);\n\n\tvec4 redColor = vec4(red, 0, 0, 1);\n\tvec4 greenColor = vec4(0, green, 0, 1);\n\tvec4 sum = redColor + greenColor;\n\tfragColor = sum; \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdXfD4.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "untested"}
{"id": "wtjczh", "name": "Surreal space caverns", "author": "jarble", "description": "This is a modification of my [url=https://www.shadertoy.com/view/tlByz1]\"Stalactites\"[/url] shader.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 2, "viewed": 362, "published": 3, "date": "1593746183", "time_retrieved": "2024-07-30T20:57:49.498631", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)*2.0+.5,sceneSDF(p)*2.0,sceneSDF(p*10.0)*2.0))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale/10.0)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n    float t1 = iTime/2.0;\n\tvec3 eye = vec3(50.0,20,10)+vec3(sin(t1),sin(t1),cos(t1))*10.0;\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //with distance fog\n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+100.0)*(200.0);\n\n    \n    fragColor = vec4(color, 1.0);\n    \n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n#define image_scale 8.0\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*.1; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    //p /= 100.0;\n    p += warp(p.yzx/500.0)*250.0;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx*(length(sin(p/100.0))+sin(p1.yxz))))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 2; k++){\n        result += planet_surface(p*i)/(i*i);\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale/2.0;\n}", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)*2.0+.5,sceneSDF(p)*2.0,sceneSDF(p*10.0)*2.0))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+depth*scale/10.0)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 dmap = depth_map(fragCoord).xyz;\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n    float t1 = iTime/2.0;\n\tvec3 eye = vec3(50.0,20,10)+vec3(sin(t1),sin(t1),cos(t1))*10.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float l0 = (length(dmap.xyz-eye));\n    //if(abs(sceneSDF(dmap.xyz) - sceneSDF(eye+l0*worldDir)) > .1 || sceneSDF(eye+l0*worldDir/2.0) < EPSILON){\n        l0 = log(1.0+l0)*2.0;\n    //}\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    fragColor = vec4(p, 1.0);\n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 88, 88, 214], [217, 638, 729, 729, 1058], [1073, 1327, 1392, 1392, 1524], [1526, 1615, 1644, 1644, 1954], [1956, 2448, 2588, 2588, 3198], [3200, 3570, 3655, 3655, 4070], [4072, 4399, 4448, 4483, 4614], [4616, 4616, 4643, 4643, 4792], [4794, 4794, 4851, 4851, 5722]], "test": "untested"}
{"id": "3tjcz1", "name": "Ball of grass", "author": "jarble", "description": "This object resembles a grassy or forested planet, or a ball of hair.", "tags": ["3d", "raymarching", "grass", "planet", "forest"], "likes": 1, "viewed": 478, "published": 3, "date": "1593731425", "time_retrieved": "2024-07-30T20:57:50.375287", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 twist(vec3 p){\n    vec3 p1 = p.yzx/1000.0;\n\treturn (sin(p1)+cos(p1))*500.0;\n}\n\nfloat planet_surface(vec3 p,float grass_scale){\n    vec3 p1 = p/5.0/size;\n    return length((sin(p1.yzx/vec3(length(sin(p1/grass_scale)))))*size) - size*1.5;\n}\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p = p/scale;\n    p += twist(p);\n    float grass_scale = 20.0;\n    float result = planet_surface(p,grass_scale);\n    for(float i = 2.0; i < 4.0; i++){\n    \tgrass_scale *= 1.5;\n        result = min(result,planet_surface(p,grass_scale));\n    }\n\n    return min(result,length(p)-30000.0)*scale + length(p/4000.0);\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0)*2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return vec3(0,1,0)/2.0;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 2.0;\n    float t1 = iTime/speed;\n    vec3 eye = vec3(sin(t1),cos(t1),1.0)*1500.0;\n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        vec3 s1 = twist(worldDir*1000.0)/1000.0;\n        fragColor = vec4(s1, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tjcz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 540, 540, 603], [605, 605, 652, 652, 764], [767, 767, 802, 802, 1117], [1119, 1119, 1142, 1142, 1173], [1175, 1175, 1203, 1203, 1233], [1236, 1657, 1748, 1748, 2115], [2130, 2384, 2449, 2449, 2581], [2583, 2672, 2701, 2701, 3011], [3013, 3505, 3645, 3645, 4255], [4257, 4627, 4712, 4712, 5059], [5061, 5388, 5437, 5472, 5603], [5605, 5605, 5662, 5662, 6635]], "test": "untested"}
{"id": "3t2cR1", "name": "attempted vegetation", "author": "yonatan", "description": "a messier version of https://www.shadertoy.com/view/wtfyzf", "tags": ["terrain", "fbm"], "likes": 13, "viewed": 568, "published": 3, "date": "1593723953", "time_retrieved": "2024-07-30T20:57:51.306796", "image_code": "// feel free to reuse\n\nmat2 rot2d(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));} // Angle => 2D rotation matrix\n\nfloat terrain_height(vec2 position) { // https://iquilezles.org/articles/fbm\n  float height=0., amplitude, n, am;\n  vec2 pp = position*.1;\n  float z = length(sin(pp)*cos(pp));\n  am = z*z*z*z*z*.6+.6;\n  amplitude=1.4*z*z;\n  for(int i = 0; i < 20; i++) { // Sum up 20 layers\n    n = sin(position.x) * cos(position.y); n = n * n * n; // Simple base pattern, no noise\n    if(i>9) n*=clamp(1., 1./(height*height*9.), 4.0); // This does the \"trees\"\n    height += n * amplitude; // Accumulate value at current amplitude\n    position *= rot2d(float(i*i)); // Rotate (phase-shift?) by a hash of the current iteration\n    position *= 1.41;\n    amplitude = am * amplitude;\n  }\n  return abs(height) - .02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  float time = iTime * .2 + iMouse.x / iResolution.x * 28.;\n  vec2 uv = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x,iResolution.y);\n  vec3 p, water_tint = vec3(1), ray_origin = vec3(-cos(time*.5)*7.,1.,time+4.), // Camera position\n    ray_direction = normalize(vec3(uv.x, uv.y - .7 + cos(time) * .5, 1.9));\n  ray_direction.xy *= rot2d(sin(time*.5)*.5); // Camera orientation and field of view\n  float distance = 0., ray_length = 0.;\n  for(int i = 0; i < 75; i++) { // Raymarching loop\n    p = ray_origin + ray_direction * ray_length; // Get current ray position\n    if(distance<.1 && p.y<0.) { // If we're close to the surface check p.y for a water hit\n      ray_origin.y = -ray_origin.y; ray_direction.y = -ray_direction.y; // Reflect ray\n      water_tint = vec3(.7,.8,.9)/(ray_direction.y);\n    } else { // Not underwater - march\n      distance = p.y-terrain_height(p.xz); // Real distance is hard to calculate so use p's\n      // height above the terrain, and since that's obviously\n      ray_length += distance * .6; // wrong - only march .6 of the way and hope for the best.\n    }\n    if(ray_length > 20.) break; // We are far away (in the sky)\n  }\n  vec2 h = vec2(.0001, 0); // From https://iquilezles.org/articles/normalsSDF\n  vec3 surface_normal = normalize(vec3(terrain_height(p.xz-h.xy) - terrain_height(p.xz+h.xy),\n                                       2.*h.x, terrain_height(p.xz-h.yx) - terrain_height(p.xz+h.yx)));\n  vec3 terrain_color = mix(vec3(.4,.6,.1),vec3(.7,.65,.15),abs(p.y)*8.)*.5\n    * (surface_normal.z * .5 + .5); // Terrain, backlit\n  vec3 sky_color = mix(vec3(1.1,1.,.8),vec3(.6,.7,.8),abs(ray_direction.y)); // Sunny horizon\n  vec3 color = mix(terrain_color, sky_color, min(1.,ray_length/20.)); // Mountains-sky fade\n  color *= water_tint; // Water color\n  fragColor = vec4(pow(color, vec3(.4545)), 1); // Gamma correction\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 44, 44, 87], [120, 120, 157, 196, 815], [817, 817, 874, 874, 2742]], "test": "untested"}
{"id": "3t2czh", "name": "Warped Liquid Metal", "author": "mrange", "description": "Licence CC0: Liquid Metal\nSome experimenting with warped FBM and very very fake lighting turned out ok ", "tags": ["2d", "fbm", "warp"], "likes": 83, "viewed": 2496, "published": 3, "date": "1593721238", "time_retrieved": "2024-07-30T20:57:52.266231", "image_code": "// Licence CC0: Liquid Metal\n// Some experimenting with warped FBM and very very fake lighting turned out ok \n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat tanh_approx(float x) {\n  float x2 = x*x;\n  return clamp(x*(27.0 + x2)/(27.0+9.0*x2), -1.0, 1.0);\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU*tanh_approx(a*b+a+b)));\n  \n  return c;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm1(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm2(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 7; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm3(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\n\nfloat warp(vec2 p) {\n  vec2 v = vec2(fbm1(p), fbm1(p+0.7*vec2(1.0, 1.0)));\n  \n  rot(v, 1.0+iTime*0.1);\n  \n  vec2 vv = vec2(fbm2(p + 3.7*v), fbm2(p + -2.7*v.yx+0.7*vec2(1.0, 1.0)));\n\n  rot(vv, -1.0+iTime*0.21315);\n    \n  return fbm3(p + 1.4*vv);\n}\n\nfloat height(vec2 p) {\n  float a = 0.005*iTime;\n  p += 5.0*vec2(cos(a), sin(a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n  return 0.35*tanh_approx(rs*h)/rs;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x*=iResolution.x/iResolution.y;\n \n  const vec3 lp1 = vec3(0.9, -0.5, 0.8);\n  const vec3 lp2 = vec3(-0.9, -1.5, 0.9);\n\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  float ll1 = length(lp1.xz - pp.xz);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), 0.0);\n  float diff2 = max(dot(ld2, n), 0.0);\n \n  vec3 baseCol = vec3(1.0, 0.8, 0.6);\n\n  float oh = height(p + ll1*0.05*normalize(ld1.xz));\n  const float level0 = 0.0;\n  const float level1 = 0.125;\n  // VERY VERY fake shadows + hilight\n  vec3 scol = baseCol*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));\n\n  vec3 col = vec3(0.0);\n  col += baseCol*pow(diff1, 6.0);\n  col += 0.1*baseCol*pow(diff1, 1.5);\n  col += 0.15*baseCol.zyx*pow(diff2, 8.0);\n  col += 0.015*baseCol.zyx*pow(diff2, 2.0);\n  col += scol*0.5;\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2czh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 194, 194, 279], [281, 281, 305, 305, 375], [377, 377, 397, 397, 495], [497, 497, 518, 518, 547], [549, 549, 577, 577, 653], [655, 655, 677, 677, 805], [807, 807, 829, 829, 1396], [1398, 1398, 1418, 1418, 1792], [1794, 1794, 1814, 1814, 2188], [2190, 2190, 2210, 2210, 2584], [2587, 2587, 2607, 2607, 2833], [2835, 2835, 2857, 2857, 3017], [3019, 3019, 3040, 3073, 3281], [3283, 3283, 3320, 3320, 3569], [3571, 3571, 3628, 3628, 4620]], "test": "untested"}
{"id": "3ljcRh", "name": "Box Frame - distance 3D", "author": "iq", "description": "Exact Euclidean distance to a box \"frame\".", "tags": ["3d", "raymarching", "distancefield", "sdf", "primitive"], "likes": 32, "viewed": 7711, "published": 3, "date": "1593719231", "time_retrieved": "2024-07-30T20:57:53.145880", "image_code": "// The MIT License\n// Copyright © 2020 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Exact euclidean distance to a box frame\n\n// List of other 3D SDFs: https://www.shadertoy.com/playlist/43cXRl\n//\n// and https://iquilezles.org/articles/distfunctions\n\n\n#if 1\nfloat sdBoxFrame( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n#else\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat sdBoxFrame( vec3 p, vec3 b, float e)\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return sqrt(min(min(dot2(max(vec3(p.x,q.y,q.z),0.0)),\n                      dot2(max(vec3(q.x,p.y,q.z),0.0))),\n                      dot2(max(vec3(q.x,q.y,p.z),0.0)))) \n         +min(0.0,min(min( max(p.x,max(q.y,q.z)),\n                           max(p.y,max(q.z,q.x))),\n                           max(p.z,max(q.x,q.y))));\n}\n#endif\n\n\nfloat map( in vec3 pos )\n{\n    return sdBoxFrame(pos, vec3(0.5,0.3,0.5), 0.025 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 3\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.5*(iTime-10.0);\n\tvec3 ro = 1.2*vec3( 1.0*cos(an), 0.0, 1.0*sin(an) );\n    vec3 ta = vec3( 0.0, -0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n   \n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n        // raymarch\n        const float tmax = 5.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n    \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            float dif = clamp( dot(nor,vec3(0.57703)), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = vec3(0.2,0.3,0.4)*amb + vec3(0.85,0.75,0.65)*dif;\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ljcRh.jpg", "access": "api", "license": "mit", "functions": [[2065, 2065, 2091, 2091, 2148], [2150, 2196, 2228, 2228, 2467]], "test": "untested"}
{"id": "3t2cRh", "name": "Alternating waves", "author": "Oggbog", "description": "Another happy accident", "tags": ["sinewave"], "likes": 1, "viewed": 257, "published": 3, "date": "1593715890", "time_retrieved": "2024-07-30T20:57:54.163159", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \t\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    uv = uv*cos(iTime)*4.;\n    \n    float a = uv.y + sin(sin(uv.x*cos(iTime)));\n    \n    uv.y = atan(a)*16.+10.;\n\t\n    float d = floor(mod(uv.y*2.,-a*6.));\n    \n    vec3 col = vec3(d/2.,-a,fract(a*4.));\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2cRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 363]], "test": "untested"}
{"id": "tlByz1", "name": "Stalactites", "author": "jarble", "description": "I modified my [url=https://www.shadertoy.com/view/tlSyzh]jungle fractal[/url] again, so it looks more like a cave full of stalactites.", "tags": ["3d", "raymarching", "fractal", "cave"], "likes": 3, "viewed": 383, "published": 3, "date": "1593703724", "time_retrieved": "2024-07-30T20:57:55.184429", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)+.5,sceneSDF(p),sceneSDF(p*10.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    p = eye+dist*worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    //distance fog\n    //vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye)/(vec3(dist)+100.0)*100.0;\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1(int t)\n{\n    t = (t>>(t/((t/4096)%5+(t/4096)%4)))|t>>4&t>>5|t>>6;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    time *= 16000.0;\n    float factor = .5;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 3; i++){\n    \tresult += sound1(int(time*factor))*factor;\n        factor *= 1.5;\n    }\n    return result/100.0;\n}", "sound_inputs": [], "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*500.0;\n    return sin(vec3(sceneSDF(p)+.5,sceneSDF(p),sceneSDF(p*10.0)))/4.0+vec3(.6,.5,.2)*1.3;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)*image_scale/2.0) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec4 depth_map(vec2 coord){\n    return texture(iChannel0, coord/iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 dmap = depth_map(fragCoord).xyz;\n    if (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n        if (length(iMouse.xy) > 40.0) {\n            viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n            viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n        }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    float l0 = length(dmap-eye);\n    \n    //if(sceneSDF(eye+l0*worldDir/2.0) < EPSILON){\n        //l0 = pow(l0,.9);\n        l0 = sqrt(l0);\n    //}\n    \n    /*\n    float divide = 2.0;\n    for(int i = 0; i < 4; i++){\n    if(sceneSDF(eye+l0*worldDir) < EPSILON){\n        l0 /= 2.0;\n        break;\n    }\n    l0 = 0.0;\n    }\n    */\n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST+l0, MAX_DIST);\n    \n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    fragColor = vec4(p, 1.0);\n    \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n#define image_scale 8.0\n//change Z-buffer resolution\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 500;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = .01; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 p){\n    vec3 a = p.zxy;\n    return (sin(a)+cos(a))*500.0;\n}\n\nfloat planet_surface(vec3 p){\n    p = sin(p/500000.0)*50000.0;\n    p += warp(p/1000.0);\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx*(4.0+sin(p1.yxz))))*size;\n    return length(p) - size;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    for(int k = 0; k < 4; k++){\n        result += planet_surface(p*i)/(i*i);\n        i *= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}", "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlByz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[58, 58, 86, 86, 200], [203, 624, 715, 715, 1082], [1097, 1351, 1416, 1416, 1548], [1550, 1639, 1668, 1668, 1978], [1980, 2472, 2612, 2612, 3222], [3224, 3594, 3679, 3679, 4094], [4096, 4423, 4472, 4507, 4638], [4640, 4640, 4667, 4667, 4816], [4818, 4818, 4875, 4875, 5531]], "test": "untested"}
{"id": "ttBczh", "name": "Sinusoids Wave 2D - v4: bump", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lScRR[/url]\nWith bump map ( with constrant-contrast blending over 7x7 neighborhood )\n\nSee analytic derivatives version here: [url]https://www.shadertoy.com/view/wljyz1[/url]\n", "tags": ["bump", "2tweets", "trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 2, "viewed": 357, "published": 3, "date": "1593691779", "time_retrieved": "2024-07-30T20:57:55.998253", "image_code": "// variant of https://shadertoy.com/view/wtSczh\n// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y,  C,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    float d, o = 0., t = o;\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(0.,1.-.05*dot(C,C)), d*=d*d*d,\n        o += sin( 36.*length(V) -0.*iTime +(U-.2*C).x ) * d   ,\n        t += d*d;\n    t = ( .5 + .1*o/sqrt(t) )* smoothstep(1.,-1.,U.y -37.);\n    O += sqrt( .4 + dot( vec2(dFdx(t),dFdy(t)) , cos(2.*iTime+vec2(0,11)) ) );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[146, 146, 182, 182, 730]], "test": "untested"}
{"id": "ttfcWl", "name": "Interference cinétique", "author": "ciphered", "description": "Having fun with interference patterns", "tags": ["interference", "optical", "vasarely"], "likes": 1, "viewed": 278, "published": 3, "date": "1593690860", "time_retrieved": "2024-07-30T20:57:56.810082", "image_code": "//\n// Just having some fun\n//\n\n#define PI \t\t3.1415926\n#define PI2\t\t1.5707963\n\n#define rot(a)   mat2( cos(a), -sin(a), sin(a), cos(a) )\n#define rand(n)  fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453)\n\n\n// @author Dave Hoskins\n// https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    \n    // time for easier sequencing\n    float t = iTime / 60.0;\n \tfloat c = 0.0;\n    \n   \tvec2 smpos = vec2(-.2, .2);\n    if (t > .5) smpos+= vec2(cos(iTime), sin(iTime)) * .1 * (min(.7, t)-.5)/.2;\n    \n    // drawing circles\n    float l = (length(uv - smpos) - (cos(iTime*.1)*.5 + .7)) * 250.0;\n    float id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n    float r = hash11(id);\n    \n    \n    c = cos(l) * r;\n    \n    \n    // drawing circles\n    vec2 smpos2 = vec2(-.2 + cos(iTime) * .2, -.2 + sin(iTime) * .2);\n    if (t>.15) {\n        float rt = min(t-.15, .25) / .25;\n        smpos2 = (smpos2 + vec2(.4, .2) * rt) * rot(iTime * .5 * rt);\n    }\n    l = (length(uv - smpos2) - (cos(iTime*.2)*.5 + .7)) * 250.0;\n    id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n    r = hash11(id);\n    \n    \n    c+= cos(l) * r * clamp(cos(iTime) - .6, .4, .8);\n    \n    \n    if (t > .75) {\n    \t// drawing circles\n        vec2 smpos3 = vec2(2. + cos(iTime) * .4, 2. + sin(iTime) * .2);\n        l = (length(uv - smpos3) - (cos(iTime*.2)*.5 + .7)) * 250.0;\n        id = floor(l / PI + PI2) + floor(iTime * floor(mod(t*.5, .1) * 18.));\n        r = hash11(id);\n\n\n        c+= cos(l) * r * clamp(cos(iTime) - .6, .4, .8) * (t-.5)/.5;   \n    }\n  \n    \n    vec2 dr = smpos - smpos2;\n    float a = atan(dr.y, dr.x);\n    vec2 ruv = (uv - vec2(-.2, .2)) * rot(-a + PI*.5);\n    \n\tc*=.4 + .8 * smoothstep(.04, .01, abs(ruv.x));\n    \n    if (t>.25) {\n    \tc = mix(1.-c, c, cos((t-.25)*20.)*.5+.5);   \n    }\n    \n    // Output to screen\n    fragColor = c * vec4(1., 1., 0.92, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttfcWl.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[209, 274, 297, 297, 382], [385, 385, 442, 442, 2113]], "test": "untested"}
{"id": "wtSczh", "name": "Sinusoids Wave 2D - variant3", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/3lScRR[/url]\nWith constant-contrast blending.\n\n", "tags": ["trochoid", "golf", "gerstner", "sinusoidswave"], "likes": 3, "viewed": 297, "published": 3, "date": "1593690115", "time_retrieved": "2024-07-30T20:57:57.676765", "image_code": "// variant of https://shadertoy.com/view/3lScRR\n// variant of https://shadertoy.com/view/ttlcDs\n\n\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy*.1, V = u/R.y, d, C,T=R-R,\n    U = V*5. + V.y* cos( iTime + V.x*.56 + 11.*O.xw );\n    for (int k=0; k<49; k++)\n        C = U - round((U+vec2(k%7-3,k/7-3))*.2) / .2 ,\n        V = C * inverse(transpose(mat2(dFdx(U),dFdy(U)) ))/R.y,\n        d = max(V-V,1.-.05*dot(C,C)), d*=d*d*d,\n        O += sin( 36.*length(V) -2.*iTime +(U-.2*C).x ) * d.x ,\n        T += d*d;\n    O = ( .5 + .1*O/sqrt(T.x) )* smoothstep(1.,-1.,U.y -37.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSczh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 134, 134, 586]], "test": "untested"}
{"id": "tlSyzh", "name": "Journey through the Jungle", "author": "jarble", "description": "This jungle is a modified version of my [url=https://www.shadertoy.com/view/wljcRz]\"bamboo lattice\"[/url] shader.", "tags": ["3d", "raymarching", "fractal", "jungle"], "likes": 1, "viewed": 275, "published": 3, "date": "1593687778", "time_retrieved": "2024-07-30T20:57:58.435736", "image_code": "#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx*(4.0+sin(p1.yxz))))*size;\n    return length(p) - size+10.0;\n}\n\nvec3 animate(inout vec3 p){\n    vec3 a = p.zxy/7000.0+iTime;\n    return (sin(a)+cos(a))*500.0;\n}\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += animate(p)*anim;\n\n    float result = planet_surface(p);\n    for(float i = 3.0; i < 9.0; i *= 3.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale-.5;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p += animate(p);\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.1)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    float speed = 10.0;\n\tvec3 eye = vec3(50.0,30.0,iTime*100.0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[589, 589, 618, 618, 737], [739, 739, 766, 766, 835], [837, 837, 872, 872, 1146], [1148, 1148, 1171, 1171, 1198], [1200, 1200, 1228, 1228, 1379], [1382, 1803, 1894, 1894, 2257], [2272, 2526, 2591, 2591, 2723], [2725, 2814, 2843, 2843, 3153], [3155, 3647, 3787, 3787, 4397], [4399, 4769, 4854, 4854, 5269], [5271, 5598, 5647, 5682, 5813], [5815, 5815, 5872, 5872, 6951]], "test": "untested"}
{"id": "wtSyzh", "name": "Logarithmic Moebius Transform 12", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/tt2yRz[/url]\n\n(un)comment line  29 for const/adaptive disc size", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 12, "viewed": 346, "published": 3, "date": "1593687435", "time_retrieved": "2024-07-30T20:57:59.379213", "image_code": "// variant of https://shadertoy.com/view/tt2yRz\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I, D,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n#if 1\n    U *= mat2(z,-z.y,z.x) / dot(U,U);\n    U += .5;\n    float a = atan(U.y, U.x)/6.283;\n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U))*vec2(.5, -.5) + iTime/8.\n        + a * vec2(6, 1); // n    \n#else\n    U.x +=.022; U *= vec2(1.5,1);                             // test in the plane\n    if(u.x/R.y>sqrt(3.)/2.) return;\n#endif\n  //D  = vec2(10,14.82)/1.43;// /(.5+iMouse.x/R.x);\n    D  = vec2(21./3., 2./sqrt(3.)*9.);                        // thanks Shane !\n    mat2 M = mat2(1,0,.5,sqrt(3.)/2.);\n    U = U*D * M;                                              // triangular mesh\n    float dx=0.,dy=0.,dax=dFdx(a),day=dFdy(a);                // manage jump trough poles arc\n    if (abs(dax) > .5) dx=-sign(dax);\n    if (abs(day) > .5) dy=-sign(day);\n    D = vec2(6,1)*D * M;\n    vec2 dFdx = dFdx(U)+D*dx, dFdy = dFdy(U)+D*dy;\n  //z = fwidth(U);\n    z = abs(dFdx)+abs(dFdy);\n    M = inverse(transpose(mat2(dFdx, dFdy)))*30./R.y;         // Jacobian to go back to screen\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.), v,                           // parallelogram = 2 triangles\n          i = mod( I.x + I.y , 3.), id; \n    I += i==0.? vec2(0) : i==1. ? vec2(1) : vec2(s,1.-s);  id = I.x +7.81*I.y;\n    vec4 V = vec4( 1.-2.*abs(U.x-U.y) , abs(U*2.-1.) , 0 );\n    v = V[i<2. ? 2-int(i+s)%2 : 0 ];\n    U = i==0. ? U : i==1. ? 1.-U : s==0.?vec2(U.x,U.y-1.):vec2(1.-U.x,-U.y);\n    U *= M;                                                  // undistort disc constante size\n    U *= 1.9 / length(vec4(M));                              // adaptive size\n // U *= inverse(mat2(1,0,.5,sqrt(3.)/2.));\n // O  = smoothstep(.7,-.7,(length(U)-.8)/( abs(z.x-z.y)>1.?.1:z.y*2.))\n    O  = smoothstep(.7,-.7,(length(U)-.8)/(z.y*2.))\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n    if (fract(iTime/6.)<.4) O += smoothstep(-.7,.7, (v-.95)/(z.y*4.));  // draw AA tiles\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtSyzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 2239]], "test": "untested"}
{"id": "ttSyzh", "name": "Spectral Duck", "author": "dr2", "description": "Duck(s) covered with a thin oil layer (pseudo: Newton's Rings)", "tags": ["reflection", "interference", "optics"], "likes": 6, "viewed": 394, "published": 3, "date": "1593687276", "time_retrieved": "2024-07-30T20:58:00.213981", "image_code": "// \"Spectral Duck\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec3 HsvToRgb (vec3 c);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltPos, vuPos, dukPos, eyePos;\nfloat tCur, dstFar, roomRd, roomHt, sclFac;\nint idObj;\nconst int idFrm = 1, idWl = 2, idFlrCl = 3, idTbl = 4, idLeg = 5, idLit = 6,\n   idBdy = 7, idBk = 8, idEye = 9;\nbool isSh;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat DuckDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, h, s;\n  dMin /= sclFac;\n  p /= sclFac;\n  cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  DMIN (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  DMIN (idBdy);\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dMin, 0.1);\n  DMIN (idBdy);\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= -0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dMin, 0.01);\n  DMIN (idBk);\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - eyePos, 0.125);\n  DMIN (idEye);\n  return 0.9 * sclFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, nw, w;\n  dMin = dstFar;\n  nw = 9.;\n  q = p;\n  q.y -= roomHt;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (nw * atan (q.z, - q.x) / (2. * pi) + 0.5) / nw);\n  q.x += roomRd;\n  w = roomRd * tan (pi / nw);\n  d = max (q.x, - PrBox2Df (q.yz, vec2 (roomHt - 0.2, w - 0.2)));\n  DMIN (idFrm);\n  d = q.x + 0.25;\n  DMIN (idWl);\n  d = roomHt - abs (q.y);\n  DMIN (idFlrCl);\n  q = p;\n  q.y -= 1.;\n  d = PrCylDf (q.xzy, 0.6, 0.02);\n  DMIN (idTbl);\n  q = p;\n  q.y -= 0.5;\n  q.xz += 0.02 * sin (7. * pi * q.y + vec2 (0.5 * pi, 0.));\n  d = PrCylDf (q.xzy, 0.03, 0.5);\n  DMIN (idLeg);\n  q = p;\n  d = PrCylDf (q.xzy, 0.2, 0.04 * (1. - 0.6 * smoothstep (0.1, 0.2, length (q.xz))));\n  DMIN (idLeg);\n  q = p - dukPos;\n  dMin = DuckDf (q, dMin);\n  if (! isSh) {\n    q = p;\n    q -= ltPos;\n    d = PrSphDf (q, 0.1);  \n    DMIN (idLit);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.001 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd, float ltDist)\n{\n  vec3 p;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    p = ro + d * rd;\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.03 * d, h));\n    d += clamp (h, 0.02, 0.2);\n    if (sh < 0.05 || d > ltDist) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, refCol, vn, ltVec, ltDir, ve;\n  float dstObj, w, sx, ld, sh;\n  const int nRef = 5;\n  sclFac = 0.4;\n  eyePos = vec3 (0.26, 0.825, -0.6);\n  col = vec3 (0.);\n  refCol = vec3 (1.);\n  isSh = false;\n  for (int n = VAR_ZERO; n < nRef; n ++) {\n    dstObj = ObjRay (ro, rd);\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (n < nRef - 1 && dstObj < dstFar && idObj == idWl) {\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n      refCol *= 0.8;\n    } else break;\n  }\n  if (dstObj < dstFar) {\n    if (idObj == idBdy) {\n      w = -0.6 - 1.2 * dot (rd, vn);\n      col4.rgb = mix (HsvToRgb (vec3 (mod (w + 0.3, 1.), 1., 1.)),\n         HsvToRgb (vec3 (mod (w - 0.3, 1.), 1., 1.)), 0.5);\n      col4 = vec4 (mix (HsvToRgb (vec3 (mod (w, 1.), 1., 1.)), col4.rgb, 0.5), 0.2);\n    } else if (idObj == idBk) {\n      col = vec3 (0.3, 0.1, 0.);\n      col4 = vec4 (col, 0.2);\n    } else if (idObj == idEye)  {\n      sx = sign (ro.x);\n      ve = eyePos * sclFac;\n      ve.x *= sx;\n      ve = RotToDirLim (normalize (vuPos - dukPos - ve), vec3 (sx, 0., 0.),\n         ro - dukPos - ve, 0.35 * pi);\n      col4 = vec4 (vec3 (0.5, 1., 0.5) * (1. - 0.9 * step (length (ve.yz) / sclFac, 0.05 +\n         0.01 * SmoothBump (0.25, 0.75, 0.25, mod (8. * atan (ve.z, - ve.y) / pi, 1.)))), -2.);\n    } else if (idObj == idFrm) {\n      col4 = vec4 (0.5, 0.2, 0., 0.1);\n    } else if (idObj == idWl) {\n      col4 = vec4 (0.1, 0.3, 0., 0.);\n    } else if (idObj == idFlrCl) {\n      col4 = (ro.y < roomHt) ? vec4 (0.35, 0.3, 0.2, 0.) : vec4 (0.7, 0.7, 1., 0.);\n    } else if (idObj == idTbl) {\n      col4 = vec4 (0.85, 0.95, 0.9, 0.2);\n      if (vn.y > 0.99) col4 = mix (vec4 (0.5, 0.7, 0.4, 0.1), col4, \n         smoothstep (0.015, 0.02, abs (Fbm2 (vec2 (4., 1.) * ro.xz) - 0.4)));\n    } else if (idObj == idLeg) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idLit) {\n      col4 = vec4 (1., 1., 0.7, -1.);\n    }\n    if (idObj == idFlrCl || idObj == idFrm) vn = VaryNf (32. * ro, vn, 0.2);\n    if (col4.a >= 0.) {\n      isSh = true;\n      ltVec = ltPos - ro;\n      ld = length (ltVec);\n      ltDir = ltVec / ld;\n      if (idObj == idBdy) col4.rgb = mix (vec3 (0.5, 0.3, 0.3), col4.rgb,\n         smoothstep (-0.2, 0.2, dot (vn, ltDir)));\n      sh = ObjSShadow (ro + 0.01 * vn, ltDir, ld);\n      col = refCol * (col4.rgb * (0.2 + 0.3 * max (- dot (vn, ltDir), 0.) +\n         0.8 * sh * max (dot (vn, ltDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (0., dot (ltDir, reflect (rd, vn))), 32.));\n    } else if (col4.a == -1.) col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    else if (col4.a == -2.) col = col4.rgb;\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, u, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr, ltAz, ltEl;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = -0.5 * pi;\n  el = -0.05 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az -= 2. * pi * sin (0.005 * pi * tCur);\n  }\n  el = clamp (el, -0.35 * pi, 0.35 * pi);\n  roomRd = 6.;\n  roomHt = 2.;\n  ro = vec3 (0.6 * roomRd * cos (el) * sin (az + vec2 (0.5 * pi, 0.)),\n     0.9 * roomHt * sin (el)).xzy;\n  ro.y += roomHt;\n  dukPos = vec3 (0., 1.21, 0.);\n  vd = normalize (dukPos - ro);\n  u = - vd.y * vd;\n  vuMat = mat3 (vec3 (vd.z, 0., - vd.x) / sqrt (1. - vd.y * vd.y),\n     vec3 (u.x, 1. + u.y, u.z) / sqrt (1. - vd.y * vd.y), vd);\n  vuPos = ro;\n  zmFac = 3.;\n  dstFar = 20.;\n  ltAz = 0.1 * pi * tCur;\n  ltEl = 0.15 * pi * sin (2.3 * ltAz);\n  ltPos = vec3 (0.5 * roomRd * cos (ltEl) * sin (ltAz + vec2 (0.5 * pi, 0.)),\n     0.8 * roomHt * sin (ltEl)).xzy;\n  ltPos.y += 1.4 * roomHt;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec3 RotToDirLim (vec3 v1, vec3 v2, vec3 p, float aMax)\n{\n  vec3 n;\n  float c;\n  n = normalize (cross (v1, v2));\n  c = max (dot (v1, v2), cos (aMax));\n  return c * p + sqrt (1. - c * c) * cross (n, p) + (1. - c) * dot (n, p) * n;\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  return c.z * mix (vec3 (1.), clamp (abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.) - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e;\n  e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttSyzh.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[990, 990, 1025, 1025, 2245], [2247, 2247, 2269, 2269, 3122], [3124, 3124, 3157, 3157, 3340], [3342, 3342, 3363, 3363, 3618], [3620, 3620, 3671, 3671, 3954], [3956, 3956, 3991, 3991, 6660], [6662, 6662, 6718, 6718, 8274], [8276, 8276, 8309, 8309, 8398], [8400, 8400, 8433, 8433, 8460], [8462, 8462, 8504, 8504, 8555], [8557, 8557, 8592, 8592, 8654], [8656, 8656, 8700, 8700, 8775], [8777, 8777, 8822, 8822, 8925], [8927, 8927, 8984, 8984, 9067], [9069, 9069, 9126, 9126, 9300], [9302, 9302, 9332, 9332, 9445], [9447, 9447, 9478, 9478, 9542], [9544, 9544, 9568, 9568, 9685], [9719, 9719, 9743, 9743, 9855], [9857, 9857, 9882, 9882, 10068], [10070, 10070, 10091, 10091, 10246], [10248, 10248, 10277, 10277, 10489], [10491, 10491, 10530, 10530, 10715]], "test": "untested"}
{"id": "ttScRh", "name": "Logic vs Math", "author": "Oggbog", "description": "Hello, just a quick question. Which method of drawing a square is more efficient? Logic or Math? I've included a bit of domain distortion to see the effect on both methods.", "tags": ["question"], "likes": 0, "viewed": 238, "published": 3, "date": "1593682515", "time_retrieved": "2024-07-30T20:58:01.077672", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    // simple domain distortion\n    uv.y += sin(uv.x*40.+iTime*4.)*.05;\n    \n\t// logic square\n    float s1 = (uv.x>-0.4 && uv.x<-0.2 && uv.y>-.1 && uv.y<0.1) ? 1.0 : 0.0;\n    \n    // math square\n    float s2 = step(0.2,uv.x) - step(0.4,uv.x);\n    s2 *= step(-0.1,uv.y) - step(0.1,uv.y);\n    \n    \n    fragColor = vec4(s1,s2,0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttScRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 458]], "test": "untested"}
{"id": "3lSyz1", "name": "utils: golfed transforms", "author": "FabriceNeyret2", "description": "Rotation , angle vector , hue , iso-triangle tilings (coords, id)...", "tags": ["glsl", "rotation", "hls", "golfing", "shortest", "hexatiling"], "likes": 19, "viewed": 525, "published": 3, "date": "1593670360", "time_retrieved": "2024-07-30T20:58:02.031122", "image_code": "#define rot(a)   mat2( cos( a + vec4(0,33,11,0)) )      // https://www.shadertoy.com/view/XlsyWX \n#define CS(a)    cos( a + vec2(0,11) )                  // https://www.shadertoy.com/view/XlsyWX \n#define hue(h)   .6 + .6 * cos( h + vec4(0,23,21,0)  )  // h = [0,2Pi]  https://www.shadertoy.com/view/ll2cDc\n#define hGrid(U) vec4( U *= mat2(6, 0, 3, 5) , U-U.y )  // https://www.shadertoy.com/view/Wl2yRz\n                        // normalized: mat()/6.\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = 2.*u/R.y, I = floor(U); U -= I+.5;              // subwindow coords\n    int  i = int(I+3.*I.y);                                  // subwindow Id\n    float t = iTime;\n   \n    O =  i < 2 ? U-=.2*t, O = fract( hGrid(U) ),             // isoTriangle grid\n          i==0 ? O                                           // local coords\n               :( O.xxxx - O.y ) / .1                        // tiling\n        : i==2 ? vec4( length(  U*rot(t) - .2* U/U ) / .1 )  // point rotation\n        : i==3 ? vec4( dot( U, CS(t) ) / .1 )                // direction rotation\n        : i==4 ? hue( 6.3*length(U) - t )                    // concentric hue\n        : i==5 ? hue( atan(U.y,U.x) - t )                    // radial hue\n        :        hue( dot( ceil(hGrid(U)), vec4(1,7,9,0) ) -t ); // isoTriangle Ids\n}                                // 'uniq' id:  1,10,100 or dot(xy,(1,10)) *2 + z%2", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyz1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[427, 451, 489, 489, 1332]], "test": "untested"}
{"id": "3tByR1", "name": "simple clock", "author": "jason82", "description": "thanks: iq and FabriceNeyret2", "tags": ["2d", "sdf", "line", "clock"], "likes": 9, "viewed": 370, "published": 3, "date": "1593669727", "time_retrieved": "2024-07-30T20:58:02.898803", "image_code": "#define cycle 1.5\n#define scale 0.8\n#define bg vec3(0, 0.6627451, 0.6196078)\n#define PI 3.1415926\n#define PI2 6.2831853\n\nmat2 rotate(float deg) {\n  return mat2(cos(deg), sin(deg), -sin(deg), cos(deg));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b, float width, float blur) {\n  vec2 pa = p - a;\n  vec2 ba = b - a;\n  vec2 dir = normalize(ba);\n  float t = clamp(dot(pa, dir), 0., length(ba));\n  float dist = length(pa - dir * t);\n  return smoothstep(width - blur, width, dist);\n}\n\nvec3 hourPointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 12.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.03) * m, vec2(0,0.3) * m, 0.02, 0.005);\n  color = mix(vec3(0), color, d);\n  return color;\n}\nvec3 minutePointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 60.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.04) * m, vec2(0,0.4) * m, 0.015, 0.005);\n  color = mix(vec3(0), color, d);\n  return color;\n}\nvec3 secondPointer(vec2 uv, vec3 color, float time) {\n  float rate = fract(time / 60.0);\n  mat2 m = rotate(rate * PI2);\n  float d = line(uv, vec2(0,-0.05) * m, vec2(0,0.5) * m, 0.005, 0.005);\n  color = mix(vec3(0.9921568,0.0666667,0.0666667), color, d);\n  return color;\n}\n\nfloat circle(vec2 p, vec2 c, float radius, float blur) {\n  vec2 pc = p - c;\n  float dist = length(pc);\n  return smoothstep(radius - blur, radius, dist);\n}\n\nvec3 plate(vec2 uv, vec3 color) {\n  float d1 = circle(uv, vec2(0), 0.7, 0.005);\n  float d2 = circle(uv, vec2(0), 0.63, 0.005);\n\n  color = mix(vec3(0.4039215, 0.8235294, 0.7843137), color, d1);\n  color = mix(vec3(1), color, d2);\n\n  float r = length(uv);\n  float a = atan(uv.x, uv.y);\n  float ss = PI / 30.;\n  float hs = PI / 6.;\n  float st = fract(a / ss);\n  float mst = min(abs(1.-st), st);\n  float ht = fract(a / hs);\n  float mht = min(abs(1.-ht), ht);\n\n  if (r > 0.58 && r < 0.6 && mst < 0.06) {\n    float sd = smoothstep(0.06 - 0.03, 0.06, mst);\n    color = mix(vec3(0), color, sd);\n  }\n  if (r > 0.55 && r < 0.6 && mht < 0.1) {\n    float hd = smoothstep(0.1 - 0.03, 0.1, mst);\n    color = mix(vec3(0), color, hd);\n  }\n\n  return color;\n}\n\nvec3 shadow(vec2 uv, vec3 color, vec2 c, vec2 d, float dist) {\n  d = normalize(d);\n  float l = dot(uv, d);\n  float w = length(uv - d * l);\n  float rate = l / dist;\n  if (w > 0.7 || rate <= 0. || rate >= 1.) return color;\n\n  vec3 pm = mix(color, vec3(0), 0.12);\n  color = mix(pm, color, rate);\n  return color;\n}\n//t = iDate.w/60., m = floor(t)/60.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / min(iResolution.y, iResolution.x);\n  uv /= scale;\n\n    \n  float iSecond = iDate.w;\n  float iMinute = iSecond/60.;\n  float iHour = iMinute/60.;\n\n  // animate\n  float tt = mod(iTime, cycle) / cycle;\n  float ss = 1.0 + 0.5 * sin(tt * PI * 6.0 + uv.y * 0.5) * exp(-tt * 4.0);\n  uv *= vec2(0.7, 1.5) + ss * vec2(0.3, -0.5);\n\n  // mix some color\n  vec3 color = bg;\n  color = plate(uv, color);\n  color = hourPointer(uv, color, iHour);\n  color = minutePointer(uv, color, iMinute);\n  color = secondPointer(uv, color, iSecond);\n  color = shadow(uv, color, vec2(0), vec2(1, -1), 1.4);\n\n  // Output to screen\n  fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByR1.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[121, 121, 145, 145, 203], [205, 205, 266, 266, 468], [470, 470, 521, 521, 710], [711, 711, 764, 764, 954], [955, 955, 1008, 1008, 1226], [1228, 1228, 1284, 1284, 1382], [1384, 1384, 1417, 1417, 2124], [2126, 2126, 2188, 2188, 2436], [2475, 2475, 2532, 2580, 3263]], "test": "untested"}
{"id": "3lByzh", "name": "Jagarikin illusion 2", "author": "ciphered", "description": "Highly inspired by the work of Jagarikin\nhttps://twitter.com/jagarikin", "tags": ["illusion", "opart", "jagarikin"], "likes": 4, "viewed": 430, "published": 3, "date": "1593654074", "time_retrieved": "2024-07-30T20:58:03.852253", "image_code": "//\n// Highly inspired by the work of Jagarikin\n// https://twitter.com/jagarikin\n//\n// \n//\n\n#define DELAY .1\n#define PI 3.1415927\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n\n// @author Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// His color interpolation just works so well with this illusion !\nvec3 rainbow (float h) {\n\tvec4 O = mod(vec4(1,2,3,0)-3.*h, 3.); O = min(O,2.-O);     // linear rainbow\n  \tO = .5+.5*cos(6.283185*(h +vec4(0,1,-1,0)/3.));       // 1/j/j² rainbow \n    //O = pow(max(O,0.),vec4(1./2.2));\t\t// gamma correction\n    return O.rgb;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float T = iTime * .1;\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    uv*= 3.;\n    \n    \n    float L = length(uv);\n    float An = atan(uv.y, uv.x)*10. + sin(L*(clamp(cos(T*2.), -.2, .2)-.2)*10.)*5.;\n    float B = mod(An, 2.*PI) / (2.*PI) - .5;\n    vec2 id = vec2(floor(abs(An)/(PI*2.) - .5), floor((L-.5)*3.));\n    float S = cos(An) * .5 + .5;\n    \n    float C = smoothstep(.7, .8, S);\n    float Lt = smoothstep(.6, .62, S) - C;\n    \n    float A = step(abs(cos(L*10.)), .5);\n    C*= A;\n    Lt*= A;\n    \n    T*=  10.;\n    T+= (-id.y * .08 + id.x * (.08 + cos(iTime*.1)*.05)) * min(iTime/60., 1.);\n    vec3 cC = rainbow(T);\n    vec3 cLt = rainbow(T + DELAY*sign(B));\n\n\n    vec3 col = vec3(.5);\n    \n    col = mix(col, cC, C);\n    col = mix(col, cLt, Lt);\n\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lByzh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 320, 344, 344, 579], [583, 583, 640, 640, 1456]], "test": "untested"}
{"id": "3tByRh", "name": "Jagarikin illusion", "author": "ciphered", "description": "This work was sort of a test to see if I could reproduce one of the many amazing illusions from Jagarikin.\nMore of his work: https://twitter.com/jagarikin\nColor linear interpolation by Fabrice Neyret", "tags": ["illusion", "perception", "opart", "jagarikin"], "likes": 5, "viewed": 581, "published": 3, "date": "1593645483", "time_retrieved": "2024-07-30T20:58:04.785757", "image_code": "//\n// Very highly inspired by the work of Jagarikin \n// https://twitter.com/jagarikin\n//\n// I basically took his concept to understand how it could be implemented, before going into\n// further exploration. Please go check his work if you liked this one !\n//\n// From my understanding, the illusion of a motion comes from the shift in hue being applied\n// width a small offset on the borders. The brain was trained in extracting motion using the\n// colors, because usually in real life objects do not tend to change color, therefore a \n// change in color at a particular point is often due to a motion at the point. When an object\n// moves, a color on its surface is supposed to follow the motion of the object in the world \n// referential.\n//\n// I took the rainbow color interpolation from Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// The color transitions are just so smooth and work so well in this context. Thanks to him !\n//\n\n#define PI 3.14159265359\n#define DELAY 0.17\n#define SIZE 0.15\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\n\n\n// @author Fabrice Neyret \n// https://www.shadertoy.com/view/MtG3Wh\n// His color interpolation just works so well with this illusion !\nvec3 rainbow (float h) {\n\tvec4 O = mod(vec4(1,2,3,0)-3.*h, 3.); O = min(O,2.-O);     // linear rainbow\n  \tO = .5+.5*cos(6.283185*(h +vec4(0,1,-1,0)/3.));       // 1/j/j² rainbow \n    //O = pow(max(O,0.),vec4(1./2.2));\t\t// gamma correction\n    return O.rgb;\n}\n\n// some sort of lerp r g b r\n// looks bad\nvec3 hsv2rgb(float h)\n{\n    h = mod(h, 1.);\n    vec3 c1 = vec3(1,0,0);\n    vec3 c2 = vec3(0,1,0);\n    vec3 c3 = vec3(0,0,1);\n    return h < .33 ? mix(c1, c2, h/.33) : \n    \th < .66 ? mix(c2, c3, (h-.33)/.33)\n        : mix(c3, c1, (h-.66)/.33);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // time\n    float t = iTime * .9;\n    \n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    uv*= iResolution.y * .01;\n    vec2 id = floor(uv);\n    uv = fract(uv) - .5;\n    uv*= rot(clamp(cos(t*.3), -.2, .2)/.2*PI*.25+ id.x*id.y);\n    // square\n    vec2 s = smoothstep(SIZE, SIZE-0.01, abs(uv));\n    float sq =  s.x * s.y;\n    \n    float hueShift = (id.x*id.y)*.04 * pow(min(1., iTime/60.), 3.5);\n    \n    // left border\n    s = smoothstep(SIZE, SIZE-0.01, abs(uv + vec2(.03, 0)));\n    float lf = min(s.x * s.y, 1.-sq);\n    float lfH = t + DELAY + hueShift;\n    vec3 lfC = rainbow(lfH);\n    \n    // right border\n    s = smoothstep(SIZE, SIZE-0.01, abs(uv - vec2(.03, 0)));\n    float rt = min(s.x * s.y, 1.-sq);\n    float rtH = t - DELAY + hueShift;\n    vec3 rtC = rainbow(rtH);\n    \n    float ch = t + hueShift;\n    vec3 c = rainbow(ch);\n    \n\n    vec3 col = vec3(.5);\n    \n    col = mix(col, c, sq);\n    col = mix(col, lfC, lf);\n    col = mix(col, rtC, rt);\n\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tByRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1063, 1198, 1222, 1222, 1457], [1459, 1501, 1524, 1524, 1746], [1749, 1749, 1806, 1818, 2816]], "test": "untested"}
{"id": "3tBcRh", "name": "Barycentric Equithirds", "author": "mla", "description": "Another equithirds substitution tiling...", "tags": ["barycentric", "tiling", "substitution", "equithirds"], "likes": 7, "viewed": 319, "published": 3, "date": "1593640440", "time_retrieved": "2024-07-30T20:58:05.536749", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Equithirds tiling with barycentric coords, mla, 2020\n//\n// https://tilings.math.uni-bielefeld.de/substitution/equithirds/\n//\n// Given points p,q,r, the centroid is at (p+q+r)/3 and the trisectors\n// of side pq are (p+2q)/3, (2p+q)/3. These are the points needed to\n// recursively construct the equithirds tiling, and the rest is just\n// bookkeeping. We could reuse the current barycentric coords for the\n// subdivided triangle, but for simplicity we recalculate them each time\n// around. And not a trig function to be seen.\n//\n// See also:\n// https://www.shadertoy.com/view/WtSczR by jeyko\n// https://www.shadertoy.com/view/WlfGWN by fizzer\n//\n////////////////////////////////////////////////////////////////////////////////\n\nvoid getbary(vec2 z, vec2 p, vec2 q, vec2 r, out float a, out float b, out float c) {\n  // Thanks to wikipedia\n  mat2 t = mat2(p-r,q-r);\n  vec2 lam = inverse(t)*(z-r);\n  a = lam.x; b = lam.y; c = 1.0-a-b;\n}\n\nfloat linedist(vec2 p, vec2 a, vec2 b) {\n  vec2 pa = p-a;\n  vec2 ba = b-a;\n  float h = dot(pa,ba)/dot(ba,ba);\n  return length(pa-ba*h);\n}\n\nint tiling(vec2 z, int iterations, vec2 p, vec2 q, vec2 r, out float d) {\n  int state = 0;\n  for (int i = 0; i < iterations; i++) {\n    float a,b,c;\n    getbary(z,p,q,r,a,b,c);\n    if (state == 0) {\n      vec2 s = (p+q+r)/3.0;\n      if (a < b && a < c) {\n        p = s; // q,r stay same\n      } else if (b < a && b < c) {\n        q = r; r = p; p = s;\n      } else {\n        r = q; q = p; p = s;\n      }\n      state = 1;\n    } else {\n      vec2 s = (r+2.0*q)/3.0;\n      vec2 t = (q+2.0*r)/3.0;\n      if (b > 2.0*c) {\n        r = q; q = p; p = s;\n      } else if (c > 2.0*b) {\n        q = r; r = p; p = t;\n      } else {\n        q = s; r = t;\n        state = 0;\n      }\n    }\n  }\n  d = min(linedist(z,p,q),\n          min(linedist(z,q,r),\n              linedist(z,r,p)));\n              \n  return state;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  float k = 5.0;\n  vec2 p = k*vec2(0,1), q = k*vec2(0.5*sqrt(3.0),-0.5), r = k*vec2(-0.5*sqrt(3.0),-0.5);\n  vec3 col = vec3(0);\n  int iterations = 2+int(iTime)%12;\n  float d;\n  int t = tiling(z,iterations,p,q,r,d);\n  float lwidth = 0.1*exp2(-0.5*float(iterations));\n  if (t == 0) col = vec3(1,0,0);\n  else col = vec3(0,1,1);\n  col = mix(vec3(1),col,0.8);\n  col *= smoothstep(0.5*lwidth,lwidth,d);\n  fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3tBcRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[813, 813, 898, 923, 1019], [1021, 1021, 1061, 1061, 1158], [1160, 1160, 1233, 1233, 1961], [1963, 1963, 2020, 2020, 2503]], "test": "untested"}
{"id": "WlByRh", "name": "Yet another jungle fractal", "author": "jarble", "description": "This fractal's surface is colored using its signed distance function.", "tags": ["3d", "raymarching", "fractal", "jungle"], "likes": 2, "viewed": 319, "published": 3, "date": "1593639175", "time_retrieved": "2024-07-30T20:58:06.358552", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    p /= 5.0;\n    p = sin(p/20000.0)*20000.0;\n    vec3 p1 = p/size;\n    p = (sin(p1/vec3(length(sin(p1/10.0)))))*size;\n    return length(p) - size/2.0;\n}\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n\n    float result = planet_surface(p);\n    for(float i = 10.0; i < 100.0; i *= 10.0){\n    \tresult -= planet_surface(p*i)/i;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale*50.0;\n    //p += animate(p);\n    //p /= 50.0;\n    return sin(vec3(sceneSDF(p+1.0,0.0)*2.0,sceneSDF(p+2.0,0.0)*2.0,sceneSDF(p+3.0,0.0)))/5.0+vec3(.0,.5,.0);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*scale)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = 120.0*scale*vec3(sin(iTime/speed), sin(iTime/speed), cos(iTime/speed))*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "sound_code": "// http://countercomplex.blogspot.jp/2011/10/algorithmic-symphonies-from-one-line-of.html\n// http://wurstcaptures.untergrund.net/music/\n\nvec2 sound1( float time )\n{\n    int t = int(time * 8000.0);\n    t = (t>>4&t*5&t/1024)-1;\n    return vec2(float(t & 0xff - 128) / 128.);\n}\n\nvec2 mainSound( in int samp,float time){\n    float factor = 4.0;\n    vec2 result = vec2(0.0);\n    for(int i = 0; i < 5; i++){\n        //if(i>3){\n        \tresult += sound1(time*factor);\n        //}\n        factor *= 3.1/(result.y+result.x);\n    }\n    return result/1500.0;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlByRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[522, 522, 551, 551, 705], [708, 708, 743, 743, 978], [980, 980, 1003, 1003, 1030], [1032, 1032, 1060, 1060, 1233], [1236, 1657, 1748, 1748, 2115], [2130, 2384, 2449, 2449, 2581], [2583, 2672, 2701, 2701, 3011], [3013, 3505, 3645, 3645, 4255], [4257, 4627, 4712, 4712, 5059], [5061, 5388, 5437, 5472, 5603], [5605, 5605, 5662, 5662, 6618]], "test": "untested"}
{"id": "3lSyRh", "name": "Socolar-C5-var tiling [Day 194]", "author": "jeyko", "description": "Derp", "tags": ["tiling", "aperiodic", "mdtmjvm", "socolar"], "likes": 23, "viewed": 502, "published": 3, "date": "1593638332", "time_retrieved": "2024-07-30T20:58:07.095582", "image_code": "// This is Socolar-C5 but with mirror simmetry added in the first rule\n\n// Mostly mathematically correct with some number crunching (about 20%) \n// https://tilings.math.uni-bielefeld.de/substitution/socolar-c5/\n\n// Substitution tilings are super fun stuff\n// Although they may seem a bit intimidating, because they,\n// I think starting one from scratch is a good way to get started,\n// because code can get... uh... convoluted, like here.\n\n#define rot(j) mat2(cos(j),-sin(j),sin(j),cos(j))\n#define pi acos(-1.)\n#define tau (2.*pi)\n\n\nfloat sdEquilateralTriangle(  vec2 p, float r ){   \n    r = r*1./3.;\n\tp.y -= r;\n    p.y += r*1.5;\n    float d = dot(vec2(abs(p.x),p.y) - -normalize(vec2(0.,1)*rot(tau/3.))*(r), -normalize(vec2(0.,1)*rot(tau/3.)));\n    d = max(d,p.y - r*2.);\n    d = max(d,-p.y - r);\n    return d;\n}\n\nfloat sdRhombus( vec2 p, float height, float angleHoriz, float angleVert ){\n\n    float hypothenuse = sin(pi/2.)*height*0.5/sin(angleHoriz/2.);\n    float base = sin( angleVert/2.)*hypothenuse/sin(pi/2.);\n\t\n    float triarea = height*0.5*base*0.5;\n    float triheight = triarea*2./hypothenuse;\n    \n    float triAngle = asin(triheight*sin(pi/2.)/base);\n    vec2 hdir = vec2(0.,1.)*rot(-triAngle);\n    p = abs(p);    \n    p -= normalize(hdir)*triheight/1.;\n    \n\treturn dot(p,vec2(0.,1.)*rot( -triAngle));\n}\n        \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 col = vec3(0);\n    \n    \n    float id = 0.;\n    float iters = 5.;\n    \n    float d = 10e5;\n    \n    float s = 1.;\n\n    uv += vec2(sin(iTime/2.6  + cos(iTime/4.)),cos(iTime/2. + sin(iTime/4.)))*0.2;    \n    uv *= 0.7;\n    \n    \n    vec2 p = uv;\n    float sc = 1.;\n    \n    float palvar = 1.;\n    \n    float lside = 2.;\n    float lsplithoriz = 2.35 ; // 2.35 is totally crunched\n    \n    \n    float avert = 2.*( asin( lsplithoriz*0.5*sin(pi/2.)/lside) );\n    float ahoriz = (tau - 2.*avert)/2.;\n    \n    float ahorizb = avert/2.;\n    float avertb = (tau - ahorizb*2.)/2.;\n    \n    float lsplitvert = 2.*sin(ahoriz/2.)*lside/sin(pi/2.);\n    \n    float ratiosidevert = lside/(lside + lsplitvert);\n    \n    float ratiohorizvert = lsplithoriz/(lsplithoriz + lsplitvert);\n    \n    float lsidesmall = lside * ratiosidevert;\n    \n    float lsplitvertsmall = lside - lsidesmall;\n    \n    float lsplithorizsmall = lsplitvertsmall*ratiohorizvert;\n    float lsplitvertb = lsplitvertsmall*1./2.62; // last minute crunch from 2.6 to 2.62?\n    \n    \n    for(float i = 0.; i < iters; i++){\n    \tfloat Llside = lside * sc;\n    \t\n        float Llsplithoriz = lsplithoriz * sc;\n    \n        float Llsplitvert = lsplitvert * sc;\n    \n    \tfloat Lratiosidevert = ratiosidevert * sc;\n    \n    \tfloat Lratiohorizvert = ratiohorizvert * sc;\n    \n    \tfloat Llsidesmall = lsidesmall * sc;\n    \n    \tfloat Llsplitvertsmall = lsplitvertsmall * sc;\n    \n    \tfloat Llsplithorizsmall = lsplithorizsmall * sc;\n    \n    \tfloat Llsplitvertb = lsplitvertb * sc;\n        \n        if(id == 0.){\n        \tfloat drh = sdRhombus(p, Llsplitvert, ahoriz, avert );\n        \n            vec2 pb = p + vec2(0,Llsplitvert*0.5 - Llsplitvertsmall/2.);\n\n            float drhb = sdRhombus(pb, Llsplitvertsmall, ahoriz, avert );\n\n            p.x = abs(p.x);\n            vec2 pc = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pc.y += Llsplitvertsmall*0.495; // some crunch here\n            mat2 pcr = rot(avert*0.5*6.); \n            pc *= pcr;\n            pc.y -= Llsplitvertsmall*0.503;\n            float drhc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pd.y += Llsplitvertsmall*0.5;\n            mat2 pdr = rot(-avert/1.);\n            pd *= pdr;\n            pd.y -= Llsplitvertsmall*0.5;\n\n            float drhd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = p + vec2(0. - Llsplithoriz*0.5, - Llsplitvertsmall*0.5);\n            pe.y += Llsplitvertsmall*0.5;\n            mat2 per = rot(-avert/1.);\n            pe *= per;\n            pe.y -= Llsplitvertsmall*1.;\n\n            pe.x -= Llsplithorizsmall*0.862;\n\n            float drhe = sdRhombus( pe, Llsplitvertsmall, ahoriz, avert );\n\n            \n            vec2 pba = p;\n            pba.x -= Llsplitvertb/2.125;\n            pba.y += Llsplitvertb/1.55;\n\n            pba *= rot(ahoriz/1.5);\n                        \n            float drhba = sdRhombus( pba, Llsplitvertb, ahorizb, avertb );\n\n\n\n\n            d = min(d, abs(drh));\n            d = min(d, abs(drhb));\n            d = min(d, abs(drhc));\n            d = min(d, abs(drhd));\n            d = min(d, abs(drhe));\n            d = min(d, abs(drhba));\n            \n\n            if (drhb < 0.) {\n                p = pb;\n            } else if (drhc < 0.) {\n                p = pc;\n            } else if (drhd < 0.) {\n                p = pd;\n            } else if (drhe < 0.) {\n                p = pe;\n            } else if (drhba < 0.) {\n                p = pba;\n            } else {\n                break;\n            }\n\n            if ( drhb < 0. || drhc < 0. || drhd < 0. || drhe < 0. ){\n\t\t\t\tid = 0.;\n                palvar += 0.4;\n            } else {\n                palvar += 2.1;\n\t\t\t\tid = 1.;\n\t\t\t}\n            sc *= lsplitvertsmall/lsplitvert;\t\n        } else if (id == 1.) {\n            \n            p *= rot(1.*pi);\n            \n            p.y = abs(p.y);\n            //p*=0.5;\n            vec2 pa = p*1.;\n            float dra = sdRhombus( pa, Llsplitvertb, ahorizb, avertb );\n\t\t\t\n            vec2 pb = p;\n            float drb = sdRhombus( pb, Llsplitvertsmall, ahoriz, avert );\n            \n            \n            vec2 pc = p;\n            pc.y += 0.5*Llsplitvertsmall;\n            pc *= rot(avert);\n            pc.y -= 0.5*Llsplitvertsmall;\n            float drc = sdRhombus( pc, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pd = pc;\n            pd.y -= 0.62*Llsplitvertsmall;\n            \n            pd.y -= 0.5*Llsplitvertsmall;\n            pd *= rot(avert/2.);\n            \n            pd.y += 0.5*Llsplitvertsmall;\n            \n            float drd = sdRhombus( pd, Llsplitvertsmall, ahoriz, avert );\n\n            vec2 pe = pc;\n            \n            pe.y -= 0.5*Llsplitvertsmall;\n            \n            pe *= rot(-ahorizb);\n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            pe.x += 0.58*Llsplitvertsmall;\n            \n            float dre = sdRhombus( pe, Llsplitvertb, ahorizb, avertb );\n\n            vec2 pf = p;\n            \n            pf.y -= 0.505*Llsplitvertsmall;\n            pf *= rot(-ahorizb);\n            \n            pf.x += 0.58*Llsplitvertsmall;\n            \n            //pe.x += Llsplithorizb*lsplithorizsmall/lsplithoriz/0.75;\n            //pe.x += 0.58*Llsplitvertsmall*lsplitvertsmall/lsplitvert;\n            \n            float drf = sdRhombus( pf, Llsplitvertb, ahorizb, avertb );\n\n            \n\t\t\t\n            //d = min(d, abs(dra));\n            \n            d = min(d, abs(drb));\n            d = min(d, abs(drc));\n            d = min(d, abs(drd));\n            d = min(d, abs(dre));\n            d = min(d, abs(drf));\n            \n            \n\t\t\tif (drb < 0.) {\n                p = pb;\n            } else if (drc < 0.) {\n                p = pc;\n            } else if (drd < 0.) {\n                p = pd;\n            } else if (dre < 0.) {\n                p = pe;\n            } else if (drf < 0.) {\n                p = pf;\n            } else  {\n                break;\n            }\n\n            if ( drb < 0. || drc < 0. || drd < 0.){\n\t\t\t\tid = 0.;\n                palvar += 1.1;\n            } else if ( dre < 0. || drf < 0.) {\n\t\t\t\tid = 1.;\n                palvar += 2.1;\n            } else {\n            \tbreak;\n            }\n            sc *= lsplitvertsmall/lsplitvert;\n            \n            \n        }\n            \n    }\n    \n    \n    #define pal(a,b,c,d,e) (a + b*sin(c*d + e))\n    \n    col = mix(col,pal(0.5,0.56,vec3(3.,0.7,0.2),3.4, palvar + iTime + uv.x/2. + uv.y/2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    //col = mix(col,pal(0.5,0.56,vec3(2.,0.7,0.2),1., palvar + iTime + uv.x*2. + uv.y*2.)/1.,smoothstep(dFdx(uv.x),0.,-d));\n    \n    \n    d = abs(d);\n    \n    float w = 0.0002;\n    col = mix(col,vec3(0.04),smoothstep(dFdx(uv.x) + w, w,d));\n    \n    \n    col = pow(col,vec3(0.454545));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3lSyRh.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[533, 533, 581, 581, 814], [816, 816, 891, 891, 1320], [1331, 1331, 1388, 1388, 8395]], "test": "untested"}
{"id": "wljcRz", "name": "Bamboo lattice", "author": "jarble", "description": "This fractal resembles a lattice made of bamboo.\nUse the mouse to look around.", "tags": ["3d", "raymarching", "fractal"], "likes": 8, "viewed": 350, "published": 3, "date": "1593626441", "time_retrieved": "2024-07-30T20:58:07.955283", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += animate(p,iTime)*anim;\n\n    float result = planet_surface(p);\n    for(float i = 2.0; i < 8.0; i *= 2.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale-0.2;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= scale;\n    p += animate(p,iTime);\n    p /= 200.0;\n    return sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.001)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec3 depth_map(vec2 coord){\n    return texture(iChannel0, vec2((coord.x-image_scale/2.0)/iResolution.x/image_scale, (coord.y-image_scale/2.0)/iResolution.y/image_scale)).xyz;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float speed = 10.0;\n\tvec3 eye = vec3(53.0);\n    \n    vec3 p = depth_map(fragCoord);\n    vec3 worldDir = normalize(p-eye);\n    float dist = shortestDistanceToSurface(eye, worldDir, length(eye-p), MAX_DIST);\n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    p = eye+dist*worldDir;\n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define image_scale 8.0\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON/10.0; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n float planet_surface(vec3 p){\n    \n    vec3 p1 = p/size;\n    p = (sin(p1.yzx/vec3(1.0,2.0,3.0)))*size;\n    return length(p) - size+10.0;\n}\n\nvec3 animate(inout vec3 p,float t){\n    vec3 a = p.zxy/7000.0+t*2.0;\n    return (sin(a)+cos(a))*500.0;\n}\n", "buffer_a_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nfloat sceneSDF(vec3 p,float anim) {\n    p /= scale;\n    p += animate(p,iTime)*anim;\n\n    float result = planet_surface(p);\n    for(float i = 2.0; i < 8.0; i *= 2.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale-0.2;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth*.001)*image_scale) {\n\t\t\treturn depth;\n        }\n        depth += dist*2.0;\n        //eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tif (fragCoord.x*image_scale<iResolution.x && fragCoord.y*image_scale<iResolution.y){\n    fragCoord *= image_scale;\n    fragCoord += vec2(image_scale/2.0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(53.0);\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n\n    fragColor = vec4(p, 1.0);\n    }\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wljcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[301, 301, 336, 336, 617], [619, 619, 642, 642, 669], [671, 671, 699, 699, 856], [858, 1279, 1370, 1370, 1736], [1751, 2005, 2070, 2070, 2202], [2204, 2293, 2322, 2322, 2632], [2634, 3126, 3266, 3266, 3876], [3878, 4248, 4333, 4333, 4748], [4750, 5077, 5126, 5161, 5292], [5294, 5294, 5321, 5321, 5470], [5472, 5472, 5529, 5529, 6199]], "test": "untested"}
{"id": "tt2yRz", "name": "Logarithmic Moebius Transform 11", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/wlByRR[/url]\n", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 4, "viewed": 310, "published": 3, "date": "1593625048", "time_retrieved": "2024-07-30T20:58:08.772099", "image_code": "// variant of https://shadertoy.com/view/wlBcRR\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n\t     z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n#if 1\n    U *= mat2(z,-z.y,z.x) / dot(U,U);             \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.283 * vec2(6, 1); // n    \n#else\n    U.x +=.022; U *= vec2(1.5,1);                             // test in the plane\n    if(u.x/R.y>sqrt(3.)/2.) return;\n#endif\n  //U *= vec2(10,14.82)/1.43;// /(.5+iMouse.x/R.x);\n    U *= vec2(21./3., 2./sqrt(3.)*9.);                        // thanks Shane !\n    U *= mat2(1,0,.5,sqrt(3.)/2.);                            // triangular mesh\n    z = fwidth(U);\n    I = floor(U); U = fract(U); \n    float s = float(U.x-U.y>0.), v,                           // parallelogram = 2 triangles\n          i = mod( I.x + I.y , 3.), id; \n    I += i==0.? vec2(0) : i==1. ? vec2(1) : vec2(s,1.-s);  id = I.x +7.81*I.y;\n    vec4 V = vec4( 1.-2.*abs(U.x-U.y) , abs(U*2.-1.) , 0 );\n    v = V[i<2. ? 2-int(i+s)%2 : 0 ];\n    U = i==0. ? U : i==1. ? 1.-U : s==0.?vec2(U.x,U.y-1.):vec2(1.-U.x,-U.y);\n    U *= inverse(mat2(1,0,.5,sqrt(3.)/2.));\n\n    O  = smoothstep(.7,-.7,(length(U)-.95)/( abs(z.x-z.y)>1.?.1:z.y*2.))\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n    if (fract(iTime/6.)<.4) O += smoothstep(-.7,.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*4.));  // draw AA tiles\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 1612]], "test": "untested"}
{"id": "wtjczR", "name": "Möbius Spiral with Hex Grid", "author": "mla", "description": "Inverts at mouse position (so you can get to see both poles).\n\ncf. [url]https://www.shadertoy.com/view/wlByRR[/url]", "tags": ["spiral", "mobius", "complex", "atanh"], "likes": 16, "viewed": 545, "published": 3, "date": "1593620782", "time_retrieved": "2024-07-30T20:58:09.572958", "image_code": "////////////////////////////////////////////////////////////////////////////////\n//\n// Complex log with hex grid\n//\n// mla, 2020\n//\n// Complex log maps the strip with -PI < Im(z) < PI to the complex\n// plane with a branch cut on the negative real axis (for log).\n// A transformed pattern that repeats vertically with a\n// period of 2PI will then appear seamless across the branch cut.\n//\n// See eg. https://www.shadertoy.com/view/WdSSWz for the square pattern case.\n// A hexagonal grid is slightly more complicated.\n//\n// 'm' shows transition from x to log(x)\n// 'b' shows untransformed plane\n//\n////////////////////////////////////////////////////////////////////////////////\n\n// Just show the untransformed band between -PI and PI.\nbool showband = false;\n// Do a gradual transition from x to log(x), this disables\n// the inversion as it's too confusing with it.\nbool mixit = false;\n\n// Constants for hexagonal grid\nconst float X = 1.732050808; // sqrt(3)\nconst float Y = 0.577350269; // 1/sqrt(3)\nconst mat2 M = 0.5*mat2(1,-X,1,X);\nconst mat2 Minv = mat2(1,1,-Y,Y);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  showband = key(CHAR_B);\n  mixit = key(CHAR_M);\n  // From start point p in the grid, go A up and B/2 along to\n  // arrive at point q. A and B must be of same parity for\n  // this to work with K = 1.0. Now rotate grid so q is\n  // vertically above p, and scale so the distance between\n  // them is 2PI. K > 1 adds more triangles so all parities\n  // of A and B work (as far as the grid skeleton is concerned).\n  // Not sure of exact relationship between N, the number\n  // of colors, and A,B,K. These all work:\n  //float A = 7.0, B = 4.0, K = 2.0, N = 8.0;\n  float A = 6.0, B = 1.0, K = 6.0, N = 6.0;\n  //float A = 3.0, B = 5.0, K = 3.0, N = 3.0;\n  //float A = 4.0, B = 3.0, K = 2.0, N = 3.0;\n  //float A = 7.0, B = 3.0, K = 4.0, N = 12.0;\n  //float A = 3.0, B = 5.0, K = 1.0 + floor(iTime), N = 3.0; // Test\n\n  float scale = 1.0;\n  if (showband) scale = 4.0;\n    \n  vec2 z = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n  z *= scale;\n\n  vec2 m = vec2(-0.5);\n  if (iMouse.x > 1.0) {\n    m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n    m *= scale;\n  }\n  if (!showband) {\n    z -= m;\n    if (!mixit) z /= dot(z,z);\n    z += m;\n    float t = 1.0;\n    if (mixit) {\n      t = mod(0.2*iTime,4.0);\n      t = min(t,4.0-t);\n        t -= 0.5;\n        t = clamp(t,0.0,1.0);\n    }\n    z = mix(z,clog(z),smoothstep(0.0,1.0,t));\n  }\n\n  vec3 col = vec3(0);\n  z /= PI;\n  if (abs(z.y) < 1.0) {\n    // Alignment of rotated triangular grid.\n    // Rotated grid should fit between -1 < y < 1\n    // with top and bottom edges coherent.\n    vec2 rot = vec2(A,B/X);\n    z = cmul(rot,z);\n    if (!key(CHAR_T)) z.x += 0.1*iTime*length(rot);\n    z *= 0.25*K;\n\n    // Hexagonal grid.\n    z *= X;\n    z.x += 0.5;\n    z = Minv*z; // Convert to square grid\n    ivec2 index = ivec2(floor(z)); // Remember cell in grid\n    z -= floor(z);\n    z = M*z; // Back to triangles\n    z.x -= 0.5;\n\n    // Color from index\n    col = hsv2rgb(vec3(float(index.x+index.y)/N,1,1));\n    bool inlower = z.y < 0.0; // Point is in lower triangle,\n    if (inlower) col *= 0.6;\n    // Shade edges of triangle\n    z = abs(z);\n    float d = z.y;\n    d = min(d,abs(dot(z-vec2(0.5,0),0.5*vec2(X,1))));\n    col *= smoothstep(0.02,0.05,d);\n  }\n  col = pow(col,vec3(0.4545));\n  fragColor = vec4(col,1);\n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "////////////////////////////////////////////////////////////////////////////////\n\nfloat PI = 3.1415929;\n\nvec2 cmul(vec2 z, vec2 w) {\n  return mat2(z,-z.y,z.x)*w;\n}\n\nvec2 cinv(vec2 z) {\n  float t = dot(z,z);\n  return vec2(z.x,-z.y)/t;\n}\n\nvec2 cdiv(vec2 z, vec2 w) {\n  return cmul(z,cinv(w));\n}\n\nvec2 clog(vec2 z) {\n  float r = length(z);\n  return vec2(log(r),atan(z.y,z.x));\n}\n\n// Inverse hyperbolic tangent \nvec2 catanh(vec2 z) {\n  return 0.5*clog(cdiv(vec2(1,0)+z,vec2(1,0)-z));\n}\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb(in vec3 c) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nconst int CHAR_A = 65;\nconst int CHAR_B = 66;\nconst int CHAR_C = 67;\nconst int CHAR_D = 68;\nconst int CHAR_E = 69;\nconst int CHAR_F = 70;\nconst int CHAR_G = 71;\nconst int CHAR_H = 72;\nconst int CHAR_I = 73;\nconst int CHAR_J = 74;\nconst int CHAR_K = 75;\nconst int CHAR_L = 76;\nconst int CHAR_M = 77;\nconst int CHAR_N = 78;\nconst int CHAR_O = 79;\nconst int CHAR_P = 80;\nconst int CHAR_Q = 81;\nconst int CHAR_R = 82;\nconst int CHAR_S = 83;\nconst int CHAR_T = 84;\nconst int CHAR_U = 85;\nconst int CHAR_V = 86;\nconst int CHAR_W = 87;\nconst int CHAR_X = 88;\nconst int CHAR_Y = 89;\nconst int CHAR_Z = 90;\n\n// Macros for use in \"common\" blocks.\n#define key(code) (texelFetch(iChannel3, ivec2((code),2),0).x != 0.0)\n#define store(i,j) (texelFetch(iChannel2, ivec2((i),(j)),0))\n#define keycount(key) (int(store(0,(key)).x))\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtjczR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1069, 1069, 1126, 1126, 3379]], "test": "untested"}
{"id": "tt2yzR", "name": "Iridescent fractal tunnel", "author": "jarble", "description": "This tunnel is based on my [url=https://www.shadertoy.com/view/3tfcD7]fractal city corridor.[/url]", "tags": ["3d", "fractal", "tunnel"], "likes": 1, "viewed": 296, "published": 3, "date": "1593617145", "time_retrieved": "2024-07-30T20:58:10.379801", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\n\nconst int MAX_MARCHING_STEPS = 10000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size+1.0;\n    p = sin(vec3(sin(p1.x*2.0)/p1.x,cos(p1.y*3.0)-p1.y,sin(p1.z)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale*2.0;\n    float result = planet_surface(p);\n    for(float i = 1.0; i < 1000.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(sceneSDF(p+vec3(1.0)),sceneSDF(p+vec3(2.0)),sceneSDF(p+vec3(3.0))))/2.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = eye;\n    vec3 light1Intensity = vec3(.6);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    \n    float speed = 1.0;\n    vec3 eye = scale*vec3(0.0,0.0,iTime*speed)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tt2yzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[585, 585, 614, 614, 749], [751, 751, 775, 775, 1027], [1029, 1029, 1057, 1057, 1161], [1163, 1584, 1675, 1675, 1981], [1996, 2250, 2315, 2315, 2447], [2449, 2538, 2567, 2567, 2877], [2879, 3371, 3511, 3511, 4121], [4123, 4493, 4578, 4578, 5271], [5273, 5600, 5649, 5684, 5815], [5817, 5817, 5874, 5874, 6968]], "test": "untested"}
{"id": "ttjyzR", "name": "Distorsion in colored volume", "author": "Leria", "description": "Applying the \"blackhole distorsion\" to the colored volume", "tags": ["noise", "color", "blackhole", "nebulae", "distorsion"], "likes": 4, "viewed": 458, "published": 3, "date": "1593615810", "time_retrieved": "2024-07-30T20:58:11.307321", "image_code": "//Free for any use, just let my name appears or a link to this shader\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n#define DISTORSION\t\t\t6.67\n#define\tMASS\t\t\t\t.2\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//enable-disable distorsion (0/1)\n#define DISTORSION_ON\t\t1\n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n//----> in HIGH_DEF mode, you can\n//choose the nathure of noise ADDITIVE 1 = additive noise || 0 = multiplicative\n\t#define ADDITIVE \t\t0\n\n\n//Stretch or not the colored volume\n\t#define STRETCH\t\t\t0\n//////////////////////////////////////////////////////////////////\n\n#define f(x) (.5+.5*cos(x))\n#define Pnoise(p) (2.* clamp( noise(p)/.178 +.5 ,0.,1.) )\n#define Psnoise(p) (2.* clamp( snoise(p)/.178 +.5 ,0.,1.) )\n\n\n/* discontinuous pseudorandom uniformly distributed in [-0.5, +0.5]^3 */\nvec3 random3(vec3 c) {\n\tfloat j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n\tvec3 r;\n\tr.z = fract(512.0*j);\n\tj *= .125;\n\tr.x = fract(512.0*j);\n\tj *= .125;\n\tr.y = fract(512.0*j);\n\treturn r-0.5;\n}\n\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    float radius; //accretion disk\n    float mass;\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n/* 3d simplex noise */\nfloat snoise(vec3 p) {\n\t /* 1. find current tetrahedron T and it's four vertices */\n\t /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n\t /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\t \n\t /* calculate s and x */\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \t\n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* 2. find four surflets and store them in d */\n\t vec4 w, d;\n\t \n\t /* calculate surflet weights */\n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n\t w = max(0.6 - w, 0.0);\n\t \n\t /* calculate surflet components */\n\t d.x = dot(random3(s), x);\n\t d.y = dot(random3(s + i1), x1);\n\t d.z = dot(random3(s + i2), x2);\n\t d.w = dot(random3(s + 1.0), x3);\n\t \n\t /* multiply d by w^4 */\n\t w *= w;\n\t w *= w;\n\t d *= w;\n\t \n\t /* 3. return the sum of the four surflets */\n\t return dot(d, vec4(52.0));\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1.,  1./4. ); \n\nfloat fbm_add( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n    \n    f = noise(p); p = p*s;\n\n    #if HIGH_DEF\n    f += 0.5000*noise( p ); p = p*s;\n    f += 0.2500*noise( p ); p = p*s;\n    f += 0.1250*noise( p ); p = p*s;\n    f += 0.0625*noise( p );   \n    #endif\n    return f;\n}\n\nfloat fbm_mul( vec3 p ) { // in [-1,1]\n    \n    float f;\n    vec3 s = vec3(2.);\n    #if STRETCH\n   \tp *= stretching*  vec3( 1. , 1.,  1./4. );\n   \ts = 2./pow(stretching,vec3(1./4.));\n    #endif\n\n    f = Pnoise(p); p = p*s;\n\n    #if HIGH_DEF\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p ); p = p*s;\n    f *=  Pnoise( p );\n    #endif\n    return f;\n}\n\nfloat fbm(vec3 p)\n{\n \n    #if ADDITIVE\n    return fbm_add(p);\n    #else\n   \treturn fbm_mul(p);\n    #endif\n    \n}\n\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 m_vec = m.pos - p;\n    float d = dot(m_vec,m_vec);\n    vec3 res = normalize(m_vec) * (DISTORSION*m.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_matter(vec3 pos, \n                float mass,\n                float radius)\n{\n \tm = Matter(pos, radius, mass);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\nvoid init_matter(void)\n{\n \tset_matter(vec3(0., 0., 0.), MASS, RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_matter();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = 50.*fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    \n    int s = 0;\n    \n    for(s; s < 140; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5-jit*k;\n\n        if(d > 0.)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float n = abs(fbm(p/4.));\n;\t\n            //sort of \"iso-value\" : .1*max(0., abs(sin(20.*fbm(p/4.))  )); //iso valeur\n            //complement : n = max(0., 1.-10.*abs(fbm(p/4.)))\n\n            \n            float mask = smoothstep(0., \n                                    1.*RADIUS,\n                                    (RADIUS-length(center))- 0.3*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  )*n; \n            \n            //How colors (rgb) are absorbed at point p in the current iteration\n            //k is the step size\n            //4*f(p.) is a property that defines the quantity of color which is absorbed\n            //f(p.) is here to make the non-uniform color varying effect not the animation\n             vec3 rgb_t = vec3(\n                \t\tk * 4.* f(p.x) * dens, \n                      \tk * 4.* f(p.y) * dens,\n              \t      \tk * 4.* f(p.z) * dens);    \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        #if DISTORSION_ON\n        space_time_bending(r, p, k); \n        #endif\n\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    cam.pos = C;\n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttjyzR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 889, 911, 911, 1084], [1754, 1754, 1811, 1811, 1980], [1982, 2005, 2027, 2280, 3197], [3199, 3199, 3225, 3225, 4050], [4153, 4153, 4178, 4191, 4565], [4567, 4567, 4592, 4605, 4953], [4955, 4955, 4974, 4974, 5067], [5069, 5069, 5130, 5130, 5324], [5325, 5344, 5420, 5420, 5467], [5469, 5469, 5501, 5501, 5521], [5523, 5523, 5557, 5557, 5579], [5681, 5681, 5705, 5705, 5865], [5867, 5867, 5891, 5891, 5976], [5978, 6007, 6035, 6035, 6205], [6207, 6229, 6275, 6275, 6898], [6948, 6948, 6989, 6989, 7025], [7027, 7027, 7113, 7113, 7148], [7150, 7150, 7193, 7193, 7233], [7235, 7235, 7259, 7259, 7307], [7309, 7309, 7349, 7349, 7653], [7655, 7655, 7679, 7679, 7742], [7744, 7744, 7791, 7791, 7843], [7845, 7845, 7928, 7928, 8067], [8070, 8070, 8123, 8123, 8480], [8483, 8483, 8535, 8535, 11245], [11248, 11248, 11305, 11305, 11930]], "test": "untested"}
{"id": "wt2cRR", "name": "mirrors dice", "author": "ich", "description": "glass dice in a room full of mirrors", "tags": ["mirrorglassredinfinitedice"], "likes": 3, "viewed": 398, "published": 3, "date": "1593613920", "time_retrieved": "2024-07-30T20:58:12.061305", "image_code": "#define pi 3.141\n#define pi2 (pi*2.)\n#define surf_dist .005\n#define max_dist 100.\n#define max_it 100\n#define recursions 10.\n\nfloat n21(vec2 uv) {\n\treturn fract(9876. * sin(dot(uv, vec2(987, 654))));\n}\n\nvec2 n22(vec2 uv) {\n\tfloat n = n21(uv);\n\treturn vec2(n, n21(vec2(n)));\n}\n\nfloat n11(float v) {\n\treturn n21(vec2(v));\n}\n\nvec3 n33(vec3 p) {\n\tfloat n = n21(p.xy);\n\treturn vec3(n11(p.x), n, n21(vec2(n, p.z)));\n}\n\nmat2 rot2(float a) {\n\treturn mat2(\n\t\tcos(a), -sin(a),\n\t\tsin(a), cos(a)\n\t);\n}\n\nvec3 rot3(vec3 p, float a) {\n\treturn vec3(rot2(a) * p.xy, p.z);\n}\n\nvec3 rot3(vec3 p, vec3 a) {\n\treturn rot3(rot3(rot3(p, a.z).zxy, a.y).yzx, a.x);\n}\n\nmat3 look(vec3 d) {\n\tvec3 u = vec3(0, 1, 0);\n\tvec3 r = normalize(cross(u, d));\n\tu = normalize(cross(d, r));\n\treturn mat3(r, u, d);\n}\n\nfloat plane(vec3 p, vec3 n, float r) {\n\treturn dot(p, n) - r;\n}\n\nfloat sphere(vec3 p, float r) {\n\treturn length(p) - r;\n}\n\nfloat quickcube(vec3 p, float r)\n{\n\tp = abs(p);\n\treturn max(p.x, max(p.y, p.z)) - r;\n}\n\nfloat quickcube(vec3 p, vec3 r)\n{\n\tp = abs(p);\n\treturn max(p.x - r.x, max(p.y - r.y, p.z - r.z));\n}\n\nvoid min_mat(inout float l0, inout vec4 mat0, float l1, vec4 mat1) {\n\tif (l1 < l0) {\n\t\tl0 = l1;\n\t\tmat0 = mat1;\n\t}\n}\n\nfloat scene(vec3 p) {\n\tfloat l = max_dist;\n\n\tvec3 p0 = p - vec3(2, .5, -2);\n\tvec3 p1 = rot3(p - vec3(2, .5, 2), vec3(0, pi*.75, 0));\n\tl = min(l, plane(p, vec3(0, 1, 0), -.6));\n\tl = min(l, max(quickcube(p, .5), sphere(p, .7)));\n\tl = min(l, plane(p, normalize(vec3(1, 0, 0)), -4.));\n\tl = min(l, -quickcube(p, 5.));\n\n\treturn l;\n}\n\nvec4 material(vec3 p) {\n\tfloat l = max_dist;\n\tvec4 mat = vec4(0);\n\n\tvec3 p0 = p - vec3(2, .5, -2);\n\tvec3 p1 = rot3(p - vec3(2, .5, 2), vec3(0, pi*.75, 0));\n\tmin_mat(l, mat, plane(p, vec3(0, 1, 0), -.6), vec4(p0, 1));\n\tmin_mat(l, mat, max(quickcube(p, .5), sphere(p, .7)), vec4(vec3(.85, 0, 0), 2));\n\tmin_mat(l, mat, plane(p, normalize(vec3(1, 0, 0)), -4.), vec4(vec3(0), 3));\n\tmin_mat(l, mat, -quickcube(p, 5.), vec4(vec3(0), 4.));\n\n\treturn mat;\n}\n\nfloat march(vec3 ro, vec3 rd, float s) {\n\tvec3 p = ro;\n\tfloat lo = 0.;\n\n\tfor (int i = 0; i < max_it; ++i) {\n\t\tfloat l = s * scene(p);\n\t\tlo += l;\n\t\tp = ro + rd * lo;\n\n\t\tif (l < surf_dist || lo > max_dist)\n\t\t\tbreak;\n\t}\n\n\treturn lo;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n\treturn march(ro, rd, 1.);\n}\n\nvec3 normal(vec3 p) {\n\tfloat l = scene(p);\n\tvec2 e = vec2(0, surf_dist / 2.);\n\treturn normalize(\n\t\tl - vec3(\n\t\t\tscene(p - e.yxx),\n\t\t\tscene(p - e.xyx),\n\t\t\tscene(p - e.xxy)\n\t));\n}\n\nfloat ambient_occlusion(vec3 p, vec3 n, float r) {\n\tfloat l = 0.;\n\tfloat it = 3.;\n\tfor (float i = 0.; i < it; ++i) {\n\t\tl += min(1., scene(p + n * r) / r);\n\t\tr *= .5;\n\t}\n\treturn pow(max(0., l / it), .2);\n}\n\nvec3 color(vec4 mat) {\n\tswitch(int(mat.w)) {\n\tcase 1: return vec3(smoothstep(.0, .1, sin(mat.x * 20.) * sin(mat.z * 20.)), 0, 0);\n\tcase 2: return vec3(.9, 1, .95);\n\tcase 3: return vec3(1, 0, 0);\n\tcase 4: return vec3(.9, 1, .95);\n\tdefault: return vec3(0, 0, 1);\n\t}\n}\n\nfloat shadow(vec3 p, vec3 n, float l, vec3 rd) {\n\tfloat c = 1.;\n\tc *= max(0., dot(rd, -n));\n\tc *= 1. - l / max_dist;\n\tc *= ambient_occlusion(p, n, 1.);\n\treturn c;\n}\n\nvec3 mirror(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tp += n * surf_dist * 2.;\n\trd = reflect(rd, n);\n\n\tfloat l = march(p, rd);\n\tp = p + rd * l;\n\tn = normal(p);\n\n\tmat = material(p);\n\treturn shadow(p, n, l, rd) * color(mat);\n}\n\nvec3 glass(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tp += -n * surf_dist * 2.;\n\trd = refract(rd, n, mat.x);\n\n\tfloat l = march(p, rd, -1.);\n\tp = p + rd * l;\n\tn = normal(p);\n\n\tp += n * surf_dist * 2.;\n\trd = refract(rd, -n, mat.x);\n\n\tl = march(p, rd);\n\tp = p + rd * l + -n * surf_dist * 2.;\n\tn = normal(p);\n\n\tmat = material(p);\n\treturn shadow(p, n, l, rd) * color(mat);\n}\n\nvec3 surface(inout vec3 p, inout vec3 n, inout vec3 rd, inout vec4 mat) {\n\tswitch(int(mat.w)) {\n\tcase 1: return mirror(p, n, rd, mat);\n\tcase 2: return glass(p, n, rd, mat);\n\tcase 3: return color(mat);\n\tcase 4: return mirror(p, n, rd, mat);\n\tdefault: return vec3(0, 0, 1);\n\t}\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 R = iResolution.xy;\n    vec2 C = fragCoord;\n\n    vec2 uv = (fragCoord - iResolution.xy * .5) / iResolution.y;\n\tvec3 c = vec3(0);\n  \tvec2 m = vec2(iMouse.xy - iResolution.xy * .5) / iResolution.y;\n\n\tm *= 5.;\n\tvec3 ro = vec3(sin(m.x) * cos(m.y), sin(m.y), cos(m.x) * cos(m.y)) * 3.5;\n\tro.y = max(-.5, ro.y);\n\tvec3 rd = look(normalize(vec3(0, .5, 0) - ro)) * normalize(vec3(uv, 1.));\n\n\tfloat lo = 0.;\n\tfloat l = march(ro, rd);\n\tvec3 p = ro + rd * l;\n\tvec3 n = normal(p);\n\tvec4 mat = material(p);\n\tvec3 col = color(mat);\n\n\tc += shadow(p, n, l, rd) * col * 1. / 5.;\n\tfor (float i = 1.; i < recursions; ++i)\n\t\tc += surface(p, n, rd, mat) / recursions * 4. / 5.;\n\n\tfragColor = vec4(c, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wt2cRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 125, 145, 145, 200], [202, 202, 221, 221, 274], [276, 276, 296, 296, 320], [322, 322, 340, 340, 410], [412, 412, 432, 432, 488], [490, 490, 518, 518, 555], [557, 557, 584, 584, 638], [640, 640, 659, 659, 772], [774, 774, 812, 812, 837], [839, 839, 870, 870, 895], [897, 897, 931, 931, 983], [985, 985, 1018, 1018, 1084], [1086, 1086, 1154, 1154, 1201], [1203, 1203, 1224, 1224, 1529], [1531, 1531, 1554, 1554, 1978], [1980, 1980, 2020, 2020, 2211], [2213, 2213, 2244, 2244, 2273], [2275, 2275, 2296, 2296, 2452], [2454, 2454, 2504, 2504, 2658], [2660, 2660, 2682, 2682, 2925], [2927, 2927, 2975, 2975, 3091], [3093, 3093, 3165, 3165, 3337], [3339, 3339, 3410, 3410, 3727], [3729, 3729, 3802, 3802, 4005], [4007, 4007, 4062, 4062, 4752]], "test": "untested"}
{"id": "WtfyWj", "name": "Ocean Treasure", "author": "dean_the_coder", "description": "Lots of firsts for me: Underwater, refraction (bubbles), 'god rays', and modelling of a (simple!) stingray.\n\nThanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!", "tags": ["3d", "raymarching", "sea", "water", "godrays", "caustics"], "likes": 26, "viewed": 1164, "published": 3, "date": "1593609443", "time_retrieved": "2024-07-30T20:58:12.809305", "image_code": "// 'Ocean Treasure'\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, and a bunch of others for sharing their knowledge!\n\n#define time (iTime + 37.0)\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return a.x < b.x ? a : b;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n  vec3 q = abs(p) - b;\n  return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdRod(vec3 p, float h, float r) {\n  p.y -= clamp( p.y, 0.0, h );\n  return length( p ) - r;\n}\n\nfloat sdSurface(vec2 p) {\n    float sh = texture(iChannel0, (p + vec2(0.0, 1.0) * (time + 1.0)) * 0.05).r;\n    sh -= texture(iChannel0, (p + vec2(0.7, 0.2) * time) * 0.05).r;\n    return clamp(0.05 + sh * 0.2, 0.0, 1.0);\n}\n\nfloat sdChest(vec3 p) {\n    if (length(p) > 4.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    float w = 1.0;\n    float l = 1.5;\n    float h = 0.6;\n    \n    vec3 pp = p + vec3(0.0, h, 0.0);\n    vec3 bs = vec3(w, h, l);\n    float box = sdBox(pp , bs);\n    float boxInner = sdBox(pp - vec3(0.0, 0.9, 0.0), bs);\n    box = max(box, -boxInner);\n\n    p.xy *= rot(0.2);\n    p.y -= 0.2;\n    float lid = max(max(-p.y, length(p.xy) - w), abs(p.z) - l);\n    \n    float d = min(lid, box) - texture(iChannel0, (p.xz + p.y) * 0.11).r * 0.1;\n    d -= abs(abs(p.z) - l * 0.5) < 0.15 ? 0.07 : 0.0;\n    \n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    float bh = textureLod(iChannel0, p.xz * rot(1.1) * 0.01, 2.5).r * 6.5;\n\t     bh += textureLod(iChannel0, (p.xz + vec2(12.3, 23.4)) * rot(0.5) * 0.02, 0.0).r * 1.2;\n    bh /= 2.5;\n    return p.y + 6.0 - bh;\n}\n\nfloat sdBubble(vec3 p, float t) {\n    float progress = pow(min(fract(t * 0.1) * 4.5, 1.0), 2.0);\n    float maxDepth = 4.2;\n    float depth = maxDepth * (1.0 - progress * progress);\n    float r = mix(0.01, 0.08, progress);\n    \n    float d = 1.2 - smoothstep(0.0, 1.0, min(progress * 5.0, 1.0)) * 0.3;\n    \n    return length(p + vec3(d, depth, -1.0 + 0.2 * progress * sin(progress * 10.0))) - r;\n}\n\nfloat sdPlant(vec3 p, float h) {\n    float r = 0.02 * -(p.y + 2.5) - 0.005 * pow(sin(p.y * 30.0), 2.0);\n    p.z += sin(time + h) * pow(0.2 * (p.y + 5.6), 3.0);\n    return sdRod(p + vec3(0.0, 5.7, 0.0), 3.0 * h, r);\n}\n\nfloat sdPlants(vec3 p) {\n    vec3 dd = vec3(0.2, 0.0, -0.5);\n    \n    // Make multiple copies, each one displaced and rotated.\n    float d = 1e10;\n    for (int i = 0; i < 4; i++) {\n        d = min(d, min(sdPlant(p, 1.2), min(sdPlant(p + dd.xyx, 0.5), sdPlant(p + dd, 0.8))));\n        p.x -= 1.0;\n        p.z -= 1.0;\n        p.xz *= rot(0.6);\n    }\n    \n    return d;\n}\n\nfloat sdManta(vec3 p) {\n    // Translate the origin to the center of the manta.\n    p.xz *= rot(3.141);\n    p.y += 3.5;\n    p.z += 22.0;\n    \n    float t = mod(iTime, 20.0);\n    p.x -= 30.0;\n    p.xz *= rot(-t * 0.07);\n    p.x += 30.0;\n\n    if (length(p) > 3.5) return 1e7; // Ray not close enough to bother rendering.\n    \n    // Flap!\n    p.y -= sin(-time * 1.5) * 0.2;\n    p.y -= (abs(p.x) + 0.1) * sin(abs(p.x) + time * 1.5) * 0.4;\n    \n    // Wings.\n    vec3 pp = p;\n    pp.xz *= rot(3.141 / 4.0);\n    float d = sdBox(pp, vec3(1.0, 0.015, 1.0));\n    d = smin(d, length(p.xz * vec2(0.5, 1.0)) - 1.18, -0.05); // Nose\n    \n    // Eyes\n    pp = p;\n    if (p.y > 0.0) {\n    \tpp.x = abs(pp.x) - 0.1;\n    \tpp.z -= 0.6;\n    \td = smin(d, length(pp) - 0.1, 0.05);\n    }\n    \n    // Tail.\n    p.z += 1.25;\n    d = smin(d, sdBox(p, vec3(0.005, 0.005, 2.0)), 0.3);\n    \n    return (d - 0.02) * 0.7;\n}\n\nfloat godLight(vec3 p, vec3 lightPos) {\n    vec3 lightDir = normalize(lightPos - p);\n    vec3 sp = p + lightDir * -p.y;\n\n    float f = 1.0 - clamp(sdSurface(sp.xz) * 10.0, 0.0, 1.0);\n    f *= 1.0 - length(lightDir.xz);\n    return smoothstep(0.2, 1.0, f * 0.7);\n}\n\nvec2 map(vec3 p) {\n    vec3 pp = p;\n    pp.xz *= rot(-.5);\n    \n    float surface = -p.y - sdSurface(p.xz);\n    float t = time * 0.6;\n    surface += (0.5 + 0.5 * (sin(p.z * 0.2 + t) + sin((p.z + p.x) * 0.1 + t * 2.0))) * 0.4;\n    \n    return min2(vec2(surface, 1.5),\n           min2(vec2(sdChest(pp + vec3(2.0, 4.4, 0.0)), 2.5),\n           min2(vec2(sdFloor(p), 3.5),\n           min2(vec2(sdPlants(p - vec3(6.0, 0.0, 7.0)), 5.5),\n           min2(vec2(sdManta(p), 6.5),\n           min2(vec2(sdBubble(pp, time - 0.3), 4.5),\n                vec2(sdBubble(pp, time), 4.5)))))));\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.0025;\n    return normalize(e.xyy * map(p + e.xyy).x + \n\t\t\t\t\t e.yyx * map(p + e.yyx).x + \n\t\t\t\t\t e.yxy * map(p + e.yxy).x + \n\t\t\t\t\t e.xxx * map(p + e.xxx).x);\n}\n\nfloat calcOcc(vec3 p, vec3 n) {\n    const float dist = 0.5;\n    return smoothstep(0.0, 1.0, 1.0 - (dist - map(p + n * dist).x));\n}\n\n\n/**********************************************************************************/\n\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nfloat marchGodRay(vec3 ro, vec3 rd, vec3 light, float hitDist) {\n    // March through the scene, accumulating god rays.\n    vec3 p = ro;\n    vec3 st = rd * hitDist / 96.0;\n    float god = 0.0;\n    for (int i = 0; i < 96; i++) {\n        float distFromGodLight = 1.0 - godLight(p, light);\n        god += godLight(p, light);\n        p += st;\n    }\n    \n    god /= 96.0;\n\n    return smoothstep(0.0, 1.0, min(god, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    // Camera.\n    vec3 ro = vec3(-0.4, -2.0, -4.0);\n    ro.xz *= rot(0.03 * sin(time * 0.3));\n    ro.y += sin(time * 0.2) * 0.3;\n    vec3 rd = getRayDir(ro, vec3(0.0, -3.0, 0.0), uv);\n\n    // Raymarching loop.\n    int hit = 0; // ID of the object we hit.\n    float d = 0.01; // Ray distance travelled.\n    float maxd = 50.0; // Max ray distance.\n    vec3 p;\n    float outside = 1.0; // Tracks inside/outside of bubble (for refraction)\n    for (float steps = 0.0; steps < 100.0; steps++) {\n        p = ro + rd * d;\n        vec2 h = map(p);\n\n        if (h.x < 0.001 * d) {\n            if (h.y == 4.5) {\n                // Bubble refraction.\n                rd = refract(rd, calcNormal(p) * sign(outside), 1.0);\n                outside *= -1.0;\n                continue;\n            }\n            \n            hit = int(h.y);\n            break;\n        }\n        \n        if (d > maxd)\n            break;\n\n        d += h.x;\n    }\n\n    vec3 deepColor = vec3(0.02, 0.08, 0.2) * 0.1;\n    vec3 lightPos = vec3(1.0, 4.0, 3.0);\n    vec3 col = deepColor;\n    if (hit > 0) {\n        \n        vec3 n = calcNormal(p);\n        vec3 mat = vec3(0.15, 0.25, 0.6);\n        if (hit == 1) {\n            // Sea\n            n.y = -n.y;\n        } else {\n        \tif (hit == 2)\n                mat = mix(mat, vec3(0.2, 0.15, 0.125), 0.5); // Chest\n            else if (hit == 3)\n                mat += vec3(0.1, 0.1, 0.0); // Sand\n        \telse if (hit == 5)\n                mat += vec3(0.0, 0.2, 0.0); // Plant\n        \telse if (hit == 6)\n                mat += vec3(0.5); // Manta\n\n            mat *= 0.4 + 0.6 * godLight(p, lightPos);\n            mat *= calcOcc(p, n); // Ambient occlusion.\n                \n            // Shadows.\n            vec3 lightDir = normalize(lightPos - p);\n\t\t\tfloat sha1 = max(0.0, map(p + lightDir * 0.25).x / 0.25);\n            float sha2 = max(0.0, map(p + lightDir).x);\n            mat *= clamp((sha1 + sha2) * 0.5, 0.0, 1.0);\n        }\n        \n        vec3 lightCol = vec3(1.0, 0.9, 0.8);\n        vec3 lightToPoint = normalize(lightPos - p);\n        \n        float amb = 0.1;\n        float diff = max(0.0, dot(lightToPoint, n));\n\n        col = (amb + diff) * mat;\n    }\n    \n    // Fog.\n    float fog = clamp(pow(d / maxd * 2.0, 1.5), 0.0, 1.0);\n    col = mix(col, deepColor, fog);\n    \n    // God rays.\n    col = mix(col, vec3(0.15, 0.25, 0.3) * 12.0, marchGodRay(ro, rd, lightPos, d));\n    \n    // Output to screen\n    col = pow(col, vec3(0.4545)); // Gamma correction\n    col = vignette(col, fragCoord); // Fade screen corners\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtfyWj.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[149, 149, 188, 188, 291], [293, 293, 312, 312, 388], [390, 390, 437, 437, 642], [644, 644, 671, 671, 703], [705, 705, 734, 734, 825], [827, 827, 866, 866, 925], [927, 927, 952, 952, 1148], [1150, 1150, 1173, 1173, 1771], [1773, 1773, 1796, 1796, 2008], [2010, 2010, 2043, 2043, 2406], [2408, 2408, 2440, 2440, 2624], [2626, 2626, 2650, 2650, 2994], [2996, 2996, 3019, 3075, 3889], [3891, 3891, 3930, 3930, 4153], [4155, 4155, 4173, 4173, 4731], [4733, 4733, 4761, 4761, 4952], [4954, 4954, 4985, 4985, 5084], [5174, 5174, 5215, 5215, 5356], [5358, 5358, 5422, 5477, 5775], [5777, 5777, 5834, 5834, 8483]], "test": "untested"}
{"id": "wlBcRR", "name": "Logarithmic Moebius Transform 10", "author": "FabriceNeyret2", "description": "variant of [url]https://shadertoy.com/view/wlByRR[/url]", "tags": ["zoom", "spiral", "mobius", "transform", "logarithm", "reproduction"], "likes": 4, "viewed": 339, "published": 3, "date": "1593601678", "time_retrieved": "2024-07-30T20:58:13.644073", "image_code": "// variant of https://shadertoy.com/view/wlByRR\n\nvoid mainImage(out vec4 O,  vec2 u ){\n\n    vec2 R = iResolution.xy,  I,\n         U = (u - .5*R) / R.y,                                // normalized coordinates\n         z = U - vec2(-1,0);  U.x -= .5;                      // Moebius transform\n#if 1\n    U *= mat2(z,-z.y,z.x) / dot(U,U);             \n                  // offset   spiral, zoom   phase            // spiraling\n    U =   log(length(U+=.5))*vec2(.5, -.5) + iTime/8.\n        + atan(U.y, U.x)/6.283 * vec2(6, 1); // n    \n#else\n    U.x +=.022; U *= vec2(2.2,1);                             // test in the plane\n    if(u.x/R.y>sqrt(3.)/2.) return;\n#endif\n // U *= vec2(10,14.82)/1.43;// /(.5+iMouse.x/R.x);\n    U *= vec2(11./3., 2./sqrt(3.)*7.5) *2.;                   // thanks Shane !\n    U *= mat2(1,0,.5,sqrt(3.)/2.);                            // triangular mesh\n    z = fwidth(U);\n    I = floor(U); U = fract(U); \n // O = fract(vec4(I.x,I.y,1.-I.x-I.y,0.)/3.)+.33*float(U.x-U.y>0.); return;\n    float s = float(U.x-U.y>0.), v,                           // parallelogram = 2 triangles\n          i = mod( I.x + I.y , 3.), id; \n    I += i==0.? vec2(0) : i==1. ? vec2(1) : vec2(s,1.-s);  id = I.x +7.81*I.y;\n // id = i;\n // id = 6.28*( I.y/6.+I.x/11.)*2.+s*91.;\n    vec4 V = vec4( 1.-2.*abs(U.x-U.y) , abs(U*2.-1.) , 0 );\n // O = smoothstep(-.7,.7, (V-.95)/( abs(z.x-z.y)>1.?.1:z.y*4.));  if (length(O)>.0) return;\n    v = V[i<2. ? 2-int(i+s)%2 : 0 ];\n // v = 1.-2.*abs(U.x-U.y); U = abs(U*2.-1.); v = max(v,max(U.x,U.y)); // dist to border\n    O =   smoothstep(.7,-.7, (v-.95)/( abs(z.x-z.y)>1.?.1:z.y*4.))  // draw AA tiles\n        * (.6 + .6 * cos( id  + vec4(0,23,21,0)  ) );         // color\n // O /= .8+.3*s;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlBcRR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 86, 86, 1727]], "test": "untested"}
{"id": "WljyRz", "name": "Stretching noise", "author": "Leria", "description": "Stretching the noise becomes faster than browsing it", "tags": ["noise", "stretch"], "likes": 0, "viewed": 281, "published": 3, "date": "1593595588", "time_retrieved": "2024-07-30T20:58:14.378110", "image_code": "//Based on this https://www.shadertoy.com/view/wtfcz2 by FabriceNeyret2\n\nvoid mainImage(  out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 R = iResolution.xy,\n         uv = fragCoord / R.y /16. + vec2(.02*iTime,0),\n         stretching, T = vec2(.01*iTime,0);\n    mat2 rot = mat2(cos( 2. + vec4(0,1.5708,-1.5708,0))), M = rot;\n\n    int y = int(3.*fragCoord.y/R.y);                // panel id\n    float N = 7.,                           // amount of details\n          k = exp2(-N), e, v = 0.;\n    float w = -.2*sign(iMouse.z-1.) ;\n    \n    for (float i=0.; i<N; i++, k*=2.)       // Perlin fractal cascade\n    {\n        stretching = vec2( pow( 1.4, -(2.+iTime/10.) ) ,1 );       // stretching\n        v += abs(2.* texture(iChannel0, (uv/k-T) *stretching *M ).x -1. ) * k; // base noise\n        M *= rot;                           // to avoid grid-aligned artifacts\n    }\n    \n    v = smoothstep(-w,w, v-.37);            // shaping function\n    fragColor = vec4( pow(v,2./2.2) );              // to sRGB\n}", "image_inputs": [{"id": 15, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WljyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[73, 73, 131, 131, 1004]], "test": "untested"}
{"id": "Wt2czR", "name": "y=cos(x)*sin(z)", "author": "changjiu", "description": "the 3D graph of the function:y=cos(x)*sin(z)", "tags": ["math", "graph", "function"], "likes": 3, "viewed": 270, "published": 3, "date": "1593592389", "time_retrieved": "2024-07-30T20:58:15.237812", "image_code": "\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 50.0;\nconst float EPSILON = 0.0001;\n\nvec3 rayDir;\n \nvec3 cameraPosition = vec3(0.0, 0.0, 5.0);\nvec3 cameraDir = vec3(0.0, 0.0, -1.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\nmat4 getPerspectiveProjectMatrix(float fovy, float aspect, float near, float far){\n    mat4 projectMatrix;\n    \n\tfloat rd, s, ct;\n\n\n  \tfovy = 3.1415926 * fovy / 180.0 / 2.0;\n  \ts = sin(fovy);\n\n\n  \trd = 1.0 / (far - near);\n  \tct = cos(fovy) / s;\n\n\n      projectMatrix[0][0]  = ct / aspect;\n      projectMatrix[0][1]  = 0.0;\n      projectMatrix[0][2]  = 0.0;\n      projectMatrix[0][3]  = 0.0;\n\n      projectMatrix[1][0]  = 0.0;\n      projectMatrix[1][1]  = ct;\n      projectMatrix[1][2]  = 0.0;\n      projectMatrix[1][3]  = 0.0;\n\n      projectMatrix[2][0]  = 0.0;\n      projectMatrix[2][1]  = 0.0;\n      projectMatrix[2][2]  = -(far + near) * rd;\n      projectMatrix[2][3]  = -1.0;\n\n      projectMatrix[3][0]  = 0.0;\n      projectMatrix[3][1]  = 0.0;\n      projectMatrix[3][2]  = -2.0 * near * far * rd;\n      projectMatrix[3][3]  = 0.0;\n\n      return projectMatrix;\n\n}\n\nmat4 matTranslate(mat4 e, float x, float y, float z) {\n    \n  e[3][0] += e[0][0] * x + e[1][0] * y + e[2][0] * z;\n  e[3][1] += e[0][1] * x + e[1][1] * y + e[2][1] * z;\n  e[3][2] += e[0][2] * x + e[1][2] * y + e[2][2] * z;\n  e[3][3] += e[0][3] * x + e[1][3] * y + e[2][3] * z;\n    \n  return e;\n}\n\nmat4 getViewMatrix(float eyeX, float eyeY, float eyeZ, float centerX, float centerY, float centerZ, float upX, float upY, float upZ){\n    mat4 viewMatrix;\n    \n\tfloat fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n\n  \t  fx = centerX - eyeX;\n      fy = centerY - eyeY;\n      fz = centerZ - eyeZ;\n\n      // Normalize f.\n      rlf = 1.0 / sqrt(fx*fx + fy*fy + fz*fz);\n      fx *= rlf;\n      fy *= rlf;\n      fz *= rlf;\n\n      // Calculate cross product of f and up.\n      sx = fy * upZ - fz * upY;\n      sy = fz * upX - fx * upZ;\n      sz = fx * upY - fy * upX;\n\n      // Normalize s.\n      rls = 1.0 / sqrt(sx*sx + sy*sy + sz*sz);\n      sx *= rls;\n      sy *= rls;\n      sz *= rls;\n\n      // Calculate cross product of s and f.\n      ux = sy * fz - sz * fy;\n      uy = sz * fx - sx * fz;\n      uz = sx * fy - sy * fx;\n\n\n      viewMatrix[0][0]  = sx;\n      viewMatrix[0][1]  = ux;\n      viewMatrix[0][2]  = -fx;\n      viewMatrix[0][3]  = 0.0;\n\n      viewMatrix[1][0]  = sy;\n      viewMatrix[1][1]  = uy;\n      viewMatrix[1][2]  = -fy;\n      viewMatrix[1][3]  = 0.0;\n\n      viewMatrix[2][0]  = sz;\n      viewMatrix[2][1]  = uz;\n      viewMatrix[2][2]  = -fz;\n      viewMatrix[2][3]  = 0.0;\n\n      viewMatrix[3][0]  = 0.0;\n      viewMatrix[3][1]  = 0.0;\n      viewMatrix[3][2]  = 0.0;\n      viewMatrix[3][3]  = 1.0;\n    \n      viewMatrix = matTranslate(viewMatrix, -eyeX, -eyeY, -eyeZ);\n\n      return viewMatrix;\n\n}\n\nvec3 applyMatrix4(vec3 v3, mat4 m4){\n\t\tfloat x = v3.x, y = v3.y, z = v3.z;\n\t\tfloat e[16];\n    \te[0] = m4[0][0];\n        e[1] = m4[0][1];\n        e[2] = m4[0][2];\n        e[3] = m4[0][3];\n    \n    \te[4] = m4[1][0];\n        e[5] = m4[1][1];\n        e[6] = m4[1][2];\n        e[7] = m4[1][3];\n    \n        e[8] = m4[2][0];\n        e[9] = m4[2][1];\n        e[10] = m4[2][2];\n        e[11] = m4[2][3];\n    \n    \te[12] = m4[3][0];\n        e[13] = m4[3][1];\n        e[14] = m4[3][2];\n        e[15] = m4[3][3];\n\n\t\tfloat w = 1. / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );\n\n\t\tv3.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;\n\t\tv3.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;\n\t\tv3.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;\n\n\t\treturn v3;\n}\n\nmat4 arrayToM4(float e[16]){\n    mat4 m4;\n    \n    m4[0][0]=e[0] ;\nm4[0][1]=e[1] ;\nm4[0][2]=e[2] ;\nm4[0][3]=e[3] ;\nm4[1][0]=e[4] ;\nm4[1][1]=e[5] ;\nm4[1][2]=e[6] ;\nm4[1][3]=e[7] ;\nm4[2][0]=e[8] ;\nm4[2][1]=e[9] ;\n m4[2][2]=e[10];\n m4[2][3]=e[11];\n m4[3][0]=e[12];\n m4[3][1]=e[13];\n m4[3][2]=e[14];\n m4[3][3]=e[15];\n    \n\treturn m4;\n}\n\nvec3 getCameraPosition(){\n\tvec3 cameraPosition;\n    cameraPosition.x = sin(0.5*iTime)*10.0;\n    cameraPosition.y = (sin(iTime)+1.0)*2.0;\n    cameraPosition.z = cos(0.5*iTime)*10.0;\n    \n    if(iMouse.z>0.){\n        float theta = -iMouse.x/iResolution.x*3.14159*2.0;\n        float y = 20.-iMouse.y/iResolution.y*20.0;\n        cameraPosition.x = sin(theta)*10.0;\n        cameraPosition.y = y;\n        cameraPosition.z = cos(theta)*10.0;\n    }\n    \n  \n    \n\treturn cameraPosition;\n}\n\nvec3 unproject(vec3 pointScreen){\n    \n    cameraPosition = getCameraPosition();\n\n    mat4 viewMatrix = getViewMatrix(cameraPosition.x, cameraPosition.y, cameraPosition.z, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n    mat4 projectMatrix  = getPerspectiveProjectMatrix(45.0, iResolution.x/iResolution.y, 1.0, 100.0);\n    \n    mat4 vpMatrix = projectMatrix * viewMatrix;\n    \n    mat4 VPmatrixInverse = inverse(vpMatrix);\n    \n\tvec3 pointV3 = applyMatrix4(pointScreen, VPmatrixInverse);\n\n    return pointV3;\n}\n\nvec3 getPointV3ByFragCoord(vec2 coord){\n    \n    vec3 pointScreen = vec3(coord.x, coord.y, 0.5);\n\tvec3 pointV3 = unproject(pointScreen);\n\n    return pointV3;\n}\n\nvec3 getRayDirByCoord(vec2 coord){\n\tvec3 pointV3 = getPointV3ByFragCoord(coord);\n    vec3 ray = pointV3 - cameraPosition;\n    return normalize(ray);\n}\n\n\nfloat funcSDF(vec3 p) {\n    \n    return p.y-cos(p.x)*sin(p.z);\n}\n\nfloat sceneSDF(vec3 p) {\n    //To prevent artefact, *0.8\n    float minDis2 = funcSDF(p)*0.8;\n    return minDis2;\n}\n\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n            \nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(10.0,5.0,3.0);\n    vec3 light1Intensity = vec3(1., 1., 1.);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 cood = vec2(( fragCoord.x / iResolution.x ) * 2. - 1., ( fragCoord.y / iResolution.y ) * 2. - 1.);\n    rayDir = getRayDirByCoord(cood);\n    \n    float dist = shortestDistanceToSurface(cameraPosition, rayDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        fragColor = vec4(0.1, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    vec3 p = cameraPosition + dist * rayDir;\n    \n    vec3 K_a = vec3(0.1, 0.1, 0.1);\n    vec3 K_d = vec3(0.3, 0.3, 0.3);\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 1.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, cameraPosition);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wt2czR.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[260, 260, 342, 342, 1127], [1129, 1129, 1183, 1183, 1423], [1425, 1425, 1558, 1558, 2835], [2837, 2837, 2873, 2873, 3622], [3624, 3624, 3652, 3652, 3955], [3957, 3957, 3982, 3982, 4436], [4438, 4438, 4471, 4471, 4935], [4937, 4937, 4976, 4976, 5096], [5098, 5098, 5132, 5132, 5248], [5251, 5251, 5274, 5274, 5315], [5317, 5317, 5341, 5373, 5431], [5433, 5433, 5524, 5524, 5830], [5832, 5832, 5861, 5861, 6171], [6173, 6173, 6313, 6313, 6742], [6756, 6756, 6841, 6841, 7212], [7214, 7214, 7271, 7271, 7935]], "test": "untested"}
{"id": "WtjyzR", "name": "Path to the colorful infinity", "author": "benoitM", "description": "Moving forward through layers of my \"sponge \"shader (https://www.shadertoy.com/view/MsjfDK)", "tags": ["2d", "fractal", "colors", "space", "abstract", "recursive", "generative", "inversion", "layers", "symmetries", "travel", "spacefolding", "cineshader"], "likes": 128, "viewed": 3548, "published": 3, "date": "1593582640", "time_retrieved": "2024-07-30T20:58:16.257087", "image_code": "// Created by Benoit Marini - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Try it fullscreen ;)\n// Try NUM_LAYERS 80. if your GPU can\n\n#define NUM_LAYERS 16.\n#define ITER 23\n\nvec4 tex(vec3 p)\n{\n    float t = iTime+78.;\n    vec4 o = vec4(p.xyz,3.*sin(t*.1));\n    vec4 dec = vec4 (1.,.9,.1,.15) + vec4(.06*cos(t*.1),0,0,.14*cos(t*.23));\n    for (int i=0 ; i++ < ITER;) o.xzyw = abs(o/dot(o,o)- dec);\n    return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-iResolution.xy*.5)/iResolution.y;\n    vec3 col = vec3(0);   \n    float t= iTime* .3;\n    \n\tfor(float i=0.; i<=1.; i+=1./NUM_LAYERS)\n    {\n        float d = fract(i+t); // depth\n        float s = mix(5.,.5,d); // scale\n        float f = d * smoothstep(1.,.9,d); //fade\n        col+= tex(vec3(uv*s,i*4.)).xyz*f;\n    }\n    \n    col/=NUM_LAYERS;\n    col*=vec3(2,1.,2.);\n   \tcol=pow(col,vec3(.5 ));  \n\n    fragColor = vec4(col,0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WtjyzR.jpg", "access": "api", "license": "cc-by-nc-sa-3.0", "functions": [[226, 226, 244, 244, 464], [466, 466, 523, 523, 979]], "test": "untested"}
{"id": "tlBcRz", "name": "Pseudo3D Fur", "author": "michael0884", "description": "fluffy ", "tags": ["hm"], "likes": 23, "viewed": 639, "published": 3, "date": "1593563795", "time_retrieved": "2024-07-30T20:58:17.066921", "image_code": "#define R iResolution.xy\n#define PI 3.14159265\n\n#define center R*0.5\n#define L 1.\n#define P 50.\n\n#define H 23\n\nvec4 fur(vec2 p, vec2 d)\n{\n    vec4 col = vec4(0.);\n    vec2 dx = 2.*wind(p*0.1, iTime);\n    \n    for(int i = 0; i < H; i++)\n    {\n        vec2 pos = p + (d+dx)*(float(i) - float(H)/2.);  \n        \n        float k = float(i)/float(H); //the depth\n      \n        vec3 c = texture(iChannel0, pos/R).xyz; //color\n       \n        float alpha = tanh(0.025*length(c)); //transparency\n     \n        float B = 0.3*k*k*k; //brightness\n        col = mix(col, vec4(B*c, alpha), alpha); //blend\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Output to screen\n    vec2 delta = (fragCoord - iMouse.xy)/R.x;\n    float r = length(delta);\n    delta = -3.*normalize(delta)*atan(6.*r); // point of view stuff\n    \n    \n   \t\n    fragColor = tanh(2.5*vec4(0.6, 0.44, 0.44, 1.)*fur(2.*fragCoord, delta));\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//generate the fur base texture\n\n\n#define center R*0.5\n#define L 1.\n#define P 50.\nvec3 fur_level(vec2 p, vec2 s)\n{\n    vec2 dx = center - p;\n    float f = perlin(dx + s).x;\n    return vec3(f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //idk random stuff\n    vec3 f = vec3(0.);\n    vec3 d = vec3(0., 0., 1.);\n    for(int i = 0; i < 4; i++)\n    {\n        f += smoothstep(0.1, 1., fur_level(d.z*fragCoord + d.xy, vec2(i)*1e3));\n        d = vec3(d.x,d.y,0.3)*d + vec3(2.64, 1.5446, 0.);\n    }\n    \n    fragColor = vec4(f*f, 1.);\n}", "buffer_a_inputs": [], "common_code": "\n#define R iResolution.xy\n#define PI 3.14159265\n\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec2 perlin(vec2 p)\n{\n   vec2 pi = floor(p);\n   vec2 pf = p - pi;\n   vec2 pfc = 0.5 - 0.5*cos(pf*PI);\n   vec2 a = vec2(0.,1.);\n   \n   vec2 a00 = hash22(pi+a.xx);\n   vec2 a01 = hash22(pi+a.xy);\n   vec2 a10 = hash22(pi+a.yx);\n   vec2 a11 = hash22(pi+a.yy);\n   \n   vec2 i1 = mix(a00, a01, pfc.y);\n   vec2 i2 = mix(a10, a11, pfc.y);\n   \n   return mix(i1, i2, pfc.x);\n}\n\nvec2 dir(float x)\n{\n    return vec2(cos(x), sin(x));\n}\n\nvec2 wind(vec2 p, float t)\n{\n    t*=15.;\n    \n    vec2 dx = 0.07*dir(dot(p, vec2(0.4, 0.7)) + t) + \n           0.04*dir(dot(p, vec2(0.8, -0.5)) + 0.625*t)+\n           0.005*dir(dot(p, vec2(-3., 0.7)) + 3.14*t)+\n           0.04*dir(dot(p, vec2(-0.6, -0.3)) + 1.133*t)+\n           0.26*dir(dot(p, vec2(0.1, 0.11)) + 0.431*t)+\n           0.35*dir(dot(p, vec2(-0.12, 0.1)) + 0.256*t);\n    return 0.6*dx;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlBcRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[625, 625, 682, 707, 945]], "test": "untested"}
{"id": "wlSyRz", "name": "Stretching colors", "author": "Leria", "description": "Stretching my previous shader ! Only rotation possible, no animation\nStretching is done line 85\n\nInspired by memory strecthed  from @FabriceNeyret2 : https://www.shadertoy.com/view/wtfcz2", "tags": ["noise", "volume", "color", "colour", "aurora", "nebulae", "stretch"], "likes": 4, "viewed": 456, "published": 3, "date": "1593556614", "time_retrieved": "2024-07-30T20:58:17.975492", "image_code": "//Free for any use, just let my name appears\n\n//You can upgrade the code to sync the sound with the moving volume\n//inspired from https://www.shadertoy.com/view/wtfcz2\n\n#define PI \t\t\t\t\t3.1415926\n#define RADIUS\t\t\t\t8.0\n#define GRAV_CONST\t\t\t6.674\n#define THICK\t\t\t\t2.\n\n#define ALPHA \t\t\t\t20.\n#define COLOR\t\t\t\t1   \n\n//Set High definition to 1 for more details (sort of LOD) else 0 :\n#define HIGH_DEF\t\t\t1\n\nstruct Ray\n{\n    vec3 origin; //origin\n    vec3 dir; //direction of the ray\n};\n\nstruct Camera\n{\n \tvec3 pos; //position\n    vec3 target; //focal point = target point\n    vec3 forward;\n    vec3 right;\n    vec3 up;\n    \n    mat4 view;\n};\n\nstruct Matter\n{\n    vec3 pos; //position\n    vec3 disk_normal;\n    float mass; //Matter mass\n    float attraction_radius; //attraction radius of the Matter\n    float inner_radius; //inner radius\n    float accretion_disk_radius; //accretion disk\n};\n\n///////////////////////////////////////////////\nMatter m;\nCamera cam;\n///////////////////////////////////////////////\n\nvec3 I = vec3(1., 0., 0.); \t//x axis\nvec3 J = vec3(0., 1., 0.);\t//y axis\nvec3 K = vec3(0., 0., 1.);\t// z axis\n\n\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\n/////////////////////\n\n#define Bnoise(x) abs(noise(x))\n\nvec3 stretching  = vec3( 1. , 1., pow( 1.4, -5. ) );\n\nfloat fbm( vec3 p ) { // in [-1,1]\n    float f;\n    \n    p *= stretching;\n    \n    f  = 0.5000*noise( p ); p = p*2.;\n    #if HIGH_DEF\n    f += 0.2500*noise( p ); p = p*2.;\n    f += 0.1250*noise( p ); p = p*2.;\n    f += 0.0625*noise( p );\n    #endif\n    return f;\n}\n\n/* Transparency */\nfloat current_transparency(float dist, float material_coef, float density)\n{\n   return exp(-dist*material_coef*density); \n}\n\nfloat current_opacity(float t)\n{\n \treturn 1.-t;   \n}\n\nvec3 current_opacity(vec3 rgb_o)\n{\n \treturn 1.-rgb_o; \n}\n#define transp current_transparency\n///////////////////////////\n\n\n//Transformations\n\n//translation\n\nmat4 translate(vec3 k)\n{\n    mat4 mat = mat4(\n        vec4(1., vec3(0.)),\n        vec4(0., 1., vec2(0.)), \n        vec4(vec2(0.), 1., 0.),\n        vec4(k, 1.) );\n    \n    return mat;\n}\n\nmat2 rot2(float angle) {\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2( c, -s, s, c);\n}\n\n//rotation around the x axis\nmat3 rotateX(float degree)\n{\n    float rad = PI*degree/180.;\n \tmat3 rot = mat3(1., 0., 0.,\n                    0., cos(rad), -sin(rad),\n                    0., sin(rad), cos(rad));\n    return rot;\n}\n\n//rotation axis-angle\nmat4 rotation_matrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n#define ROT rotation_matrix\n\n//end of rotation\n\nvec3 ray_interpolation(Ray r, float t) \n{\n \treturn (r.origin + r.dir*t);   \n}\n\nvoid set_black_hole(vec3 pos, float mass,\n                         float radius, float inner_rad, \n                         float disk_rad)\n{\n \tm = Matter(pos, J, mass, radius, inner_rad, disk_rad);\n}\n\nfloat sdf_sphere(vec3 pXp0, float radius)\n{\n    return (length(pXp0) - (radius));\n}\n\n//gravity stuff\nvoid space_time_bending(inout Ray r, inout vec3 p, float k)\n{    \n\n    vec3 m_vec = m.pos - p;\n    float d = dot(m_vec,m_vec);\n    vec3 res = normalize(m_vec) * (GRAV_CONST*m.mass)/(d);\n        \n    d = min(.92, d);\n    r.dir = normalize(r.dir + k*res);\n}\n\nvoid init_black_hole(void)\n{\n \tset_black_hole(vec3(0., 0., 0.), .12, RADIUS, RADIUS/8., RADIUS);\n}\n\nvoid set_camera(vec3 pos, vec3 target)\n{\n    cam.pos = pos;\n    cam.target = target;\n    cam.forward = normalize(pos-target);\n    cam.right = cross(normalize(vec3(0., 1., 0.)), cam.forward);\n    cam.up = cross(cam.forward, cam.right);\n        \n    cam.view = mat4(vec4(cam.right, 0.), vec4(cam.up, 0.), vec4(cam.forward, 0.), vec4(1.) );\n    \n}\n\nvoid init_camera(void)\n{\n    init_black_hole();\n    set_camera(vec3(0., 0., 12), m.pos); \n}\n\nfloat intersect_plane(Ray r, vec3 p0, vec3 n)\n{\n\treturn -dot((p0-r.origin), n)/dot(r.dir, n);    \n}\n\nbool intersect_disk(Ray r, vec3 disk_origin, vec3 norm, float radius, out vec3 p)\n{\n    float t = intersect_plane(r, disk_origin, norm);\n    p = ray_interpolation(r, t);\n    return (distance(p, disk_origin) <= (radius));\n}\n\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/(baba);\n}\n\n\nvoid ray_march_scene(Ray r, float k, inout vec3 c)\n{\n    float uniform_step = k;\n    \n    float jit = 1.;\n    //jit = fract(1e4*sin(1e4*dot(r.dir, vec3(1., 7.1, 13.3))));\n    vec3 p = ray_interpolation(r, k*jit);       \n    \n\n    float perturbation = fbm(p);\n  \tfloat dens = perturbation;\n    \n    //rgb transparency               \n    \n    vec3 t_acc = vec3(0.);\t// accumulated parameters for transparency\n    float t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.)) ), 0., 1.)  ) );\n    float t_gen = 1.;\n\n    int s = 0;\n    \n    for(s; s < 150; s++)\n    {       \n        float dist_dist = dot(p-cam.pos, p-cam.pos);\n        float dist_center = length(m.pos-cam.pos);\n        vec3 center = p-m.pos;\n\n        //if too far, then big step        \n        float d = length(center)-RADIUS-.5;\n\n        if(d > -.5)\n        k = max(d,uniform_step);\n        else\n        {\n            k = uniform_step;\n        }        \t\n        \n        if(length(center)-RADIUS < 0.)\n        {\n            \n            #if COLOR           \n            float n = ( abs(fbm( (p/8.) ) ));\n            \n            \n            float mask = smoothstep(0., \n                                    2.*RADIUS,\n                                    (RADIUS-length(center))- 128.*n) ;\n\n            \n            //Optical density/depth : dens for density\n            float dens = ( clamp( mask,\n                                 0., \n                                 1.)  );\n            \n            //How colors (rgb) are absorbed at the point p in the current iteration\n            //k is the step size\n            //4*cos(p.) is a property that defines the quantity of color which is absorbed\n            //cos(p.) is to make the non-uniform color varying effect not the animation\n            vec3 rgb_t = vec3(\n                \t\tk * 4.* cos(p.x) * dens, \n                      \tk * 4.* cos(p.y) * dens,\n              \t      \tk * 4.* cos(p.z) * dens);  \n            \n            t_acc += rgb_t;\n\n\n            #else\n            t_gen *= t_loc;\n            t_loc = transp(uniform_step, 14., ( clamp(smoothstep(.2, 3.*RADIUS+anim_coef, (RADIUS-length(p))) - abs( 2.*(fbm(p/8.*anim_coef)) ), 0., 1.)  ) );\n\t\t\t#endif\n        }\n\n        //if it will never be in the shape anymore, return;\n        \n        if(length(p-cam.pos) >(dist_center+m.accretion_disk_radius))\n        {\n         \tbreak;\n        }\n        \n        p += r.dir*k;\n        k = uniform_step;\n    }\n    \n\n    //c =float(s)/vec3(50,150,20); return;\n\n    #if COLOR\n    c = exp(-t_acc);\n    #else\n    c = vec3(t_gen); return;\n    #endif\n}\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    init_camera();\n    \n    vec2 uv = (2.0*(fragCoord)-iResolution.xy)/iResolution.y;\n    \n    float degree = 2.*PI * iMouse.x/iResolution.x - PI;\n\tfloat degree2 = 2.*PI * iMouse.y/iResolution.y - PI;\n    \n    vec3 color = vec3(1.);\n    vec3 ray_dir = vec3(uv, -1.);\n\n    m.pos = normalize(vec3(-10, 20., m.pos.z));\n    \n    vec2 m = 2.*PI * iMouse.xy/iResolution.xy - PI;\n    vec3 C = cam.pos, R = normalize(ray_dir);\n    C.xz *= rot2(m.x); C.yz *= rot2(m.y);\n    R.xz *= rot2(m.x); R.yz *= rot2(m.y);\n    \n    ray_march_scene(Ray(C, normalize(R)), .1, color);  \n        \n    fragColor = vec4(color, 1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlSyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[1115, 1115, 1172, 1172, 1341], [1344, 1344, 1370, 1370, 2195], [2306, 2306, 2327, 2340, 2570], [2572, 2591, 2667, 2667, 2714], [2716, 2716, 2748, 2748, 2768], [2770, 2770, 2804, 2804, 2826], [2927, 2927, 2951, 2951, 3111], [3113, 3113, 3137, 3137, 3222], [3224, 3253, 3281, 3281, 3451], [3453, 3475, 3521, 3521, 4144], [4194, 4194, 4235, 4235, 4271], [4273, 4273, 4414, 4414, 4473], [4475, 4475, 4518, 4518, 4558], [4560, 4576, 4637, 4637, 4831], [4833, 4833, 4861, 4861, 4931], [4933, 4933, 4973, 4973, 5277], [5279, 5279, 5303, 5303, 5370], [5372, 5372, 5419, 5419, 5471], [5473, 5473, 5556, 5556, 5695], [5698, 5698, 5751, 5751, 6108], [6111, 6111, 6163, 6163, 8734], [8737, 8737, 8794, 8794, 9402]], "test": "untested"}
{"id": "tlSyRz", "name": "Wobbly fractal tunnel", "author": "jarble", "description": "This fractal surface is generated using trigonometric functions at several different scales.", "tags": ["3d", "raymarching", "fractal"], "likes": 1, "viewed": 299, "published": 3, "date": "1593556211", "time_retrieved": "2024-07-30T20:58:18.883065", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.01;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p){\n    vec3 p1 = p/size;\n    p1 += cos(p1+vec3(iTime));\n    p = sin(vec3(sin(p1.x)/p1.x,cos(p1.y/2.0),sin(p1.z/4.0)+p1.z))*size;\n    return length(p) - size;\n}\n\nfloat sceneSDF(vec3 p) {\n    p /= scale;\n    float result = planet_surface(p);\n    for(float i = .1; i < 100.0; i *= 10.0){\n    \tresult = max(result, planet_surface(p*i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result*scale;\n}\n\nvec3 surface_color(vec3 p)\n{\n    return sin(vec3(sceneSDF(p+vec3(1.0)),sceneSDF(p+vec3(2.0)),sceneSDF(p+vec3(3.0))))/2.0+vec3(.4);\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON*(1.0+dist)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    //vec3 light2Pos = vec3(2.0 * sin(0.37),\n    //                      2.0 * cos(0.37),\n    //                      2.0);\n    //vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    //color += phongContribForLight(k_d, k_s, alpha, p, eye,\n    //                              light2Pos,\n    //                              light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = -rayDirection(45.0, iResolution.xy, fragCoord);\n    float speed = 10.0;\n    vec3 eye = scale*vec3(0.0,1.0,50.0)*size;\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tlSyRz.jpg", "access": "api", "license": "CC-BY-NC-SA-3.0", "functions": [[518, 518, 547, 547, 704], [706, 706, 730, 730, 976], [978, 978, 1006, 1006, 1110], [1112, 1533, 1624, 1624, 1941], [1956, 2210, 2275, 2275, 2407], [2409, 2498, 2527, 2527, 2837], [2839, 3331, 3471, 3471, 4081], [4083, 4453, 4538, 4538, 5300], [5302, 5629, 5678, 5713, 5844], [5846, 5846, 5903, 5903, 6814]], "test": "untested"}
